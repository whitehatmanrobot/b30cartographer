DataBlock() -
 *
 * Returns:
 *    # of bytes written to the output file
 *
 * NOTE: Write saves the name of a temp file in the clipboard for it's
 * own internal clipboard format.  This file goes aways when Write
 * (or windows?) shuts down.  Thus saving Write clipboards won't work
 * (should we special case hack this?)
 *
 */
DWORD WriteDataBlock(
register HANDLE hFile,
DWORD offset,
WORD Format)
{
WORD            wPalEntries;
LPSTR           lpData;
DWORD           dwSize = 0;
BITMAP          bitmap;
HANDLE          hMF;
HANDLE          hBitmap;
HANDLE          hLogPalette;
register HANDLE hData;
LPLOGPALETTE    lpLogPalette;
LPMETAFILEPICT  lpMFP;
DWORD           dwMFPSize;
BOOL            fOK = FALSE;

if (!(hData = GetClipboardData(Format)) ||
    SetFilePointer(hFile, offset, NULL, FILE_BEGIN) != offset)
   {
   PERROR(TEXT("WriteDataBlock: couldn't get format data\n\r"));
   }
else
   {

   /* We have to special case a few common formats but most things
    * get handled in the default case.
    */
   switch (Format)
      {
   case CF_ENHMETAFILE:
      dwSize = (DWORD) GetEnhMetaFileBits(hData, 0, NULL); /* Get data size */

      if (lpData = GlobalAllocPtr(GHND, dwSize))   /* allocate mem for EMF bits */
         {
         if (GetEnhMetaFileBits(hData, dwSize, (LPBYTE)lpData))
            {
            WriteFile(hFile, lpData, dwSize, &dwSize, NULL);
            fOK = TRUE;
            }
         GlobalFreePtr(lpData);
         }

      if (!fOK)
         {
         PERROR(TEXT("WriteDataBlock: couldn't write CF_ENHMETAFILE\r\n"));
         dwSize = 0;
         }
      break;

   case CF_METAFILEPICT:
      if (lpMFP = (LPMETAFILEPICT)GlobalLock(hData)) /* get header */
         {
         // Write METAFILEPICT header -- if we're saving in Win31 format,
         // write the old-style header.
         if (fNTSaveFileFormat)
            {
            WriteFile(hFile, lpMFP, sizeof(METAFILEPICT),
                &dwMFPSize, NULL);
            }
         else
            {
            WIN31METAFILEPICT w31mfp;
            /* If we save the metafile in the Windows 3.1 .CLP file format
               we have to save the METAFILEPICT structure as a 16bit METAFILEPICT
               structure. This may cause loss of information if the
               high half of the METAFILEPICT structure's fields are used.
               [pierrej 5/27/92]                                        */

            w31mfp.mm = lpMFP->mm;
            w31mfp.xExt = lpMFP->xExt;
            w31mfp.yExt = lpMFP->yExt;
            w31mfp.hMF  = 0;

            WriteFile(hFile, &w31mfp, sizeof(WIN31METAFILEPICT),
                &dwMFPSize, NULL);
            }

         hMF = lpMFP->hMF;

         GlobalUnlock(hData);            /* unlock the header */

         /* Figure out how big a block we need */
         dwSize = GetMetaFileBitsEx(hMF, 0, NULL);
         if (dwSize)
            {
            if (lpData = GlobalAllocPtr(GHND, dwSize))
               {
               if (dwSize == GetMetaFileBitsEx(hMF, dwSize, lpData))
                  {
                  WriteFile(hFile, lpData, dwSize,
                       &dwSize, NULL);

                  dwSize += dwMFPSize;
                  }
               else
                  {
                  dwSize = 0;
                  }

               GlobalFreePtr(lpData);
               }
            else
               {
               dwSize = 0;
               }
            }
         }
      break;

   case CF_BITMAP:
      /* Writing DDBs to disk is bad. Therefore, we */
      /* write an intelligent CF_DIB block instead.    */
      /* A-MGATES 9/29/92                              */

      Format = CF_DIB;

      GetObject((HBITMAP)hData, sizeof(BITMAP), &bitmap);

      if (hBitmap = DibFromBitmap((HBITMAP)hData, BI_RGB,
               bitmap.bmBitsPixel * bitmap.bmPlanes,
               IsClipboardFormatAvailable(CF_PALETTE) ?
                  GetClipboardData(CF_PALETTE) : NULL))
         {
         if (lpData = GlobalLock(hBitmap))
            {
            // dwSize might be too big, but we can live with that.
            dwSize = GlobalSize(lpData);

            WriteFile(hFile, lpData, dwSize,
                &dwSize, NULL);

            // Clean up
            GlobalUnlock(hBitmap);
            GlobalFree(hBitmap);
            }
         }
      break;

   case CF_PALETTE:
      /* Get the number of palette entries */
      GetObject(hData, sizeof(WORD), (LPBYTE)&wPalEntries);

      /* Allocate enough place to build the LOGPALETTE struct */
      dwSize = (DWORD)(sizeof(LOGPALETTE) +
           (LONG)wPalEntries * sizeof(PALETTEENTRY));
      if (lpLogPalette = (LPLOGPALETTE)GlobalAllocPtr(GHND, dwSize))
         {
         lpLogPalette->palVersion = 0x300;      /* Windows 3.00 */
         lpLogPalette->palNumEntries = wPalEntries;

         if (GetPaletteEntries(hData, 0, wPalEntries,
            (LPPALETTEENTRY)(lpLogPalette->palPalEntry)) != 0)
            {
            /* Write the LOGPALETTE structure onto disk */
            WriteFile(hFile, lpLogPalette, dwSize, &dwSize, NULL);
            }
         else
            {
            dwSize = 0;
            }

         GlobalFreePtr(lpLogPalette);
         }
      else
         {
         dwSize = 0L;
         }
      break;

   default:
      dwSize = GlobalSize(hData);

      // Just lock the data down and write it out.
      if (lpData = GlobalLock(hData))
         {
         WriteFile(hFile, lpData, dwSize, &dwSize, NULL);
         GlobalUnlock(hData);
         }
      else
         {
         dwSize = 0;
         }

      break;
      }
   }

/* Return the number of bytes written. */
return(dwSize);
}


/*--------------------------------------------------------------------------*/
/*                               */
/*  SendOwnerMessage() -                      */
/*                               */
/*--------------------------------------------------------------------------*/
void SendOwnerMessage(
UINT message,
WPARAM wParam,
LPARAM lParam)
{
register HWND hwndOwner;

/* Send a message to the clipboard owner, if there is one */
hwndOwner = GetClipboardOwner();

if (hwndOwner != NULL)
    SendMessage(hwndOwner, message, wParam, lParam);
}


/*--------------------------------------------------------------------------*/
/*                               */
/*  GetClipboardNameW() -                      */
/*                               */
/*--------------------------------------------------------------------------*/
void GetClipboardNameW(
register int fmt,
LPWSTR wszName,
register int iSize)
{
LPWSTR  lprgch;
HANDLE  hrgch;

*wszName = '\0';

/* Get global memory that everyone can get to */
if (hrgch = GlobalAlloc(GMEM_MOVEABLE, (LONG)(iSize + 1)*sizeof(WCHAR)))
   {
   if ((lprgch = (LPWSTR)GlobalLock(hrgch)))
      {
      memset(lprgch, 0, (iSize+1)*sizeof(WCHAR));

      switch (fmt)
         {
      case CF_RIFF:
      case CF_WAVE:
      case CF_PENDATA:
      case CF_SYLK:
      case CF_DIF:
      case CF_TIFF:
      case CF_TEXT:
      case CF_BITMAP:
      case CF_METAFILEPICT:
      case CF_ENHMETAFILE:
      case CF_OEMTEXT:
      case CF_DIB:
      case CF_PALETTE:
      case CF_DSPTEXT:
      case CF_DSPBITMAP:
      case CF_DSPMETAFILEPICT:
      case CF_DSPENHMETAFILE:
         LoadStringW(hInst, fmt, lprgch, iSize);
         break;

      case CF_OWNERDISPLAY:         /* Clipbrd owner app supplies name */
         // Note: This should NEVER happen because this function only gets
         // called when we're writing a given clipboard format. Clipbrd can't
         // get away with writing CF_OWNERDISPLAY because we become clipboard
         // owner when we re-read the file, and we won't know how to deal.
         PERROR(TEXT("GetClipboardName on OwnerDisplay format!\r\n"));

         // *lprgch = '\0';
         // SendOwnerMessageW(WM_ASKCBFORMATNAME, iSize, (LPARAM)lprgch);

         // if (!*lprgch)
             LoadStringW(hInst, fmt, lprgch, iSize);
         break;

      default:
         GetClipboardFormatNameW(fmt, lprgch, iSize);
         break;
         }
      lstrcpyW(wszName, lprgch);

      GlobalUnlock(hrgch);
      }
   else
      {
      PERROR(TEXT("GetClipboardNameW: bad lock\r\n"));
      }
   GlobalFree(hrgch);
   }
else
   {
   PERROR(TEXT("GetClipboardNameW: bad alloc\r\n"));
   }
}

extern PSECURITY_DESCRIPTOR CurrentUserOnlySD(void);

/*
 *  SaveClipboardData() - Writes a clipboard file.
 *
 * In:
 *    hwnd        handle of wnd that becomes the clipboard owner
 *    szFileName  file handle to read from
 *    fPage       TRUE if this is a clipbook page (which means we secure it)
 *
 * NOTE:
 *    When done we call ReadClipboardFromFile(). this makes us the
 *    clipboard owner.
 */
BOOL SaveClipboardData(
HWND   hwnd,
LPTSTR szFileName,
BOOL   fPage)
{
register HANDLE  fh;
register WORD   Format;
DWORD     HeaderPos;
DWORD     DataPos;
DWORD     datasize;
BOOL      fComplain = TRUE;
HCURSOR   hCursor;
FILEHEADER FileHeader;
// Must be WCHAR... it be format name!
WCHAR     wszName[CCHFMTNAMEMAX];
UINT      wHeaderSize;
UINT      uiSizeHeaderToWrite;
BOOL      fDIBUsed = FALSE;
DWORD     dwQuaker100PercentNatural; // What I was eating when I created this meaningless temp variable
SECURITY_ATTRIBUTES sa;
PSECURITY_DESCRIPTOR pSDUser;


/* First open the clipboard */
if (SyncOpenClipboard(hwndServer))
   {
   sa.nLength = sizeof(sa);
   sa.lpSecurityDescriptor = (fPage ? CurrentUserOnlySD() : NULL);
   sa.bInheritHandle = FALSE;

   fh = CreateFile((LPCTSTR)szFileName, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
              &sa, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

   if (sa.lpSecurityDescriptor)
      {
      GlobalFree((HGLOBAL)sa.lpSecurityDescriptor);
      }

   if (fh != INVALID_HANDLE_VALUE)
      {
      /* Fill out the file header structure */
      if (fNTSaveFileFormat)
         {
         FileHeader.magic = CLPBK_NT_ID;          /* magic number to tag our files */
         uiSizeHeaderToWrite = sizeof(FORMATHEADER);
         }
      else
         {
         FileHeader.magic = CLP_ID;          /* magic number to tag our files */
         uiSizeHeaderToWrite = sizeof(OLDFORMATHEADER);
         }
      FileHeader.FormatCount = 0;          /* dummy for now */

      /* Update HeaderPos and DataPos */
      HeaderPos = sizeof(FILEHEADER);

      /* This is the maximum number of formats that will be written.  Potentially
       * some may fail and some space will be wasted.
       */
      if (fNTSaveFileFormat)
         {
         DataPos = HeaderPos + (uiSizeHeaderToWrite *
               CountClipboardFormats());
         }
      else
         {
         DataPos = HeaderPos + (uiSizeHeaderToWrite *
               Count16BitClipboardFormats());
         }

      /* Now loop throught the data, one format at a time, and write out the data. */
      hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
      ShowCursor(TRUE);
      fComplain = FALSE;

      /* Enumerate all formats */
      Format = 0;
      while (Format = EnumClipboardFormats(Format))
         {
         if (IsWriteable(Format))
             {
             // DO NOT write CF_BITMAP to disk. Transform to CF_DIB
             // and write that instead.
             if (CF_BITMAP == Format || CF_DIB == Format)
                {
                if (!fDIBUsed)
                   {
                   fDIBUsed = TRUE;
                   }
                // If I've already done DIB, go on to the next format.
                else continue;
                }

             GetClipboardNameW(Format == CF_BITMAP ? CF_DIB : Format,
                   wszName, sizeof(wszName));

             PINFO(TEXT("SClipboardData: writing %ls (#)%d\r\n"),
                  wszName,Format);

             if (datasize = WriteDataBlock(fh, DataPos, Format))
                {
                /* Create a Format header and write it to the file */
                wHeaderSize = (WORD)WriteFormatBlock(
                     fh,
                     HeaderPos,
                     DataPos, datasize,
                     Format == CF_BITMAP ? CF_DIB : Format,
                     wszName);

                if (wHeaderSize < uiSizeHeaderToWrite)
                   {
                   PERROR(TEXT("SaveClipboardData: error writing format block\n\r"));
                   fComplain = TRUE;
                   break;
                   }
                HeaderPos += wHeaderSize;

                /* Update the data pos for the next block */
                DataPos += datasize;

                FileHeader.FormatCount++;   /* this format has been written */
                }
             else
                {
                PERROR(TEXT("SaveClipboardData: error writing data block\n\r"));
                fComplain = TRUE;
                break;
                }
             }
          }

      ShowCursor(FALSE);
      SetCursor(hCursor);

      SyncCloseClipboard();      /* we are done looking at this */

      // Go back and write the file header at the front of the file
      SetFilePointer(fh, 0L, NULL, FILE_BEGIN);
      WriteFile(fh, &FileHeader, sizeof(FileHeader),
           &dwQuaker100PercentNatural, NULL);

      /* Now we open the clipboard and become the owner.  this places
       * all the things we just saved in the clipboard (and throws out
       * those things we didn't save)
       */

      // Set us back to the beginning
      SetFilePointer(fh, 0L, NULL, FILE_BEGIN);

      /* Under NT, the save filename will be used to get the file back */
      lstrcpy(szSaveFileName, szFileName);

      PINFO(TEXT("sAVEcLIPBOARDdATA: Copied name %s to name %s\r\n"),
            szSaveFileName, szFileName);
      fNTReadFileFormat = fNTSaveFileFormat;

      if (!fComplain)
         {
         fComplain = ReadClipboardFromFile(hwndServer, fh);
         }

      CloseHandle(fh);

      if (fComplain)
         {
         PERROR(TEXT("SCD: Trouble in ReadClipboardFromFile\r\n"));
         DeleteFile(szFileName);
         }
      }
   else
      {
      PERROR ("Error opening clipboard file!\r\n");
      GetLastError();
      }
   SyncCloseClipboard();
   }
return !fComplain;
}

/*
 *  SaveClipboardToFile() -
 *    Parameters:
 *       hwnd - Passed to SaveClipboardData
 *       szShareName - Clipbook page name
 *       szFileName  - Filename to save to
 *       fPage - TRUE if this is a clbook page, FALSE if a file saved
 *          by the user.
 *
 *    Returns: TRUE on success, FALSE on failure.
 *
 */
BOOL SaveClipboardToFile(
HWND hwnd,
TCHAR *szShareName,
TCHAR *szFileName,
BOOL  fPage)
{

PINFO(TEXT("\r\n Entering SaveClipboardToFile\r\n"));
if (fPage)
   {
   AddNetInfoToClipboard( szShareName );
   AddPreviewFormat();
   }

if (!SaveClipboardData(hwnd, szFileName, fPage))
   {
   /* If Failure, Delete the incomplete file */
   PERROR(TEXT("SaveClipboardData failed!"));
   DeleteFile(szSaveFileName);
   return FALSE;
   }
return TRUE;
}


BOOL AddPreviewFormat (
VOID)
{
HANDLE hClpData, hBmpData;
HBITMAP hBitmap, hClpBmp, hOldDstBmp, hOldSrcBmp;
LPMETAFILEPICT lpMF;
BITMAP Bitmap;
HDC hDC, hDstDC, hSrcDC;
LPBYTE lpClpData, lpBmp;
int ret = FALSE;
RECT rc;
int OldMode;

if (IsClipboardFormatAvailable(CF_TEXT)         ||
    IsClipboardFormatAvailable(CF_BITMAP)       ||
    IsClipboardFormatAvailable(CF_METAFILEPICT) ||
    IsClipboardFormatAvailable(CF_ENHMETAFILE)  ||
    IsClipboardFormatAvailable(CF_UNICODETEXT)  )
   {
   if ( !SyncOpenClipboard(hwndServer))
      return FALSE;

   if ( !(hBmpData = GlobalAlloc ( GHND, 64 * 64 / 8 )) )
      {
      SyncCloseClipboard();
      return FALSE;
      }

   hDC = GetDC ( hwndServer );
   hDstDC = CreateCompatibleDC ( hDC );
   hSrcDC = CreateCompatibleDC ( hDC );
   ReleaseDC ( hwndServer, hDC );

   if ( !( hBitmap = CreateBitmap ( 64, 64, 1, 1, NULL )) )
      PERROR (TEXT("CreateBitmap failed\n\r"));

   hOldDstBmp = SelectObject ( hDstDC, hBitmap );

   rc.top = rc.left = 0;
   rc.bottom = rc.right = 64;

   PatBlt ( hDstDC, 0, 0, 64, 64, WHITENESS );

   if (IsClipboardFormatAvailable(CF_ENHMETAFILE))
      {
      HENHMETAFILE hemf;
      ENHMETAHEADER enheader;

      if (hemf = (HENHMETAFILE)GetClipboardData(CF_ENHMETAFILE))
         {
         GetEnhMetaFileHeader(hemf, sizeof(enheader), &enheader);

         SaveDC(hDstDC);
         SetMapMode( hDstDC, MM_ISOTROPIC);
         SetViewportExtEx(hDstDC, 64, 64, NULL);
         SetWindowExtEx(hDstDC, enheader.rclBounds.right, enheader.rclBounds.bottom, NULL);
         PlayEnhMetaFile(hDstDC, hemf, (LPRECT)&enheader.rclBounds);
         RestoreDC(hDstDC, -1);
         }
      else
         {
         PERROR(TEXT("GetClipboardData fail on CF_ENHMETAFILE\r\n"));
         }
      }
   else if ( IsClipboardFormatAvailable ( CF_METAFILEPICT ))
      {
      if ( hClpData = GetClipboardData ( CF_METAFILEPICT ))
         {
         if ( lpMF = (LPMETAFILEPICT)GlobalLock ( hClpData ) )
            {
            SaveDC(hDstDC);
            SetMapMode( hDstDC, lpMF->mm);
            if ( lpMF->xExt >= lpMF->yExt )
               {
               SetViewportExtEx( hDstDC, 64,
                  (int)((64L*(LONG)lpMF->yExt)/(LONG)lpMF->xExt), NULL);
               SetViewportOrgEx ( hDstDC, 0,
                  (64 - (int)((64L*(LONG)lpMF->yExt)/(LONG)lpMF->xExt))
                  / 2, NULL );
               }
            else
               {
               SetViewportExtEx( hDstDC,
                  (int)((64L*(LONG)lpMF->xExt)/(LONG)lpMF->yExt),64, NULL);
               SetViewportOrgEx( hDstDC,
                  ( 64 - (int)((64L*(LONG)lpMF->xExt)/(LONG)lpMF->yExt))
                  / 2, 0, NULL);
               }
            if ( !PlayMetaFile ( hDstDC, lpMF->hMF ))
               PERROR(TEXT("playmetafile failed\n\r"));
            GlobalUnlock ( hClpData );
            RestoreDC( hDstDC, -1 );
            }
         else
            PERROR(TEXT("couldn't LOCK it though...\n\r"));
         }
      else
         PERROR(TEXT("couldn't GET it though...\n\r"));
      }
   else if ( IsClipboardFormatAvailable ( CF_BITMAP ))
      {
      if ( hClpBmp = GetClipboardData ( CF_BITMAP ))
         {
         GetObject ( hClpBmp, sizeof(BITMAP), &Bitmap );
         hOldSrcBmp = SelectObject ( hSrcDC, hClpBmp );
         OldMode = SetStretchBltMode ( hDstDC, COLORONCOLOR);
         StretchBlt ( hDstDC, 0, 0, 64, 64,
                  hSrcDC, 0, 0, Bitmap.bmWidth, Bitmap.bmHeight,
                  SRCCOPY );
         SetStretchBltMode ( hDstDC, OldMode );
         SelectObject ( hSrcDC, hOldSrcBmp );
         }
      }
   else if ( IsClipboardFormatAvailable ( CF_TEXT ))
      {
      LPSTR lpText;
      HFONT hSmallFont, hOldFont;

      if ( hClpData = GetClipboardData ( CF_TEXT ))
         {
         lpText = (LPSTR)GlobalLock ( hClpData );
         FillRect ( hDstDC, &rc, GetStockObject ( WHITE_BRUSH ) );
         hSmallFont = CreateFont( -6,
            0, 0, 0, 400, 0, 0, 0, ANSI_CHARSET, OUT_DEFAULT_PRECIS,
            CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
            VARIABLE_PITCH | FF_SWISS, TEXT("Small Fonts")
            );
         hOldFont = SelectObject ( hDstDC, hSmallFont );
         DrawTextA( hDstDC,lpText, lstrlenA(lpText),
            &rc, DT_LEFT);
         SelectObject ( hDstDC, hOldFont );
         DeleteObject ( hSmallFont );
         GlobalUnlock ( hClpData );
         }
      }
   else if ( IsClipboardFormatAvailable (CF_UNICODETEXT))
      {
      LPWSTR lpText;
      HFONT hSmallFont, hOldFont;

      if ( hClpData = GetClipboardData ( CF_UNICODETEXT ))
         {
         lpText = (LPWSTR)GlobalLock ( hClpData );
         FillRect ( hDstDC, &rc, GetStockObject ( WHITE_BRUSH ) );
         hSmallFont = CreateFont( -6,
            0, 0, 0, 400, 0, 0, 0, ANSI_CHARSET, OUT_DEFAULT_PRECIS,
            CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
            VARIABLE_PITCH | FF_SWISS, TEXT("Small Fonts")
            );
         hOldFont = SelectObject ( hDstDC, hSmallFont );
         DrawTextW( hDstDC,lpText, lstrlenW(lpText),
            &rc, DT_LEFT);
         SelectObject ( hDstDC, hOldFont );
         DeleteObject ( hSmallFont );
         GlobalUnlock ( hClpData );
         }
      }

   SelectObject ( hDstDC, hOldDstBmp );
   DeleteDC ( hDstDC );
   DeleteDC ( hSrcDC );

   lpBmp = GlobalLock ( hBmpData );

   if ( GetBitmapBits ( hBitmap, 64 * 64 / 8, lpBmp ) != 64*64/8 )
//      if ( GetBitmapBits ( hBitmap, 64 * 64 / 2, lpBmp ) != 64*64/2 )
      PERROR(TEXT("GetBitmapBits failed\n\r"));

   GlobalUnlock ( hBmpData );

   SetClipboardData ( cf_preview, hBmpData );
   ret = TRUE;

   DeleteObject ( hBitmap );
   SyncCloseClipboard();
   }
return ret;
}

BOOL AddCopiedFormat (
UINT ufmtOriginal,
UINT ufmtCopy )
{
LPBYTE lpOriginal, lpCopy;
HANDLE hOriginal, hCopy = NULL;
BOOL ret = FALSE;
int i;


if (IsClipboardFormatAvailable(ufmtOriginal) && SyncOpenClipboard(hwndServer)) {
   if ( hOriginal = GetClipboardData(ufmtOriginal)) {
      if ( hCopy = GlobalAlloc( GHND, GlobalSize(hOriginal))) {
         if ( lpOriginal = GlobalLock(hOriginal)) {
            if ( lpCopy = GlobalLock (hCopy)) {
               for ( i=(int)GlobalSize(hOriginal); i--; )
                  *lpCopy++ = *lpOriginal++;
               GlobalUnlock(hCopy);
#ifdef DEBUG
               lpCopy = GlobalLock(hCopy);
               GlobalUnlock(hCopy);
#endif
               ret = ( SetClipboardData ( ufmtCopy, hCopy ) != NULL );
            }
            GlobalUnlock(hOriginal);
         }
      }
   }
   SyncCloseClipboard();
}
if ( !ret ) {
   PERROR(TEXT("AddCopiedFormat returning FALSE!\n\r"));
   if ( hCopy )
      GlobalFree ( hCopy );
}
return ret;
}


BOOL AddNetInfoToClipboard (
TCHAR *szShareName )
{
HANDLE hData, hNewData;
TCHAR szServerName[MAX_COMPUTERNAME_LENGTH + 1];
DWORD dwNameLen;
LPTSTR src,dst;

cf_link = RegisterClipboardFormat ( SZLINK );
cf_objectlink = RegisterClipboardFormat ( SZOBJECTLINK );
cf_linkcopy = RegisterClipboardFormat ( SZLINKCOPY );
cf_objectlinkcopy = RegisterClipboardFormat ( SZOBJECTLINKCOPY );

// check to see if this info already added:
if ( IsClipboardFormatAvailable ( cf_linkcopy ) )
   {
   PINFO(TEXT("AddNetInfo: Already added\n\r"));
   return FALSE;
   }
else if ( IsClipboardFormatAvailable ( cf_link ) )
   {
   AddCopiedFormat ( cf_link, cf_linkcopy );

   if (!SyncOpenClipboard(hwndServer))
      return(FALSE);

   dwNameLen = MAX_COMPUTERNAME_LENGTH+1;
   GetComputerName(szServerName, &dwNameLen);

   PINFO(TEXT("link data found\n\r"));
   hData = GetClipboardData ( cf_link );

   src = GlobalLock ( hData );

   hNewData = GlobalAlloc ( GMEM_MOVEABLE | GMEM_ZEROINIT,
      GlobalSize( hData )
      + lstrlen ( szServerName ) + lstrlen(szShareName) + 3 );

   dst = GlobalLock ( hNewData );

   wsprintf( dst, TEXT("\\\\%s\\%s"), szServerName, TEXT("NDDE$")  );
   dst += lstrlen(dst) + 1;

   lstrcpy ( dst, szShareName );
   *dst = SHR_CHAR;
   lstrcat ( dst, TEXT(".dde") );
   // lstrcat ( dst, TEXT(".ole") );
   dst += lstrlen(dst) + 1;

   src += lstrlen(src) + 1;
   src += lstrlen(src) + 1;

   lstrcpy ( dst, src );

   GlobalUnlock ( hData );
   GlobalUnlock ( hNewData );

   SetClipboardData ( cf_link, hNewData );
   SyncCloseClipboard();
   }

if ( IsClipboardFormatAvailable ( cf_objectlink ) )
   {
   AddCopiedFormat ( cf_objectlink, cf_objectlinkcopy );

   if (!SyncOpenClipboard(hwndServer))
      return(FALSE);

   dwNameLen = MAX_COMPUTERNAME_LENGTH+1;
   GetComputerName(szServerName, &dwNameLen);

   PINFO(TEXT("objectlink data found\n\r"));
   hData = GetClipboardData ( cf_objectlink );

   src = GlobalLock ( hData );

   hNewData = GlobalAlloc ( GMEM_MOVEABLE | GMEM_ZEROINIT,
      GlobalSize( hData )
      + lstrlen(szServerName) + lstrlen(szShareName) + 3 );

   dst = GlobalLock ( hNewData );

   wsprintf( dst, TEXT("\\\\%s\\%s"), szServerName, TEXT("NDDE$")  );
   dst += lstrlen(dst) + 1;

   lstrcpy ( dst, szShareName );
   *dst = SHR_CHAR;
   lstrcat ( dst, TEXT(".ole") );
   dst += lstrlen(dst) + 1;

   src += lstrlen(src) + 1;
   src += lstrlen(src) + 1;

   lstrcpy ( dst, src );

   GlobalUnlock ( hData );
   GlobalUnlock ( hNewData );

   SetClipboardData ( cf_objectlink, hNewData );
   SyncCloseClipboard();
   }
return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\datasrv\clipshr.h ===
#ifndef _WINDOWS_
#include <windows.h>
#endif

#ifndef _INC_COMMDLG
#include <commdlg.h>
#endif

// added for winball - clausgi
extern UINT cf_link;
extern UINT cf_objectlink;
extern UINT cf_linkcopy;
extern UINT cf_objectlinkcopy;

// end additions

#define PRIVATE_FORMAT(fmt)	((fmt) >= 0xC000)

/* Header text string ids */
#define IDS_NAME            100  /* CF_TEXT to CF_OEMTEXT (1 to 7) are also used */
#define IDS_OVERWRITE	    101
#define IDS_ERROR           102  /* as string ids.  Be sure to keep these    */
#define IDS_BINARY          103  /* different.                               */
#define IDS_CLEAR	          104
#define IDS_FMTNOTSAV       105
#define IDS_DEFAULT         106
#define IDS_CANTDISPLAY     107  /* "Can't display data in this format" */
#define IDS_NOTRENDERED     108  /* "Application Couldn't render data"  */
#define IDS_HELPFILE        109  /* Clipbrd.hlp */
#define IDS_ALREADYOPEN     112  /* OpenClipboard() fails */
#define IDS_INVALIDFILENAME 113  /* Filename is invalid */
#define IDS_OPENCAPTION     114  /* ID of File/Open dlg. caption string */
#define IDS_SAVECAPTION     115  /* ID of File/Save dlg. caption string */
#define IDS_FILTERTEXT      116  /* ID of filter string for File/Open	*/
#define IDS_ALLFILES        117  /* ID of filter string for All Files	*/
#define IDS_MEMERROR        118

#define IDS_READERR 	    200  /* ID of base ReadClipboardFile error */
#define IDS_READFORMATERR   201
#define IDS_READOPENCLIPERR 202

/* Dialogbox resource id */
#define ABOUTBOX        1
#define CONFIRMBOX	2

/* Other constants */
#define CDEFFMTS        8       /* Count of predifined clipboard formats    */
#define VPOSLAST        100     /* Highest vert scroll bar value */
#define HPOSLAST        100     /* Highest horiz scroll bar value */
#define CCHFMTNAMEMAX   79      /* Longest clipboard data fmt name, including
                                   terminator */
#define cLineAlwaysShow 3       /* # of "standard text height" lines to show
                                   when maximally scrolled down */
#define BUFFERLEN       160      /* String buffer length */
#define SMALLBUFFERLEN  90
#define IDSABOUT        1

#define CBMENU		1	/* Number for the Clipboard main menu  */

#define FILTERMAX   100		/* max len. of File/Open filter string */
#define CAPTIONMAX  30		/* len of caption text for above dlg.  */
#define PATHMAX     128 	/* max. len of DOS pathname	       */

/* The menu ids */
#define CBM_AUTO        WM_USER
#define CBM_CLEAR       WM_USER+1
#define CBM_OPEN        WM_USER+2
#define CBM_SAVEAS      WM_USER+3
#define CBM_ABOUT       WM_USER+4
#define CBM_EXIT        WM_USER+5

// winball add-ons

#define CBM_SHAREAS		WM_USER+6
#define	CBM_IMPORT		WM_USER+7

// end winball add-ons

#define CBM_HELP	0xFFFF	 /* Standard numbers */
#define CBM_USEHELP     0xFFFC   /* Standard numbers */
#define CBM_SEARCH	0x0021

/*  Last parameter to SetDIBits() and GetDIBits() calls */

#define  DIB_RGB_COLORS   0
#define  DIB_PAL_COLORS	  1

#define  IDCLEAR 	IDOK

/* Structures for saving/loading clipboard data from disk */

#define      CLP_ID  0xC350
#define   CLP_NT_ID  0xC351
#define CLPBK_NT_ID  0xC352

typedef struct
   {
   WORD        magic;
   WORD        FormatCount;
   } FILEHEADER;


// Format header
typedef struct
   {
   DWORD FormatID;
   DWORD DataLen;
   DWORD DataOffset;
   WCHAR  Name[CCHFMTNAMEMAX];
   } FORMATHEADER;

// Windows 3.1-type structures - Win31 packed on byte boundaries.
#pragma pack(1)
typedef struct
   {
   WORD FormatID;
   DWORD DataLen;
   DWORD DataOffset;
   char Name[CCHFMTNAMEMAX];
   } OLDFORMATHEADER;

// Windows 3.1 BITMAP struct - used to save Win 3.1 .CLP files
typedef struct {
   WORD bmType;
   WORD bmWidth;
   WORD bmHeight;
   WORD bmWidthBytes;
   BYTE bmPlanes;
   BYTE bmBitsPixel;
   LPVOID bmBits;
   } WIN31BITMAP;

// Windows 3.1 METAFILEPICT struct
typedef struct {
   WORD mm;
   WORD xExt;
   WORD yExt;
   WORD hMF;
   } WIN31METAFILEPICT;

#pragma pack()


BOOL NEAR PASCAL OpenClipboardFile( HWND, LPTSTR );
void NEAR PASCAL GetClipboardName(int fmt, LPTSTR szName, int iSize);
BOOL ReadFormatHeader(HANDLE, FORMATHEADER *,unsigned);
unsigned ReadFileHeader(HANDLE);

LONG FAR PASCAL ClipbrdWndProc(HWND, WORD, WORD, LONG);
BOOL FAR PASCAL ConfirmDlgProc(HWND, WORD, WORD, LONG);

// Clipboard open/close with synchronization
BOOL SyncOpenClipboard(HWND);
BOOL SyncCloseClipboard(void);

/* Far low mem situations. */
void FAR PASCAL MemErrorMessage(void);


/*****************************  global data  *******************************/
// extern OFSTRUCT	ofStruct;
extern HWND  hwndMain;
extern TCHAR szAppName[];
extern TCHAR szFileSpecifier[];

/* variables for the new File Open,File SaveAs and Find Text dialogs */

extern TCHAR  szSaveFileName [];
extern TCHAR  szLastDir  [];
extern TCHAR  szFilterSpec [];    /* default filter spec. for above	 */
extern int    wHlpMsg;            /* message used to invoke Help	 */
extern TCHAR  szOpenCaption [];   /* File open dialog caption text	 */
extern TCHAR  szSaveCaption [];   /* File Save as dialog caption text  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\datasrv\clipsrv.h ===
#ifndef _INC_DDEMLH
#include <ddeml.h>
#endif

#ifndef _INC_NDDEAPI
#include <nddeapi.h>
#endif



#define	CACHEFORMATLIST
#define	CACHEPREVIEWS

#define MAX_TOPIC       64
#define MAX_COMMENT     100
#define MAX_EXEC        MAX_DDE_EXEC

#define MAX_CLIPSHARES  127
#define MAX_CLPSHRNAME  MAX_NDDESHARENAME
#define MAX_FILEPATH    MAX_PATH



// shrinfotag flags

#define	SIF_SHARED	0x1


struct ShrInfotag
        {
        WCHAR       szFileName[MAX_FILEPATH];  // no extension
        WCHAR       szName[MAX_CLPSHRNAME+1];
        HSZ         hszName;
        WORD        flags;
        #ifdef CACHEFORMATLIST
         HDDEDATA   hFormatList;
        #endif
        #ifdef CACHEPREVIEWS
         HDDEDATA   hPreviewBmp;
        #endif
        struct ShrInfotag *Next;
        };

typedef struct ShrInfotag ShrInfo;
typedef ShrInfo *pShrInfo;




extern pShrInfo SIHead;






// GLOBALS


extern  DWORD       idInst;
extern  HINSTANCE   hInst;
extern  HWND        hwndApp;
extern  HSZ         hszAppName;
extern  TCHAR       szTopic[MAX_TOPIC];
extern  TCHAR       szServer[MAX_TOPIC];
extern  TCHAR       szExec[MAX_EXEC];

extern  UINT        cf_preview;
extern  ShrInfo     *SIHead;

extern  TCHAR       szUpdateName[MAX_CLPSHRNAME+1];





// FUNCTIONS

void ClipSrvMain(
    DWORD   argc,
    LPSTR   *argv);


BOOL InitApplication(
    HINSTANCE,
    SERVICE_STATUS *);


LRESULT FAR PASCAL MainWndProc(
    HWND,
    UINT,
    WPARAM,
    LPARAM);


HDDEDATA EXPENTRY DdeCallback(
    WORD        wType,
    WORD        wFmt,
    HCONV       hConv,
    HSZ         hszTopic,
    HSZ         hszItem,
    HDDEDATA    hData,
    DWORD      lData1,
    DWORD      lData2);


void Hszize(void);

void UnHszize(void);


HDDEDATA RenderRawFormatToDDE(
    FORMATHEADER    *pfmthdr,
    HANDLE          fh);




// Resource ID
#define IDI_CLIPSRV 1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\datasrv\clipsrv.c ===
#include    <windows.h>
#include    <windowsx.h>
#include    <stdarg.h>
#include    "common.h"
#include    "clipsrv.h"
#include    "clipfile.h"
#include    "callback.h"
#include    "debugout.h"







static HANDLE   hmutexClp;      // for syncing open and close of clipboard

static BOOL     fAnythingToRender = FALSE;
static BOOL     fService = TRUE;
static BOOL     fServiceStopped = FALSE;
static TCHAR    szClass[] = TEXT("ClipSrvWClass");
static TCHAR    szServiceName[] = TEXT("Clipbook Service");

static TCHAR    wsbuf[128];




DWORD           idInst = 0;
HINSTANCE       hInst;
HWND            hwndApp;
HSZ             hszAppName = 0L;
TCHAR           szTopic[MAX_TOPIC] = TEXT("ClipData");
TCHAR           szServer[MAX_TOPIC] = TEXT("ClipSrv");
TCHAR           szExec[MAX_EXEC] = TEXT("");

TCHAR           szUpdateName[MAX_CLPSHRNAME+1] = TEXT("");


UINT            cf_preview;
ShrInfo         *SIHead = NULL;






// Service status stuff
static SERVICE_STATUS_HANDLE hService;
static SERVICE_STATUS srvstatus =
   {
   SERVICE_WIN32_OWN_PROCESS,
   SERVICE_START_PENDING,
   SERVICE_ACCEPT_STOP,
   NO_ERROR,
   0L,
   1,
   200
   };



#if DEBUG
HKEY hkeyRoot;
HKEY hkeyClp;
#endif



void ClipSrvHandler (DWORD);







/////////////////////////////////////////////////////////////////////////
//
// "main" function... just calls StartServiceCtrlDispatcher.
//
//
/////////////////////////////////////////////////////////////////////////



/*
 *      main
 */

void _cdecl main(
    int     argc,
    char    **argv)
{
SERVICE_TABLE_ENTRY srvtabl[] = {{szServiceName, ClipSrvMain},
                                 {NULL,          NULL}};




#if DEBUG
    DeleteFile("C:\\CLIPSRV.OUT");
#endif


    if (argv[1] && !lstrcmpi(argv[1], "-debug"))
        {
        fService = FALSE;
        ClipSrvMain(argc, argv);
        }
    else
        {
        StartServiceCtrlDispatcher(srvtabl);
        }
}





/*
 *      ClipSrvMain
 */

void ClipSrvMain(
    DWORD   argc,
    LPSTR   *argv)
{
MSG msg;

    if (fService)
        {
        hService = RegisterServiceCtrlHandler(szServiceName, ClipSrvHandler);
        }


    if (0L != hService || FALSE == fService)
        {
        if (fService)
            {
            // Tell SCM that we're starting
            SetServiceStatus(hService, &srvstatus);
            }

        hInst = GetModuleHandle(TEXT("CLIPSRV.EXE"));

        // Perform initializations
        if (InitApplication(hInst, &srvstatus))
            {
            if (fService)
               {
               // Tell SCM we've started OK
               srvstatus.dwCurrentState = SERVICE_RUNNING;
               SetServiceStatus(hService, &srvstatus);

               PINFO(TEXT("Told system we're running\r\n"));
               }

            // Process messages
            while (GetMessage(&msg, NULL, 0, 0))
               {
               TranslateMessage(&msg);
               DispatchMessage(&msg);
               }

            UnregisterClass(szClass, hInst);

            if (fService && !fServiceStopped)
               {
               fServiceStopped = TRUE;
               srvstatus.dwCurrentState = SERVICE_STOPPED;
               SetServiceStatus(hService, &srvstatus);
               }

            if (NULL != hmutexClp)
               {
               CloseHandle(hmutexClp);
               }
            }
        else
            {
            PERROR(TEXT("ClSrv: InitApplication failed!\r\n"));
            if (fService && !fServiceStopped)
                {
                fServiceStopped = TRUE;
                srvstatus.dwCurrentState = SERVICE_STOPPED;
                SetServiceStatus(hService, &srvstatus);
                }
            }
        }
}








/*
 *      ReportStatusToSDMgr
 *
 *  This function is called by the ServMainFunc() and
 *  by the ServCtrlHandler() to update the service's status
 *  to the Service Control Manager.
 */

BOOL ReportStatusToSCMgr (
    DWORD   dwCurrentState,
    DWORD   dwWin32ExitCode,
    DWORD   dwCheckPoint,
    DWORD   dwWaitHint)
{
BOOL fResult;


    /* disable control requests until service is started */
    if (dwCurrentState == SERVICE_START_PENDING)
        {
        srvstatus.dwControlsAccepted = 0;
        }
    else
        {
        srvstatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
        }

    /* These SERVICE_STATUS members set from parameters */

    srvstatus.dwCurrentState = dwCurrentState;
    srvstatus.dwWin32ExitCode = dwWin32ExitCode;
    srvstatus.dwCheckPoint = dwCheckPoint;

    srvstatus.dwWaitHint = dwWaitHint;

    /* Report status of service to Service Control Manager */

    if (!(fResult = SetServiceStatus(hService,&srvstatus)))
        {
        /* if error occurs, stop service */
        }

    return fResult;
}









/*
 *      ClipSrvHandler
 *
 *
 *  Purpose: Acts as the HANDLER_FUNCTION for the Clipbook service.
 *
 *  Parameters:
 *     fdwControl = Flags saying what action to take
 *
 *  Returns: Void (SetServiceStatus is used to set status)
 */

void ClipSrvHandler(
    DWORD   fdwControl)
{

    if (SERVICE_CONTROL_STOP == fdwControl)
       {
       PINFO(TEXT("Handler: stopping service\r\n"));
       srvstatus.dwCheckPoint = 0;
       srvstatus.dwCurrentState = SERVICE_STOP_PENDING;
       SetServiceStatus(hService, &srvstatus);

       SendMessage(hwndApp, WM_CLOSE, 0, 0);

       if (!fServiceStopped) {
           fServiceStopped = TRUE;
           srvstatus.dwCurrentState = SERVICE_STOPPED;
           SetServiceStatus(hService, &srvstatus);
       }
       PINFO(TEXT("Handler: Service stopped\r\n"));
       }
    else
       {
       // Unhandled control request.. just keep running.
       srvstatus.dwCurrentState = SERVICE_RUNNING;
       srvstatus.dwWin32ExitCode = NO_ERROR;
       SetServiceStatus(hService, &srvstatus);
       }
    return;

}








/*
 *      InitApplication
 *
 *
 *  Purpose: Application initialization, including creation of a window
 *     to do DDE with, getting settings out of the registry, and starting
 *     up DDE.
 *
 *  Parameters:
 *     hInstance - Application instance.
 *     psrvstatus - Pointer to a SERVICE_STATUS struct. We update the
 *           dwCheckPoint member of this struct and call SetServiceStatus,
 *           so the system knows that we didn't die.
 *
 *  Returns: True on OK, false on fail.
 */

BOOL InitApplication(
    HINSTANCE       hInstance,
    SERVICE_STATUS  *psrvstatus)
{
WNDCLASS        wc;
#if DEBUG
DWORD           dwKeyStatus;
#endif
HWINSTA hwinsta;

    // lpDdeI = CreateDDEShare(szServer, TEXT(SZDDESYS_TOPIC), NULL);
    //
    // if (NULL != lpDdeI)
    //    {
    //    GlobalFreePtr(lpDdeI);
    //    }
    // else
    //    {
    //    PERROR(TEXT("Couldn't create DDE share for ClipSrv!\r\n"));
    //    }


    wc.style = 0L;
    wc.lpfnWndProc = MainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_CLIPSRV));
    wc.hCursor = NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName = NULL;
    wc.lpszClassName = TEXT("ClipSrvWClass");

    if (!RegisterClass(&wc))
       {
       PERROR(TEXT("Couldn't register wclass\r\n"));
       return FALSE;
       }

  /*
   * We are now connected to the appropriate service windowstation
   * and desktop. In order to get stuff from clipbook, we need to
   * switch our process over to use the interactive user's
   * clipboard.  Verify that we have access to do this.
   */
  hwinsta = OpenWindowStation("WinSta0", FALSE,
          WINSTA_ACCESSCLIPBOARD | WINSTA_ACCESSGLOBALATOMS);
  if (hwinsta == NULL) {
      PERROR(TEXT("Couldn't open windowstation WinSta0\r\n"));
      return FALSE;
  }

  SetProcessWindowStation(hwinsta);



    psrvstatus->dwCheckPoint++;

    hmutexClp = CreateMutex(NULL, FALSE, SZMUTEXCLP);

    hwndApp = CreateWindow(TEXT("ClipSrvWClass"),
                              TEXT("Hidden Data Server"),
                              WS_POPUP,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              400,
                              200,
                              NULL,
                              NULL,
                              hInstance,
                              NULL
                              );



    if (!hwndApp)
       {
       PERROR(TEXT("No window created\r\n"));
       return FALSE;
       }


    psrvstatus->dwCheckPoint++;


    #if DEBUG
    if (ERROR_SUCCESS != RegCreateKeyEx (HKEY_CURRENT_USER,
                                         szClipviewRoot,
                                         0L,
                                         szRegClass,
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_QUERY_VALUE, NULL,
                                         &hkeyClp,
                                         &dwKeyStatus)
         &&

        ERROR_SUCCESS != RegOpenKeyEx   (HKEY_CURRENT_USER,
                                         szClipviewRoot,
                                         0,
                                         KEY_QUERY_VALUE,
                                         &hkeyClp))
        {
        DebugLevel = 2;
        PINFO(TEXT("Clipsrv: Could not get root key\r\n"));
        }
    else
        {
        DWORD iSize = sizeof(DebugLevel);

        RegQueryValueEx (hkeyClp,
                         szDebug,
                         NULL,
                         NULL,
                         (LPBYTE)&DebugLevel,
                         &iSize);

        RegCloseKey (hkeyClp);
        }

    if (DebugLevel > 0)
        {
        ShowWindow(hwndApp, SW_SHOWMINNOACTIVE );
        }
    #endif


    if (DdeInitialize ((LPDWORD)&idInst,
                       (PFNCALLBACK)DdeCallback,
                       APPCMD_FILTERINITS,
                       0L))
        {
        PERROR(TEXT("Couldn't initialize DDE\r\n"));
        return FALSE;
        }



    PINFO(TEXT("DdeInit OK...\r\n"));
    psrvstatus->dwCheckPoint++;
    if (fService)
        {
        SetServiceStatus(hService, psrvstatus);
        }

    Hszize();
    DdeNameService(idInst, hszAppName, 0L, DNS_REGISTER);

    InitShares();

    return TRUE;

}










/*
 *      MainWndProc
 */

LRESULT CALLBACK MainWndProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam)
{

    switch (message)
        {
        case WM_CREATE:
            fAnythingToRender = FALSE;
            cf_preview = RegisterClipboardFormat (SZPREVNAME);

            if (fService)
                {
                // Let the SCP that started us know that we're making progress
                srvstatus.dwCheckPoint++;
                SetServiceStatus(hService, &srvstatus);
                }

            PINFO(TEXT("Creating ClSrv window\r\n"));
            break;

        case WM_DESTROYCLIPBOARD:
            /* Prevent unnecessary file I/O when getting a WM_RENDERALLFORMATS */
            fAnythingToRender = FALSE;
            break;

        case WM_RENDERALLFORMATS:
            PINFO(TEXT("ClSrv\\WM_RNDRALL rcvd\r\n"));
            return (LRESULT)RenderAllFromFile(szSaveFileName);
            break;

        case WM_RENDERFORMAT:
            SetClipboardData((UINT)wParam, RenderFormatFromFile(szSaveFileName, (WORD)wParam));
            break;

        case WM_QUERYOPEN:
            return FALSE;

        case WM_DESTROY:
            PINFO(TEXT("sTOPPING...\r\n"));
            CleanUpShares();
            DdeNameService(idInst, 0L, 0L, DNS_UNREGISTER);
            UnHszize();
            DdeUninitialize(idInst);

            if (fService)
                {
                // Tell SCP we're stopping
                srvstatus.dwCheckPoint++;
                SetServiceStatus(hService, &srvstatus);
                }
            PostQuitMessage(0);
            break;

        default:
            return (DefWindowProc(hwnd, message, wParam, lParam));
        }

    return 0L;

}







/*
 *      RenderRawFormatToDDE
 *
 *  CLAUSGI - don't setClipboardData - just return the handle...
 */

HDDEDATA RenderRawFormatToDDE(
    FORMATHEADER    *pfmthdr,
    HANDLE          fh )
{
HDDEDATA   hDDE;
LPBYTE     lpDDE;
DWORD      cbData;
DWORD      dwBytesRead;
BOOL       fPrivate = FALSE, fMetafile = FALSE, fBitmap = FALSE;


    PINFO(TEXT("ClSrv\\RndrRawFmtToDDE:"));

    // Note that complex-data formats are sent under a private
    // format instead.

    if (PRIVATE_FORMAT(pfmthdr->FormatID )
       || pfmthdr->FormatID == CF_BITMAP
       || pfmthdr->FormatID == CF_METAFILEPICT
       || pfmthdr->FormatID == CF_PALETTE
       || pfmthdr->FormatID == CF_DIB
       || pfmthdr->FormatID == CF_ENHMETAFILE
       )
       {
       fPrivate = TRUE;
       if (pfmthdr->FormatID == CF_BITMAP)
          {
          fBitmap = TRUE;
          }
       else if (pfmthdr->FormatID == CF_METAFILEPICT)
          {
          fMetafile = TRUE;
          }
       pfmthdr->FormatID = RegisterClipboardFormatW(pfmthdr->Name);
       }


    PINFO(TEXT("rendering format %ws as %x\n\r"), (LPTSTR)pfmthdr->Name, pfmthdr->FormatID );

    #ifdef CACHEPREVIEWS
    if ( pfmthdr->FormatID == cf_preview )
       PINFO(TEXT("making APPOWNED data\n\r"));
    #endif




    if (!(hDDE = DdeCreateDataHandle (idInst,
                                      NULL,
                                      pfmthdr->DataLen,
                                      0L,
                                      hszAppName,
                                      pfmthdr->FormatID,
                                      #ifdef CACHEPREVIEWS
                                       pfmthdr->FormatID == cf_preview ? HDATA_APPOWNED : 0
                                      #else
                                       0
                                      #endif
                                      )))
        {
        PERROR(TEXT("Couldn't createdata handle\r\n"));
        goto done;
        }




    if ( !(lpDDE = DdeAccessData ( hDDE, &cbData )) )
       {
        PERROR(TEXT("Couldn't access handle\r\n"));
        DdeFreeDataHandle(hDDE);
        hDDE = 0L;
        goto done;
        }




    if (~0 == SetFilePointer(fh, pfmthdr->DataOffset, NULL, FILE_BEGIN))
        {
        PERROR(TEXT("Couldn't set file pointer\r\n"));
        DdeUnaccessData(hDDE);
        DdeFreeDataHandle(hDDE);
        hDDE = 0L;
        goto done;
        }


    ReadFile(fh, lpDDE, pfmthdr->DataLen, &dwBytesRead, NULL);

    if (dwBytesRead != pfmthdr->DataLen)
       {
       // Error in reading the file
       DdeUnaccessData(hDDE);
       DdeFreeDataHandle(hDDE);
       PERROR(TEXT("Error reading file: %ld from lread\n\r"),
         dwBytesRead);
       hDDE =  0L;
       goto done;
       }


    // REARCHITECT This code packs CF_METAFILEPICT and CF_BITMAP
    // structs to WFW-type structs. It may lose extents for
    // very large bitmaps and metafiles when going from NT to NT.
    // Main symptom would be "Moved a metafile across clipbook and
    // it suddenly grew way outside its bounds".
    if (fMetafile)
       {
       WIN31METAFILEPICT w31mfp;
       unsigned uNewSize;
       HDDEDATA hDDETmp;

       uNewSize = pfmthdr->DataLen + sizeof(WIN31METAFILEPICT) -
                   sizeof(METAFILEPICT);

       // Have to make a smaller data handle now
       hDDETmp = hDDE;
       hDDE = DdeCreateDataHandle(idInst, NULL,  uNewSize, 0L,
             hszAppName, pfmthdr->FormatID, 0);

       w31mfp.mm   = (WORD)((METAFILEPICT *)lpDDE)->mm;
       w31mfp.xExt = (WORD)((METAFILEPICT *)lpDDE)->xExt;
       w31mfp.yExt = (WORD)((METAFILEPICT *)lpDDE)->yExt;

       // Place oldmetafilepict and data in new DDE block
       DdeAddData(hDDE, (LPTSTR)&w31mfp, sizeof(WIN31METAFILEPICT), 0L);
       DdeAddData(hDDE, lpDDE + sizeof(METAFILEPICT),
             uNewSize - sizeof(WIN31METAFILEPICT),
             sizeof(WIN31METAFILEPICT));

       // Drop old handle
       DdeUnaccessData(hDDETmp);
       DdeFreeDataHandle(hDDETmp);

       // We came in with hDDE accessed
       lpDDE = DdeAccessData(hDDE, &cbData);
       }
    else if (fBitmap)
       {
       WIN31BITMAP w31bm;
       unsigned uNewSize;
       HDDEDATA hDDETmp;

       uNewSize = pfmthdr->DataLen + sizeof(WIN31BITMAP) -
                 sizeof(BITMAP);

       // Have to make a smaller data handle now
       hDDETmp = hDDE;
       hDDE = DdeCreateDataHandle(idInst, NULL,  uNewSize, 0L,
             hszAppName, pfmthdr->FormatID, 0);

       w31bm.bmType       = (WORD)((BITMAP *)lpDDE)->bmType;
       w31bm.bmWidth      = (WORD)((BITMAP *)lpDDE)->bmWidth;
       w31bm.bmHeight     = (WORD)((BITMAP *)lpDDE)->bmHeight;
       w31bm.bmWidthBytes = (WORD)((BITMAP *)lpDDE)->bmWidthBytes;
       w31bm.bmPlanes     = (BYTE)((BITMAP *)lpDDE)->bmPlanes;
       w31bm.bmBitsPixel  = (BYTE)((BITMAP *)lpDDE)->bmBitsPixel;

       // Place old-style bitmap header and data in DDE block
       DdeAddData(hDDE, (LPTSTR)&w31bm, sizeof(WIN31BITMAP), 0L);
       DdeAddData(hDDE, lpDDE + sizeof(BITMAP),
             uNewSize - sizeof(WIN31BITMAP),
             sizeof(WIN31BITMAP));

       // Drop old handle
       DdeUnaccessData(hDDETmp);
       DdeFreeDataHandle(hDDETmp);

       // We came in with hDDE accessed
       lpDDE = DdeAccessData(hDDE, &cbData);
       }

    DdeUnaccessData(hDDE);



done:


    PINFO("Ret %lx\r\n", hDDE);
    return(hDDE);

}








/*
 *      SyncOpenClipboard
 */

BOOL SyncOpenClipboard(
    HWND    hwnd)
{
BOOL fOK;

    PINFO(TEXT("\r\nClipSrv: Opening Clipboard\r\n"));

    WaitForSingleObject (hmutexClp, INFINITE);
    fOK = OpenClipboard (hwnd);
    if (!fOK)
        {
        ReleaseMutex (hmutexClp);
        }

    return fOK;
}






/*
 *      SyncCloseClipboard
 */

BOOL SyncCloseClipboard(void)
{
BOOL fOK;

    PINFO(TEXT("\r\nClipSrv: Closing Clipboard\r\n"));

    fOK = CloseClipboard ();
    ReleaseMutex (hmutexClp);

    return fOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\datasrv\callback.c ===
#include    <windows.h>
#include    <nddeapi.h>
#include    <nddesec.h>
#include    <string.h>
#include    <stdio.h>
#include    <stdlib.h>
#include    <memory.h>
#include    <assert.h>
#include    <ddeml.h>

#include    "common.h"

#include    "clipsrv.h"
#include    "clipfile.h"
#include    "ddeutil.h"
#include    "callback.h"

#include    "debugout.h"






#define AUTOUPDATE
#define ASKED_FOR_LINK 1
#define ASKED_FOR_OBJECTLINK 2


#define MAX_XERR    128         // maximum number of XERRs we'll store
#define XERR_INUSE  1


typedef struct _XERR            // struct for Xaction ERRor
    {
    HCONV       hConv;          // the conversation handle
    DWORD       dwErr;          // the error code
    DWORD       dwUse;          // usage, when & with XERR_MASK gives type,
    }                           //    bit 1 is set when if struct is in use.
    XERR, *PXERR;


XERR    gXactErr[MAX_XERR];
TCHAR   gszXactErrStr[30];




TCHAR szInitShareCmd[]      = SZCMD_INITSHARE;
TCHAR szExitCmd[]           = SZCMD_EXIT;
TCHAR szPasteShareCmd[]     = SZCMD_PASTESHARE;
TCHAR szDelShareCmd[]       = SZCMD_DELETE;
TCHAR szMarkSharedCmd[]     = SZCMD_SHARE;
TCHAR szMarkUnSharedCmd[]   = SZCMD_UNSHARE;
TCHAR szKeepCmd[]           = SZCMD_PASTE;
TCHAR szSaveAsCmd[]         = SZCMD_SAVEAS;
TCHAR szSaveAsOldCmd[]      = SZCMD_SAVEASOLD;
TCHAR szOpenCmd[]           = SZCMD_OPEN;
TCHAR szDebugCmd[]          = SZCMD_DEBUG;
TCHAR szVersionCmd[]        = SZCMD_VERSION;
TCHAR szSecurityCmd[]       = SZCMD_SECURITY;
TCHAR szDebug[]             = TEXT("Debug");
TCHAR szVer[]               = TEXT("1.1"); // need to be able to
                                           // handle Uni or Ansi req's for this

TCHAR szSection[]           = TEXT("Software\\Microsoft\\Clipbook Server");
TCHAR szClipviewRoot[]      = TEXT("Software\\Microsoft\\Clipbook");
TCHAR szRegClass[]          = TEXT("Config");

HSZ hszSysTopic;
HSZ hszTopicList;
HSZ hszFormatList;
HSZ hszErrorRequest;











/*
 *      MakeTheDamnKey
 *
 *  Purpose: Open the usual key (the one named by szSection) with the
 *     specified access.
 *
 *  Parameters:
 *     phkey - Pointer to the HKEY to fill
 *     regsam - The access types, same as RegCreateKeyEx
 *
 *  Returns:
 *     ERROR_SUCCESS on success, whatever RegOpenKeyEx returns on fail.
 */

LONG MakeTheDamnKey(
    PHKEY   phkey,
    REGSAM  regsam)
{
DWORD   dwR;
DWORD   dwIck;


    dwR = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                          szSection,
                          0,
                          szRegClass,
                          REG_OPTION_NON_VOLATILE,
                          regsam,
                          NULL,
                          phkey,
                          &dwIck);

    if (dwR == ERROR_SUCCESS)
       {
       return ERROR_SUCCESS;
       }



    dwR = RegOpenKeyEx (HKEY_LOCAL_MACHINE, szSection, 0, regsam, phkey);

    if (dwR == ERROR_SUCCESS)
       {
       return ERROR_SUCCESS;
       }


    PERROR(TEXT("Couldn't regopen %s with %lx access - #%lx\r\n"), szSection, (long)regsam, dwR);

    return dwR;
    
}








/*
 *      lstrncmp
 */

int lstrncmp(
    LPTSTR  s1,
    LPTSTR  s2,
    WORD    count )
{
unsigned i;
register TCHAR tch1;
register TCHAR tch2;

    for (i = 0; i < (unsigned)count; i++)
        {
        if ( (tch1 = *s1++) != (tch2 = *s2++) )
            {
            if (tch1 < tch2)
                return -1;
            else
                return 1;
            }
        }

    return 0;

}









/*
 *      AddXactErr
 *
 *  To add a XERR record for hConv.  Called
 *  when XTYP_CONNECT_CONFIRM.
 */

static VOID    AddXactErr(
    HCONV   hConv)
{
INT i;


    for (i=0; i<MAX_XERR; i++)
        if (!gXactErr[i].dwUse & XERR_INUSE)
            {
            gXactErr[i].hConv = hConv;
            gXactErr[i].dwErr = 0;
            gXactErr[i].dwUse = XERR_INUSE;

            return;
            }

}




/*
 *      DelXactErr
 *
 *  To delete a XERR record for hConv.
 *  Called at XTYP_DISCONNECT.
 */

static VOID    DelXactErr(
    HCONV   hConv)
{
INT i;

    for (i=0; i<MAX_XERR; i++)
        if ((gXactErr[i].dwUse & XERR_INUSE) && gXactErr[i].hConv == hConv)
            {
            gXactErr[i].dwUse = 0;
            return;
            }

}




/*
 *      GetXactErr
 *
 *  Returns the XERR error code associated with hConv.
 */

DWORD   GetXactErr(
    HCONV   hConv)
{
INT i;

    for (i=0; i<MAX_XERR; i++)
        if ((gXactErr[i].dwUse & XERR_INUSE) && gXactErr[i].hConv == hConv)
            return gXactErr[i].dwErr;

    return 0L;
}






/*
 *      GetXactErrType
 *
 *  Returns the XERR error type associated with hConv.
 */

DWORD   GetXactErrType(
    HCONV   hConv)
{
INT i;

    for (i=0; i<MAX_XERR; i++)
        if ((gXactErr[i].dwUse & XERR_INUSE) && gXactErr[i].hConv == hConv)
            return gXactErr[i].dwUse & XERRT_MASK;

    return 0L;
}






/*
 *      SetXactErr
 *
 *  Sets XERR for hConv.
 *  dwType specifies type, this should be one of the XERRT_ defines.
 *  dwErr specifies error code.
 */

VOID    SetXactErr(
    HCONV   hConv,
    DWORD   dwType,
    DWORD   dwErr)
{
INT     i;

    for (i=0; i<MAX_XERR; i++)
        if ((gXactErr[i].dwUse & XERR_INUSE) && gXactErr[i].hConv == hConv)
            {
            gXactErr[i].dwErr = dwErr;
            gXactErr[i].dwUse = (gXactErr[i].dwUse & ~XERRT_MASK) | dwType;
            return;
            }

}






/*
 *      DdeCallback
 */

HDDEDATA EXPENTRY DdeCallback(
    WORD        wType,
    WORD        wFmt,
    HCONV       hConv,
    HSZ         hszTopic,
    HSZ         hszItem,
    HDDEDATA    hData,
    DWORD       lData1,
    DWORD       lData2)
{
HDDEDATA    hDDEtmp = 0L;
UINT        uiErr;



    PINFO(TEXT("\n>>>> DdeCallback\n"));

    if (!(wType & XCLASS_NOTIFICATION))
        {
        PINFO(TEXT("Impersonating\n"));
        DdeImpersonateClient(hConv);
        }



    switch ( wType )
        {
        case XTYP_CONNECT_CONFIRM:

            PINFO (TEXT("XTYP_CONNECT_CONFIRM\n"));

            AddXactErr (hConv);
            PINFO(TEXT("Confirming connect\r\n"));
            hDDEtmp = (HDDEDATA)TRUE;
            break;


        case XTYP_EXECUTE:

            PINFO (TEXT("XTYP_EXECUTE\n"));

            // no error yet

            SetXactErr (hConv, 0, 0);


            // We only take executes on the System topic.
            // And only in Unicode or CF_TEXT format.

            if ((wFmt == CF_TEXT || wFmt == CF_UNICODETEXT) &&
                DdeCmpStringHandles ( hszTopic, hszSysTopic ) )
                {
                PERROR(TEXT("XTYP_EXECUTE received on non-system topic\n\r"));
                hDDEtmp = (HDDEDATA)DDE_FNOTPROCESSED;

                break;
                }


            DdeGetData(hData, (LPBYTE)szExec, MAX_EXEC, 0);
            szExec[MAX_EXEC - 1] = '\0';


            hDDEtmp = DDE_FNOTPROCESSED;



            #if 0
            //a-mgates, 12/92. We no longer shut down when asked this way,
            //'cause we're a system service, not just part of the Clipbook app.
            if (0 == lstrncmp ( szExec, szExitCmd, (WORD)lstrlen(szExitCmd)))
                {
                DdeDisconnect ( hConv );
                PostMessage ( hwndApp, WM_CLOSE, 0, 0L );
                hDDEtmp = (HDDEDATA)DDE_FACK;
                }
            //a-mgates This is never used by NT clipbook, 'cause we have to set
            //the page up before we can set its security
            else if ( 0 == lstrncmp( szExec, szPasteShareCmd,
                (WORD)lstrlen(szPasteShareCmd )) )
                {
                PINFO(TEXT("Add/sharing %s\n\r"),
                   (LPSTR)szExec + lstrlen(szPasteShareCmd ) );

                AddShare ( szExec + lstrlen(szPasteShareCmd ), SIF_SHARED );

                hDDEtmp = (HDDEDATA)DDE_FACK;
                }
            else
            #endif


            if (!lstrcmp (szExec, szInitShareCmd))
                {
                InitShares();
                hDDEtmp = (HDDEDATA)DDE_FACK;
                }
            else if (!lstrncmp (szExec, szKeepCmd, (WORD)lstrlen(szKeepCmd)))
                {
                DWORD dwErr;

                dwErr = AddShare ( szExec + lstrlen(szKeepCmd ), 0);
                if (dwErr != NO_ERROR)
                    SetXactErr (hConv, XERRT_SYS, dwErr);
                else
                    hDDEtmp = (HDDEDATA)DDE_FACK;
                }
            else if (!lstrncmp (szExec, szVersionCmd, (WORD)lstrlen(szVersionCmd)))
                {
                hDDEtmp = DdeCreateDataHandle(idInst, szVer, sizeof(szVer) + 1, 0, 0L, wFmt, 0L);
                }
            else if (!lstrncmp( szExec, szSaveAsCmd, (WORD)lstrlen(szSaveAsCmd)))
                {
                DWORD dwErr;

                fNTSaveFileFormat = TRUE;

                dwErr = SaveClipboardToFile (hwndApp, NULL, szExec + lstrlen(szSaveAsCmd ), FALSE);
                if (dwErr != NO_ERROR)
                    SetXactErr (hConv, XERRT_SYS, dwErr);
                else
                    hDDEtmp = (HDDEDATA)DDE_FACK;
                }
            else if (!lstrncmp (szExec, szSaveAsOldCmd, (WORD)lstrlen(szSaveAsOldCmd)))
                {
                DWORD dwErr;

                fNTSaveFileFormat = FALSE;

                dwErr = SaveClipboardToFile(hwndApp, NULL, szExec + lstrlen(szSaveAsOldCmd), FALSE);
                if (dwErr != NO_ERROR)
                    SetXactErr (hConv, XERRT_SYS, dwErr);
                else
                    hDDEtmp = (HDDEDATA)DDE_FACK;
                }
            else if (!lstrncmp (szExec, szOpenCmd, (WORD)lstrlen(szOpenCmd )) )
                {
                DWORD dwErr;

                dwErr = OpenClipboardFile(hwndApp, szExec + lstrlen(szOpenCmd));
                if (dwErr != NO_ERROR)
                    SetXactErr (hConv, XERRT_SYS, dwErr);
                else
                    hDDEtmp = (HDDEDATA)DDE_FACK;
                }
            else if (!lstrncmp (szExec, szDelShareCmd, (WORD)lstrlen(szDelShareCmd)))
                {
                PINFO(TEXT("Deleting %s\n\r"), (LPSTR)szExec + lstrlen(szDelShareCmd));

                if (DelShare ( hConv, szExec + lstrlen(szDelShareCmd) ))
                    {
                    hDDEtmp = (HDDEDATA)DDE_FACK;
                    }
                }
            else if (!lstrncmp (szExec,szMarkSharedCmd, (WORD)lstrlen(szMarkSharedCmd)))
                {
                PINFO(TEXT("Marking %s as shared\n\r"), (LPSTR)szExec + lstrlen(szMarkSharedCmd));

                if ( MarkShare (szExec + lstrlen(szMarkSharedCmd), SIF_SHARED ))
                    {
                    hDDEtmp = (HDDEDATA)DDE_FACK;
                    }
                }
            else if (!lstrncmp(szExec,szMarkUnSharedCmd, (WORD)lstrlen(szMarkUnSharedCmd)))
                {
                if ( MarkShare ( szExec + lstrlen(szMarkUnSharedCmd ), 0 ))
                    {
                    hDDEtmp = (HDDEDATA)DDE_FACK;
                    }
                }

            #if DEBUG
            else if (!lstrncmp(szExec,szDebugCmd, (WORD)lstrlen(szDebugCmd)))
                {
                DumpShares();
                hDDEtmp = (HDDEDATA)DDE_FACK;
                }
            #endif
            else
                {
                PERROR(TEXT("Invalid execute\r\n"));
                hDDEtmp = (HDDEDATA)DDE_FNOTPROCESSED;
                }

            break;

        case XTYP_DISCONNECT:

            PINFO (TEXT("XTYP_DISCONNECT\n"));

            DelXactErr (hConv);
            break;

        case XTYP_CONNECT:

            PINFO (TEXT("XTYP_CONNECT\n"));

            hDDEtmp = (HDDEDATA)FALSE;

            if ( IsSupportedTopic( hszTopic ) )
                {
                if (!DdeKeepStringHandle (idInst, hszAppName))
                    {
                    PERROR(TEXT("DdeKSHandle fail in DdeCB\r\n"));
                    }
                hDDEtmp = (HDDEDATA)TRUE;
                }
            #if DEBUG
            else
                {
                TCHAR buf[128];
                DdeQueryString ( idInst, hszTopic, buf, 128, CP_WINANSI );
                PERROR(TEXT("ClipSRV: Unsupported topic %s requested\n\r"), (LPSTR)buf );
                }
            #endif

            break;


        case XTYP_ADVREQ:
        case XTYP_REQUEST:

            // must be a valid topic
            {
            TCHAR atch[128];

            PINFO (wType==XTYP_ADVREQ?
                     TEXT("XTYP_ADVREQ\n"): TEXT("XTYP_REQUEST\n"));

            DdeQueryString(idInst, hszTopic, atch, 128, CP_WINANSI);
            PINFO(TEXT("Topic = %s, "), atch);
            DdeQueryString(idInst, hszItem, atch, 128, CP_WINANSI);
            PINFO(TEXT("item = %s\r\n"), atch);
            }

            if (!IsSupportedTopic ( hszTopic ))
                {
                #if DEBUG
                TCHAR buf[128];
                DdeQueryString ( idInst, hszTopic, buf, 128, CP_WINANSI );
                PERROR(TEXT("Topic %s unsupported!\n\r"), (LPTSTR)buf );
                #endif

                hDDEtmp = (HDDEDATA)0;
                }
            else
                {
                PINFO("System topic request\r\n");

                if (!DdeCmpStringHandles (hszTopic, hszSysTopic))
                    {
                    if (!DdeCmpStringHandles (hszItem,  hszErrorRequest))
                        {
                        sprintf (gszXactErrStr,
                                 XERR_FORMAT,
                                 GetXactErrType (hConv),
                                 GetXactErr (hConv));

                        hDDEtmp = DdeCreateDataHandle (idInst,
                                                       gszXactErrStr,
                                                       lstrlen(gszXactErrStr)+sizeof(CHAR),
                                                       0,
                                                       hszErrorRequest,
                                                       wFmt,
                                                       0);

                        uiErr = DdeGetLastError (idInst);
                        }
                    else if (!DdeCmpStringHandles (hszItem, hszTopicList))
                        {
                        PINFO(TEXT("Topic list requested\r\n"));

                        SetXactErr (hConv, 0, 0);

                        if (CF_TEXT == wFmt)
                            {
                            hDDEtmp = (HDDEDATA)GetTopicListA(hConv, TRUE);
                            }
                        else if (CF_UNICODETEXT == wFmt)
                            {
                            hDDEtmp = (HDDEDATA)GetTopicListW(hConv, TRUE);
                            }
                        else // Can't get the topiclist in anything but CF_TEXT or UNICODE
                            {
                            PERROR(TEXT("ClSrv\\DdeCB: Client asked for topics in bad fmt\r\n"));
                            hDDEtmp = (HDDEDATA)0;
                            }
                        }
                    else
                        {
                        #if DEBUG
                        TCHAR rgtch[128];

                        DdeQueryString(idInst, hszItem,rgtch, 128, CP_WINANSI);
                        PERROR(TEXT("item %s requested under system\n\r"), rgtch);
                        #endif
                        hDDEtmp = (HDDEDATA)0;
                        }
                    }
                else
                    {
                    // all other topics are assumed clipboard shares!!!

                    // Is format list the requested item?
                    if (!DdeCmpStringHandles (hszItem,  hszErrorRequest))
                        {
                        sprintf (gszXactErrStr,
                                 XERR_FORMAT,
                                 GetXactErrType (hConv),
                                 GetXactErr (hConv));

                        hDDEtmp = DdeCreateDataHandle (idInst,
                                                       gszXactErrStr,
                                                       lstrlen(gszXactErrStr)+sizeof(CHAR),
                                                       0,
                                                       hszErrorRequest,
                                                       wFmt,
                                                       0);

                        uiErr = DdeGetLastError (idInst);
                        }
                    else if (!DdeCmpStringHandles (hszItem, hszFormatList))
                        {
                        PINFO(TEXT("Getting format list\r\n"));

                        SetXactErr (hConv, 0, 0);

                        if (CF_TEXT == wFmt)
                            {
                            hDDEtmp = (HDDEDATA)GetFormatListA(hConv, hszTopic);
                            }
                        else
                            {
                            hDDEtmp = (HDDEDATA)GetFormatListW(hConv, hszTopic);
                            }
                        }
                    else
                        {   // request for specific format, or invalid
                        SetXactErr (hConv, 0, 0);

                        hDDEtmp = GetFormat ( hConv, hszTopic, hszItem );
                        }
                    }
                }
            break;


        case XTYP_ADVSTART:

            PINFO (TEXT("XTYP_ADVSTART\n"));

            // a-mgates 12/92- Added check for system topic.
            if (0 == DdeCmpStringHandles(hszItem, hszTopicList) &&
                0 == DdeCmpStringHandles(hszTopic, hszSysTopic))
                {
                PINFO(TEXT("Advise on topiclist OK\r\n"));
                hDDEtmp = (HDDEDATA)TRUE;
                }
            else
                {
                PERROR(TEXT("Advise loop requested on item other than topiclist\n\r"));
                hDDEtmp = (HDDEDATA)FALSE;
                }
            break;

        default:

            PINFO (TEXT("unknown wType %#x\n"), wType);

            break;
        }




    if (!(wType & XCLASS_NOTIFICATION))
        {
        RevertToSelf();
        }


    if (0L == hDDEtmp)
        {
        TCHAR atch[128];

        DdeQueryString(idInst, hszTopic, atch, 128, CP_WINANSI);
        PINFO(TEXT("Topic was %s, "), atch);
        DdeQueryString(idInst, hszItem, atch, 128, CP_WINANSI);
        PINFO(TEXT("item was %s\r\n"), atch);
        }



    PINFO(TEXT("Return %#x\n"), hDDEtmp);
    PINFO(TEXT("<<<< DdeCallback\n\n"));


    return hDDEtmp;

}












/*
 *      IsSupportedTopic
 */

BOOL IsSupportedTopic ( HSZ hszTopic )
{
pShrInfo p;

    if ( !DdeCmpStringHandles (hszTopic, hszSysTopic))
        {
        DdeKeepStringHandle ( idInst, hszTopic );
        return TRUE;
        }

    for ( p = SIHead; p; p = p->Next )
        {
        if (!DdeCmpStringHandles (hszTopic, p->hszName))
            return TRUE;
        }

    return FALSE;

}







/*
 *      CleanUpShares
 */

BOOL CleanUpShares ( VOID )
{
pShrInfo p, tmp;

    for (p=SIHead; p; p=tmp)
        {
        DdeFreeStringHandle ( idInst, p->hszName );

        #ifdef CACHEFORMATLIST
        PINFO(TEXT("freeing cached format list\n\r"));
        if ( p->hFormatList )
            DdeFreeDataHandle ( p->hFormatList );
        #endif

        #ifdef CACHEPREVIEWS
        PINFO(TEXT("freeing cached preview bitmap\n\r"));
        if ( p->hPreviewBmp )
            DdeFreeDataHandle ( p->hPreviewBmp );
        #endif

        tmp = p->Next;
        LocalFree ((HLOCAL) p );
        }


    SIHead = NULL;

    return TRUE;

}








/*
 *      CheckPageName
 *
 *  Check to see if the page name saved is
 *  a real DDE share.
 */

BOOL    CheckPageName (
    LPTSTR  ComputerName,
    LPTSTR  Name)
{
TCHAR   cTmp;
BOOL    bRet = FALSE;
UINT    uiRet;
DWORD   dwSize;
WORD    wItem;


    cTmp = Name[0];
    Name[0] = SHR_CHAR;

    wItem = 0;
    uiRet = NDdeShareGetInfo (ComputerName,
                              Name,
                              2,
                              NULL,
                              0,
                              &dwSize,
                              &wItem);

    Name[0] = cTmp;



    // No error if:
    //  1. no error
    //  2. buffer is too small; the share exists
    //  3. no access; share exists but we still need to
    //     let the user to see it on the list.


    if (uiRet == NDDE_NO_ERROR ||
        uiRet == NDDE_BUF_TOO_SMALL ||
        uiRet == NDDE_ACCESS_DENIED)
        return TRUE;
    else
        return FALSE;

}







/*
 *      InitShares
 */

BOOL InitShares (VOID)
{
TCHAR   szComputerName[MAX_COMPUTERNAME_LENGTH+3];
TCHAR   rgtchPageName[MAX_CLPSHRNAME+1];
TCHAR   rgtchPageFile[MAX_FILEPATH+1];
DWORD   dwPageSize;
DWORD   dwNameSize;
DWORD   dwType;
HKEY    hkeyClp;
DWORD   dwR;

unsigned iValue = 0;
unsigned iKeys = 0;



    CleanUpShares ();



    if (ERROR_SUCCESS != MakeTheDamnKey(&hkeyClp, KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE))
        {
        PERROR(TEXT("Couldn't get to Clipbook root key\r\n"));
        return FALSE;
        }


    szComputerName[0] = szComputerName[1] = TEXT('\\');
    dwNameSize = MAX_COMPUTERNAME_LENGTH+1;
    GetComputerName (szComputerName+2, &dwNameSize);


    do  {

        dwNameSize = sizeof (rgtchPageName);
        dwPageSize = sizeof (rgtchPageFile);

        dwR = RegEnumValue (hkeyClp,
                            iValue,
                            rgtchPageName,
                            &dwNameSize,
                            NULL,
                            &dwType,
                            (LPBYTE)rgtchPageFile,
                            &dwPageSize);


        if (dwR == ERROR_SUCCESS)
            {
            rgtchPageName[dwNameSize] = 0;
            rgtchPageFile[dwPageSize] = 0;

            //if (CheckPageName (szComputerName, rgtchPageName))
            // this does not work in 548

                AddRecord (rgtchPageName,
                           rgtchPageFile,
                           (SHR_CHAR == rgtchPageName[0]) ? SIF_SHARED : 0);
            }


        iValue++;

        } while (dwR != ERROR_NO_MORE_ITEMS);




    RegCloseKey(hkeyClp);

    PINFO(TEXT("Read %d pages\r\n"),iKeys);


    return TRUE;

}








/*
 *      GetFormat
 */

HDDEDATA GetFormat (
    HCONV   hConv,
    HSZ     hszTopic,
    HSZ     hszItem )
{
HDDEDATA        hData    = 0l;
HANDLE          hClpData = NULL;
DWORD           cbData   = 0L;
pShrInfo        pshrinfo;
HANDLE          fh;
FORMATHEADER    FormatHeader;
unsigned        i;
TCHAR           szItemKey[CCHFMTNAMEMAX];
unsigned        cFormats;
BOOL            fPreviewRequested;
unsigned        fLocalAskedForLocal = 0;

#ifndef UNICODE
TCHAR           szFormatName[CCHFMTNAMEMAX * 2];
#endif




    PINFO(TEXT("Clsrv\\GetFormat:"));

    if (!DdeQueryString (idInst,hszItem,szItemKey,CCHFMTNAMEMAX,CP_WINANSI))
        {
        PERROR(TEXT("invalid item\n\r"));
        return 0;
        }




    // is the asked-for format cf_preview?
    fPreviewRequested = !lstrcmpi ( szItemKey, SZPREVNAME );



    // If the user asks for cf_link or cf_objectlink, we have to determine
    // whether they are local or not. If local, we need to give them cf_linkcopy
    // or cf_objectlinkcopy (which don't have NetDDE references).
    // if (!lstrcmpi(szItemKey, SZOBJECTLINK) && IsUserLocal(hConv))
    //    {
    //    lstrcpy(szItemKey, SZOBJECTLINKCOPY);
    //    fLocalAskedForLocal = ASKED_FOR_OBJECTLINK;
    //    }
    // else if (!lstrcmpi(szItemKey, SZLINK) && IsUserLocal(hConv))
    //    {
    //    lstrcpy(szItemKey, SZLINKCOPY);
    //    fLocalAskedForLocal = ASKED_FOR_LINK;
    //    };




    for ( pshrinfo=SIHead; pshrinfo; pshrinfo = pshrinfo->Next )
        {
        if ( DdeCmpStringHandles ( hszTopic, pshrinfo->hszName ) == 0 )
            {
            DdeKeepStringHandle ( idInst, hszTopic );

            if ( fPreviewRequested && pshrinfo->hPreviewBmp )
                {
                return pshrinfo->hPreviewBmp;
                }
            fh = CreateFileW(pshrinfo->szFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);

            if ( INVALID_HANDLE_VALUE == fh)
                {
                PERROR(TEXT("ERROR opening %ls\n\r"), pshrinfo->szFileName );
                }
            else
                {
                cFormats = ReadFileHeader(fh);

                if (0 == cFormats)
                    {
                    PERROR(TEXT("Bad .CLP file\r\n"));
                    }

                for (i=0; i < cFormats; i++)
                    {
                    ReadFormatHeader(fh, &FormatHeader, i);


                    #ifndef UNICODE
                    WideCharToMultiByte (CP_ACP,
                                         0,
                                         FormatHeader.Name,
                                         CCHFMTNAMEMAX,
                                         szFormatName,
                                         CCHFMTNAMEMAX * 2,
                                         NULL,
                                         NULL);


                    if (!lstrcmpi (szItemKey, szFormatName))
                    #else
                    if (!lstrcmpi (szItemKey, FormatHeader.Name))
                    #endif
                        {
                        // Put back the format names, if a local client asked
                        // us for objectlink or link.
                        if (ASKED_FOR_OBJECTLINK == fLocalAskedForLocal)
                            {
                            lstrcpyW(FormatHeader.Name, LSZOBJECTLINK);
                            }
                        else if (ASKED_FOR_LINK == fLocalAskedForLocal)
                            {
                            lstrcpyW(FormatHeader.Name, LSZLINK);
                            }

                        hData = RenderRawFormatToDDE(&FormatHeader, fh);

                        #ifdef CACHEPREVIEWS
                        if ( fPreviewRequested )
                            {
                            PINFO(TEXT("GetFormat: caching preview\n\r"));
                            pshrinfo->hPreviewBmp = hData;
                            }
                        #endif

                        #if DEBUG
                        if (!hData)
                            {
                            PERROR(TEXT("RenderRawFormatToDDE resulted in 0 handle\n\r"));
                            }
                        #endif
                        }
                    }
                if (!hData)
                    {
                    PERROR(TEXT("GetFormat: requested format %s not found\n\r"),
                                   (LPSTR)szItemKey );
                    }
                CloseHandle(fh);
                }
            }
        }


    PINFO("Returning %lx",hData);

    return hData;
}









/*
 *      DelShare
 *
 *  Purpose: Delete a ClipBook page.
 *
 *  Parameters:
 *     pszName - The name of the page.
 *
 *  Returns:
 *     TRUE on success, FALSE on failure.
 */

BOOL DelShare(
    HCONV   hConv,
    TCHAR   *pszName)
{
pShrInfo    pshrinfo;
pShrInfo    q;
HKEY        hkeyClp;
TCHAR       atch[MAX_COMPUTERNAME_LENGTH + 3];
DWORD       dwLen = MAX_COMPUTERNAME_LENGTH + 1;
BOOL        fOK = FALSE;
DWORD       ret;
WCHAR       rgwchT[MAX_CLPSHRNAME + 1];
TCHAR       tch;




    assert(pszName);
    assert(*pszName);

    #ifndef UNICODE
    MultiByteToWideChar(CP_ACP, 0, pszName, -1, rgwchT, MAX_CLPSHRNAME + 1);
    #else
    lstrcpy(rgwchT, pszName);
    #endif

    PINFO(TEXT("Looking for %ls\r\n"), rgwchT);

    q = NULL;


    for (pshrinfo = SIHead; pshrinfo; pshrinfo = (q = pshrinfo)->Next)
        {
        assert(pshrinfo->szName);
        PINFO(TEXT("Comparing to %ls\r\n"), pshrinfo->szName);

        if (!lstrcmpW(pshrinfo->szName, rgwchT))
            {

            // Delete the Network DDE share for this item -- this also makes

            atch[0] = atch[1] = TEXT('\\');
            dwLen = MAX_COMPUTERNAME_LENGTH +1;

            GetComputerName(atch+2, &dwLen);
            tch = pszName[0];
            pszName[0] = SHR_CHAR;


            PINFO(TEXT("Deleting share %s on %s\r\n"), pszName, atch);

            ret = NDdeShareDel(atch, pszName, 0);
            pszName[0] = tch;

            if (NDDE_NO_ERROR == ret)
                {
                // Delete the key in the registry
                RevertToSelf();
                if (ERROR_SUCCESS == MakeTheDamnKey(&hkeyClp, KEY_SET_VALUE))
                    {
                    RegDeleteValue(hkeyClp, pszName);
                    RegCloseKey(hkeyClp);
                    }
                else
                    {
                    PERROR(TEXT("Couldn't delete key! #%ld\r\n"), GetLastError());
                    }

                DdeImpersonateClient(hConv);


                // force render all if applicable!
                SendMessage (hwndApp, WM_RENDERALLFORMATS, 0, 0L);

                // unlink file!
                DeleteFileW(pshrinfo->szFileName);

                // Take this page out of the linked list of pages.
                if (q == NULL)
                    {
                    SIHead = pshrinfo->Next;
                    }
                else
                    {
                    q->Next = pshrinfo->Next;
                    }

                DdeFreeStringHandle ( idInst, pshrinfo->hszName );

                if ( pshrinfo->hFormatList )
                    DdeFreeDataHandle ( pshrinfo->hFormatList );

                if ( pshrinfo->hPreviewBmp )
                    DdeFreeDataHandle ( pshrinfo->hPreviewBmp );

                LocalFree ( (HLOCAL)pshrinfo );

                #ifdef AUTOUPDATE
                  DdePostAdvise ( idInst, hszSysTopic, hszTopicList );
                #endif

                fOK = TRUE;
                }
            else
                {
                PERROR(TEXT("Csrv: NDde err %ld on delshare\r\n"), ret);
                SetXactErr (hConv, XERRT_NDDE, ret);
                }

            break; // Don't loop thru additional pages if you found the right one
            }
        }

    if (!fOK)
       {
       PERROR(TEXT("Clipsrv: item to delete '%s' not found\n\r"), pszName );
       }

    return fOK;
}








/*
 *      AddRecord
 *
 *  Purpose:
 *     Add a record to the linked list of Clipbook pages in memory.
 *
 *  Parameters:
 *     lpszName - Name of the page.
 *     lpszFileName - Name of the .CLP file containing the page's data.
 *     siflags - Flags for the page.
 *
 *  Returns:
 *     TRUE on success, FALSE on failure
 */

BOOL AddRecord (
    LPTSTR  lpszName,
    LPTSTR  lpszFileName,
    ULONG   siflags)
{
    pShrInfo pshrinfo;


    PINFO(TEXT("Making page %s with file %s\r\n"), lpszName, lpszFileName);

    pshrinfo = (pShrInfo) LocalAlloc ( LPTR, sizeof ( ShrInfo ) );


    if ( !pshrinfo )
        {
        PERROR(TEXT("AddRecord: LocalAlloc failed\n\r"));
        return FALSE;
        }


    if ( !( pshrinfo->hszName = DdeCreateStringHandle ( idInst, lpszName, 0 )))
        {
        PERROR(TEXT("AddRecord: DdeCHSZ fail\r\n"));

        LocalFree (pshrinfo);
        return(FALSE);
        }


    #ifdef UNICODE
      lstrcpy( pshrinfo->szFileName, lpszFileName );
      lstrcpy( pshrinfo->szName, lpszName );
    #else
      MultiByteToWideChar(CP_ACP, 0L, lpszFileName, -1, pshrinfo->szFileName, MAX_FILEPATH - 1);
      MultiByteToWideChar(CP_ACP, 0L, lpszName, -1, pshrinfo->szName, MAX_CLPSHRNAME);
    #endif


    PINFO(TEXT("Made page %ls with file %ls\r\n"), pshrinfo->szName, pshrinfo->szFileName);



    #ifdef CACHEFORMATLIST
     pshrinfo->hFormatList = 0L;
    #endif

    #ifdef CACHEPREVIEWS
     pshrinfo->hPreviewBmp = 0L;
    #endif

    pshrinfo->Next = SIHead;
    SIHead = pshrinfo;
    pshrinfo->flags = (WORD) siflags;


    return TRUE;

}






/*
 *      ResetRecord
 *
 *  When paste into an existing page, we need to clear the cached
 *  stuff for the old data.
 */

void    ResetRecord (pShrInfo   pInfo)
{

    // clear the format list

    if (pInfo->hFormatList)
        {
        DdeFreeDataHandle (pInfo->hFormatList);
        pInfo->hFormatList = NULL;
        }

    // clear the preview bitmap

    if (pInfo->hPreviewBmp)
        {
        DdeFreeDataHandle (pInfo->hPreviewBmp);
        pInfo->hPreviewBmp = NULL;
        }

}









/*
 *      GetShareFileName
 *
 */

pShrInfo    GetShareFileName (LPTSTR szSName, LPTSTR szFName)
{
BOOL        bRet = FALSE;
HSZ         hS;
CHAR        cSave;
pShrInfo    pInfo;



    cSave = *szSName;



    hS = DdeCreateStringHandle (idInst, szSName, 0);
    if (!hS)
        goto done;



    for (pInfo = SIHead; pInfo; pInfo = pInfo->Next)
        if (!DdeCmpStringHandles (pInfo->hszName, hS))
            {
            #ifndef UNICODE
                WideCharToMultiByte (CP_ACP,
                                     0,
                                     pInfo->szFileName,
                                     -1,
                                     szFName,
                                     MAX_PATH+1,
                                     NULL,
                                     NULL);
            #else
                lstrcpy (szFName, pInfo->szFileName);
            #endif

            bRet = TRUE;
            goto done;
            }



    DdeFreeStringHandle (idInst, hS);





    // not found, change share name to shared or unshared

    if (UNSHR_CHAR == cSave)
        *szSName = SHR_CHAR;
    else
        *szSName = UNSHR_CHAR;




    // try again with new share name

    hS = DdeCreateStringHandle (idInst, szSName, 0);
    if (!hS)
        goto done;



    for (pInfo = SIHead; pInfo; pInfo = pInfo->Next)
        if (!DdeCmpStringHandles (pInfo->hszName, hS))
            {
            #ifndef UNICODE
                WideCharToMultiByte (CP_ACP,
                                     0,
                                     pInfo->szFileName,
                                     -1,
                                     szFName,
                                     MAX_PATH+1,
                                     NULL,
                                     NULL);
            #else
                lstrcpy (szFName, pInfo->szFileName);
            #endif

            bRet = TRUE;
            goto done;
            }





done:

    if (hS)
        DdeFreeStringHandle (idInst, hS);


    *szSName = cSave;


    if (bRet)
        return pInfo;
    else
        return NULL;

}







/*
 *      AddShare
 *
 *  Purpose:
 *     Creates a new Clipbook page by doing this:
 *        - Save the current clipboard with some random file name.
 *        - Add the Clipbook page to the list in memory
 *        - Record the existence of the page in the Clipbook Server
 *           section of the registry. The value name is the page name,
 *           and the value is the filename.
 *
 *  Parameters:
 *     pszName - Name of the page.
 *     flags   - Flags to store with the page.
 *
 *  Returns:
 *     TRUE on success, FALSE on failure.
 */

DWORD AddShare(
    LPTSTR  pszName,
    WORD    flags)
{
TCHAR       szFName[MAX_PATH+1];
HKEY        hkeyClp;
DWORD       dwR = NO_ERROR;
pShrInfo    pInfo;



    fNTSaveFileFormat = TRUE;


    if (pInfo = GetShareFileName (pszName, szFName))
        {
        dwR = SaveClipboardToFile (hwndApp, pszName, szFName, TRUE);

        ResetRecord (pInfo);

        lstrcpy (szUpdateName, pszName);
        }
    else
        {
        dwR = GetRandShareFileName (szFName);
        if (dwR != NO_ERROR)
            return dwR;

        dwR = SaveClipboardToFile (hwndApp, pszName, szFName, TRUE);
        if (dwR != NO_ERROR)
            return dwR;


        if (!AddRecord ( pszName, szFName, flags ))
            return ERROR_NOT_ENOUGH_MEMORY;


        if (ERROR_SUCCESS == MakeTheDamnKey(&hkeyClp, KEY_SET_VALUE))
            {
            RegSetValueEx(hkeyClp, pszName, 0, REG_SZ, szFName,
                  lstrlen(szFName));
            RegCloseKey(hkeyClp);

            PINFO(TEXT("%s is being written...\n\r"), pszName);
            }
        }



    #ifdef AUTOUPDATE
      DdePostAdvise ( idInst, hszSysTopic, hszTopicList );
    #endif



    return dwR;

}








#if DEBUG

/*
 *      DumpShares
 */

VOID DumpShares (void)
{
char     buf[65];
pShrInfo pshrinfo;
int      i;
DWORD    cbRet;

    for ( i=0, pshrinfo = SIHead; pshrinfo; pshrinfo = pshrinfo->Next, i++ )
        {
        PINFO(TEXT("---------- Share %d  flags:%x-------------\n\r"), i, pshrinfo->flags );
        cbRet = DdeQueryString ( idInst, pshrinfo->hszName, buf, 128L, CP_WINANSI );
        PINFO(TEXT("name: >%s<\n\r"), (LPSTR)pshrinfo->szName );
        PINFO(TEXT("hsz:  >%s<\n\r"), cbRet? (LPSTR)buf : (LPSTR)TEXT("ERROR") );
        }

}
#else
VOID DumpShares (void)
{
}
#endif








/*
 *      MarkShare
 *
 *  Purpose: Mark a Clipbook page as shared or unshared.
 *
 *  Parameters:
 *     pszName - Name of the page.
 *     flags   - 0 for "unshared", SIF_SHARED for "shared."
 *
 *  Returns:
 *     TRUE on success, FALSE on failure.
 *
 */

BOOL MarkShare(
    TCHAR   *pszName,
    WORD    flags)
{
PSECURITY_DESCRIPTOR pSDShare;
pShrInfo    pshrinfo;
HKEY        hkeyClp;
INT         iTmp;

ACCESS_ALLOWED_ACE *pace;
WCHAR       rgwchT[MAX_CLPSHRNAME+1];
UINT        ret;
DWORD       dwBytes = sizeof(pSDShare);
WORD        wItems = 0;
PACL        Acl;
BOOL        fDacl;
BOOL        fDefault;
DWORD       i;


#ifndef UNICODE
    MultiByteToWideChar(CP_ACP, 0, pszName, -1, rgwchT, MAX_CLPSHRNAME);
#endif





    PINFO(TEXT("Entering MarkShare\r\n"));

    for (pshrinfo = SIHead; pshrinfo; pshrinfo = pshrinfo->Next)
        {

        #ifdef UNICODE
        iTmp = lstrcmpW (pshrinfo->szName+1, pszName+1);
        #else
        iTmp = lstrcmpW (pshrinfo->szName+1, rgwchT+1);
        #endif

        if (!iTmp)
            {
            PINFO(TEXT("MarkShare: marking %s %d\n\r"), (LPSTR)pszName, flags );

            // If the name's changing, need to delete old reg key.
            // (We make the new one after hitting the file security.)
            if ((pshrinfo->flags & SIF_SHARED) != (flags & SIF_SHARED))
                {
                PINFO(TEXT("Changing shared status\r\n"));

                // Delete the registry item with the old name
                if (ERROR_SUCCESS == MakeTheDamnKey(&hkeyClp, KEY_SET_VALUE))
                    {
                    PINFO(TEXT("Deleting old name %ws\r\n"),pshrinfo->szName);
                    RegDeleteValueW(hkeyClp, pshrinfo->szName);
                    RegCloseKey(hkeyClp);
                    }
                else
                    {
                    PERROR(TEXT("MarkShare: Couldn't open registry!\r\n"));
                    }
                }


            // Set name to reflect shared/unshared status
            pshrinfo->szName[0] = (flags & SIF_SHARED) ? SHR_CHAR : UNSHR_CHAR;
            pshrinfo->flags = flags;



            // Sync the security on the Clipbook page file to be
            // analogous to the security set on the NetDDE share.
            pszName[0] = SHR_CHAR;
            NDdeGetShareSecurity(NULL, pszName, DACL_SECURITY_INFORMATION, NULL, 0, &i);

            PINFO(TEXT("Getting security %ld bytes\r\n"), i);


            if (!(pSDShare = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, i)))
                {
                PERROR(TEXT("LocalAlloc fail\r\n"));
                }
            else
                {
                ret = NDdeGetShareSecurity (NULL,
                                            pszName,
                                            DACL_SECURITY_INFORMATION,
                                            pSDShare,
                                            i,
                                            &i);

                if (NDDE_NO_ERROR != ret)
                    {
                    PERROR(TEXT("Couldn't get sec #%ld\r\n"), ret);
                    }
                else if (!GetSecurityDescriptorDacl(pSDShare, &fDacl, &Acl, &fDefault))
                    {
                    PERROR(TEXT("GetDACL fail %ld\r\n"), GetLastError());
                    }
                else
                    {
                    DWORD dwGeneric;

                    for (i = 0; GetAce(Acl, i, &pace); i++)
                        {
                        dwGeneric = 0L;


                        // Convert NDDE access mask types to generic access
                        // mask types
                        if (ACCESS_ALLOWED_ACE_TYPE == pace->Header.AceType ||
                            ACCESS_DENIED_ACE_TYPE == pace->Header.AceType)
                            {
                            if ((pace->Mask & NDDE_SHARE_READ) == NDDE_SHARE_READ)
                                {
                                PINFO(TEXT("R"));
                                dwGeneric |= GENERIC_READ;
                                }

                            if ((pace->Mask & NDDE_SHARE_WRITE) == NDDE_SHARE_WRITE)
                                {
                                PINFO(TEXT("R"));
                                dwGeneric |= GENERIC_WRITE;
                                }

                            if ((pace->Mask & NDDE_GUI_CHANGE) == NDDE_GUI_CHANGE)
                                {
                                PINFO(TEXT("D"));
                                dwGeneric |= GENERIC_WRITE|GENERIC_READ|DELETE;
                                }

                            if ((pace->Mask & NDDE_GUI_FULL_CONTROL) ==
                                  NDDE_GUI_FULL_CONTROL)
                                {
                                PINFO(TEXT("A"));
                                dwGeneric |= GENERIC_ALL;
                                }

                            PINFO(TEXT(" = %ld\r\n"), dwGeneric);
                            pace->Mask = dwGeneric;
                            }
                        else
                            {
                            PERROR(TEXT("Invalid ACE type!!!\r\n"));
                            }
                        }

                    ret = SetFileSecurityW (pshrinfo->szFileName,
                                            DACL_SECURITY_INFORMATION,
                                            pSDShare);

                    if (FALSE == ret)
                        {
                        PERROR(TEXT("SetFSec err %ld\r\n"), GetLastError());
                        }

                    }

                LocalFree(pSDShare);
                }


            DdeFreeStringHandle ( idInst, pshrinfo->hszName );
            pshrinfo->hszName = DdeCreateStringHandleW( idInst, pshrinfo->szName,
                  CP_WINUNICODE);

            if ( !pshrinfo->hszName )
                {
                PERROR(TEXT("DdeCreateStringHandle failed\n\r"));
                }
            else
                {
                // update the registry to show shared/unshared status
                if (ERROR_SUCCESS == MakeTheDamnKey(&hkeyClp, KEY_SET_VALUE))
                    {
                    PINFO(TEXT("Making registry key %ls from %ls, %d\r\n"),
                          pshrinfo->szName, pshrinfo->szFileName,
                          lstrlenW(pshrinfo->szFileName));

                    RegSetValueExW (hkeyClp,
                                    pshrinfo->szName,
                                    0,
                                    REG_SZ,
                                    (LPBYTE)pshrinfo->szFileName,
                                    lstrlenW (pshrinfo->szFileName) *sizeof(WCHAR) +sizeof(WCHAR));

                    RegCloseKey(hkeyClp);

                    DdePostAdvise ( idInst, hszSysTopic, hszTopicList );
                    return TRUE;
                    }
                else
                    {
                    PERROR(TEXT("Could not make registry key to record %s"),
                           pshrinfo->szName);
                    }
                }
            }
        }




    PERROR(TEXT("Item to mark '%s' not found\n\r"), pszName );

    return FALSE;

}









/*
 *      Hszize
 *  This creates often used global hszs from standard global strings.
 *  It also fills the hsz fields of the topic and item tables.
 *
 */

void Hszize(void)
{

    hszAppName      = DdeCreateStringHandle (idInst, szServer,             0L);
    hszSysTopic     = DdeCreateStringHandle (idInst, SZDDESYS_TOPIC,       0L);
    hszTopicList    = DdeCreateStringHandle (idInst, SZDDESYS_ITEM_TOPICS, 0L);
    hszFormatList   = DdeCreateStringHandle (idInst, SZ_FORMAT_LIST,       0L);
    hszErrorRequest = DdeCreateStringHandle (idInst, SZ_ERR_REQUEST, 0L);

    #ifdef DEBUG
    if ( !hszAppName || !hszSysTopic || !hszTopicList || !hszFormatList )
        {
        PERROR(TEXT("error creating HSZ constants\n\r"));
        }
    #endif
}




/*
 *      UnHszize
 */

void UnHszize(void)
{
    DdeFreeStringHandle (idInst, hszAppName);
    DdeFreeStringHandle (idInst, hszSysTopic);
    DdeFreeStringHandle (idInst, hszTopicList);
    DdeFreeStringHandle (idInst, hszFormatList);
    DdeFreeStringHandle (idInst, hszErrorRequest);
}







/*
 *      GetRandShareFileName
 *
 *  Purpose:
 *     Generate a random share file name in the Windows directory.
 *
 *  Parameters:
 *     buf - Buffer to place the file name in.
 *
 *  Returns:
 *     TRUE if a valid filename was found, or FALSE if all of the random
 *     filenames are taken up.
 */

DWORD GetRandShareFileName (
    LPTSTR  buf)
{
TCHAR   szWinDir[144];
BOOL    IsUnique = FALSE;
WORD    rand;
WORD    cTry = 0;
HANDLE  hFile;


    if (!GetWindowsDirectory( szWinDir, 144))
        {
        return GetLastError();
        }

    rand = (WORD)GetTickCount() % 10000;

    do  {
        wsprintf ( buf, TEXT("%s\\CBK%04d.CLP"), szWinDir, rand++ );
        hFile = CreateFile (buf,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_NEW,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);

        }while (INVALID_HANDLE_VALUE == hFile && cTry++ < 10000);


    if (INVALID_HANDLE_VALUE == hFile)
        {
        PERROR(TEXT("GetRandShareFileName: More than 1000 clipbook file exist!\r\n"));
        return GetLastError();
        }
    else
        {
        CloseHandle(hFile);
        return NO_ERROR;
        }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\datasrv\ddeutil.h ===
// Prototypes for DDE utiltity functions-- most with AW variants.
//


extern HDDEDATA GetTopicListA(
    HCONV   hConv,
    BOOL    fAllTopicsReq);



extern HDDEDATA GetTopicListW(
    HCONV   hConv,
    BOOL    fAllTopicsReq);

extern HDDEDATA GetFormatListA(
    HCONV   hConv,
    HSZ     hszTopic);


extern HDDEDATA GetFormatListW(
    HCONV   hConv,
    HSZ     hszTopic);


#ifdef UNICODE
    #define GetTopicList    GetTopicListA
    #define GetFormatList   GetFormatListA
#else
    #define GetTopicList    GetTopicListW
    #define GetFormatList   GetFormatListW
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\datasrv\ddeutil.c ===
#include    <windows.h>
#include    <string.h>
#include    <stdlib.h>
#include    <stdio.h>
#include    <memory.h>
#include    <ddeml.h>

#include    "common.h"

#include    "clipfile.h"
#include    "clipsrv.h"
#include    "ddeutil.h"
#include    "callback.h"
#include    "debugout.h"







/*
 *      GetTopicListA
 *
 *  Purpose: Creata a DDE handle to a block containing a tab-delimited
 *     list of the available topics with a NULL at the end.
 *
 *  Parameters:
 *     fAllTopicReq - TRUE to get all topics, FALSE to just get shared.
 *
 *  Returns: The data handle.
 *
 *  Notes: AW variants
 */

HDDEDATA GetTopicListA(
    HCONV   hConv,
    BOOL    fAllTopicReq)
{
LPSTR       lpszTopics;
LPSTR       pTmp;
HDDEDATA    hData;
DWORD       cbData = 0L;
pShrInfo    pshrinfo;



    for ( pshrinfo=SIHead; pshrinfo; pshrinfo = pshrinfo->Next )
        {
       /*
        * Keep enought buffer for MBCS string,
        * Should I use nls function to compute MBCS length ?.
        * but go easy way.
        */
        cbData += ( ( lstrlenW( pshrinfo->szName ) + 1 ) * sizeof(WORD) );
        }

        cbData += sizeof(szUpdateName) +1;


    // if there are no entries, must send a "" string, not 0!

    if ( !cbData )
        return (DdeCreateDataHandle (idInst, TEXT(""), 1, 0L, hszTopicList, CF_TEXT, 0));





    hData = DdeCreateDataHandle (idInst, NULL, cbData, 0L, hszTopicList, CF_TEXT, 0);


    if ( !hData )
        {
        SetXactErr (hConv, XERRT_DDE, DdeGetLastError (idInst));
        PERROR(TEXT("error creating hddedata for topic list\n\r"));
        }
    else
        {
        if ( ( pTmp = lpszTopics = DdeAccessData(hData, NULL) ) == (LPSTR)NULL )
            {
            SetXactErr (hConv, XERRT_DDE, DdeGetLastError (idInst));
            PERROR(TEXT("error accessing data handle for topic list\n\r"));

            DdeFreeDataHandle(hData);
            hData = 0L;
            }
        else
            {
            // put the updated name first
            #ifdef UNICODE
              wsprintfA (pTmp, "%lc%ls\t", BOGUS_CHAR, szUpdateName);
            #else
              wsprintfA (pTmp, "%hc%hs\t", BOGUS_CHAR, szUpdateName);
            #endif

            pTmp += lstrlenA (pTmp);


            // Create a tab-delimited list of topics in CF_TEXT format.
            for ( pshrinfo=SIHead; pshrinfo; pshrinfo = pshrinfo->Next )
                {
                // Only list SHARED topics if this isn't a "[alltopiclist]" req
                if (SHR_CHAR == pshrinfo->szName[0] ||
                    fAllTopicReq)
                    {

                    WideCharToMultiByte (CP_ACP,
                                         0,
                                         pshrinfo->szName,
                                         -1,
                                         pTmp,
                                         (int)(cbData - (size_t)(pTmp - lpszTopics)),
                                         NULL,
                                         NULL);


                    pTmp += lstrlenA(pTmp);
                    *pTmp++ = '\t';
                    }
                }

            // Turn the last tab into a NULL.
            if ( pTmp != lpszTopics )
                *--pTmp = '\0';

            DdeUnaccessData ( hData );
            }
        }


    return hData;
}








/*
 *      GetTopicListW
 */

HDDEDATA GetTopicListW(
    HCONV   hConv,
    BOOL    fAllTopicsReq)
{
LPWSTR      lpszTopics;
LPWSTR      pTmp;
HDDEDATA    hData;
DWORD       cbData = 0L;
pShrInfo    pshrinfo;

    for (pshrinfo=SIHead; pshrinfo; pshrinfo = pshrinfo->Next)
        {
       /*
        * Keep enought buffer for MBCS string,
        * Should I use nls function to compute MBCS length ?.
        * but go easy way.
        */
        cbData += ( ( lstrlenW( pshrinfo->szName ) + 1 ) * sizeof(WORD) );

        }

        cbData += sizeof(szUpdateName)/sizeof(TCHAR) +1;

    // if there are no entries, must send a "" string, not 0!

    if ( !cbData )
        return DdeCreateDataHandle (idInst, TEXT(""), 1, 0L, hszTopicList, CF_UNICODETEXT, 0);


    hData = DdeCreateDataHandle (idInst, NULL, cbData, 0L, hszTopicList, CF_UNICODETEXT, 0);


    if ( !hData )
        {
        SetXactErr (hConv, XERRT_DDE, DdeGetLastError(idInst));
        PERROR(TEXT("error creating hddedata for topic list\n\r"));
        }
    else
        {
        if ((pTmp = lpszTopics = (LPWSTR)DdeAccessData( hData, NULL ))
                 == (LPWSTR)NULL)
            {
            SetXactErr (hConv, XERRT_DDE, DdeGetLastError(idInst));
            PERROR(TEXT("error accessing data handle for topic list\n\r"));

            DdeFreeDataHandle(hData);
            hData = 0L;
            }
        else
            {

            // put the updated name first
            #ifdef UNICODE
              wsprintfW (pTmp, L"%lc%ls\t", BOGUS_CHAR, szUpdateName);
            #else
              wsprintfW (pTmp, L"%hc%hs\t", BOGUS_CHAR, szUpdateName);
            #endif

            pTmp += lstrlenW (pTmp);
            // Create a tab-delimited list of topics in CF_TEXT format.
            for (pshrinfo=SIHead; pshrinfo; pshrinfo = pshrinfo->Next )
                {
                if (SHR_CHAR == pshrinfo->szName[0] ||
                    fAllTopicsReq)
                    {
                    lstrcpyW( pTmp, pshrinfo->szName );
                    pTmp += lstrlenW(pTmp);
                    *pTmp++ = '\t';
                    }
                }

            // Turn the last tab into a NULL.
            if ( pTmp != lpszTopics )
                *--pTmp = '\0';

            DdeUnaccessData ( hData );
            }
        }


    return hData;

}








/*
 *      GetFormatListA
 *
 *  Purpose: Create a DDE handle containing a tab-delimited list of the
 *     formats available for the given topic -- it's assumed to be a share.
 *
 *  Parameters:
 *     hszTopic - String handle to the topic name.
 *
 *  Returns:
 *     DDE handle to the list.
 *
 *  Notes:
 *     AW variants
 */

HDDEDATA GetFormatListA(
    HCONV   hConv,
    HSZ     hszTopic )
{
LPSTR           lpszFormats;
LPSTR           lpcsTmp;
HDDEDATA        hData = 0L;
DWORD           cbData = 0L;
pShrInfo        pshrinfo;
unsigned        cFormats;
FORMATHEADER    FormatHeader;
unsigned        i;
HANDLE          fh;



    PINFO(TEXT("GetFormatList:"));

    for ( pshrinfo=SIHead; pshrinfo; pshrinfo = pshrinfo->Next )
        {
        if ( DdeCmpStringHandles ( hszTopic, pshrinfo->hszName ) == 0 )
            {

            #ifdef CACHEFORMATLIST
            if (pshrinfo->hFormatList)
                return pshrinfo->hFormatList;
            #endif


            fh = CreateFileW (pshrinfo->szFileName,
                              GENERIC_READ,
                              0,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL);


            if ( INVALID_HANDLE_VALUE == fh)
                {
                SetXactErr (hConv, XERRT_SYS, GetLastError());
                PERROR(TEXT("ERROR opening %s\n\r"), pshrinfo->szFileName);
                }
            else
                {
                cFormats = ReadFileHeader(fh);

                // allocate max data - some will be wasted...
                // It's this or go through the loop twice...

                /*
                 * Keep enought buffer for MBCS string,
                 * Should I use nls function to compute MBCS length ?.
                 * but go easy way.
                 */
                 cbData = cFormats * CCHFMTNAMEMAX * sizeof(WORD);
               hData = DdeCreateDataHandle (idInst,
                                             NULL,
                                             cbData,
                                             0L,
                                             hszFormatList,
                                             CF_TEXT,
                                           #ifdef CACHEFORMATLIST
                                             HDATA_APPOWNED );
                                           #else
                                             0 );
                                           #endif

                if (!hData)
                    {
                    SetXactErr (hConv, XERRT_DDE, DdeGetLastError (idInst));
                    PERROR(TEXT("DdeCreateDataHandle failed!!!\n\r"));
                    }
                else
                    {
                    lpszFormats = DdeAccessData(hData, NULL);
                    lpcsTmp = lpszFormats;
                    if (NULL == lpcsTmp)
                        {
                        SetXactErr (hConv, XERRT_DDE, DdeGetLastError (idInst));
                        DdeFreeDataHandle ( hData );
                        hData = 0L;
                        PERROR(TEXT("DdeAccessData failed!!!\n\r"));
                        }
                    else
                        {
                        PINFO(TEXT("%d formats found\n\r"), cFormats);

                        // form tab-separated list

                        for (i=0; i < cFormats; i++)
                            {
                            ReadFormatHeader(fh, &FormatHeader, i);
                            PINFO(TEXT("getformat: read >%ws<\n\r"), FormatHeader.Name);
                            WideCharToMultiByte (CP_ACP,
                                                 0,
                                                 FormatHeader.Name,
                                                 -1,
                                                 lpcsTmp,
                                                 cbData,
                                                 NULL,
                                                 NULL);


                            //  lstrcpyW( lpcsTmp, FormatHeader.Name );
                            lpcsTmp += lstrlenA(lpcsTmp);
                            *lpcsTmp++ = '\t';
                            }

                       *--lpcsTmp = '\0';

                       PINFO(TEXT("clipsrv: returning format list >%cs<\n\r"), lpszFormats );
                       DdeUnaccessData ( hData );

                       #ifdef CACHEFORMATLIST
                         pshrinfo->hFormatList = hData;
                       #endif
                       }
                   }
                CloseHandle(fh);
                }
            }
        }


    if (!hData)
        {
        PERROR (TEXT("GetFormatList: Topic not found\n\r"));
        }


    return hData;

}









/*
 *      GetFormatListW
 */

HDDEDATA GetFormatListW(
    HCONV   hConv,
    HSZ     hszTopic )
{
LPWSTR          lpszFormats;
LPWSTR          lpwsTmp;
HDDEDATA        hData = 0L;
DWORD           cbData = 0L;
pShrInfo        pshrinfo;
unsigned        cFormats;
FORMATHEADER    FormatHeader;
unsigned        i;
HANDLE          fh;


    PINFO(TEXT("GetFormatList:"));



    for ( pshrinfo=SIHead; pshrinfo; pshrinfo = pshrinfo->Next )
        {
        if ( DdeCmpStringHandles ( hszTopic, pshrinfo->hszName ) == 0 )
            {

            #ifdef CACHEFORMATLIST
            if ( pshrinfo->hFormatList )
                return pshrinfo->hFormatList;
            #endif

            fh = CreateFileW (pshrinfo->szFileName,
                              GENERIC_READ,
                              0,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL);


            if ( INVALID_HANDLE_VALUE == fh)
                {
                SetXactErr (hConv, XERRT_SYS, GetLastError());
                PERROR(TEXT("ERROR opening %s\n\r"), pshrinfo->szFileName);
                }
            else
                {
                cFormats = ReadFileHeader(fh);

                // allocate max data - some will be wasted...
                // It's this or go through the loop twice...
               /*
                * Keep enought buffer for MBCS string,
                * Should I use nls function to compute MBCS length ?.
                * but go easy way.
              */
                cbData = cFormats * CCHFMTNAMEMAX * sizeof(WORD);

                hData = DdeCreateDataHandle (idInst,
                                             NULL,
                                             cbData,
                                             0L,
                                             hszFormatList,
                                             CF_TEXT,
                                           #ifdef CACHEFORMATLIST
                                             HDATA_APPOWNED );
                                           #else
                                             0);
                                           #endif

                if ( !hData )
                    {
                    SetXactErr (hConv, XERRT_DDE, DdeGetLastError(idInst));
                    PERROR(TEXT("DdeCreateDataHandle failed!!!\n\r"));
                    }
                else
                    {
                    lpszFormats = (LPWSTR)DdeAccessData(hData, NULL);
                    lpwsTmp = lpszFormats;
                    if (NULL == lpwsTmp)
                        {
                        SetXactErr (hConv, XERRT_DDE, DdeGetLastError(idInst));

                        DdeFreeDataHandle ( hData );
                        hData = 0L;
                        PERROR(TEXT("DdeAccessData failed!!!\n\r"));
                        }
                    else
                        {
                        PINFO(TEXT("%d formats found\n\r"), cFormats);

                        // form tab-separated list

                        for (i=0; i < cFormats; i++)
                            {
                            ReadFormatHeader (fh, &FormatHeader, i);
                            PINFO(TEXT("getformat: read >%ws<\n\r"), FormatHeader.Name);

                            lstrcpyW (lpwsTmp, FormatHeader.Name);
                            lpwsTmp += lstrlenW (FormatHeader.Name);
                            *lpwsTmp++ = '\t';
                            }

                        *--lpwsTmp = '\0';

                        PINFO(TEXT("clipsrv: returning format list >%ws<\n\r"), lpszFormats );
                        DdeUnaccessData ( hData );


                        #ifdef CACHEFORMATLIST
                        pshrinfo->hFormatList = hData;
                        #endif
                        }
                    }

                CloseHandle(fh);
                }
            }
        }



    if (!hData)
        {
        PERROR (TEXT("GetFormatList: Topic not found\n\r"));
        }



    return hData;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\datasrv\islocal.h ===
/******************************************************************************

                        I S L O C A L   H E A D E R

    Name:       islocal.h
    Date:       1/20/94
    Creator:    John Fu

    Description:
        This is the header file for islocal.c

******************************************************************************/



void HexDumpBytes(
    char        *pv,
    unsigned    cb);


void PrintSid(
    PSID sid);


BOOL IsUserLocal (
    HCONV hConv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\datasrv\dib.h ===
/****************************************************************************
 *                                                                            *
 *  FILE        : SHOWDIB.H                                                    *
 *                                                                            *
 *  DESCRIPTION : Header/include file for ShowDIB example.                    *
 *                                                                            *
 ****************************************************************************/

/* Macro to restrict a given value to an upper or lower boundary value */
#define BOUND(x,min,max) ((x) < (min) ? (min) : ((x) > (max) ? (max) : (x)))

/* Macro to swap two values */
#define SWAP(x,y)   ((x)^=(y)^=(x)^=(y))

/* Macro to find the minimum of two values */
#define MIN(x,y) (((x) <= (y)) : x ? y)

/* Macros to display/remove hourglass cursor for lengthy operations */
#define StartWait() hcurSave = SetCursor(LoadCursor(NULL,IDC_WAIT))
#define EndWait()   SetCursor(hcurSave)

#define MINBAND         50     /* Minimum band size used by the program */
#define BANDINCREMENT        20     /* Decrement for band size while trying        */
                               /* to determine optimum band size.        */

/* macro to determine if resource is a DIB */
#define ISDIB(bft) ((bft) == BFT_BITMAP)

/* Macro to align given value to the closest DWORD (unsigned long ) */
#define ALIGNULONG(i)        ((i+3)/4*4)

/* Macro to determine to round off the given value to the closest byte */
#define WIDTHBYTES(i)        ((i+31)/32*4)

#define PALVERSION      0x300
#define MAXPALETTE        256          /* max. # supported palette entries */

/***************** GLOBAL VARIABLES *************************/

extern char              achFileName[128]; /* File pathname                       */
extern DWORD              dwOffset;     /* Current position if DIB file pointer    */
extern RECT              rcClip;            /* Current clip rectangle.                       */
extern BOOL              fPalColors;   /* TRUE if the current DIB's color table   */
                                    /* contains palette indexes not rgb values */
extern BOOL              bDIBToDevice; /* Use SetDIBitsToDevice() to BLT data.    */
extern BOOL              bLegitDraw;   /* We have a valid bitmap to draw               */
extern WORD              wTransparent; /* Mode of DC                               */
extern char              szAppName[];  /* App. name                               */
extern HPALETTE       hpalCurrent;  /* Handle to current palette               */
extern HANDLE              hdibCurrent;  /* Handle to current memory DIB               */
extern HBITMAP              hbmCurrent;   /* Handle to current memory BITMAP               */
extern HANDLE              hbiCurrent;   /* Handle to current bitmap info struct    */
extern DWORD              dwStyle;            /* Style bits of the App. window               */


/***********************************************************/
/* Declarations of functions used in dib.c module           */
/***********************************************************/

WORD            PaletteSize (VOID FAR * pv);
WORD            DibNumColors (VOID FAR * pv);
HANDLE          DibFromBitmap (HBITMAP hbm, DWORD biStyle, WORD biBits, HPALETTE hpal);
HBITMAP         BitmapFromDib (HANDLE hdib, HPALETTE hpal);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\datasrv\shares.c ===
// Shares.C -- Functions for manipulating NetDDE shares
#define    WINVER 0x0310
#define    NOAUTOUPDATE 1

#include <windows.h>
#include <windowsx.h>
#include "clipsrv.h"
#include "..\common\common.h"

BOOL
GetTokenHandle(
PHANDLE pTokenHandle )
{

if( !OpenThreadToken( GetCurrentThread(), TOKEN_READ, FALSE, pTokenHandle ) )
   {
   if( GetLastError() == ERROR_NO_TOKEN )
      {
      if( !OpenProcessToken( GetCurrentProcess(),
               TOKEN_READ,
               pTokenHandle ) )
         {
         return FALSE;
         }
      }
   else
      {
      return FALSE;
      }
   }
return TRUE;
}

// Purpose: Generate a self-relative SD whose ACL contains only an
//    entry for LocalSystem/GENERIC_ALL access. This SD will be used
//    in calls to CreateFile() for clipbook page files.
//
// Parameters: None
//
// Returns: Pointer to the security descriptor. This pointer may be freed.
//    Returns NULL on failure.
//
//////////////////////////////////////////////////////////////////////////
PSECURITY_DESCRIPTOR MakeLocalOnlySD(
void)
{
PSECURITY_DESCRIPTOR pSD;
PSECURITY_DESCRIPTOR pSDSelfRel = NULL;
SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
PSID sidLocal;
PACL Acl;
DWORD dwAclSize;

if (AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
         0, 0, 0, 0, 0, 0, 0, &sidLocal))
   {
   if (InitializeSecurityDescriptor(&pSD, SECURITY_DESCRIPTOR_REVISION))
      {
      // Allocate space for DACL with "System Full Control" access
      dwAclSize = sizeof(ACL)+ GetLengthSid(sidLocal) +
            sizeof(ACCESS_ALLOWED_ACE) + 42; // 42==fudge factor
      if (Acl = (PACL)GlobalAlloc(GPTR, dwAclSize))
         {
         if (InitializeAcl(Acl, dwAclSize, ACL_REVISION))
            {
            // LocalSystem gets all access, nobody else gets any.
            if (AddAccessAllowedAce(Acl, ACL_REVISION,
                  GENERIC_ALL, sidLocal))
               {
               if (SetSecurityDescriptorDacl(pSD, TRUE, Acl, TRUE))
                  {
                  DWORD dwSelfRelLen;

                  dwSelfRelLen = GetSecurityDescriptorLength(pSD);
                  pSDSelfRel = GlobalAlloc(GPTR, dwSelfRelLen);

                  if (MakeSelfRelativeSD(pSD, pSDSelfRel, &dwSelfRelLen))
                     {
                     }
                  else
                     {
                     GlobalFree((HANDLE)pSDSelfRel);
                     pSDSelfRel = NULL;
                     }
                  }
               }
            }
         GlobalFree((HANDLE)Acl);
         }
      }
   FreeSid(sidLocal);
   }
return(pSDSelfRel);
}

// Purpose: Create a security descriptor containing only a single
// DACL entry-- one to allow the user whose context we are running
// in GENERIC_ALL access.
//
// Parameters: None.
//
// Returns: A pointer to the security descriptor described above,
//    or NULL on failure.
PSECURITY_DESCRIPTOR CurrentUserOnlySD(
void)
{
SECURITY_DESCRIPTOR   aSD;
PSECURITY_DESCRIPTOR  pSD = NULL;
BOOL                  OK;
PACL                  TmpAcl;
PACCESS_ALLOWED_ACE   TmpAce;
DWORD                 lSD;
LONG                  DaclLength;
DWORD                 lTokenInfo;
HANDLE                hClientToken;
TOKEN_USER           *pUserTokenInfo;
SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

if (InitializeSecurityDescriptor(&aSD, SECURITY_DESCRIPTOR_REVISION)
    && !GetTokenHandle(&hClientToken))
   {
   // See if the token info fits in 50 bytes. If it does, fine.
   // If not, realloc to proper size and get the token info.
   pUserTokenInfo = (TOKEN_USER *)LocalAlloc( LMEM_FIXED, 50 );
   if (!GetTokenInformation( hClientToken, TokenUser,
                (LPVOID) pUserTokenInfo, 50, &lTokenInfo ) )
      {
      LocalFree( pUserTokenInfo );
      pUserTokenInfo = (TOKEN_USER *)LocalAlloc( LMEM_FIXED, lTokenInfo );
      if (!GetTokenInformation( hClientToken, TokenUser,
              (LPVOID) pUserTokenInfo, lTokenInfo, &lTokenInfo ) )
         {
         LocalFree( pUserTokenInfo );
         pUserTokenInfo = NULL;
         }
      }
   if (pUserTokenInfo)
      {
      // Figure out how big a Dacl we'll need for just me to be on it.
      DaclLength = (DWORD)sizeof(ACL) +
            GetLengthSid( pUserTokenInfo->User.Sid ) +
            (DWORD)sizeof( ACCESS_ALLOWED_ACE );

      if (TmpAcl = (PACL)LocalAlloc(LMEM_FIXED, DaclLength ))
         {
         if (InitializeAcl( TmpAcl, DaclLength, ACL_REVISION ))
            {
            if (AddAccessAllowedAce( TmpAcl, ACL_REVISION,
                  GENERIC_ALL, pUserTokenInfo->User.Sid ))
               {
               if (GetAce( TmpAcl, 0, (LPVOID *)&TmpAce ))
                  {
                  TmpAce->Header.AceFlags = 0;
                  OK   = SetSecurityDescriptorDacl(&aSD, TRUE, TmpAcl, FALSE);
                  lSD  = GetSecurityDescriptorLength( &aSD);
                  if (pSD  = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, lSD))
                     {
                     MakeSelfRelativeSD( &aSD, pSD, &lSD);

                     if( IsValidSecurityDescriptor( pSD ) )
                        {
                        LocalFree(pSD);
                        pSD = NULL;
                        }
                     else
                        {
                        PERROR(TEXT("Failed creating self-relative SD (%d)."),
                              GetLastError());
                        }
                     }
                  else
                     {
                     PERROR(TEXT("LocalAlloc for pSD fail\r\n"));
                     }
                  }
               else
                  {
                  PERROR("GetAce error %d", GetLastError());
                  }
               }
            else
               {
               PERROR(TEXT("AddAccessAllowedAce fail\r\n"));
               }
            }
         else
            {
            PERROR(TEXT("InitializeAcl fail\r\n"));
            }
         LocalFree((HANDLE)TmpAcl);
         }
      else
         {
         PERROR(TEXT("LocalAllof for Acl fail\r\n"));
         }
      LocalFree((HANDLE)pUserTokenInfo);
      }
   else
      {
      PERROR(TEXT("Couldn't get usertokeninfo\r\n"));
      }
   CloseHandle(hClientToken);
   }
else
   {
   PERROR(TEXT("Couldn't get token handle or InitSD bad \r\n"));
   }
return pSD;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\datasrv\islocal.c ===
/*
 *      islocal.c
 *
 *      Determine if a user is local.
 *
 *      Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 *      TimF    20010226
 */


#include <windows.h>
#include "common.h"
#include "clipsrv.h"
#include "security.h"
#include "debugout.h"


/*
 *      IsUserLocal
 *
 *  Purpose: Determine if the user context we're running in is
 *     interactive or remote.
 *
 *  Parameters: None.
 *
 *  Returns: TRUE if this is a locally logged-on user.
 */

BOOL
IsUserLocal(
    HCONV                   hConv
)
{
    BOOL                    fRet = FALSE;
    PSID                    sidInteractive;
    SID_IDENTIFIER_AUTHORITY NTAuthority = SECURITY_NT_AUTHORITY;

    if (!AllocateAndInitializeSid(&NTAuthority,
                                  1,
                                  SECURITY_INTERACTIVE_RID,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  &sidInteractive)) {

        PERROR(TEXT("IsUserLocal: Couldn't get interactive SID\r\n"));
    } else {

        if (!DdeImpersonateClient(hConv)) {
            PERROR(TEXT("IsUserLocal: DdeImpersonateClient failed\r\n"));
        } else {

            BOOL                    IsMember;

            if (!CheckTokenMembership(NULL,
                                      sidInteractive,
                                      &IsMember)) {

                PERROR(TEXT("IsUserLocal: CheckTokenMembership failed.\r\n"));
            } else {
                fRet = IsMember;
            }

            RevertToSelf();
        }

        FreeSid(sidInteractive);
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\datasrv\dib.c ===
/*******************************************************************************
 *                                                                             *
 *  MODULE      : DIB.C                                                        *
 *                                                                             *
 *  DESCRIPTION : Routines for dealing with Device Independent Bitmaps.        *
 *                                                                             *
 *                PaletteSize()       - Calculates the palette size in bytes   *
 *                                      of given DIB                           *
 *                                                                             *
 *                DibNumColors()      - Determines the number of colors in DIB *
 *                                                                             *
 *                BitmapFromDib()     - Creates a DDB given a global handle to *
 *                                      a block in CF_DIB format.              *
 *                                                                             *
 *                DibFromBitmap()     - Creates a DIB repr. the DDB passed in. *
 *                                                                             *
 *******************************************************************************/

#include <windows.h>
#include "dib.h"
static   HCURSOR hcurSave;

/****************************************************************************
 *                                                                          *
 *  FUNCTION   :  PaletteSize(VOID FAR * pv)                                *
 *                                                                          *
 *  PURPOSE    :  Calculates the palette size in bytes. If the info. block  *
 *                is of the BITMAPCOREHEADER type, the number of colors is  *
 *                multiplied by 3 to give the palette size, otherwise the   *
 *                number of colors is multiplied by 4.                                                          *
 *                                                                          *
 *  RETURNS    :  Palette size in number of bytes.                          *
 *                                                                          *
 ****************************************************************************/
WORD PaletteSize (pv)
VOID FAR * pv;
{
    LPBITMAPINFOHEADER lpbi;
    WORD               NumColors;

    lpbi      = (LPBITMAPINFOHEADER)pv;
    NumColors = DibNumColors(lpbi);

    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
        return NumColors * sizeof(RGBTRIPLE);
    else
        return NumColors * sizeof(RGBQUAD);
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : DibNumColors(VOID FAR * pv)                                *
 *                                                                          *
 *  PURPOSE    : Determines the number of colors in the DIB by looking at   *
 *               the BitCount filed in the info block.                      *
 *                                                                          *
 *  RETURNS    : The number of colors in the DIB.                           *
 *                                                                          *
 ****************************************************************************/
WORD DibNumColors (pv)
VOID FAR * pv;
{
    int                 bits;
    LPBITMAPINFOHEADER  lpbi;
    LPBITMAPCOREHEADER  lpbc;

    lpbi = ((LPBITMAPINFOHEADER)pv);
    lpbc = ((LPBITMAPCOREHEADER)pv);

    /*  With the BITMAPINFO format headers, the size of the palette
     *  is in biClrUsed, whereas in the BITMAPCORE - style headers, it
     *  is dependent on the bits per pixel ( = 2 raised to the power of
     *  bits/pixel).
     */
    if (lpbi->biSize != sizeof(BITMAPCOREHEADER)){
        if (lpbi->biClrUsed != 0)
            return (WORD)lpbi->biClrUsed;
        bits = lpbi->biBitCount;
    }
    else
        bits = lpbc->bcBitCount;

    switch (bits){
        case 1:
                return 2;
        case 4:
                return 16;
        case 8:
                return 256;
        default:
                /* A 24 bitcount DIB has no color table */
                return 0;
    }
}
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : DibFromBitmap()                                            *
 *                                                                          *
 *  PURPOSE    : Will create a global memory block in DIB format that       *
 *               represents the Device-dependent bitmap (DDB) passed in.    *
 *                                                                          *
 *  RETURNS    : A handle to the DIB                                        *
 *                                                                          *
 ****************************************************************************/
HANDLE DibFromBitmap (hbm, biStyle, biBits, hpal)
HBITMAP      hbm;
DWORD        biStyle;
WORD         biBits;
HPALETTE     hpal;
{
    BITMAP               bm;
    BITMAPINFOHEADER     bi;
    BITMAPINFOHEADER FAR *lpbi;
    DWORD                dwLen;
    HANDLE               hdib;
    HANDLE               h;
    HDC                  hdc;

    if (!hbm)
        return NULL;

    if (hpal == NULL)
        hpal = GetStockObject(DEFAULT_PALETTE);

    GetObject(hbm,sizeof(bm),(LPSTR)&bm);

    if (biBits == 0)
        biBits =  bm.bmPlanes * bm.bmBitsPixel;

    bi.biSize               = sizeof(BITMAPINFOHEADER);
    bi.biWidth              = bm.bmWidth;
    bi.biHeight             = bm.bmHeight;
    bi.biPlanes             = 1;
    bi.biBitCount           = biBits;
    bi.biCompression        = biStyle;
    bi.biSizeImage          = 0;
    bi.biXPelsPerMeter      = 0;
    bi.biYPelsPerMeter      = 0;
    bi.biClrUsed            = 0;
    bi.biClrImportant       = 0;

    dwLen  = bi.biSize + PaletteSize(&bi);

    hdc = GetDC(NULL);
    hpal = SelectPalette(hdc,hpal,FALSE);
         RealizePalette(hdc);

    hdib = GlobalAlloc(GHND,dwLen);

    if (!hdib){
        SelectPalette(hdc,hpal,FALSE);
        ReleaseDC(NULL,hdc);
        return NULL;
    }

    lpbi = (VOID FAR *)GlobalLock(hdib);

    *lpbi = bi;

    /*  call GetDIBits with a NULL lpBits param, so it will calculate the
     *  biSizeImage field for us
     */
    GetDIBits(hdc, hbm, 0, (WORD)bi.biHeight,
        NULL, (LPBITMAPINFO)lpbi, DIB_RGB_COLORS);

    bi = *lpbi;
    GlobalUnlock(hdib);

    /* If the driver did not fill in the biSizeImage field, make one up */
    if (bi.biSizeImage == 0){
        bi.biSizeImage = WIDTHBYTES((DWORD)bm.bmWidth * biBits) * bm.bmHeight;

        if (biStyle != BI_RGB)
            bi.biSizeImage = (bi.biSizeImage * 3) / 2;
    }

    /*  realloc the buffer big enough to hold all the bits */
    dwLen = bi.biSize + PaletteSize(&bi) + bi.biSizeImage;
    if (h = GlobalReAlloc(hdib,dwLen,0))
        hdib = h;
    else{
        GlobalFree(hdib);
        hdib = NULL;

        SelectPalette(hdc,hpal,FALSE);
        ReleaseDC(NULL,hdc);
        return hdib;
    }

    /*  call GetDIBits with a NON-NULL lpBits param, and actualy get the
     *  bits this time
     */
    lpbi = (VOID FAR *)GlobalLock(hdib);

    if (GetDIBits( hdc,
                   hbm,
                   0,
                   (WORD)bi.biHeight,
                   (LPSTR)lpbi + (WORD)lpbi->biSize + PaletteSize(lpbi),
                   (LPBITMAPINFO)lpbi, DIB_RGB_COLORS) == 0){
         GlobalUnlock(hdib);
         hdib = NULL;
         SelectPalette(hdc,hpal,FALSE);
         ReleaseDC(NULL,hdc);
         return NULL;
    }

    bi = *lpbi;
    GlobalUnlock(hdib);

    SelectPalette(hdc,hpal,FALSE);
    ReleaseDC(NULL,hdc);
    return hdib;
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : BitmapFromDib(HANDLE hdib, HPALETTE hpal)                  *
 *                                                                          *
 *  PURPOSE    : Will create a DDB (Device Dependent Bitmap) given a global *
 *               handle to a memory block in CF_DIB format                  *
 *                                                                          *
 *  RETURNS    : A handle to the DDB.                                       *
 *                                                                          *
 ****************************************************************************/
HBITMAP BitmapFromDib (HANDLE hdib,HPALETTE hpal)
{
    LPBITMAPINFOHEADER  lpbi;
    HPALETTE            hpalT;
    HDC                 hdc;
    HBITMAP             hbm;

    StartWait();

    if (!hdib)
        return NULL;

    lpbi = (VOID FAR *)GlobalLock(hdib);

    if (!lpbi)
        return NULL;

    hdc = GetDC(NULL);

    if (hpal){
        hpalT = SelectPalette(hdc,hpal,FALSE);
        RealizePalette(hdc);     // GDI Bug...????
    }

    hbm = CreateDIBitmap(hdc,
                (LPBITMAPINFOHEADER)lpbi,
                (LONG)CBM_INIT,
                (LPSTR)lpbi + lpbi->biSize + PaletteSize(lpbi),
                (LPBITMAPINFO)lpbi,
                DIB_RGB_COLORS );

    if (hpal)
        SelectPalette(hdc,hpalT,FALSE);

    ReleaseDC(NULL,hdc);
    GlobalUnlock(hdib);

    EndWait();

    return hbm;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\datasrv\wnet.c ===
/*
 *      WNetGetCaps
 */

HINSTANCE WNetGetCaps(WORD wGunk)
{
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbrd\dib.h ===
/****************************************************************************
 *                                                                            *
 *  FILE        : SHOWDIB.H                                                    *
 *                                                                            *
 *  DESCRIPTION : Header/include file for ShowDIB example.                    *
 *                                                                            *
 ****************************************************************************/

/* Macro to restrict a given value to an upper or lower boundary value */
#define BOUND(x,min,max) ((x) < (min) ? (min) : ((x) > (max) ? (max) : (x)))

/* Macro to swap two values */
#define SWAP(x,y)   ((x)^=(y)^=(x)^=(y))

/* Macro to find the minimum of two values */
#define MIN(x,y) (((x) <= (y)) : x ? y)

/* Macros to display/remove hourglass cursor for lengthy operations */
#define StartWait() hcurSave = SetCursor(LoadCursor(NULL,IDC_WAIT))
#define EndWait()   SetCursor(hcurSave)

#define MINBAND         50     /* Minimum band size used by the program */
#define BANDINCREMENT        20     /* Decrement for band size while trying        */
                               /* to determine optimum band size.        */

/* macro to determine if resource is a DIB */
#define ISDIB(bft) ((bft) == BFT_BITMAP)

/* Macro to align given value to the closest DWORD (unsigned long ) */
#define ALIGNULONG(i)        ((i+3)/4*4)

/* Macro to determine to round off the given value to the closest byte */
#define WIDTHBYTES(i)        ((i+31)/32*4)

#define PALVERSION      0x300
#define MAXPALETTE        256          /* max. # supported palette entries */

/***************** GLOBAL VARIABLES *************************/

extern char              achFileName[128]; /* File pathname                       */
extern DWORD              dwOffset;     /* Current position if DIB file pointer    */
extern RECT              rcClip;            /* Current clip rectangle.                       */
extern BOOL              fPalColors;   /* TRUE if the current DIB's color table   */
                                    /* contains palette indexes not rgb values */
extern BOOL              bDIBToDevice; /* Use SetDIBitsToDevice() to BLT data.    */
extern BOOL              bLegitDraw;   /* We have a valid bitmap to draw               */
extern WORD              wTransparent; /* Mode of DC                               */
extern char              szAppName[];  /* App. name                               */
extern HPALETTE       hpalCurrent;  /* Handle to current palette               */
extern HANDLE              hdibCurrent;  /* Handle to current memory DIB               */
extern HBITMAP              hbmCurrent;   /* Handle to current memory BITMAP               */
extern HANDLE              hbiCurrent;   /* Handle to current bitmap info struct    */
extern DWORD              dwStyle;            /* Style bits of the App. window               */


/***********************************************************/
/* Declarations of functions used in dib.c module           */
/***********************************************************/

WORD            PaletteSize (VOID FAR * pv);
WORD            DibNumColors (VOID FAR * pv);
HANDLE          DibFromBitmap (HBITMAP hbm, DWORD biStyle, WORD biBits, HPALETTE hpal);
HBITMAP         BitmapFromDib (HANDLE hdib, HPALETTE hpal);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbrd\clipbrd.c ===
/****************************************************************************/
/*                                                                          */
/*  CLIPBRD.C -                                                             */
/*                                                                          */
/*  Copyright 1985-92, Microsoft Corporation                                */
/*                                                                          */
/*                                                                          */
/*      Window Clipboard Viewer                                             */
/*                                                                          */
/****************************************************************************/



/*
*
* Modified by Michael Gates (a-mgates), 9/9/92.
*
* Fixed bug #3576 ("Can't copy to clipboard from file manager")
*
* Touched by      :       Anas Jarrah
* On Date         :       May 11/1992.
* Revision remarks by Anas Jarrah ext #15201
* This file has been changed to comply with the Unicode standard
* Following is a quick overview of what I have done.
*
* Was             Changed it into        Remark
* ===             ===============        ======
* CHAR            TCHAR                  if it refers to a text elements
* LPCHAR & LPSTR  LPTSTR                 if it refers to text.
* LPCHAR & LPSTR  LPBYTE                 if it does not refer to text
* "..."           TEXT("...")            compile time macro resolves it.
* '...'           TEXT('...')            same
* strlen          CharStrLen             compile time macro resolves it.
* strcpy          CharStrCpy             compile time macro resolves it.
* strcmp          CharStrCmp             compile time macro resolves it.
* strcat          CharStrCat             compile time macro resolves it.
* RegisterWindow  RegisterWindowW        tell windows to send Unicode messages.
* LoadResource    LoadResource(A/W)      NT compiles resource strings into
*                                        Unicode binaries
* MOpenFile()     CreateFile             replaced to use the Win32 API [pierrej]
*
*
*
*   Modified by Pierre Jammes [pierrej] on 5/19/92
*
* The clipboard viewer must be able to display unicode string
* and ansi strings whether it is built as a unicode app or not.
* This is why the functions related to text display are able
* to handle both ansi and unicode strings and are specifically
* calling either the unicode or the ansi API.
* The three functions
*                 1) CchLineA(),
*                 2) CchLineW() and
*                 3) ShowText().
* are able to handle both ansi and unicode text, they contain some code
* that depend on ansi or unicode version of the system APIs and should
* stay the same whether UNICODE is defined or not (whether we are building
* a unicode app or not).
*
* There you will find some occurences of CHAR, WCHAR, LPSTR and LPWSTR.
*
* The Win32 API specifies clipboard ID as 32bit values and the BITMAP and
* METAFILEPICT structures contain fields that are twice as large as the
* same fields under Windows 3.1
* Saving the content of the clipboard into .CLP files that are readable by the
* Windows 3.1 clipboard viewer results in a loss of information.
* As the user may not want this loss of information unless (s)he is planning on
* using the .CLP file with a 16bit version of Windows (s)he is now given the
* oportunity to save the data in a new .CLP format that won't be recognized by
* the Windows 3.1 clipboard viewer (the FileID is different).
*
*/



#include "clipbrd.h"
#include "dib.h"
#include <shellapi.h>
#include <memory.h>

void NEAR PASCAL ShowString(HDC, WORD);

BOOL    fAnythingToRender = FALSE;
BOOL    fOwnerDisplay = FALSE;
BOOL    fDisplayFormatChanged = TRUE;

TCHAR    szAppName[] = TEXT("Clipboard");
TCHAR    szCaptionName[CAPTIONMAX];
TCHAR    szHelpFileName[20];

TCHAR    szMemErr[MSGMAX];

HWND    hwndNextViewer = NULL;
HWND    hwndMain;

HINSTANCE  hInst;
HANDLE  hAccel;
HANDLE  hfontSys;
HANDLE  hfontOem;
HANDLE  hfontUni;

HBRUSH  hbrWhite;
HBRUSH  hbrBackground;

HMENU   hMainMenu;
HMENU   hDispMenu;

/* The scroll information for OWNER display is to be preserved, whenever
 * the display changes between OWNER and NON-OWNER; The following globals
 * are used to save and restore the scroll info.
 */
INT     OwnVerMin, OwnVerMax, OwnHorMin, OwnHorMax;
INT     OwnVerPos, OwnHorPos;

LONG    cyScrollLast = -1;              /* Y-offset of display start when maximally */
                                        /*   scrolled down; -1==invalid             */
LONG    cyScrollNow  = 0;               /* Y-offset of current display start        */
                                        /*   (0=scrolled up all the way)            */
INT     cxScrollLast = -1;              /* Like cyScrollLast, but for horiz scroll  */
INT     cxScrollNow  = 0;               /* Like cyScrollNow, but for horiz scroll   */

RECT    rcWindow;                       /* Window in which to paint clipboard info  */

UINT      cyLine, cxChar, cxMaxCharWidth; /* Size of a standard text char             */
UINT      cxMargin, cyMargin;             /* White border size around clip data area  */

UINT    CurSelFormat = CBM_AUTO;

/* Defines priority order for show format */
UINT    rgfmt[] = {
                    CF_OWNERDISPLAY,
                    CF_DSPTEXT,
                    CF_DSPBITMAP,
                    CF_DSPENHMETAFILE,
                    CF_DSPMETAFILEPICT,
                    CF_TEXT,
                    CF_UNICODETEXT,
                    CF_OEMTEXT,
                    CF_ENHMETAFILE,
                    CF_METAFILEPICT,
                    CF_BITMAP,
                    CF_DIB,
                    CF_PALETTE,
                    CF_RIFF,
                    CF_WAVE,
                    CF_SYLK,
                    CF_DIF,
                    CF_TIFF,
                    CF_PENDATA
                  };
#define ifmtMax 19


/* variables for the new File Open,File SaveAs and Find Text dialogs */

OPENFILENAME OFN;
TCHAR szFileName[PATHMAX];              /*  Unicode  AnasJ May 92            */
TCHAR szLastDir[PATHMAX];
TCHAR szDefExt[CCH_szDefExt];           /* default extension for above       */
TCHAR szFilterSpec[FILTERMAX];          /* default filter spec. for above    */
TCHAR szCustFilterSpec[FILTERMAX];      /* buffer for custom filters created */
UINT  wHlpMsg;                          /* message used to invoke Help       */
TCHAR szOpenCaption [CAPTIONMAX];       /* File open dialog caption text     */
TCHAR szSaveCaption [CAPTIONMAX];       /* File Save as dialog caption text  */

/* MemErrorMessage is called when a failure occurs on either WinHelp or
 * ShellAbout.
 */
void FAR PASCAL MemErrorMessage()
{
        MessageBeep(0);
        MessageBox(hwndMain,szMemErr,NULL,MB_ICONHAND|MB_OK);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  MyOpenClipboard() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/
BOOL MyOpenClipboard(
HWND hWnd)
{
HDC   hDC;
RECT  Rect;

if(OpenClipboard(hWnd))
   {
   return(TRUE);
   }

/* Some app forgot to close the clipboard */
hDC = GetDC(hWnd);
GetClientRect(hWnd, (LPRECT)&Rect);
FillRect(hDC, (LPRECT)&Rect, hbrBackground);
ShowString(hDC, IDS_ALREADYOPEN);
ReleaseDC(hWnd, hDC);
return(FALSE);
}

/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  ChangeCharDimensions() -                                                    */
/*                                                                            */
/*--------------------------------------------------------------------------*/
void ChangeCharDimensions(
HWND hwnd,
UINT wOldFormat,
UINT wNewFormat)
{
/* Check if the font has changed. */
if (wOldFormat != wNewFormat)
   {
   switch (wNewFormat)
      {
   case CF_OEMTEXT:
      SetCharDimensions(hwnd, hfontOem);
      break;
   case CF_UNICODETEXT:
      SetCharDimensions(hwnd, hfontUni);
      break;
   case CF_TEXT:
   default:
      SetCharDimensions(hwnd, hfontSys);
      break;
      }
   }
}


/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  RenderFormat() -                                                            */
/*                                                                            */
/*--------------------------------------------------------------------------*/
/* Read the data from fh and SetClipboardData() with it. */
BOOL RenderFormat(
FORMATHEADER *FormatHeader,
register INT fh)
{
  HANDLE            hBitmap;
  register HANDLE   hData;
  LPBYTE             lpData;
  DWORD             MetaOffset;     /* special case hack for metafiles */
  BITMAP            bitmap;
  HPALETTE          hPalette;
  LPLOGPALETTE      lpLogPalette;

  if (PRIVATE_FORMAT(FormatHeader->FormatID))
      FormatHeader->FormatID = (UINT)RegisterClipboardFormat(FormatHeader->Name);

  /* Special case hack for metafiles to get hData referencing
   * the metafile bits, not the METAFILEPICT structure.
   */

  switch (FormatHeader->FormatID)
    {
      case CF_METAFILEPICT:
          if (fNTReadFileFormat)
              MetaOffset = sizeof(METAFILEPICT);
          else
              MetaOffset = SIZE_OF_WIN31_METAFILEPICT_STRUCT;
          break;
      case CF_BITMAP:
          if (fNTReadFileFormat)
              MetaOffset = sizeof(BITMAP);
          else
              MetaOffset = SIZE_OF_WIN31_BITMAP_STRUCT;
          break;
      default:
          MetaOffset = 0;
          break;
    }


  if (!(hData = GlobalAlloc(GHND, FormatHeader->DataLen - MetaOffset)))
      return(FALSE);

  if (!(lpData = GlobalLock(hData)))
    {
      GlobalFree(hData);
      return(FALSE);
    }

  _llseek(fh, FormatHeader->DataOffset + MetaOffset, 0);
  if(!lread(fh, lpData, FormatHeader->DataLen - MetaOffset))
    {
      /* Error in reading the file */
      GlobalUnlock(hData);
      GlobalFree(hData);
      return(FALSE);
    }

  GlobalUnlock(hData);

  /* As when we write these we have to special case a few of
   * these guys.  This code and the write code should match in terms
   * of the sizes and positions of data blocks being written out.
   */

  switch (FormatHeader->FormatID)
    {
      case CF_ENHMETAFILE:
        {
          HENHMETAFILE     hEMF;

          hEMF = (HENHMETAFILE)SetEnhMetaFileBits(FormatHeader->DataLen, lpData);
          GlobalUnlock(hData);
          GlobalFree(hData);
          hData = hEMF;          /* Stuff this in the clipboard */
          break;
        }
      case CF_METAFILEPICT:
        {
          HANDLE            hMF;
          HANDLE            hMFP;
          LPMETAFILEPICT    lpMFP;

          /* Create the METAFILE with the bits we read in. */

          if (!(hMF = SetMetaFileBitsEx(FormatHeader->DataLen, lpData)))  /* portable code */
              return(FALSE);

          /* Alloc a METAFILEPICT header. */

          if (!(hMFP = GlobalAlloc(GHND, (DWORD)sizeof(METAFILEPICT))))
              return(FALSE);

          if (!(lpMFP = (LPMETAFILEPICT)GlobalLock(hMFP)))
            {
              GlobalFree(hMFP);
              return(FALSE);
            }

          /* Reposition to the start of the METAFILEPICT header. */
          _llseek(fh, FormatHeader->DataOffset, 0);

          /* Read it in. */
          if (fNTReadFileFormat)
              _lread(fh, (LPBYTE)lpMFP, sizeof(METAFILEPICT));
          else {
              /* If we read a win 3.1 metafile we have to read the fields
                 one after the other as they aren't of the same size as
                 the corresponding Win 3.1 METAFILEPICT structure fields.
                 We initialize the fields to zero their hight word.
                 [pierrej 5/27/92]                                        */
              lpMFP->mm = 0;
              lpMFP->xExt = 0;
              lpMFP->yExt = 0;
              _lread(fh, (LPBYTE)&(lpMFP->mm), sizeof(WORD));
              _lread(fh, (LPBYTE)&(lpMFP->xExt), sizeof(WORD));
              _lread(fh, (LPBYTE)&(lpMFP->yExt), sizeof(WORD));
                /* No, we don't need to read in the handle, we wouldn't
                   use it anyways.  [pierrej, 5/27/92]                   */
            }


          lpMFP->hMF = hMF;         /* Update the METAFILE handle  */
          GlobalUnlock(hMFP);       /* Unlock the header           */
          hData = hMFP;             /* Stuff this in the clipboard */
          break;
        }

      case CF_BITMAP:
          /* Reposition to the start of the METAFILEPICT header. */
          _llseek(fh, FormatHeader->DataOffset, 0);

          /* Read it in. */
          if (fNTReadFileFormat)
              _lread(fh, (LPBYTE)&bitmap, sizeof(BITMAP));
          else {
              /* If we read a win 3.1 bitmap we have to read the fields
                 one after the other as they aren't of the same size as
                 the corresponding Win 3.1 BITMAP structure fields.
                 We initialize the fields to zero their hight word or byte.
                 [pierrej 5/27/92]                                        */

              bitmap.bmType = 0;
              bitmap.bmWidth = 0;
              bitmap.bmHeight = 0;
              bitmap.bmWidthBytes = 0;
              bitmap.bmPlanes = 0;
              bitmap.bmBitsPixel = 0;
              bitmap.bmBits = NULL;
              _lread(fh, (LPBYTE)&(bitmap.bmType), sizeof(WORD));
              _lread(fh, (LPBYTE)&(bitmap.bmWidth), sizeof(WORD));
              _lread(fh, (LPBYTE)&(bitmap.bmHeight), sizeof(WORD));
              _lread(fh, (LPBYTE)&(bitmap.bmWidthBytes), sizeof(WORD));
              _lread(fh, (LPBYTE)&(bitmap.bmPlanes), sizeof(BYTE));
              _lread(fh, (LPBYTE)&(bitmap.bmBitsPixel), sizeof(BYTE));
              _lread(fh, (LPBYTE)&(bitmap.bmBits), sizeof(LPVOID));
            }

          if (!(lpData = GlobalLock(hData)))
             {
             GlobalFree(hData);
             return FALSE;
             }

          bitmap.bmBits = lpData;

          /* If this fails we should avoid doing the SetClipboardData()
           * below with the hData check.
           */

          hBitmap = CreateBitmapIndirect(&bitmap);

          GlobalUnlock(hData);
          GlobalFree(hData);
          hData = hBitmap;          /* Stuff this in the clipboard */
          break;

      case CF_DIB:
         break;

      case CF_PALETTE:
          if (!(lpLogPalette = (LPLOGPALETTE)GlobalLock(hData)))
            {
              GlobalFree(hData);
              return(FALSE);
            }

          /* Create a logical palette. */
          if (!(hPalette = CreatePalette(lpLogPalette)))
            {
              GlobalUnlock(hData);
              GlobalFree(hData);
              return(FALSE);
            }
          GlobalUnlock(hData);
          GlobalFree(hData);

          hData = hPalette;         /* Stuff this into clipboard */
          break;
    }

  if (!hData)
      return(FALSE);

  SetClipboardData(FormatHeader->FormatID, hData);
  return(TRUE);
}


/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  ClipbrdVScroll() -                                                            */
/*                                                                            */
/*--------------------------------------------------------------------------*/

/* Scroll contents of window vertically, according to action code in wParam. */

void ClipbrdVScroll(
HWND hwnd,
WORD wParam,
WORD wThumb)
{
  INT           cyWindow;
  LONG          dyScroll;
  LONG          cyScrollT;
  LONG          dyScrollAbs;
  LONG          cyPartialChar;

  /* Ensure that all the bits are valid first, before scrolling them */
  UpdateWindow(hwnd);

  cyScrollT = cyScrollNow;
  cyWindow = rcWindow.bottom - rcWindow.top;

  /* Compute scroll results as an effect on cyScrollNow */
  switch (wParam)
    {
      case SB_LINEUP:
          cyScrollT -= cyLine;
          break;

      case SB_LINEDOWN:
          cyScrollT += cyLine;
          break;

      case SB_THUMBPOSITION:
          cyScrollT = (LONG)(((LONG)wThumb * (LONG)cyScrollLast) / VPOSLAST);
          break;

      case SB_PAGEUP:
      case SB_PAGEDOWN:
        {
          INT   cyPageScroll;

          cyPageScroll = cyWindow - cyLine;

          if (cyPageScroll < (INT)cyLine)
              cyPageScroll = cyLine;

          cyScrollT += (wParam == SB_PAGEUP) ? -cyPageScroll : cyPageScroll;
          break;
        }

      default:
          return;
    }

  if ((cyScrollT < 0) || (cyScrollLast <= 0))
      cyScrollT = 0;
  else if (cyScrollT > cyScrollLast)
      cyScrollT = cyScrollLast;
  else if ((cyPartialChar = cyScrollT % cyLine) != 0)
    {
      /* Round to the nearest character increment. */
      if (cyPartialChar > (LONG)(cyLine >> 1))
          cyScrollT += cyLine;
      cyScrollT -= cyPartialChar;
    }

  dyScroll = cyScrollNow - cyScrollT;
  if (dyScroll > 0)
      dyScrollAbs = dyScroll;
  else if (dyScroll < 0)
      dyScrollAbs = -dyScroll;
  else
      return;                       /* Scrolling has no effect here. */

  cyScrollNow = cyScrollT;

  if (dyScrollAbs >= rcWindow.bottom - rcWindow.top)
      /* ScrollWindow does not handle this case */
      InvalidateRect(hwnd, (LPRECT)&rcWindow, TRUE);
  else
      ScrollWindow(hwnd, 0, (INT)dyScroll, &rcWindow, &rcWindow);

  UpdateWindow(hwnd);

  SetScrollPos(hwnd,
               SB_VERT,
               (cyScrollLast <= 0) ? 0 : (INT)((cyScrollT * (DWORD)VPOSLAST) / cyScrollLast),
               TRUE);
}


/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  ClipbrdHScroll() -                                                            */
/*                                                                            */
/*--------------------------------------------------------------------------*/

/* Scroll contents of window horizontally, according to op code in wParam. */

void NEAR PASCAL ClipbrdHScroll(HWND hwnd,WORD wParam,WORD wThumb)

{
  INT           cxWindow;
  register INT  dxScroll;
  register INT  cxScrollT;
  INT           dxScrollAbs;
  LONG          cxPartialChar;

  cxScrollT = cxScrollNow;
  cxWindow = rcWindow.right - rcWindow.left;

  /* Compute scroll results as an effect on cxScrollNow */
  switch (wParam)
    {
      case SB_LINEUP:
          cxScrollT -= cxChar;
          break;

      case SB_LINEDOWN:
          cxScrollT += cxChar;
          break;

      case SB_THUMBPOSITION:
          cxScrollT = (INT)(((LONG)wThumb * (LONG)cxScrollLast) / HPOSLAST);
          break;

      case SB_PAGEUP:
      case SB_PAGEDOWN:
        {
          INT   cxPageScroll;

          cxPageScroll = cxWindow - cxChar;
          if (cxPageScroll < (INT)cxChar)
              cxPageScroll = cxChar;

          cxScrollT += (wParam == SB_PAGEUP) ? -cxPageScroll : cxPageScroll;
          break;
        }

      default:
          return;
    }

  if ((cxScrollT < 0) || (cxScrollLast <= 0))
      cxScrollT = 0;
  else if (cxScrollT > cxScrollLast)
      cxScrollT = cxScrollLast;
  else if ((cxPartialChar = cxScrollT % cxChar) != 0)
    { /* Round to the nearest character increment */
      if (cxPartialChar > (LONG)(cxChar >> 1))
          cxScrollT += cxChar;
      cxScrollT -= cxPartialChar;
    }

  /* Now we have a good cxScrollT value */

  dxScroll = cxScrollNow - cxScrollT;
  if (dxScroll > 0)
      dxScrollAbs = dxScroll;
  else if (dxScroll < 0)
      dxScrollAbs = -dxScroll;
  else
      return;                       /* Scrolling has no effect here. */

  cxScrollNow = cxScrollT;

  if (dxScrollAbs >= rcWindow.right - rcWindow.left)
      /* ScrollWindow does not handle this case */
      InvalidateRect( hwnd, (LPRECT) & rcWindow, TRUE );
  else
      ScrollWindow(hwnd, dxScroll, 0, (LPRECT)&rcWindow, (LPRECT)&rcWindow);

  UpdateWindow(hwnd);

  SetScrollPos(hwnd,
               SB_HORZ,
               (cxScrollLast <= 0) ? 0 : (INT)(((DWORD)cxScrollT * (DWORD)HPOSLAST) / (DWORD)cxScrollLast),
               TRUE );
}


/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  DibPaletteSize() -                                                            */
/*                                                                            */
/*--------------------------------------------------------------------------*/

INT NEAR PASCAL DibPaletteSize(LPBITMAPINFOHEADER  lpbi)

{
  register INT  bits;

  /* With the new format headers, the size of the palette is in biClrUsed
   * else is dependent on bits per pixel.
   */
  if (lpbi->biSize != sizeof(BITMAPCOREHEADER))
    {
      if (lpbi->biClrUsed != 0)
          return((WORD)lpbi->biClrUsed * sizeof(RGBQUAD));

      bits = lpbi->biBitCount;
      return((bits == 24) ? 0 : (1 << bits) * sizeof(RGBQUAD));
    }
  else
    {
      bits = ((LPBITMAPCOREHEADER)lpbi)->bcBitCount;
      return((bits == 24) ? 0 : (1 << bits) * sizeof(RGBTRIPLE));
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  DibGetInfo() -                                                            */
/*                                                                            */
/*--------------------------------------------------------------------------*/

void NEAR PASCAL DibGetInfo(HANDLE hdib,LPBITMAP pbm)

{
  LPBITMAPINFOHEADER lpbi;

  lpbi = (LPBITMAPINFOHEADER)GlobalLock(hdib);

  if (lpbi->biSize != sizeof(BITMAPCOREHEADER))
    {
      pbm->bmWidth  = (INT)lpbi->biWidth;
      pbm->bmHeight = (INT)lpbi->biHeight;
    }
  else
    {
      pbm->bmWidth  = (INT)((LPBITMAPCOREHEADER)lpbi)->bcWidth;
      pbm->bmHeight = (INT)((LPBITMAPCOREHEADER)lpbi)->bcHeight;
    }

  GlobalUnlock(hdib);
}


/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  DrawDib() -                                                             */
/*                                                                            */
/*--------------------------------------------------------------------------*/

BOOL NEAR PASCAL DrawDib(HDC hdc,INT x0,INT y0,HANDLE hdib)

{
  BITMAP                bm;
  LPBYTE                 lpBits;
  LPBITMAPINFOHEADER    lpbi;

  if (!hdib)
      return(FALSE);

  lpbi = (LPBITMAPINFOHEADER)GlobalLock(hdib);

  if (!lpbi)
      return(FALSE);

  DibGetInfo(hdib, (LPBITMAP)&bm);

  lpBits = (LPBYTE)lpbi + (WORD)lpbi->biSize + DibPaletteSize(lpbi);

  SetDIBitsToDevice(hdc,
                    x0, y0, bm.bmWidth, bm.bmHeight,
                    0, 0,
                    0, bm.bmHeight,
                    lpBits, (LPBITMAPINFO)lpbi,
                    DIB_RGB_COLORS);

  GlobalUnlock(hdib);
  return(TRUE);
}


/*--------------------------------------------------------------------------
  FShowDIBitmap() -

  Parameters:
      hdc - DC to draw into.
      prc - Pointer to bounds rectangle within DC.
      hdib - DIB to draw.
      cxScroll, cyScroll - Position the window's scrolled to.
--------------------------------------------------------------------------*/

BOOL NEAR PASCAL FShowDIBitmap(register HDC hdc,PRECT prc,
            HANDLE hdib /* Bitmap in DIB format */,INT cxScroll,INT cyScroll)

{
  BITMAP    bm;

  DibGetInfo(hdib, (LPBITMAP)&bm);

  if (cyScrollLast == -1)
    {
      /* Compute last scroll offset into bitmap */
      cyScrollLast = bm.bmHeight - (rcWindow.bottom - rcWindow.top);
      if (cyScrollLast < 0)
          cyScrollLast = 0;
    }

  if (cxScrollLast == -1)
    {
      /* Compute last scroll offset into bitmap */
      cxScrollLast = bm.bmWidth - (rcWindow.right - rcWindow.left);
      if (cxScrollLast < 0)
          cxScrollLast = 0;
    }

  SaveDC(hdc);
  IntersectClipRect(hdc, prc->left, prc->top, prc->right, prc->bottom);
  /* MSetViewportOrg(hdc, prc->left - cxScroll, prc->top - cyScroll); */
  DrawDib(hdc, -cxScroll, -cyScroll, hdib);
  RestoreDC(hdc, -1);
  return(TRUE);
}


/*--------------------------------------------------------------------------
  FShowBitmap() -

  Purpose: Draw a bitmap in the given HDC.

  Parameters:
      hdc - hDC to draw into.
      prc - Bounds rectangle in the DC.
      hbm - The bitmap to draw
      cxScroll, cyScroll - Where the DC's scrolled to

  Returns:
      TRUE on success, FALSE on failure.
--------------------------------------------------------------------------*/

BOOL NEAR PASCAL FShowBitmap(HDC hdc,register PRECT prc,
                    HBITMAP hbm,INT cxScroll,INT cyScroll)
{
  register HDC  hMemDC;
  BITMAP        bitmap;
  INT           cxBlt, cyBlt;
  INT           cxRect, cyRect;

  if ((hMemDC = CreateCompatibleDC(hdc)) == NULL)
      return(FALSE);

  SelectObject(hMemDC, (HBITMAP)hbm);
  GetObject((HBITMAP)hbm, sizeof(BITMAP), (LPBYTE)&bitmap);

  if (cyScrollLast == -1)
    {
      /* Compute last scroll offset into bitmap */
      cyScrollLast = bitmap.bmHeight - (rcWindow.bottom - rcWindow.top);
      if (cyScrollLast < 0)
          cyScrollLast = 0;
    }

  if (cxScrollLast == -1)
    {
      /* Compute last scroll offset into bitmap */
      cxScrollLast = bitmap.bmWidth - (rcWindow.right - rcWindow.left);
      if (cxScrollLast < 0)
          cxScrollLast = 0;
    }

  cxRect = prc->right - prc->left;
  cyRect = prc->bottom - prc->top;

/* Bug #10656:  Subtract 1 so we won't fall off the end of the bitmap
 *              (the bitmap is zero based).
 *   11 January 1992            Clark R. Cyr
 */
     cxBlt = min(cxRect, bitmap.bmWidth - cxScroll);
     cyBlt = min(cyRect, bitmap.bmHeight - cyScroll);

/* Bug #14131:  Instead of subtracting 1 from the amount to blt, subtract 1
 *              from the offset to blt from, thus allowing for a full picture
 *              when no scrolling is needed.
 *   06 February 1992           Clark R. Cyr
 */
     if ((cxBlt != cxRect) && (cxScroll > 0))
          cxScroll--;
     if ((cyBlt != cyRect) && (cyScroll > 0))
          cyScroll--;

  BitBlt(hdc, prc->left, prc->top,
         cxBlt, cyBlt,
         hMemDC,
         cxScroll, cyScroll,     /* X,Y offset into source DC */
         SRCCOPY);

  DeleteDC(hMemDC);
  return(TRUE);
}

#define DXPAL  (cyLine)
#define DYPAL  (cyLine)

/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  FShowPalette() -                                                            */
/*                                                                            */
/*--------------------------------------------------------------------------*/

BOOL NEAR PASCAL FShowPalette(register HDC hdc,register PRECT prc,
                    HPALETTE hpal,INT cxScroll,INT cyScroll)

{
  INT     n;
  INT     x, y;
  INT     nx, ny;
  INT     nNumEntries = 0;
  RECT    rc;
  HBRUSH  hbr;

  if (!hpal)
      return(FALSE);

  GetObject(hpal, sizeof(INT), (LPBYTE)&nNumEntries);

  nx = (rcWindow.right - rcWindow.left) / DXPAL;

  if (nx == 0)
      nx = 1;

  ny = (nNumEntries + nx - 1) / nx;

  if (cyScrollLast == -1)
    {
      /* Compute last scroll offset into bitmap */
      cyScrollLast = ny * DYPAL - (rcWindow.bottom - rcWindow.top);
      if (cyScrollLast < 0)
          cyScrollLast = 0;
    }

  if (cxScrollLast == -1)
    {
      /* Compute last scroll offset into bitmap */
      cxScrollLast = 0;
    }

  SaveDC(hdc);
  IntersectClipRect(hdc, prc->left, prc->top, prc->right, prc->bottom);
  MSetViewportOrg(hdc, prc->left - cxScroll, prc->top - cyScroll);

  SelectPalette(hdc, hpal, FALSE);
  RealizePalette(hdc);

  x = 0;
  y = -((int)DYPAL);

  for (n=0; n < nNumEntries; n++, x += DXPAL)
    {
      if (n % nx == 0)
        {
          x = 0;
          y += DYPAL;
        }

      rc.left        = x;
      rc.top        = y;
      rc.right        = x + DXPAL;
      rc.bottom = y + DYPAL;

      if (RectVisible(hdc,&rc))
        {
          InflateRect(&rc, -1, -1);
          FrameRect(hdc, &rc, GetStockObject(BLACK_BRUSH));
          InflateRect(&rc, -1, -1);
          hbr = CreateSolidBrush(PALETTEINDEX(n));
          FillRect(hdc, &rc, hbr);
          DeleteObject(hbr);
        }
    }
  RestoreDC(hdc, -1);
  return(TRUE);
}


/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  PxlConvert() -                                                            */
/*                                                                            */
/*--------------------------------------------------------------------------*/

/* Return the # of pixels spanned by 'val', a measurement in coordinates
 * appropriate to mapping mode mm.  'pxlDeviceRes' gives the resolution
 * of the device in pixels, along the axis of 'val'. 'milDeviceRes' gives
 * the same resolution measurement, but in millimeters.
 */

INT NEAR PASCAL PxlConvert(INT mm, INT val,INT pxlDeviceRes,INT milDeviceRes)
{
  register WORD wMult = 1;
  register WORD wDiv = 1;
  DWORD         ulPxl;
  DWORD         ulDenom;
  /* Should be a constant!  This works around a compiler bug as of 07/14/85. */
  DWORD         ulMaxInt = MAXSHORT;

  if (milDeviceRes == 0)
    {
      /* to make sure we don't get divide-by-0 */
      return(0);
    }

  switch (mm)
    {
      case MM_LOMETRIC:
          wDiv = 10;
          break;

      case MM_HIMETRIC:
          wDiv = 100;
          break;

      case MM_TWIPS:
          wMult = 254;
          wDiv = 14400;
          break;

      case MM_LOENGLISH:
          wMult = 2540;
          wDiv = 10000;
          break;

      case MM_HIENGLISH:
          wMult = 254;
          wDiv = 10000;
          break;

      case MM_TEXT:
          return(val);

      case MM_ISOTROPIC:
      case MM_ANISOTROPIC:
              /* These picture types have no original size */
      default:
              return(0);
    }

  /* Add denominator - 1 to numerator, to avoid roundoff */

  ulDenom = (DWORD)wDiv * (DWORD)milDeviceRes;
  ulPxl = (((DWORD)((DWORD)wMult * (DWORD)val * (DWORD)pxlDeviceRes)) + ulDenom - 1) / ulDenom;

  return((ulPxl > ulMaxInt) ? 0 : (INT)ulPxl);
}


/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  FShowEnhMetaFile() -                                                    */
/*                                                                            */
/*--------------------------------------------------------------------------*/

/* Display an enhanced metafile in the specified rectangle. */

BOOL NEAR PASCAL FShowEnhMetaFile(
register HDC        hdc,
HANDLE hemf,
LPRECT prc)
{
  INT               level;
  INT               f = FALSE;
  ENHMETAHEADER     EnhHeader;

      if ((level = SaveDC( hdc )) != 0)
        {

          cyScrollLast = 0;
          cxScrollLast = 0;

          GetEnhMetaFileHeader(hemf, sizeof(ENHMETAHEADER), &EnhHeader);

          rcWindow.top--;
          rcWindow.left--;

          SetWindowOrgEx(hdc, -prc->left, -prc->top, NULL);
          f = PlayEnhMetaFile(hdc, hemf, &rcWindow);

          rcWindow.top++;
          rcWindow.left++;
          RestoreDC(hdc, level);
        }
  return(f);
}

/*--------------------------------------------------------------------------
  FShowMetaFilePict()

  Display a metafile in the specified rectangle.
--------------------------------------------------------------------------*/


BOOL NEAR PASCAL FShowMetaFilePict(
register HDC   hdc,
register PRECT prc,
HANDLE         hmfp,
INT            cxScroll,
INT            cyScroll)
{
  INT               level;
  INT               cxBitmap;
  INT               cyBitmap;
  INT               f = FALSE;
  LPMETAFILEPICT    lpmfp;

  if ((lpmfp = (LPMETAFILEPICT)GlobalLock( hmfp )) != NULL)
    {
      METAFILEPICT mfp;

      mfp = *lpmfp;
      GlobalUnlock( hmfp );

      if ((level = SaveDC( hdc )) != 0)
        {
          /* Compute size of picture to be displayed */
          switch (mfp.mm)
             {
          case MM_ISOTROPIC:
          case MM_ANISOTROPIC:
             /* Not scrollable.  Resize these into the given rect. */
             cyScrollLast = 0;
             cxScrollLast = 0;
             cxBitmap = rcWindow.right - rcWindow.left;
             cyBitmap = rcWindow.bottom - rcWindow.top;
             break;

          default:
             cxBitmap = PxlConvert(mfp.mm, mfp.xExt,
                  GetDeviceCaps(hdc, HORZRES),
                  GetDeviceCaps(hdc, HORZSIZE)
                  );
             cyBitmap = PxlConvert(mfp.mm, mfp.yExt,
                  GetDeviceCaps(hdc, VERTRES),
                  GetDeviceCaps(hdc, VERTSIZE)
                  );
             if (!cxBitmap || !cyBitmap)
                 goto NoDisplay;

             if (cxScrollLast == -1)
                {
                cxScrollLast = cxBitmap - (rcWindow.right - rcWindow.left);
                if (cxScrollLast < 0)
                   cxScrollLast = 0;
                }

             if (cyScrollLast == -1)
                {
                cyScrollLast = cyBitmap - (rcWindow.bottom - rcWindow.top);
                if (cyScrollLast < 0)
                   cyScrollLast = 0;
                }
             break;
             }

          /* We make the "viewport" to be an area the same size as the
           * clipboard object, and set the origin and clip region so as
           * to show the area we want. Note that the viewport may well be
           * bigger than the window.
           */
          // IntersectClipRect(hdc, prc->left, prc->top, prc->right, prc->bottom);
          SetMapMode(hdc, mfp.mm);

          // MSetViewportOrg(hdc, cxScroll, cyScroll);
          switch (mfp.mm)
            {
              case MM_ANISOTROPIC:
                  if (mfp.xExt && mfp.yExt)
                    {
                      /* So we get the correct shape rectangle when
                       * SetViewportExtEx gets called.
                       */
                      MSetWindowExt(hdc, mfp.xExt, mfp.yExt);
                    }
                  /* FALL THRU */

              case MM_ISOTROPIC:
                  MSetViewportExt(hdc, cxBitmap, cyBitmap);
                  break;
            }

          /* Since we may have scrolled, force brushes to align */
          // MSetBrushOrg(hdc, cxScroll - prc->left, cyScroll - prc->top);
          f = PlayMetaFile(hdc, mfp.hMF);
NoDisplay:
          RestoreDC(hdc, level);
        }
    }
  return(f);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ShowString() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Blank rcWindow and show the string on the top line of the client area. */

void NEAR PASCAL ShowString(HDC        hdc,WORD id)

{
  TCHAR        szBuffer[BUFFERLEN];

  /* Cancel any scrolling effects. */
  cyScrollNow = 0;
  cxScrollNow = 0;

  LoadString(hInst, id, szBuffer, BUFFERLEN);
  FillRect(hdc, &rcWindow, hbrBackground);
  DrawText(hdc, szBuffer, -1, &rcWindow, DT_CENTER | DT_WORDBREAK | DT_NOCLIP | DT_TOP);
}


/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  CchLineA() -                                                             */
/*                                                                            */
/*--------------------------------------------------------------------------*/

/* Determine the # of characters in one display line's worth of lpch.
 * lpch is assumed to be an ansi string.
 *
 * Return the following:
 *       HI WORD:    # of chars to display (excludes CR, LF; will not
 *                   exceed cchLine)
 *       LO WORD:    offset of start of next line in lpch; If the current line
 *                   is NULL terminated, this contains offset to the NULL char;
 *       In RgchBuf: characters to display
 *
 *   Expands Tabs
 *
 *   Accepts any of the following as valid end-of-line terminators:
 *       CR, LF, CR-LF, LF-CR, NULL
 *   Callers may test for having reached NULL by (lpch[LOWORD] == '\0')
 */

LONG NEAR PASCAL CchLineA(HDC hDC, CHAR rgchBuf[],
#ifdef WIN16
                    CHAR huge *lpch,
#else
                    CHAR FAR  *lpch,
#endif
                    INT cchLine,WORD wWidth)

{
  CHAR          ch;
  CHAR         *pch = rgchBuf;
  register INT  cchIn = 0;
  register INT  cchOut = 0;
  INT           iMinNoOfChars;
  SIZE          size;
  INT           iTextWidth = 0;

  iMinNoOfChars = wWidth / cxMaxCharWidth;

  while (cchOut < cchLine)
    {
      switch (ch = *(lpch + (DWORD)cchIn++))
        {
          case '\0':
               /* cchIn is already incremented; So, it is pointing to
               * a character beyond the NULL; So, decrement it.
               */
              cchIn--;
              goto DoubleBreak;

          case '\015':  /* CR */
          case '\012':  /* LF */
              if ((lpch[cchIn] == '\015') || (lpch[cchIn] == '\012'))
                  cchIn++;
              goto DoubleBreak;

          case '\011':  /* TAB */
            {
              INT   cchT = 8 - (cchOut % 8);

              /* Check if the width has exceeded or the total
               * number of characters has exceeded
               */
              if (((WORD)(iTextWidth + cchT * cxChar) > wWidth) || ((cchOut+cchT) >= cchLine))
                  /* Tab causes wrap to next line */
                  goto DoubleBreak;

              while (cchT--)
                  rgchBuf[cchOut++] = ' ';
              break;
            }

          default:
              rgchBuf[cchOut++] = ch;
#ifdef DBCS
              if( IsDBCSLeadByte(ch) )
                  rgchBuf[cchOut++] = *(lpch + (DWORD)cchIn++);
#endif
              break;
        }

      /* Check if the width has been exceeded. */
      if (cchOut >= iMinNoOfChars)
        {
          GetTextExtentPointA(hDC, rgchBuf, cchOut, (LPSIZE)&size);
          iTextWidth = size.cx;
          if ((WORD)iTextWidth == wWidth)
              break;
          else if((WORD)iTextWidth > wWidth)
              {
#ifdef DBCS
                if( IsDBCSLeadByte(ch) ){
                    cchOut--;
                    cchIn--;
                }
#endif
                cchOut--;
                cchIn--;
                break;
              }

          iMinNoOfChars += (wWidth - iTextWidth) / cxMaxCharWidth;
        }
    }
DoubleBreak:
  return(MAKELONG(cchIn, cchOut));
}

/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  CchLineW() -                                                             */
/*                                                                            */
/*--------------------------------------------------------------------------*/

/*Same as previous function but takes unicode strings.
 */

LONG NEAR PASCAL CchLineW(HDC hDC, WCHAR rgchBuf[],
                    WCHAR FAR  *lpch,
                    INT cchLine,WORD wWidth)

{
  WCHAR                ch;
  WCHAR                *pch = rgchBuf;
  register INT        cchIn = 0;
  register INT        cchOut = 0;
  INT                iMinNoOfChars;
  INT           iTextWidth = 0;
  SIZE          size;

  iMinNoOfChars = wWidth / cxMaxCharWidth;

  while (cchOut < cchLine)
    {
      switch (ch = *(lpch + (DWORD)cchIn++))
        {
          case L'\0':
               /* cchIn is already incremented; So, it is pointing to
               * a character beyond the NULL; So, decrement it.
               */
              cchIn--;
              goto DoubleBreak;

          case L'\015':  /* CR */
          case L'\012':  /* LF */
              if ((lpch[cchIn] == L'\015') || (lpch[cchIn] == L'\012'))
                  cchIn++;
              goto DoubleBreak;

          case L'\011':  /* TAB */
            {
              INT   cchT = 8 - (cchOut % 8);

              /* Check if the width has exceeded or the total
               * number of characters has exceeded
               */
              if (((WORD)(iTextWidth + cchT * cxChar) > wWidth) || ((cchOut+cchT) >= cchLine))
                  /* Tab causes wrap to next line */
                  goto DoubleBreak;

              while (cchT--)
                  rgchBuf[cchOut++] = L' ';
              break;
            }

          default:
              rgchBuf[cchOut++] = ch;
              break;
        }

      /* Check if the width has been exceeded. */
      if (cchOut >= iMinNoOfChars)
       {
          GetTextExtentPointW(hDC, rgchBuf, cchOut, &size);
          iTextWidth = size.cx;
          if ((WORD)iTextWidth == wWidth)
              break;
          else if((WORD)iTextWidth > wWidth)
              {
                cchOut--;
                cchIn--;
                break;
              }

          iMinNoOfChars += (wWidth - iTextWidth) / cxMaxCharWidth;
        }
    }
DoubleBreak:
  return(MAKELONG(cchIn, cchOut));
}


#define cchLineMax  200

/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  ShowText() -                                                            */
/*                                                                            */
/*--------------------------------------------------------------------------*/

void NEAR PASCAL ShowText(register HDC        hdc,PRECT prc,HANDLE h,INT cyScroll,
                         BOOL fUnicode)

{
#ifdef WIN16
  CHAR huge *lpch;
#else
  CHAR FAR  *lpch;
#endif
  INT       yT;
  INT       cLine;
  INT       cLineAllText = 0;
  RECT      rc;
  INT       yLine;
  INT       iLineFirstShow;
  WORD      wLen;
  WORD      wWidth;
  CHAR      rgch[cchLineMax*sizeof(WCHAR)];

  rc = *prc;

  /* Expand repaint rectangle as necessary to hold an exact number of
   * lines and start on an even line boundary. This is because we may
   * get arbitrarily weird repaint rectangles when popups are moved.
   * Scrolling repaint areas should require no adjustment.
   */
  rc.top -= (rc.top - rcWindow.top) % cyLine;

  /* If expanding the repaint rectangle to the next line expands it */
  /* beyond the bottom of my window, contract it one line.          */
  if ((yT = (rc.bottom - rc.top) % cyLine) != 0)
      if ((rc.bottom += cyLine - yT) > rcWindow.bottom)
          rc.bottom -= cyLine;

  if (rc.bottom <= rc.top)
      return;

  if (((wWidth = (WORD)(rcWindow.right - rcWindow.left)) <= 0) ||
      ((cLine = (rc.bottom - rc.top) / cyLine) <= 0)         ||
      (NULL == (lpch = (LPSTR)GlobalLock(h))) )
      {
        /* Bad Rectangle or Bad Text Handle */
        ShowString(hdc, IDS_ERROR);
        return;
      }

  /* Advance lpch to point at the text for the first line to show. */
  iLineFirstShow = cyScroll / cyLine;

  /* Advance lpch to point at text for that line. */
  if (!fUnicode)
      while ((*lpch) && (iLineFirstShow--))
        {
          lpch += LOWORD(CchLineA(hdc, rgch, lpch, cchLineMax, wWidth));
          cLineAllText++;
        }
  else
      while ((*((WCHAR *)lpch)) && (iLineFirstShow--))
        {
          lpch += ((LOWORD(CchLineW(hdc, (WCHAR *)rgch, (WCHAR FAR *)lpch, cchLineMax, wWidth)))*sizeof(WCHAR));
          cLineAllText++;
        }

  /* Display string, line by line */
  yLine = rc.top;
  while (cLine--)
    {
      LONG lT;

      if (!fUnicode)
         lT = CchLineA(hdc, rgch, lpch, cchLineMax, wWidth);
      else
         lT = CchLineW(hdc, (WCHAR *)rgch, (WCHAR FAR *)lpch, cchLineMax, wWidth);
      wLen = LOWORD(lT);
      if (!fUnicode) {
          TextOutA(hdc, rc.left, yLine, (LPSTR) rgch, HIWORD(lT));
          lpch += wLen;
      } else {
          if (!TextOutW(hdc, rc.left, yLine, (LPCWSTR) rgch, HIWORD(lT))) {
            GetLastError();
            }
          lpch += (wLen * sizeof(WCHAR));
      }
      yLine += cyLine;
      cLineAllText++;
      if ((!fUnicode && (*lpch == 0)) || (fUnicode && (*((WCHAR *)lpch) == L'\0')))
          break;
    }

  if (cxScrollLast == -1)
      /* We don't use horiz scroll for text */
      cxScrollLast = 0;

  if (cyScrollLast == -1)
    {
      INT   cLineInRcWindow;

      /* Validate y-size of text in clipboard. */
      /* Adjust rcWindow dimensions for text display */
      cLineInRcWindow = (rcWindow.bottom - rcWindow.top) / cyLine;

      do {
          if (!fUnicode)
              lpch += LOWORD(CchLineA(hdc, rgch, lpch, cchLineMax, wWidth));
          else
              lpch += ((LOWORD(CchLineW(hdc, (WCHAR *)rgch, (WCHAR FAR *)lpch, cchLineMax, wWidth)))*sizeof(WCHAR));
          cLineAllText++;
      } while ((!fUnicode && (*lpch != 0)) || (fUnicode && ((*lpch != 0) || (*(lpch+1) != 0))));

      cyScrollLast = (cLineAllText - cLineInRcWindow) * cyLine;
      if (cyScrollLast < 0)
         {
         cyScrollLast = 0;
         }

      /* Restrict rcWindow so that it holds an exact # of text lines */
      rcWindow.bottom = rcWindow.top + (cLineInRcWindow * cyLine);
    }
  GlobalUnlock(h);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SendOwnerMessage() -                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void SendOwnerMessage(
UINT message,
WPARAM wParam,
LPARAM lParam)
{
register HWND hwndOwner;

/* Send a message to the clipboard owner, if there is one */
hwndOwner = GetClipboardOwner();

if (hwndOwner != NULL)
   {
   SendMessage(hwndOwner, message, wParam, lParam);
   }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SendOwnerSizeMessage() -                                                */
/*                                                                          */
/*--------------------------------------------------------------------------*/
/* Send WM_SIZECLIPBOARD message to clipboard owner.
 *    wParam is a handle to the clipboard window
 *    LOWORD(lParam) is a handle to the passed rect
 */
void SendOwnerSizeMessage(
HWND hwnd,
INT  left,
INT  top,
INT  right,
INT  bottom)
{
register HANDLE   hrc;
LPRECT            lprc;

if ((hrc = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
                       (LONG)sizeof(RECT))) != NULL )
   {
   if ((lprc = (LPRECT)GlobalLock(hrc)) != NULL )
      {
      lprc->top = top;
      lprc->bottom = bottom;
      lprc->left = left;
      lprc->right = right;
      GlobalUnlock(hrc);
      SendOwnerMessage(WM_SIZECLIPBOARD, (WPARAM)hwnd, (LONG)hrc);
      }
   GlobalFree(hrc);
   }
}

//
// Purpose: Return the best clipboard format we have available, given a
//    'starting' clipboard format.
//
// Parameters:
//    wFormat - The format selected on the Display menu.
//
// Returns:
//    The number of the clipboard format to use, or NULL if no clipboard
//    format matching the requested one exists.
//
////////////////////////////////////////////////////////////////////////
UINT GetBestFormat(
UINT  wFormat)
{
register UINT cFmt;
register UINT *pfmt;

if (wFormat == CBM_AUTO)
   {
   wFormat = 0;

   for (cFmt=ifmtMax, pfmt=&rgfmt[0]; cFmt--; pfmt++)
      {
      if (IsClipboardFormatAvailable(*pfmt))
         {
         wFormat = *pfmt;
         break;
         }
      }
   }
else if (!IsClipboardFormatAvailable(wFormat))
   {
   wFormat = 0;
   }
return wFormat;
}


/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  ClearClipboard() -                                                            */
/*                                                                            */
/*--------------------------------------------------------------------------*/

/* This is called to clear the clipboard.  If the clipboard is not
 *        empty the user is asked if it should be cleared.
 */

BOOL NEAR PASCAL ClearClipboard(register HWND        hwnd)

{
  CHAR          szBuffer[SMALLBUFFERLEN];
  CHAR          szLocBuffer[BUFFERLEN];

  if (CountClipboardFormats() <= 0)
      return(TRUE);

  /* Get the confirmation from the user. */
  LoadString(hInst, IDS_CLEARTITLE, szBuffer, SMALLBUFFERLEN);
  LoadString(hInst, IDS_CONFIRMCLEAR, szLocBuffer, BUFFERLEN);
  if (MessageBox(hwnd, szLocBuffer, szBuffer, MB_YESNO | MB_ICONEXCLAMATION) == IDYES)
    {
    if (!OpenClipboard(hwnd) ||
        !EmptyClipboard() ||
        !CloseClipboard() )
       {
       LoadString(hInst, IDS_ERROR, szBuffer, SMALLBUFFERLEN);
       LoadString(hInst, IDS_CLEAR, szLocBuffer, BUFFERLEN);
       MessageBox(hwnd, szLocBuffer, szBuffer, MB_OK | MB_SYSTEMMODAL | MB_ICONHAND);
       }
    InvalidateRect(hwnd, NULL, TRUE);

    return(TRUE);
    }
  return(FALSE);
}



/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  GetClipboardName() -                                                    */
/*                                                                            */
/*--------------------------------------------------------------------------*/

void NEAR PASCAL GetClipboardName(register UINT fmt,LPTSTR szName,
                                        register INT iSize)

{
  LPTSTR   lprgch;
  HANDLE  hrgch;

  *szName = 0;

  /* Get global memory that everyone can get to */
  if ((hrgch = GlobalAlloc(GPTR, (LONG)(iSize + 1))) == NULL)
      return;

  if (!(lprgch = (LPTSTR)GlobalLock(hrgch)))
      goto ExitPoint;

  switch (fmt)
    {
      case CF_RIFF:
      case CF_WAVE:
      case CF_PENDATA:
      case CF_SYLK:
      case CF_DIF:
      case CF_TIFF:
      case CF_TEXT:
      case CF_BITMAP:
      case CF_METAFILEPICT:
      case CF_OEMTEXT:
      case CF_DIB:
      case CF_PALETTE:
      case CF_DSPTEXT:
      case CF_DSPBITMAP:
      case CF_DSPMETAFILEPICT:
      case CF_UNICODETEXT:
      case CF_ENHMETAFILE:
      case CF_DSPENHMETAFILE:
          LoadString(hInst, fmt, lprgch, iSize);
          break;

      case CF_OWNERDISPLAY:           /* Clipbrd owner app supplies name */
	  *lprgch = 0;
          SendOwnerMessage(WM_ASKCBFORMATNAME, iSize, (LONG)(LPTSTR)lprgch);

          if (!*lprgch)
              LoadString(hInst, fmt, lprgch, iSize);
          break;

      default:
          GetClipboardFormatName(fmt, lprgch, iSize);
          break;
    }

  lstrcpy(szName, lprgch);

  GlobalUnlock(hrgch);
ExitPoint:
  GlobalFree(hrgch);
}


/*--------------------------------------------------------------------------

  DrawFormat() -

  Purpose: Draw the data on the clipboard, using the given format.

  Parameters:
      hdc - hDC to draw into.
      prc - Pointer to a rectangle showing bounds to paint into
      cxScroll - Horizontal position we're scrolled to (0=left)
      cyScroll - Vertical   position we're scrolled to (0=top)
      BestFormat - Format to use when drawing.

--------------------------------------------------------------------------*/
void NEAR PASCAL DrawFormat(
register HDC hdc,
PRECT prc,
INT cxScroll,
INT cyScroll,
UINT BestFormat)
{
register HANDLE   h;
HFONT             hFont;
INT               fOK = TRUE;
UINT		  wFormat = 0;

if ((BestFormat == 0))
   {
   if (CountClipboardFormats() )
      {
      ShowString(hdc, IDS_CANTDISPLAY);
      }
   }
else if ((h = GetClipboardData(/* wFormat ? wFormat :*/  BestFormat)) != NULL)
   {
   switch (BestFormat)
      {
   case CF_DSPTEXT:
   case CF_TEXT:
      ShowText(hdc, prc, h, cyScroll, FALSE);
      break;

   case CF_UNICODETEXT:
      hFont = SelectObject(hdc, hfontUni);
      ShowText(hdc, prc, h, cyScroll, TRUE);
      SelectObject(hdc, hFont);
      break;

   case CF_OEMTEXT:
      hFont = SelectObject(hdc, hfontOem);
      ShowText(hdc, prc, h, cyScroll, FALSE);
      SelectObject(hdc, hFont);
      break;

   case CF_DSPBITMAP:
   case CF_BITMAP:
      fOK = FShowBitmap(hdc, prc, h, cxScroll, cyScroll);
      break;

   case CF_DIB:
      fOK = FShowDIBitmap(hdc, prc, h, cxScroll, cyScroll);
      break;

   case CF_PALETTE:
      fOK = FShowPalette(hdc, prc, h, cxScroll, cyScroll);
      break;

   case CF_WAVE:
   case CF_RIFF:
   case CF_PENDATA:
   case CF_DIF:
   case CF_SYLK:
   case CF_TIFF:
      ShowString(hdc, IDS_BINARY);
      break;

   case CF_ENHMETAFILE:
   case CF_DSPENHMETAFILE:
      fOK = FShowEnhMetaFile(hdc, h, prc);
      break;

   case CF_DSPMETAFILEPICT:
   case CF_METAFILEPICT:
      fOK = FShowMetaFilePict(hdc, prc, h, cxScroll, cyScroll);
      break;

   /* If "Auto" is chosen and only data in unrecognised formats is
    * available, then display "Can't display data in this format".
   */
   default:
      ShowString(hdc, IDS_CANTDISPLAY);
      break;
      }
   }
else if (CountClipboardFormats()) // There's data, but we can't Get it..
   {
   ShowString(hdc, IDS_ERROR);
   }

/* If we are unable to display the data, display "<Error>" */
if (!fOK)
   {
   ShowString(hdc, IDS_NOTRENDERED);
   }
}


/*--------------------------------------------------------------------------

  DrawStuff() -

 Paint portion of current clipboard contents given by PAINT struct

 NOTE: If the paintstruct rectangle includes any part of the header, the
       whole header is redrawn.

 Parameters:
    hwnd - Window to draw in.
    pps  - Pointer to PAINTSTRUCT to use.

 Returns:
    Nothing.
----------------------------------------------------------------------------*/
void NEAR PASCAL DrawStuff(
HWND                  hwnd,
register PAINTSTRUCT *pps)
{
register HDC  hdc;
RECT          rcPaint;
RECT          rcClient;
UINT          BestFormat;

hdc = pps->hdc;

if (pps->fErase)
   FillRect(hdc, (LPRECT)&pps->rcPaint, hbrBackground);

GetClientRect(hwnd, (LPRECT)&rcClient);

BestFormat = GetBestFormat(CurSelFormat);

fOwnerDisplay = (BestFormat == CF_OWNERDISPLAY);

/* If the display format has changed, Set rcWindow,
 * the display area for clip info.
 */

if (fDisplayFormatChanged)
  {
    CopyRect((LPRECT)&rcWindow, (LPRECT)&rcClient);

    /* We have changed the size of the clipboard. Tell the owner,
     * if fOwnerDisplay is active.
     */

    if (fOwnerDisplay)
        SendOwnerSizeMessage(hwnd, rcWindow.left, rcWindow.top, rcWindow.right, rcWindow.bottom);
    else
        /* Give the window a small margin, for looks */
        InflateRect(&rcWindow, -((int)cxMargin), -((int)cyMargin));

    fDisplayFormatChanged = FALSE;
  }

if (fOwnerDisplay)
  {
    /* Clipboard Owner handles display */
    HANDLE hps;

    hps = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
                      (LONG)sizeof(PAINTSTRUCT));

    if (hps != NULL)
      {
        LPPAINTSTRUCT lppsT;

        if ((lppsT = (LPPAINTSTRUCT)GlobalLock(hps)) != NULL)
           {
           _fmemcpy(lppsT,pps,sizeof(PAINTSTRUCT));
           IntersectRect(&lppsT->rcPaint, &pps->rcPaint, &rcWindow);
           GlobalUnlock(hps);
           SendOwnerMessage(WM_PAINTCLIPBOARD, (WPARAM)hwnd, (LONG)hps);
           GlobalFree(hps);
           }
      }

  }
else
   {
   /* We handle display */
   /* Redraw the portion of the paint rectangle that is in the clipbrd rect */
   IntersectRect(&rcPaint, &pps->rcPaint, &rcWindow);

   rcPaint.left = rcWindow.left;   /* Always draw from left edge of window */

   if ((rcPaint.bottom > rcPaint.top) && (rcPaint.right > rcPaint.left))
      {
      DrawFormat(hdc, &rcPaint,
                  /* rcPaint.left always == rcWindow.left | A-MGATES    */
                  /* (INT)(cxScrollNow + rcPaint.left - rcWindow.left), */
                  cxScrollNow,
                  (INT)(cyScrollNow + rcPaint.top - rcWindow.top),
                  BestFormat);
      }
   }
}


/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  UpdateCBMenu() -                                                            */
/*                                                                            */
/* This routine is called once during initialisation and everytime
 * the contents of the clipboard change. This updates the entries
 * in the "Display" popup menu and the "grey" and "checked" status
 * based on the data formats available in the clipboard.
 */

void UpdateCBMenu(
HWND hwnd)
{
  register UINT fmt;
  WORD          cFmt;
  WORD          cCBCount;   /* Number of data items in CB */
  register WORD wFlags;     /* Used to store the status flags for menu items */
  INT           iIndex;
  INT           nPopupCount;
  BOOL          bAutoSelect;
  TCHAR          szName[40];

  /* Find out the number of data items present in clipboard. */
  if (!(cCBCount = (WORD)CountClipboardFormats()))
    {
      /* The Clipboard is empty;  So, disable both menu items */
      EnableMenuItem(hMainMenu, 2, MF_BYPOSITION | MF_GRAYED);
      EnableMenuItem(hMainMenu, CBM_CLEAR, MF_BYCOMMAND | MF_GRAYED);
      EnableMenuItem(hMainMenu, CBM_SAVEAS, MF_BYCOMMAND | MF_GRAYED);
      goto ExitPoint;
    }

  /* Now clipboard contains at least one item...
   * Find out the number entries in the popup menu at present.
   */
  if (!hDispMenu)
      /* Get the handle to the Display popup menu */
      hDispMenu = GetSubMenu(GetMenu(hwnd), 2);


  nPopupCount = GetMenuItemCount(hDispMenu);

  if (nPopupCount > 2)
    {
      /* Delete all the entries in the popup menu below menu break. */
      for (iIndex = 2; iIndex < nPopupCount; iIndex++)
        {
          /* NOTE: The second parameter must always be 2! (because we use
           * MF_BYPOSITION, when 2 is deleted, 3 becomes 2!).
           */
          DeleteMenu(hDispMenu, 2, MF_BYPOSITION);
        }
    }

  bAutoSelect = TRUE;

  /* EnumClipboard() requires an OpenClipboard(). */
  if (!OpenClipboard(hwnd))
      goto ExitPoint;

  for (fmt=0, cFmt=1; cFmt <= cCBCount; cFmt++)
    {
      wFlags = 0;
      fmt = EnumClipboardFormats(fmt);

      GetClipboardName(fmt, (LPTSTR)szName, sizeof(szName));

      switch (fmt)
        {
          case CF_TEXT:           /* can display all of these */
          case CF_BITMAP:
          case CF_METAFILEPICT:
          case CF_OEMTEXT:
          case CF_DIB:
          case CF_DSPTEXT:
          case CF_DSPBITMAP:
          case CF_DSPMETAFILEPICT:
          case CF_OWNERDISPLAY:
          case CF_PALETTE:
          case CF_UNICODETEXT:
          case CF_ENHMETAFILE:
          case CF_DSPENHMETAFILE:
              break;

          default:                /* all the rest... no */
              wFlags |= MF_GRAYED;
              break;
        }

      /* We have the name of the format in szName. */
      wFlags |= MF_STRING;

      /* Check if the current format is the one selected by the user */
      if (CurSelFormat == fmt)
        {
          bAutoSelect = FALSE;
          wFlags |= MF_CHECKED;
        }

      AppendMenu(hDispMenu, wFlags, fmt, (LPTSTR)szName);
    }

  CloseClipboard();

  if (bAutoSelect)
    {
      CurSelFormat = CBM_AUTO;
      CheckMenuItem(hDispMenu, CBM_AUTO, MF_BYCOMMAND | MF_CHECKED);
    }

  /* Enable the menu items in the top level menu. */
  EnableMenuItem(hMainMenu, 2, MF_BYPOSITION | MF_ENABLED);
  EnableMenuItem(hMainMenu, CBM_CLEAR, MF_BYCOMMAND | MF_ENABLED);
  EnableMenuItem(hMainMenu, CBM_SAVEAS, MF_BYCOMMAND | MF_ENABLED);

ExitPoint:
  DrawMenuBar(hwnd);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SaveOwnerScrollInfo() -                                                 */
/*                                                                          */
/* When the user switched the clipboard display from owner disp to
 *  a non-owner display, all the information about the scroll bar
 *  positions are to be saved. This routine does that.
 *  This is required because, when the user returns back to owner
 *  display, the scroll bar positions are to be restored.
 */

void SaveOwnerScrollInfo(
register HWND hwnd)
{
GetScrollRange(hwnd, SB_VERT, (LPINT) & OwnVerMin, (LPINT) & OwnVerMax);
GetScrollRange(hwnd, SB_HORZ, (LPINT) & OwnHorMin, (LPINT) & OwnHorMax);
OwnVerPos = GetScrollPos(hwnd, SB_VERT);
OwnHorPos = GetScrollPos(hwnd, SB_HORZ);
}


/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  RestoreOwnerScrollInfo() -                                                    */
/*                                                                            */
/*--------------------------------------------------------------------------*/

/*  When the user sitches back to owner-display, the scroll bar
 *  positions are restored by this routine.
 */

void RestoreOwnerScrollInfo(
register HWND hwnd)
{
SetScrollRange(hwnd, SB_VERT, OwnVerMin, OwnVerMax, FALSE);
SetScrollRange(hwnd, SB_HORZ, OwnHorMin, OwnHorMax, FALSE);

SetScrollPos(hwnd, SB_VERT, OwnVerPos, TRUE);
SetScrollPos(hwnd, SB_HORZ, OwnHorPos, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbrd\clipfile.c ===
/*
 * CLIPFILE.C - Windows Clipboard File I/O Routines
 *
 *  Copyright 1985-92, Microsoft Corporation
 */

/* NOTE:
 *   When saving the contents of the clipboard we SetClipboardData(fmt, NULL)
 *   to free up the memory associated with each clipboard format.  Then
 *   after we are done saving we take over as the clipboard owner.  This
 *   causes OWNERDRAW formats to be lost in the save process.
 */


/*
*
*    Touched by    :    Anas Jarrah
*    On Date        :    May 11/1992.
*    Revision remarks by Anas Jarrah ext #15201
*    This file has been changed to comply with the Unicode standard
*    Following is a quick overview of what I have done.
*
*    Was            Changed it into        Remark
*    ===            ===============        ======
*    CHAR              TCHAR             if it refers to a text elements
*    LPCHAR & LPSTR    LPTSTR            if it refers to text.
*    LPCHAR & LPSTR    LPBYTE            if it does not refer to text
*    "..."             TEXT("...")       compile time macro resolves it.
*    '...'             TEXT('...')       same
*    strlen            CharStrLen        compile time macro resolves it.
*    strcpy            CharStrCpy        compile time macro resolves it.
*    strcmp            CharStrCmp        compile time macro resolves it.
*    strcat            CharStrCat        compile time macro resolves it.
*    LoadResource      LoadResource(A/W) NT compiles resource strings into
*                                         Unicode binaries
*    MOpenFile()       MapOpenFile/MOpenFile   Depending on whether Unicode is defined or not.
*                                              This is a temporary cluge, That has to be taken care of.
*
*
*/

#include "clipbrd.h"
#include "dib.h"

#define ATTRDIRLIST 0xC010

// Windows 3.1 programs were packed on byte boundaries.
#pragma pack(1)
// Windows 3.1 BITMAP struct - used to save Win 3.1 .CLP files
typedef struct {
   WORD bmType;
   WORD bmWidth;
   WORD bmHeight;
   WORD bmWidthBytes;
   BYTE bmPlanes;
   BYTE bmBitsPixel;
   LPVOID bmBits;
   } WIN31BITMAP;
#pragma pack()

/* EXTERN data */
extern BOOL fAnythingToRender;

/* FORWARD procs */
HBITMAP PASCAL BitmapToBitmap(HBITMAP, WORD, WORD);

TCHAR       szFileSpecifier[] = TEXT("*.CLP");
TCHAR       szFileName[MAX_PATH];
BOOL        fNTReadFileFormat;
#ifdef JAPAN
extern TCHAR szCaptionName[];
#endif

/* ofSaveStruct is required; Otherwise, the following bug will occur
 *   When the contents of the clipboard are loaded from a file, the
 *   ofStruct is used to open the file and the data handles assigned to
 *   the clipboard are NULL because of DELAYED RENDERING; Delayed
 *   rendering will be done by reading from the file (ofStruct). But,
 *   now, if the contents are to be saved into another file, it should
 *   use the same ofStruct, because data has to be obtained from this
 *   file using delayed rendering; So, a temporary ofSaveStruct is used
 *   to hold the saved file's info; Once the save is successful, the
 *   contents of ofSaveStruct are copied onto ofStruct
 */
/* the ofStruct and ofSaveStruct are replaced by szFileName and
 * szSaveFileName strings.
 */
TCHAR       szSaveFileName[MAX_PATH];
BOOL        fNTSaveFileFormat;


/*
 *  IsWriteable()
 *
 * Test if a clipboard format is writeable(i.e. if it makes sense to write it)
 * OWNERDRAW and others can't be written because we (CLIPBRD) will become the
 * owner when the files are reopened.
 */

BOOL NEAR PASCAL IsWriteable(UINT Format)

{
  /* Are the PRIVATEFIRST and PRIVATELAST things right? */
  if ((Format >= CF_PRIVATEFIRST && Format <= CF_PRIVATELAST) || Format == CF_OWNERDISPLAY)
      return(FALSE);
  if (!fNTSaveFileFormat &&
      (Format == CF_UNICODETEXT || Format == CF_ENHMETAFILE || Format == CF_DSPENHMETAFILE))
      return(FALSE);
  return(TRUE);
}


/*
 *  ReadClipboardFromFile()
 *
 * Read in a clipboard file and register all the formats in delayed mode.
 * to render things for real reopen the file specified by szFileName (was ofStruct).
 *
 * NOTE:
 *    This makes us the clipboard owner.
 *
 * Bug 14564:  Changed return value to a short integer noting why the
 * reading failed.
 * Return Value:  0  Success
 *                1  Improper format
 *                2  OpenClipboard failed
 */
#define READFILE_SUCCESS         0
#define READFILE_IMPROPERFORMAT  1
#define READFILE_OPENCLIPBRDFAIL 2

short NEAR PASCAL ReadClipboardFromFile(HWND hwnd,INT fh)

{
register WORD i;
FILEHEADER    FileHeader;
FORMATHEADER  FormatHeader;

    /* Read the File Header */
    _lread(fh, (LPBYTE)&FileHeader, sizeof(FILEHEADER));

    /* Sanity check, make sure this is one of ours. */
#ifndef JAPAN
    if (FileHeader.magic == CLP_NT_ID)
        fNTReadFileFormat = TRUE;
    else if (FileHeader.magic == CLP_ID)
        fNTReadFileFormat = FALSE;
    else
        return(READFILE_IMPROPERFORMAT);

    if (FileHeader.FormatCount > 100)
        return(READFILE_IMPROPERFORMAT);
#else
    if (FileHeader.magic == CLP_NT_ID)
        fNTReadFileFormat = TRUE;
    else if (FileHeader.magic == CLP_ID)
        fNTReadFileFormat = FALSE;
    else
        goto improperformat;

    if (FileHeader.FormatCount > 100)
    {

improperformat:
    TCHAR szOutMessage[BUFFERLEN];
    TCHAR szCapBuffer[SMALLBUFFERLEN];

    LoadStringW(hInst, IDS_NAME, szCapBuffer, SMALLBUFFERLEN);
    LoadStringW(hInst, IDS_ENOTVALIDFILE, szOutMessage, BUFFERLEN);
    MessageBox(hwnd, szOutMessage,szCapBuffer, MB_OK | MB_ICONEXCLAMATION);
        return(READFILE_IMPROPERFORMAT);
    }
#endif

    /* We become the clipboard owner here! */
    if (!OpenClipboard(hwnd))
        return(READFILE_OPENCLIPBRDFAIL);

    EmptyClipboard();

    for (i=0; i < FileHeader.FormatCount; i++)
        {

        if (fNTReadFileFormat)
            _lread(fh, (LPBYTE)&(FormatHeader.FormatID), sizeof(FormatHeader.FormatID));
        else {
            FormatHeader.FormatID = 0;  /* initialize the high WORD */
            _lread(fh, (LPBYTE)&(FormatHeader.FormatID), sizeof(WORD));
        }
        _lread(fh, (LPBYTE)&(FormatHeader.DataLen), sizeof(FormatHeader.DataLen));
        _lread(fh, (LPBYTE)&(FormatHeader.DataOffset), sizeof(FormatHeader.DataOffset));
        _lread(fh, (LPBYTE)&(FormatHeader.Name), sizeof(FormatHeader.Name));

        if (PRIVATE_FORMAT(FormatHeader.FormatID))
            FormatHeader.FormatID = (UINT)RegisterClipboardFormat(FormatHeader.Name);

        /* Delayed Render. */
        SetClipboardData(FormatHeader.FormatID, NULL);
        }

    /* Now, clipbrd viewer has something to render */
    if (FileHeader.FormatCount > 0)
        fAnythingToRender = TRUE;

    CloseClipboard();
    return(READFILE_SUCCESS);
}


/*
 *  OpenClipboardFile()
 */

void NEAR PASCAL OpenClipboardFile(HWND hwnd)

{
INT     fh;

   lstrcpy(szFileName, TEXT(""));
   OFN.lpstrTitle = szOpenCaption;
   OFN.lpstrFile  = szFileName;
   /* Added OFN_FILEMUSTEXIST.  4 March 1991   clarkc   */
   /* Added OFN_HIDEREADONLY. Happy now, Patrick? :) 1 Oct 1992 a-mgates.*/
   OFN.Flags       = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;

    /* All long pointers should be defined immediately before the call.
     * L.Raman - 2/12/91
     */
   OFN.lpstrDefExt       = (LPTSTR)szDefExt;
   OFN.lpstrFilter       = (LPTSTR)szFilterSpec;
   OFN.lpstrCustomFilter = (LPTSTR)szCustFilterSpec;

   fh = GetOpenFileName ((LPOPENFILENAME) &OFN);
   if (fh)
      {
      fh = (INT)CreateFile((LPCTSTR)szFileName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

      if (fh > 0)
         {
         short nReadError;

         if (ClearClipboard(hwnd))
            {
            if (nReadError = ReadClipboardFromFile(hwnd, fh))
               {
               TCHAR szErr[MSGMAX];

               LoadString (hInst, IDS_READERR + nReadError, szErr, MSGMAX);
               MessageBox(hwnd,szErr,szAppName,MB_OK | MB_ICONEXCLAMATION);
               }
           }
        _lclose(fh);
        }
     }

  /* On GetOpenFileName failure CommDlgExtendedError will return a value.*/
  if(CommDlgExtendedError())
     {
     MemErrorMessage();
     }

}


/*
 *  WriteFormatBlock() -
 */
DWORD NEAR PASCAL WriteFormatBlock(INT fh,DWORD offset,DWORD DataOffset,
                                    DWORD DataLen,UINT Format,LPSTR szName)
{
FORMATHEADER    FormatHeader;
DWORD           dwBytesWritten = 0;

    FormatHeader.FormatID = Format;
    FormatHeader.DataLen = DataLen;
    FormatHeader.DataOffset = DataOffset;
    lstrcpy(FormatHeader.Name, szName);
    _llseek(fh, offset, 0);

    if (fNTSaveFileFormat)
        dwBytesWritten += _lwrite(fh, (LPSTR)&(FormatHeader.FormatID), sizeof(FormatHeader.FormatID));
    else
        dwBytesWritten += _lwrite(fh, (LPSTR)&(FormatHeader.FormatID), sizeof(WORD));
    dwBytesWritten += _lwrite(fh, (LPSTR)&(FormatHeader.DataLen), sizeof(FormatHeader.DataLen));
    dwBytesWritten += _lwrite(fh, (LPSTR)&(FormatHeader.DataOffset), sizeof(FormatHeader.DataOffset));
    dwBytesWritten += _lwrite(fh, (LPSTR)&(FormatHeader.Name), sizeof(FormatHeader.Name));
    return(dwBytesWritten);
}


/*
 *  lread() - Good ol' _lread that will handle >64k
 */
#define MAXREAD   ((LONG)  (60L * 1024L))

DWORD APIENTRY lread(INT hFile,void FAR *pBuffer,DWORD dwBytes)
{
DWORD   dwByteCount = dwBytes;
#ifdef WIN16
BYTE    huge *hpBuffer = pBuffer;

    while (dwByteCount > MAXREAD)
        {
    if (_lread(hFile, hpBuffer, (WORD)MAXREAD) != MAXREAD)
            return(0);

        dwByteCount -= MAXREAD;
        hpBuffer += MAXREAD;
        }
#else
BYTE    FAR  *hpBuffer = pBuffer;
#endif
    if ((DWORD)_lread(hFile, hpBuffer, dwByteCount) != dwByteCount)
        return(0);

    return(dwBytes);
}


/*
 *  lwrite() -  Good ol' _lwrite that will handle >64k
 */
DWORD APIENTRY lwrite(INT hFile,void FAR *pBuffer,DWORD dwBytes)

{
DWORD   dwByteCount=dwBytes;
#ifdef WIN16
BYTE    huge *hpBuffer = pBuffer;

    while (dwByteCount > MAXREAD)
        {
    if (_lwrite(hFile, (LPSTR)hpBuffer, (WORD)MAXREAD) != MAXREAD)
            return(0);
        dwByteCount -= MAXREAD;
        hpBuffer += MAXREAD;
        }

#else
BYTE    FAR  *hpBuffer = pBuffer;
#endif

    if ((DWORD)_lwrite(hFile, (LPSTR)hpBuffer, dwByteCount) != dwByteCount)
        return(0);

    return(dwBytes);
}


/*
 *  WriteDataBlock() -
 *
 * Returns:
 *    # of bytes written to the output file
 *
 * NOTE: Write saves the name of a temp file in the clipboard for it's
 * own internal clipboard format.  This file goes aways when Write
 * (or windows?) shuts down.  Thus saving Write clipboards won't work
 * (should we special case hack this?)
 *
 */
DWORD NEAR PASCAL WriteDataBlock(register INT hFile,LONG offset,UINT Format)
{
WORD    wPalEntries;
LPBYTE   lpData;
DWORD   dwSize;
BITMAP  bitmap;
HANDLE  hMF;
HANDLE  hBitmap;
HANDLE  hLogPalette;
register HANDLE hData;
LPLOGPALETTE    lpLogPalette;
LPMETAFILEPICT  lpMFP;
HENHMETAFILE    hEMF;
WIN31BITMAP     bmWin31;

    if (!(hData = GetClipboardData(Format)))
        return(0);

    if(_llseek(hFile, offset, 0) != (int)offset)
        return(0);

    /* We have to special case a few common formats but most things
     * get handled in the default case.
     */
    switch (Format)
        {
        case CF_ENHMETAFILE:
            hEMF = hData;
            dwSize = (DWORD) GetEnhMetaFileBits(hEMF, 0, NULL); /* Get data size */
            if (!(hData = GlobalAlloc(GHND, dwSize)))   /* allocate mem for EMF bits */
                return(0);
            if (!(lpData = GlobalLock(hData)))
                return(0);
            if (!GetEnhMetaFileBits(hEMF, dwSize, (LPBYTE)lpData))
                return(0);
            dwSize = lwrite(hFile, lpData, dwSize);
            GlobalUnlock(hData);
            GlobalFree(hData);
            break;


        case CF_METAFILEPICT:
            if (!(lpMFP = (LPMETAFILEPICT)GlobalLock(hData))) /* get header */
                return(0);

            if (fNTSaveFileFormat)
                _lwrite(hFile, (LPBYTE)lpMFP, sizeof(METAFILEPICT)); /* write header */
            else {
                /* If we save the metafile in the Windows 3.1 .CLP file format
                   we have to save the METAFILEPICT structure as a 16bit METAFILEPICT
                   structure. This may cause loss of information if the
                   hight half of the METAFILEPICT structure's fields are used.
                   [pierrej 5/27/92]                                        */

                _lwrite(hFile, (LPBYTE)&(lpMFP->mm), sizeof(WORD));
                _lwrite(hFile, (LPBYTE)&(lpMFP->xExt), sizeof(WORD));
                _lwrite(hFile, (LPBYTE)&(lpMFP->yExt), sizeof(WORD));
                _lwrite(hFile, (LPBYTE)&(lpMFP->hMF), sizeof(WORD));
            }

            hMF = lpMFP->hMF;

            GlobalUnlock(hData);            /* unlock the header */

            /* A-MGates 9/15/92 - Converted this block to use */
            /* GetMetaFileBitsEx                              */

            /* Figure out how big a block we need */
            dwSize = GetMetaFileBitsEx(hMF, 0, NULL);
            if (0 == dwSize)
               {
               return(0);
               }

            hData = GlobalAlloc(GMEM_MOVEABLE, dwSize);
            if (!(lpData = GlobalLock(hData)))
               {
               return(0);
               }

            if (dwSize != GetMetaFileBitsEx(hMF, dwSize, lpData))
               {
               GlobalUnlock(hData);
               GlobalFree(hData);
               return(0);
               }

            dwSize = lwrite(hFile, lpData, dwSize); /* spit them out */

            GlobalUnlock(hData);
            GlobalFree(hData);

            if(dwSize)
                if (fNTSaveFileFormat)
                    dwSize += sizeof(METAFILEPICT);     /* we wrote this much data */
                else
                    dwSize += SIZE_OF_WIN31_METAFILEPICT_STRUCT;
            break;

        case CF_BITMAP:
            // hBitmap = hData;

            /* Writing DDBs to disk is bad. Therefore, we */
            /* write an intelligent CF_DIB block instead.    */
            /* A-MGATES 9/29/92                              */

            Format = CF_DIB;

            hBitmap = DibFromBitmap((HBITMAP)hData, BI_RGB, 4, NULL);

            lpData = GlobalLock(hBitmap);

            // dwSize might be too big, but we can live with that.
            dwSize = GlobalSize(lpData);

            _lwrite(hFile, lpData, dwSize);

            GlobalUnlock(hBitmap);
            GlobalFree(hBitmap);

            break;

#ifdef ICKYOLDCODE

            if (!fNTSaveFileFormat)
                hBitmap = BitmapToBitmap(hBitmap, 4, 1);

            GetObject(hBitmap, sizeof(BITMAP), (LPBYTE) &bitmap);
            dwSize = (DWORD)bitmap.bmWidthBytes * bitmap.bmHeight * bitmap.bmPlanes;

            if (!fNTSaveFileFormat)
               {
               // Round up to the nearest TWO bytes when saving to Win 3.1,
               // not the nearest four, which is what GetObject gives you.
               // Note: The WidthBytes calculation does not include
               // bmPlanes in the multiplication because it seems to represent
               // bytes in a given plane.
               bitmap.bmWidthBytes =
                     ((bitmap.bmWidth * bitmap.bmBitsPixel)+ 15 ) >> 3;
                      // ">> 3" == " / 8", except cheaper.

               if (bitmap.bmWidthBytes & 1)
                  {
                  bitmap.bmWidthBytes++;
                  }
               }

            if (!(hData = GlobalAlloc(GHND, dwSize)))
                return(0);

            if (!(lpData = GlobalLock(hData)))
                {
                GlobalFree(hData);
                return(0);
                }

            GetBitmapBits(hBitmap, dwSize, lpData);

            if (fNTSaveFileFormat)
                _lwrite(hFile, (LPBYTE) & bitmap, sizeof(BITMAP));
            else {
                /* If we save the bitmap in the Windows 3.1 .CLP file format
                   we have to save the BITMAP structure as a 16bit BITMAP
                   structure. This may cause loss of information if the
                   hight half of the BITMAP structure's fields are used.
                   [pierrej 5/27/92]                                        */

                bmWin31.bmType = bitmap.bmType;
                bmWin31.bmWidth = bitmap.bmWidth;
                bmWin31.bmHeight = bitmap.bmHeight;
                bmWin31.bmWidthBytes = bitmap.bmWidthBytes;
                bmWin31.bmPlanes = bitmap.bmPlanes;
                bmWin31.bmBitsPixel = bitmap.bmBitsPixel;
                bmWin31.bmBits = bitmap.bmBits;

                _lwrite(hFile, (LPBYTE) &bmWin31, sizeof(WIN31BITMAP));
            }
            dwSize = lwrite(hFile, lpData, dwSize);

            GlobalUnlock(hData);
            GlobalFree(hData);
            if(dwSize)
                if (fNTSaveFileFormat)
                    dwSize += sizeof(BITMAP);
                else
                    dwSize += sizeof(WIN31BITMAP);
            break;

#endif

        case CF_PALETTE:
            /* Get the number of palette entries */
            GetObject(hData, sizeof(WORD), (LPBYTE)&wPalEntries);

            /* Allocate enough place to build the LOGPALETTE struct */
            dwSize = (DWORD)(sizeof(LOGPALETTE) + (LONG)wPalEntries * sizeof(PALETTEENTRY));
            if (!(hLogPalette = GlobalAlloc(GMEM_ZEROINIT | GMEM_MOVEABLE, dwSize)))
                {
                dwSize = 0L;
                goto Palette_Error;
                }

            if (!(lpLogPalette = (LPLOGPALETTE)GlobalLock(hLogPalette)))
                {
                dwSize = 0L;
                goto Palette_Error;
                }

            lpLogPalette->palVersion = 0x300;      /* Windows 3.00 */
            lpLogPalette->palNumEntries = wPalEntries;

        if (GetPaletteEntries(hData, 0, wPalEntries,
              (LPPALETTEENTRY)(lpLogPalette->palPalEntry)) == 0)
                {
                dwSize = 0L;
                goto Palette_Error;
                }

            /* Write the LOGPALETTE structure onto disk */
            dwSize = lwrite(hFile, (LPBYTE)lpLogPalette, dwSize);

Palette_Error:
            if (lpLogPalette)
                GlobalUnlock(hLogPalette);
            if (hLogPalette)
                GlobalFree(hLogPalette);
            break;

        default:
            dwSize = GlobalSize(hData);

            if (0 ==(lpData = GlobalLock(hData)) )
               {
               return 0;
               }

            dwSize = _lwrite(hFile, lpData, dwSize);
            GlobalUnlock(hData);
            break;
        }

    /* Return the number of bytes written. */
    return(dwSize);
}


/* This function will return the number of clipboard formats compatible with
   the Windows 3.1 clipboard, this excludes CF_UNICODETEXT, CF_ENHMETAFILE and
   CF_DSPENHMETAFILE
*/

int Count16BitClipboardFormats(void)
{
    int iCount;

    iCount = CountClipboardFormats();
    if (IsClipboardFormatAvailable(CF_UNICODETEXT))
        iCount--;
    if (IsClipboardFormatAvailable(CF_ENHMETAFILE))
        iCount--;
    if (IsClipboardFormatAvailable(CF_DSPENHMETAFILE))
        iCount--;

    return iCount;
}


/*
 *  SaveClipboardData() - Writes a clipboard file.
 *
 * In:
 *    hwnd        handle of wnd that becomes the clipboard owner
 *    szFileName  file handle to read from
 *
 * NOTE:
 *    When done we call ReadClipboardFromFile(). this makes us the
 *    clipboard owner.
 */

BOOL NEAR PASCAL SaveClipboardData(HWND    hwnd,LPTSTR szLocalFileName)

{
INT    fh;
register UINT Format;
DWORD     HeaderPos;
DWORD     DataPos;
DWORD     datasize;
BOOL      fComplain;
BOOL      fDIBUsed;
HCURSOR   hCursor;
FILEHEADER FileHeader;
TCHAR      szComplaint[BUFFERLEN];
TCHAR      szName[CCHFMTNAMEMAX];
WORD      wHeaderSize;
UINT      uiSizeHeaderToWrite;

    /* First open the clipboard */
    if (!OpenClipboard(hwndMain))
        return(FALSE);

    /* Open the file */

    fh = (INT)CreateFile((LPCTSTR)szLocalFileName, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (fh == -1)
        {
        GetLastError();
        CloseClipboard();
        return(FALSE);
        }
    /* Fill out the file header structure */
    if (fNTSaveFileFormat) {
        FileHeader.magic = CLP_NT_ID;          /* magic number to tag our files */
        uiSizeHeaderToWrite = (sizeof(UINT) + 2*sizeof(DWORD) + CCHFMTNAMEMAX*sizeof(TCHAR));
    } else {
        FileHeader.magic = CLP_ID;          /* magic number to tag our files */
        uiSizeHeaderToWrite = (sizeof(WORD) + 2*sizeof(DWORD) + CCHFMTNAMEMAX*sizeof(TCHAR));
    }
    FileHeader.FormatCount = 0;          /* dummy for now */

    /* Update HeaderPos and DataPos */
    HeaderPos = sizeof(FILEHEADER);

    /* This is the maximum number of formats that will be written.  Potentially
     * some may fail and some space will be wasted.
     * In 32bit the number of bytes written to the disk isn't sizeof(FORMATHEADER)
     * because of DWORD alignment in the FORMATHEADER structure. Instead we write
     * the format headre structure one field at a time to remain compatible with
     * the 16bit Windows versions.
     */

    if (fNTSaveFileFormat)
        DataPos = HeaderPos + (uiSizeHeaderToWrite * CountClipboardFormats());
    else
        DataPos = HeaderPos + (uiSizeHeaderToWrite * Count16BitClipboardFormats());

    /* Now loop throught the data, one format at a time, and write out the data. */
    fComplain = FALSE;

    LoadString(hInst, IDS_FMTNOTSAV, szComplaint, BUFFERLEN);

    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    ShowCursor(TRUE);

    /* Enumerate all formats */
    Format = 0;
    fDIBUsed = FALSE;
    while ((Format = EnumClipboardFormats(Format)) != 0)
        {
        if (IsWriteable(Format))
            {
            // DO NOT write CF_BITMAP to disk. Transform to CF_DIB
            // and write that instead.
            if (CF_BITMAP == Format || CF_DIB == Format)
               {
               if (!fDIBUsed)
                  {
                  fDIBUsed = TRUE;
                  }
               // If I've already done DIB, go on to the next format.
               else continue;
               }

            GetClipboardName((Format == CF_BITMAP ? CF_DIB : Format),
                  szName, sizeof(szName));

            if ((datasize = WriteDataBlock(fh, DataPos, Format)) != 0)
                {
                /* Create a Format header and write it to the file */
                wHeaderSize = (WORD)WriteFormatBlock(fh,
                     HeaderPos, DataPos, datasize,
                     (Format == CF_BITMAP ? CF_DIB : Format),
                     (LPTSTR)szName);
                if(wHeaderSize < uiSizeHeaderToWrite)
                    {
                    fComplain = TRUE;
                    break;
                    }
                HeaderPos += wHeaderSize;

                /* Update the data pos for the next block */
                DataPos += datasize;

                FileHeader.FormatCount++;       /* this format has been written */
                }
            else
                {
                fComplain = TRUE;
                break;
                }
            }
        }

    ShowCursor(FALSE);
    SetCursor(hCursor);

    if (fComplain)
        {
#ifdef JAPAN
        /* Use Japanese message for caption instead of app name */
        MessageBox(hwnd, szComplaint, szCaptionName, MB_OK | MB_ICONEXCLAMATION);
#else
        MessageBox(hwnd, szComplaint, szAppName, MB_OK | MB_ICONEXCLAMATION);
#endif
        CloseClipboard();
        _lclose(fh);
        return(FALSE);
        }

    CloseClipboard();      /* we are done looking at this */

    _llseek(fh, 0L, 0);     /* move back to the start of file */

    /* Write the File Header with the correct number of formats written */
    _lwrite(fh, (LPBYTE) & FileHeader, sizeof(FILEHEADER));

    /* Now we open the clipboard and become the owner.  this places
     * all the things we just saved in the clipboard (and throws out
     * those things we didn't save)
     */
    _llseek(fh, 0L, 0);

    /* ofStruct will be used for reopening the file */
    lstrcpy(szFileName, szSaveFileName);
    fNTReadFileFormat = fNTSaveFileFormat;

    ReadClipboardFromFile(hwndMain, fh);

    _lclose(fh);

    return(TRUE);
}

/*
 *  SaveClipboardToFile() -
 */
void NEAR PASCAL SaveClipboardToFile(HWND hwnd)
{
INT    hFile;

OFN.lpstrTitle = szSaveCaption;
OFN.lpstrFile  = szSaveFileName;
szSaveFileName[0] = 0;
OFN.Flags      = OFN_HIDEREADONLY | OFN_PATHMUSTEXIST |
                 OFN_OVERWRITEPROMPT | OFN_NOREADONLYRETURN;

/* All long pointers should be defined immediately before the call. */
OFN.lpstrDefExt       = (LPTSTR)szDefExt;
OFN.lpstrFilter       = (LPTSTR)szFilterSpec;
OFN.lpstrCustomFilter = NULL;
OFN.lpfnHook          = NULL;
OFN.nFilterIndex      = 1;

hFile = GetSaveFileName ((LPOPENFILENAME) &OFN);
if (hFile)
   {
   // The first filter listed is "NT Clipboard File". The second is
   // "Windows 3.1 Clipboard file".
   fNTSaveFileFormat = (1 == OFN.nFilterIndex);

   hFile = (INT)CreateFile((LPCTSTR)szSaveFileName, GENERIC_READ, FILE_SHARE_READ,
                     NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
   if (hFile != -1)
      /* The file already exists and the user wants to
       * overwrite! Now, we have to check whether this
       * file is the most recently saved clip file;
       * If so, it will be used for delayed rendering; So,
       * before we overwrite this file we must read all data
       * from it thro RENDERALLFORMATS;
       * Fix for Bug #5602 --SANKAR-- 10-16-89
       */
      {
      CloseHandle((HANDLE)hFile);
      if (lstrcmp(szSaveFileName, szFileName) == 0)
         {
         SendMessage(hwndMain, WM_RENDERALLFORMATS, 0, 0L);
         }
      }

   if (!SaveClipboardData(hwnd, (LPTSTR)szSaveFileName))
      {
      /* If Failure, Delete the incomplete file */
      DeleteFile(szSaveFileName);
      }
   }
}


//
// Purpose:
//    Convert an existing bitmap to the given number of planes and
//    bits/pixel.
//
// Parameters:
//    hBitmap - Handle to the existing bitmap.
//    wPlanes - Number of planes in the destination bitmap.
//    wBitCount - Number of bits/pel in the destination bitmap.
//
// Returns:
//    A handle to the converted bitmap.
//
////////////////////////////////////////////////////////////////////////////
HBITMAP PASCAL BitmapToBitmap(HBITMAP hBitmap, WORD wPlanes, WORD wBitCount)
{
    BITMAP  bm;
    BITMAPINFOHEADER    BmpInfoHeader;
    HANDLE  hDib, hBmp;
    LPBYTE  lpDib, lpBits;
    DWORD   dwLength, dwSize;
    int     iColorTable;
    int     iColorUsed;
    HDC     hDC;

    /*
    ** Get the size of the bitmap.  These values are used to setup the memory
    ** requirements for the DIB.
    */
    GetObject(hBitmap,sizeof(BITMAP),(LPSTR)&bm);
    if ((bm.bmBitsPixel == wBitCount) && (bm.bmPlanes == wPlanes))
        return hBitmap;

    #if 0
    dwSize = dwLength = (DWORD)(bm.bmWidthBytes+sizeof(WORD)) * bm.bmHeight * bm.bmPlanes;
    #else
    dwSize = dwLength = (DWORD)(((bm.bmWidth * wBitCount + 7)/8)*2 + 1)/2
         * wPlanes * bm.bmHeight;
    #endif

    switch(bm.bmBitsPixel * bm.bmPlanes)
    {
        case 1:
            iColorTable = sizeof(RGBQUAD) * 2;
            break;

        case 4:
            iColorTable = sizeof(RGBQUAD) * 16;
            break;

        case 8:
            iColorTable = sizeof(RGBQUAD) * 256;
            break;

        case 24:
        default:
            iColorTable = 0;
            break;
    }
    iColorUsed = iColorTable / sizeof(RGBQUAD);
    dwLength   += (sizeof(BITMAPINFOHEADER) + iColorTable);


    /*
    ** Create the DIB.  First, to the size of the bitmap.  We will calculate
    ** the new memory requirements if DIB-Compression is desired.
    */
    if(hDib = GlobalAlloc(GHND,dwLength)) {
        if(lpDib = GlobalLock(hDib))
           {
           ((LPBITMAPINFOHEADER)lpDib)->biSize          = sizeof(BITMAPINFOHEADER);
           ((LPBITMAPINFOHEADER)lpDib)->biWidth         = bm.bmWidth;
           ((LPBITMAPINFOHEADER)lpDib)->biHeight        = bm.bmHeight;
           ((LPBITMAPINFOHEADER)lpDib)->biPlanes        = 1;
           ((LPBITMAPINFOHEADER)lpDib)->biBitCount      = bm.bmBitsPixel*bm.bmPlanes;
           ((LPBITMAPINFOHEADER)lpDib)->biCompression   = BI_RGB;
           ((LPBITMAPINFOHEADER)lpDib)->biSizeImage     = 0;
           ((LPBITMAPINFOHEADER)lpDib)->biXPelsPerMeter = 0;
           ((LPBITMAPINFOHEADER)lpDib)->biYPelsPerMeter = 0;
           ((LPBITMAPINFOHEADER)lpDib)->biClrUsed       = 0;
           ((LPBITMAPINFOHEADER)lpDib)->biClrImportant  = 0;


           // Figure out where the bits go
           lpBits = (LPBYTE)lpDib+sizeof(BITMAPINFOHEADER)+iColorTable;
           hDC = GetDC(hwndMain);
           if (NULL != hDC)
              {
              if (bm.bmHeight == GetDIBits(hDC,hBitmap,0,
                        bm.bmHeight,lpBits,(LPBITMAPINFO)lpDib,
                        // DIB_PAL_INDICES))
                        DIB_RGB_COLORS))
                 {
                 BmpInfoHeader.biSize          = sizeof(BITMAPINFOHEADER);
                 BmpInfoHeader.biWidth         = bm.bmWidth;
                 BmpInfoHeader.biHeight        = bm.bmHeight;
                 BmpInfoHeader.biPlanes        = wPlanes;
                 BmpInfoHeader.biBitCount      = wBitCount;
                 BmpInfoHeader.biCompression   = BI_RGB;
                 BmpInfoHeader.biSizeImage     = dwSize;
                 BmpInfoHeader.biXPelsPerMeter = 0;
                 BmpInfoHeader.biYPelsPerMeter = 0;
                 BmpInfoHeader.biClrUsed       = iColorUsed;
                 BmpInfoHeader.biClrImportant  = iColorUsed;
                 hBmp = CreateDIBitmap(NULL, &BmpInfoHeader, CBM_INIT,
                            lpBits, (LPBITMAPINFO)lpDib, DIB_RGB_COLORS);
                 }
              ReleaseDC(hwndMain, hDC);
              }
           GlobalUnlock(hDib);
           }
        GlobalFree(hDib);
        }

    return(hBmp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbrd\clipbrd.h ===
/*  CLIPBRD.H                                                               */
/*                                                                          */
/*  Copyright 1985-92, Microsoft Corporation                                */

#include <windows.h>
#include <port1632.h>
#include <commdlg.h>

#ifndef MAXSHORT
#define  MAXSHORT 0x7fff
#endif

#define SIZE_OF_WIN31_BITMAP_STRUCT 14       //Win 3.1 BITMAP structure is 14 bytes long
#define SIZE_OF_WIN31_METAFILEPICT_STRUCT 8  //Win 3.1 METAFILEPICT structure is 8 bytes long


#define PRIVATE_FORMAT(fmt)   ((fmt) >= 0xC000)

/* Header text string ids */
#define IDS_NAME            100  /* CF_TEXT to CF_OEMTEXT (1 to 7) are also used */
#define IDS_ERROR           102  /* as string ids.  Be sure to keep these    */
#define IDS_BINARY          103  /* different.                               */
#define IDS_CLEAR           104
#define IDS_FMTNOTSAV       105
#define IDS_DEFAULT         106
#define IDS_CANTDISPLAY     107  /* "Can't display data in this format" */
#define IDS_NOTRENDERED     108  /* "Application Couldn't render data"  */
#define IDS_HELPFILE        109  /* Clipbrd.hlp */
#define IDS_CLEARTITLE      110
#define IDS_CONFIRMCLEAR    111
#define IDS_ALREADYOPEN     112  /* OpenClipboard() fails */
#define IDS_INVALIDFILENAME 113  /* Filename is invalid */
#define IDS_OPENCAPTION     114  /* ID of File/Open dlg. caption string */
#define IDS_SAVECAPTION     115  /* ID of File/Save dlg. caption string */
#define IDS_MEMERROR        116
#define IDS_DEFEXTENSION    117  /* Default extension for clipboard files */
#ifdef JAPAN
#define IDS_ENOTVALIDFILE   130  /* ID of invalid file format messagebox*/
#endif

#define IDS_READERR        200  /* ID of base ReadClipboardFile error */
#define IDS_READFORMATERR   201
#define IDS_READOPENCLIPERR 202
#define IDS_FILTERTEXT      301  /* ID of filter string for File/Open   */

/* Dialogbox resource id */
#define ABOUTBOX        1
#define CONFIRMBOX   2

#define CDEFFMTS        8       /* Count of predifined clipboard formats    */
#define VPOSLAST        100     /* Highest vert scroll bar value */
#define HPOSLAST        100     /* Highest horiz scroll bar value */
#define CCHFMTNAMEMAX   79      /* Longest clipboard data fmt name, including
                                   terminator */
#define cLineAlwaysShow 3       /* # of "standard text height" lines to show
                                   when maximally scrolled down */
#define BUFFERLEN       200     /* String buffer length */
#define SMALLBUFFERLEN  90
#define IDSABOUT        1

#define CBMENU          1       /* Number for the Clipboard main menu  */
#define CBICON          2
#define CBACCEL         3

#define FILTERMAX   100         /* max len. of File/Open filter string */
#define CAPTIONMAX  30          /* len of caption text for above dlg.  */
#define PATHMAX     128         /* max. len of DOS pathname          */
#define MSGMAX      255

/* The menu ids */
#define CBM_AUTO        WM_USER
#define CBM_CLEAR       WM_USER+1
#define CBM_OPEN        WM_USER+2
#define CBM_SAVEAS      WM_USER+3
#define CBM_ABOUT       WM_USER+4
#define CBM_EXIT        WM_USER+5
#define CBM_HELP   0xFFFF    /* Standard numbers */
#define CBM_USEHELP     0xFFFC   /* Standard numbers */
#define CBM_SEARCH   0x0021

/*  Last parameter to SetDIBits() and GetDIBits() calls */

#define  DIB_RGB_COLORS   0
#define  DIB_PAL_COLORS     1

#define  IDCLEAR    IDOK

/* Structures for saving/loading clipboard data from disk */

#define     CLP_ID     0xC350
#define     CLP_NT_ID  0xC351

// Windows 3.1 used byte packing on structs. These structs are used in
// files common between NT and Win 3.1, therefore need byte packing.
// a-mgates 9/28/92
#ifndef RC_INVOKED
#pragma pack(1)
typedef struct {
    WORD magic;
    WORD FormatCount;
} FILEHEADER;

typedef struct {
   UINT  FormatID;
   DWORD DataLen;
   DWORD DataOffset;
   TCHAR Name[CCHFMTNAMEMAX];
} FORMATHEADER;
#pragma pack()
#endif


void NEAR PASCAL SaveClipboardToFile(HWND);
void NEAR PASCAL OpenClipboardFile(HWND);

BOOL MyOpenClipboard(HWND);
BOOL NEAR PASCAL ClearClipboard(HWND);
void NEAR PASCAL GetClipboardName(UINT fmt, LPSTR szName, INT iSize);

BOOL RenderFormat(FORMATHEADER *f,INT);
DWORD APIENTRY lread(INT fh, void FAR *pv, DWORD ul);
DWORD APIENTRY lwrite(INT fh, void FAR *pv, DWORD ul);

void UpdateCBMenu(HWND);
void ChangeCharDimensions(HWND,UINT,UINT);
void SetCharDimensions(HWND,HFONT);
void SaveOwnerScrollInfo(HWND);
void RestoreOwnerScrollInfo(HWND);

void SendOwnerMessage(UINT, WPARAM, LPARAM);
void SendOwnerSizeMessage(HWND, INT, INT, INT, INT);

void DrawStuff(HWND,PAINTSTRUCT *f);

void ClipbrdVScroll(HWND, WORD, WORD);
void ClipbrdHScroll(HWND, WORD, WORD);

UINT GetBestFormat(UINT);

LONG APIENTRY ClipbrdWndProc(HWND, UINT, WPARAM, LONG);
BOOL APIENTRY ConfirmDlgProc(HWND, UINT, WPARAM, LONG);

/* Far low mem situations. */
void FAR PASCAL MemErrorMessage(void);


/*****************************  global data  *******************************/

extern HINSTANCE   hInst;
extern TCHAR    szFileName[];
extern HWND   hwndMain;
extern TCHAR   szAppName[];
extern TCHAR   szFileSpecifier[];

/* variables for the new File Open,File SaveAs and Find Text dialogs */
#define CCH_szDefExt 8

extern OPENFILENAME OFN;
extern TCHAR szFileName [];
extern BOOL  fNTReadFileFormat;
extern TCHAR szLastDir  [];
extern TCHAR szFilterSpec[];         /* default filter spec. for above    */
extern TCHAR szCustFilterSpec[];     /* buffer for custom filters created */
extern UINT wHlpMsg;                 /* message used to invoke Help    */
extern TCHAR szOpenCaption [];       /* File open dialog caption text    */
extern TCHAR szSaveCaption [];       /* File Save as dialog caption text  */
extern TCHAR szDefExt      [CCH_szDefExt];       /* default file extension to use  */

#define MAXBITSPERPIXEL     24

extern BOOL    fAnythingToRender;
extern BOOL    fOwnerDisplay;
extern BOOL    fDisplayFormatChanged;

extern TCHAR    szAppName[];
extern TCHAR    szCaptionName[CAPTIONMAX];
extern TCHAR    szHelpFileName[20];

extern TCHAR    szMemErr[MSGMAX];

extern HWND    hwndNextViewer;
extern HWND    hwndMain;

extern HANDLE  hAccel;
extern HANDLE  hfontSys;
extern HANDLE  hfontOem;
extern HANDLE  hfontUni;

extern HBRUSH  hbrWhite;
extern HBRUSH  hbrBackground;

extern HMENU   hMainMenu;
extern HMENU   hDispMenu;

extern INT     OwnVerMin, OwnVerMax, OwnHorMin, OwnHorMax;
extern INT     OwnVerPos, OwnHorPos;

extern LONG    cyScrollLast;
extern LONG    cyScrollNow;
extern INT     cxScrollLast;
extern INT     cxScrollNow;

extern RECT    rcWindow;
extern UINT    cyLine, cxChar, cxMaxCharWidth;
extern UINT    cxMargin, cyMargin;

extern UINT    CurSelFormat;
extern UINT    rgfmt[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbrd\clipinit.c ===
#include <windows.h>
#include "clipbrd.h"


/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  SetCharDimensions() -                                                    */
/*                                                                            */
/*--------------------------------------------------------------------------*/
void SetCharDimensions(
HWND hWnd,
HFONT hFont)
{
register HDC  hdc;
TEXTMETRIC    tm;

hdc = GetDC(hWnd);
SelectObject(hdc, hFont);
GetTextMetrics(hdc, (LPTEXTMETRIC)&tm);
ReleaseDC(hWnd, hdc);

cxChar = tm.tmAveCharWidth;
cxMaxCharWidth = tm.tmMaxCharWidth;
cyLine = tm.tmHeight + tm.tmExternalLeading;
cxMargin = cxChar / 2;
cyMargin = cyLine / 4;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ClipbrdInit() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL NEAR PASCAL ClipbrdInit()

{
  WNDCLASS  class;

  if (!(hAccel = LoadAccelerators(hInst, (LPTSTR)MAKEINTRESOURCE(CBACCEL))))
      return(FALSE);

  hbrBackground = CreateSolidBrush(GetSysColor(COLOR_WINDOW));

  class.hCursor       = LoadCursor(NULL, IDC_ARROW);
  class.hIcon              = LoadIcon(hInst, MAKEINTRESOURCE(CBICON));
  class.lpszClassName = szAppName;
  class.hbrBackground = (HBRUSH)NULL;
  class.style              = CS_HREDRAW | CS_VREDRAW | CS_BYTEALIGNCLIENT;
  class.lpszMenuName  = (LPTSTR)MAKEINTRESOURCE(CBMENU);
  class.hInstance     = hInst;
  class.lpfnWndProc   = ClipbrdWndProc;
  class.cbClsExtra    = 0;
  class.cbWndExtra    = 0;

  return(RegisterClass((LPWNDCLASS)&class));
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  WinMain() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

int WINAPI WinMain(
HINSTANCE hInstance,
HINSTANCE hPrevInstance,
LPSTR lpszCmdLine,
int cmdShow)
{
MSG         msg;
HWND   hwndPrev;
typedef VOID (FAR PASCAL *LPVFNWB)(WORD, BOOL);
LPVFNWB lpfnRegisterPenApp = NULL;
LOGFONT UniFont;

hInst = hInstance;

// If there's a previous instance, activate its window and blow.
if (hwndPrev = FindWindow(szAppName, NULL))
   {
   ShowWindow(hwndPrev, SW_RESTORE);
   SetForegroundWindow(hwndPrev);
   return(0);
   }
else
   {
   LoadString(hInst, IDS_NAME, szCaptionName, sizeof(szCaptionName));
   LoadString(hInst, IDS_HELPFILE, (LPTSTR)szHelpFileName, sizeof(szHelpFileName));

   /* load caption strings for new File/Open and File/saveAs dialogs */
   LoadString(hInst, IDS_OPENCAPTION, (LPTSTR)szOpenCaption, CAPTIONMAX);
   LoadString(hInst, IDS_SAVECAPTION, (LPTSTR)szSaveCaption, CAPTIONMAX);

   /* Load default extension */
   LoadString(hInst, IDS_DEFEXTENSION, (LPTSTR)szDefExt, CCH_szDefExt);

   /* Load custom resources for CommDlg filters                           */
   /* a-mgates 9/24/92                                                    */
   LoadString(hInst, IDS_FILTERTEXT, szFilterSpec, FILTERMAX);

   /*  To prevent LoadString failure on low memory situations. */
   LoadString(hInst, IDS_MEMERROR,(LPTSTR)szMemErr,MSGMAX);

   if (!ClipbrdInit())
      {
      return FALSE;
      }

   hwndMain = CreateWindow(szAppName,
                           szCaptionName,
                           WS_TILEDWINDOW | WS_VSCROLL | WS_HSCROLL,
                           CW_USEDEFAULT, 0,
                           GetSystemMetrics(SM_CXSCREEN) / 2, GetSystemMetrics(SM_CYSCREEN) / 2,
                           (HWND)NULL,
                           (HMENU)NULL,
                           hInstance, (LPTSTR)NULL);

   /* Obtain size of standard chars; compute white border size from this */
   hfontSys = GetStockObject(SYSTEM_FONT);
   hfontOem = GetStockObject(OEM_FIXED_FONT);
   GetObject(hfontSys, sizeof(LOGFONT), &UniFont);
   UniFont.lfCharSet = ANSI_CHARSET;
   lstrcpy(UniFont.lfFaceName, TEXT("Lucida Sans Unicode"));
   hfontUni = CreateFontIndirect(&UniFont);
   if (hfontUni == NULL)
       hfontUni = (HFONT)hfontSys;

   /* Get the character dimensions for the default font */
   SetCharDimensions(hwndMain, hfontSys);

   /* Attach us to the clipboard viewer chain */
   hwndNextViewer = SetClipboardViewer(hwndMain);

   /* init. some fields of the OPENFILENAME struct used by fileopen and
    * filesaveas
    */
   OFN.lStructSize       = sizeof(OPENFILENAME);
   OFN.hwndOwner         = hwndMain;
   OFN.lpstrFileTitle    = 0;
   OFN.nMaxCustFilter    = FILTERMAX;
   OFN.nFilterIndex      = 1;
   OFN.nMaxFile          = PATHMAX;
   OFN.lpfnHook          = NULL;
   OFN.Flags             = 0L;/* for now, since there's no readonly support */

   /* determine the message number to be used for communication with
    * help application
    */
   if (!(wHlpMsg = RegisterWindowMessage ((LPTSTR)HELPMSGSTRING)))
        return FALSE;

   ShowWindow(hwndMain, cmdShow);

   if (lpfnRegisterPenApp = (LPVFNWB)
       GetProcAddress((HANDLE)GetSystemMetrics(SM_PENWINDOWS),
       "RegisterPenApp"))                /*   Anas May 92 should I?   */
      {
      (*lpfnRegisterPenApp)(1, TRUE);
      }

   while (GetMessage(&msg, NULL, 0, 0))
     {
       if (TranslateAccelerator(hwndMain, hAccel, (LPMSG)&msg) == 0)
         {
           TranslateMessage(&msg);
           DispatchMessage(&msg);
         }
     }

   if (lpfnRegisterPenApp)
       (*lpfnRegisterPenApp)(1, FALSE);

   return(msg.wParam);
   }

UNREFERENCED_PARAMETER(hPrevInstance);
UNREFERENCED_PARAMETER(lpszCmdLine);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbrd\dib.c ===
/*******************************************************************************
 *                                                                             *
 *  MODULE      : DIB.C                                                        *
 *                                                                             *
 *  DESCRIPTION : Routines for dealing with Device Independent Bitmaps.        *
 *                                                                             *
 *                PaletteSize()       - Calculates the palette size in bytes   *
 *                                      of given DIB                           *
 *                                                                             *
 *                DibNumColors()      - Determines the number of colors in DIB *
 *                                                                             *
 *                BitmapFromDib()     - Creates a DDB given a global handle to *
 *                                      a block in CF_DIB format.              *
 *                                                                             *
 *                DibFromBitmap()     - Creates a DIB repr. the DDB passed in. *
 *                                                                             *
 *******************************************************************************/

#include <windows.h>
#include "dib.h"
static   HCURSOR hcurSave;

/****************************************************************************
 *                                                                          *
 *  FUNCTION   :  PaletteSize(VOID FAR * pv)                                *
 *                                                                          *
 *  PURPOSE    :  Calculates the palette size in bytes. If the info. block  *
 *                is of the BITMAPCOREHEADER type, the number of colors is  *
 *                multiplied by 3 to give the palette size, otherwise the   *
 *                number of colors is multiplied by 4.                                                          *
 *                                                                          *
 *  RETURNS    :  Palette size in number of bytes.                          *
 *                                                                          *
 ****************************************************************************/
WORD PaletteSize (pv)
VOID FAR * pv;
{
    LPBITMAPINFOHEADER lpbi;
    WORD               NumColors;

    lpbi      = (LPBITMAPINFOHEADER)pv;
    NumColors = DibNumColors(lpbi);

    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
        return NumColors * sizeof(RGBTRIPLE);
    else
        return NumColors * sizeof(RGBQUAD);
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : DibNumColors(VOID FAR * pv)                                *
 *                                                                          *
 *  PURPOSE    : Determines the number of colors in the DIB by looking at   *
 *               the BitCount filed in the info block.                      *
 *                                                                          *
 *  RETURNS    : The number of colors in the DIB.                           *
 *                                                                          *
 ****************************************************************************/
WORD DibNumColors (pv)
VOID FAR * pv;
{
    int                 bits;
    LPBITMAPINFOHEADER  lpbi;
    LPBITMAPCOREHEADER  lpbc;

    lpbi = ((LPBITMAPINFOHEADER)pv);
    lpbc = ((LPBITMAPCOREHEADER)pv);

    /*  With the BITMAPINFO format headers, the size of the palette
     *  is in biClrUsed, whereas in the BITMAPCORE - style headers, it
     *  is dependent on the bits per pixel ( = 2 raised to the power of
     *  bits/pixel).
     */
    if (lpbi->biSize != sizeof(BITMAPCOREHEADER)){
        if (lpbi->biClrUsed != 0)
            return (WORD)lpbi->biClrUsed;
        bits = lpbi->biBitCount;
    }
    else
        bits = lpbc->bcBitCount;

    switch (bits){
        case 1:
                return 2;
        case 4:
                return 16;
        case 8:
                return 256;
        default:
                /* A 24 bitcount DIB has no color table */
                return 0;
    }
}
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : DibFromBitmap()                                            *
 *                                                                          *
 *  PURPOSE    : Will create a global memory block in DIB format that       *
 *               represents the Device-dependent bitmap (DDB) passed in.    *
 *                                                                          *
 *  RETURNS    : A handle to the DIB                                        *
 *                                                                          *
 ****************************************************************************/
HANDLE DibFromBitmap (hbm, biStyle, biBits, hpal)
HBITMAP      hbm;
DWORD        biStyle;
WORD         biBits;
HPALETTE     hpal;
{
    BITMAP               bm;
    BITMAPINFOHEADER     bi;
    BITMAPINFOHEADER FAR *lpbi;
    DWORD                dwLen;
    HANDLE               hdib;
    HANDLE               h;
    HDC                  hdc;

    if (!hbm)
        return NULL;

    if (hpal == NULL)
        hpal = GetStockObject(DEFAULT_PALETTE);

    GetObject(hbm,sizeof(bm),(LPSTR)&bm);

    if (biBits == 0)
        biBits =  bm.bmPlanes * bm.bmBitsPixel;

    bi.biSize               = sizeof(BITMAPINFOHEADER);
    bi.biWidth              = bm.bmWidth;
    bi.biHeight             = bm.bmHeight;
    bi.biPlanes             = 1;
    bi.biBitCount           = biBits;
    bi.biCompression        = biStyle;
    bi.biSizeImage          = 0;
    bi.biXPelsPerMeter      = 0;
    bi.biYPelsPerMeter      = 0;
    bi.biClrUsed            = 0;
    bi.biClrImportant       = 0;

    dwLen  = bi.biSize + PaletteSize(&bi);

    hdc = GetDC(NULL);
    hpal = SelectPalette(hdc,hpal,FALSE);
         RealizePalette(hdc);

    hdib = GlobalAlloc(GHND,dwLen);

    if (!hdib){
        SelectPalette(hdc,hpal,FALSE);
        ReleaseDC(NULL,hdc);
        return NULL;
    }

    lpbi = (VOID FAR *)GlobalLock(hdib);

    *lpbi = bi;

    /*  call GetDIBits with a NULL lpBits param, so it will calculate the
     *  biSizeImage field for us
     */
    GetDIBits(hdc, hbm, 0, (WORD)bi.biHeight,
        NULL, (LPBITMAPINFO)lpbi, DIB_RGB_COLORS);

    bi = *lpbi;
    GlobalUnlock(hdib);

    /* If the driver did not fill in the biSizeImage field, make one up */
    if (bi.biSizeImage == 0){
        bi.biSizeImage = WIDTHBYTES((DWORD)bm.bmWidth * biBits) * bm.bmHeight;

        if (biStyle != BI_RGB)
            bi.biSizeImage = (bi.biSizeImage * 3) / 2;
    }

    /*  realloc the buffer big enough to hold all the bits */
    dwLen = bi.biSize + PaletteSize(&bi) + bi.biSizeImage;
    if (h = GlobalReAlloc(hdib,dwLen,0))
        hdib = h;
    else{
        GlobalFree(hdib);
        hdib = NULL;

        SelectPalette(hdc,hpal,FALSE);
        ReleaseDC(NULL,hdc);
        return hdib;
    }

    /*  call GetDIBits with a NON-NULL lpBits param, and actualy get the
     *  bits this time
     */
    lpbi = (VOID FAR *)GlobalLock(hdib);

    if (GetDIBits( hdc,
                   hbm,
                   0,
                   (WORD)bi.biHeight,
                   (LPSTR)lpbi + (WORD)lpbi->biSize + PaletteSize(lpbi),
                   (LPBITMAPINFO)lpbi, DIB_RGB_COLORS) == 0){
         GlobalUnlock(hdib);
         hdib = NULL;
         SelectPalette(hdc,hpal,FALSE);
         ReleaseDC(NULL,hdc);
         return NULL;
    }

    bi = *lpbi;
    GlobalUnlock(hdib);

    SelectPalette(hdc,hpal,FALSE);
    ReleaseDC(NULL,hdc);
    return hdib;
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : BitmapFromDib(HANDLE hdib, HPALETTE hpal)                  *
 *                                                                          *
 *  PURPOSE    : Will create a DDB (Device Dependent Bitmap) given a global *
 *               handle to a memory block in CF_DIB format                  *
 *                                                                          *
 *  RETURNS    : A handle to the DDB.                                       *
 *                                                                          *
 ****************************************************************************/
HBITMAP BitmapFromDib (HANDLE hdib,HPALETTE hpal)
{
    LPBITMAPINFOHEADER  lpbi;
    HPALETTE            hpalT;
    HDC                 hdc;
    HBITMAP             hbm;

    StartWait();

    if (!hdib)
        return NULL;

    lpbi = (VOID FAR *)GlobalLock(hdib);

    if (!lpbi)
        return NULL;

    hdc = GetDC(NULL);

    if (hpal){
        hpalT = SelectPalette(hdc,hpal,FALSE);
        RealizePalette(hdc);     // GDI Bug...????
    }

    hbm = CreateDIBitmap(hdc,
                (LPBITMAPINFOHEADER)lpbi,
                (LONG)CBM_INIT,
                (LPSTR)lpbi + lpbi->biSize + PaletteSize(lpbi),
                (LPBITMAPINFO)lpbi,
                DIB_RGB_COLORS );

    if (hpal)
        SelectPalette(hdc,hpalT,FALSE);

    ReleaseDC(NULL,hdc);
    GlobalUnlock(hdib);

    EndWait();

    return hbm;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbrd\wndproc.c ===
#include <windows.h>
#include <shellapi.h>
#include "clipbrd.h"



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  InitOwnerScrollInfo() -                                                 */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void InitOwnerScrollInfo(
void)
{
OwnVerPos = OwnHorPos = OwnVerMin = OwnHorMin = 0;
OwnVerMax = VPOSLAST;
OwnHorMax = HPOSLAST;
}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ClipbrdWndProc() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

LONG FAR PASCAL ClipbrdWndProc(register HWND hwnd,
                                UINT message,register WPARAM wParam,LONG lParam)

{
  int           i;
  HDC           hdc;
  UINT          wNewFormat;
  UINT          wOldFormat;
  HPALETTE      hpal;
  HPALETTE      hpalT;

  static INT UpdateCount = 0;

  switch (message)
    {
      case WM_RENDERALLFORMATS:
          /* When clipboard is cleared by user using EDIT-CLEAR command
           * we (clipboard viewer) become the owner and this results in
           * WM_RENDERALLFORMATS message when Clipbrd viewer is closed.
           * So, we should check if we have anything to render before
           * processing this message.  Sankar
           */
          if (!CountClipboardFormats())
              break;

          /* Check if the clipbrd viewer has done any File I/O before.
           * If it has not, then it has nothing to render!  Sankar
           */
          if (!fAnythingToRender)
              break;

          /* Empty the clipboard */
          if (!MyOpenClipboard(hwnd))
                  break;
          EmptyClipboard();
          /*** FALL THRU ***/

      case WM_RENDERFORMAT:
        {
          INT           fh;
          DWORD         HeaderPos;
          FILEHEADER    FileHeader;
          FORMATHEADER  FormatHeader;
          WORD          w;

          fh = (INT)CreateFile((LPCTSTR)szFileName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
          FileHeader.FormatCount = 0; /* If _lread fails, we can detect */
          _lread(fh, (LPBYTE)&FileHeader, sizeof(FILEHEADER));

          HeaderPos = sizeof(FILEHEADER);

          for (w=0; w < FileHeader.FormatCount; w++)
            {
              _llseek(fh, HeaderPos, 0);
              if (fNTReadFileFormat) {
                  if(_lread(fh, (LPBYTE)&(FormatHeader.FormatID), sizeof(FormatHeader.FormatID)) < sizeof(FormatHeader.FormatID))
                      break;
              } else {
                  FormatHeader.FormatID = 0;  /* initialize the hight WORD */
                  if(_lread(fh, (LPBYTE)&(FormatHeader.FormatID), sizeof(WORD)) < sizeof(WORD))
                      break;
              }
              if(_lread(fh, (LPBYTE)&(FormatHeader.DataLen), sizeof(FormatHeader.DataLen)) < sizeof(FormatHeader.DataLen))
                  break;
              if(_lread(fh, (LPBYTE)&(FormatHeader.DataOffset), sizeof(FormatHeader.DataOffset)) < sizeof(FormatHeader.DataOffset))
                  break;
              if(_lread(fh, (LPBYTE)&(FormatHeader.Name), sizeof(FormatHeader.Name)) < sizeof(FormatHeader.Name))
                  break;
              if (fNTReadFileFormat)
                  HeaderPos += (sizeof(UINT) + 2*sizeof(DWORD) + CCHFMTNAMEMAX*sizeof(TCHAR));
              else
                  HeaderPos += (sizeof(WORD) + 2*sizeof(DWORD) + CCHFMTNAMEMAX*sizeof(TCHAR));

              if (PRIVATE_FORMAT(FormatHeader.FormatID))
                  FormatHeader.FormatID = (UINT)RegisterClipboardFormat(FormatHeader.Name);

              if ((message == WM_RENDERALLFORMATS) || (FormatHeader.FormatID == (UINT)wParam))
                  RenderFormat(&FormatHeader, fh);
            }

          if (message == WM_RENDERALLFORMATS)
              CloseClipboard();

          _lclose(fh);
          break;
        }

      case WM_DESTROYCLIPBOARD:
          /* Prevent unnecessary file I/O when getting a WM_RENDERALLFORMATS */
          fAnythingToRender = FALSE;
          break;

      case WM_CREATE:
          hMainMenu = GetMenu(hwnd);
            /* Get the handle to the Display popup menu */
          hDispMenu = GetSubMenu(hMainMenu, 2);
          UpdateCBMenu(hwnd);
          break;

      case WM_COMMAND:
          switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
              case CBM_CLEAR:
                  ClearClipboard(hwnd);
                  break;

              case CBM_EXIT:
                  SendMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
                  break;

              case CBM_ABOUT:
                  if(ShellAbout(hwnd, szCaptionName, (LPTSTR)TEXT(""),
                             LoadIcon(hInst, MAKEINTRESOURCE(CBICON))) == -1)
                        MemErrorMessage();
                  break;

              case CBM_OPEN:
                  OpenClipboardFile(hwnd);
                  break;

              case CBM_SAVEAS:
                  SaveClipboardToFile(hwnd);
                  break;

              case CBM_AUTO:
              case CF_PALETTE:
              case CF_TEXT:
              case CF_BITMAP:
              case CF_METAFILEPICT:
              case CF_SYLK:
              case CF_DIF:
              case CF_TIFF:
              case CF_OEMTEXT:
              case CF_DIB:
              case CF_OWNERDISPLAY:
              case CF_DSPTEXT:
              case CF_DSPBITMAP:
              case CF_DSPMETAFILEPICT:
              case CF_PENDATA:
              case CF_UNICODETEXT:
              case CF_RIFF:
              case CF_WAVE:
              case CF_ENHMETAFILE:
              case CF_DSPENHMETAFILE:
                  if (CurSelFormat == GET_WM_COMMAND_ID(wParam, lParam))
                      break;

                  CheckMenuItem(hDispMenu, CurSelFormat, MF_BYCOMMAND | MF_UNCHECKED);
                  CheckMenuItem(hDispMenu, GET_WM_COMMAND_ID(wParam, lParam), MF_BYCOMMAND | MF_CHECKED);
                  DrawMenuBar(hwnd);

                  wOldFormat = GetBestFormat(CurSelFormat);
                  wNewFormat = GetBestFormat(GET_WM_COMMAND_ID(wParam, lParam));
                  if (wOldFormat == wNewFormat)
                    {
                       /* An equivalent format is selected; No change */
                       CurSelFormat = GET_WM_COMMAND_ID(wParam, lParam);
                       break;
                    }

                  /* A different format is selected; So, refresh... */

                  /* Change the character sizes based on new format. */
                  ChangeCharDimensions(hwnd, wOldFormat, wNewFormat);

                  fDisplayFormatChanged = TRUE;

                  CurSelFormat = GET_WM_COMMAND_ID(wParam, lParam);
                  if (wOldFormat == CF_OWNERDISPLAY)
                    {
                      /* Save the owner Display Scroll info */
                      SaveOwnerScrollInfo(hwnd);
                      goto InvalidateScroll1;
                    }

                  if (wNewFormat == CF_OWNERDISPLAY)
                    {
                      /* Restore the owner display scroll info */
                      RestoreOwnerScrollInfo(hwnd);
                      InvalidateRect(hwnd,NULL,TRUE);
                    }
                  else
                      goto InvalidateScroll1;
                  break;

              case CBM_USEHELP:
                  if(!WinHelp(hwnd, (LPTSTR)NULL, HELP_HELPONHELP, 0L))
                        MemErrorMessage();
                  break;

              case CBM_HELP:
                  if(!WinHelp(hwnd, (LPTSTR)szHelpFileName, HELP_INDEX, 0L))
                        MemErrorMessage();
                  break;

              case CBM_SEARCH:
                  if(!WinHelp(hwnd, (LPTSTR)szHelpFileName, HELP_PARTIALKEY, (DWORD)(LPTSTR)TEXT("")))                /*        Anas May 92 should I?        */
                               MemErrorMessage();
                  break;

              default:
                  return(DefWindowProc(hwnd, message, wParam, lParam));
            }
          break;

      case WM_CHANGECBCHAIN:
          /* Some window is being removed from the clipboard viewer chain. */

          if (hwndNextViewer == NULL)
              return(FALSE);

          if ((HWND)wParam == hwndNextViewer)
            {
              /* Chain link being removed is our descendant */
              hwndNextViewer = GET_WM_CHANGECBCHAIN_HWNDNEXT(wParam, lParam);
              return(TRUE);
            }
          return(SendMessage(hwndNextViewer, WM_CHANGECBCHAIN, wParam, lParam));

      case WM_KEYDOWN:
        {
          WPARAM                sb;

          switch (wParam)
            {
              case VK_UP:
                  sb = SB_LINEUP;
                  goto VertScroll;

              case VK_DOWN:
                  sb = SB_LINEDOWN;
                  goto VertScroll;

              case VK_PRIOR:
                  sb = SB_PAGEUP;
                  goto VertScroll;

              case VK_NEXT:
                  sb = SB_PAGEDOWN;
VertScroll:
                  SendMessage(hwnd, WM_VSCROLL, sb, 0L);
                  break;

              case VK_LEFT:
                  sb = SB_LINEUP;
                  goto HorzScroll;

              case VK_RIGHT:
                  sb = SB_LINEDOWN;
                  goto HorzScroll;

              case VK_TAB:
                  sb = (GetKeyState( VK_SHIFT ) < 0) ? SB_PAGEUP : SB_PAGEDOWN;
HorzScroll:
                  SendMessage( hwnd, WM_HSCROLL, sb, 0L);
                  break;

              default:
                  goto DefaultProc;
            }
          break;
        }

      case WM_SIZE:
          fDisplayFormatChanged = TRUE;
          if (wParam == SIZEICONIC)
            {
              if (fOwnerDisplay)
                  SendOwnerSizeMessage(hwnd, 0, 0, 0, 0);
            }
          else
            {
              /* Invalidate scroll offsets since they are dependent on
               * window size UNLESS it is a Owner display item.  Also the
               * "object size" of CF_TEXT changes when the window width
               * changes.
               */
              if (fOwnerDisplay)
                  SendOwnerSizeMessage(hwnd, 0, 0, LOWORD(lParam), HIWORD(lParam));
              else
                  goto InvalidateScroll;
            }
          break;

      case WM_DESTROY:
          /* Take us out of the viewer chain */
          ChangeClipboardChain(hwnd, hwndNextViewer);

          if (fOwnerDisplay)
              SendOwnerSizeMessage(hwnd, 0, 0, 0, 0);

          DeleteObject(hbrBackground);

          WinHelp(hwnd, (LPTSTR)szHelpFileName, HELP_QUIT, 0L);

          PostQuitMessage(0);
          break;

      case WM_DRAWCLIPBOARD:
          fDisplayFormatChanged = TRUE;

          /* Pass the message on to the next clipboard viewer in the chain. */
          if (hwndNextViewer != NULL)
              SendMessage(hwndNextViewer, WM_DRAWCLIPBOARD, wParam, lParam);

          wOldFormat = GetBestFormat(CurSelFormat);

          /* Update the popup menu entries. */
          UpdateCBMenu(hwnd);
          wNewFormat = GetBestFormat(CurSelFormat);

          /* Change the character dimensions based on the format. */
          ChangeCharDimensions(hwnd, wOldFormat, wNewFormat);

          /* Initialize the owner display scroll info, because the
           * contents have changed.
           */
          InitOwnerScrollInfo();

InvalidateScroll1:
          /* Force a total repaint. fOwnerDisplay gets updated during
           * a total repaint.
           */
          InvalidateRect(hwnd,NULL,TRUE);

InvalidateScroll:
          /* Invalidate object info; reset scroll position to 0. */
          cyScrollLast = cxScrollLast = -1;

          /* Range is set in case CF_OWNERDISPLAY owner changed it. */
          SetScrollRange(hwnd, SB_VERT, 0, VPOSLAST, FALSE);
          SetScrollPos(hwnd, SB_VERT, (INT)(cyScrollNow = 0), TRUE);
          SetScrollRange(hwnd, SB_HORZ, 0, HPOSLAST, FALSE);
          SetScrollPos(hwnd, SB_HORZ, cxScrollNow = 0, TRUE);
          break;

      case WM_QUERYNEWPALETTE:
          /* If palette realization caused a palette change, do a full redraw. */
          if (!MyOpenClipboard(hwnd))
              return(FALSE);

          if (IsClipboardFormatAvailable(CF_PALETTE))
              hpal = GetClipboardData(CF_PALETTE);
          else
              hpal = NULL;

          CloseClipboard();

          if (hpal)
            {
              hdc = GetDC(hwnd);
              hpalT = SelectPalette(hdc, hpal, FALSE);

              i = RealizePalette(hdc);

              SelectPalette (hdc, hpalT, FALSE);
              ReleaseDC(hwnd, hdc);

              if (i)
                {
                  InvalidateRect(hwnd, NULL, TRUE);
                  UpdateCount = 0;
                  return TRUE;
                }
            }
          return(FALSE);

      case WM_PALETTECHANGED:
          if ((HWND)wParam != hwnd && IsClipboardFormatAvailable(CF_PALETTE))
            {
              if (!MyOpenClipboard(hwnd))
                  return(FALSE);

              if (IsClipboardFormatAvailable(CF_PALETTE))
                  hpal = GetClipboardData(CF_PALETTE);
              else
                  hpal = NULL;

              CloseClipboard();

              if (hpal)
                {
                  hdc = GetDC(hwnd);
                  hpalT = SelectPalette (hdc, hpal, FALSE);

                  if (RealizePalette(hdc))
                    {
#ifdef ORG_CODE
                      UpdateColors(hdc);
                      UpdateCount++;
#else
                      InvalidateRect(hwnd, NULL, TRUE);
                      UpdateCount = 0;
#endif
                    }

                  SelectPalette (hdc, hpalT, 0);
                  ReleaseDC(hwnd, hdc);
                }
            }
          break;

      case WM_PAINT:
        {
          PAINTSTRUCT   ps;

          /* If we have updated more than once, the rest of our
           * window is not in some level of degradation worse than
           * our redraw...  We need to redraw the whole area.
           */
          if (UpdateCount > 1)
            {
              UpdateCount = 0;
              InvalidateRect(hwnd, NULL, TRUE);
            }

          BeginPaint(hwnd, &ps);
          hdc = ps.hdc;
          if (MyOpenClipboard(hwnd))
            {
              SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
              SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));

              /* Check if a palette is also available in the clipboard.
               * If so, select it before drawing data.
               */
              if (IsClipboardFormatAvailable(CF_PALETTE)) {
                if ((hpal = GetClipboardData(CF_PALETTE)) != NULL)
                {
                  hpalT = SelectPalette(hdc, hpal, FALSE);
                  RealizePalette(hdc);
                }
              } else
                hpal = NULL;

              DrawStuff(hwnd, &ps);

              if (hpal)
                  SelectPalette(hdc, hpalT, FALSE);

              CloseClipboard();
            }
          EndPaint(hwnd, &ps);
          break;
        }

      case WM_VSCROLL:
          if (GET_WM_VSCROLL_CODE(wParam, lParam) != SB_THUMBTRACK)
            {
              if (fOwnerDisplay)
                  SendOwnerMessage(WM_VSCROLLCLIPBOARD, (WPARAM)hwnd,
                           (LPARAM)MAKELONG(GET_WM_VSCROLL_CODE(wParam, lParam),
                                    GET_WM_VSCROLL_POS(wParam, lParam)));
              else
                  ClipbrdVScroll(hwnd, GET_WM_VSCROLL_CODE(wParam, lParam),
                                 GET_WM_VSCROLL_POS(wParam, lParam));
            }
          break;

      case WM_HSCROLL:
          if (GET_WM_HSCROLL_CODE(wParam, lParam) != SB_THUMBTRACK)
            {
              if (fOwnerDisplay)
                  SendOwnerMessage(WM_HSCROLLCLIPBOARD, (WPARAM)hwnd,
                           (LPARAM)MAKELONG(GET_WM_HSCROLL_CODE(wParam, lParam),
                                    GET_WM_HSCROLL_POS(wParam, lParam)));
              else
                  ClipbrdHScroll(hwnd, GET_WM_HSCROLL_CODE(wParam, lParam),
                                 GET_WM_HSCROLL_POS(wParam, lParam));
            }
          break;

      case WM_SYSCOLORCHANGE:
          /* Update pen and brush to reflect new color */
          DeleteObject(hbrBackground);
          hbrBackground = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
          break;

      default:
DefaultProc:
          return(DefWindowProc(hwnd, message, wParam, lParam));
    }
  return(0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\common\common.h ===
/* include file for common routines */

INT APIENTRY FAR DlgOpen(HANDLE, HWND, INT, INT, INT, INT, INT,
                CHAR *, INT, CHAR *, LPOFSTRUCT, INT *);

BOOL APIENTRY FAR DlgCheckFileName(CHAR *);
VOID APIENTRY FAR DlgCheckOkEnable(HWND, INT, WORD);
VOID APIENTRY FAR DlgInitSaveAs(HWND, INT, INT, INT, LPOFSTRUCT);
CHAR * APIENTRY FAR PFileInPath(CHAR *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clock\clock.h ===
/****************************************************************************/
/*                                                                          */
/*  CLOCK.H -                                                               */
/*                                                                          */
/*      Windows Clock Include File                                          */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/*                                                                          */
/*       Touched by      :       Diane K. Oh                                */
/*       On Date         :       June 11, 1992                              */
/*       Revision remarks by Diane K. Oh ext #15201                         */
/*       This file has been changed to comply with the Unicode standard     */
/*       Following is a quick overview of what I have done.                 */
/*                                                                          */
/*       Was               Changed it into    Remark                        */
/*       ===               ===============    ======                        */
/*       CHAR              TCHAR              if it refers to text          */
/*       LPCHAR & LPSTR    LPTSTR             if it refers to text          */
/*       PSTR & NPSTR      LPTSTR             if it refers to text          */
/*                                                                          */
/****************************************************************************/

/*--------------------------------------------------------------------------*/
/*  Typedefs and Structures                                                 */
/*--------------------------------------------------------------------------*/

typedef struct tagTIME
{
    int     hour;   /* 0 - 11 hours for analog clock */
    int     hour12; /* 12 hour format */
    int     hour24; /* 24 hour format */
    int     minute;
    int     second;
    int     ampm;   /* 0 - AM , 1 - PM */
} TIME;

typedef struct tagDATE
{
    int     day;
    int     month;
    int     year;
} xDATE;

typedef struct tagCLOCKDISPSTRUCT
{
    /* Clock display format for main window/icon outut */
    /* either  IDM_ANALOG, or IDM_DIGITAL */
    WORD    wFormat;

    /* flags */
    BOOL    bIconic, bNoSeconds, bNoTitle, bTopMost, bNoDate;

    /* X and Y offset within client area of window
     * or icon where digital clock will be displayed */
    int nPosY, nPosHr, nPosSep1, nPosMin, nPosSep2, nPosSec, nPosAMPM;
    int nSizeChar, nSizeSep, nSizeY, nSizeAMPM;
    int nPosDateX, nPosDateY, nSizeDateX, nSizeDateY;

    /* size of shadow offset, in pixels. If 0, no shadow */
    WORD    wShdwOff;

    /* handle to offscreen bitmap for fast painting of shadowed digits */
    HBITMAP hBitmap;

    /* buffer to hold the win.ini international indicators
     * for 1159, and 2359 AM/PM 12 hour time format.
     * szAMPM[0] holds AM, szAMPM[1] holds PM indicator */
#define MAX_AMPM_LEN    10
    TCHAR   szAMPM[2][MAX_AMPM_LEN];
    int     nMaxAMPMLen;
    WORD    wAMPMPosition;

    /* intl time format (like DOS) 0 - 12 hour, 1 - 24 hour */
    WORD    wTimeFormat, wTimeLZero;

#define MAX_DATE_LEN    80
    TCHAR   szDateFmt[MAX_DATE_LEN];
    TCHAR   szDate[MAX_DATE_LEN];
    int     nDateLen;

#define MAX_TIME_LEN    80
    TCHAR   szTimeFmt[MAX_TIME_LEN];
    int     nTimeLen;

    /* intl time seperator character */
#define MAX_TIME_SEP    5
    TCHAR   szTimeSep[MAX_TIME_SEP];
} CLOCKDISPSTRUCT, *PCLOCKDISPSTRUCT;


/*--------------------------------------------------------------------------*/
/*  Function Templates                                                      */
/*--------------------------------------------------------------------------*/

void NEAR GetTime  (TIME *);
void NEAR ConvTime (TIME *);
void NEAR GetDate  (xDATE *);

void NEAR PASCAL PrepareSavedWindow (LPTSTR, PRECT);
void NEAR PASCAL ParseSavedWindow   (LPTSTR, PRECT);
void NEAR PASCAL PrepareSavedFlags  (LPTSTR, PCLOCKDISPSTRUCT);
void NEAR PASCAL ParseSavedFlags    (LPTSTR, PCLOCKDISPSTRUCT);

LONG FAR PASCAL ClockWndProc (HWND, WORD, WORD, LONG);


/*--------------------------------------------------------------------------*/
/*  Constants                                                               */
/*--------------------------------------------------------------------------*/

    /* Main Menu ID defines */

#define IDM_ANALOG       1
#define IDM_DIGITAL      2
#define IDM_SETFONT      3
#define IDM_ABOUT        4
#define IDM_TOPMOST      5  /* actually in system menu */
#define IDM_NOTITLE      6
#define IDM_SECONDS      7
#define IDM_DATE         8
#define IDM_UTC          9

/* Temp ID for dialogs. */
#define ID_JUNK     0xCACC
#define ID_DATA     99

    /* String Resource definitions */

#define IDS_APPNAME      2
#define IDS_TOOMANY      3
#define IDS_FONTFILE     4
#define IDS_TOPMOST      5

#define IDS_FONTCHOICE  22
#define IDS_USNAME      23
#define IDS_INIFILE     24

#define IDD_FONT        100

#define HOURSCALE       65
#define MINUTESCALE     80
#define HHAND           TRUE
#define MHAND           FALSE
#define SECONDSCALE     80
#define MAXBLOBWIDTH    25
#define BUFLEN          30
#define REPAINT         0
#define HANDPAINT       1

#define UPDATE                  0
#define REDRAW                  1

#define OPEN_TLEN               450      /* < half second */
#define ICON_TLEN               20000    /* 20 seconds    */

#ifndef HWND_TOPMOST
#define HWND_TOPMOST ((HWND)-1)
#endif


#ifndef HWND_NOTOPMOST
#define HWND_NOTOPMOST ((HWND)-2)
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clock\clock.c ===
/****************************************************************************/
/*                                                                          */
/*       Touched by      :       Diane K. Oh                                */
/*       On Date         :       June 11, 1992                              */
/*       Revision remarks by Diane K. Oh ext #15201                         */
/*       This file has been changed to comply with the Unicode standard     */
/*       Following is a quick overview of what I have done.                 */
/*                                                                          */
/*       Was               Changed it into   Remark                         */
/*       ===               ===============   ======                         */
/*       CHAR              TCHAR             if it refers to text           */
/*       LPCHAR & LPSTR    LPTSTR            if it refers to text           */
/*       PSTR & NPSTR      LPTSTR            if it refers to text           */
/*       "..."             TEXT("...")       compile time macro resolves it */
/*       '...'             TEXT('...')       same                           */
/*                                                                          */
/*       strlen            lstrlen           compile time macro resolves it */
/*                                                                          */
/*  Notes:                                                                  */
/*                                                                          */
/*    1. Added LPTSTR typecast before MAKEINTRESOURCE to remove warning     */
/*    2. Size was multiplied by sizeof(TCHAR) when allocating strings.      */
/*    3. WinMain has not been Unicode enabled so lpCmdLine parameter        */
/*         remains as LPSTR type.                                           */
/*    4. Changed typecast from FARPROC to LPCFHOOKPROC to remove warning    */
/*                                                                          */
/****************************************************************************/

#include <windows.h>               /* required for all Windows applications */
#include <stdlib.h>
#include "commdlg.h"
#include "shellapi.h"
#include "clock.h"                 /* specific to this program              */

#if defined(JAPAN)
#include <dlgs.h>
#endif


BOOL InitApplication (HANDLE);
HRGN CreateEllipticWndRgn(HWND,LPRECT);

LRESULT FAR PASCAL MainWndProc (HWND, UINT, WPARAM, LPARAM);

#if defined(JAPAN)
#define NATIVE_CHARSET  SHIFTJIS_CHARSET

UINT APIENTRY ExceptVerticalFont(HWND, UINT, UINT, LONG);
#endif

HANDLE hInst;                       /* current instance                      */
void  ParseSavedWindow(LPTSTR szBuf, PRECT pRect );
void NEAR PASCAL DeleteTools (void);
void NEAR PASCAL PrintShadowText (register HDC hDC, int nx, int ny, int sizex, int sizey, LPTSTR pszStr, int nStrLen, HDC hOffScrnDC);
void NEAR PASCAL ClockSize (register HWND hWnd,int newWidth,int newHeight,WORD SizeWord);
void NEAR PASCAL ClockTimerInterval (HWND hWnd);
void NEAR PASCAL CompClockDim (void);
void NEAR PASCAL ClockTimer (HWND hWnd);
void NEAR PASCAL FormatTimeStr (void);
void NEAR PASCAL ClockPaint (HWND hWnd, register HDC hDC, int hint);
void NEAR PASCAL DrawFace (HDC hDC);
void NEAR PASCAL DrawFatHand (register HDC hDC, int pos, HPEN hPen, BOOL hHand);
void NEAR PASCAL DrawHand (register HDC hDC, int pos, HPEN hPen, int scale, int patMode);
void NEAR PASCAL DrawIconBorder (HWND hWnd, register HDC hDC);
void NEAR PASCAL FormatDateStr (xDATE *pDate, BOOL bRealShort);
void NEAR PASCAL SizeFont (HWND hWnd, int newHeight, int newWidth);
void NEAR PASCAL SetMenuBar (HWND hWnd);
void NEAR PASCAL FormatInit (VOID);
VOID NEAR PASCAL SaveClockOptions (HWND hWnd);
void NEAR PASCAL ResetWinTitle (HWND hWnd);
void NEAR PASCAL CreateTools (void);
void NEAR PASCAL ClockCreate (HWND hWnd);

TIME    oTime;
xDATE   oDate;

CLOCKDISPSTRUCT ClockDisp;

LOGFONT    FontStruct;
typedef struct
{
    SHORT x;
    SHORT y;

} TRIG;


#define FNOSHAD_MONOCHROME 1
#define FNOSHAD_USERSAYSNO 2

short   fNoShadow = 0;

BOOL    bUtc       = FALSE;
BOOL    bFirst     = TRUE;
BOOL    bColor     = TRUE;
BOOL    fShadedHands = FALSE;
BOOL    bNewFont   = TRUE;
BOOL    bCantHide = FALSE;
BOOL    bTmpHide = FALSE;
BOOL    fDisplay = FALSE;
TCHAR   szBuffer[BUFLEN];    /* buffer for stringtable stuff */
TCHAR   szAppName[BUFLEN];
TCHAR   szIniFile[20];
TCHAR   szDfltFontFile[20];
TCHAR   szSection[30];
TCHAR   szFontFileKey[20];
HBRUSH  hbrColorWindow;
HBRUSH  hbrBtnHighlight;
HBRUSH  hbrForeground;
HBRUSH  hbrBlobColor;
HFONT   hFont = NULL;
HFONT   hFontDate = NULL;
#define bDisplayDate    (!ClockDisp.bNoDate && !ClockDisp.bIconic)

RECT    clockRect;
RECT    rCoordRect;
TRIG    clockCenter;

HPEN    hpenForeground;
HPEN    hpenShadow;
HPEN    hpenBackground;
HPEN    hpenBlobHlt;
HPEN    hpenRed;
HCURSOR hCurWait;


/* win.ini strings...   Don't internationalize */
TCHAR   szMaximized[] = TEXT("Maximized");
TCHAR   szOptions[]   = TEXT("Options");
TCHAR   szPosition[]  = TEXT("Position");
TCHAR   szNoShadow[]  = TEXT("NoShadow");

#if defined(JAPAN)
TCHAR   szCharSet[]   = TEXT("Charset");
#endif

int     TimerID = 1;    /* number used for timer-id */
int     clockRadius;
int     HorzRes;
int     VertRes;

int     aspectD;
int     aspectN;

extern TRIG CirTab[];
TRIG FAR *lpcirTab = CirTab;

#if defined(JAPAN) || defined(KOREA)
UINT FAR PASCAL  ExceptVerticalFont(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
#endif


void MoveTo (HDC hdc, int x, int y)
{
   MoveToEx (hdc, x, y, NULL);
}

INT MyAtoi (LPTSTR  Str)
{
  CHAR    szAnsi [160];
  BOOL    fDefCharUsed;

#ifdef UNICODE
   WideCharToMultiByte (CP_ACP, 0, Str, -1, szAnsi, 160, NULL, &fDefCharUsed);
   return (atoi (szAnsi));
#else
   return (atoi (Str));
#endif

}

/****************************************************************************

    FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int)

    PURPOSE: calls initialization function, processes message loop

    COMMENTS:

        Windows recognizes this function by name as the initial entry point
        for the program.  This function calls the application initialization
        routine, if no other instance of the program is running, and always
        calls the instance initialization routine.  It then executes a message
        retrieval and dispatch loop that is the top-level control structure
        for the remainder of execution.  The loop is terminated when a WM_QUIT
        message is received, at which time this function exits the application
        instance by returning the value passed by PostQuitMessage().

        If this function must abort before entering the message loop, it
        returns the conventional value NULL.

****************************************************************************/

int APIENTRY WinMain (HINSTANCE hInstance,
                      HINSTANCE hPrevInstance,
                      LPSTR lpCmdLine,
                      int nCmdShow)
{

    MSG        msg;                        /* message */
    HDC        hDC;
    HWND       hWnd;
    HMENU      hMenu;
    int        iMaximized;
    TCHAR      szParseStr [80];
    TIME       nTime;
    LPTSTR     szTooMany;
    TCHAR      szTopmost [80];
#ifdef JAPAN
    int        i;
#endif
    UNREFERENCED_PARAMETER( lpCmdLine );


    hInst = hInstance;
    FormatInit ();
    if (!InitApplication (hInstance)) /* Initialize shared things       */
       return (FALSE);                /* Exits if unable to initialize  */

    /* Perform initializations that apply to a specific instance */
    LoadString (hInstance, IDS_APPNAME, szAppName, BUFLEN);
    LoadString (hInstance, IDS_USNAME, szSection, 30);
    LoadString (hInstance, IDS_INIFILE, szIniFile, 20);
    ClockCreate ((HWND)NULL);


    hDC = GetDC (NULL);
    if ((UINT)GetDeviceCaps (hDC, NUMCOLORS) <= 2)
        fNoShadow = FNOSHAD_MONOCHROME;
    ReleaseDC (NULL, hDC);
    if (GetPrivateProfileInt (szSection, szNoShadow, 0, szIniFile))
        fNoShadow |= FNOSHAD_USERSAYSNO;

    /* get window position and size from ini file */
    GetPrivateProfileString (szSection, szPosition, TEXT(""), szParseStr,
                             80, szIniFile);
    ParseSavedWindow (szParseStr, &rCoordRect);


    hWnd = CreateWindow (szSection,      /* The class name.             */
                         szSection,      /* The window instance name.   */
                         WS_TILEDWINDOW,
                         rCoordRect.left, rCoordRect.top,
                         rCoordRect.right, rCoordRect.bottom,
                         NULL,
                         NULL,
                         hInstance,
                         NULL);

    // Loop if control panel time being changed.
    GetTime (&oTime);
    do
    {
        GetTime (&nTime);
    }
    while (nTime.second == oTime.second && nTime.minute == oTime.minute &&
           nTime.hour24 == oTime.hour24);

    GetDate (&oDate);

    if (!SetTimer (hWnd, TimerID, OPEN_TLEN, 0L))
    {
        /* Windows only supports 16 public timers */
        szTooMany = (LPTSTR) LocalAlloc (LPTR, 160 * sizeof(TCHAR));
        LoadString (hInstance, IDS_TOOMANY, szTooMany, 160);
        MessageBox ((HWND)NULL, szTooMany, szBuffer, MB_OK | MB_ICONHAND | MB_SYSTEMMODAL);
        DeleteTools ();
        return (FALSE);
    }

    /* get font choice from ini file */
#ifdef JAPAN
    lstrcpy (szDfltFontFile, TEXT("System"));
#else
    LoadString (hInstance, IDS_FONTFILE, szDfltFontFile, 20);
#endif
    LoadString (hInstance, IDS_FONTCHOICE, szFontFileKey, 20);
    GetPrivateProfileString (szSection, szFontFileKey, szDfltFontFile,
                             FontStruct.lfFaceName, 20, szIniFile);
    FontStruct.lfPitchAndFamily = FF_SWISS | VARIABLE_PITCH;
#ifdef JAPAN
    if (!(i = GetPrivateProfileInt(szSection, szCharSet,
        ANSI_CHARSET, szIniFile)))
        FontStruct.lfCharSet = ANSI_CHARSET;
    else
        FontStruct.lfCharSet = i;
#else
    FontStruct.lfCharSet = ANSI_CHARSET;
#endif
    FontStruct.lfWeight = FW_NORMAL;
    FontStruct.lfQuality = DEFAULT_QUALITY;
    FontStruct.lfUnderline = FALSE;
    FontStruct.lfStrikeOut = FALSE;
    FontStruct.lfEscapement = 0;
    FontStruct.lfOrientation = 0;
    FontStruct.lfOutPrecision = OUT_DEFAULT_PRECIS;
    FontStruct.lfClipPrecision = CLIP_DEFAULT_PRECIS;

#ifdef JAPAN
    /* We can use only NATIVE_CHARSET */
    if (FontStruct.lfCharSet != NATIVE_CHARSET)
    {
        FontStruct.lfCharSet = NATIVE_CHARSET;
        lstrcpy (FontStruct.lfFaceName, TEXT("System"));
    }
#endif


    /* get clock options from ini file */
    GetPrivateProfileString (szSection, szOptions, TEXT(""), szParseStr, 80, szIniFile);
    ParseSavedFlags (szParseStr, &ClockDisp);

    FormatTimeStr ();
    FormatDateStr (&oDate, ClockDisp.bIconic);

    hMenu = GetMenu (hWnd);
    /* Check the default menu item either analog or digital */
    CheckMenuItem (hMenu, ClockDisp.wFormat, MF_BYCOMMAND | MF_CHECKED);
    if (ClockDisp.wFormat == IDM_ANALOG)
        EnableMenuItem( hMenu, IDM_SETFONT, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);

    if (!ClockDisp.bNoSeconds)
    {
        CheckMenuItem (hMenu, IDM_SECONDS, MF_BYCOMMAND | MF_CHECKED);
        ClockTimerInterval (hWnd);
    }
    if (!ClockDisp.bNoDate)
    {
        CheckMenuItem (hMenu, IDM_DATE, MF_BYCOMMAND | MF_CHECKED);
        ResetWinTitle (hWnd);
    }
    hMenu = GetSystemMenu (hWnd, FALSE);
    AppendMenu (hMenu, MF_SEPARATOR, 0, NULL);

    LoadString (hInstance, IDS_TOPMOST, szTopmost, 79);

    if (ClockDisp.bTopMost)
    {
        AppendMenu (hMenu, MF_ENABLED | MF_CHECKED | MF_STRING, IDM_TOPMOST,
                    szTopmost);
        SetWindowPos (hWnd, (HWND)-1, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
    }
    else
        AppendMenu (hMenu, MF_ENABLED | MF_UNCHECKED | MF_STRING, IDM_TOPMOST,
                    szTopmost);


    if (ClockDisp.bNoTitle)
       SetMenuBar (hWnd);


    if (!ClockDisp.bIconic)
    {
        iMaximized = GetPrivateProfileInt (szSection, szMaximized, 0, szIniFile);
        if (iMaximized)
            ShowWindow (hWnd, SW_MAXIMIZE);
        else
        {
            ShowWindow (hWnd, nCmdShow);
            GetWindowRect (hWnd, &rCoordRect);
        }
    }
    else
        ShowWindow (hWnd, SW_MINIMIZE);


    /* Acquire and dispatch messages until a WM_QUIT message is received. */
    while (GetMessage (&msg,        /* message structure                      */
                       NULL,        /* handle of window receiving the message */
                       0,        /* lowest message to examine              */
                       0))       /* highest message to examine             */
    {
        TranslateMessage (&msg);    /* Translates virtual key codes           */
        DispatchMessage (&msg);     /* Dispatches message to window           */
    }
    return (int)(msg.wParam);       /* Returns the value from PostQuitMessage */

    hPrevInstance; //UNUSED
    nCmdShow; //UNUSED
}


/****************************************************************************

    FUNCTION: InitApplication(HANDLE)

    PURPOSE: Initializes window data and registers window class

    COMMENTS:

        This function is called at initialization time only if no other
        instances of the application are running.  This function performs
        initialization tasks that can be done once for any number of running
        instances.

        In this case, we initialize a window class by filling out a data
        structure of type WNDCLASS and calling the Windows RegisterClass()
        function.  Since all instances of this application use the same window
        class, we only need to do this when the first instance is initialized.


****************************************************************************/

BOOL InitApplication (HANDLE hInstance)       /* current instance */
{
   WNDCLASS  ClockClass;

    /* Fill in window class structure with parameters that describe the       */
    /* main window.                                                           */
    ClockClass.cbClsExtra = ClockClass.cbWndExtra = 0;

    ClockClass.lpszClassName = TEXT("Clock");
    ClockClass.lpszMenuName  = TEXT("Clock"); //szSection;
    ClockClass.hbrBackground = GetStockObject(LTGRAY_BRUSH);
    ClockClass.style         = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS;
    ClockClass.hInstance     = hInstance;
    ClockClass.lpfnWndProc   = MainWndProc;

    ClockClass.hCursor       = LoadCursor (NULL, IDC_ARROW);
    ClockClass.hIcon         = NULL;

    /* Register the window class and return success/failure code. */
    return (RegisterClass (&ClockClass));
}



/****************************************************************************

    FUNCTION: MainWndProc(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages

    MESSAGES:

        WM_COMMAND    - application menu (About dialog box)
        WM_DESTROY    - destroy window

****************************************************************************/

LRESULT APIENTRY MainWndProc (HWND hWnd,         /* window handle          */
                              UINT message,      /* type of message        */
                              WPARAM wParam,     /* additional information */
                              LPARAM lParam)     /* additional information */
{
  HMENU       hMenu;
  PAINTSTRUCT ps;

    switch (message)
    {
       case WM_COMMAND:
           switch (LOWORD (wParam))
           {
               case IDM_ANALOG:
               case IDM_DIGITAL:
                   if (LOWORD (wParam) != ClockDisp.wFormat)
                   {
                       /* Switch flag to other choice */
                       hMenu = GetMenu(hWnd);
                       CheckMenuItem(hMenu, ClockDisp.wFormat, MF_BYCOMMAND | MF_UNCHECKED);
                       CheckMenuItem(hMenu, ClockDisp.wFormat = (WORD)wParam, MF_BYCOMMAND | MF_CHECKED);
                       if (wParam == IDM_ANALOG)
                           EnableMenuItem (hMenu, IDM_SETFONT, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
                       else
                           EnableMenuItem (hMenu, IDM_SETFONT, MF_BYCOMMAND | MF_ENABLED);
                       ResetWinTitle (hWnd);
                       InvalidateRect (hWnd, (LPRECT)NULL, TRUE);
                   }
                   break;


               case IDM_SETFONT:
               {
                   CHOOSEFONT  cf;
                   short cy, nOldFontHeight;
#ifdef JAPAN
                   /* Win 3.1 */
                   LOGFONT OldFontStruct;
#endif

                   /* calls the font chooser (in commdlg)
                    */
                   cf.lStructSize = sizeof (CHOOSEFONT);
                   cf.hwndOwner = hWnd;
                   cf.hInstance = hInst;
                   cf.lpTemplateName = (LPTSTR) MAKEINTRESOURCE(IDD_FONT);
                   cf.hDC = NULL;
                   cf.lpLogFont = &FontStruct;
                   FontStruct.lfItalic = 0;
                   FontStruct.lfWeight = FW_NORMAL;
                   cf.Flags = CF_SCREENFONTS | CF_INITTOLOGFONTSTRUCT |
#ifdef JAPAN
                              CF_NOSIMULATIONS | CF_ENABLETEMPLATE |
#else
                              CF_NOSIMULATIONS | CF_ANSIONLY | CF_ENABLETEMPLATE |
#endif
                              CF_NOVECTORFONTS;
#if defined(JAPAN)
                   /* except vertical font from list */
                   cf.Flags |= CF_ENABLEHOOK;
                   cf.lpfnHook = (LPCFHOOKPROC)ExceptVerticalFont;
#else
                   cf.lpfnHook = (LPCFHOOKPROC) NULL;
#endif

#ifdef JAPAN
                   /* Win 3.1 */
                   OldFontStruct = FontStruct;
#endif
                   nOldFontHeight = (short) FontStruct.lfHeight;
                   cy = HIWORD (GetDialogBaseUnits ());

                   /* 36 is the (height - 1) of the stc5 static control in font.dlg template */
                   if (((36 * cy) / 8) < -FontStruct.lfHeight)
                      FontStruct.lfHeight = -((36 * cy) / 8);

                   if (ChooseFont (&cf))
                   {
#if defined(JAPAN) || defined(KOREA)
                    /* We can use only NATIVE_CHARSET */
                      if (FontStruct.lfCharSet != NATIVE_CHARSET)
                      {
                         FontStruct = OldFontStruct;
                         break;
                      }
#endif
                      /* write new font info to ini file */
                       WritePrivateProfileString (szSection, szFontFileKey,
                                                  FontStruct.lfFaceName, szIniFile);
                       bNewFont = TRUE;
                       InvalidateRect(hWnd, NULL, TRUE);
                   }
                   else  /* restore old height */
                      FontStruct.lfHeight = nOldFontHeight;
                   break;
               }

               case IDM_UTC:
                   hMenu = GetMenu(hWnd);
                   if (!bUtc)
                   {
                       bUtc = TRUE;
                       CheckMenuItem(hMenu, IDM_UTC, MF_BYCOMMAND | MF_CHECKED);
                   }
                   else
                   {
                       bUtc = FALSE;
                       CheckMenuItem (hMenu, IDM_UTC, MF_BYCOMMAND | MF_UNCHECKED);
                   }
                   // call FormatInit to add or remove am/pm string (utc
                   // doesn't have it, non-utc does)
                   FormatInit();
                   ResetWinTitle (hWnd);
                   FormatTimeStr ();
                   bNewFont = TRUE;
                   InvalidateRect (hWnd, (LPRECT)NULL, TRUE);
                   ClockTimer (hWnd);
                   break;

               case IDM_NOTITLE:
                   goto toggle_title;

               case IDM_SECONDS:

                   /* toggle seconds option
                    */
                   hMenu = GetMenu (hWnd);
                   if (ClockDisp.bNoSeconds)
                   {
                       CheckMenuItem (hMenu, IDM_SECONDS, MF_BYCOMMAND | MF_CHECKED);
                       ClockDisp.bNoSeconds = FALSE;
                   }
                   else
                   {
                       CheckMenuItem (hMenu, IDM_SECONDS, MF_BYCOMMAND | MF_UNCHECKED);
                       ClockDisp.bNoSeconds = TRUE;
                   }
                   ClockTimerInterval (hWnd);
                   FormatTimeStr ();
                   bNewFont = TRUE;
                   InvalidateRect (hWnd, (LPRECT)NULL, TRUE);

                   break;

               case IDM_DATE:
                   /* toggles date option
                    */
                   hMenu = GetMenu (hWnd);
                   if (ClockDisp.bNoDate)
                   {
                       CheckMenuItem (hMenu, IDM_DATE, MF_BYCOMMAND | MF_CHECKED);
                       ClockDisp.bNoDate = FALSE;
                   }
                   else
                   {
                       CheckMenuItem (hMenu, IDM_DATE, MF_BYCOMMAND | MF_UNCHECKED);
                       ClockDisp.bNoDate = TRUE;
                   }
                   bNewFont = TRUE;
                   if (ClockDisp.wFormat == IDM_DIGITAL)
                       InvalidateRect(hWnd, (LPRECT)NULL, TRUE);
                   else
                       ResetWinTitle (hWnd);
                   break;

               case IDM_ABOUT:
                   ShellAbout(hWnd, szAppName, TEXT(""), LoadIcon(hInst, TEXT("cckk")));
                   break;

               default:
                   goto defproc;
           }
           break;

       case WM_MOUSEACTIVATE:
           /* right button temporarily hides the window if topmost is
            * enabled (window re-appears when right button is released).
            * When this happens, we don't want to activate the clock window
            * just before hiding it (it would look really bad), so we
            * intercept the activate message.
            */
           if (GetAsyncKeyState (VK_RBUTTON) & 0x8000)
               return (MA_NOACTIVATE);
           else
               goto defproc;
           break;

       case WM_INITMENU:
           bCantHide = TRUE;
           goto defproc;

       case WM_MENUSELECT:
           if (LOWORD (lParam) == -1  && HIWORD(lParam) == 0)
               bCantHide = FALSE;
           goto defproc;

       case WM_RBUTTONDOWN:
       case WM_NCRBUTTONDOWN:
           /* right button temporarily hides the window, if the window
            * is topmost, and if no menu is currently "active"
            */
           if (!bTmpHide && ClockDisp.bTopMost && !bCantHide)
           {
               ShowWindow (hWnd, SW_HIDE);
               SetCapture (hWnd);
               bTmpHide = TRUE;
           }
           break;

       case WM_RBUTTONUP:
       case WM_NCRBUTTONUP:
           /* if window is currently hidden, right button up brings it
            * back. Must make sure we show it in its previous state - ie:
            * minimized, maximized or normal.
            */
           if (bTmpHide)
           {
               ReleaseCapture ();
               if (ClockDisp.bIconic)
                   ShowWindow (hWnd, SW_SHOWMINNOACTIVE);
               else if (IsZoomed (hWnd))
                   ShowWindow (hWnd, SW_SHOWMAXIMIZED);
               else
                   ShowWindow (hWnd, SW_SHOWNOACTIVATE);
               bTmpHide = FALSE;
           }
           break;


       case WM_KEYDOWN:
           /* ESC key toggles the menu/title bar (just like a double click
            * on the client area of the window.
            */
           if ((wParam == VK_ESCAPE) && !(HIWORD (lParam) & 0x4000))
               goto toggle_title;
           break;

       case WM_NCLBUTTONDBLCLK:
           if (!ClockDisp.bNoTitle)
               /* if we have title bars etc. let the normal sutff take place */
               goto defproc;
           /* else: no title bars, then this is actually a request to bring
            * the title bars back...
            */
           /* fall through */

       case WM_LBUTTONDBLCLK:
toggle_title:
           fDisplay = FALSE;
           ClockDisp.bNoTitle = (ClockDisp.bNoTitle ? FALSE : TRUE);
           SetMenuBar (hWnd);
           break;

       case WM_NCHITTEST:
           /* if we have no title/menu bar, clicking and dragging the client
            * area moves the window. To do this, return HTCAPTION.
            * Note dragging not allowed if window maximized, or if caption
            * bar is present.
            */
           wParam = DefWindowProc(hWnd, message, wParam, lParam);
           if (ClockDisp.bNoTitle && (wParam == HTCLIENT) && !IsZoomed(hWnd))
               return HTCAPTION;
           else
               return wParam;

       case WM_SIZE:
           bNewFont = TRUE;
           ClockSize(hWnd, (int) LOWORD (lParam), (int) HIWORD (lParam), (WORD) wParam);
           UpdateWindow(hWnd);
           break;

       case WM_QUERYDRAGICON:
           return (LRESULT) LoadIcon (hInst, TEXT("cckk"));

       case WM_DESTROY:
       {
         HCURSOR   hTempCursor;

           KillTimer (hWnd, TimerID);
           DeleteTools ();
           if (hFont)
               DeleteObject (hFont);
           if (hFontDate)
               DeleteObject (hFontDate);
           if (ClockDisp.hBitmap)
               DeleteObject (ClockDisp.hBitmap);

           SetCapture (hWnd);
           hTempCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));

           SaveClockOptions (hWnd);

           PostQuitMessage (0);
           break;
       }

       case WM_WININICHANGE:
           FormatInit ();
           FormatDateStr (&oDate, ClockDisp.bIconic);
           ResetWinTitle (hWnd);
           FormatTimeStr ();
           bNewFont = TRUE;
           InvalidateRect (hWnd, (LPRECT)NULL, TRUE);
           break;

       case WM_PAINT:

           /* 25-Mar-1987. Added to force total repaint to solve
            * problem of garbage under second hand when hidden
            * by menu or popup.
            */
           InvalidateRect (hWnd, (LPRECT)NULL, TRUE);
           fDisplay = FALSE;
           BeginPaint (hWnd, &ps);
           ClockPaint (hWnd, ps.hdc, REPAINT);
           EndPaint (hWnd, &ps);
           break;

       case WM_TIMECHANGE:
           /* Redraw. */
           oDate.day = 0;
           InvalidateRect (hWnd, (LPRECT)NULL, TRUE);
           /* fall through */

       case WM_TIMER:
           ClockTimer (hWnd);
           break;

       case WM_SYSCOMMAND:
           switch (wParam)
           {
               case SC_MINIMIZE:
                   if (!IsZoomed (hWnd))
                       GetWindowRect (hWnd, &rCoordRect);
                   if (ClockDisp.bTopMost)
                   {
                       ClockDisp.bTopMost = FALSE;
                       PostMessage (hWnd, WM_SYSCOMMAND, IDM_TOPMOST, 0L);
                   }
                   break;

               case SC_MAXIMIZE:
                   if (!IsIconic (hWnd))
                       GetWindowRect (hWnd, &rCoordRect);
                   break;

               case IDM_TOPMOST:
               {
                   /* toggles topmost option
                    */
                   hMenu = GetSystemMenu (hWnd, FALSE);
                   if (ClockDisp.bTopMost)
                   {
                       CheckMenuItem (hMenu, IDM_TOPMOST, MF_BYCOMMAND | MF_UNCHECKED);
                       SetWindowPos (hWnd, HWND_NOTOPMOST, 0, 0, 0, 0,
                                        SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
                       ClockDisp.bTopMost = FALSE;
                   }
                   else
                   {
                       CheckMenuItem (hMenu, IDM_TOPMOST, MF_BYCOMMAND | MF_CHECKED);
                       SetWindowPos (hWnd, HWND_TOPMOST, 0, 0, 0, 0,
                                        SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
                       ClockDisp.bTopMost = TRUE;
                   }
                   break;
               }
           }
           return (DefWindowProc(hWnd, message, wParam, lParam));
           break;

       case WM_SYSCOLORCHANGE:
           DeleteTools ();
           CreateTools ();
           break;

       case WM_ERASEBKGND:
       {
         RECT rect;
         HBRUSH  hBr;
         DWORD   rgbCol;
         HDC     hDC;

           GetClientRect (hWnd, &rect);
           hDC = GetDC (hWnd);
           SetBkMode (hDC, OPAQUE);

           /* Make a temp brush to color the background.  This is to
            * force use of a solid color so the hand motion is painted
            * correctly.
            */
           rgbCol = GetNearestColor(hDC, GetSysColor(COLOR_BTNFACE));


           /* CHECK RETURN VALUE!! */
           hBr = CreateSolidBrush(rgbCol);

           FillRect((HDC)wParam, &rect, hBr);
           ReleaseDC (hWnd, hDC);
           DeleteObject(hBr);
           break;
       }

       case WM_ENDSESSION:
           if (wParam)
               SaveClockOptions (hWnd);
           break;

       default:                          /* Passes it on if unproccessed    */
defproc:
           return (DefWindowProc (hWnd, message, wParam, lParam));
    }
    return (0);
}


/*
 *  ResetWinTitle() - Sets the window title with the date if appropriate
 *
 *  The date is part of the window text when the clock is minimized, or when
 *  it is analog, and the date option is selected.
 */

void NEAR PASCAL ResetWinTitle (HWND hWnd)
{
TCHAR    szNewTitle[BUFLEN+20];

    if (((ClockDisp.wFormat == IDM_DIGITAL) && !ClockDisp.bIconic)
        || ClockDisp.bNoDate)
        SetWindowText (hWnd, szAppName);   /* no date in title if digital */
    else
    {
        wsprintf (szNewTitle, TEXT("%s - %s"), szAppName, ClockDisp.szDate);
        SetWindowText (hWnd, szNewTitle);
    }
}


void NEAR PASCAL CreateTools (void)
{
#define BLOB_COLOR  RGB (0,128,128)

    hbrForeground  = CreateSolidBrush (GetSysColor (COLOR_BTNSHADOW));
    hbrColorWindow = CreateSolidBrush (GetSysColor (COLOR_BTNFACE));
    hbrBtnHighlight= CreateSolidBrush (GetSysColor (COLOR_BTNHIGHLIGHT));
    hbrBlobColor   = CreateSolidBrush (BLOB_COLOR);
    hpenForeground = CreatePen (0, 1, GetSysColor (COLOR_WINDOWTEXT));
    hpenShadow     = CreatePen (0, 1, GetSysColor (COLOR_BTNSHADOW));
    hpenBackground = CreatePen (0, 1, GetSysColor (COLOR_BTNFACE));
    hpenBlobHlt    = CreatePen (0, 1, RGB (0,255,255));
    hpenRed        = CreatePen (0, 1, RGB (255, 0, 0));
    hCurWait       = LoadCursor (NULL, IDC_WAIT);
}


void NEAR PASCAL ClockCreate (HWND hWnd)
{
  register HDC    hDC;
  int             HorzSize;
  int             VertSize;


    hDC = GetDC (hWnd);
    VertRes = GetDeviceCaps (hDC, VERTRES);
    HorzRes = GetDeviceCaps (hDC, HORZRES);
    VertSize= GetDeviceCaps (hDC, VERTSIZE);
    HorzSize= GetDeviceCaps (hDC, HORZSIZE);
    ReleaseDC (hWnd, hDC);

    aspectN = MulDiv (VertRes, 100, VertSize);
    aspectD = MulDiv (HorzRes, 100, HorzSize);

    CreateTools ();

}


/*
 *  ClockTimerInterval()
 *
 *  Sets the timer interval. Two things affect this interval:
 *    1) if the window is iconic, or
 *    2) if Seconds option has been disabled
 *  In both cases, timer ticks occur every half-minute. Otherwise, timer
 *  every half-second.
 *  Gets the flags from ClockDisp structure.
 */

void  PASCAL ClockTimerInterval (HWND hWnd)
{

    if (ClockDisp.bIconic || ClockDisp.bNoSeconds)
    {
        /* Update once every 1/2 minute in the iconic state, or if
         * seconds display suppressed
         */
        KillTimer (hWnd, TimerID);
        SetTimer (hWnd, TimerID, (WORD)ICON_TLEN, 0L);
    }
    else
    {
        /* Update every 1/2 second in the opened state. */
        KillTimer (hWnd, TimerID);
        SetTimer (hWnd, TimerID, OPEN_TLEN, 0L);
    }
}


/*
 *  ClockTimer()
 *
 *      msg - timer ID
 *
 * Called by windows to tell CLOCK there has been a time change.
 *
 */

void NEAR PASCAL ClockTimer (HWND hWnd)
{
  HDC     hDC;
  TIME    nTime;
  xDATE   nDate;


    GetTime (&nTime);
    GetDate (&nDate);
    if (fDisplay)
       return;

    if (ClockDisp.bNoSeconds || ClockDisp.bIconic)
    {
        KillTimer (hWnd, TimerID);
        SetTimer (hWnd, TimerID, (WORD)(61 - nTime.second) * 100, 0L);
    }
    /* It's possible to change any part of the system at any time
     * through the Control Panel.  So we check everything.
     */
    if (((nTime.second == oTime.second) || ClockDisp.bIconic || ClockDisp.bNoSeconds) &&
        (nTime.minute == oTime.minute)          &&
        (nTime.hour24 == oTime.hour24)          &&
        ((nDate.day == oDate.day    &&
         nDate.month == oDate.month &&
         nDate.year == oDate.year ) || ClockDisp.bNoDate))
        return;

    hDC = GetDC (hWnd);
    ClockPaint (hWnd, hDC, HANDPAINT);
    ReleaseDC (hWnd, hDC);
}


VOID GetTime (TIME * pTime)
{
  SYSTEMTIME st;

    if  (bUtc)
       GetSystemTime (&st);
    else
       GetLocalTime (&st);

    if (st.wHour > 11)
       pTime->ampm = 1;
    else
       pTime->ampm = 0;

    if (st.wHour == 0 && !ClockDisp.wTimeFormat)
       st.wHour = 12;

    pTime->hour = st.wHour;
    pTime->hour24 = pTime->hour12 = st.wHour;
    if (pTime->hour12 > 12)
        pTime->hour12 -= 12;

    pTime->minute = st.wMinute;
    pTime->second = st.wSecond;
}

void NEAR GetDate (xDATE * pDate)
{
  SYSTEMTIME st;

    if (bUtc)
       GetSystemTime(&st);
    else
       GetLocalTime(&st);

    pDate->day= st.wDay;
    pDate->month= st.wMonth;
    pDate->year= st.wYear;
}


/*
 * FormatTimeStr()
 *
 * Creates a template for the time, based on options in the ClockDisp
 * structure. ie: seconds or no seconds, AM/PM string, etc.
 * The result is used in ExtTextOut calls to determine the size of the
 * time string.
 * Note that this is based on the assumption that digits are fixed pitch
 * (and so '8' is used as a dummy digit).
 * Bad things will happen if the selected font has proportional digits!!!
 */

void NEAR PASCAL FormatTimeStr (void)
{
    LPTSTR  pstr;
    int     i;
    TCHAR   szAMPM[MAX_AMPM_LEN];
    TCHAR   szTime[MAX_TIME_SEP + MAX_AMPM_LEN + 8];
    int     iAMPMLen;


    pstr = ClockDisp.szTimeFmt;

    if (!ClockDisp.bIconic)
    {
        /*
         *  Build the widest possible AM/PM string.
         *  This assumes the widest proportional character is M.
         */
        iAMPMLen = ClockDisp.nMaxAMPMLen;
        for (i = 0; i < iAMPMLen; i++)
        {
            szAMPM[i] = TEXT('M');
        }

        if (ClockDisp.wAMPMPosition && iAMPMLen)
        {
            /*
             *  Length includes a space, so write the space to the
             *  buffer instead of the M.
             */
            szAMPM[i - 1] = TEXT(' ');
        }
        szAMPM[i] = TEXT('\0');

        /*
         *  Get the Time string.
         */
        wsprintf (szTime, TEXT("88%c88"), ClockDisp.szTimeSep[0]);
        if (!ClockDisp.bNoSeconds)
        {
            wsprintf (szTime + 5, TEXT("%c88"), ClockDisp.szTimeSep[0]);
        }
        lstrcat (szTime, TEXT(" "));

        /*
         *  Build the actual format string in the proper order.
         */
        if (ClockDisp.wAMPMPosition)
        {
            lstrcpy (pstr, szAMPM);
            lstrcat (pstr, szTime);
        }
        else
        {
            lstrcpy (pstr, szTime);
            lstrcat (pstr, szAMPM);
        }
    }
    else
    {
        /*
         *  Icon - only show hours and minutes.
         */
        wsprintf (pstr, TEXT("88%c88"), ClockDisp.szTimeSep[0] );
    }

    /*
     *  Remove trailing space, if necessary.
     */
    ClockDisp.nTimeLen = lstrlen (pstr);
    if (pstr[ClockDisp.nTimeLen - 1] == TEXT(' '))
    {
       ClockDisp.nTimeLen--;
       pstr[ClockDisp.nTimeLen] = TEXT('\0');
    }
}


/*
 *  ClockPaint()
 */

void NEAR PASCAL ClockPaint (HWND hWnd, register HDC hDC, int hint)
{
  int     hour;
  RECT    Rect;
  TIME    nTime;
  xDATE   nDate;
  TCHAR   szTime[6];
  HDC     hTmpDC = NULL;
  HBITMAP hOldBM;
  HFONT   h;

    GetTime (&nTime);
    GetDate (&nDate);

    if ((nDate.day != oDate.day)      ||
        (nDate.month != oDate.month)  ||
        (nDate.year != oDate.year))
    {
        /* new date - so reformat date string */
        FormatDateStr (&nDate, ClockDisp.bIconic);
        ResetWinTitle (hWnd);
        bNewFont = TRUE;
    }

    if (ClockDisp.wFormat == IDM_DIGITAL)
    {
        /*******************/
        /* Digital Display */
        /*******************/

        /* Is the font ready yet? */
        if (!hFont || bNewFont)
        {
            GetClientRect (hWnd, &Rect);
            /* Create a suitable font */
            SizeFont (hWnd, Rect.bottom - Rect.top, Rect.right - Rect.left);
            bNewFont = FALSE;
        }

        if (hFont)
            h = SelectObject (hDC, hFont);
        else
            h = 0;
        SetBkColor (hDC, GetSysColor (COLOR_BTNFACE));
        SetTextAlign (hDC, TA_LEFT);

        if (ClockDisp.wShdwOff && (hTmpDC = CreateCompatibleDC (hDC)))
        {
            /* we will want to print shadowed text. Attempt to allocate
             * the offscreen DC and bitmap for this.
             */
            if (!(hOldBM = SelectObject (hTmpDC, ClockDisp.hBitmap)))
            {
                /* select failed. Perhaps the bitmap was discarded.
                 * So attempt to reallocate a bitmap
                 */
                DeleteObject (ClockDisp.hBitmap);
                ClockDisp.hBitmap = CreateDiscardableBitmap (hDC,
                                                             2*ClockDisp.nSizeChar + 2*ClockDisp.wShdwOff,
                                                             ClockDisp.nSizeY);
                if (!ClockDisp.hBitmap ||
                    !(hOldBM = SelectObject (hTmpDC, ClockDisp.hBitmap)))
                {
                    /* either we couldn't re-allocate the bitmap, or the
                     * select failed again (ie: not because the bitmap
                     * was discarded). Either way, we can't use an offscreen.
                     */
                    DeleteDC (hTmpDC);
                    hTmpDC = NULL;
                }
            }
            if (hTmpDC)
            {
                /* we can use our offscreen. Prepare it for use.
                 */
                if (hFont)
                    SelectObject (hTmpDC, hFont);
                SetBkColor (hTmpDC, GetSysColor (COLOR_BTNFACE));
                SetTextAlign (hTmpDC, TA_LEFT);
            }
        }

        if (hint == REPAINT || ClockDisp.bIconic)
        {
            SelectObject (hDC, hbrColorWindow);
            /* Set old values as undefined, so entire clock updated. */
            oTime.hour24 = 25;
            oTime.minute = 60;
            oTime.ampm   = 2;
            oDate.day = 0;

            /* paint the separators */
            PrintShadowText (hDC,
                             ClockDisp.nPosSep1,
                             ClockDisp.nPosY,
                             ClockDisp.nSizeSep,
                             ClockDisp.nSizeY,
                             &ClockDisp.szTimeSep[0],
                             1,
                             hTmpDC);
            if (!ClockDisp.bIconic && !ClockDisp.bNoSeconds)
                PrintShadowText (hDC,
                                 ClockDisp.nPosSep2,
                                 ClockDisp.nPosY,
                                 ClockDisp.nSizeSep,
                                 ClockDisp.nSizeY,
                                 &ClockDisp.szTimeSep[0],
                                 1,
                                 hTmpDC);
        }

        if (!ClockDisp.bIconic)
        {
            if (ClockDisp.wAMPMPosition)
            {
                /*
                 *  AM/PM - Prefix.
                 */
                if ((oTime.ampm != nTime.ampm) || (oTime.hour24 != nTime.hour24))
                {
                    Rect.left = ClockDisp.nPosAMPM;
                    Rect.top = ClockDisp.nPosY;
                    Rect.right = ClockDisp.nPosHr + ClockDisp.nSizeChar;
                    Rect.bottom = ClockDisp.nPosY + ClockDisp.nSizeY;
                    FillRect (hDC, &Rect, hbrColorWindow);
                }
            }
            else
            {
                /*
                 *  AM/PM - Suffix.
                 */
                if (oTime.ampm != nTime.ampm)
                {
                    PrintShadowText (hDC,
                                     ClockDisp.nPosAMPM,
                                     ClockDisp.nPosY,
                                     ClockDisp.nSizeAMPM,
                                     ClockDisp.nSizeY,
                                     ClockDisp.szAMPM[nTime.ampm],
                                     lstrlen (ClockDisp.szAMPM[nTime.ampm]),
                                     hTmpDC);
                }
            }
        }

        if (!ClockDisp.bIconic && !ClockDisp.bNoSeconds)
        {
            /* paint the seconds */
            szTime[0] = TEXT('0') + nTime.second / 10;
            szTime[1] = TEXT('0') + nTime.second % 10;
            PrintShadowText (hDC,
                             ClockDisp.nPosSec,
                             ClockDisp.nPosY,
                             2 * ClockDisp.nSizeChar,
                             ClockDisp.nSizeY,
                             szTime,
                             2,
                             hTmpDC);
        }

        if (oTime.minute != nTime.minute)
        {
            /* paint the minutes */
            szTime[0]  = TEXT('0') + nTime.minute / 10;
            szTime[1]  = TEXT('0') + nTime.minute % 10;
            PrintShadowText (hDC,
                             ClockDisp.nPosMin,
                             ClockDisp.nPosY,
                             2 * ClockDisp.nSizeChar,
                             ClockDisp.nSizeY,
                             szTime,
                             2,
                             hTmpDC);
        }

        if (oTime.hour24 != nTime.hour24)
        {
            /* paint the hours */
            if (ClockDisp.wTimeFormat)
                hour = nTime.hour24;
            else
                hour = nTime.hour12;

            szTime[0] = TEXT('0') + hour / 10;
            szTime[1] = TEXT('0') + hour % 10;

            /* Kill Leading zero if needed. */
            if (ClockDisp.wTimeLZero == 0 && szTime[0] == TEXT('0'))
            {
                PrintShadowText (hDC,
                                 ClockDisp.nPosHr + ClockDisp.nSizeChar,
                                 ClockDisp.nPosY,
                                 ClockDisp.nSizeChar,
                                 ClockDisp.nSizeY,
                                 szTime + 1,
                                 1,
                                 hTmpDC);
                if ((oTime.hour12 > 9) ||
                    (ClockDisp.wTimeFormat && (oTime.hour24 > 9)))
                {
                    /* if we just switched from 12 to 1 (or 11 to 0),
                     * erase leading 1
                     */
                    Rect.left = ClockDisp.nPosHr;
                    Rect.top = ClockDisp.nPosY;
                    Rect.right = ClockDisp.nPosHr + ClockDisp.nSizeChar;
                    Rect.bottom = ClockDisp.nPosY + ClockDisp.nSizeY;
                    FillRect (hDC, &Rect, hbrColorWindow);
                }
            }
            else
            {
                PrintShadowText (hDC,
                                 ClockDisp.nPosHr,
                                 ClockDisp.nPosY,
                                 2 * ClockDisp.nSizeChar,
                                 ClockDisp.nSizeY,
                                 szTime,
                                 2,
                                 hTmpDC);
            }
        }

        if (ClockDisp.wAMPMPosition && !ClockDisp.bIconic)
        {
            if ((oTime.ampm != nTime.ampm) || (oTime.hour24 != nTime.hour24))
            {
                int hh;

                if (ClockDisp.wTimeFormat)
                    hour = nTime.hour24;
                else
                    hour = nTime.hour12;

                szTime[0] = TEXT('0') + hour / 10;

                /* Kill Leading zero if needed. */
                if (ClockDisp.wTimeLZero == 0 && szTime[0] == TEXT('0'))
                    hh = ClockDisp.nSizeChar;
                else
                    hh = 0;

                PrintShadowText (hDC,
                                 ClockDisp.nPosAMPM + hh,
                                 ClockDisp.nPosY,
                                 ClockDisp.nSizeAMPM,
                                 ClockDisp.nSizeY,
                                 ClockDisp.szAMPM[nTime.ampm],
                                 lstrlen (ClockDisp.szAMPM[nTime.ampm]),
                                 hTmpDC);
            }
        }

        if (hTmpDC)
        {
            SelectObject (hDC, hOldBM);
            DeleteDC (hTmpDC);
            hTmpDC = NULL;
        }

        if ((oDate.day != nDate.day     ||
             oDate.month != nDate.month ||
             oDate.year != nDate.year) && bDisplayDate)
        {
            /* paint the date - first erase old string, 'cause new string
             * may be shorter. Problem: we no longer know the extent of
             * the old string, so paint the whole x-extent of the clock
             * window. Don't worry, this doesn't happen too often. */
            GetClientRect (hWnd, &Rect);
            Rect.top = ClockDisp.nPosDateY;
            Rect.bottom = ClockDisp.nPosDateY + ClockDisp.nSizeDateY;
            FillRect (hDC, &Rect, hbrColorWindow);

            if (hFontDate)
                h = SelectObject (hDC, hFontDate);
            else
                h = 0;
            PrintShadowText (hDC,
                             ClockDisp.nPosDateX,
                             ClockDisp.nPosDateY,
                             ClockDisp.nSizeDateX,
                             ClockDisp.nSizeDateY,
                             ClockDisp.szDate,
                             ClockDisp.nDateLen,
                             hTmpDC);
        }

        if (h)
            SelectObject(hDC, h);
    }
    else
    {
        /******************/
        /* Analog display */
        /******************/

        if (hint == REPAINT)
        {
            SetBkMode (hDC, TRANSPARENT);

            DrawFace (hDC);
            if (!ClockDisp.bIconic)
            {
                DrawFatHand (hDC, oTime.hour * 5 + (oTime.minute / 12), hpenForeground, HHAND);
                DrawFatHand (hDC, oTime.minute, hpenForeground, MHAND);
            }
            else
            {
                DrawHand (hDC, oTime.hour * 5 + (oTime.minute / 12), hpenForeground, HOURSCALE, R2_COPYPEN);
                DrawHand (hDC, oTime.minute, hpenForeground, MINUTESCALE, R2_COPYPEN);
            }

            if (!ClockDisp.bIconic && !ClockDisp.bNoSeconds)
                /* Draw the second hand. */
                DrawHand (hDC, oTime.second, hpenBackground, SECONDSCALE, R2_NOT);

            /* NOTE: Don't update oTime in this case! */

            if (ClockDisp.bIconic)
                DrawIconBorder (hWnd, hDC);
            return;
        }
        else if (hint == HANDPAINT)
        {
            SetBkMode(hDC, TRANSPARENT);
            if ((!ClockDisp.bIconic && !ClockDisp.bNoSeconds) && nTime.second != oTime.second)
                /* Erase the old second hand. */
                DrawHand (hDC, oTime.second, hpenBackground, SECONDSCALE, R2_NOT);

            if (nTime.minute != oTime.minute || nTime.hour != oTime.hour)
            {
                if (ClockDisp.bIconic)
                {
                    DrawHand (hDC, oTime.minute, hpenBackground, MINUTESCALE, R2_COPYPEN);
                    DrawHand (hDC, oTime.hour * 5 + (oTime.minute / 12), hpenBackground, HOURSCALE, R2_COPYPEN);
                    DrawHand (hDC, nTime.minute, hpenForeground, MINUTESCALE, R2_COPYPEN);
                    DrawHand (hDC, nTime.hour * 5 + (nTime.minute / 12), hpenForeground, HOURSCALE, R2_COPYPEN);
                }
                else
                {
                    DrawFatHand (hDC, oTime.hour * 5 + (oTime.minute/12), hpenBackground, HHAND);
                    DrawFatHand (hDC, oTime.minute, hpenBackground, MHAND);

                    DrawFatHand (hDC, (nTime.hour) * 5 + (nTime.minute / 12), hpenForeground, HHAND);
                    DrawFatHand (hDC, nTime.minute, hpenForeground, MHAND);
                }
            }

            if ((!ClockDisp.bIconic && !ClockDisp.bNoSeconds) && nTime.second != oTime.second)
                /* Draw new second hand */
                DrawHand (hDC, nTime.second, hpenBackground, SECONDSCALE, R2_NOT);
        }

    }

    if (ClockDisp.bIconic)
        DrawIconBorder (hWnd, hDC);

    oTime = nTime;
    oDate = nDate;
}

void Adjust (POINT * rgpt, INT cPoint, INT iDelta)
{
   INT i;

     for (i = 0; i < cPoint; i++)
     {
        rgpt[i].x += iDelta;
        rgpt[i].y += iDelta;
     }
}


/*
 *  DrawFatHand() - Draws either hour or minute hand.
 */

void NEAR PASCAL DrawFatHand (register HDC hDC, int pos, HPEN hPen, BOOL hHand)
{
  register int  m;
  int           n;
  int           scale;

  TRIG     tip;
  TRIG     stip;
  BOOL     fErase;

    SetROP2 (hDC, 13);
    fErase = (hPen == hpenBackground);

    SelectObject (hDC, hPen);

    scale = hHand ? 7 : 5;

    n = (pos + 15) % 60;
    m = MulDiv (clockRadius, scale, 100);
    stip.y = (SHORT) MulDiv (lpcirTab[n].y, m, 8000);
    stip.x = (SHORT) MulDiv (lpcirTab[n].x, m, 8000);

    scale = hHand ? 65 : 80;
    tip.y = (SHORT) MulDiv (lpcirTab[pos % 60].y, MulDiv (clockRadius, scale, 100), 8000);
    tip.x = (SHORT) MulDiv (lpcirTab[pos % 60].x, MulDiv (clockRadius, scale, 100), 8000);
    {
      POINT  rgpt[4];
      HBRUSH hbrInit;

        rgpt[0].x = clockCenter.x + stip.x;
        rgpt[0].y = clockCenter.y + stip.y;
        rgpt[1].x = clockCenter.x + tip.x;
        rgpt[1].y = clockCenter.y + tip.y;
        rgpt[2].x = clockCenter.x - stip.x;
        rgpt[2].y = clockCenter.y - stip.y;

        scale = hHand ? 15 : 20;

        n = (pos + 30) % 60;
        m = MulDiv (clockRadius, scale, 100);
        tip.y = (SHORT) MulDiv (lpcirTab[n].y, m, 8000);
        tip.x = (SHORT) MulDiv (lpcirTab[n].x, m, 8000);

        rgpt[3].x = clockCenter.x + tip.x;
        rgpt[3].y = clockCenter.y + tip.y;

        SelectObject (hDC, GetStockObject (NULL_PEN));
        if (fErase)
        {
            hbrInit = SelectObject (hDC, hbrColorWindow);
        }
        if (fShadedHands)
        {
            Adjust (rgpt, 4, -2);
            if (!fErase)
            {
               hbrInit = SelectObject (hDC, hbrBtnHighlight);
            }
            Polygon(hDC, rgpt, 4);

            if (!fErase)
            {
               SelectObject (hDC, hbrForeground);
            }
            Adjust (rgpt, 4, 4);
            Polygon (hDC, rgpt, 4);

            Adjust (rgpt, 4, -2);
        }
        if (!fErase)
        {
           SelectObject (hDC, hbrBlobColor);
        }
        Polygon (hDC, rgpt, 4);
        /*
         * if we selected a brush in, reset it now.
         */
        if (fErase || fShadedHands) {
           SelectObject(hDC, hbrInit);
        }
    }
}


/*
 *  DrawFace()
 */

void NEAR PASCAL DrawFace(HDC hDC)
{
  int      i;
  RECT     tRect;
  TRIG *   ppt;
  int      blobHeight, blobWidth;

    blobWidth = MulDiv (MAXBLOBWIDTH, (clockRect.right - clockRect.left), HorzRes);
    blobHeight = MulDiv (blobWidth, aspectN, aspectD);

    if (blobHeight < 2)
        blobHeight = 1;

    if (blobWidth < 2)
        blobWidth = 2;

    InflateRect (&clockRect, -(blobHeight >> 1), -(blobWidth >> 1));


    clockRadius = (int) ((clockRect.right - clockRect.left-8) >> 1);
    clockCenter.y = (SHORT) (clockRect.top + ((clockRect.bottom - clockRect.top) >> 1) - 1);
    clockCenter.x = (SHORT) (clockRect.left + clockRadius+3);

    for (i = 0; i < 60; i++)
    {
        ppt = lpcirTab + i;

        tRect.top  = MulDiv (ppt->y, clockRadius, 8000) + clockCenter.y;
        tRect.left = MulDiv (ppt->x, clockRadius, 8000) + clockCenter.x;

        fShadedHands = FALSE;

        if (i % 5)
        {
            /* Draw a dot. */
            if (blobWidth > 2 && blobHeight >= 2)
            {
                fShadedHands = TRUE;
                tRect.right = tRect.left + 2;
                tRect.bottom = tRect.top + 2;
                FillRect (hDC, &tRect, GetStockObject (WHITE_BRUSH));
                OffsetRect (&tRect, -1, -1);
                FillRect (hDC, &tRect, hbrForeground);
                tRect.left++;
                tRect.top++;
                FillRect (hDC, &tRect, hbrColorWindow);
            }
        }
        else if (!ClockDisp.bIconic)
        {
            tRect.right = tRect.left + blobWidth;
            tRect.bottom = tRect.top + blobHeight;
            OffsetRect (&tRect, -(blobWidth >> 1) , -(blobHeight >> 1));

            SelectObject (hDC, GetStockObject (BLACK_PEN));
            SelectObject (hDC, hbrBlobColor);

            Rectangle (hDC, tRect.left, tRect.top, tRect.right, tRect.bottom);
            SelectObject (hDC, hpenBlobHlt);
            MoveTo (hDC, tRect.left, tRect.bottom-1);
            LineTo (hDC, tRect.left, tRect.top);
            LineTo (hDC, tRect.right-1, tRect.top);
        }
        else
        {
            PatBlt (hDC, tRect.left, tRect.top, 2, 2, BLACKNESS);
            PatBlt (hDC, tRect.left, tRect.top, 1, 1, WHITENESS);
        }
    }
    InflateRect (&clockRect, (blobHeight >> 1), (blobWidth >> 1));
}

/*
 *  DrawIconBorder() - Draws a Border around either icon-clock.
 */

void NEAR PASCAL DrawIconBorder (HWND hWnd, register HDC hDC)
{
  RECT Rect;

    /* draws a "sunk-in" border, ie: double black outline top and left,
     * single white outline bottom and right.
     */
    GetClientRect (hWnd, &Rect);

    SelectObject (hDC, GetStockObject (BLACK_PEN));
    MoveTo (hDC, Rect.left, Rect.top + 1);
    LineTo (hDC, Rect.left, Rect.bottom - 1);
    MoveTo (hDC, Rect.left+1, Rect.bottom - 1);
    LineTo (hDC, Rect.right - 1, Rect.bottom - 1);
    MoveTo (hDC, Rect.right - 1, Rect.bottom - 2);
    LineTo (hDC, Rect.right - 1, Rect.top);
    MoveTo (hDC, Rect.right - 2, Rect.top);
    LineTo (hDC, Rect.left, Rect.top);

    MoveTo (hDC, Rect.left + 2, Rect.top + 2);
    LineTo (hDC, Rect.left + 2, Rect.bottom - 3);
    LineTo (hDC, Rect.right - 3, Rect.bottom - 3);
    LineTo (hDC, Rect.right - 3, Rect.top + 2);
    LineTo (hDC, Rect.left + 2, Rect.top + 2);

    SelectObject (hDC, hpenRed);
    MoveTo (hDC, Rect.left + 1, Rect.top + 1);
    LineTo (hDC, Rect.left + 1, Rect.bottom - 2);
    LineTo (hDC, Rect.right - 2, Rect.bottom - 2);
    LineTo (hDC, Rect.right - 2, Rect.top + 1);
    LineTo (hDC, Rect.left + 1, Rect.top + 1);
}


/*
 * FormatDateStr() - prepare the formatted date string
 *
 * parameters:
 *  xDATE *pDate - structure contains current date
 *  BOOL bRealShort - if TRUE, the year is not added to the string (ie:
 *                    only use the day and the month)
 *
 * This will format the given date according to the format specified
 * by the current Locale, and place the result in ClockDisp.szDate.
 */

void NEAR PASCAL FormatDateStr (xDATE * pDate, BOOL bRealShort)
{
  register int i = 0, j = 0;
  BOOL         bLead;
  TCHAR        cSep;

    while (ClockDisp.szDateFmt[i] && (j < MAX_DATE_LEN - 1))
    {
        bLead = FALSE;
        switch (cSep = ClockDisp.szDateFmt[i++])
        {
            case TEXT('d'):
                while (ClockDisp.szDateFmt[i] == TEXT('d'))
                {
                    bLead = TRUE;
                    i++;
                }
                if (bLead || (pDate->day / 10))
                    ClockDisp.szDate[j++] = TEXT('0') + pDate->day / 10;
                ClockDisp.szDate[j++] = TEXT('0') + pDate->day % 10;
                break;

            case TEXT('M'):
                while (ClockDisp.szDateFmt[i] == TEXT('M'))
                {
                    bLead = TRUE;
                    i++;
                }
                if (bLead || (pDate->month / 10))
                    ClockDisp.szDate[j++] = TEXT('0') + pDate->month / 10;
                ClockDisp.szDate[j++] = TEXT('0') + pDate->month % 10;
                break;

            case TEXT('y'):
                i++;
                if (ClockDisp.szDateFmt[i] == TEXT('y'))
                {
                    bLead = TRUE;
                    i+=2;
                }
                if (bLead && !bRealShort)
                {
                    ClockDisp.szDate[j++] = (pDate->year < 2000 ? TEXT('1') : TEXT('2'));
                    ClockDisp.szDate[j++] = (pDate->year < 2000 ? TEXT('9') : TEXT('0'));
                }
                if (!bRealShort)
                {
                    ClockDisp.szDate[j++] = TEXT('0') + (pDate->year % 100) / 10;
                    ClockDisp.szDate[j++] = TEXT('0') + (pDate->year % 100) % 10;
                }
                break;

            default:
                /* copy the current character into the formatted string - it
                 * is a separator. BUT: don't copy a separator into the
                 * very first position (could happen if the year comes first,
                 * but we're not using the year)
                 */
                if (j)
                    ClockDisp.szDate[j++] = cSep;
                break;
        }
    }
    while ((ClockDisp.szDate[j-1] < TEXT('0')) || (ClockDisp.szDate[j-1] > TEXT('9')))
        j--;
    ClockDisp.szDate[j] = TEXT('\0');
    ClockDisp.nDateLen = j;
}


/*
 *  PrintShadowText()
 *
 *  Parameters:
 *      HDC hdc - the window DC
 *      int nx, ny, sizex, sizey - position and extent of bounding box
 *      PSTR pszStr - actual string to print
 *      int nStrLen - length of pszStr
 *      HDC hOffScrnDC - an offscreen DC used to paint the shadowed text.
 *                       If this is NULL, the text is not shadowed.
 *                       Assumes the bitmap associated with this DC can
 *                       contain 2 digits. If the specified bounding box
 *                       does not fit in the bitmap, the shadowed text is
 *                       painted directly to the window DC (may cause flashing)
 *
 *  Shadowed text is: a white highlight top and left, dark highlight bottom
 *  and right. The character itself is painted the same color as the background
 *  (so only noticeable if both highlights are noticeable).
 */


void NEAR PASCAL PrintShadowText (register HDC hDC, int nx, int ny,
                                  int sizex, int sizey, LPTSTR pszStr,
                                  int nStrLen, HDC hOffScrnDC)
{
    RECT    Rect;
    register WORD    Shadow;

    if (!hOffScrnDC || fNoShadow)
    {
        /* If no valid offscreen DC is provided, then we can NOT print
         * shadowed text. Simply print the normal font.
         */
        SetTextColor (hDC, GetSysColor (COLOR_BTNTEXT));

        Rect.top = ny;
        Rect.bottom = ny + sizey;
        Rect.left = nx;
        Rect.right = nx + sizex;
        ExtTextOut (hDC, nx, ny, ETO_OPAQUE | ETO_CLIPPED, &Rect,
                    pszStr, nStrLen, NULL);
    }
    else if (sizex > 2 * ClockDisp.nSizeChar)
    {
        /* print the shadowed text (but don't use offscreen bitmap because
         * the string is too long to fit)
         */
        Shadow = ClockDisp.wShdwOff;
        SetTextColor (hDC, GetSysColor (COLOR_BTNHIGHLIGHT));

        Rect.top = ny - Shadow;
        Rect.bottom = ny + sizey + Shadow;
        Rect.left = nx - Shadow;
        Rect.right = nx + sizex + Shadow;

        ExtTextOut (hDC, nx - Shadow, ny - Shadow,
                    ETO_OPAQUE | ETO_CLIPPED, &Rect, pszStr, nStrLen, NULL);

        SetBkMode (hDC, TRANSPARENT);
        SetTextColor (hDC, GetSysColor (COLOR_BTNSHADOW));
        ExtTextOut (hDC, nx + Shadow, ny + Shadow,
                    ETO_CLIPPED, &Rect, pszStr, nStrLen, NULL);

        SetTextColor (hDC, GetSysColor (COLOR_BTNFACE));
        ExtTextOut (hDC, nx, ny, ETO_CLIPPED, &Rect, pszStr, nStrLen, NULL);
    }
    else
    {
        /* use the off-screen bitmap, and print shadowed text. */
        Shadow = ClockDisp.wShdwOff;

        Rect.left = 0;
        Rect.right = sizex + 2* Shadow;
        Rect.top = 0;
        Rect.bottom = sizey + 2* Shadow;

        SetTextColor (hOffScrnDC, GetSysColor (COLOR_BTNHIGHLIGHT));
        ExtTextOut (hOffScrnDC, 0, 0, ETO_OPAQUE | ETO_CLIPPED, &Rect, pszStr,
                    nStrLen, NULL);
        SetBkMode (hOffScrnDC, TRANSPARENT);
        SetTextColor (hOffScrnDC, GetSysColor (COLOR_BTNSHADOW));
        ExtTextOut (hOffScrnDC, 2 * Shadow, 2* Shadow,
                    ETO_CLIPPED, &Rect, pszStr, nStrLen, NULL);

        SetTextColor (hOffScrnDC, GetSysColor (COLOR_BTNFACE));
        ExtTextOut (hOffScrnDC, Shadow, Shadow,
                    ETO_CLIPPED, &Rect, pszStr, nStrLen, NULL);

        BitBlt (hDC, nx-Shadow, ny-Shadow,
                Rect.right, Rect.bottom, hOffScrnDC, 0, 0, SRCCOPY);
    }
}

/*
 * SizeFont() - size font according to window size
 *
 * Only useful in digital mode.
 * Create a font that will fit the current time format (based on the
 * time template). Center the string, set up the positions for the
 * different components of the time string.
 * Do the same for the date, unless that option is disabled.
 * 2 results:
 *  fonts are created. The font handles are stored in global variables
 *  string is positioned. Results are stored in the ClockDisp structure
 *    (ie: starting positions and extents)
 */

void NEAR PASCAL SizeFont(HWND hWnd, int newHeight, int newWidth)
{
  register HDC    hDC;
  SIZE       sizeTimeExt;
  SIZE       sizeDateExt;

  int        nzExts[ 15 ];
#ifdef JAPAN    // #1208:6/1/93:
  int        bFit;
  LOGFONT    wkFontStruct;
#endif
  int        nOldFit, nFit, i;
  int        nAMPMIndx = 0;
  int        iAMPMLen;
  int        DesiredWidth;
  int        DesiredHeight;
  int        InitialHeight;
  HCURSOR    hOldCur;
  HFONT h;

    if (ClockDisp.wFormat == IDM_DIGITAL)
    {
        hOldCur = SetCursor (hCurWait);

        hDC = GetDC(hWnd);
        if (hFont != NULL)
            DeleteObject (hFont);

        if (ClockDisp.bIconic)  /* Adjust for fat border */
        {
            newWidth -= 4;
            newHeight -= 4;
        }

        /* use up 7/8 of the x-extent of the window */
        DesiredWidth = (newWidth * 7) / 8;

        if (bDisplayDate)
            /* display the date with the time - time only occupied a third
             * of the screen height
             */
            DesiredHeight = 3 * newHeight / 8;
        else
            /* no date - time occupies two-thirds the screen height */
            DesiredHeight = 7 * newHeight / 8;

        if (ClockDisp.bIconic)  /* Readjust for fat border */
        {
            newWidth += 4;
            newHeight += 4;
        }

        /* create initial font real big, for more precision in calculations.
         * This will give us an extent for out string, we can then figure
         * out the correct font height to fit the string (using a ratio).
         */
        InitialHeight = 1000;

        FontStruct.lfWidth = 0;                 /* don't stretch fonts */
        FontStruct.lfHeight = -InitialHeight;

#ifdef JAPAN
        /* In Win 3.0 if the following were not done some unexpected font
         * maybe selected in special cases.  Especially in Japan with
         * vertical writing.
         */
        FontStruct.lfEscapement  = 0;
        FontStruct.lfOrientation = 0;
#endif

#if defined(JAPAN) || defined(KOREA)
        /* We can use only NATIVE_CHARSET */
        if (FontStruct.lfCharSet != NATIVE_CHARSET)
        {
            FontStruct.lfCharSet = NATIVE_CHARSET;
            lstrcpy (FontStruct.lfFaceName, TEXT("System"));
        }
#endif

        hFont = CreateFontIndirect(&FontStruct);
        if (hFont)
            h = SelectObject(hDC, hFont);
        else
            h = 0;

        GetTextExtentPoint (hDC, ClockDisp.szTimeFmt, ClockDisp.nTimeLen, &sizeTimeExt);
        if (bDisplayDate)
            GetTextExtentPoint (hDC, ClockDisp.szDate, ClockDisp.nDateLen, &sizeDateExt);

        if (h)
            SelectObject(hDC, h);

        /* compute appropriate font for time string:
         * establish a ratio current size to required size.
         * This may yield a font too tall to fit the window, so limit
         * the font height.
         */
        FontStruct.lfHeight = -MulDiv (InitialHeight, DesiredWidth,
                                       sizeTimeExt.cx);
        if (-FontStruct.lfHeight > DesiredHeight)
            FontStruct.lfHeight = -DesiredHeight;


        // pre-initialize nzExts in case this for loop doesn't execute
        // (in really small cy cases).
        for (i = 0; i < 15; nzExts[i] = 0, i++);
#ifdef JAPAN    // #1208:6/1/93:
        bFit = FALSE;
        wkFontStruct = FontStruct;
#endif

        for (nOldFit = 0, nFit = -1; FontStruct.lfHeight < 0;)
        {
            nOldFit = nFit;

            /* little loop to take care of round-off errors, which may
             * cause our initial "guess" to be slightly too large. So
             * check that the string fits (in most cases it will),
             * otherwise, re-create the font in a slightly smaller size.
             */
            if (hFont)
                DeleteObject (hFont);
            hFont = CreateFontIndirect(&FontStruct);

            if (hFont)
                h = SelectObject(hDC, hFont);
            else
                h = 0;

            GetTextExtentExPoint (hDC, ClockDisp.szTimeFmt, ClockDisp.nTimeLen,
                                  DesiredWidth, &nFit, nzExts, &sizeTimeExt);
            if (h)
                SelectObject(hDC, h);

            if (nFit == ClockDisp.nTimeLen) /* if string fits, exit loop */
#ifdef JAPAN    // #1208:6/1/93:
            {
                bFit = TRUE;
                break;
            }
#else
               break;
#endif

            FontStruct.lfHeight += 2;       /* remember height is negative! */
        }

#ifdef JAPAN    // #1208:6/1/93: Change display font fit iconic
        if (!bFit && ClockDisp.bIconic)
        {
            wkFontStruct.lfPitchAndFamily = FF_SWISS | VARIABLE_PITCH;
            lstrcpy (wkFontStruct.lfFaceName, TEXT(" "));
            for (nOldFit = 0, nFit = -1; wkFontStruct.lfHeight < 0;)
            {
                nOldFit = nFit;

                if (hFont)
                    DeleteObject (hFont);
                hFont = CreateFontIndirect(&wkFontStruct);

                if (hFont)
                    h = SelectObject(hDC, hFont);
                else
                    h = 0;

                GetTextExtentExPoint( hDC, ClockDisp.szTimeFmt,
                ClockDisp.nTimeLen, DesiredWidth, &nFit, nzExts, &sizeTimeExt );
                if (h)
                    SelectObject(hDC, h);

                if (nFit == ClockDisp.nTimeLen)
                    break;

                wkFontStruct.lfHeight += 2;
            }
        }
#endif


        /* compute placement and extents */
        iAMPMLen = ClockDisp.nMaxAMPMLen;
        if (!ClockDisp.bIconic && ClockDisp.wAMPMPosition && iAMPMLen)
        {
            ClockDisp.nSizeChar = nzExts[iAMPMLen] - nzExts[iAMPMLen-1];
            ClockDisp.nPosAMPM = (newWidth - sizeTimeExt.cx) / 2;
            ClockDisp.nSizeAMPM = nzExts[iAMPMLen-2];
            ClockDisp.nSizeSep = nzExts[iAMPMLen+2] - nzExts[iAMPMLen+1];
            ClockDisp.nPosHr = ClockDisp.nPosAMPM + nzExts[iAMPMLen-1];
            ClockDisp.nPosSep1 = ClockDisp.nPosAMPM + nzExts[iAMPMLen+1];
            ClockDisp.nPosMin = ClockDisp.nPosAMPM + nzExts[iAMPMLen+2];
            if (!ClockDisp.bNoSeconds)
            {
                ClockDisp.nPosSep2 = ClockDisp.nPosAMPM + nzExts[iAMPMLen+4];
                ClockDisp.nPosSec = ClockDisp.nPosAMPM + nzExts[iAMPMLen+5];
            }
        }
        else
        {
            ClockDisp.nSizeChar = nzExts[0];
            ClockDisp.nSizeSep = nzExts[2] - nzExts[1];
            ClockDisp.nPosHr = (newWidth - sizeTimeExt.cx) / 2;
            ClockDisp.nPosSep1 = ClockDisp.nPosHr + nzExts[ 1 ];
            ClockDisp.nPosMin = ClockDisp.nPosHr + nzExts[2];
            if (!ClockDisp.bIconic)
            {
                if (!ClockDisp.bNoSeconds)
                {
                    ClockDisp.nPosSep2 = ClockDisp.nPosHr + nzExts[4];
                    ClockDisp.nPosSec = ClockDisp.nPosHr + nzExts[5];
                    if (ClockDisp.nTimeLen > 8)
                        nAMPMIndx = 8;
                }
                else if (ClockDisp.nTimeLen > 5)
                    nAMPMIndx = 5;
                if (nAMPMIndx)
                {
                    ClockDisp.nPosAMPM = ClockDisp.nPosHr + nzExts[nAMPMIndx];
                    ClockDisp.nSizeAMPM = sizeTimeExt.cx - nzExts[nAMPMIndx];
                }
                else
                {
                    ClockDisp.nPosAMPM = 0;
                    ClockDisp.nSizeAMPM = 0;
                }
            }
        }

        ClockDisp.nSizeY  = sizeTimeExt.cy;

        /* compute size of shadow offset - if the font is too small, no
         * shadow (offset = 0)
         */

        ClockDisp.wShdwOff = (WORD) (((ClockDisp.nSizeChar + ClockDisp.nSizeY) < 90) ?
                                0 : 2 * GetSystemMetrics (SM_CXBORDER));

        /* allocate a bitmap for 2 digits */
        if (ClockDisp.hBitmap != NULL)
            DeleteObject (ClockDisp.hBitmap);

        ClockDisp.hBitmap = CreateDiscardableBitmap (hDC, 2*ClockDisp.nSizeChar
                                                     + 2*ClockDisp.wShdwOff, ClockDisp.nSizeY);

        /* prepare a font for the date */
        if (bDisplayDate)
        {
            DesiredHeight = -(FontStruct.lfHeight * 3) / 4;

            /* compute appropriate font for date - same algorithm as time */
            FontStruct.lfHeight = -MulDiv (InitialHeight, DesiredWidth,
                sizeDateExt.cx);
            if (-FontStruct.lfHeight > DesiredHeight)
                FontStruct.lfHeight = -DesiredHeight;

            for (; ;)
            {
                if (hFontDate != NULL)
                    DeleteObject (hFontDate);
                hFontDate = CreateFontIndirect (&FontStruct);

                if (hFontDate)
                    h = SelectObject (hDC, hFontDate);
                else
                    h = 0;
                GetTextExtentPoint (hDC, ClockDisp.szDate,
                    ClockDisp.nDateLen, &sizeDateExt);
                if (h)
                    SelectObject (hDC, h);
                if (sizeDateExt.cx < DesiredWidth)
                   break;
                FontStruct.lfHeight += 2;
            }

            /* compute date placement and extents */
            ClockDisp.nPosDateX = (newWidth - sizeDateExt.cx) / 2;
            ClockDisp.nSizeDateX = sizeDateExt.cx;
            ClockDisp.nSizeDateY = sizeDateExt.cy;

            ClockDisp.nPosY = (newHeight - (ClockDisp.nSizeY +
                               ClockDisp.nSizeDateY)) / 2;
            ClockDisp.nPosDateY = ClockDisp.nPosY + ClockDisp.nSizeY;
        }
        else
        {
            /* no date, so center the time */
            ClockDisp.nPosY = (newHeight - ClockDisp.nSizeY) / 2;
        }
        ReleaseDC (hWnd, hDC);

        SetCursor (hOldCur);
    }
}


/*
 *  DrawHand() - Draw the second hand using XOR mode.
 */

void NEAR PASCAL DrawHand (register HDC hDC,
                           int          pos,
                           HPEN         hPen,
                           int          scale,
                           int          patMode)
{
  TRIG *   lppt;
  int      radius;

    MoveTo (hDC, clockCenter.x, clockCenter.y);
    radius = MulDiv (clockRadius, scale, 100);
    lppt = lpcirTab + (pos % 60);
    SetROP2 (hDC, patMode);
    SelectObject (hDC, hPen);

    LineTo (hDC, clockCenter.x + MulDiv (lppt->x, radius, 8000),
            clockCenter.y + MulDiv (lppt->y, radius, 8000));
}


/*
 *  SetMenuBar() - places or removes the menu bar, etc.
 *
 *  Based on the flags in ClockDisp structure (ie: do we want a menu/title
 *  bar or not?), adds or removes the window title and menu bar:
 *    Gets current style, toggles the bits, and re-sets the style.
 *    Must then resize the window frame and show it.
 */

void NEAR PASCAL SetMenuBar (HWND hWnd)
{
    static DWORD  wID;
    DWORD         dwStyle;

    dwStyle = GetWindowLong (hWnd, GWL_STYLE);
    if (ClockDisp.bNoTitle)
    {
        /* remove caption & menu bar, etc. */
        dwStyle &= ~(WS_DLGFRAME | WS_SYSMENU |
                   WS_MINIMIZEBOX | WS_MAXIMIZEBOX);
        wID = SetWindowLong (hWnd, GWL_ID, 0);

    }
    else
    {
        /* put menu bar & caption back in */
        dwStyle = WS_TILEDWINDOW | dwStyle;
        SetWindowLong (hWnd, GWL_ID, wID);
        SetWindowRgn(hWnd, NULL, TRUE);
    }
    SetWindowLong (hWnd, GWL_STYLE, dwStyle);
    SetWindowPos (hWnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE |
                  SWP_NOZORDER | SWP_FRAMECHANGED);

    if (ClockDisp.wFormat == IDM_ANALOG && ClockDisp.bNoTitle)
    {
        HRGN hrgn;
        RECT rc;

        GetClientRect(hWnd,&rc);

        if(hrgn = CreateEllipticWndRgn(hWnd,&rc))
            SetWindowRgn(hWnd,hrgn,TRUE);
    }

    ShowWindow (hWnd, SW_SHOW);
}


/*
 *  FormatInit() -  Retrieve current locale information.
 */

void NEAR PASCAL FormatInit (VOID)
{
    LCID   lcid;
    TCHAR  szBuf[3];


    lcid = GetUserDefaultLCID ();

    /*
     *  Get time format:
     *      0 = 12 hour format
     *      1 = 24 hour format
     */
    if (!bUtc)
    {
        GetLocaleInfoW (lcid, LOCALE_ITIME, (LPWSTR) szBuf, 3);
        ClockDisp.wTimeFormat = (WORD)MyAtoi (szBuf);
    }
    else
    {
        /*
         *  GMT - use 24 hour clock format.
         */
        ClockDisp.wTimeFormat = 1;
    }

    /*
     *  Get time leading zero:
     *      0 = no leading zero
     *      1 = leading zero
     */
    GetLocaleInfoW (lcid, LOCALE_ITLZERO, (LPWSTR) szBuf, 3);
    ClockDisp.wTimeLZero = (WORD)MyAtoi (szBuf);

    /*
     *  Get time marker position:
     *      0 = suffix
     *      1 = prefix
     */
    GetLocaleInfoW (lcid, LOCALE_ITIMEMARKPOSN, (LPWSTR) szBuf, 3);
    ClockDisp.wAMPMPosition = (WORD)MyAtoi (szBuf);

    /*
     *  Get AM/PM designators.
     */
    if (!bUtc)
    {
        GetLocaleInfoW (lcid, LOCALE_S1159, (LPWSTR) ClockDisp.szAMPM[0], MAX_AMPM_LEN);
        GetLocaleInfoW (lcid, LOCALE_S2359, (LPWSTR) ClockDisp.szAMPM[1], MAX_AMPM_LEN);

        ClockDisp.nMaxAMPMLen = max( lstrlen(ClockDisp.szAMPM[0]),
                                     lstrlen(ClockDisp.szAMPM[1]) );
        if ((ClockDisp.wAMPMPosition) && (ClockDisp.nMaxAMPMLen))
        {
            /*
             *  AM/PM is a Prefix, so need to add one to the length
             *  for the space between the time marker and the time string.
             */
            (ClockDisp.nMaxAMPMLen)++;
        }
    }
    else
    {
        *(ClockDisp.szAMPM[0]) = *(ClockDisp.szAMPM[1]) = TEXT('\0');
        ClockDisp.nMaxAMPMLen = 0;
    }

    /*
     *  Get time separator string.
     */
    GetLocaleInfoW (lcid, LOCALE_STIME, (LPWSTR) ClockDisp.szTimeSep, MAX_TIME_SEP);

    /*
     *  Get short date format.
     */
    GetLocaleInfoW (lcid, LOCALE_SSHORTDATE, (LPWSTR) ClockDisp.szDateFmt, MAX_DATE_LEN);
}


/*
 *  ClockSize()
 */

void NEAR PASCAL ClockSize (register HWND hWnd,
                            int           newWidth,
                            int           newHeight,
                            WORD          SizeWord)
{
  BOOL    bChanged = FALSE;

    SetRect (&clockRect, 0, 0, newWidth, newHeight);
    CompClockDim ();

    if (SizeWord == SIZEICONIC)
    {
        ClockDisp.bIconic = TRUE;
        bChanged = TRUE;
    }
    else if (ClockDisp.bIconic)
    {
        ClockDisp.bIconic = FALSE;
        bChanged = TRUE;
    }

    if (bChanged)
    {
        ClockTimerInterval (hWnd);
        FormatTimeStr ();
        if (!ClockDisp.bNoDate)
        {
            FormatDateStr (&oDate, ClockDisp.bIconic);
            ResetWinTitle (hWnd);    /* date has changed */
        }
    }

    if (ClockDisp.wFormat == IDM_ANALOG && ClockDisp.bNoTitle)
    {
        HRGN hrgn;
        RECT rc;

        GetClientRect(hWnd,&rc);

        if(hrgn = CreateEllipticWndRgn(hWnd,&rc))
            SetWindowRgn(hWnd,hrgn,TRUE);
    }
}


/*
 *  CompClockDim() - Recompute the clock's dimensions.
 */

void NEAR PASCAL CompClockDim (void)

{
  int             i;
  register int    tWidth;
  register int    tHeight;

    tWidth = clockRect.right - clockRect.left;
    tHeight = clockRect.bottom - clockRect.top;

    if (tWidth > MulDiv (tHeight,aspectD,aspectN))
    {
        i = MulDiv (tHeight, aspectD, aspectN);
        clockRect.left += (tWidth - i) >> 1;
        clockRect.right = clockRect.left + i;
    }
    else
    {
        i = MulDiv (tWidth, aspectN, aspectD);
        clockRect.top += (tHeight - i) >> 1;
        clockRect.bottom = clockRect.top + i;
    }
}


/*
 *  DeleteTools()
 */

void NEAR PASCAL DeleteTools (void)
{
    DeleteObject (hbrForeground);
    DeleteObject (hbrColorWindow);
    DeleteObject (hbrBtnHighlight);
    DeleteObject (hbrBlobColor);
    DeleteObject (hpenForeground);
    DeleteObject (hpenShadow);
    DeleteObject (hpenBackground);
    DeleteObject (hpenBlobHlt);
    DeleteObject (hpenRed);
}


void ParseSavedWindow (LPTSTR szBuf, PRECT pRect)
{
  PINT  pint;
  int   count;

    short cxFrame  = (short) GetSystemMetrics (SM_CXFRAME);
    short cxSize   = (short) GetSystemMetrics (SM_CXSIZE);
    short cyFrame  = (short) GetSystemMetrics (SM_CYFRAME);
    short cySize   = (short) GetSystemMetrics (SM_CYSIZE);

    count = 0;
    pint = (PINT) pRect;

    while (*szBuf && count < 4)
    {
        *pint = (int) MyAtoi (szBuf);
        pint++;         // advance to next field

        while (*szBuf && *szBuf != TEXT(','))
            szBuf++;

        while (*szBuf && *szBuf == TEXT(','))
            szBuf++;

        count++;
    }
    if ((count < 4) ||
        (pRect->left >= pRect->right) || (pRect->top >= pRect->bottom))
    {
        HDC hDC = GetDC(NULL);
        int nPixMMX = GetDeviceCaps (hDC, HORZRES) / GetDeviceCaps (hDC, HORZSIZE);
        int nPixMMY = GetDeviceCaps (hDC, VERTRES) / GetDeviceCaps (hDC, VERTSIZE);
        ReleaseDC (NULL, hDC);

/* Bug #14014:  These sizes chosen for showing date in title bar as well as
 * instruction speed.    24 September 1991    Clark Cyr
 */
        pRect->left   = (LONG)CW_USEDEFAULT;
        pRect->top    = SW_SHOWNORMAL;
        pRect->right  = 64 * nPixMMX + 4 * cxFrame;
        pRect->bottom = 64 * nPixMMY + 4 * cyFrame + cySize;
    }
    else
    {
        short cxScreen = (short) GetSystemMetrics (SM_CXSCREEN);
        short cyScreen = (short) GetSystemMetrics (SM_CYSCREEN);

        pRect->right -= pRect->left;  /* right is now width   */
        pRect->bottom -= pRect->top;  /* bottom is now height */

        if (pRect->left > cxScreen - cxFrame - cxSize)
            pRect->left = cxScreen - cxFrame - cxSize;
        else if (pRect->left < cxFrame + cxSize - pRect->right)
            pRect->left = cxFrame + cxSize - pRect->right;

        if (pRect->top > cyScreen - cyFrame - cySize)
            pRect->top = cyScreen - cyFrame - cySize;
        else if (pRect->top < cxFrame + cxSize - pRect->bottom)
            pRect->top = cxFrame + cxSize - pRect->bottom;
    }

}


#define ADVANCE(sz)  while (*sz && *sz != TEXT(',')) sz++; \
                     while (*sz && *sz == TEXT(',')) sz++; \
                     if (!*sz) return;

void NEAR PASCAL ParseSavedFlags (LPTSTR szBuf, PCLOCKDISPSTRUCT pClck)
{
    pClck->wFormat = IDM_ANALOG;
    pClck->bIconic = FALSE;
    pClck->bNoSeconds = FALSE;
    pClck->bNoTitle = FALSE;
    pClck->bTopMost = FALSE;
    pClck->bNoDate = FALSE;

    if (!szBuf)
       return;

    pClck->wFormat = (WORD)(MyAtoi(szBuf) ? IDM_ANALOG : IDM_DIGITAL);
    ADVANCE (szBuf);
    pClck->bIconic = (MyAtoi(szBuf) ? TRUE : FALSE);
    ADVANCE (szBuf);
    pClck->bNoSeconds = (MyAtoi(szBuf) ? TRUE : FALSE);
    ADVANCE (szBuf);
    pClck->bNoTitle = (MyAtoi(szBuf) ? TRUE : FALSE);
    ADVANCE (szBuf);
    pClck->bTopMost = (MyAtoi(szBuf) ? TRUE : FALSE);
    ADVANCE (szBuf);
    pClck->bNoDate = (MyAtoi(szBuf) ? TRUE : FALSE);
}


VOID NEAR PASCAL PrepareSavedWindow (LPTSTR szBuf, PRECT pRect)
{
    wsprintf (szBuf, TEXT("%i,%i,%i,%i"), pRect->left, pRect->top,
              pRect->right, pRect->bottom);
}

TRIG CirTab[] = {       // circle sin, cos, table
    { 0,     -7999  },
    { 836,   -7956  },
    { 1663,  -7825  },
    { 2472,  -7608  },
    { 3253,  -7308  },
    { 3999,  -6928  },
    { 4702,  -6472  },
    { 5353,  -5945  },
    { 5945,  -5353  },
    { 6472,  -4702  },
    { 6928,  -4000  },
    { 7308,  -3253  },
    { 7608,  -2472  },
    { 7825,  -1663  },
    { 7956,  -836   },

    { 8000,  0      },
    { 7956,  836    },
    { 7825,  1663   },
    { 7608,  2472   },
    { 7308,  3253   },
    { 6928,  4000   },
    { 6472,  4702   },
    { 5945,  5353   },
    { 5353,  5945   },
    { 4702,  6472   },
    { 3999,  6928   },
    { 3253,  7308   },
    { 2472,  7608   },
    { 1663,  7825   },
    { 836,   7956   },

    { 0,     7999   },
    { -836,  7956   },
    { -1663, 7825   },
    { -2472, 7608   },
    { -3253, 7308   },
    { -4000, 6928   },
    { -4702, 6472   },
    { -5353, 5945   },
    { -5945, 5353   },
    { -6472, 4702   },
    { -6928, 3999   },
    { -7308, 3253   },
    { -7608, 2472   },
    { -7825, 1663   },
    { -7956, 836    },

    { -7999, -0     },
    { -7956, -836   },
    { -7825, -1663  },
    { -7608, -2472  },
    { -7308, -3253  },
    { -6928, -4000  },
    { -6472, -4702  },
    { -5945, -5353  },
    { -5353, -5945  },
    { -4702, -6472  },
    { -3999, -6928  },
    { -3253, -7308  },
    { -2472, -7608  },
    { -1663, -7825  },
    { -836 , -7956  }
};

VOID NEAR PASCAL PrepareSavedFlags (LPTSTR szBuf, PCLOCKDISPSTRUCT pClck)
{
    wsprintf (szBuf, TEXT("%i,%i,%i,%i,%i,%i"),
              (pClck->wFormat == IDM_ANALOG ? 1 : 0),
              (pClck->bIconic ? 1 : 0), (pClck->bNoSeconds ? 1 : 0),
              (pClck->bNoTitle ? 1 : 0), (pClck->bTopMost ? 1 : 0),
              (pClck->bNoDate ? 1 : 0));
}

/*
 *  SaveClockOptions()
 */

VOID NEAR PASCAL SaveClockOptions (HWND hWnd)
{
    TCHAR    szInt[80];
    INT      i = (INT) IsZoomed (hWnd);

/* Bug 15058: Don't save the rectangle if we're maximized, assume it
 * has already been saved for restoration when maximization took place.
 *       18 October 1991           Clark Cyr
 */
    if (!ClockDisp.bIconic && !i)
        GetWindowRect (hWnd, &rCoordRect);

    wsprintf (szInt, TEXT("%i"), i);
    WritePrivateProfileString(szSection, szMaximized, szInt, szIniFile);

    /* write current clock options */
    PrepareSavedFlags (szInt, &ClockDisp);
    WritePrivateProfileString (szSection, szOptions, szInt, szIniFile);

    /* write window position and size */
    PrepareSavedWindow (szInt, &rCoordRect);
    WritePrivateProfileString (szSection, szPosition, szInt, szIniFile);

#ifdef JAPAN
    WritePrivateProfileString(
            szSection, szFontFileKey, FontStruct.lfFaceName, szIniFile );

    wsprintf (szInt, TEXT("%i"), (INT)FontStruct.lfCharSet);
    WritePrivateProfileString(szSection, szCharSet, szInt, szIniFile);
#endif
}


#if defined(JAPAN) || defined(KOREA)
/*
 * ExceptVerticalFont()
 */

UINT FAR PASCAL  ExceptVerticalFont(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LOGFONT lf;
    TCHAR szFaceName[LF_FACESIZE];
    UINT nId, count;

    switch (message)
    {
      case WM_INITDIALOG:
        count = SendDlgItemMessage(hwnd, cmb1, CB_GETCOUNT, 0, 0L);
        /* except vertical font */
        for (nId = 0; nId < count; nId++)
        {
            SendDlgItemMessage(hwnd, cmb1, CB_GETLBTEXT,
                               nId, (LONG) szFaceName);
            if (szFaceName[0] == TEXT('@'))
            {
                SendDlgItemMessage(hwnd, cmb1, CB_DELETESTRING, nId, 0L);
                nId--;
                count--;
            }
        }
        /* set selection current selected facename */
        SendMessage(hwnd, WM_CHOOSEFONT_GETLOGFONT, 0, (LONG) (LPTSTR) &lf);
        nId = SendDlgItemMessage(hwnd, cmb1, CB_FINDSTRING,
                                 0, (LONG) lf.lfFaceName);
        SendDlgItemMessage(hwnd, cmb1, CB_SETCURSEL, nId, 0L);

                // KKBUGFIX #1364: 12/10/92: Set focus on face name
        return(TRUE);

      default:
        return(FALSE);
    }
}
#endif


HRGN CreateEllipticWndRgn(HWND hWnd, LPRECT lprc)
{
    int  cSide;
    int  xOffset;
    int  yOffset;
    HRGN hRgn = NULL;


    if(lprc)
    {
        cSide = min(lprc->right, lprc->bottom);

        xOffset = GetSystemMetrics(SM_CXFRAME) + ((lprc->right  - cSide) >> 1);
        yOffset = GetSystemMetrics(SM_CYFRAME) + ((lprc->bottom - cSide) >> 1);

        hRgn = CreateEllipticRgn(xOffset, yOffset, xOffset+cSide, yOffset+cSide);
    }

    return(hRgn);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\common\datein.c ===
#include "windows.h"
#include <port1632.h>
#include "date.h"

extern CHAR    chSepDate;
extern CHAR    chSepTime;
extern CHAR    sz1159[];
extern CHAR    sz2359[];
extern INT     iDate;
extern INT     iYearOffset;
extern BOOL    f24Time;
extern BOOL    fLZero;
extern HANDLE  hinstTimeDate;

CHAR * APIENTRY Int2Ascii();
CHAR * FAR APIENTRY Ascii2Int();
CHAR * APIENTRY SkipDateSep();
CHAR * APIENTRY GetMonthString();
CHAR * APIENTRY GetWeekString();

INT  FAR APIENTRY ParseTimeString(pdt, pch)
DOSTIME *pdt;
register CHAR *pch;
{
    INT h, m;
    CHAR *pchT;
    CHAR ch;
    BOOL fPM;

    if ((pch = Ascii2Int(pch, &h)) == NULL)
        return(PD_ERRFORMAT);
    if (*pch++ != chSepTime)
        return(PD_ERRFORMAT);
    if ((pch = Ascii2Int(pch, &m)) == NULL)
        return(PD_ERRFORMAT);

    /* Now look for match against AM or PM string */
    fPM = FALSE;
    if (*pch != 0) {
        /* Upper case the string in PLACE */
        AnsiUpper((LPSTR)pch);
        ch = *pch;
        if (ch == sz1159[0]) {
            pchT = sz1159;
        } else if (ch == sz2359[0]) {
            fPM = TRUE;
            pchT = sz2359;
        } else {
            return(PD_ERRFORMAT);
        }
        /* The following is just a case-insensitive, kanji-sensitive
           string equality check */
        while (*pchT != 0) {
            if (*pch == 0 || *pch++ != *pchT++)
                return(PD_ERRFORMAT);
        }
    }

    if (!f24Time) {
        if (h > 12)
            return PD_ERRSUBRANGE;

        if (!fPM) {
            /* Convert 12:xx am to 0:xx */
            if (h == 12)
                h = 0;
        } else {
            if (h == 0)
                return(PD_ERRSUBRANGE);
            /* convert 0..11 to 12..23 */
            if (h < 12)
                h += 12;
        }
    }
    if (h >= 24 || m >= 60)
        return(PD_ERRSUBRANGE);
    pdt->hour = (BYTE)h;
    pdt->minutes = (BYTE)m;
    pdt->seconds = 0;
    pdt->hundredths = 0;
    return(0);
}

BOOL FAR APIENTRY ParseDateString(pdd, pch)
DOSDATE *pdd;
register CHAR *pch;
{
    INT m, d, y;
    register INT t;
    INT cDays;

    if ((pch = Ascii2Int(pch, &m)) == NULL)
        return(PD_ERRFORMAT);
    if ((pch = SkipDateSep(pch, chSepDate)) == NULL)
        return(PD_ERRFORMAT);
    if ((pch = Ascii2Int(pch, &d)) == NULL)
        return(PD_ERRFORMAT);
    if ((pch = SkipDateSep(pch, chSepDate)) == NULL)
        return(PD_ERRFORMAT);
    if ((pch = Ascii2Int(pch, &y)) == NULL)
        return(PD_ERRFORMAT);

    if (*pch != 0)
        return(PD_ERRFORMAT);

    switch (iDate) {
    case 1:                 /* mdy->dmy */
        t = m; m = d; d = t;
        break;
    case 2:                 /* mdy->ymd */
        t = y; y = m; m = d; d = t;
        break;
    }
    /* if y < 100, assume he's specifying the last two digits of 19xx */
    y += iYearOffset;

    if (y < 100)
        y += 1900;

    pdd->month = (BYTE)m;
    pdd->year  = (WORD)y;
    pdd->day   = (BYTE)d;

    return(ValidateDosDate(pdd));   /* validate the date */
}

CHAR * APIENTRY SkipDateSep(pch, ch)
CHAR *pch;
CHAR ch;
{
    if (*pch == ch || *pch == '-' || *pch == '/')
        return(++pch);

    return(NULL);
}

CHAR * FAR APIENTRY Ascii2Int(pch, pw)
register CHAR *pch;
DWORD *pw;     //- Changed from WORD to DWORD for 32 bit ints. 7/11/91 t-davema
{
    register INT ch;
    DWORD n;
    CHAR *pchStart;

    /* skip leading spaces */
    while (*pch == ' ')
        pch++;

    pchStart = pch;
    n = 0;
    /* OLD: while (n < 3000 && !IsTwoByteCharPrefix(ch = *pch) && *pch >= '0' && ch <= '9') { */
    while (n < 3000 && /*!IsTwoByteCharPrefix(ch = *pch) &&*/ (ch = *pch) >= '0' && ch <= '9') {
        n = n * 10 + ch - '0';
        pch++;
    }
    if (pch == pchStart)        /* return NULL if nothing parsed */
	return (NULL);

    /* skip trailing spaces */
    while (*pch == ' ')
        pch++;

    *pw = n;

    return(pch);
}

INT FAR APIENTRY ValidateDosDate(pdd)
PDOSDATE pdd;
{
    register WORD d;
    register WORD y;
    static INT cDaysAccum[12] = { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };
    static BYTE rgbDaysMonth[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

    /* Make sure this is a valid date:
       - The year must be in the range 1980 through 2099 inclusive.
       - The month must be in the range 1 through 12 inclusive.
       - The day must be in the range 1 through the number of days
         of the specified month (which may need adjustment for leap year).
    */
    /* months are from 1..12 */
    if (pdd->month == 0 || pdd->month > 12)
        return(PD_ERRSUBRANGE);

    y = pdd->year - 1980;
    if (y > 119)
	return(PD_ERRRANGE);

    d = rgbDaysMonth[pdd->month - 1];
    if ((y & (4-1)) == 0 && pdd->month == 2)
        d++;

    if ((WORD)(pdd->day) > (WORD)d || (pdd->day == 0))
        return(PD_ERRSUBRANGE);

    /* We have a legal date.  Now calculate day of week and store in pdd->dayofweek */

    /* calc no. days in previous years plus total up to beginning of month */
    d = y * 365 + cDaysAccum[pdd->month - 1];

    /* Add in the days for the preceding leap years. */
    if (y != 0)
        d += 1 + (y - 1) / 4;

    /* if this is a leap year and we're past feb, add in extra day. */
    if ((y & (4-1)) == 0 && pdd->month > 2)
        d++;

    /* add 2 since jan 1 1980 was a tuesday */
    pdd->dayofweek = ((d + pdd->day - 1 + 2) % 7);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\common\date.h ===
/* Typedefs and constants for use with date.c */

typedef struct {
    BYTE dayofweek;
    BYTE day;
    BYTE month;
    WORD year;
} DOSDATE;
typedef DOSDATE *PDOSDATE;

#define GDS_SHORT       1
#define GDS_LONG        2
#define GDS_DAYOFWEEK   4
#define GDS_NODAY       8

typedef struct {
    BYTE hundredths;
    BYTE seconds;
    BYTE minutes;
    BYTE hour;
} DOSTIME;
typedef DOSTIME *PDOSTIME;

#define GTS_DEFAULT      0
#define GTS_SECONDS      1
#define GTS_HUNDREDTHS   2
#define GTS_LEADINGZEROS 4
#define GTS_LEADINGSPACE 8
#define GTS_12HOUR       16
#define GTS_24HOUR       32

#define IDS_DATESTRINGS 32736
#define IDS_MONTHS      IDS_DATESTRINGS
#define IDS_DAYSOFWEEK  IDS_MONTHS+12
#define IDS_DAYABBREVS  IDS_DAYSOFWEEK+7
#define IDS_SEPSTRINGS  IDS_DAYABBREVS+7

#define PD_ERRFORMAT    -1
#define PD_ERRSUBRANGE  -2
#define PD_ERRRANGE     -3


BOOL FAR APIENTRY InitTimeDate(HANDLE, UINT);
BOOL FAR APIENTRY InitLongTimeDate(UINT);
VOID FAR APIENTRY GetDosTime(PDOSTIME);
VOID FAR APIENTRY GetDosDate(PDOSDATE);
BOOL FAR APIENTRY ValidateDosDate(PDOSDATE);
INT FAR APIENTRY GetTimeString(PDOSTIME, CHAR *, WORD);
INT FAR APIENTRY GetDateString(PDOSDATE, CHAR *, WORD);
INT FAR APIENTRY GetLongDateString(PDOSDATE, CHAR *, WORD);
INT FAR APIENTRY ParseTimeString(PDOSTIME, CHAR *);
INT FAR APIENTRY ParseDateString(PDOSDATE, CHAR *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\common\dateout.c ===
/* Time and date stuff                                              */
/* NOTE: Date & time input routines work only if SS == DS */

#include "windows.h"
#include <port1632.h>
#include "date.h"

CHAR    chSepDate = '/';        /* Separator character for date string */
CHAR    chSepTime = ':';        /* Separator character for time string */
CHAR    sz1159[9] = "AM";       /* Time string suffix for morning hours */
CHAR    sz2359[9] = "PM";       /* Time string suffix for afternoon */
INT     iYearOffset = 0;        /* Japanese year offset */
INT     iDate = 0;              /* short date format code */
BOOL    f24Time = FALSE;        /* True if military time, else False */
BOOL    fLZero = FALSE;         /* True iff date values get leading zeros */
HANDLE  hinstTimeDate;
INT     cchTimeMax;             /* Size of time string */
INT     cchLongDateMax;

CHAR * FAR APIENTRY Int2Ascii();
CHAR * APIENTRY Ascii2Int();
CHAR * APIENTRY SkipSep();

INT FAR APIENTRY GetTimeString(PDOSTIME pdt, CHAR *pch, WORD format)
{
    CHAR *pchSave = pch;
    CHAR *szAMPM;
    INT h;

    szAMPM = NULL;
    h = pdt->hour;
    if (!f24Time) {       /* want 12 hour clock */
        if (h >= 12) {     /* PM */
            h -= 12;
            szAMPM = sz2359;
        } else {
            szAMPM = sz1159;
        }
        if (h == 0)
            h = 12;
    }
    pch = Int2Ascii(h, pch, fLZero || (format & GTS_LEADINGZEROS));
    *pch++ = chSepTime;
    pch = Int2Ascii(pdt->minutes, pch, TRUE);
#ifdef DISABLE
    if (format & (GTS_SECONDS | GTS_HUNDREDTHS)) {
        *pch++ = chSepTime;
        pch = Int2Ascii(pdt->seconds, pch, TRUE);
    }
    if (format & GTS_HUNDREDTHS) {
        *pch++ = chSepTime;
        pch = Int2Ascii(pdt->hundredths, pch, TRUE);
    }
#endif
    if (szAMPM) {
        *pch++ = ' ';
    while (*szAMPM != 0)
            *pch++ = *szAMPM++;
    }
    if ((format & GTS_LEADINGSPACE) && *pchSave == '0')
        *pchSave = ' ';

    *pch = 0;
    return(int)(pch - pchSave);
}

INT FAR APIENTRY GetDateString(PDOSDATE pdd, CHAR *pch, WORD format)
{
    CHAR *pchSave = pch;
    CHAR *szMonth;
    INT i1, i2, i3;
    BOOL fLZeroSave;
    LANGID PrimaryLangID = PRIMARYLANGID(GetSystemDefaultLangID());

    if ((PrimaryLangID == LANG_JAPANESE) || (PrimaryLangID == LANG_KOREAN))
    {
        pdd->year = pdd->year - iYearOffset;
        if (format != GDS_LONG)
            pdd->year %= 100;
    }
    else
    {
        pdd->year = (pdd->year - iYearOffset) % 100;
    }
    i1 = pdd->month;            /* assume mdy */
    i2 = pdd->day;
    i3 = pdd->year;
    if (iDate != 0) {
        i1 = pdd->day;          /* dmy or ymd */
        i2 = pdd->month;
        if (iDate == 2) {  /* ymd */
            i1 = pdd->year;
            i3 = pdd->day;
        }
    }

    if ((iDate == 2) && (format == GDS_LONG) &&
        ((PrimaryLangID == LANG_JAPANESE) || (PrimaryLangID == LANG_KOREAN)))
    {
        pch = Int2Ascii(i1/100, pch, fLZero);
        pch = Int2Ascii(i1%100, pch, TRUE);
    }
    else
    {
        pch = Int2Ascii(i1, pch, fLZero);
    }
    *pch++ = chSepDate;
    pch = Int2Ascii(i2, pch, fLZero);
    *pch++ = chSepDate;

    if ((iDate != 2) && (format == GDS_LONG) &&
        ((PrimaryLangID == LANG_JAPANESE) || (PrimaryLangID == LANG_KOREAN)))
    {
        pch = Int2Ascii(i3/100, pch, fLZero);
        pch = Int2Ascii(i3%100, pch, TRUE);
    }
    else
    {
        pch = Int2Ascii(i3, pch, fLZero);
    }
    *pch = 0;

    return(int)(pch - pchSave);
}

CHAR * FAR APIENTRY Int2Ascii(val, pch, fLeadingZeros)
register INT val;
register CHAR *pch;
BOOL fLeadingZeros;
{
    INT tens;

    if ((tens = val / 10) != 0 || fLeadingZeros) {
        *pch++ = tens + '0';
    }
    *pch++ = (val % 10) + '0';
    return(pch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\common\dateoutl.c ===
#include "windows.h"
#include <port1632.h>
#include "date.h"

extern CHAR    chSepDate;
extern CHAR    chSepTime;
extern CHAR    sz1159[];
extern CHAR    sz2359[];
extern INT     iDate;
extern INT     iYearOffset;
extern BOOL    f24Time;
extern BOOL    fLZero;
extern HANDLE  hinstTimeDate;

CHAR * FAR APIENTRY Int2Ascii();
CHAR * APIENTRY LoadDateString();

#define LDS_DAYOFWEEK   0
#define LDS_MONTH       1
#define LDS_DAY         2
#define LDS_YEAR        3

BYTE mpIFmt[3][4] = {
    { LDS_DAYOFWEEK, LDS_MONTH, LDS_DAY, LDS_YEAR },
    { LDS_DAYOFWEEK, LDS_DAY, LDS_MONTH, LDS_YEAR },
    { LDS_YEAR, LDS_MONTH, LDS_DAY, LDS_DAYOFWEEK }
};

INT FAR APIENTRY GetLongDateString(PDOSDATE pdd, CHAR *pch, WORD format)
{
    register INT i;
    CHAR *pchSave = pch;
    CHAR *szMonth;
    INT i1, i2, i3;
    INT y;
    LANGID PrimaryLangID = PRIMARYLANGID(GetSystemDefaultLangID());

    for (i = 1; i <= 4; i++) {
        switch (mpIFmt[iDate][i - 1]) {
        case LDS_DAYOFWEEK:
            if ((format & GDS_DAYOFWEEK)) {
                if (pdd->dayofweek == 0xff && ValidateDosDate(pdd) < 0)
                    return(0);
                pch = LoadDateString(pch, IDS_DAYSOFWEEK + pdd->dayofweek);
                /* If day of week is at start of string, stick in comma */
                if (i == 1)
                    *pch++ = ',';
                if (i != 4)
                    *pch++ = ' ';
            }
            break;
        case LDS_MONTH:
            pch = LoadDateString(pch, pdd->month - 1 + IDS_MONTHS);
            *pch++ = ' ';
            break;
        case LDS_DAY:
            if (!(format & GDS_NODAY)) {
                pch = Int2Ascii(pdd->day, pch, fLZero);
                //
                //  If it's Japanese or Korean, get native name for year
                //  from resource.
                //
                if ((PrimaryLangID == LANG_JAPANESE) ||
                    (PrimaryLangID == LANG_KOREAN))
                {
                    pch = LoadDateString(pch, IDS_SEPSTRINGS + 6);
                }
                if (iDate == 0) {
                    *pch++ = ',';
                }
                *pch++ = ' ';
            }
            break;
        case LDS_YEAR:
            y = pdd->year - iYearOffset;
            pch = Int2Ascii(y / 100, pch, TRUE);
            pch = Int2Ascii(y % 100, pch, TRUE);
            //
            //  If it's Japanese or Korean, get native name for month
            //  from resource.
            //
            if ((PrimaryLangID == LANG_JAPANESE) ||
                (PrimaryLangID == LANG_KOREAN))
            {
                pch = LoadDateString(pch, IDS_SEPSTRINGS + 5);
            }
            if (i != 4)
                *pch++ = ' ';
            break;
        }
    }
    *pch = 0;
    return(int)(pch - pchSave);
}

CHAR * APIENTRY LoadDateString(pch, id)
register CHAR *pch;
INT id;
{
    return(pch + LoadString(hinstTimeDate, id, (LPSTR)pch, 30));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\common\datelini.c ===
#include "windows.h"
#include <port1632.h>
#include "date.h"

extern CHAR    chSepDate;
extern CHAR    chSepTime;
extern CHAR    sz1159[];
extern CHAR    sz2359[];
extern INT     iDate;
extern INT     iYearOffset;
extern BOOL    f24Time;
extern BOOL    fLZero;
extern HANDLE  hinstTimeDate;
extern INT     cchTimeMax;
extern INT     cchLongDateMax;
extern CHAR    *rgszDayAbbrevs[];

void
LockStrings(id)
WORD id;
{
    HANDLE h;

    if ((h = FindResource(hinstTimeDate, MAKEINTRESOURCE(IDS_DATESTRINGS >> 4), RT_STRING))
            && (h = LoadResource(hinstTimeDate, h))) {
        GlobalLock(h);
    }
}

void
CalcCchDateMax(idFirst, idLast)
WORD idFirst;
WORD idLast;
{
    CHAR rgch[30];
    register INT cch, cchT;

    cch = 0;
    while (idFirst <= idLast) {
        cchT = LoadString(hinstTimeDate, idFirst++, rgch, 30);
        if (cchT > cch)
            cch = cchT;
    }
    cchLongDateMax += cch;
}

BOOL FAR APIENTRY InitLongTimeDate(UINT format)
{
    INT cchT;
    INT i;
    CHAR rgch[30];
    LANGID PrimaryLangID = PRIMARYLANGID(GetSystemDefaultLangID());

    /* Get date/time strings into memory & lock down for all time */
    LockStrings(((WORD)IDS_DATESTRINGS >> 4) + 0);
    LockStrings(((WORD)IDS_DATESTRINGS >> 4) + 1);

    /* Now calculate worst case size of long date string */
    /* this is sum of separator strings, plus max of months, plus max of
       weekdays, plus 2 digits, plus 4 digits, plus zero terminator */
    cchLongDateMax = 2 + 4;
    CalcCchDateMax(IDS_MONTHS,     IDS_MONTHS+11);
#ifdef LEPPARD
    for (i = IDS_SEPSTRINGS; i <= IDS_SEPSTRINGS+4; i++) {
        cchLongDateMax += LoadString(hinstTimeDate, i, rgch, 30);
    }
#else
    cchLongDateMax += 5;    /* room for spaces and commas */
#endif
    CalcCchDateMax(IDS_DAYSOFWEEK, IDS_DAYSOFWEEK+6);

    //
    //  See if it's Japanese or Korean.
    //
    if ((PrimaryLangID == LANG_JAPANESE) || (PrimaryLangID == LANG_KOREAN))
    {
        cchLongDateMax += LoadString(hinstTimeDate, IDS_SEPSTRINGS+5, rgch, 30);
        cchLongDateMax += LoadString(hinstTimeDate, IDS_SEPSTRINGS+6, rgch, 30);
    }

    /* Calc max size of time string */
    cchT = 0;
    if (!f24Time) {
        cchT = lstrlen(sz2359);
        cchTimeMax = lstrlen(sz1159);
        if (cchT > cchTimeMax)
            cchTimeMax = cchT;
    }
    cchTimeMax += 6;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\common\dateinit.c ===
#include "windows.h"
#include <port1632.h>
#include "date.h"

extern CHAR    chSepDate;
extern CHAR    chSepTime;
extern CHAR    sz1159[];
extern CHAR    sz2359[];
extern INT     iDate;
extern INT     iYearOffset;
extern BOOL    f24Time;
extern BOOL    fLZero;
extern HANDLE  hinstTimeDate;
extern INT     cchTimeMax;
extern INT     cchLongDateMax;
extern CHAR    *rgszDayAbbrevs[];

BOOL FAR APIENTRY InitTimeDate (HANDLE hInstance, UINT format)
{
    static CHAR szIntl[] = "intl";
    CHAR rgch[2];

    hinstTimeDate = hInstance;

    iDate = GetProfileInt((LPSTR)szIntl, (LPSTR)"iDate", 0);

    if (format & GTS_24HOUR)
        f24Time = TRUE;
    else if (format & GTS_12HOUR)
        f24Time = FALSE;
    else
        f24Time = GetProfileInt((LPSTR)szIntl, (LPSTR)"iTime", 0);

    if (format & GTS_LEADINGZEROS)
        fLZero = TRUE;
    else
        fLZero  = GetProfileInt((LPSTR)szIntl, (LPSTR)"iLzero", 0);

    iYearOffset  = GetProfileInt((LPSTR)szIntl, (LPSTR)"iYearOffset", 0);

    GetProfileString((LPSTR)szIntl, (LPSTR)"s1159", (LPSTR)sz1159,
                           (LPSTR)sz1159, 9);

    GetProfileString((LPSTR)szIntl, (LPSTR)"s2359", (LPSTR)sz2359,
                           (LPSTR)sz2359, 9);

    GetProfileString((LPSTR)szIntl, (LPSTR)"sDate", (LPSTR)"/", (LPSTR)rgch, 2);
    chSepDate = rgch[0];

    GetProfileString((LPSTR)szIntl, (LPSTR)"sTime", (LPSTR)":", (LPSTR)rgch, 2);
    chSepTime = rgch[0];
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\common\ll.c ===
/*****************************************************************************
*                                                                            *
*  LL.C                                                                      *
*                                                                            *
*  Copyright (C) Microsoft Corporation 1989.                                 *
*  All Rights reserved.                                                      *
*                                                                            *
******************************************************************************
*                                                                            *
*  Program Description: Linked list module                                   *
*                                                                            *
******************************************************************************
*                                                                            *
*  Revision History:  Created 4/15/89 by Robert Bunney                       *
*                                                                            *
*                                                                            *
******************************************************************************
*                                                                            *
*  Known Bugs: None                                                          *
*                                                                            *
*                                                                            *
*                                                                            *
*****************************************************************************/

/*****************************************************************************
*                                                                            *
*                               Defines                                      *
*                                                                            *
*****************************************************************************/

#define NEAR near
#define PRIVATE static
#define publicsw
#define H_ASSERT
#define H_MEM

#include <windows.h>
#include <port1632.h>

#define ALLOC(x)    GlobalAlloc(GMEM_MOVEABLE, (LONG)x)
#define FREE(x)     GlobalFree(x)
#define LOCK(x)     GlobalLock(x)
#define UNLOCK(x)   GlobalUnlock(x)
#define ASSERT(x)
#define MEMMOVE(dest, src, cb) QvCopy(dest, src, cb)


#include "ll.h"

/*****************************************************************************
*                                                                            *
*                               Typedefs                                     *
*                                                                            *
*****************************************************************************/

typedef struct
  {
   HANDLE hNext;
   HANDLE hData;
  } LLN;                                 /* L inked L ist N ode              */
typedef LLN FAR *PLLN;


/*****************************************************************************
*                                                                            *
*                               Prototypes                                   *
*                                                                            *
*****************************************************************************/

PRIVATE HLLN NEAR APIENTRY HLLNAlloc(VOID);
VOID FAR * FAR cdecl QvCopy(VOID FAR *, VOID FAR *, LONG);

/*******************
**
** Name:       LLCreate
**
** Purpose:    Creates a link list
**
** Arguments:  None.
**
** Returns:    Link list.  nilLL is returned if an error occurred.
**
*******************/

LL FAR APIENTRY LLCreate(VOID)
  {
  return HLLNAlloc();
  }

/*******************
**
** Name:       InsertLL
**
** Purpose:    Inserts a new node at the head of the linked list
**
** Arguments:  ll     - link list
**             vpData - pointer to data to be associated with
**             c      - count of the bytes pointed to by vpData
**
** Returns:    TRUE iff insertion is successful.
**
*******************/

BOOL FAR APIENTRY InsertLL(ll, qvData, c)
LL ll;
VOID FAR *qvData;
LONG c;
  {
  HLLN   hlln;                          /* Handle for the new node          */
  PLLN   pllnCur;                       /* Head node for linked list        */
  PLLN   pllnNew;                       /* New node                         */
  HANDLE h;                             /* Handle to the object data        */
  VOID FAR *qv;                         /* Pointer to data block            */

  ASSERT(c > 0L);
                                        /* Check and lock to get header node*/
  if ((ll == nilHAND) || ((pllnCur = (PLLN)LOCK((HANDLE)ll)) == NULL))
    return FALSE;
  if ((h = (HANDLE)ALLOC(c)) == nilHAND)       /* Get handle for data              */
    {UNLOCK((HANDLE)ll); return FALSE;}
  if ((qv = LOCK(h)) == NULL)           /* Get pointer to data              */
    {UNLOCK((HANDLE)ll); FREE(h); return FALSE;}
  if ((hlln = HLLNAlloc()) == NULL)     /* Get handle to new node           */
    {UNLOCK((HANDLE)ll); FREE(h); return FALSE;}
  if ((pllnNew = (PLLN)LOCK((HANDLE)hlln)) == NULL)/* Get pointer to new node          */
    {UNLOCK((HANDLE)ll); UNLOCK(h); FREE(h); UNLOCK(hlln); FREE(hlln); return FALSE;}

  MEMMOVE(qv, qvData, c);               /* Copy data                        */
  UNLOCK(h);
  pllnNew->hData = h;                   /* Insert at head of list           */
  pllnNew->hNext = pllnCur->hNext;
  pllnCur->hNext = hlln;
  UNLOCK((HANDLE)ll);
  UNLOCK(hlln);
  return TRUE;
  }


/*******************
**
** Name:       WalkLL
**
** Purpose:    Mechanism for walking the nodes in the linked list
**
** Arguments:  ll   - linked list
**             hlln - handle to a linked list node
**
** Returns:    a handle to a link list node or NIL_HLLN if at the
**             end of the list (or an error).
**
** Notes:      To get the first node, pass NIL_HLLN as the hlln - further
**             calls should use the HLLN returned by this function.
**
*******************/

HLLN FAR APIENTRY WalkLL(ll, hlln)
LL ll;
HLLN hlln;
  {
  PLLN plln;                            /* node in linked list              */
  HLLN hllnT;

  if (hlln == nilHLLN)                  /* First time called                */
    hlln = ll;

  if ((hlln == nilHAND) || ((plln = (PLLN)LOCK((HANDLE)hlln)) == NULL))
    return nilHAND;
  hllnT = plln->hNext;
  UNLOCK(hlln);
  return hllnT;
  }


/*******************
**
** Name:       QVLockHLLN
**
** Purpose:    Locks a LL node returning a pointer to the data
**
** Arguments:  hlln - handle to a linked list node
**
** Returns:    pointer to data or NULL if an error occurred
**
*******************/

VOID FAR * FAR QVLockHLLN(hlln)
HLLN hlln;
  {
  PLLN plln;
  VOID FAR * qv;
                                        /* Lock node                        */
  if ((hlln == nilHAND) || ((plln = (PLLN)LOCK((HANDLE)hlln)) == NULL))
    return NULL;

  qv = LOCK(plln->hData);               /* Get pointer to data              */
  UNLOCK(hlln);
  return qv;
  }


/*******************
**
** Name:       QVUnlockHLLN
**
** Purpose:    Unlocks a LL node
**
** Arguments:  hlln - handle to a link list node
**
** Returns:    TRUE iff the handle is successfully locked.
**
*******************/

VOID FAR UnlockHLLN(hlln)
  HLLN hlln;
  {
  PLLN plln;                            /* Pointer to the node              */

  if ((hlln == nilHAND) || ((plln = (PLLN)LOCK((HANDLE)hlln)) == NULL))
    return;

  UNLOCK(plln->hData);
  UNLOCK(hlln);
  return;
  }


/*******************
**
** Name:       HLLNAlloc
**
** Purpose:    Allocates a link list node
**
** Arguments:  Nothing.
**
** Returns:    A new new node with hNext and hData set to nilHAND
**
**
** Method:
**
*******************/

PRIVATE HLLN NEAR APIENTRY HLLNAlloc(VOID)
  {
  HANDLE h;
  PLLN plln;
  if ((h = ALLOC(sizeof(LLN))) != nilHAND)
    {
    if ((plln = (PLLN) LOCK(h)) != NULL)
      {
      plln->hNext = nilHAND;
      plln->hData = nilHAND;
      UNLOCK(h);
      }
    else
      {
      FREE(h);
      h = nilHAND;
      }
    }
  return (LL)h;
  }


/*******************
**
** Name:       DestroyLL
**
** Purpose:    Deletes a LL and all of its contents
**
** Arguments:  ll - linked list
**
** Returns:    Nothing.
**
*******************/

VOID FAR APIENTRY DestroyLL(ll)
LL ll;
  {
  HLLN hllnNow = ll;
  HLLN hllnNext;
  PLLN plln;

  do
    {
    hllnNext = WalkLL(ll, hllnNow);
    plln = (PLLN)LOCK(hllnNow);
    ASSERT(plln);
    FREE(plln->hData);
    UNLOCK(hllnNow);
    FREE(hllnNow);
    hllnNow = hllnNext;
    } while (hllnNow != nilHLLN);
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\common\message.c ===
#include "windows.h"
#include <port1632.h>

VOID    FAR InitMerge();
INT     FAR AlertBox();

BOOL  FAR MergeStrings(CHAR    *szSrc,
                       CHAR    *szMerge,
                       CHAR    *szDst);

WORD wMerge;

/* ** Post a message box */
INT FAR AlertBox(hwndParent, szCaption, szText1, szText2, style)
HWND    hwndParent;
CHAR    *szCaption;
CHAR    *szText1;
CHAR    *szText2;
WORD style;
{
    CHAR    szMessage[256];

    MergeStrings(szText1, szText2, szMessage);

    return (MessageBox(hwndParent, (LPSTR)szMessage, (LPSTR)szCaption, style));
}


/* ** Scan sz1 for merge spec.  If found, insert string sz2 at that point.
      Then append rest of sz1 NOTE! Merge spec guaranteed to be two chars.
      returns TRUE if it does a merge, false otherwise. */
BOOL  FAR MergeStrings(szSrc, szMerge, szDst)
CHAR    *szSrc;
CHAR    *szMerge;
CHAR    *szDst;
{
    register    CHAR *pchSrc;
    register    CHAR *pchDst;

    pchSrc = szSrc;
    pchDst = szDst;

#ifndef UNICODE
    /* Find merge spec if there is one. */
    while (*(WORD *)pchSrc != wMerge) {
        if( IsDBCSLeadByte( *pchSrc ) )
            *pchDst++ = *pchSrc++;
        *pchDst++ = *pchSrc;

        /* If we reach end of string before merge spec, just return. */
        if(!*pchSrc++)
            return FALSE;
    }
#else
    /* Find merge spec if there is one. */
    while (*(WORD *)pchSrc != wMerge) {
        *pchDst++ = *pchSrc;

        /* If we reach end of string before merge spec, just return. */
        if (!*pchSrc++)
            return FALSE;
    }
#endif

    /* If merge spec found, insert sz2 there. (check for null merge string */
    if (szMerge) {
        while (*szMerge)
            *pchDst++ = *szMerge++;

    }

    /* Jump over merge spec */
    pchSrc++,pchSrc++;


    /* Now append rest of Src String */
    while (*pchDst++ = *pchSrc++);
    return TRUE;

}


VOID MergeInit(sz)
CHAR    *sz;
{
    wMerge = *(WORD *)sz;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\blinkdlg.h ===
/**************************************************/
/*                                                */
/*                                                */
/*      Chinese IME Batch Mode                    */
/*              (Dialogbox)                       */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#if 0 // move to imeblink.h!

#ifndef RC_INVOKED
#pragma pack(1)
#endif

//	data structure of IME table 
typedef struct tagUSRDICIMHDR {
    WORD  uHeaderSize;                  // 0x00
    BYTE  idUserCharInfoSign[8];        // 0x02
    BYTE  idMajor;                      // 0x0A
    BYTE  idMinor;                      // 0x0B
    DWORD ulTableCount;                 // 0x0C
    WORD  cMethodKeySize;               // 0x10
    BYTE  uchBankID;                    // 0x12
    WORD  idInternalBankID;             // 0x13
    BYTE  achCMEXReserved1[43];         // 0x15
    WORD  uInfoSize;                    // 0x40
    BYTE  chCmdKey;                     // 0x42
    BYTE  idStlnUpd;                    // 0x43
    BYTE  cbField;                      // 0x44
    WORD  idCP;                         // 0x45
    BYTE  achMethodName[6];             // 0x47
    BYTE  achCSIReserved2[51];          // 0x4D
    BYTE  achCopyRightMsg[128];         // 0x80
} USRDICIMHDR;

#ifndef RC_INVOKED
#pragma pack()
#endif

typedef USRDICIMHDR FAR *LPUSRDICIMHDR;

#endif 0 // move to imeblink.h!

class CBLinkDlg : public CDialog
{
public:
    CBLinkDlg(CWnd* pParent = NULL);

    //{{AFX_DATA(CBLinkDlg)
    enum { IDD = IDD_LINKBATCH };
    //}}AFX_DATA

    //{{AFX_VIRTUAL(CBLinkDlg)
    protected:
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

protected:
    BOOL    RegistStringTable();
#if 0 // move to imeblink.h!
    HKL     MatchImeName( LPCTSTR szStr);
    HKL     RegisterTable( HWND hWnd, LPUSRDICIMHDR lpIsvUsrDic,
            DWORD dwFileSize, UINT  uCodePage);
    int     CodePageInfo( UINT uCodePage);
#endif 0 // move to imeblink.h!

protected:
    //{{AFX_MSG(CBLinkDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnBrowsetable();
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\assocdlg.cpp ===
/**************************************************/
/*						                          */
/*						                          */
/*		Registry Process		                  */
/*		  (Dialog)			                      */
/*						                          */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include 	"stdafx.h"
#include 	"eudcedit.h"
#include 	"assocdlg.h"
#include 	"registry.h"
#include	"ttfstruc.h"
#include	"extfunc.h"
#include	"util.h"
#include	"gagedlg.h"

#define		LSPACE	2
#define		RSPACE	2
#define		LCSPACE 17
#define		NUMITEM	3
#define		DBCSCHK	0
#define		EUDCCHK 1

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

SELECTEUDC	SelectEUDC;

static HDC	hDC;
static HWND	hWnd;
static HICON	tIcon;
static HGLOBAL	hMem;
static int	nTypeFace, nIdx, CheckFlg;
static TCHAR	FontName[LF_FACESIZE];
static LPASSOCIATIONREG	lpAssociationReg;

static int 	CheckTTF( LOGFONT);
static BOOL	CheckCharSet( int CharSet);
static BOOL 	IsEUDCTTF( TCHAR *ttffile);
static BOOL 	CheckFileName( LPTSTR FileStr);

static int CALLBACK EnumFontFamProc(
	ENUMLOGFONT FAR*, NEWTEXTMETRIC FAR*, int, LPARAM);

static int CALLBACK EnumFontNumber(
	ENUMLOGFONT FAR*, NEWTEXTMETRIC FAR*, int, LPARAM);

extern BOOL 	SetCountryInfo( UINT LocalCP);



/****************************************/
/*					*/
/*	Constructor			*/
/*					*/
/****************************************/
CAssocDlg::CAssocDlg(
CWnd* 	pParent) : CDialog(CAssocDlg::IDD, pParent)
{
	m_pParent = pParent;
	//{{AFX_DATA_INIT(CAssocDlg)
	//}}AFX_DATA_INIT
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_INITDIALOG"		*/
/*					*/
/****************************************/
BOOL
CAssocDlg::OnInitDialog()
{
	CString	DlgTtl;
 	long	WindowStyle;

	CDialog::OnInitDialog();

	WindowStyle = GetWindowLong( this->GetSafeHwnd(), GWL_EXSTYLE);
	WindowStyle |= WS_EX_CONTEXTHELP;
	SetWindowLong( this->GetSafeHwnd(), GWL_EXSTYLE, WindowStyle);

	DlgTtl.LoadString( IDS_ASSOCIATE_DLGTITLE);
	this->SetWindowText( DlgTtl);

//	Set Dialog subclass
 	m_RegListBox.SubclassDlgItem( IDC_REGISTLIST, this);
	m_RegListBox.EnableScrollBar( SB_VERT, ESB_DISABLE_BOTH);

	CheckFlg = EUDCCHK;
	this->SendDlgItemMessage( IDC_RADIO_SYSTEM, BM_SETCHECK, (WPARAM)1, 0);
	hMem = NULL;
	if( !SetAssociationFontType()){
		this->MessageBox( NotMemMsg, NotMemTtl, MB_OK |
			MB_ICONHAND | MB_SYSTEMMODAL);

		return FALSE;
	}
	tIcon = AfxGetApp()->LoadIcon( IDI_TRUETYPE);
	return TRUE;
}

/****************************************/
/*					*/
/*	Set TTF and WIFE font		*/
/*					*/
/****************************************/
BOOL
CAssocDlg::SetAssociationFontType()
{
LPASSOCIATIONREG	lpAssociationRegTmp;
	int	aFontCount[] = {0,0,0};
	int	StartIdx = 0;
	int	sts;

	nTypeFace = nIdx = 0;
	hWnd = this->GetSafeHwnd();
	hDC  = ::GetDC( hWnd);

	sts = EnumFontFamilies( hDC, NULL,
	  	(FONTENUMPROC)EnumFontNumber, (LPARAM)aFontCount);
	if( hMem != NULL){
		GlobalUnlock( hMem);
		GlobalFree( hMem);
	}
	hMem = GlobalAlloc(GHND, sizeof(ASSOCIATIONREG) * nTypeFace);
	if( hMem == NULL){
		::ReleaseDC( hWnd, hDC);
		return FALSE;
	}

  lpAssociationReg = (LPASSOCIATIONREG)GlobalLock( hMem);
  lpAssociationRegTmp = lpAssociationReg;
  sts = EnumFontFamilies( hDC, NULL,
    (FONTENUMPROC)EnumFontFamProc, (LPARAM)aFontCount);
  ::ReleaseDC( hWnd, hDC);

  lpAssociationRegTmp = lpAssociationReg;
	for( int i = 0; i < nTypeFace; i++){
		sts = m_RegListBox.AddString(
			(LPCTSTR)lpAssociationRegTmp->szFaceName);
    m_RegListBox.SetItemData(sts, i);
		if( sts == LB_ERR || sts == LB_ERRSPACE){
			GlobalUnlock( hMem);
			GlobalFree( hMem);
			return FALSE;
		}
		if( !lstrcmp(lpAssociationRegTmp->szFaceName, SelectEUDC.m_Font)){
			StartIdx = i;
		}
		lpAssociationRegTmp++;
	}
	m_RegListBox.SetCurSel( StartIdx);

	return TRUE;
}

/****************************************/
/*					*/
/*		Callback 		*/
/*					*/
/****************************************/
static int
CALLBACK EnumFontNumber(
ENUMLOGFONT FAR	*lplf,
NEWTEXTMETRIC FAR* lptm,
int 	FontType,
LPARAM 	lParam)
{
	int 	sts;

	if( FontType == TRUETYPE_FONTTYPE){
		sts = CheckTTF( lplf->elfLogFont);
		if( sts == 1 && CheckCharSet( lplf->elfLogFont.lfCharSet)){
			nTypeFace++;
		}else if( sts == -1){
			return 0;
		}else	;
	}else if( FontType == 0x8 && lplf->elfLogFont.lfFaceName[0] != '@' &&
		  CheckCharSet( lplf->elfLogFont.lfCharSet)){
		nTypeFace++;
	}

	return 1;
}
/****************************************/
/*					*/
/*		Callback 		*/
/*					*/
/****************************************/
static int
CALLBACK EnumFontFamProc(
ENUMLOGFONT FAR	*lplf,
NEWTEXTMETRIC FAR* lptm,
int 	FontType,
LPARAM 	lParam)
{
  LPASSOCIATIONREG	lpAssociationRegTmp;
	TCHAR		FileTitle[MAX_PATH];
	TCHAR		*FilePtr;
	int		  sts;
  TCHAR   FileSbstName[LF_FACESIZE];

	if( FontType == TRUETYPE_FONTTYPE){
		sts = CheckTTF( lplf->elfLogFont);
		if( sts == 1 && CheckCharSet( lplf->elfLogFont.lfCharSet)){
      FindFontSubstitute(lplf->elfLogFont.lfFaceName, FileSbstName);
			lpAssociationRegTmp = lpAssociationReg + nIdx;
			lstrcpy((TCHAR *)lpAssociationRegTmp->szFaceName,
				FileSbstName);

			if(!InqTypeFace(lpAssociationRegTmp->szFaceName,
			    lpAssociationRegTmp->szFileName,
			    sizeof( lpAssociationRegTmp->szFileName)/sizeof(TCHAR))){
				GetStringRes(
				(TCHAR *)lpAssociationRegTmp->szFileName,
				IDS_NOTSELECT_STR);

				lstrcpy( lpAssociationRegTmp->szFileTitle,
				       lpAssociationRegTmp->szFileName);
			}else{
				lstrcpy(FileTitle,lpAssociationRegTmp->szFileName);
				if(( FilePtr=Mytcsrchr( FileTitle, '\\')) != NULL)
					FilePtr++;

				else{
					FilePtr = Mytcsrchr( FileTitle,':');
					if( FilePtr != NULL){
						FilePtr++;
					}else 	FilePtr = FileTitle;
				}
				lstrcpy(lpAssociationRegTmp->szFileTitle,
				       FilePtr);
			}
			lpAssociationRegTmp->FontTypeFlg = TRUE;
			lpAssociationRegTmp->UpdateFlg = FALSE;
			nIdx++;
		}else if( sts == -1){
			return 0;
		}else	;
	}else if( FontType == 0x8 && lplf->elfLogFont.lfFaceName[0] != '@' &&
		  CheckCharSet( lplf->elfLogFont.lfCharSet)){
    FindFontSubstitute(lplf->elfLogFont.lfFaceName, FileSbstName);
		lpAssociationRegTmp = lpAssociationReg + nIdx;

    lstrcpy((TCHAR *)lpAssociationRegTmp->szFaceName,
			FileSbstName);

		if( !InqTypeFace(lpAssociationRegTmp->szFaceName,
		   lpAssociationRegTmp->szFileName,
		    sizeof(lpAssociationRegTmp->szFileName)/sizeof(TCHAR))){
			GetStringRes((TCHAR *)lpAssociationRegTmp->szFileName,
				IDS_NOTSELECT_STR);
			lstrcpy(lpAssociationRegTmp->szFileTitle,
			       lpAssociationRegTmp->szFileName);
		}else{
			lstrcpy(FileTitle,
			       lpAssociationRegTmp->szFileName);
			if(( FilePtr=Mytcsrchr( FileTitle, '\\')) != NULL)
				FilePtr++;
			else{
				FilePtr = Mytcsrchr( FileTitle,':');
				if( FilePtr != NULL){
					FilePtr++;
				}else 	FilePtr = FileTitle;
			}
			lstrcpy(lpAssociationRegTmp->szFileTitle,
			       FilePtr);
		}
		lpAssociationRegTmp->FontTypeFlg = FALSE;
		lpAssociationRegTmp->UpdateFlg = FALSE;
		nIdx++;
	}
	return 1;
}

/****************************************/
/*					*/
/*	Check Character Set		*/
/*					*/
/****************************************/
static BOOL
CheckCharSet(
int 	CharSet)
{
	if( CountryInfo.CharacterSet != CharSet)
		return FALSE;
	else	return TRUE;
}

/****************************************/
/*					*/
/*	COMMAND 	"IDOK"		*/
/*					*/
/****************************************/
void
CAssocDlg::OnOK()
{
  LPASSOCIATIONREG	lpAssociationRegTmp;
	TCHAR	FileList[MAX_PATH];	
	TCHAR	TTFPath[MAX_PATH];
	TCHAR	BMPPath[MAX_PATH];
	TCHAR	*FilePtr;

  int	nIndex = m_RegListBox.GetCurSel();
	if( nIndex == -1){
		OutputMessageBox( this->GetSafeHwnd(),
			IDS_ASSOCIATE_DLGTITLE,
			IDS_NOTSELTYPEFACE_MSG, TRUE);
		m_RegListBox.SetFocus();
		return;
	}

    // The code is to fix the related bug #421829 & #438677
    // It delays 1 second to call EnabelEUDC(FALSE).
    DWORD dwStart = GetTickCount();

    // Stop if this has taken too long
    while (1)
    {
        if( GetTickCount() - dwStart >= 1000 )
            break;
    }
    
	EnableEUDC( FALSE);
	lpAssociationRegTmp = lpAssociationReg;
	GetStringRes( FileList, IDS_NOTSELECT_STR);
  nIndex = (int)m_RegListBox.GetItemData(nIndex);
	for( int i = 0; i < nTypeFace; i++)
  {
	  if( i == nIndex)
    {
      //
      // Treat as an error, if the eudc font file name is not
      // specified, yet.
      //
      if( !lstrcmp((LPCTSTR)lpAssociationRegTmp->szFileName,FileList) && 
				  (CheckFlg == DBCSCHK))
      {
        this->SendMessage(WM_COMMAND, IDC_MODIFY, NULL);
        if( !lstrcmp((LPCTSTR)lpAssociationRegTmp->szFileName,FileList))
        {
           m_RegListBox.SetFocus();
             EnableEUDC(TRUE);
		         return;
        }
      }

		  lstrcpy(SelectEUDC.m_Font, lpAssociationRegTmp->szFaceName);
			lstrcpy(SelectEUDC.m_File, lpAssociationRegTmp->szFileName);
			lstrcpy(SelectEUDC.m_FileTitle, lpAssociationRegTmp->szFileTitle);
			SelectEUDC.m_FontTypeFlg = lpAssociationRegTmp->FontTypeFlg;
		}
		if(!lstrcmp((LPCTSTR)lpAssociationRegTmp->szFileName,FileList)){
      if (lpAssociationRegTmp->UpdateFlg)
				  DeleteReg(lpAssociationRegTmp->szFaceName);
			lpAssociationRegTmp++;
			continue;
		}
		lstrcpy( (LPTSTR)TTFPath, (LPCTSTR)lpAssociationRegTmp->szFileName);
		lstrcpy( BMPPath, TTFPath);
		if(( FilePtr = Mytcsrchr( BMPPath, '.')) != NULL)
				*FilePtr = '\0';
		lstrcat( BMPPath, TEXT(".EUF"));
	
		if( OExistTTF( TTFPath))
    {
#if (WINVER >= 0x0500)
		  if (IsWin95EUDCBmp(BMPPath))
      {
			  if (!HandleImportWin95(TTFPath, BMPPath,nIndex ))
        {
//#for fix of 408428 -- allow user to proceed to register fontlink 
//even if there's no correct euf
//				  EnableEUDC( TRUE);
//				  return;
        }
      }
#endif
    }

		if( !lpAssociationRegTmp->UpdateFlg){
			lpAssociationRegTmp++;
			continue;
		}
 		if( !RegistTypeFace(
		    lpAssociationRegTmp->szFaceName,
		    lpAssociationRegTmp->szFileName))
    {
			EnableEUDC( TRUE);
			return;
		}

		lpAssociationRegTmp++;
	}
	EnableEUDC( TRUE);
	if( CheckFlg != DBCSCHK){
		if (!InitSystemFontAssoc())
		{
			return;
		}
	}

	GlobalUnlock( hMem);
 	GlobalFree( hMem);
	EndDialog(IDOK);
}

BOOL
CAssocDlg::InitSystemFontAssoc()
{
	TCHAR	DefaultFace[LF_FACESIZE];
	TCHAR	DefaultFile[MAX_PATH];
	TCHAR	TTFPath[MAX_PATH];
	TCHAR	BMPPath[MAX_PATH];
	TCHAR	*FilePtr;


	GetStringRes(DefaultFace, IDS_SYSTEMEUDCFONT_STR);
	GetStringRes(DefaultFile, IDS_DEFAULTFILENAME);

  // if the registry data for SystemEUDC font is already there, just use that.
  if (!InqTypeFace(DefaultFace,TTFPath,MAX_PATH)) {
    GetSystemWindowsDirectory( TTFPath, MAX_PATH);
#ifdef IN_FONTS_DIR // CAssocDlg::OnOK()
		lstrcat( TTFPath, TEXT("\\FONTS\\"));
#else
		lstrcat( TTFPath, TEXT("\\"));
#endif // IN_FONTS_DIR
 		lstrcat( TTFPath, DefaultFile);
  }

  lstrcpy( BMPPath, TTFPath);
  if(( FilePtr = Mytcsrchr( BMPPath, '.')) != NULL)
		*FilePtr = '\0';
	lstrcat( BMPPath, TEXT(".EUF"));

    // The code is to fix the related bug #421829 & #438677
    // It delays 1 second to call EnabelEUDC(FALSE).
    DWORD dwStart = GetTickCount();

    // Stop if this has taken too long
    while (1)
    {
        if( GetTickCount() - dwStart >= 1000 )
            break;
    }
	
	EnableEUDC( FALSE);
	if(OExistTTF( TTFPath))
  {
#if (WINVER >= 0x0500)
		if (IsWin95EUDCBmp(BMPPath))
		{
			if (!HandleImportWin95(TTFPath, BMPPath, -1))
			{
				EnableEUDC( TRUE);
				return FALSE;
			}
		}
#endif
  }

	SelectEUDC.m_FontTypeFlg = TRUE;
	lstrcpy(SelectEUDC.m_Font,(const TCHAR *)DefaultFace);
	lstrcpy(SelectEUDC.m_File,(const TCHAR *)TTFPath);
	lstrcpy(SelectEUDC.m_FileTitle,(const TCHAR *)DefaultFile);

	if( !RegistTypeFace(DefaultFace, TTFPath)){
		EnableEUDC( TRUE);
		return FALSE;
	}

  EnableEUDC( TRUE);
    return TRUE;
}
/****************************************/
/*					*/
/*	MESSAGE	"WM_DBLCLKS"		*/
/*					*/
/****************************************/
void
CAssocDlg::OnDblclkRegistlist()
{
	this->SendMessage(WM_COMMAND, IDC_MODIFY, 0);

}

/****************************************/
/*					*/
/*	COMMAND	"IDCANCEL"		*/
/*					*/
/****************************************/
void
CAssocDlg::OnCancel()
{
	GlobalUnlock( hMem);
	GlobalFree( hMem);
	EndDialog( IDCANCEL);
}

/****************************************/
/*					*/
/*	COMMAND	 "Modify"		*/
/*					*/
/****************************************/
void
CAssocDlg::OnModify()
{
LPASSOCIATIONREG	lpAssociationRegTmp;
OPENFILENAME	ofn;
	CString	sFilter;
	CWnd	*cWnd;
	TCHAR	chReplace;
	CString	szDlgTtl;
	TCHAR 	szFilter[MAX_PATH];
	TCHAR	szFileName[MAX_PATH];
	TCHAR	szTitleName[MAX_PATH];
	TCHAR	szDirName[MAX_PATH];

	int	nIndex = m_RegListBox.GetCurSel();
	if( nIndex == -1){
		OutputMessageBox( this->GetSafeHwnd(),
			IDS_ASSOCIATE_DLGTITLE,
			IDS_NOTSELTYPEFACE_MSG, TRUE);
		m_RegListBox.SetFocus();
		return;
	}
	//lpAssociationRegTmp = lpAssociationReg + nIndex;
	lpAssociationRegTmp = lpAssociationReg + m_RegListBox.GetItemData(nIndex);

//	Set filter of file( from string table)
	GetStringRes(szFilter, IDS_EUDCTTF_FILTER);
	int StringLength = lstrlen( szFilter);

	chReplace = szFilter[StringLength-1];
	for( int i = 0; szFilter[i]; i++){
		if( szFilter[i] == chReplace)
			szFilter[i] = '\0';
	}
	GetSystemWindowsDirectory( szDirName, sizeof(szDirName)/sizeof(TCHAR));
#ifdef IN_FONTS_DIR // CAssocDlg::OnModify()
    lstrcat( szDirName, TEXT("\\FONTS\\"));
#endif // IN_FONTS_DIR
	lstrcpy( szFileName, TEXT("*.TTE"));
	szDlgTtl.LoadString( IDS_MODIFY_DLGTITLE);

//	Set data in structure of OPENFILENAME
	ofn.lStructSize = sizeof( OPENFILENAME);
	ofn.hInstance = AfxGetInstanceHandle();
	ofn.hwndOwner = this->GetSafeHwnd();
	ofn.lpstrFilter = szFilter;
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxCustFilter = 0;
	ofn.nFilterIndex = 0;
	ofn.lpstrFile = szFileName;
	ofn.lpstrFileTitle = szTitleName;
	ofn.nMaxFileTitle = sizeof( szTitleName) / sizeof(TCHAR);
	ofn.nMaxFile = sizeof( szFileName) / sizeof(TCHAR);
	ofn.lpstrInitialDir = szDirName;
	ofn.Flags = OFN_HIDEREADONLY | OFN_NOCHANGEDIR
		| OFN_PATHMUSTEXIST ; 
  // there's no direct overwrite issue here, the file will be re-cycled.
  //| OFN_OVERWRITEPROMPT;
	ofn.lpstrDefExt = TEXT("tte");
	ofn.lpstrTitle = szDlgTtl;
	if( !GetSaveFileName( &ofn)){
		return;
	}
  TCHAR tmpName[MAX_PATH];
  lstrcpy(tmpName, szDirName);
  lstrcat(tmpName, TEXT("eudc.tte"));
  if( !lstrcmpi(ofn.lpstrFile, tmpName) ) {
		OutputMessageBox( this->GetSafeHwnd(),
			IDS_MODIFY_DLGTITLE,
			IDS_NOUSEEUDCFILE_MSG, TRUE);
		return;
  }
	if( !CheckFileName( ofn.lpstrFile)){
		OutputMessageBox( this->GetSafeHwnd(),
			IDS_MODIFY_DLGTITLE,
			IDS_ILLEGALFILE_MSG, TRUE);
		return;
	}
	if( OExistTTF( ofn.lpstrFile)){
		if( !IsEUDCTTF( ofn.lpstrFile)){
			OutputMessageBox( this->GetSafeHwnd(),
			IDS_MODIFY_DLGTITLE,
			IDS_NOTEUDCFILE_MSG, TRUE);
			return;
		}
	}
	lstrcpy(lpAssociationRegTmp->szFileName, ofn.lpstrFile);
	lstrcpy(lpAssociationRegTmp->szFileTitle,
		ofn.lpstrFileTitle);
	lpAssociationRegTmp->UpdateFlg = TRUE;
	m_RegListBox.InsertString( nIndex,
		(LPCTSTR)lpAssociationRegTmp->szFaceName);
  m_RegListBox.SetItemData(nIndex, m_RegListBox.GetItemData(nIndex+1));
	m_RegListBox.DeleteString( nIndex + 1);
	m_RegListBox.SetCurSel( nIndex);

	cWnd = GetDlgItem( IDC_REGISTLIST);
	GotoDlgCtrl( cWnd);
}

/****************************************/
/*					*/
/*	COMMAND 	"Remove"	*/
/*					*/
/****************************************/
void
CAssocDlg::OnRemove()
{
LPASSOCIATIONREG	lpAssociationRegTmp;
	TCHAR	Tmp[MAX_PATH];

	int	nIndex = m_RegListBox.GetCurSel();
	if( nIndex == -1){
		OutputMessageBox( this->GetSafeHwnd(),
			IDS_ASSOCIATE_DLGTITLE,
			IDS_NOTSELTYPEFACE_MSG, TRUE);
		m_RegListBox.SetFocus();
		return;
	}

	GetStringRes( Tmp, IDS_NOTSELECT_STR);
	//lpAssociationRegTmp = lpAssociationReg + nIndex;
	lpAssociationRegTmp = lpAssociationReg + m_RegListBox.GetItemData(nIndex);
	lstrcpy(lpAssociationRegTmp->szFileName,  (const TCHAR *)Tmp);
	lstrcpy(lpAssociationRegTmp->szFileTitle, (const TCHAR *)Tmp);
	lpAssociationRegTmp->UpdateFlg = TRUE;
	m_RegListBox.InsertString( nIndex,
			lpAssociationRegTmp->szFaceName);
  m_RegListBox.SetItemData(nIndex, m_RegListBox.GetItemData(nIndex+1));
	m_RegListBox.DeleteString( nIndex + 1);
	m_RegListBox.SetCurSel( nIndex);
	
//	DeleteReg(lpAssociationRegTmp->szFaceName);
	CWnd *cWnd = GetDlgItem( IDC_REGISTLIST);
	GotoDlgCtrl( cWnd);	
}

/****************************************/
/*					*/
/*	Check .TTF 			*/
/*					*/
/****************************************/
static int
CheckTTF(
LOGFONT 	LogFont)
{
struct	NamingTable	*Ntbl;
struct	NameRecord	*NameRec;
	HGLOBAL	hglb;
	DWORD	dwSize = 0L;
	DWORD	dwTable = 0L;
	LPSTR	lpBuffer, lpTable;
	HFONT	hFont = NULL;
	HGDIOBJ	OldFont = NULL;
	short	nRec = 0;
  int sysLCID;

//	Check "tategaki" or not
	if( LogFont.lfFaceName[0] == '@')
		return 0;

//	Get current font to Inquire ttf file
	hFont = ::CreateFontIndirect( &LogFont);
	if( hFont ) {
		OldFont = ::SelectObject( hDC, hFont);
	}
  

//	Get name table in ttf file
	lpTable = "name";
	dwTable = *(LPDWORD)lpTable;
	dwSize  = ::GetFontData( hDC, dwTable, 0L, NULL, 0L);
	if( dwSize == GDI_ERROR){
		if( OldFont ) ::SelectObject(hDC, OldFont);
		if( hFont ) ::DeleteObject(hFont);
		return 0;
	}
	hglb = GlobalAlloc( GHND, dwSize);
	if( hglb == NULL){
		if( OldFont ) ::SelectObject(hDC, OldFont);
		if( hFont ) ::DeleteObject(hFont);
		return -1;
	}
	lpBuffer = (LPSTR)GlobalLock( hglb);
	::GetFontData( hDC, dwTable, 0L, (LPVOID)lpBuffer, dwSize);
	if( OldFont ) ::SelectObject(hDC, OldFont);
	if( hFont ) ::DeleteObject(hFont);

	Ntbl = (struct NamingTable *)lpBuffer;
	sitom( &Ntbl->NRecs);
	nRec = Ntbl->NRecs;
	lpBuffer += sizeof(struct NamingTable);
  sysLCID = (int) LANGIDFROMLCID(GetSystemDefaultLCID());
	while( nRec-- > 0){
		NameRec = (struct NameRecord *)lpBuffer;			
		sitom( &NameRec->PlatformID);
		sitom( &NameRec->PlatformSpecEncID);
		sitom( &NameRec->LanguageID);

#ifdef BUILD_ON_WINNT
//		Unicode TTF
		if( CountryInfo.bUnicodeMode ){
// 			if( NameRec->PlatformID == 3 &&
//		    	    NameRec->LanguageID == sysLCID){
        GlobalUnlock( hglb);
				GlobalFree( hglb);
				return 1;
//			}
		}
#endif //BUILD_ON_WINNT

//		Japanese TTF
		if( CountryInfo.LangID == EUDC_JPN){
			if( NameRec->PlatformID == 3 &&
		    	    NameRec->LanguageID == EUDC_JPN){
				GlobalUnlock( hglb);
				GlobalFree( hglb);
				return 1;
			}
		}
//		Chinese Taipei TTF
		if( CountryInfo.LangID == EUDC_CHT){
			if( NameRec->PlatformID == 3 &&
        NameRec->LanguageID == EUDC_CHT){
    		GlobalUnlock( hglb);
				GlobalFree( hglb);
				return 1;
			}
		}
//		Chinese GB TTF
		if( CountryInfo.LangID == EUDC_CHS){
			if( NameRec->PlatformID == 3 &&
        NameRec->LanguageID == EUDC_CHS){
        GlobalUnlock( hglb);
				GlobalFree( hglb);
				return 1;
			}
		}
//		Korea TTF(WANSUNG)
		if( CountryInfo.LangID == EUDC_KRW){
			if( NameRec->PlatformID == 3 &&
        NameRec->LanguageID == EUDC_KRW){
		    GlobalUnlock( hglb);
				GlobalFree( hglb);
				return 1;		
			}
		}	    	
/*
//    Hebrew TTF
    if( CountryInfo.LangID == EUDC_HEBREW) {
			if( NameRec->PlatformID == 1 &&
          NameRec->LanguageID == 0 ) {
		    		GlobalUnlock( hglb);
				GlobalFree( hglb);
				return 1;		
			}
		}	    	
*/

		lpBuffer += sizeof(struct NameRecord);
	}
	GlobalUnlock( hglb);
	GlobalFree( hglb);
	return 0;
}

/****************************************/
/*					*/
/*	Radio DBCS Clicked		*/
/*					*/
/****************************************/
void
CAssocDlg::OnRadioDbcs()
{
	CWnd 	*cWnd;

	if( CheckFlg != DBCSCHK){
		CheckFlg = DBCSCHK;
		m_RegListBox.EnableWindow( TRUE);
		m_RegListBox.EnableScrollBar( SB_VERT, ESB_ENABLE_BOTH);
		m_RegListBox.UpdateWindow();

		cWnd = this->GetDlgItem( IDC_MODIFY);
		cWnd->EnableWindow( TRUE);

		cWnd = this->GetDlgItem( IDC_REMOVE);
		cWnd->EnableWindow( TRUE);
	}
}

/****************************************/
/*					*/
/*	Radio SYSTEM Clicked		*/
/*					*/
/****************************************/
void
CAssocDlg::OnRadioSystem()
{
	CWnd	*cWnd;

	if( CheckFlg != EUDCCHK){
		CheckFlg = EUDCCHK;
		m_RegListBox.EnableWindow( FALSE);
		m_RegListBox.EnableScrollBar( SB_VERT, ESB_DISABLE_BOTH);

		cWnd = this->GetDlgItem( IDC_MODIFY);
		cWnd->EnableWindow( FALSE);

		cWnd = this->GetDlgItem( IDC_REMOVE);
		cWnd->EnableWindow( FALSE);
	}
}

/****************************************/
/*					*/
/*	Inquire into file( EUDC or not)	*/
/*					*/
/****************************************/
static BOOL
IsEUDCTTF(
TCHAR 	*ttffile)
{
struct	NamingTable	*nTbl;
struct	NameRecord	*nRec;
unsigned int	BufSiz;	
	char	*TableBuf, *SearchOfs;
	char	TTFName[MAX_CODE];


	HANDLE fHdl = CreateFile(ttffile,
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fHdl == INVALID_HANDLE_VALUE)
		return FALSE;

	if( TTFReadVarTable( fHdl, &TableBuf, &BufSiz, "name")){
		CloseHandle( fHdl);
		return FALSE;
	}

	SearchOfs = TableBuf;
	nTbl = (struct NamingTable *)TableBuf;

	sitom( &nTbl->OfsToStr);
	SearchOfs += sizeof(struct NamingTable);
	SearchOfs += sizeof(struct NameRecord);
	nRec = (struct NameRecord *)SearchOfs;

	sitom( &nRec->StringOfs);
	SearchOfs = TableBuf + nTbl->OfsToStr + nRec->StringOfs;
	SearchOfs += sizeof(char);
	for( short Inc = 0; Inc < MAX_CODE - 1; Inc++){
		TTFName[Inc] = (char)*SearchOfs;
		SearchOfs += sizeof(char)*2;
	}
	TTFName[Inc] = '\0';
	if( lstrcmpA( TTFName, "EUDC") == 0){
		free( TableBuf);
		CloseHandle( fHdl);
		return TRUE;
	}
	free( TableBuf);
	CloseHandle( fHdl);
	return FALSE;
}

/****************************************/
/*					*/
/*	Inquire into filename		*/
/*					*/
/****************************************/
static BOOL
CheckFileName(
LPTSTR	FileStr)
{
	TCHAR	FileTmp[MAX_PATH];
	TCHAR	Tmp[MAX_PATH];
	TCHAR	*FilePtr;

	FilePtr = FileStr;
	while( *FilePtr == ' ')
		FilePtr++;

	if( *FilePtr == '.' || *FilePtr == '\0')
		return FALSE;

	int i = 0;
	while( *FilePtr != '\0'){
		FileTmp[i] = *FilePtr;
		FilePtr++;
		i++;
	}
	FileTmp[i] = '\0';
	if(( FilePtr = Mytcsrchr( FileTmp, '.')) == NULL)
		lstrcat( FileTmp, TEXT(".tte"));
	else{
#ifdef BUILD_ON_WINNT
		if( lstrcmpi( FilePtr, TEXT(".TTE")))
#else
		if( stricmp( FilePtr, ".TTE"))
#endif // BUILD_ON_WINNT
			return FALSE;
	}

	lstrcpy(Tmp, FileTmp);
	if( lstrlen(Tmp) >= MAX_PATH)
		return FALSE;
	lstrcpy( FileStr, FileTmp);

	return TRUE;
}
static DWORD aIds[] =
{
	IDC_MODIFY, IDH_EUDC_MODIFY,
	IDC_REMOVE, IDH_EUDC_REMOVE,
	IDC_REGISTLIST,	IDH_EUDC_ASSO_LIST,
	IDC_RADIO_SYSTEM, IDH_EUDC_ASSO_STANDARD,
	IDC_RADIO_DBCS, IDH_EUDC_ASSO_TYPEFACE,
	0,0
};

/****************************************/
/*					*/
/*		Window Procedure	*/
/*					*/
/****************************************/
LRESULT
CAssocDlg::WindowProc(
UINT 	message,
WPARAM 	wParam,
LPARAM 	lParam)
{
	if( message == WM_HELP){
		::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
			HelpPath, HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);
		return(0);
	}	
	if( message == WM_CONTEXTMENU){
		::WinHelp((HWND)wParam, HelpPath,
			HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)aIds);
		return(0);
	}
	return CDialog::WindowProc(message, wParam, lParam);
}

BEGIN_MESSAGE_MAP(CAssocDlg, CDialog)
	//{{AFX_MSG_MAP(CAssocDlg)
	ON_LBN_DBLCLK(IDC_REGISTLIST, OnDblclkRegistlist)
	ON_BN_CLICKED(IDC_MODIFY, OnModify)
	ON_BN_CLICKED(IDC_REMOVE, OnRemove)
	ON_BN_CLICKED(IDC_RADIO_DBCS, OnRadioDbcs)
	ON_BN_CLICKED(IDC_RADIO_SYSTEM, OnRadioSystem)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/****************************************/
/*					*/
/*	MeasureItem			*/
/*					*/
/****************************************/
void
CRegistListBox::MeasureItem(
LPMEASUREITEMSTRUCT lpMIS)
{
	CRect	ListBoxRect;

	this->GetClientRect( &ListBoxRect);
	ItemHeight = ListBoxRect.Height() /NUMITEM;
	lpMIS->itemHeight = ItemHeight;
}

/****************************************/
/*					*/
/*	Draw Item			*/
/*					*/
/****************************************/
void
CRegistListBox::DrawItem(
LPDRAWITEMSTRUCT lpDIS)
{
LPASSOCIATIONREG	lpAssociationRegTmp;
	LOGFONT	LogFont;
	CSize	CharSize, FontSize, cSize;
	TCHAR	FileTmp[MAX_PATH], NotSel[MAX_PATH];
	int	Offset;

	CDC* pDC = CDC::FromHandle( lpDIS->hDC);
	if( lpDIS->itemAction & ODA_DRAWENTIRE){
	  	CBrush	fBrush;

		fBrush.CreateSolidBrush(GetSysColor(COLOR_WINDOW)); // COLOR_WIN);
		pDC->FillRect( &lpDIS->rcItem, &fBrush);
		fBrush.DeleteObject();
		pDC->SetBkColor( GetSysColor(COLOR_WINDOW)); //COLOR_WIN);

		//lpAssociationRegTmp = lpAssociationReg + lpDIS->itemID;
		lpAssociationRegTmp = lpAssociationReg + lpDIS->itemData;
    if( CheckFlg == DBCSCHK)
			pDC->SetTextColor( GetSysColor(COLOR_WINDOWTEXT)); //COLOR_BLACK);
		else 	pDC->SetTextColor( GetSysColor(COLOR_GRAYTEXT));  //COLOR_SHADOW);

		GetFont()->GetObject( sizeof(LOGFONT), &LogFont);
		if( abs( LogFont.lfHeight) < ItemHeight)
			Offset = ( ItemHeight - abs( LogFont.lfHeight)) /2;
		else	Offset = 0;

		if( lpAssociationRegTmp->FontTypeFlg){
			pDC->DrawIcon( lpDIS->rcItem.left + LSPACE,
				lpDIS->rcItem.top + Offset, tIcon);
		}

		lstrcpy(FileTmp,
		(const TCHAR *)lpAssociationRegTmp->szFileTitle);
		GetStringRes( NotSel, IDS_NOTSELECT_STR);
		if( FileTmp[0] == '\0' ||
		   !lstrcmp((const TCHAR *)FileTmp,(const TCHAR *)NotSel)){

		}else{
			TCHAR	*FilePtr;
			if(( FilePtr = Mytcsrchr( FileTmp, '.')) != NULL)
				*FilePtr = '\0';
			if( lstrlen((const TCHAR *)FileTmp) > 20){
				FileTmp[20] = '\0';
				lstrcat((TCHAR *)FileTmp, TEXT(".."));
			}
		}

		GetTextExtentPoint32( pDC->GetSafeHdc(),
			(const TCHAR *)FileTmp,
			lstrlen((const TCHAR *)FileTmp), &CharSize);

		pDC->ExtTextOut( lpDIS->rcItem.right - CharSize.cx - RSPACE,
			lpDIS->rcItem.top + Offset, 0, 0,
			(const TCHAR *)FileTmp,
			lstrlen((const TCHAR *)FileTmp), NULL);

		int	FontWidth;

		lstrcpy(FontName,
		(const TCHAR *)lpAssociationRegTmp->szFaceName);
		FontWidth = lpDIS->rcItem.right - lpDIS->rcItem.left
			- LCSPACE - RSPACE - CharSize.cx;

		GetTextExtentPoint32( pDC->GetSafeHdc(),
			(const TCHAR *)FontName,
			lstrlen((const TCHAR *)FontName), &FontSize);
			
		if( FontWidth <= FontSize.cx){
			int 	i;
			
 			GetTextExtentPoint32( pDC->GetSafeHdc(),TEXT("<<"),2, &cSize);
			i = ( FontWidth /cSize.cx) * 2;
			FontName[i-2] = '.';
			FontName[i-1] = '.';
			FontName[i] = '\0';
		}

		pDC->ExtTextOut(lpDIS->rcItem.left + LCSPACE,
			lpDIS->rcItem.top + Offset, 0, 0,
			FontName,
			lstrlen(FontName),	NULL);
	}

	if(( lpDIS->itemState & ODS_SELECTED) &&
	   ( lpDIS->itemAction & (ODA_SELECT | ODA_DRAWENTIRE))){
	   	CBrush	fBrush;

		if( CheckFlg == DBCSCHK)
			fBrush.CreateSolidBrush(::GetSysColor(COLOR_HIGHLIGHT));
		else	fBrush.CreateSolidBrush(GetSysColor(COLOR_WINDOW)); // COLOR_WIN);

		pDC->FillRect( &lpDIS->rcItem, &fBrush);
		fBrush.DeleteObject();

		//lpAssociationRegTmp = lpAssociationReg + lpDIS->itemID;
		lpAssociationRegTmp = lpAssociationReg + lpDIS->itemData;

		if( CheckFlg == DBCSCHK){
			pDC->SetBkColor(::GetSysColor( COLOR_HIGHLIGHT));
			pDC->SetTextColor(::GetSysColor( COLOR_HIGHLIGHTTEXT));
		}else{
			pDC->SetBkColor(GetSysColor(COLOR_WINDOW)); // COLOR_WIN);
			pDC->SetTextColor(GetSysColor(COLOR_GRAYTEXT)); // COLOR_SHADOW);
		}

		GetFont()->GetObject( sizeof(LOGFONT), &LogFont);
		if( abs( LogFont.lfHeight) < ItemHeight)
			Offset = ( ItemHeight - abs( LogFont.lfHeight)) /2;
		else	Offset = 0;

		if( lpAssociationRegTmp->FontTypeFlg){
			pDC->DrawIcon( lpDIS->rcItem.left + LSPACE,
				lpDIS->rcItem.top + Offset, tIcon);
		}

		lstrcpy(FileTmp,
			lpAssociationRegTmp->szFileTitle);
		GetStringRes( NotSel, IDS_NOTSELECT_STR);
		if( FileTmp[0] == '\0' ||
		   !lstrcmp(FileTmp,NotSel)){

		}else{
			TCHAR 	*FilePtr;
			if(( FilePtr = Mytcsrchr( FileTmp, '.')) != NULL)
				*FilePtr = '\0';
			if( lstrlen(FileTmp) > 20){
				FileTmp[20] = '\0';
				lstrcat(FileTmp, TEXT(".."));
			}
		}

		GetTextExtentPoint32( pDC->GetSafeHdc(),
			FileTmp,
			lstrlen(FileTmp), &CharSize);

		pDC->ExtTextOut( lpDIS->rcItem.right - CharSize.cx - RSPACE,
			lpDIS->rcItem.top + Offset, 0, 0,
			FileTmp,
			lstrlen(FileTmp), NULL);

		int	FontWidth;

		lstrcpy(FontName,
			lpAssociationRegTmp->szFaceName);
		FontWidth = lpDIS->rcItem.right - lpDIS->rcItem.left
			- LCSPACE - RSPACE - CharSize.cx;

		GetTextExtentPoint32( pDC->GetSafeHdc(),
			FontName,
			lstrlen(FontName), &FontSize);
			
		if( FontWidth <= FontSize.cx){
			int 	i;
			
 			GetTextExtentPoint32( pDC->GetSafeHdc(),TEXT("<<"),2, &cSize);
			i = ( FontWidth /cSize.cx) * 2;
			FontName[i-2] = '.';
			FontName[i-1] = '.';
			FontName[i] = '\0';
		}
				
		pDC->ExtTextOut( lpDIS->rcItem.left + LCSPACE,
			lpDIS->rcItem.top + Offset, 0, 0,
			FontName,
			lstrlen(FontName),	NULL);
	}

	if( !(lpDIS->itemState & ODS_SELECTED) &&
	  ( lpDIS->itemAction & ODA_SELECT)){
	  	CBrush	fBrush;

		fBrush.CreateSolidBrush(GetSysColor(COLOR_WINDOW)); // COLOR_WIN);
		pDC->FillRect( &lpDIS->rcItem, &fBrush);
		fBrush.DeleteObject();
		
		//lpAssociationRegTmp = lpAssociationReg + lpDIS->itemID;
		lpAssociationRegTmp = lpAssociationReg + lpDIS->itemData;

		pDC->SetBkColor(GetSysColor(COLOR_WINDOW)); // COLOR_WIN);
		if( CheckFlg == DBCSCHK)
			pDC->SetTextColor(GetSysColor(COLOR_WINDOWTEXT)); // COLOR_BLACK);
		else	pDC->SetTextColor(GetSysColor(COLOR_GRAYTEXT));  // COLOR_SHADOW);

		GetFont()->GetObject( sizeof(LOGFONT), &LogFont);
		if( abs( LogFont.lfHeight) < ItemHeight)
			Offset = ( ItemHeight - abs( LogFont.lfHeight)) /2;
		else	Offset = 0;

		if( lpAssociationRegTmp->FontTypeFlg){
			pDC->DrawIcon( lpDIS->rcItem.left + LSPACE,
				lpDIS->rcItem.top + Offset, tIcon);
		}

		lstrcpy( FileTmp,
			lpAssociationRegTmp->szFileTitle);
		GetStringRes( NotSel, IDS_NOTSELECT_STR);
		if( FileTmp[0] == '\0' ||
		   !lstrcmp(FileTmp,NotSel)){

		}else{
			TCHAR 	*FilePtr;
			if(( FilePtr = Mytcsrchr( FileTmp, '.')) != NULL)
				*FilePtr = '\0';
			if( lstrlen(FileTmp) > 20){
				FileTmp[20] = '\0';
				lstrcat(FileTmp, TEXT(".."));
			}
		}

		GetTextExtentPoint32( pDC->GetSafeHdc(),
			FileTmp,
			lstrlen(FileTmp), &CharSize);

		pDC->ExtTextOut( lpDIS->rcItem.right - CharSize.cx - RSPACE,
			lpDIS->rcItem.top + Offset, 0, 0,
			FileTmp,
			lstrlen(FileTmp), NULL);

		int	FontWidth;

		lstrcpy(FontName,
			lpAssociationRegTmp->szFaceName);
		FontWidth = lpDIS->rcItem.right - lpDIS->rcItem.left
			- LCSPACE - RSPACE - CharSize.cx;

		GetTextExtentPoint32( pDC->GetSafeHdc(),
			FontName,
			lstrlen(FontName), &FontSize);
			
		if( FontWidth <= FontSize.cx){
			int 	i;
			
 			GetTextExtentPoint32( pDC->GetSafeHdc(),TEXT("<<"),2, &cSize);
			i = ( FontWidth /cSize.cx) * 2;
			FontName[i-2] = '.';
			FontName[i-1] = '.';
			FontName[i] = '\0';
		}

		pDC->ExtTextOut( lpDIS->rcItem.left + LCSPACE,
			lpDIS->rcItem.top + Offset, 0, 0,
			FontName,	
			lstrlen(FontName),	NULL);
	}
}

int CRegistListBox::CompareItem(LPCOMPAREITEMSTRUCT lpCIS)
{
  TCHAR	TmpFontName1[LF_FACESIZE], TmpFontName2[LF_FACESIZE];
  LPASSOCIATIONREG	lpAssociationRegTmp1,lpAssociationRegTmp2;
    lpAssociationRegTmp1 = lpAssociationReg + lpCIS->itemData1;
    lpAssociationRegTmp2 = (LPASSOCIATIONREG) (lpCIS->itemData2);
    lstrcpy(TmpFontName1, lpAssociationRegTmp1->szFaceName);
    lstrcpy(TmpFontName2, lpAssociationRegTmp2->szFaceName);
    return (lstrcmp(TmpFontName1, TmpFontName2));
}

BOOL CAssocDlg::HandleImportWin95(
LPTSTR TTFPath,
LPTSTR BMPPath,
int Idx)
{

	TCHAR UserFont[MAX_PATH];
	LPTSTR FilePtr;
	TCHAR szTmpDir[MAX_PATH];

	GetTempPath(MAX_PATH, szTmpDir);

	if (!GetTempFileName(szTmpDir, TEXT("EUF"), 0, UserFont))
	{
		lstrcpy(UserFont, BMPPath);
		if(( FilePtr = Mytcsrchr( UserFont, '\\')) != NULL)
			*FilePtr = '\0';
		lstrcpy(UserFont, TEXT("EUF.tmp"));
	}

	if (!MoveFileEx(BMPPath, UserFont, MOVEFILE_REPLACE_EXISTING))
	{
		return FALSE;

	}

  CGageDlg dlg(this, UserFont, BMPPath, TTFPath, TRUE);
	dlg.DoModal();

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\bmpope.cpp ===
/***********************************************************************
 *
 *	BitMap Openration modules
 *
 * Copyright (c) 1997-1999 Microsoft Corporation.
 *
 ***********************************************************************
 *	BitMap Specifications
 *
 *	Coordinate
 *		(0,0)	X    (255,0)
 *		 +--------------*
 *		 |
 *	       Y |
 *		 |
 *		 |
 *		 |
 *		 *
 *	      (0,255)
 *	Memory Boundary : Word Boundary
 *
 *	Entry List
 *		BMPDefine,
 *		BMPZoomUp,
 *		BMPOutline
 ***********************************************************************/

#include	"stdafx.h"


#include	"vdata.h"
#include	"extfunc.h"
#define		BMPWIDMAX		256
#define		BMPDEPMAX		256

#define		BMPMAX		8

struct BMPDef {
	int	width, depth;
	unsigned char *buf;
	int	bWid;
	};


void  BMPInit(void);
int  BMPDefine(unsigned char  *buf,int  xWid,int  yWid);
int  BMPFreDef(int  bmpno);
int  BMPMkCont(int  BMPNo,int  wkBMP,int  refBMP,int  lsthdl);
static int  SearchON(int  BMPNo,int  x,int  y);
static int  outline(int  BMPNo,int  x,int  y,int  lsthdl,int  wkBMP,int  refBMP);
static int  ContributeOutside(int  BMPNo,int  wkBMP,struct  vecdata *org,int  lsthdl);
static int  ContributeInside(int  BMPNo,int  wkBMP,struct  vecdata *org,int  lsthdl);
int  rdot(int  BMP,int  x,int  y);
void  wdot(int  BMP,int  x,int  y,int  onoff);
int  ReverseRight(int  BMPNo,int  x,int  y);
static void  cpybuf(int  src,int  dst);
int  BMPReverse(int  bmpNo);
int  BMPClear(int  bmpNo);

struct BMPDef BMPTbl[BMPMAX]={0};

	/* On Bit Most left position */
static unsigned char	bitptbl[256] = {
	 8,  7,  6,  6,  5,  5,  5,  5,  4,  4,  4,  4,  4,  4,  4,  4,
	 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
	 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
	 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
	 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
	};
static unsigned char	wmaskB[8]={
	0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01
	};
static unsigned char	rightmask[8] = {
	0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01
	};
/***********************************************************************
 *	BMP Initialize
 */
/* */	void
/* */	BMPInit()
/*
 *	returns; none
 ***********************************************************************/
{
	int	i;

	for ( i = 0; i < BMPMAX; i++)
		BMPTbl[i].buf=(unsigned char *)0;
	return;
}
/***********************************************************************
 *	Define BitMap
 */
/* */	int
/* */	BMPDefine(
/* */		unsigned char *buf,
/* */		int	xWid,
/* */		int	yWid)
/*
 *	returns : 0-(BMPMAX-1), -1
 ***********************************************************************/
{
	int	i;

	/* Check Size */
	if ( xWid > BMPWIDMAX || xWid < 0
		    ||	yWid > BMPWIDMAX || yWid < 0)
		goto	ERET;

	/* Set Define */
	for ( i = 0; i < BMPMAX; i++) {
		if (BMPTbl[i].buf==(unsigned char *)0) {
			BMPTbl[i].bWid =  (xWid + 15)/16*2;
			BMPTbl[i].width = xWid;
			BMPTbl[i].depth = yWid;
			BMPTbl[i].buf = buf;

			return(i);
		}
	}
ERET:
	return( -1);
}
/***********************************************************************
 *	Free BMP define
 */
/* */	int
/* */	BMPFreDef( int bmpno)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
	if ( bmpno < 0 || bmpno >= BMPMAX)
		return -1;
	else {
		BMPTbl[bmpno].buf = 0;
		return 0;
	}
}
/***********************************************************************
 *	Get Outline
 */
/* */	int
/* */	BMPMkCont( int BMPNo, int wkBMP, int refBMP, int lsthdl)
/*
 *	returns : Number of Contour, -1
 *	REMARKS : Used BMP be destroyed
 ***********************************************************************/
{
	int	x, y;
	int	ncont;
	int	sts;

	VDNew( lsthdl);
	sts = 0;
	ncont = 0;
	cpybuf( BMPNo, wkBMP);
	cpybuf( BMPNo, refBMP);
	for ( y = 0; y < BMPTbl[BMPNo].depth; y++) {
		x = 0;
		while ( (x = SearchON( wkBMP, x, y)) <BMPTbl[BMPNo].width) {
			if ((sts = outline( BMPNo, x, y,lsthdl, wkBMP, refBMP))<0)
				goto	RET;

			ncont++;
			x++;
		}
	}
	sts = ncont;
    	cpybuf(refBMP,BMPNo);
RET:
	return( sts);
}
/***********************************************************************
 *	Search ON dot
 */
/* */	static int
/* */	SearchON( int BMPNo, int x, int y)
/*
 *	returns : found position, Width(Not Found case)
 ***********************************************************************/
{
	int	bpos;		/* byte position */
	int	sbitpos;	/* Start Byte Bit position */
unsigned char	*p;

	bpos = x/8;
	sbitpos = x % 8;
	p = BMPTbl[BMPNo].buf + BMPTbl[BMPNo].bWid*y + bpos;
	/* First Byte */
	if ( *p & rightmask[sbitpos])
		x = bpos*8 + bitptbl[(int)(*p& rightmask[sbitpos])];
	else {
		bpos++;
		x = bpos*8;
		for ( ; bpos < BMPTbl[BMPNo].bWid; bpos++, x+=8) {
			p++;
			if (*p) {
				x += bitptbl[(int)*p];
				break;
			}
		}
	}
	return( x);
}
/***********************************************************************
 *	make outline data
 */
/* */	static int
/* */	outline(
/* */		int	BMPNo,
/* */		int	x,
/* */		int	y,
/* */		int	lsthdl,
/* */		int	wkBMP,
/* */		int	refBMP)
/*
 *	returns : 0, -1
 **********************************************************************/
{
	int	inout;
    struct vecdata	vd;	
	int	sts;

	/* Check Inside/Outside */
	if ( rdot( refBMP, x, y) ==rdot( wkBMP, x, y))	/* OUTSIDE */
		inout = 0;
	else	/* INSIDE */
		inout = 1;

	/* copy buffer */
	cpybuf( wkBMP, BMPNo);
	/* contribute */
	vd.x = (short)x;
	vd.y = (short)y;
	vd.atr = 0;
	if ( inout==0)
		sts = ContributeOutside( BMPNo, wkBMP, &vd, lsthdl);
	else
		sts = ContributeInside( BMPNo, wkBMP, &vd, lsthdl);
	return( sts);
}
/***********************************************************************
 *	Contribute Outside Contour
 */
/* */	static int
/* */	ContributeOutside(int BMPNo, int wkBMP, struct vecdata *org, int lsthdl)
/*
 *	returns : 0, -1
 *	Direction	2
 *			|
 *			|
 *		3-------+-------1
 *			|
 *			|
 *			0
 ***********************************************************************/
{
	int	orgx, orgy;
struct vecdata	vd;
	int	dir;

	orgx = org->x;
	orgy = org->y;
	vd = *org;
	dir = 0;
	/*
	if (ReverseRight( wkBMP, vd.x, vd.y))
		return( -1);
	*/
	do {
		if (VDSetData( lsthdl, &vd))
			return(-1);
		switch( dir) {
		    case 0:
			if (ReverseRight( wkBMP, vd.x, vd.y))
				return( -1);
			vd.y++;
			if ( rdot( BMPNo, vd.x-1, vd.y))
				dir = 3;
			else if ( rdot( BMPNo, vd.x, vd.y))
				dir = 0;
			else	dir = 1;
			break;
		    case 1:
			vd.x++;
			if ( rdot( BMPNo, vd.x, vd.y))
				dir = 0;
			else if ( rdot( BMPNo, vd.x, vd.y-1))
				dir = 1;
			else	dir = 2;
			break;
		    case 2:
			vd.y--;
			if (ReverseRight( wkBMP, vd.x, vd.y))
				return( -1);
			if ( rdot( BMPNo, vd.x, vd.y-1))
				dir = 1;
			else if ( rdot( BMPNo, vd.x-1, vd.y-1))
				dir = 2;
			else	dir = 3;
			break;
		    case 3:
			vd.x--;
			if ( rdot( BMPNo, vd.x-1, vd.y-1))
				dir = 2;
			else if ( rdot( BMPNo, vd.x-1, vd.y))
				dir = 3;
			else	dir = 0;
			break;
		}

	} while( vd.x!=orgx || vd.y != orgy);
	VDClose(lsthdl);
	return( 0);
}
/***********************************************************************
 *	Contribute Outside Contour
 */
/* */	static int
/* */	ContributeInside( int BMPNo, int wkBMP, struct vecdata *org, int lsthdl)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
	int	orgx, orgy;
struct vecdata	vd;
	int	dir;

	orgx = org->x;
	orgy = org->y;
	vd = *org;
	dir = 1;
	do {
		if (VDSetData( lsthdl, &vd))
			return(-1);
		switch( dir) {
		    case 0:
			if (ReverseRight( wkBMP, vd.x, vd.y))
				return( -1);
			vd.y++;
			if ( rdot( BMPNo, vd.x-1, vd.y)==0)	/* right */
				dir = 3;
			else if ( rdot( BMPNo, vd.x, vd.y)==0) /* left */
				dir = 0;
			else	dir = 1;
			break;
		    case 1:
			vd.x++;
			if ( rdot( BMPNo, vd.x, vd.y)==0) /* right */
				dir = 0;
			else if ( rdot( BMPNo, vd.x, vd.y-1)==0) /* left */
				dir = 1;
			else	dir = 2;
			break;
		    case 2:
			vd.y--;
			if (ReverseRight( wkBMP, vd.x, vd.y))
				return( -1);
			if ( rdot( BMPNo, vd.x, vd.y-1)==0)
				dir = 1;
			else if ( rdot( BMPNo, vd.x-1, vd.y-1)==0)
				dir = 2;
			else	dir = 3;
			break;
		    case 3:
			vd.x--;
			if ( rdot( BMPNo, vd.x-1, vd.y-1)==0)
				dir = 2;
			else if ( rdot( BMPNo, vd.x-1, vd.y)==0)
				dir = 3;
			else	dir = 0;
			break;
		}
	} while( vd.x!=orgx || vd.y != orgy);
	VDClose(lsthdl);

	return( 0);
}
/***********************************************************************
 *	Read Dot
 */
/* */	int
/* */	rdot( int BMP, int x, int y)
/*
 *	returns : 0, nonzero
 ***********************************************************************/
{
	unsigned char	*radd;
	int	rbit;
	int	onoff;

	if ( x < 0 || y < 0 || x>=BMPTbl[BMP].width ||y>=BMPTbl[BMP].depth)
		return( 0);

	radd = BMPTbl[BMP].buf + BMPTbl[BMP].bWid*y + x/8;
	rbit = x % 8;
	onoff = (int)(wmaskB[rbit] & *radd);
	return  onoff;
}
/***********************************************************************
 *	Write Dot
 */
/* */	void
/* */	wdot( int BMP, int x, int y, int onoff)
/*
 *	returns : none
 ***********************************************************************/
{
	unsigned char	*radd;
	int	rbit;

	if ( x < 0 || y < 0 || x>=BMPTbl[BMP].width ||y>=BMPTbl[BMP].depth)
		return;

	radd = BMPTbl[BMP].buf + BMPTbl[BMP].bWid*y + x/8;
	rbit = x % 8;

	if ( onoff)	*radd |= wmaskB[rbit];
	else		*radd &= ~wmaskB[rbit];
	return;
}
/***********************************************************************
 *	Reverse right side ( Edge fill method)
 */
/* */	int
/* */	ReverseRight( int BMPNo, int x, int y)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
	int	rb;
	int	bitp;
unsigned char	*wp;

	if ( BMPNo < 0 || BMPNo >= BMPMAX)
		return 0;
	if ( x < 0 || x >= BMPTbl[BMPNo].width
	 || y < 0 || y >= BMPTbl[BMPNo].depth)
		return 0;
	rb = BMPTbl[BMPNo].bWid - x/8 -1;
	bitp = x%8;
	wp = BMPTbl[BMPNo].buf + y*BMPTbl[BMPNo].bWid + x/8;

	/* First Byte */
	*wp ^= rightmask[bitp];

	/* to right limit */
	while( rb-->0) {
		wp++;
		*wp = (unsigned char)~(*wp);
	}
	return ( 0);
}
/***********************************************************************
 *	Copy Buffer
 */
/* */	static void
/* */	cpybuf( int src, int dst)
/*
 *	returns : none
 ***********************************************************************/
{
	int	siz;

	if ( src < 0 || src >= BMPMAX)
		return;
	if ( dst < 0 || dst >= BMPMAX)
		return;
	siz = BMPTbl[src].bWid * BMPTbl[src].depth;
	memcpy( BMPTbl[dst].buf, BMPTbl[src].buf, siz);
}
/***********************************************************************
 *	Reverse bitmap
 */
/* */	int
/* */	BMPReverse( int bmpNo)
/*
 *	returns : none
 ***********************************************************************/
{
	int	siz;
	char	*buf;

	if ( bmpNo < 0 || bmpNo >= BMPMAX)
		return -1;
	else if (BMPTbl[bmpNo].buf==(unsigned char *)0)
		return -1;
	else {
		siz = BMPTbl[bmpNo].bWid * BMPTbl[bmpNo].depth;
		buf = (char *)BMPTbl[bmpNo].buf;
		while ( siz-->0) {
			*buf = (char)~*buf;
			buf++;
		}
			
	}
	return 0;
}
/***********************************************************************
 *	Clear BMP
 */
/* */	int
/* */	BMPClear( int bmpNo)
/*
 *	returns : 0,-1
 ***********************************************************************/
{
	int	siz;

	if ( bmpNo < 0 || bmpNo >= BMPMAX)
		return -1;
	else if (BMPTbl[bmpNo].buf==(unsigned char *)0)
		return -1;
	siz = BMPTbl[bmpNo].bWid * BMPTbl[bmpNo].depth;
	memset( BMPTbl[bmpNo].buf, 0, siz);
	return 0;
}

/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\blinkdlg.cpp ===
/**************************************************/
/*                                                */
/*                                                */
/*      Chinese IME Batch Mode                    */
/*              (Dialogbox)                       */
/*                                                */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include    "stdafx.h"
#include    "eudcedit.h"
#if 1 // use function in imeblink.c!
#include    "imeblink.h"
#endif
#include    "blinkdlg.h"
#include    "util.h"

#define     SIGN_CWIN       0x4E495743      /* Sign of CWin */
#define     SIGN__TBL       0x4C42545F      /* Sign of IME Table */

#if 0 // move to imeblink.c!

#define     UNICODE_CP      1200

#define     BIG5_CP         950
#define     ALT_BIG5_CP     938
#define     GB2312_CP       936

typedef struct _tagCOUNTRYSETTING {
    UINT    uCodePage;
    LPCTSTR szCodePage;
} COUNTRYSETTING;

static const COUNTRYSETTING sCountry[] = {
    {
        BIG5_CP, TEXT("BIG5")
    }
    , {
        ALT_BIG5_CP, TEXT("BIG5")
    }
#if defined(UNICODE)
    , {
        UNICODE_CP, TEXT("UNICODE")
    }
#endif
    , {
        GB2312_CP, TEXT("GB2312")
    }
};

#endif // move to imeblink.c!

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/****************************************/
/*                                      */
/*            Constructor               */
/*                                      */
/****************************************/
CBLinkDlg::CBLinkDlg(   CWnd *pParent)
    : CDialog( CBLinkDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CBLinkDlg)
    //}}AFX_DATA_INIT
}

/****************************************/
/*                                      */
/*      MESSAGE "WM_INITDIALOG"         */
/*                                      */
/****************************************/
BOOL
CBLinkDlg::OnInitDialog()
{
    CString DlgTtl;
    CDialog::OnInitDialog();

//  Increment contexthelp mark "?" in dialog caption.
//    LONG WindowStyle = GetWindowLong( this->GetSafeHwnd(), GWL_EXSTYLE);
//    WindowStyle |= WS_EX_CONTEXTHELP;
//    SetWindowLong( this->GetSafeHwnd(), GWL_EXSTYLE, WindowStyle);

//  Set dialog title name.
    DlgTtl.LoadString( IDS_BATCHLNK_DLGTITLE);
    this->SetWindowText( DlgTtl);

    return TRUE;
}

/****************************************/
/*                                      */
/*      COMMAND "BROWSE"                */
/*                                      */
/****************************************/
void
CBLinkDlg::OnBrowsetable()
{
    OPENFILENAME    ofn;
    CString         DlgTtl, DlgMsg;
    CString         sFilter;
    TCHAR           chReplace;
    TCHAR           szFilter[64];
    TCHAR           szFileName[MAX_PATH];
    TCHAR           szDirName[MAX_PATH];
    TCHAR           szTitleName[MAX_PATH];

//  Check size of IME batch table structure
    if( sizeof( USRDICIMHDR) != 256){
        OutputMessageBox( this->GetSafeHwnd(),
            IDS_INTERNAL_TITLE,
            IDS_INTERNAL_MSG, TRUE);
        return;
    }

//  Set filter of file( from string table)
    GetStringRes(szFilter, IDS_BATCHIME_FILTER);
    int StringLength = lstrlen( szFilter);

    chReplace = szFilter[StringLength-1];
    for( int i = 0; szFilter[i]; i++){
        if( szFilter[i] == chReplace)
            szFilter[i] = '\0';
    }

    GetSystemWindowsDirectory( szDirName, sizeof(szDirName)/sizeof(TCHAR));
    lstrcpy( szFileName, TEXT("*.TBL"));
    DlgTtl.LoadString( IDS_BROWSETABLE_DLGTITLE);

//  Set data in structure of OPENFILENAME
    ofn.lStructSize = sizeof( OPENFILENAME);
    ofn.hwndOwner = this->GetSafeHwnd();
    ofn.lpstrFilter = szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFileTitle = szTitleName;
    ofn.nMaxFileTitle = sizeof( szTitleName) / sizeof(TCHAR);
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = sizeof( szFileName) / sizeof(TCHAR);
    ofn.lpstrInitialDir = szDirName;
    ofn.Flags = OFN_HIDEREADONLY | OFN_NOCHANGEDIR
        | OFN_CREATEPROMPT | OFN_PATHMUSTEXIST;
    ofn.lpstrDefExt = NULL;
    ofn.lpstrTitle = DlgTtl;

    if( !GetOpenFileName( &ofn))
        return;

    this->SetDlgItemText( IDC_IMETABLE, ofn.lpstrFile);
    CWnd *cWnd = GetDlgItem( IDOK);
    GotoDlgCtrl( cWnd);
}

/****************************************/
/*                                      */
/*      COMMAND "IDOK"                  */
/*                                      */
/****************************************/
void
CBLinkDlg::OnOK()
{
    if( !RegistStringTable())
        return;

    CDialog::OnOK();
}

/****************************************/
/*                                      */
/*      Register reading string         */
/*                                      */
/****************************************/
BOOL
CBLinkDlg::RegistStringTable()
{
    LPUSRDICIMHDR lpIsvUsrDic;
    HANDLE        hIsvUsrDicFile, hIsvUsrDic;
    DWORD         dwSize, dwFileSize;
    BOOL          stFunc;
    TCHAR         szTableFile[MAX_PATH];
    TCHAR         szFileName[MAX_PATH];
    CString       DlgMsg, DlgTtl;

    this->GetDlgItemText( IDC_IMETABLE, szTableFile, sizeof( szTableFile)/sizeof(TCHAR));
    lstrcpy( szFileName, TEXT("*.TBL"));

//  Create file( to read)
    hIsvUsrDicFile = CreateFile( szTableFile, GENERIC_READ, 0, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if( hIsvUsrDicFile == INVALID_HANDLE_VALUE){
        DlgTtl.LoadString( IDS_NOTOPEN_TITLE);
        DlgMsg.LoadString( IDS_NOTOPEN_MSG);
        this->MessageBox( DlgMsg, DlgTtl, MB_OK | MB_ICONHAND |
            MB_TASKMODAL | MB_TOPMOST);
        return FALSE;
    }

#if 0
    for( i = 0; i < sizeof( szFileName); i++){
        if( szFileName[i] == '\\'){
            szFileName[i] = ' ';
        }
    }
#endif

//  Create file mapping( read only)
    hIsvUsrDic = CreateFileMapping((HANDLE)hIsvUsrDicFile, NULL,
        PAGE_READONLY, 0, 0, NULL);
    if( !hIsvUsrDic){
        stFunc = FALSE;
        DlgTtl.LoadString( IDS_NOTOPEN_TITLE);
        DlgMsg.LoadString( IDS_NOTOPEN_MSG);
        this->MessageBox( DlgMsg, DlgTtl, MB_OK | MB_ICONHAND |
            MB_TASKMODAL | MB_TOPMOST);
        goto BatchCloseUsrDicFile;
    }

//  Set view file
    lpIsvUsrDic = (LPUSRDICIMHDR)MapViewOfFile( hIsvUsrDic,
        FILE_MAP_READ, 0, 0, 0);
    if( !lpIsvUsrDic){
        stFunc = FALSE;
        DlgTtl.LoadString( IDS_NOTOPEN_TITLE);
        DlgMsg.LoadString( IDS_NOTOPEN_MSG);
        this->MessageBox( DlgMsg, DlgTtl, MB_OK | MB_ICONHAND |
            MB_TASKMODAL | MB_TOPMOST);
        goto BatchCloseUsrDic;
    }
		
    dwSize = lpIsvUsrDic->ulTableCount * ( sizeof(WORD) + sizeof(WORD)
        + lpIsvUsrDic->cMethodKeySize) + 256;
    dwFileSize = GetFileSize( hIsvUsrDicFile, (LPDWORD)NULL);

#if 0
    dwSize = dwFileSize;
#endif

//  Check table file data
    if( dwSize != dwFileSize){
        stFunc = FALSE;
        OutputMessageBox( this->GetSafeHwnd(),
            IDS_FILESIZE_MSGTITLE,
            IDS_FILESIZE_MSG, TRUE);
    }else if( lpIsvUsrDic->uHeaderSize != 256){
        stFunc = FALSE;
        OutputMessageBox( this->GetSafeHwnd(),
            IDS_FILEHEADER_MSGTITLE,
            IDS_FILEHEADER_MSG, TRUE);
    }else if( lpIsvUsrDic->uInfoSize != 13){
        stFunc = FALSE;
        OutputMessageBox( this->GetSafeHwnd(),
            IDS_INMETHOD_MSGTITLE,
            IDS_INMETHOD_MSG, TRUE);
    }else if( CodePageInfo( lpIsvUsrDic->idCP) == -1){
        stFunc = FALSE;
        OutputMessageBox( this->GetSafeHwnd(),
            IDS_CODEPAGE_MSGTITLE,
            IDS_CODEPAGE_MSG, TRUE);
    }else if( *(DWORD UNALIGNED *)lpIsvUsrDic->idUserCharInfoSign != SIGN_CWIN){
        stFunc = FALSE;
        OutputMessageBox( this->GetSafeHwnd(),
            IDS_SIGN_MSGTITLE,
            IDS_SIGN_MSG, TRUE);
    }else if( *(DWORD UNALIGNED *)((LPBYTE)lpIsvUsrDic->idUserCharInfoSign +
        sizeof(DWORD)) != SIGN__TBL){
        stFunc = FALSE;
        OutputMessageBox( this->GetSafeHwnd(),
            IDS_SIGN_MSGTITLE,
            IDS_SIGN_MSG, TRUE);
    }else{
        stFunc = TRUE;
        if( !RegisterTable( this->GetSafeHwnd(),
            lpIsvUsrDic, dwFileSize, lpIsvUsrDic->idCP)){
            OutputMessageBox( this->GetSafeHwnd(),
                IDS_UNMATCHED_TITLE,
                IDS_UNMATCHED_MSG, TRUE);
            stFunc = FALSE;
        }
    }
    UnmapViewOfFile( lpIsvUsrDic);
					
BatchCloseUsrDic:
    CloseHandle( hIsvUsrDic);

BatchCloseUsrDicFile:
    CloseHandle( hIsvUsrDicFile);

    return stFunc;
}

#if 0 // move to imeblink.c!

/****************************************/
/*                                      */
/*      Register reading string         */
/*                                      */
/****************************************/
HKL
CBLinkDlg::RegisterTable(
HWND            hWnd,
LPUSRDICIMHDR   lpIsvUsrDic,
DWORD           dwFileSize,
UINT            uCodePage)
{
    HKL     hKL;
    DWORD   i;
    LPBYTE  lpCurr, lpEnd;
    BOOL    fRet;
    TCHAR   szStr[16];
    WORD    wInternalCode[256];
    WORD    wAltInternalCode[256];

#ifdef UNICODE
    if (uCodePage == UNICODE_CP) {
        LPUNATSTR lpszMethodName;

        lpszMethodName = (LPUNATSTR)lpIsvUsrDic->achMethodName;

        for (i = 0; i < sizeof(lpIsvUsrDic->achMethodName) / sizeof(TCHAR); i++) {
            szStr[i] = *lpszMethodName++;
        }

        szStr[i] = '\0';
    } else {
        UINT uLen;

        uLen = MultiByteToWideChar(uCodePage, MB_PRECOMPOSED,
            (LPCSTR)lpIsvUsrDic->achMethodName,
            sizeof(lpIsvUsrDic->achMethodName),
            szStr,
            sizeof(szStr) / sizeof(TCHAR));
        szStr[uLen] = '\0';
    }
#else
    for( i = 0; i < sizeof( lpIsvUsrDic->achMethodName); i++){
        szStr[i] = lpIsvUsrDic->achMethodName[i];
    }

    szStr[i] = '\0';
#endif

    hKL = MatchImeName( szStr);

    if( !hKL) return (hKL);

    for( i = 0; i < sizeof(wInternalCode) / sizeof(WORD); i++) {
        LRESULT lRet;

        lRet = ImmEscape(hKL, (HIMC)NULL,
            IME_ESC_SEQUENCE_TO_INTERNAL, &i);

        if (HIWORD(lRet) == 0xFFFF) {
            // This is caused by sign extent in Win9x in the return value of
            // ImmEscape, it causes an invalid internal code.
            wAltInternalCode[i] = 0;
        } else {
            wAltInternalCode[i] = HIWORD(lRet);
        }


#ifndef UNICODE
        if( wAltInternalCode[i] > 0xFF) {
            wAltInternalCode[i] = LOBYTE(wAltInternalCode[i]) << 8 |
            HIBYTE(wAltInternalCode[i]);
        }

        if( wInternalCode[i] > 0xFF) {
            wInternalCode[i] = LOBYTE(wInternalCode[i]) << 8 |
            HIBYTE(wInternalCode[i]);
        }
#endif
    }

    lpCurr = (LPBYTE)(lpIsvUsrDic + 1) + sizeof(WORD);
    lpEnd = (LPBYTE)lpIsvUsrDic + dwFileSize;

    for (; lpCurr < lpEnd; lpCurr += sizeof(WORD) + lpIsvUsrDic->cMethodKeySize + sizeof(WORD)) {
        int j;

        *(LPDWORD)szStr = 0;

#ifdef UNICODE
        if (uCodePage == UNICODE_CP) {
            szStr[0] = *(LPUNATSTR)lpCurr;
        } else {
            CHAR szMultiByte[4];

            szMultiByte[0] = HIBYTE(*(LPUNASTR)lpCurr);
            szMultiByte[1] = LOBYTE(*(LPUNASTR)lpCurr);


            MultiByteToWideChar(uCodePage, MB_PRECOMPOSED,
                szMultiByte, 2, szStr, 2);
        }
#else
        szStr[1] = *lpCurr;
        szStr[0] = *(lpCurr + 1);
#endif

        for (i = 0, j = 0; i < lpIsvUsrDic->cMethodKeySize; i++) {
            if (!wAltInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)]) {
            } else if (wAltInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)] < 0xFF) {
                *(LPTSTR)&szStr[4 + j] = (TCHAR)
                    wAltInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)];
                j += sizeof(TCHAR) / sizeof(TCHAR);
            } else {
                *(LPWSTR)&szStr[4 + j] = (WCHAR)
                    wAltInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)];
                j += sizeof(WCHAR) / sizeof(TCHAR);
            }

            if (wInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)] < 0xFF) {
                *(LPTSTR)&szStr[4 + j] = (TCHAR)
                    wInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)];
                j += sizeof(TCHAR) / sizeof(TCHAR);
            } else {
                *(LPWSTR)&szStr[4 + j] = (WCHAR)
                    wInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)];
                j += sizeof(WCHAR) / sizeof(TCHAR);
            }
        }

        szStr[4 + j] = szStr[4 + j + 1] = szStr[4 + j + 2] = '\0';

        fRet = ImmRegisterWord(hKL, &szStr[4], IME_REGWORD_STYLE_EUDC,
            szStr);
    }

    return (hKL);
}

/****************************************/
/*                                      */
/*      Get keyboard layout handle      */
/*                                      */
/****************************************/
HKL
CBLinkDlg::MatchImeName(
LPCTSTR szStr)
{
    TCHAR   szImeName[16];
    int     nLayout;
    HKL     hKL;
    HGLOBAL hMem;
    HKL FAR *lpMem;
    int i;

    nLayout = GetKeyboardLayoutList( 0, NULL);

    hMem = GlobalAlloc( GHND, sizeof(HKL) * nLayout);
    if( !hMem)  return NULL;

    lpMem = (HKL FAR *)GlobalLock( hMem);
    if( !lpMem){
        GlobalFree( hMem);
        return NULL;
    }

    GetKeyboardLayoutList( nLayout, lpMem);

    for( i = 0; i < nLayout; i++){
        BOOL fRet;

        hKL = *(lpMem + i);
        for( j = 0; j < uLen; j++){
            szImeName[j] = '\0';
        }
        fRet = ImmEscape(hKL, (HIMC)NULL, IME_ESC_IME_NAME, szImeName);
        if( !fRet)  continue;

        if(lstrcmp(szStr, szImeName) == 0){
            goto MatchOvr;
        }
    }

    hKL = NULL;

MatchOvr:
    GlobalUnlock( hMem);
    GlobalFree( hMem);

    return( hKL);
}

/****************************************/
/*                                      */
/*      CodePage Info                   */
/*                                      */
/****************************************/
int
CBLinkDlg::CodePageInfo(
    UINT uCodePage)
{
    int i;

    for (i = 0; i < sizeof(sCountry) / sizeof(COUNTRYSETTING); i++) {
        if (sCountry[i].uCodePage == uCodePage) {
            return(i);
        }
    }

    return (-1);
}

#endif // move to imeblink.c!

static DWORD    aIds[] =
{
    IDC_STATICIMETBL, IDH_EUDC_BLINK_EDITTBL,
    IDC_IMETABLE, IDH_EUDC_BLINK_EDITTBL,
    IDC_BROWSETABLE, IDH_EUDC_BROWSE,
    0, 0
};

/****************************************/
/*                                      */
/*      Window Procedure                */
/*                                      */
/****************************************/		
LRESULT
CBLinkDlg::WindowProc(
UINT    message,
WPARAM  wParam,
LPARAM  lParam)
{/*
    if( message == WM_HELP){
        ::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
            HelpPath, HELP_WM_HELP, (DWORD_PTR)(LPDWORD)aIds);
        return(0);
    }
    if( message == WM_CONTEXTMENU){
        ::WinHelp((HWND)wParam, HelpPath,
            HELP_CONTEXTMENU, (DWORD_PTR)(LPDWORD)aIds);
        return(0);
    }
  */
    return CDialog::WindowProc(message, wParam, lParam);
}

BEGIN_MESSAGE_MAP(CBLinkDlg, CDialog)
    //{{AFX_MSG_MAP(CBLinkDlg)
    ON_BN_CLICKED(IDC_BROWSETABLE, OnBrowsetable)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\common\ll.h ===
/*****************************************************************************
*                                                                            *
*  LL.H                                                                      *
*                                                                            *
*  Copyright (C) Microsoft Corporation 1989.                                 *
*  All Rights reserved.                                                      *
*                                                                            *
******************************************************************************
*                                                                            *
*  Program Description: Exports link list functions                          *
*                                                                            *
******************************************************************************
*                                                                            *
*  Revision History:                                                         *
*                                                                            *
*                                                                            *
******************************************************************************
*                                                                            *
*  Known Bugs: None                                                          *
*                                                                            *
*                                                                            *
*                                                                            *
*****************************************************************************/

/*****************************************************************************
*                                                                            *
*                               Defines                                      *
*                                                                            *
*****************************************************************************/

#define nilHAND  (HANDLE)NULL
#define nilLL   nilHAND
#define nilHLLN nilHAND


/*****************************************************************************
*                                                                            *
*                               Typedefs                                     *
*                                                                            *
*****************************************************************************/

typedef HANDLE  LL;
typedef HANDLE  HLLN;


/*******************
**
** Name:       LLCreate
**
** Purpose:    Creates a link list
**
** Arguments:  None.
**
** Returns:    Link list.  nilLL is returned if an error occurred.
**
*******************/

LL FAR APIENTRY LLCreate(VOID);


/*******************
**
** Name:       InsertLL
**
** Purpose:    Inserts a new node at the head of the linked list
**
** Arguments:  ll     - link list
**             vpData - pointer to data to be associated with
**             c      - count of the bytes pointed to by vpData
**
** Returns:    TRUE iff insertion is successful.
**
*******************/

BOOL FAR APIENTRY InsertLL(LL, VOID FAR *, LONG);


/*******************
**
** Name:       WalkLL
**
** Purpose:    Mechanism for walking the nodes in the linked list
**
** Arguments:  ll   - linked list
**             hlln - handle to a linked list node
**
** Returns:    a handle to a link list node or NIL_HLLN if at the
**             end of the list (or an error).
**
** Notes:      To get the first node, pass NIL_HLLN as the hlln - further
**             calls should use the HLLN returned by this function.
**
*******************/

HLLN FAR APIENTRY WalkLL(LL, HLLN);


/*******************
**
** Name:       QVLockHLLN
**
** Purpose:    Locks a LL node returning a pointer to the data
**
** Arguments:  hlln - handle to a linked list node
**
** Returns:    pointer to data or NULL if an error occurred
**
*******************/

VOID FAR * FAR QVLockHLLN(HLLN);


/*******************
**
** Name:       QVUnlockHLLN
**
** Purpose:    Unlocks a LL node
**
** Arguments:  hlln - handle to a link list node
**
** Returns:    TRUE iff the handle is successfully locked.
**
*******************/

VOID FAR UnlockHLLN(HLLN);


/*******************
**
** Name:       DestroyLL
**
** Purpose:    Deletes a LL and all of its contents
**
** Arguments:  ll - linked list
**
** Returns:    Nothing.
**
*******************/

VOID FAR APIENTRY DestroyLL(LL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\code.cpp ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//

#include	"stdafx.h"
#include	"eudcedit.h"
#ifdef BUILD_ON_WINNT
#include    "extfunc.h"
#endif // BUILD_ON_WINNT
#pragma		pack(2)


#define		SEGMAX	256
#define		EUDCCODEBASE	((unsigned short)0xe000)


static int init = 0;
static unsigned short	segStart[SEGMAX];
static unsigned short	segEnd[SEGMAX];
static unsigned short	segUni[SEGMAX];
static int	segCnt = 0;
static int	recCnt = 0;
static void
setseg( unsigned short segH, unsigned short segLS, unsigned short segLE)
{
	unsigned short	cCnt;

	if ( segCnt >= SEGMAX)
		return;
	cCnt = segLE - segLS + 1;
	segStart[segCnt] = (segH<<8)+segLS;
	segEnd[segCnt] = (segH<<8)+segLE;
	segUni[segCnt]  = EUDCCODEBASE	+recCnt;
	recCnt += cCnt;
	segCnt++;
}
void
makeUniCodeTbl ( )
{
	int	base;
	unsigned short	slow, elow;
	int	n;
	int	nlow;
	unsigned short high;
	COUNTRYINFO	*cInfo;

    //we don't need an unicode table if we only have unicode
    if (CountryInfo.bOnlyUnicode) 
        return;

	if ( init)	return ;
	cInfo = &CountryInfo;
	base = 0;
	segCnt = recCnt = 0;
	for ( n=0; n < cInfo->nRange - 1; n++) {

#ifdef BUILD_ON_WINNT
        /* CHS needs to dynamically calculate trailbyte range for each 
         * EUDC select range.
         */
        if (cInfo->LangID == EUDC_CHS)
            CorrectTrailByteRange(n);
#endif // BUILD_ON_WINNT

		for ( high = cInfo->sLeadByte[n]; high <=cInfo->eLeadByte[n]; 
                                                        high++){
		    if ( high == cInfo->sLeadByte[n])
			    slow = cInfo->sRange[n] & 0xff;
		    else
			    slow = cInfo->sTralByte[0];
		    if ( high ==cInfo->eLeadByte[n])
			    elow = cInfo->eRange[n] & 0xff;
		    else
			    elow = cInfo->eTralByte[cInfo->nTralByte-1];

		    for ( nlow = 0; nlow < cInfo->nTralByte; nlow++) {
			if (  slow >= cInfo->sTralByte[nlow]
					&& slow <= cInfo->eTralByte[nlow]) {
				if ( elow <=  cInfo->eTralByte[nlow] )
					setseg( high, slow, elow);
				else
				    setseg( high, slow, cInfo->eTralByte[nlow]);
			}
			else if ( slow < cInfo->sTralByte[nlow]
				&& elow >= cInfo->sTralByte[nlow]) {
				if ( elow <=  cInfo->eTralByte[nlow] )
				    setseg( high, cInfo->sTralByte[nlow], elow);
				else
				    setseg( high, cInfo->sTralByte[nlow],
						cInfo->sTralByte[nlow]);
			}
		    }
		}
	}
	init = 1;
}
unsigned short
sjisToUniEUDC( unsigned short code)
{
	int	seg;
	unsigned short	ofs;

	for ( seg = 0; seg < segCnt; seg++) {
		if ( code <= segEnd[seg]) {
			if ( segStart[seg] <= code) {
				ofs = code - segStart[seg];
				return segUni[seg]+ofs;
			}
		}
	}
	return (unsigned short)0xffff;
}
unsigned short
getMaxUniCode( )
{
		USHORT ansiMax;
		if (CountryInfo.bOnlyUnicode)
			ansiMax = 0;
		else
			ansiMax = segUni[segCnt-1] + (segEnd[segCnt-1] - segStart[segCnt-1]);
        return max(ansiMax, CountryInfo.eRange[CountryInfo.nRange-1]);
}


/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\assocdlg.h ===
/**************************************************/
/*					                              */
/*					                              */
/*	Associations Property		                  */
/*		(Dialog)		                          */
/*					                              */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

typedef struct _tagASSOCIATIONREG{
	TCHAR	szFaceName[LF_FACESIZE];
	TCHAR	szFileName[MAX_PATH];
	TCHAR	szFileTitle[MAX_PATH];
	BOOL	FontTypeFlg;	// TRUE:TRUETYPE, FALSE:WIFE FONT
	BOOL	UpdateFlg;
} ASSOCIATIONREG;

typedef ASSOCIATIONREG FAR *LPASSOCIATIONREG;

class CRegistListBox : public CListBox
{
private:
	int	ItemHeight;

public:
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMIS);
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);
	virtual int  CompareItem(LPCOMPAREITEMSTRUCT lpCIS);
};

class CAssocDlg : public CDialog
{
public:
	CAssocDlg(CWnd* pParent = NULL);
	BOOL    InitSystemFontAssoc();

  //{{AFX_DATA(CAssocDlg)
	enum { IDD = IDD_ASSOCIATION };
	//}}AFX_DATA

private:
	BOOL 	SetAssociationFontType();
	BOOL	HandleImportWin95(LPTSTR TTFPath, LPTSTR BMPPath, int Idx);
  CWnd * m_pParent;

protected:
	CRegistListBox	m_RegListBox;

	//{{AFX_VIRTUAL(CAssocDlg)
	protected:
	virtual BOOL OnInitDialog();
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

protected:

	// Generated message map functions
	//{{AFX_MSG(CAssocDlg)
	afx_msg void OnDblclkRegistlist();
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnModify();
	afx_msg void OnRemove();
	afx_msg void OnRadioDbcs();
	afx_msg void OnRadioSystem();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\dataif.cpp ===
/*
 *	Bitmap and TTF control 
 *
 *  Copyright (c) 1997-1999 Microsoft Corporation.
 */

#include	"stdafx.h"
#include	"eudcedit.h"


#pragma		pack(2)


#include	"vdata.h"
#include	"ttfstruc.h"
#include	"extfunc.h"

static void reverseBMP( unsigned char *mem, int siz);
static int makeNullGlyph( int lstH, struct BBX *bbx, short uPEm);

#define		OUTLSTH		0
#define		TMPLSTH		1
#define		NGLYPHLSTH	3
static int init = 0;
static int	inputSiz = 0;
/***********************************************************************
 *	initialize
 */
/* */	int
/* */	OInit( )
/*
 *	returns 0 , -1 (Failed)
 ***********************************************************************/
{
	if ( init)
		return 0;


	if (VDInit())
		return -1;
	else	{
		init = 1;
		return 0;
	}
}
/***********************************************************************
 *	initialize
 */
/* */	int
/* */	OTerm( )
/*
 *	returns 0 
 ***********************************************************************/
{
	if ( init) {
		init = 0;
		VDTerm();
	}
	return 0;
}
/***********************************************************************
 *	Make Outline
 */
/* */	int
/* */	OMakeOutline( 
/* */		unsigned char *buf, 
/* */		int	siz,
/* */		int	level)
/*
 *	returns : 0< : list handle, -1 ( error)
 ***********************************************************************/
{
	int	pb1, pb2, pb3;
struct SMOOTHPRM	prm;
	unsigned char	*tmp1, *tmp2;
	int	msiz;

	inputSiz = siz;
	reverseBMP( buf, ((siz+15)/16*2*siz));
	if ( init==0)
		if (OInit())	return -1;

	tmp1 = tmp2 = (unsigned char *)0;
	BMPInit();

	msiz = (siz+15)/16*2 * siz;

	if ( (tmp1 = (unsigned char *)malloc( msiz))==(unsigned char *)0)
		goto	ERET;
	if ( (tmp2 = (unsigned char *)malloc( msiz))==(unsigned char *)0)
		goto	ERET;
	if ( (pb1 = BMPDefine( buf, siz, siz))<0)
		goto	ERET;

	if ( (pb2 = BMPDefine( tmp1, siz, siz))<0)
		goto	ERET;
	if ( (pb3 = BMPDefine( tmp2, siz, siz))<0)
		goto	ERET;

	VDNew( OUTLSTH);
	if (BMPMkCont( pb1, pb2, pb3, OUTLSTH)<0)
		goto	ERET;
	prm.SmoothLevel = level;
	prm.UseConic = 1;
	/* ͂̂S{ŏ_ȉSrbgŌvZ */
	if (SmoothVector( OUTLSTH, TMPLSTH, siz, siz,siz*4, &prm, 16))
		goto	ERET;

	VDCopy( OUTLSTH, TMPLSTH);
	RemoveFp( TMPLSTH, siz*4, 16);

	free( tmp1);
	free( tmp2);
	BMPFreDef( pb1);
	BMPFreDef( pb2);
	BMPFreDef( pb3);
	reverseBMP( buf, ((siz+15)/16*2*siz));

	/* Ԃ̂́A͂̂S{ɂ */
	return TMPLSTH;
ERET:
	if ( tmp1)	free( tmp1);	
	if ( tmp2)	free( tmp2);	
	BMPFreDef( pb1);
	BMPFreDef( pb2);
	BMPFreDef( pb3);
	return -1;
}
/***********************************************************************
 *	check File exist
 */
/* */	int
/* */	OExistTTF( TCHAR	*path)
/*
 *	returns : 0, 1 (exist)
 ***********************************************************************/
{
	HANDLE	fh;
	fh = CreateFile(path,
					GENERIC_READ,
					FILE_SHARE_READ,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fh == INVALID_HANDLE_VALUE)	return 0;
	CloseHandle( fh);
	return	1;
}
#ifdef BUILD_ON_WINNT
int OExistUserFont( TCHAR	*path)
{
	HANDLE	fh;
	fh = CreateFile(path,
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fh == INVALID_HANDLE_VALUE)
		return 0;
	CloseHandle( fh);
	return	1;
}
#endif // BUILD_ON_WINNT
static void
setWIFEBBX( struct BBX *bbx, short *uPEm)
{
	
	bbx->xMin = 0;
	bbx->xMax = 255;
	bbx->yMin = 0;
	bbx->yMax = 255;
	*uPEm = 256;
}
/***********************************************************************
 *	Create EUDC TTF
 */
/* */	int
/* */	OCreateTTF( 
/* */		HDC	hDC,
/* */		TCHAR	*path,
/* */		int	fontType)
/* 		
 *	returns : 0, -1
 ***********************************************************************/
{
struct BBX	bbx;
	short	uPEm;

	if ( fontType)
		setWIFEBBX( &bbx, &uPEm);
	else {
		if (TTFGetBBX( hDC, &bbx, &uPEm))
			goto	ERET;
	}
	makeNullGlyph( NGLYPHLSTH, &bbx, uPEm);
	if (TTFCreate( hDC, path, &bbx,  NGLYPHLSTH, fontType))
		goto	ERET;
	return 0;
ERET:
	return -1;
}
/***********************************************************************
 *	Output to EUDC TTF
 */
/* */	int
/* */	OOutTTF( 
/* */		HDC	hDC,
/* */		TCHAR *path,	/* TrueType Path */
/* */		unsigned short	code,
/* */       BOOL bUnicode)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
	int	mesh;
struct BBX	bbx;
	short	uPEm;
	int	sts;

	if (TTFGetEUDCBBX( path, &bbx, &uPEm))
		goto	ERET;

	mesh = uPEm;
	/* OUTLSTH mesh is inputBitmapSiz*4 , and made into ufp 4bit*/
	/* ufp : under Fixed Point */
	ConvMesh( OUTLSTH, inputSiz*4, mesh);
	RemoveFp( OUTLSTH,  mesh, 16);

	if (toTTFFrame( OUTLSTH, &bbx))
		goto	ERET;
    if (!bUnicode)
    {
	    code = sjisToUniEUDC( code);
    }
	if ( sts = TTFAddEUDCChar( path,code, &bbx,  OUTLSTH)) {
    if (sts == -3) // tte file is being used by another process.
      return -3;
		if ( TTFLastError()==-2)
			return -2;
		else	return -1;
	}
	return 0;
ERET:
	return -1;
}
static void
smtoi( unsigned short *s)
{
	unsigned short	sval;
	unsigned char	*c;

	c = (unsigned char *)s;
	sval = *c;
	sval<<=8;
	sval += (unsigned short)*c;
}
static void
reverseBMP( unsigned char *mem, int siz)
{
	while ( siz-->0)
		*mem++ ^= (unsigned char)0xff;
}
static int
makeNullGlyph( int lstH, struct BBX *bbx, short uPEm)
{
	int	width;
	int	height;
	int	cx, cy;
	int	dx, dy;
struct vecdata	vd;

	width = height = uPEm;
	cx = bbx->xMin + width/2;
	cy = bbx->yMin + height/2;
	dx = width/20;
	dy = height/20;

	VDNew( lstH);

	vd.atr = 0;
	vd.x = cx - dx;
	vd.y = cy - dy;

	if (VDSetData( lstH, &vd)) goto	ERET;
	vd.y = cy + dy;

	if (VDSetData( lstH, &vd)) goto	ERET;
	vd.x = cx + dx;

	if (VDSetData( lstH, &vd)) goto	ERET;
	vd.y = cy - dy;

	if (VDSetData( lstH, &vd)) goto	ERET;
	if ( VDClose( lstH))	goto	ERET;
	return 0;
ERET:
	return -1;
}
/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\editwnd.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
#include	<afxtempl.h>

class CEditWnd : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CEditWnd)
public:
	CEditWnd();
	int  	SaveEUDCCode(UINT msgBoxType);
	void 	CallCharTextOut();
	void 	SetDuplicateRect( RECT	*rect, POINT *point);
	void 	FlipRotate( int RadioItem);
	void	WriteSelRectBitmap();
	BOOL 	SelectCodes();
	BOOL	UpdateBitmap();
	BOOL 	GetBitmapDirty();
	BOOL	SetBitmapDirty( BOOL Flg);
	BOOL 	Create( LPCTSTR szTitle, LONG Style, 
			RECT EudcWndRect, CMDIFrameWnd* Parent);
	virtual ~CEditWnd();
	void 	CaptionDraw();

private:
	BOOL	MoveClipRect();
	void	RotateFigure90( LPBYTE pBuf1, LPBYTE pBuf2, int bWid, int bHgt);
	void	RotateFigure270( LPBYTE pBuf1, LPBYTE pBuf2,int bWid, int bHgt);
	void	DrawGridLine( CDC *dc);
	void 	DrawMoveRect( CDC *dc);
	void 	DrawStretchRect( CDC *dc);
	BOOL	CurveFittingDraw( CDC *dc);
	void 	CorrectMouseDownPoint( CPoint point);
	void 	CorrectMouseUpPoint( CPoint point);
	void 	DrawClipBmp();
	void 	UndoImageDraw();
	void 	EraseRectangle();
	void 	EraseFreeForm();
	BOOL 	SetFreeForm();
	void 	ZoomPoint( CPoint *DrawPt, int x, int y);
	void 	IllegalRect( PPOINT ptTL, PPOINT ptBR);
	void 	DrawFreeForm( BOOL MouseSts);
	void 	SelectFreeForm( BOOL MouseSts);
	void 	ToolInit( int LRButton);
	void 	ToolTerm();
	void 	DrawRubberBand( BOOL StretchFlag);
	void 	SetMoveRect();
	void 	SetValidRect();
	void 	SetPickRect();
	void	SetClickRect();
	void 	StretchMoveRect();
	void 	DrawRectBmp();
	void 	DrawPoint( CPoint Pt, BOOL bErase);
	void 	DrawToPoint(BOOL bErase);
	void 	InitFlipRotate( CDC *RotateDC, CBitmap *RotateBMP);
	BOOL 	DrawStretchClipToDisp();
	BOOL 	CreateNewBitmap();
	BOOL 	CreateUndoBitmap();
	BOOL 	ClipPickValueInit();
	BOOL	InitEditLogfont();
	BOOL 	ClipImageCopy();
	BOOL 	ClipImageCut();
	int	CheckClipRect( POINT ClickPoint);

private:
	CBitmap	UndoImage;
	CBitmap	CRTDrawBmp;
	CBitmap	ImageBmp;
	CDC	CRTDrawDC;
	CDC	ImageDC;
	BOOL	BitmapDirty;
	BOOL	RectClipFlag;
	BOOL 	UndoBitmapFlag;
	BOOL 	IsCapture;
	BOOL	ButtonFlag;
	UINT	ClipboardFormat;
	int	Ratio;
	int	CheckNum;
	int	BrushWidth;
	CArray<CPoint,CPoint>	m_pointArray;
	CArray<CPoint,CPoint>	m_SelectArray;
	CRgn	FreeRgn;
	CRgn	PickRgn;
	CPoint	ptStart;
	CPoint	ptPrev;
	CPoint	ptEnd;
	CRect	PickRect[8];
	CRect	ClipRect[5];
	CRect	EudcWndRect;

public:
	TCHAR 	SelectFont[40];
	int	SelectItem;
	int	ZoomRate;
	WORD	UpdateCode;
	BOOL	GridShow;
	WORD	CallCode;
	BOOL	FlagTmp;
	BOOL    bFocus;

protected:
	static CMenu NEAR menu;

	//{{AFX_MSG(CEditWnd)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnPaint();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnGaijiCopy();
	afx_msg void OnGaijiCut();
	afx_msg void OnGaijiPaste();
	afx_msg void OnGaijiUndo();
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnUpdateGaijiPaste(CCmdUI* pCmdUI);
	afx_msg void OnMDIActivate(BOOL bActivate, CWnd* pActivateWnd, CWnd* pDeactivateWnd);
	afx_msg void OnUpdateGaijiCopy(CCmdUI* pCmdUI);
	afx_msg void OnUpdateGaijiCut(CCmdUI* pCmdUI);
	afx_msg void OnDeleteEdit();
	afx_msg void OnUpdateDeleteEdit(CCmdUI* pCmdUI);
	afx_msg void OnUpdateGaijiUndo(CCmdUI* pCmdUI);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnClose();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\common.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
typedef int int16;
typedef long int32;
typedef unsigned int uint16;
typedef unsigned long uint32;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\create.cpp ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//


#include	"stdafx.h"
#include	"eudcedit.h" 

#pragma		pack(2)

#include	"ttfstruc.h"
#include	"vdata.h"
#include	"extfunc.h"

#define		EUDCCODEBASE	((unsigned short)0xe000)
/*
 File Structure */

struct W31_Header {
	char	identify[72];
unsigned char	segCnt[2];		/* ??? */
unsigned char	sCode[2],
		eCode[2];
	unsigned short	cCnt;       // Max character count
	unsigned long	ofsCmap;    // CMAP table offset
	unsigned short	sizCmap;    // Size of CMAP table
	unsigned long	ofsHCmap;
	unsigned short	sizHCmap;
	unsigned long	ofsStbl;    // Search table
	unsigned short	sizStbl;    // Size of search table
	unsigned long	ofsBdatSub; // Sub table of bitmap data
	};

struct BDatSubTbl {
	unsigned long	tail;
	long	locStartOfs;
	unsigned long	head;
	short	filler2;
	/* Following Pointer tbl. */
	};
struct BMPHeader {
	unsigned long	bitmapSiz;
	unsigned short	xsiz, ysiz;
	};

struct SrchEntry {
	unsigned short	sCode;
	unsigned short	eCode;
	unsigned short	sloc;
	};
/************************
 *	Tables 
 */
/*
 *	For Japan 
 */

#if (WINVER >= 0x0500)
static struct W31_Header W31Hdr= {
	"Windows EUDC Editor Bitmap File (Uni-Code) ",
	{(unsigned char)0x0, (unsigned char)0x1},
	{(unsigned char)0xe0, (unsigned char)0x00},
	{(unsigned char)0xf8, (unsigned char)0xff},
	(unsigned short)6400,
	(unsigned long)	0,
	(unsigned short)0,
	(unsigned long)0,
	(unsigned short) 512,
	(unsigned long)0,
	(unsigned short)0,
	(unsigned long)0
	};
#else
static struct W31_Header W31Hdr= {
	"Windows95 EUDC Editor Bitmap File (Uni-Code) ",
	{(unsigned char)0x0, (unsigned char)0x1},
	{(unsigned char)0xe0, (unsigned char)0x00},
	{(unsigned char)0xe7, (unsigned char)0x57},
	(unsigned short)1880,
	(unsigned long)	0,
	(unsigned short)0,
	(unsigned long)0,
	(unsigned short) 512,
	(unsigned long)0,
	(unsigned short)0,
	(unsigned long)0
	};
#endif

static struct SrchEntry cSrchEntry = {
	(unsigned short)0xE000,(unsigned short)0xE757,(unsigned short)0
	};

static void
setFileHeader( )
{
struct W31_Header *hdr;
	unsigned short	maxCode;

	maxCode = getMaxUniCode();
	hdr = &W31Hdr;
	hdr->eCode[0] = (unsigned char)(maxCode>>8);
	hdr->eCode[1] = (unsigned char)(maxCode & 0xff);
	hdr->cCnt =  maxCode - EUDCCODEBASE +1;
	hdr->ofsCmap = sizeof(struct W31_Header);
	hdr->sizCmap = hdr->cCnt*2;
	hdr->ofsHCmap = hdr->ofsCmap + hdr->sizCmap;
	hdr->ofsStbl = hdr->ofsHCmap+hdr->sizHCmap;
	hdr->sizStbl = sizeof(struct SrchEntry);
	hdr->ofsBdatSub = hdr->ofsStbl + hdr->sizStbl;

	cSrchEntry.sCode = EUDCCODEBASE;
	cSrchEntry.eCode = maxCode;
	return;
}
static int
makeCodeMap( char **mem, unsigned int *msiz)
{
	unsigned short	code;
	unsigned short	*cbuf;
	unsigned short	startC, endC;
	
	*msiz = W31Hdr.cCnt*2;
	if ( (*mem = (char *)malloc(*msiz)) == (char *)0)
		return -1;
	cbuf = (unsigned short *)*mem;

	startC =  cSrchEntry.sCode;
	endC =  cSrchEntry.eCode = getMaxUniCode();
	for ( code = startC; code <= endC; code++, cbuf++)
			*cbuf = code;
	return 0;
}
static int
makeHCMap( char **mem, unsigned int *msiz)
{
	unsigned short	*hcp;
	unsigned short	hc;
	unsigned short	sofs;
	unsigned short	start, end;

	*msiz = W31Hdr.sizHCmap;

	if ( (*mem = (char *)malloc( *msiz))==(char *)0)
		return -1;
	memset( *mem, 0xff, *msiz);
	hcp = (unsigned short *)*mem;
	sofs = (unsigned short)0;
	start = (unsigned short)W31Hdr.sCode[0];
	end = (unsigned short)W31Hdr.eCode[0];
	for ( hc = start; hc <= end; hc++) {
		*(hcp+hc) = (unsigned short)0;
	}
	return 0;
}
static int
makeSrchTbl( char **mem, unsigned int *msiz)
{

	*msiz = sizeof(struct SrchEntry);
	if ( (*mem = (char *)malloc( *msiz))==(char *)0)
		return -1;

	memcpy( *mem, &cSrchEntry, *msiz);

	return 0;
}
static int
makeBdatSub( char **mem, unsigned int *msiz)
{
struct BDatSubTbl	*bdtbl;
	*msiz = (W31Hdr.cCnt)*4 + sizeof(struct BDatSubTbl);
	if ( (*mem = (char *)malloc(*msiz))==(char *)0)
		return -1;
	memset( *mem, 0, *msiz);
	bdtbl = (struct BDatSubTbl *)*mem;
	bdtbl->head = bdtbl->tail = *msiz;
	bdtbl->locStartOfs=sizeof(struct BDatSubTbl);
	return 0;
}
/***************************************************************
 *	Create EUDC Bitmap File (.EUF)
 */
/* */	int
/* */	creatW31JEUDC( 
/* */		TCHAR *path)		/* .EUF file path */
/*
 *	returns : 0, -1
 ***************************************************************/
{
	HANDLE	fh;
	char	*mem;
	unsigned int msiz;
	DWORD nByte;
	BOOL res;


	mem = (char *)0;
	makeUniCodeTbl();
	fh = CreateFile(path,
					GENERIC_WRITE,
					FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
					NULL,
					CREATE_ALWAYS,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fh == INVALID_HANDLE_VALUE)
		goto	ERET;

	/* File Header */
	setFileHeader( );
	res =WriteFile( fh, (char *)&W31Hdr, sizeof(W31Hdr), &nByte, NULL);
	if (!res || nByte !=sizeof(W31Hdr))
		goto	ERET;
	/* Code Map */	
	if (makeCodeMap( &mem, &msiz))
		goto	ERET;
	res =WriteFile( fh, mem, msiz, &nByte, NULL);
	if (!res || nByte !=msiz)
		goto	ERET;
	free(mem);

	/* High Byte Mapping for Search table */
	if ( makeHCMap( &mem, &msiz))
		goto	ERET;
	res =WriteFile( fh, mem, msiz, &nByte, NULL);
	if (!res || nByte !=msiz)
		goto	ERET;
	free(mem);

	/* Srch Table */
	if (makeSrchTbl( &mem, &msiz))
		goto	ERET;
	res =WriteFile( fh, mem, msiz, &nByte, NULL);
	if (!res || nByte !=msiz)
		goto	ERET;
	free(mem);

	/* Segment Def Header */
	makeBdatSub( &mem, &msiz);
	res =WriteFile( fh, mem, msiz, &nByte, NULL);
	if (!res || nByte !=msiz)
		goto	ERET;
	free(mem);
	CloseHandle( fh);
	return 0;
ERET:
	if ( mem!=(char *)0)
		free( mem);
	if ( fh != INVALID_HANDLE_VALUE)
		CloseHandle( fh);
	return -1;
}
/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\eten.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
/*
CWIN31 EUDC Format and ETEN format
The structures are not aligned to word order. For the reason, it is need to use
'char' array base structures for the purpose of R/W files.
For the further item, the word is strored in Intel monor, use set/get functions.

+---------------------------+
| File Header  256 bytes    | -----> USERFONTHEADER
+---------------------------+
| Code Bank ID  2 bytes     | ~|
+---------------------------+  |---> CODEELEMENT
| DBCS Code    2 bytes      | _|
+---------------------------+
| Patten     ?? bytes       | -----> Glyph Patten depend on width and height
+---------------------------+
.              .
.              .
.              .
+---------------------------+
| Code Bank ID  2 bytes     |
+---------------------------+
| DBCS Code    2 bytes      |
+---------------------------+
| Patten     ?? bytes       |	---> Byte Boundary,remaining bits are not stable
+---------------------------+
*/

#ifdef BUILD_ON_WINNT
#pragma pack(1)
#endif // BUILD_ON_WINNT

struct CFONTINFO {
unsigned short	uInfoSize;		// Size of this structure.
unsigned short  idCP;			// Code page ID 938 for Taiwan.
	char	idCharSet;		// Character set is CHINESEBIG5_CHARSET
	char	fbTypeFace;  		// Type face.
	char	achFontName[12];	// Font Name.
unsigned long	ulCharDefine;		// Number of usable characters.
unsigned short  uCellWidth;		// Width of font cell.
unsigned short  uCellHeight;		// Height of font cell.
unsigned short  uCharHeight;		// Height of character height.
unsigned short  uBaseLine;		//
unsigned short  uUnderLine;		//
unsigned short  uUnlnHeight;		// Height of underline.
	char	fchStrokeWeight;	// Weight of font (Bold or Thin)
unsigned short  fCharStyle;		// italy
	char	fbFontAttrib;		//
unsigned long	ulCellWidthMax;		// Max width of font cell.
unsigned long	ulCellHeightMax;	// Max height of font cell.
	};

struct ETENHEADER {
unsigned short  uHeaderSize;	 	// Size of this structure.
	char	idUserFontSign[8];	// Must be "CWIN_PTN", "CMEX_PTN"
	char	idMajor;		// Version number if it is 1.0 then
	char	idMinor;		// idMajor is 1 and idMinor is 0
unsigned long	ulCharCount;		// Number of characters in file
unsigned short  uCharWidth;		// Width of the character.
unsigned short  uCharHeight;		// Height of the character.
unsigned long	cPatternSize;		// size of pattern in byte.
	char	uchBankID;	  	// if data is in same bank.
unsigned short  idInternalBankID;	// Internal code bank ID.
	char	achReserved1[37];	// must be zero.
struct	CFONTINFO  sFontInfo;		// chinese font structure.
	char	achReserved2[18];	// must be zero.
	char	achCopyRightMsg[128];	// Copyright message.
	};

struct CODEELEMENT {
	unsigned short   nBankID;		// BankID
	unsigned short   nInternalCode;		// Internal Code
	};


struct R_CFONTINFO {
unsigned char   uInfoSize[2];		// Size of this structure.
unsigned char   idCP[2];		// Code page ID 938 for Taiwan.
	char	idCharSet;		// Character set is CHINESEBIG5_CHARSET
	char	fbTypeFace;		// Type face.
	char	achFontName[12];	// Font Name.
unsigned char	ulCharDefine[4];	// Number of usable characters.
unsigned char   uCellWidth[2];		// Width of font cell.
unsigned char   uCellHeight[2];		// Height of font cell.
unsigned char   uCharHeight[2];		// Height of character height.
unsigned char   uBaseLine[2];		//
unsigned char   uUnderLine[2]; 		//
unsigned char   uUnlnHeight[2];		// Height of underline.
	char	fchStrokeWeight;	// Weight of font (Bold or Thin)
unsigned char   fCharStyle[2];		// italy
	char	fbFontAttrib;		//
unsigned char	ulCellWidthMax[4];	// Max width of font cell.
unsigned char	ulCellHeightMax[4];	// Max height of font cell.
	};

struct R_ETENHEADER {
unsigned char	uHeaderSize[2];		// Size of this structure.
	char	idUserFontSign[8];	// Must be "CWIN_PTN", "CMEX_PTN"
	char	idMajor;		// Version number if it is 1.0 then
	char	idMinor;		// idMajor is 1 and idMinor is 0
unsigned char	ulCharCount[4];		// Number of characters in file
unsigned char	uCharWidth[2];		// Width of the character.
unsigned char	uCharHeight[2];		// Height of the character.
unsigned char	cPatternSize[4];	// size of pattern in byte.
	char	uchBankID;		// if data is in same bank.
unsigned char	idInternalBankID[2];	// Internal code bank ID.
	char	achReserved1[37];	// must bezero.
struct R_CFONTINFO sFontInfo;		// chinese font structure.
	char	achReserved2[18]; 	// must be zero.
	char	achCopyRightMsg[128];	// Copyright message.
	};

struct R_CODEELEMENT {
	unsigned char   nBankID[2];		// BankID
	unsigned char   nInternalCode[2];		// Internal Code
	};

/* Open Mode */
#define	ETEN_READ	0
#define	ETEN_WRITE	1

int  openETENBMP(TCHAR  *path,int  md);
int  closeETENBMP(void);
int  createETENBMP(TCHAR  *path,int  width,int  height);
int  readETENBMPRec(int  rec,LPBYTE buf,int  bufsiz,unsigned short  *code);
int  appendETENBMP(LPBYTE buf,unsigned short  code);

#ifdef BUILD_ON_WINNT
#pragma pack()
#endif // BUILD_ON_WINNT
/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\eten.cpp ===
/*
 *	CWIN3.1 and ETEN format file i/o
 *
 * Copyright (c) 1997-1999 Microsoft Corporation.
 */

#include	"stdafx.h"
#pragma		pack(2)


#include	"extfunc.h"
#include	"eten.h"

#define		EUDCCODEBASE	((unsigned short)0xe000)
#define		ETENBANKID	0x8001
/*
static unsigned short  getsval(unsigned char  *s);
static unsigned long  getlval(unsigned char  *l);
static void  setsval(unsigned char  *m,unsigned short  s);
static void  setlval(unsigned char  *m,unsigned long  lval);
static int  readHdr(HANDLE fhdl,struct  ETENHEADER *hdr);
static int  updHdr(void);
static int  getETENBankID( HANDLE  fh, WORD  *BankID);
int  openETENBMP(TCHAR *path,int  md);
int  closeETENBMP(void);
static void  setIniHdr(struct  R_ETENHEADER *hdr,int  width,int  height);
int  createETENBMP(TCHAR *path,int  wid,int  hei);
int  getETENBMPInf(int  *n, int *ng, int  *wid,int  *hei, char *sign,WORD *bID);
int  readETENBMPRec(int  rec,LPBYTE buf,int  bufsiz,unsigned short  *code);
int  appendETENBMP(LPBYTE buf,unsigned short  code);
int  isETENBMP(TCHAR  *path);
*/
static HANDLE	bmpFh ;
static int	openmd = -1;
static int	nChar;
static int	width, height;
static int	*recordBuf=0;
	int	uNum=0;
static int	*codep=0;
static char	UserFontSign[8];
static WORD	BankID;

static unsigned short
getsval( unsigned char *s)
{
	unsigned short	sval;

	sval = (unsigned short )*(s+1);
	sval <<=8;
	sval |= (unsigned short )*s;
	return sval;
}
static unsigned long
getlval( unsigned char *l)
{
	unsigned long	lval;
	int	i;

	lval = (unsigned long)*(l+3);
	for ( i=2; i>=0; i--) {
		lval<<=8;
		lval |=(unsigned long)*(l+i);
	}
	return lval;
}
static void
setsval( unsigned char *m, unsigned short s)
{
	*m = (unsigned char)(s & 0xff);
	*(m+1) = (unsigned char)((s>>8) & 0xff);
}
static void
setlval( unsigned char *m, unsigned long lval)
{
	int	i;

	for ( i=0; i<4; i++) {
		*m++ = (unsigned char)(lval & 0xff);
		lval>>=8;
	}
}
static int
readHdr( HANDLE fhdl, struct ETENHEADER *hdr)
{
struct R_ETENHEADER	rhdr;
DWORD nByte;
BOOL res;

	res = ReadFile( fhdl, &rhdr, 256, &nByte, NULL);
	if (!res || nByte !=256)
		goto	ERET;

	memset( hdr, 0, sizeof(struct ETENHEADER));

	/* Set values to hdr */
	hdr->uHeaderSize = getsval( rhdr.uHeaderSize);
	memcpy( hdr->idUserFontSign, rhdr.idUserFontSign, 8);
	hdr->idMajor = rhdr.idMajor;
	hdr->idMinor = rhdr.idMinor;
	hdr->ulCharCount = getlval( rhdr.ulCharCount);
	hdr->uCharWidth = getsval( rhdr.uCharWidth);
	hdr->uCharHeight = getsval( rhdr.uCharHeight);
	hdr->cPatternSize = getlval( rhdr.cPatternSize);
	hdr->uchBankID = rhdr.uchBankID;
	hdr->idInternalBankID = getsval( rhdr.idInternalBankID);
	hdr->sFontInfo.uInfoSize = getsval(rhdr.sFontInfo.uInfoSize);
	hdr->sFontInfo.idCP = getsval(rhdr.sFontInfo.idCP);
	hdr->sFontInfo.idCharSet = rhdr.sFontInfo.idCharSet;
	hdr->sFontInfo.fbTypeFace = rhdr.sFontInfo.fbTypeFace;
	memcpy( hdr->sFontInfo.achFontName , rhdr.sFontInfo.achFontName,12);
	hdr->sFontInfo.ulCharDefine = getlval(rhdr.sFontInfo.ulCharDefine);
	hdr->sFontInfo.uCellWidth = getsval(rhdr.sFontInfo.uCellWidth);
	hdr->sFontInfo.uCellHeight = getsval(rhdr.sFontInfo.uCellHeight);
	hdr->sFontInfo.uCharHeight = getsval(rhdr.sFontInfo.uCharHeight);
	hdr->sFontInfo.uBaseLine = getsval(rhdr.sFontInfo.uBaseLine);
	hdr->sFontInfo.uUnderLine = getsval(rhdr.sFontInfo.uUnderLine);
	hdr->sFontInfo.uUnlnHeight = getsval(rhdr.sFontInfo.uUnlnHeight);
	hdr->sFontInfo.fchStrokeWeight = rhdr.sFontInfo.fchStrokeWeight;
	hdr->sFontInfo.fCharStyle = getsval(rhdr.sFontInfo.fCharStyle);
	hdr->sFontInfo.fbFontAttrib = rhdr.sFontInfo.fbFontAttrib;
	hdr->sFontInfo.ulCellWidthMax = getlval(rhdr.sFontInfo.ulCellWidthMax);
	hdr->sFontInfo.ulCellHeightMax= getlval(rhdr.sFontInfo.ulCellHeightMax);
	return 0;
ERET:
	return -1;
}
static int
updHdr( )
{
struct R_ETENHEADER	rhdr;
DWORD nByte;
BOOL res;
	
	if ( (long) SetFilePointer( bmpFh, 0L, NULL, FILE_BEGIN)!=0L)
		goto	ERET;
	res = ReadFile( bmpFh, &rhdr, 256, &nByte, NULL);
	if (!res || nByte !=256)
		goto	ERET;

	setlval( rhdr.ulCharCount, (long)nChar);
	setlval( rhdr.sFontInfo.ulCharDefine, (long)nChar);
	if ( (long) SetFilePointer( bmpFh, 0L, NULL, FILE_BEGIN)!=0L)
		goto	ERET;
	res = WriteFile(bmpFh, (char *)&rhdr, 256,&nByte, NULL);
	if (!res || nByte !=256)
		goto	ERET;
	return 0;
ERET:
	return -1;
}
static int
getETENBankID( HANDLE fh, WORD *BankID)
{
struct R_CODEELEMENT	cElm;
	long	ofs;
	DWORD nByte;
	BOOL res;

	ofs = sizeof(struct R_ETENHEADER);
	if ((long) SetFilePointer( fh, ofs, NULL, FILE_BEGIN) != ofs)
		goto	ERET;

	res = ReadFile( fh, &cElm, sizeof(struct R_CODEELEMENT), &nByte, NULL);
	if (!res || nByte !=sizeof(struct R_CODEELEMENT))
		goto	ERET;
	*BankID = getsval( cElm.nBankID);
	return 0;
ERET:
	return -1;
}
/***
	recBuf
	+-------+
	| rec#	| E000
	+-------+
	|	| E001
	+-------+
	    |
	+-------+
	|	| maxUCode
	+-------+
****/
static int
scanETENBMP( int **recBuf, unsigned int maxUCode, int  nRec)
{
	long	ofs;
	int	recsiz, bmpsiz;
struct R_CODEELEMENT *bhd;
	int	rec;
	char	*rbuf;
	unsigned short	code;
	unsigned short	ucode;
	int	urec;
	int	*recp;
	DWORD nByte;
	BOOL res;
	
	recp = 0;
	rbuf = 0;
	if (  maxUCode < EUDCCODEBASE)
		return -1;
	else if ( nRec <=0)
		return -1;
	uNum = maxUCode - EUDCCODEBASE+1;
	if ( (codep = (int *)malloc( uNum*sizeof(int)))==0)
		goto	ERET;
		
	ofs = sizeof( struct R_ETENHEADER);
	if ( (long) SetFilePointer( bmpFh, ofs, NULL, FILE_BEGIN)!=ofs)
		goto	ERET;
	bmpsiz = (width+7)/8*height;
	recsiz =bmpsiz+sizeof (bhd);
	if ((rbuf = (char *)malloc( recsiz))==(char *)0)
		goto	ERET;
	for ( code = EUDCCODEBASE; code <= maxUCode; code++)
		codep[code-EUDCCODEBASE] = -1;
	bhd = (struct R_CODEELEMENT *)rbuf;

	for ( rec = 0; rec < nRec; rec++) {
		res = ReadFile( bmpFh, rbuf, (unsigned int)recsiz, &nByte, NULL);
		if (!res || nByte !=(unsigned int)recsiz)
			goto	ERET;
		code = getsval( bhd->nInternalCode);
		if( memcmp(UserFontSign, "CMEX_PTN", 8) ||
		    BankID != ETENBANKID){
			ucode = sjisToUniEUDC( code);
		}else	ucode = code;

		if( ucode > maxUCode || ucode < EUDCCODEBASE)
			continue;
		urec = (int)(ucode - EUDCCODEBASE);
		codep[urec] = rec;
	}
	free( rbuf);

	if ( (recp = (int *)malloc( nRec*sizeof(int)))==0)
		goto	ERET;

	*recBuf=recp;
	for ( rec=0; rec < uNum; rec++) {
		if ( codep[rec]>0)
			*recp++ = codep[rec];
	}
	return 0;
ERET:
	if ( codep)	free( codep);
	if ( recp)	free( recp);
	if ( rbuf)	free( rbuf);
	return -1;
}
int
openETENBMP( TCHAR *path, int md)
{
	HANDLE	fh;
struct ETENHEADER hdr;

	makeUniCodeTbl();
	if ( md) {
		fh = CreateFile(path,
					GENERIC_READ | GENERIC_WRITE,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

		if ( fh == INVALID_HANDLE_VALUE)
			goto	ERET;
		bmpFh = fh;
		openmd = 1;
	}
	else {
		fh = CreateFile(path,
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

		if ( fh == INVALID_HANDLE_VALUE)
			goto	ERET;
		bmpFh = fh;
		openmd = 0;
	}
	if (readHdr( fh, &hdr))
		goto	ERET;
	if (getETENBankID( fh, &BankID))
		goto 	ERET;

	nChar = (int)hdr.ulCharCount;
	width =  (int)hdr.uCharWidth;
	height =  (int)hdr.uCharHeight;
	memcpy((char *)UserFontSign, hdr.idUserFontSign, 8);

	if ( scanETENBMP( &recordBuf, getMaxUniCode(), nChar))
		goto	ERET;

	return 0;
ERET:
  if (fh != INVALID_HANDLE_VALUE)
    CloseHandle(fh);
	return -1;
}
int
closeETENBMP( )
{
	int	sts;
	if ( openmd)
		sts = updHdr();
	else	sts = 0;
	if ( bmpFh!=INVALID_HANDLE_VALUE)
		CloseHandle( bmpFh);
	if(recordBuf)	{
		free(recordBuf);
		recordBuf = 0;
	}
	if ( codep) {
		free(codep);
		codep = 0;
	}
	return sts;
}
static void
setIniHdr( struct R_ETENHEADER *hdr, int width, int height)
{
	memset( hdr, 0, sizeof(struct R_ETENHEADER));
	setsval( hdr->uHeaderSize, sizeof(struct R_ETENHEADER));
	memcpy( hdr->idUserFontSign, "CWIN_PTN", 8);
	hdr->idMajor = 1;
	hdr->idMinor = 0;
	setsval( hdr->uCharWidth, (unsigned short)width);
	setsval( hdr->uCharHeight, (unsigned short)height);
	setlval( hdr->cPatternSize, (unsigned long)(((width+7)/8)*height));
	setsval( hdr->sFontInfo.uInfoSize,
			(unsigned short)sizeof(struct R_CFONTINFO));
	setsval( hdr->sFontInfo.idCP, 938);
	hdr->sFontInfo.idCharSet = (char)0x88;
	setsval( hdr->sFontInfo.uCellWidth, (unsigned short)width);
	setsval( hdr->sFontInfo.uCellHeight, (unsigned short)height);
	setsval( hdr->sFontInfo.uCharHeight, (unsigned short)height);
	setlval( hdr->sFontInfo.ulCellWidthMax, (unsigned long)width);
	setlval( hdr->sFontInfo.ulCellHeightMax, (unsigned long)height);
}
int
createETENBMP( TCHAR *path, int wid, int hei)
{
	HANDLE	fh;
struct R_ETENHEADER	hdr;
	DWORD nByte;
	BOOL res;

	 fh = CreateFile(path,
					GENERIC_WRITE,
					FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
					NULL,
					CREATE_ALWAYS,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fh == INVALID_HANDLE_VALUE)
		goto	ERET;

	width = wid;
	height = hei;
	setIniHdr( &hdr, width, height);
	res = WriteFile( fh, (char *)&hdr, sizeof(hdr), &nByte, NULL);
	if (!res || nByte !=sizeof(hdr))
		goto	ERET;
	bmpFh = fh;
	openmd = 1;
	nChar =0;
	return 0;
ERET:
  if (fh != INVALID_HANDLE_VALUE)
    CloseHandle(fh);
	return -1;
}
int
getETENBMPInf( int *nRec, int *nGlyph, int *wid, int *hei, char *sign,WORD *bID)
{
	if ( bmpFh <0)	return -1;
	*nRec = uNum;
	*nGlyph = nChar;
	*wid = width;
	*hei = height;
	*bID = BankID;
	memcpy( sign, UserFontSign, 8);
	return 0;
}
int
readETENBMPRec( int rec, LPBYTE buf, int bufsiz, unsigned short *code)
{
	long	ofs;
	int	recsiz;
struct R_CODEELEMENT bhd;
	int	rdsiz;
	int	bWid, wWid;
	int	y, ylim;
	unsigned char	*rbuf;
	DWORD nByte;
	BOOL res;

	bWid = (width+7)/8;
	wWid = (bWid+1)/2*2;
	recsiz = (width+7)/8*height;
	ofs = sizeof( struct R_ETENHEADER)+(long)(recsiz+sizeof (bhd))*rec;
	if ( (long) SetFilePointer( bmpFh, ofs, NULL, FILE_BEGIN)!=ofs)
		goto	ERET;
	res = ReadFile( bmpFh, &bhd, sizeof(bhd), &nByte, NULL);
	if (!res || nByte !=sizeof(bhd))
		goto	ERET;
	if ( bufsiz<recsiz)	rdsiz = bufsiz;
	else			rdsiz = recsiz;

	if ( bWid!=wWid) {
		BYTE	*src, *dst;
		if ((rbuf = (unsigned char *)malloc( recsiz))==(unsigned char *)0)
			goto	ERET;
		res = ReadFile( bmpFh, (char *)rbuf, (unsigned int)recsiz, &nByte, NULL);
		if (!res || nByte !=(unsigned int)recsiz) {
			free(rbuf);
			goto	ERET;
		}
		ylim = rdsiz / bWid;
		src = (LPBYTE)rbuf;
		dst = buf;
		memset( buf, 0xff, rdsiz);
		for ( y = 0; y < ylim; y++, src+=bWid, dst+=wWid)
			memcpy(dst , src , bWid);

		free( rbuf);
	}
	else {
		res = ReadFile( bmpFh, (char *)buf, (unsigned int)rdsiz, &nByte, NULL);
		if (!res || nByte !=(unsigned int)rdsiz)
			goto	ERET;
	}

	*code = getsval( bhd.nInternalCode);
	return 0;
ERET:
	return -1;
}
int
appendETENBMP( LPBYTE buf, unsigned short code)
{
struct R_CODEELEMENT bhd;
	int	bmpsiz;
	DWORD nByte;
	BOOL res;

	SetFilePointer( bmpFh, 0L, NULL, FILE_END);
	bmpsiz = (width+7)/8*height;
	setsval( bhd.nBankID, 1);
	setsval( bhd.nInternalCode, code);
	res = WriteFile( bmpFh, (LPBYTE)(&bhd), sizeof( bhd), &nByte, NULL);
	if (!res || nByte !=sizeof(bhd))
		goto	ERET;
	res = WriteFile( bmpFh, (LPBYTE)buf, (unsigned int)bmpsiz, &nByte, NULL);
	if (!res || nByte != (unsigned int)bmpsiz)
		goto	ERET;

	nChar++;
	return 0;
ERET:
	return -1;
}
int
isETENBMP(TCHAR *path)
{
struct ETENHEADER	hdr;
	HANDLE fhdl;
	fhdl = CreateFile(path,
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fhdl == INVALID_HANDLE_VALUE)
		return -1;
	if ( readHdr( fhdl, &hdr)) {
		CloseHandle( fhdl);
		return -1;
	}
	CloseHandle( fhdl);
	/* check Header size and keyWord*/
	if ( hdr.uHeaderSize != sizeof(struct R_ETENHEADER))
		goto	NO_ETEN;

	if ( memcmp(hdr.idUserFontSign, "CWIN_PTN", 8) &&
	     memcmp(hdr.idUserFontSign, "CMEX_PTN", 8))
		goto	NO_ETEN;
	return 1;
NO_ETEN:
	return 0;
}

int
ETENrecTbl( int **recTbl)
{
	*recTbl=codep;
	return 0;
}
/* EOF */
/* For test  +/
static int
dispHdr( struct ETENHEADER *hdr)
{
	printf("hdr->uHeaderSize= %d\n", hdr->uHeaderSize );
	printf("hdr->idMajor %d\n", hdr->idMajor );
	printf("hdr->idMinor  %d\n", hdr->idMinor );
	printf("hdr->ulCharCout  %ld\n", hdr->ulCharCount );
	printf("hdr->uCharWidth  %d\n", hdr->uCharWidth );
	printf(" hdr->uCharHeight  %d\n", hdr->uCharHeight );
	printf(" hdr->cPatternSize %d\n", hdr->cPatternSize);
	printf("hdr->uchBankID %d\n", hdr->uchBankID);
	printf("hdr->idInternalBankID %d\n", hdr->idInternalBankID);
	printf("hdr->sFontInfo.uInfoSize %d\n", hdr->sFontInfo.uInfoSize);
	printf("hdr->sFontInfo.idCP %d\n", hdr->sFontInfo.idCP);
	printf("hdr->sFontInfo.idCharSet %d\n", hdr->sFontInfo.idCharSet);
	printf("hdr->sFontInfo.fbTypeFace %d\n", hdr->sFontInfo.fbTypeFace);
	printf("hdr->sFontInfo.ulCharDefine %ld\n", hdr->sFontInfo.ulCharDefine);
	printf("hdr->sFontInfo.uCellWidth %d\n", hdr->sFontInfo.uCellWidth);
	printf("hdr->sFontInfo.uCellHeight %d\n", hdr->sFontInfo.uCellHeight);
	printf("hdr->sFontInfo.uCharHeight %d\n", hdr->sFontInfo.uCharHeight);
	printf("hdr->sFontInfo.uBaseLine %d\n", hdr->sFontInfo.uBaseLine);
	printf("hdr->sFontInfo.uUnderLine %d\n", hdr->sFontInfo.uUnderLine);
	printf("hdr->sFontInfo.uUnlnHeight %d\n", hdr->sFontInfo.uUnlnHeight);
	printf("hdr->sFontInfo.fchStrokeWeight %d\n", hdr->sFontInfo.fchStrokeWeight);
	printf("hdr->sFontInfo.fCharStyle %d\n", hdr->sFontInfo.fCharStyle);
	printf("hdr->sFontInfo.fbFontAttrib %d\n", hdr->sFontInfo.fbFontAttrib);
	printf("hdr->sFontInfo.ulCellWidthMax %ld\n", hdr->sFontInfo.ulCellWidthMax);
	printf("hdr->sFontInfo.ulCellHeightMax %ld\n", hdr->sFontInfo.ulCellHeightMax);
}
main( int argc, char *argv[])
{
	int	fh;
struct ETENHEADER hdr;
	fh = _lopen( argv[1], O_RDONLY | O_BINARY);
	
	readHdr( fh, &hdr);
	dispHdr( &hdr);
	_lclose(fh);
	exit(0);
}
/+ */
/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\eudcdlg.cpp ===
/**************************************************/
/*						                          */
/*						                          */
/*	SelectCode... EUDC Editor Dialog	          */
/*						                          */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include 	"stdafx.h"
#include 	"eudcedit.h"
#include 	"eudcdlg.h"
#include 	"registry.h"
#include	"util.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

typedef struct _tagRegistDef{
	TCHAR	RegFont[LF_FACESIZE];
	TCHAR	RegFile[MAX_PATH];
	BOOL	RegFlg;
} REGISTDEF;

static 	REGISTDEF	RegistDef;	
BEGIN_MESSAGE_MAP(CEudcDlg, CDialog)
	//{{AFX_MSG_MAP(CEudcDlg)
	ON_CBN_SELCHANGE(IDC_CHINARANGE, OnSelchangeChinarange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/****************************************/
/*					*/
/*	Constructor			*/
/*					*/
/****************************************/
CEudcDlg::CEudcDlg( CWnd* pParent)
	: CDialog(CEudcDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CEudcDlg)
	//}}AFX_DATA_INIT
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_INITDIALOG"		*/
/*					*/
/****************************************/
BOOL
CEudcDlg::OnInitDialog()
{
	LOGFONT	LogFont;
	CString	DialogTitle;		
	TCHAR	SBuf[5], EBuf[5], CodeBuf[15];
	TCHAR	SysFace[LF_FACESIZE];
	long	WindowStyle;

	CDialog::OnInitDialog();

	WindowStyle = GetWindowLong( this->GetSafeHwnd(), GWL_EXSTYLE);
	WindowStyle |= WS_EX_CONTEXTHELP;
	SetWindowLong( this->GetSafeHwnd(), GWL_EXSTYLE, WindowStyle);

	m_EditList.SubclassDlgItem( IDC_CUSTOMEDIT, this);
	m_ViewChar.SubclassDlgItem( IDC_CUSTOMCHR, this);
#ifdef BUILD_ON_WINNT
	m_ColumnHeading.SubclassDlgItem( IDC_COLUMNHEADING, this);
#endif //BUILD_ON_WINNT
	m_Frame.SubclassDlgItem( IDC_CUSTOMFRAME, this);
	m_ListFrame.SubclassDlgItem( IDC_CUSTOMLISTFRAME, this);
	m_InfoFrame2.SubclassDlgItem( IDC_CUSTOMFRAME2, this);
	m_InfoFrame3.SubclassDlgItem( IDC_CUSTOMFRAME3, this);
	m_StaticRange.SubclassDlgItem( IDC_STATICRANGE, this);
	m_ComboRange.SubclassDlgItem( IDC_CHINARANGE, this);

	if( CountryInfo.LangID != EUDC_KRW || CountryInfo.bUnicodeMode){
		m_EditList.EnableScrollBar( SB_VERT, ESB_ENABLE_BOTH);
	}else	m_EditList.ShowScrollBar( SB_VERT, FALSE);

	AdjustFileName();
	AdjustFontName();
	this->SetDlgItemText( IDC_SETFONTNAME, FontName);
	this->SetDlgItemText( IDC_SETFILENAME, FileName);
	if( WorRFlag)
		DialogTitle.LoadString( IDS_REGISTAS_DLGTITLE);
	else	DialogTitle.LoadString( IDS_SELECTCODE_DLGTITLE);
	this->SetWindowText( DialogTitle);

	m_EditList.cRange = CountryInfo.CurrentRange;
	if( CountryInfo.nRange > 2 && !CountryInfo.bUnicodeMode){
	    m_StaticRange.ShowWindow( SW_SHOWNORMAL);
		m_ComboRange.ShowWindow( SW_SHOWNORMAL);
		m_StaticRange.UpdateWindow();
		m_ComboRange.UpdateWindow();

		for( int i = 0; i < CountryInfo.nRange-1; i++){
			wsprintf( SBuf, TEXT("%X"), CountryInfo.sRange[i]);
			wsprintf( EBuf, TEXT("%X"), CountryInfo.eRange[i]);
			lstrcpy( CodeBuf, SBuf);
			lstrcat( CodeBuf, TEXT(" - "));
			lstrcat( CodeBuf, EBuf);
			m_ComboRange.InsertString( i, CodeBuf);
		}
		m_ComboRange.DeleteString( CountryInfo.nRange-1);
		m_ComboRange.SetCurSel( CountryInfo.CurrentRange);
	}

//	Set font for output character code
	GetFont()->GetObject( sizeof( LOGFONT), &LogFont);
	m_EditList.SysFFont.CreateFontIndirect( &LogFont);
	m_EditList.CalcCharSize();
#ifdef BUILD_ON_WINNT
//  Set font for the column heading
	m_ColumnHeading.SysFFont.CreateFontIndirect( &LogFont);
#endif //BUILD_ON_WINNT

//	Set font for output character
	memset( &LogFont, 0, sizeof( LogFont));
	if( m_EditList.CharSize.cx >= m_EditList.CharSize.cy)
		LogFont.lfHeight = m_EditList.CharSize.cy-2;
	else	LogFont.lfHeight = m_EditList.CharSize.cx-2;
	LogFont.lfCharSet = (BYTE)CountryInfo.CharacterSet;
	
  GetStringRes((TCHAR *)SysFace, IDS_SYSTEMEUDCFONT_STR);
  if( !lstrcmp(SelectEUDC.m_Font, (const TCHAR *)SysFace) )
  {
    lstrcpy (LogFont.lfFaceName, TEXT("System"));
	}else{
    lstrcpy( LogFont.lfFaceName, SelectEUDC.m_Font);
	}
	if( !m_EditList.EUDCFont.CreateFontIndirect( &LogFont))
		return FALSE;
//fix for 261529
	if( !m_ViewChar.EUDCFont.CreateFontIndirect( &LogFont))
		return FALSE;

	return TRUE;
}

/****************************************/
/*		Deal with "OK"		*/
/****************************************/
void CEudcDlg::OnOK()
{
	if( !m_EditList.SelectCode){
		if( WorRFlag){
			OutputMessageBox( this->GetSafeHwnd(),
				IDS_REGISTAS_DLGTITLE,
				IDS_NOTSELCHARACTER_MSG, TRUE);
		}else{
			OutputMessageBox( this->GetSafeHwnd(),
				IDS_SELECTCODE_DLGTITLE,
				IDS_NOTSELCHARACTER_MSG, TRUE);
		}
		return;
	}
	RegistRegFont();
	EndDialog(IDOK);
}
void CEudcDlg::OnCancel()
{
	RegistRegFont();
	CDialog::OnCancel();
}
/****************************************/
/*	Take off ".TTF" from filename	*/
/****************************************/
void CEudcDlg::AdjustFileName()
{
	TCHAR	*FilePtr;

	lstrcpy(FileName, SelectEUDC.m_FileTitle);
	if(( FilePtr = Mytcsrchr( FileName, '.')) != NULL)
		*FilePtr = '\0';	

#ifdef BUILD_ON_WINNT
    /*
     * Trim the string more better way...
     */
    CClientDC   dc(this);
	CRect	    ViewFileRect;
	CSize       FileNameSize;
	CWnd       *cWnd = GetDlgItem( IDC_SETFILENAME);
    INT         MaxChars;
    INT         cchString = lstrlen(FileName);

	cWnd->GetClientRect( &ViewFileRect);

	GetTextExtentExPoint( dc.GetSafeHdc(), FileName,
		cchString, ViewFileRect.Width(), &MaxChars, NULL ,&FileNameSize);

    if( cchString > MaxChars) {
        INT Chars = 0;

        FilePtr = FileName;
        while (Chars < (MaxChars-3)) {
            FilePtr++; Chars++;
        }

        for (; Chars < MaxChars; Chars++) {
            FileName[Chars] = TEXT('.');
        }
        FileName[Chars] = TEXT('\0');
    }
#else
	if( strlen((const char *)FileName) > 11){
		FileName[11] = '.';
		FileName[12] = '.';
		FileName[13] = '\0';
	}
#endif // BUILD_ON_WINNT

	return;
}

/****************************************/
/*	Adjust EUDC Font name		*/
/****************************************/
void CEudcDlg::AdjustFontName()
{
CClientDC	dc(this);
	CRect	ViewFontRect;
	CSize	FontNameSize, CharSize;
	int	i;

	lstrcpy(FontName, SelectEUDC.m_Font);

	CWnd *cWnd = GetDlgItem( IDC_SETFONTNAME);
	cWnd->GetClientRect( &ViewFontRect);

	GetTextExtentPoint32( dc.GetSafeHdc(), FontName,
		lstrlen(FontName), &FontNameSize);

	if( ViewFontRect.Width() <= FontNameSize.cx){
		GetTextExtentPoint32( dc.GetSafeHdc(), TEXT("<<"), 2, &CharSize);
		i = ( ViewFontRect.Width() /CharSize.cx) * 2;
		FontName[i-2] = '.';
		FontName[i-1] = '.';
		FontName[i] = '\0';
	}
}

/****************************************/
/*	Change EUDC code range(CHINESE)	*/
/****************************************/
void CEudcDlg::OnSelchangeChinarange()
{
	int nIndex = m_ComboRange.GetCurSel();

	m_EditList.cRange = nIndex;
	m_EditList.SetEUDCCodeRange( nIndex);
	this->SetDlgItemText( IDC_CUSTOMCHR, TEXT(""));
	this->SetDlgItemText( IDC_CODECUST,  TEXT(""));
	m_EditList.Invalidate();
	m_EditList.UpdateWindow();

	CWnd *cWnd = this->GetDlgItem( IDC_CUSTOMEDIT);
	this->GotoDlgCtrl( cWnd);
}

void CEudcDlg::RegistRegFont()
{
	if( RegistDef.RegFlg){

        // The code is to fix the related bug #421829 & #438677
        // It delays 1 second to call EnabelEUDC(FALSE).
        DWORD dwStart = GetTickCount();

        // Stop if this has taken too long
        while (1)
        {
            if( GetTickCount() - dwStart >= 1000 )
                break;
        }
        
		EnableEUDC(FALSE);
		RegistTypeFace( RegistDef.RegFont,  RegistDef.RegFile);
		EnableEUDC(TRUE);
	}
}

static DWORD aIds[] =
{
    IDC_CUSTOMEDIT, IDH_EUDC_SELLIST,
    IDC_COLUMNHEADING,  IDH_EUDC_SELLIST,
    IDC_CODECUST,   IDH_EUDC_SELCODE,
    IDC_CODE_NAME,  IDH_EUDC_SELCODE,
    IDC_CUSTOMFRAME,    IDH_EUDC_SELCODE,
    IDC_SETFONTNAME,IDH_EUDC_SELFONT,
    IDC_FONT_NAME, IDH_EUDC_SELFONT,
    IDC_CUSTOMFRAME3, IDH_EUDC_SELFONT,
    IDC_SETFILENAME,IDH_EUDC_SELFILE,
    IDC_FILE_NAME, IDH_EUDC_SELFILE,
    IDC_CUSTOMFRAME2, IDH_EUDC_SELFILE,
    IDC_CUSTOMCHR, IDH_EUDC_SELCHAR,
    IDC_STATICRANGE, IDH_EUDC_SELRANGE,
    IDC_CHINARANGE, IDH_EUDC_SELRANGE,
	0,0
};

static DWORD aIdsReg[] =
{
    IDC_CUSTOMEDIT, IDH_EUDC_REGLIST,
    IDC_COLUMNHEADING,  IDH_EUDC_REGLIST,
    IDC_CODECUST,   IDH_EUDC_REGCODE,
    IDC_CODE_NAME,  IDH_EUDC_REGCODE,
    IDC_CUSTOMFRAME,    IDH_EUDC_REGCODE,
    IDC_SETFONTNAME,IDH_EUDC_REGFONT,
    IDC_FONT_NAME, IDH_EUDC_REGFONT,
    IDC_CUSTOMFRAME3, IDH_EUDC_REGFONT,
    IDC_SETFILENAME,IDH_EUDC_REGFILE,
    IDC_FILE_NAME, IDH_EUDC_REGFILE,
    IDC_CUSTOMFRAME2, IDH_EUDC_REGFILE,
    IDC_CUSTOMCHR, IDH_EUDC_REGCHAR,
    IDC_STATICRANGE, IDH_EUDC_REGRANGE,
    IDC_CHINARANGE, IDH_EUDC_REGRANGE,
	0,0
};
/****************************************/
/*	Customdlg Window Procedure	*/
/****************************************/
LRESULT CEudcDlg::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	if( message == WM_VIEWUPDATE){
		m_ViewChar.Invalidate( FALSE);
		m_ViewChar.UpdateWindow();
		return(0);
	}
	if( message == WM_HELP){
		::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
			HelpPath, HELP_WM_HELP, (DWORD_PTR)(LPTSTR)(WorRFlag ? aIdsReg : aIds));
		return(0);
	}
	if( message == WM_CONTEXTMENU){
		::WinHelp((HWND)wParam, HelpPath,
			HELP_CONTEXTMENU, (DWORD_PTR)(LPTSTR) (WorRFlag ? aIdsReg : aIds));
		return(0);
	}
	return CDialog::WindowProc( message, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\editwnd.cpp ===
/**************************************************/
/*                                           */
/*                                           */
/* MDI Child Window( For Edit)                     */
/*                                           */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include    "stdafx.h"
#include    "eudcedit.h"
#include    "editwnd.h"
#include    "refrwnd.h"
#include    "vdata.h"
#include "extfunc.h"
#include "util.h"
#include "rotatdlg.h"

// For mouse
#define     NCLICK   0
#define     LCLICK   1
#define     RCLICK   2

// For selected rectangle
#define     LUPPER   0
#define     RUPPER   1
#define     RLOWER   2
#define     LLOWER   3
#define     MUPPER   4
#define     RMIDLE   5
#define     MLOWER   6
#define     LMIDLE   7
#define     NCHECK   8

// For Rectangular selection and freeform selection
#define     BMP   0
#define     DSP   1  
#define     PRV   2
#define     VLD   3
#define     PIN   4

// max of freeform selection point
#define     FREELIAIS   1000
#define     MKOUTHDL 2

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CMenu NEAR CEditWnd::menu;
IMPLEMENT_DYNCREATE( CEditWnd, CMDIChildWnd)
BEGIN_MESSAGE_MAP(CEditWnd, CMDIChildWnd)
//{{AFX_MSG_MAP(CEditWnd)
   ON_WM_LBUTTONDOWN()
   ON_WM_LBUTTONUP()
   ON_WM_MOUSEMOVE()
   ON_WM_PAINT()
   ON_WM_CREATE()
   ON_COMMAND(ID_GAIJI_COPY, OnGaijiCopy)
   ON_COMMAND(ID_GAIJI_CUT, OnGaijiCut)
   ON_COMMAND(ID_GAIJI_PASTE, OnGaijiPaste)
   ON_COMMAND(ID_GAIJI_UNDO, OnGaijiUndo)
   ON_WM_RBUTTONDOWN()
   ON_WM_RBUTTONUP()
   ON_WM_SIZE()
   ON_WM_SETCURSOR()
   ON_UPDATE_COMMAND_UI(ID_GAIJI_PASTE, OnUpdateGaijiPaste)
   ON_WM_MDIACTIVATE()
   ON_UPDATE_COMMAND_UI(ID_GAIJI_COPY, OnUpdateGaijiCopy)
   ON_UPDATE_COMMAND_UI(ID_GAIJI_CUT, OnUpdateGaijiCut)
   ON_COMMAND(ID_DELETE_EDIT, OnDeleteEdit)
   ON_UPDATE_COMMAND_UI(ID_DELETE_EDIT, OnUpdateDeleteEdit)
   ON_UPDATE_COMMAND_UI(ID_GAIJI_UNDO, OnUpdateGaijiUndo)
   ON_WM_KEYDOWN()
   ON_WM_CLOSE()
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// Global parameter
LOGFONT  EditLogFont;
extern   int   SelectItems;
extern  CBitmap   DupBmp;
extern  CRect  DupRect;
extern CRefrWnd *pRefrChild;
extern BOOL g_bKeepEUDCLink;

/****************************************/
/*             */
/*   Create MDI child window for edit  */
/*             */
/****************************************/
BOOL
CEditWnd::Create(
LPCTSTR  szTitle,
LONG  Style,
RECT  EudcWndRect,
CMDIFrameWnd* Parent)
{
// Load menu as same as MainFrame
   if( menu.m_hMenu == NULL)
      menu.LoadMenu( IDR_MAINFRAME);
   m_hMenuShared = menu.m_hMenu;

// Register window class of MDI child for edit
   const TCHAR *pszEudcWndClass =
      AfxRegisterWndClass( CS_BYTEALIGNCLIENT,
      NULL, (HBRUSH)(COLOR_WINDOW+1), NULL);

   return CMDIChildWnd::Create( pszEudcWndClass,
          szTitle, Style, EudcWndRect, Parent);
}

/****************************************/
/*             */
/*   Process before window is created  */
/*             */
/****************************************/
int
CEditWnd::OnCreate( LPCREATESTRUCT lpCreateStruct)
{
   if( CMDIChildWnd::OnCreate( lpCreateStruct) == -1)
      goto ERR;

// If it is mirrored then turn off mirroing.
   ModifyStyleEx( WS_EX_LAYOUTRTL, 0);

   if( !CreateNewBitmap())
      goto ERR;
   if( !ClipPickValueInit())
      goto ERR;
   if( !InitEditLogfont())
      goto ERR;

   return  0;
ERR:
   return -1;
}

/****************************************/
/*             */
/* Create bitmap, and initialized   */
/*             */
/****************************************/
BOOL
CEditWnd::CreateNewBitmap()
{
   WORD  BitSize;
   HANDLE   BitInit;
   BYTE  *BitmapPtr;

   CClientDC   ChildDC( this);

   if( !ImageDC.CreateCompatibleDC( &ChildDC))
      return FALSE;

   if( !CRTDrawDC.CreateCompatibleDC( &ChildDC))
      return FALSE;

   BitSize = (WORD)((( BITMAP_WIDTH +15) /16) *2) *(WORD)BITMAP_HEIGHT;
   if(( BitInit = LocalAlloc( LMEM_MOVEABLE, BitSize)) == 0)
      return FALSE;

   if(( BitmapPtr = (BYTE *)LocalLock( BitInit)) == NULL){
      LocalFree( BitInit);
      return FALSE;
   }

// Initialize with white color
   memset( BitmapPtr, 0xffff, BitSize);
   if( !ImageBmp.CreateBitmap( BITMAP_WIDTH, BITMAP_HEIGHT,
      1, 1, (LPSTR)BitmapPtr)){
      LocalUnlock( BitInit);
      LocalFree( BitInit);
      return FALSE;
   }

// Initialize with white color
   if( !CRTDrawBmp.CreateBitmap( BITMAP_WIDTH, BITMAP_HEIGHT,
       1, 1, (LPSTR)BitmapPtr)){
       LocalUnlock( BitInit);
       LocalFree( BitInit);
      return FALSE;
   }
   LocalUnlock( BitInit);
   LocalFree( BitInit);    
   ImageDC.SelectObject( &ImageBmp);
   CRTDrawDC.SelectObject( &CRTDrawBmp);

   return TRUE;
}
               
/****************************************/
/*             */
/* Registry clipboard format  */
/*             */
/****************************************/
BOOL
CEditWnd::ClipPickValueInit()
{
// Register "EUDCEDIT" clipboard format
   if( !( ClipboardFormat = RegisterClipboardFormat(TEXT("EudcEdit"))))
      return FALSE;

   return TRUE;
}
               
/****************************************/
/*             */
/* Initialize EditLogFont     */
/*             */
/****************************************/
BOOL
CEditWnd::InitEditLogfont()
{
   CFont cFont;

#ifdef BUILD_ON_WINNT
  cFont.CreateStockObject(DEFAULT_GUI_FONT);
#else
   cFont.CreateStockObject( SYSTEM_FONT);
#endif
   cFont.GetObject( sizeof(LOGFONT), &EditLogFont);
   cFont.DeleteObject();

   return TRUE;
}

/****************************************/
/*             */
/* Default Constructor     */
/*             */
/****************************************/
CEditWnd::CEditWnd()
{
// Initialize static parameter
   BitmapDirty = FALSE;
   GridShow = TRUE;
   SelectItem = PEN;
   RectClipFlag = FALSE;
   CheckNum = NCHECK;
   ButtonFlag = NCLICK;
   IsCapture = FALSE;
   UndoBitmapFlag = FALSE;
   FlagTmp = FALSE;
   UpdateCode = 0x0000;
   Ratio = 3;
   bFocus = TRUE;
}
   
/****************************************/
/*             */
/* Destructor        */
/*             */ 
/****************************************/
CEditWnd::~CEditWnd()
{
// Delete CDC and CBitmap object
   if( CRTDrawBmp.Detach() != NULL)
      CRTDrawBmp.DeleteObject();
   if( ImageBmp.Detach() != NULL)
      ImageBmp.DeleteObject();
   if( CRTDrawDC.Detach() != NULL)
      CRTDrawDC.DeleteDC();
   if( ImageDC.Detach() != NULL)
      ImageDC.DeleteDC();
   if( UndoImage.Detach() != NULL)
      UndoImage.DeleteObject();
  menu.DestroyMenu();
}

/****************************************/
/*             */
/* COMMAND     "UNDO"      */
/*             */
/****************************************/
void
CEditWnd::OnGaijiUndo()
{
   int   wSize;
   LPBYTE   pBuf1, pBuf2;

   if( !UndoBitmapFlag)
      CreateUndoBitmap();
   UndoBitmapFlag = TRUE;

   if( SelectItem == RECTCLIP || SelectItem == FREEFORM)
      WriteSelRectBitmap();

   wSize = (int)((( BITMAP_WIDTH +15) /16) *2) *(int)BITMAP_HEIGHT;
   pBuf1 = (LPBYTE)malloc( wSize);
   pBuf2 = (LPBYTE)malloc( wSize);
   ImageBmp.GetBitmapBits( wSize, (LPVOID)pBuf1);
   UndoImage.GetBitmapBits( wSize, (LPVOID)pBuf2);
   ImageBmp.SetBitmapBits( wSize, (LPVOID)pBuf2);
   UndoImage.SetBitmapBits( wSize, (LPVOID)pBuf1);          
   free(pBuf1);
   free(pBuf2);
   
   this->Invalidate(FALSE);   
   this->UpdateWindow();
}

/****************************************/
/*             */
/* COMMAND     "UNDO" (Update)   */
/*             */
/****************************************/
void
CEditWnd::OnUpdateGaijiUndo(
CCmdUI* pCmdUI)
{
   if( BitmapDirty)
      pCmdUI->Enable(TRUE);
   else  pCmdUI->Enable(FALSE);
}

/****************************************/
/*             */
/* COMMAND     "CUT"    */
/*             */
/****************************************/
void
CEditWnd::OnGaijiCut()
{
   UndoImageDraw();
   BitmapDirty = TRUE;
   ClipImageCopy();
   ClipImageCut();
   this->Invalidate(FALSE);
   if( RectClipFlag){
      ToolTerm();
      RectClipFlag = FALSE;
   }        
}

/****************************************/
/*             */
/* COMMAND     "Cut" (Update) */
/*             */
/****************************************/
void
CEditWnd::OnUpdateGaijiCut(
CCmdUI* pCmdUI)
{
   pCmdUI->Enable( RectClipFlag);   
}

/****************************************/
/*             */
/* COMMAND     "COPY"      */
/*             */
/****************************************/
void
CEditWnd::OnGaijiCopy()
{
   ClipImageCopy();
}

/****************************************/
/*             */
/* COMMAND     "Copy" (Update)   */
/*             */
/****************************************/
void
CEditWnd::OnUpdateGaijiCopy( CCmdUI* pCmdUI)
{
   pCmdUI->Enable( RectClipFlag);   
}

/****************************************/
/*             */
/* COMMAND     "PASTE"     */
/*             */
/****************************************/
void
CEditWnd::OnGaijiPaste()
{
   HBITMAP  ClipBmpHandle, hTempBitmap1;
   CBitmap  ClipBmp1, ClipBmp2;
   HDC   hStdDC, hTempDC1;
   HGDIOBJ  hOldSObj, hOldSObj2;
   BITMAP   Bmp;
   CSize StretchSize;
   BOOL  BitmapFmt, PrivateFmt;

   BitmapFmt  = FALSE;
   PrivateFmt = FALSE;
   UndoImageDraw();
   BitmapDirty = TRUE;
   WriteSelRectBitmap();
   this->Invalidate( FALSE);
   this->UpdateWindow();

   if( !this->OpenClipboard())
      return;

   if(( ClipBmpHandle = (HBITMAP)GetClipboardData(CF_BITMAP)) == NULL){
      CloseClipboard();
         return;
      }
   GetObject(ClipBmpHandle, sizeof(BITMAP), (LPVOID)&Bmp);
   hStdDC = CreateCompatibleDC( ImageDC.GetSafeHdc());
   hOldSObj = SelectObject(hStdDC, ClipBmpHandle);

   hTempBitmap1 = CreateBitmap(Bmp.bmWidth, Bmp.bmHeight, 1, 1, NULL);
   hTempDC1 = CreateCompatibleDC( ImageDC.GetSafeHdc());
   hOldSObj2 = SelectObject( hTempDC1, hTempBitmap1);
   ::BitBlt( hTempDC1, 0, 0, Bmp.bmWidth, Bmp.bmHeight,
      hStdDC, 0, 0, SRCCOPY);

   if( !CloseClipboard())
  {
   SelectObject( hStdDC, hOldSObj);
     SelectObject( hTempDC1, hOldSObj2);
     DeleteObject( hTempBitmap1);
     DeleteDC( hStdDC);
     DeleteDC( hTempDC1);
      return;
  }
   if( (int)Bmp.bmWidth  < BITMAP_WIDTH  &&
            (int)Bmp.bmHeight < BITMAP_HEIGHT ){
         StretchSize.cx = (int)Bmp.bmWidth;
         StretchSize.cy = (int)Bmp.bmHeight;
      ::StretchBlt( CRTDrawDC.GetSafeHdc(), 0, 0,
         StretchSize.cx, StretchSize.cy, hTempDC1, 0, 0,
         StretchSize.cx, StretchSize.cy, SRCCOPY);
      }else if( Bmp.bmWidth < BITMAP_WIDTH){
      StretchSize.cx = (int)Bmp.bmWidth;
      StretchSize.cy = BITMAP_HEIGHT;
      ::StretchBlt( CRTDrawDC.GetSafeHdc(), 0, 0,
         StretchSize.cx, StretchSize.cy, hTempDC1, 0, 0,
         StretchSize.cx, Bmp.bmHeight, SRCCOPY);
   }else if( Bmp.bmHeight < BITMAP_HEIGHT){
      StretchSize.cx = BITMAP_HEIGHT;
      StretchSize.cy = (int)Bmp.bmHeight;
      ::StretchBlt( CRTDrawDC.GetSafeHdc(), 0, 0,
         StretchSize.cx, StretchSize.cy, hTempDC1, 0, 0,
         Bmp.bmWidth, StretchSize.cy, SRCCOPY);
   }else{
         StretchSize.cx = BITMAP_WIDTH;
         StretchSize.cy = BITMAP_HEIGHT;
      ::StretchBlt( CRTDrawDC.GetSafeHdc(), 0, 0,
         StretchSize.cx, StretchSize.cy, hTempDC1, 0, 0,
         Bmp.bmWidth, Bmp.bmHeight, SRCCOPY);
      }
   ptStart.x = 0;
   ptStart.y = 0;
   ptEnd.x = (StretchSize.cx-1) *ZoomRate;
   ptEnd.y = (StretchSize.cy-1) *ZoomRate;
   SetMoveRect();
   SetValidRect();
   SetClickRect();
   SetPickRect();
   SelectItem = RECTCLIP;
   RectClipFlag = TRUE;
   this->InvalidateRect( &ClipRect[VLD], FALSE);
   this->UpdateWindow();

   SelectObject( hStdDC, hOldSObj);
   SelectObject( hTempDC1, hOldSObj2);
   DeleteObject( hTempBitmap1);
   DeleteDC( hStdDC);
   DeleteDC( hTempDC1);

    return; 
}

/****************************************/
/*             */
/* COMMAND  "PASTE" (Update)  */
/*             */
/****************************************/
void
CEditWnd::OnUpdateGaijiPaste(
CCmdUI* pCmdUI)
{
   UINT  ClipFormat;
   BOOL  BitmapFmt;
   BOOL  PrivateFmt;

   BitmapFmt  = FALSE;
   PrivateFmt = FALSE;
   if( !::OpenClipboard(this->GetSafeHwnd()))
      return;

   for( ClipFormat = 0;;){
         ClipFormat = EnumClipboardFormats( ClipFormat);
         if( ClipFormat == CF_BITMAP){
                  BitmapFmt = TRUE;
                  if( PrivateFmt)   break;
         }
         if( ClipFormat == ClipboardFormat){
                  PrivateFmt = TRUE;
                  if( BitmapFmt) break;
         }
         if( ClipFormat == 0)   break;
      }
      if( !PrivateFmt){
         if( BitmapFmt){
         CloseClipboard();
         pCmdUI->Enable(TRUE);
         return;
         }else{
                  CloseClipboard();
         pCmdUI->Enable(FALSE);
                  return;
         }
      }else{
         if ( !BitmapFmt){
                  CloseClipboard();
         pCmdUI->Enable(FALSE);
                  return;
         }
      }
   CloseClipboard();
   pCmdUI->Enable(FALSE);
}

/****************************************/
/*             */
/* COMMAND     "Delete" */
/*             */
/****************************************/
void
CEditWnd::OnDeleteEdit()
{
   UndoImageDraw();
   BitmapDirty = TRUE;
   if(( SelectItem == RECTCLIP || SelectItem == FREEFORM) &&
        RectClipFlag){
      RectClipFlag = FALSE;
      ToolTerm();
   }
   this->Invalidate( FALSE);
   this->UpdateWindow();
}

/****************************************/
/*             */
/* COMMAND     "Delete"(Update)*/
/*             */
/****************************************/
void
CEditWnd::OnUpdateDeleteEdit(
CCmdUI* pCmdUI)
{
   pCmdUI->Enable( RectClipFlag);   
}

/****************************************/
/*             */
/* Create bitmap for undo     */
/*             */
/****************************************/
BOOL
CEditWnd::CreateUndoBitmap()
{
   HANDLE   BitHandle;
   BYTE  *pBitmap;
   WORD  wSize;

   wSize = (WORD)((( BITMAP_WIDTH + 15) /16) *2) *(WORD)BITMAP_HEIGHT;
   if(( BitHandle = LocalAlloc( LMEM_MOVEABLE, wSize)) == 0)
      return FALSE;

   if(( pBitmap = (BYTE *)LocalLock( BitHandle)) == NULL){
      LocalFree( BitHandle);
      return FALSE;
   }
   memset( pBitmap, 0xffff, wSize);
   if( !UndoImage.CreateBitmap( BITMAP_WIDTH, BITMAP_HEIGHT,
             1, 1, (LPSTR)pBitmap)){
      LocalFree( BitHandle);
      return FALSE;
   }
   LocalUnlock( BitHandle);
   LocalFree( BitHandle);
   return TRUE;   
}

/****************************************/
/*             */
/* Cut image to clipboard     */
/*             */
/****************************************/
BOOL
CEditWnd::ClipImageCut()
{
   CPen   CutPen;
   CBrush CutBrush;

   CutPen.CreateStockObject( NULL_PEN);
   CPen *OldPen = CRTDrawDC.SelectObject( &CutPen);
   CutBrush.CreateSolidBrush( COLOR_WHITE );
      CBrush *OldBrush = CRTDrawDC.SelectObject( &CutBrush);

   ClipRect[BMP].right  += 1;
   ClipRect[BMP].bottom += 1;
      CRTDrawDC.Rectangle( &ClipRect[BMP]);

      CRTDrawDC.SelectObject( OldPen);
      CRTDrawDC.SelectObject( OldBrush);
   CutPen.DeleteObject();
   CutBrush.DeleteObject();
   return TRUE;
}

/****************************************/
/*             */
/* Copy image to clipboard    */
/*             */
/****************************************/
BOOL
CEditWnd::ClipImageCopy()
{
   CBitmap  ClipBmp;
   CDC   ClipDC;
   CRect pRect;

   pRect.SetRect( ClipRect[DSP].left /ZoomRate,
        ( ClipRect[DSP].top - CAPTION_HEIGHT) /ZoomRate,
          ClipRect[DSP].right /ZoomRate,
        ( ClipRect[DSP].bottom - CAPTION_HEIGHT) /ZoomRate);

   ClipDC.CreateCompatibleDC( &ImageDC);
      ClipBmp.CreateCompatibleBitmap( &ImageDC,
         pRect.Width(), pRect.Height());
      CBitmap *OldClip = ClipDC.SelectObject( &ClipBmp);

      ClipDC.PatBlt( 0, 0, pRect.Width(), pRect.Height(), WHITENESS);
      ClipDC.StretchBlt( 0, 0, pRect.Width(), pRect.Height(), &CRTDrawDC,
         ClipRect[BMP].left, ClipRect[BMP].top,
      ClipRect[BMP].Width(), ClipRect[BMP].Height(),SRCCOPY);

      if( !this->OpenClipboard()){
      ClipDC.SelectObject( OldClip);
      ClipBmp.DeleteObject();
         ClipDC.DeleteDC();
         return FALSE;
      }
      EmptyClipboard();

   if( !SetClipboardData( CF_BITMAP, ClipBmp.Detach())){
      ClipDC.SelectObject( OldClip);
      ClipBmp.DeleteObject();
         ClipDC.DeleteDC();
         CloseClipboard();
         return FALSE;
      }
      CloseClipboard();
   ClipDC.SelectObject( OldClip);
   ClipBmp.DeleteObject();
      ClipDC.DeleteDC();
      return TRUE;
}

/****************************************/
/*             */
/* MESSAGE  "WM_PAINT"     */
/*             */
/****************************************/
void
CEditWnd::OnPaint()
{
   CPaintDC dc( this);
   DWORD    OldTextColor;

   this->GetClientRect( &EudcWndRect);

// Set textcolor to gray if fitting curve
   if( FlagTmp)
      OldTextColor = dc.SetTextColor( COLOR_FITTING);
   else  OldTextColor = dc.SetTextColor( COLOR_BLACK);

// Put bitmap data   on display
   ZoomRate = EudcWndRect.right /BITMAP_WIDTH;
   dc.StretchBlt( 0, CAPTION_HEIGHT, EudcWndRect.right,
      EudcWndRect.bottom - CAPTION_HEIGHT,
      &ImageDC, 0, 0, BITMAP_WIDTH, BITMAP_HEIGHT, SRCCOPY);

// Draw selected rectangle if RectClipFlag is build
   if( RectClipFlag){
      dc.StretchBlt( ClipRect[DSP].left - 1, ClipRect[DSP].top - 1,
         ClipRect[DSP].Width(), ClipRect[DSP].Height(),
         &CRTDrawDC, ClipRect[BMP].left, ClipRect[BMP].top,
         ClipRect[BMP].Width(), ClipRect[BMP].Height(), SRCAND);

      DrawMoveRect( &dc);
      DrawStretchRect( &dc);
   }
   dc.SetTextColor( OldTextColor);
   CaptionDraw();

   if( ZoomRate >= 2 && GridShow)
      DrawGridLine( &dc);

   if( FlagTmp)
      CurveFittingDraw( &dc);
}
               
/****************************************/
/*             */
/* MESSAGE  "WM_LBUTTONDOWN"  */
/*             */
/****************************************/
void
CEditWnd::OnLButtonDown(
UINT  ,
CPoint   point)
{
   CRect CaptionRect;
   CPoint   ClickPt;

   if( ButtonFlag == RCLICK){
      this->Invalidate();
      ToolTerm(); 
      return;
   }
   ClickPt = point;
   CaptionRect.CopyRect( &EudcWndRect);
   CaptionRect.top = CAPTION_HEIGHT;
   if( !CaptionRect.PtInRect( point))
      return;

   ToolInit(LCLICK);
// Modurate coordinate
   CorrectMouseDownPoint( point);

// Stretch selected rectangle
   if( RectClipFlag){
      SetClickRect();
      if( ClipRect[PIN].PtInRect( ClickPt) &&
             ( EudcWndRect.Width() > ClipRect[DSP].Width() ||
          EudcWndRect.Height() - CAPTION_HEIGHT
          > ClipRect[DSP].Height())){
            BitmapDirty = TRUE;
      }else if(( CheckNum = CheckClipRect( ClickPt)) != NCHECK){
         BitmapDirty = TRUE;
         SetValidRect();
         RectClipFlag = FALSE;
         this->InvalidateRect( &ClipRect[VLD], FALSE);
         this->UpdateWindow();
         RectClipFlag = TRUE;
         CClientDC   dc( this);
         DrawMoveRect( &dc);
      }else{
         RectClipFlag = FALSE;
         this->InvalidateRect( &ClipRect[VLD], FALSE);
         this->UpdateWindow();
         DrawClipBmp();
         SetPickRect();
         if( SelectItem == RECTCLIP)
            DrawRubberBand( TRUE);
         else{
            CPoint   Sp;

            Sp.x = ptStart.x;
            Sp.y = ptStart.y + CAPTION_HEIGHT;
            m_pointArray.RemoveAll();
            m_SelectArray.RemoveAll();
            m_pointArray.Add( Sp);
            Sp.x = ptStart.x /ZoomRate;
            Sp.y = ptStart.y /ZoomRate;
            m_SelectArray.Add( Sp);

         }
      }
   }else{
      if( SelectItem == PEN || SelectItem == BRUSH ){
         UndoImageDraw();
         BitmapDirty = TRUE;
         DrawPoint( ptStart, FALSE);
      }else if (SelectItem == ERASER){
         UndoImageDraw();
         BitmapDirty = TRUE;
         DrawPoint( ptStart, TRUE);
      }else{
         UndoImageDraw();
         BitmapDirty = TRUE;
         if( SelectItem == FREEFORM){
            CPoint   Sp;

            Sp.x = ptStart.x;
            Sp.y = ptStart.y + CAPTION_HEIGHT;
            m_pointArray.RemoveAll();
            m_SelectArray.RemoveAll();
            m_pointArray.Add( Sp);
            Sp.x = ptStart.x /ZoomRate;
            Sp.y = ptStart.y /ZoomRate;
            m_SelectArray.Add( Sp);
         }else    DrawRubberBand( TRUE);
      }
   }
}

/****************************************/
/*             */
/* MESSAGE  "WM_MOUSEMOVE"    */
/*             */
/****************************************/
void
CEditWnd::OnMouseMove(
UINT  ,
CPoint   point)
{

   if( IsCapture){
//    Modurate coordinate
      CorrectMouseUpPoint( point);
      if( ptPrev.x == ptEnd.x && ptPrev.y == ptEnd.y)
         return;

      if( RectClipFlag){
         if( CheckNum == NCHECK){
            CRect URect, MRect, PRRect;

            if( !MoveClipRect())
               return;
            MRect.SetRect(  ClipRect[DSP].left   - Ratio,
               ClipRect[DSP].top    - Ratio,
               ClipRect[DSP].right  + Ratio,
               ClipRect[DSP].bottom + Ratio);

            PRRect.SetRect( ClipRect[PRV].left   - Ratio,
               ClipRect[PRV].top    - Ratio,
               ClipRect[PRV].right  + Ratio,
               ClipRect[PRV].bottom + Ratio);

            URect.UnionRect( &MRect, &PRRect);
            this->InvalidateRect( &URect, FALSE);
            this->UpdateWindow();

         }else    StretchMoveRect();
      }else{
         if( SelectItem == PEN || SelectItem == BRUSH)
            DrawToPoint(FALSE);
         else if (SelectItem == ERASER)
            DrawToPoint(TRUE);
         else if( SelectItem == FREEFORM){
            DrawFreeForm( FALSE);
            SelectFreeForm(FALSE);
         }else DrawRubberBand( FALSE);
      }
   }
}

/****************************************/
/*             */
/* MESSAGE  "WM_LBUTTONUP"    */
/*             */
/****************************************/
void
CEditWnd::OnLButtonUp(
UINT  ,
CPoint   point)
{
    if (!bFocus)
    {
        bFocus = TRUE;
        CaptionDraw();

        pRefrChild->bFocus = FALSE;
        pRefrChild->CaptionDraw();

    }

   if( IsCapture){
//    Modurate coordinate
      CorrectMouseUpPoint( point);

      if( SelectItem == PEN || SelectItem == BRUSH ||SelectItem == ERASER){
         if( FlagTmp)
            this->Invalidate(FALSE);
         ToolTerm();
         return;
      }

//    draw a figure on bitmap
      if( SelectItem == RECTCLIP && !RectClipFlag){
         SetMoveRect();
         SetPickRect();
         SetValidRect();
         SetClickRect();
         if(( abs( ptEnd.x - ptStart.x) >= ZoomRate*2) &&
            ( abs( ptEnd.y - ptStart.y) >= ZoomRate*2) ){
            CRTDrawDC.BitBlt( ClipRect[BMP].left,
               ClipRect[BMP].top,
               ClipRect[BMP].Width(),
               ClipRect[BMP].Height(),
               &ImageDC, ClipRect[BMP].left,
               ClipRect[BMP].top, SRCCOPY);

            EraseRectangle();
            RectClipFlag = TRUE;
         }
         this->InvalidateRect( &ClipRect[VLD], FALSE);
         this->UpdateWindow();
      }else if( SelectItem == FREEFORM && !RectClipFlag){
         POINT nArray[FREELIAIS];
         POINT pArray[FREELIAIS];
   
         DrawFreeForm( FALSE);
         SelectFreeForm( FALSE);
         DrawFreeForm( TRUE);
         SelectFreeForm( TRUE);

         if( m_pointArray.GetSize()  >= FREELIAIS ||
             m_SelectArray.GetSize() >= FREELIAIS ){
               ToolTerm();
               this->Invalidate(FALSE);
            this->UpdateWindow();
            return;
         }
         for( int i = 0; i < m_pointArray.GetSize(); i++)
            nArray[i] = m_pointArray[i];
         for( i = 0; i < m_SelectArray.GetSize(); i++)
            pArray[i] = m_SelectArray[i];

         if( FreeRgn.GetSafeHandle() != NULL)
            FreeRgn.DeleteObject();
         if( PickRgn.GetSafeHandle() != NULL)
            PickRgn.DeleteObject();
         FreeRgn.CreatePolygonRgn( nArray,
            (int)(m_pointArray.GetSize()), ALTERNATE);
         PickRgn.CreatePolygonRgn( pArray,
            (int)(m_SelectArray.GetSize()), ALTERNATE);

         if( FreeRgn.GetSafeHandle()  == NULL ||
             PickRgn.GetSafeHandle()  == NULL){
            m_pointArray.RemoveAll();
            m_SelectArray.RemoveAll();
            RectClipFlag = FALSE;
         }else{
            RectClipFlag = TRUE;
            if( !SetFreeForm()){
               RectClipFlag = FALSE;
               FreeRgn.DeleteObject();
               PickRgn.DeleteObject();
               SetPickRect();
               SetValidRect();
               SetClickRect();
               ClipRect[PRV].CopyRect( &ClipRect[DSP]);
               this->InvalidateRect( &ClipRect[VLD], FALSE);
               this->UpdateWindow();
            }else{
               EraseFreeForm();
               SetPickRect();
               SetValidRect();
               SetClickRect();
               ClipRect[PRV].CopyRect( &ClipRect[DSP]);
               this->InvalidateRect( &ClipRect[VLD], FALSE);
               this->UpdateWindow();
            }
         }
      }else if( RectClipFlag){
         if( CheckNum != NCHECK){
            DrawStretchClipToDisp();
            CheckNum = NCHECK;
         }else{
            if( !MoveClipRect()){
               ToolTerm();
               return;
            }
         }
         SetValidRect();
         SetClickRect();

         this->InvalidateRect( &ClipRect[VLD], FALSE);
         this->UpdateWindow();
      }else{      
         if( SelectItem != SLOPE)
            IllegalRect( &ptStart, &ptEnd);
         else{
            ptEnd.x = ( ptEnd.x /ZoomRate) *ZoomRate;
            ptEnd.y = ( ptEnd.y /ZoomRate) *ZoomRate;
            ptStart.x = ( ptStart.x /ZoomRate) *ZoomRate;
            ptStart.y = ( ptStart.y /ZoomRate) *ZoomRate;
         }
         DrawRectBmp();
         if( SelectItem == SLOPE)
            IllegalRect( &ptStart, &ptEnd);
         SetMoveRect();
         if( FlagTmp)
            this->Invalidate( FALSE);
         else if( SelectItem != PEN && SelectItem != BRUSH && SelectItem != ERASER){
            this->InvalidateRect( &ClipRect[DSP], FALSE);
         }
      }
      ToolTerm();
   }
}

/****************************************/
/*             */
/* MESSAGE  "WM_RBUTTONDOWN"  */
/*             */
/****************************************/
void
CEditWnd::OnRButtonDown(
UINT  nFlags,
CPoint   point)
{
   CRect CaptionRect;

   if( ButtonFlag == LCLICK){
      this->Invalidate();
      ToolTerm();
      return;
   }
   if( SelectItem == RECTCLIP || SelectItem == FREEFORM){
      ToolTerm();
      return;
   }
   CaptionRect.CopyRect( &EudcWndRect);
   CaptionRect.top = CAPTION_HEIGHT;
   if( !CaptionRect.PtInRect( point))
      return;
   ToolInit(RCLICK);

// Modurate coordinate
   CorrectMouseDownPoint( point);
   UndoImageDraw();
   BitmapDirty = TRUE;
   if( SelectItem == PEN || SelectItem == BRUSH )
      DrawPoint( ptStart, FALSE);
   else if (SelectItem == ERASER)
      DrawPoint( ptStart, TRUE);
   else
      DrawRubberBand( TRUE);  
}

/****************************************/
/*             */
/* MESSAGE  "WM_RBUTTONUP"    */
/*             */
/****************************************/
void
CEditWnd::OnRButtonUp(
UINT  nFlags,
CPoint   point)
{
   if( IsCapture){
      if( SelectItem == PEN || SelectItem == BRUSH || SelectItem == ERASER ||
          SelectItem == RECTCLIP || SelectItem == FREEFORM){
         if( FlagTmp)
            this->Invalidate( FALSE);
         ToolTerm();
         return;
      }
//    Modurate coordinate
      CorrectMouseUpPoint( point);
      DrawRubberBand( TRUE);
      if( SelectItem != SLOPE)
         IllegalRect( &ptStart, &ptEnd);
      else{
         ptEnd.x = ( ptEnd.x /ZoomRate) *ZoomRate;
         ptEnd.y = ( ptEnd.y /ZoomRate) *ZoomRate;
         ptStart.x = ( ptStart.x /ZoomRate) *ZoomRate;
         ptStart.y = ( ptStart.y /ZoomRate) *ZoomRate;
      }

//    Draw a figure on bitmap
      DrawRectBmp();
      if( SelectItem == SLOPE)
         IllegalRect( &ptStart, &ptEnd);
      SetMoveRect();
      if( FlagTmp)
         this->Invalidate( FALSE);
      else  this->InvalidateRect( &ClipRect[DSP], FALSE);
      ToolTerm();
   }
}

/****************************************/
/*             */
/* MESSAGE     "WM_SIZE"   */
/*             */
/****************************************/
void
CEditWnd::OnSize(
UINT  nType,
int   cx,
int   cy)
{
   int   NewZoomRate;

   NewZoomRate = cx / BITMAP_WIDTH;
   if( RectClipFlag && NewZoomRate > 1){
      ClipRect[PRV].left = ( ClipRect[PRV].left /ZoomRate)
         * NewZoomRate;

      ClipRect[PRV].top  = ((( ClipRect[PRV].top - CAPTION_HEIGHT)
         /ZoomRate) * NewZoomRate) + CAPTION_HEIGHT;

      ClipRect[PRV].right = ( ClipRect[PRV].right /ZoomRate)
         * NewZoomRate + 1;

      ClipRect[PRV].bottom = ((( ClipRect[PRV].bottom -CAPTION_HEIGHT)
         / ZoomRate) * NewZoomRate) + CAPTION_HEIGHT + 1;

      ClipRect[DSP].left = ( ClipRect[DSP].left /ZoomRate)
         * NewZoomRate;

      ClipRect[DSP].top = ((( ClipRect[DSP].top - CAPTION_HEIGHT)
         / ZoomRate) * NewZoomRate) + CAPTION_HEIGHT;

      ClipRect[DSP].right = ( ClipRect[DSP].right /ZoomRate)
         * NewZoomRate + 1;

      ClipRect[DSP].bottom = ((( ClipRect[DSP].bottom -CAPTION_HEIGHT)
         / ZoomRate) * NewZoomRate) + CAPTION_HEIGHT + 1;

      SetClickRect();
      SetValidRect();
   }else if( RectClipFlag && NewZoomRate <= 1)
      WriteSelRectBitmap();

   CMDIChildWnd::OnSize(nType, cx, cy);

   this->Invalidate(FALSE);
   this->UpdateWindow();
}

/****************************************/
/*             */
/* MESSAGE     "WM_SETCURSOR"  */
/*             */
/****************************************/
BOOL
CEditWnd::OnSetCursor(
CWnd*    pWnd,
UINT  nHitTest,
UINT  message)
{
   CPoint   point;
   CRect CaptionRect;
   CRect EditRect;
   HCURSOR  hArrowCur;

   GetCursorPos( &point);
   this->ScreenToClient( &point);
   this->GetClientRect( &CaptionRect);
   EditRect.CopyRect( &CaptionRect);
   CaptionRect.bottom = CAPTION_HEIGHT;
   EditRect.top = CAPTION_HEIGHT;

   if(CaptionRect.PtInRect( point)){
      hArrowCur = AfxGetApp()->LoadStandardCursor( IDC_ARROW);
      ::SetCursor( hArrowCur);
   }else if( RectClipFlag && !IsCapture && EditRect.PtInRect( point)){
      if( PickRect[LUPPER].PtInRect( point) ||
          PickRect[RLOWER].PtInRect( point)){
         ::SetCursor((HCURSOR)ArrowCursor[LEFTSLOPE]);
      }else if( PickRect[RUPPER].PtInRect( point) ||
           PickRect[LLOWER].PtInRect( point)){
         ::SetCursor((HCURSOR)ArrowCursor[RIGHTSLOPE]);
      }else if( PickRect[MUPPER].PtInRect( point) ||
           PickRect[MLOWER].PtInRect( point)){
         ::SetCursor((HCURSOR)ArrowCursor[HORIZONTAL]);
      }else if( PickRect[RMIDLE].PtInRect( point) ||
           PickRect[LMIDLE].PtInRect( point)){
         ::SetCursor((HCURSOR)ArrowCursor[VERTICAL]);
      }else if( ClipRect[DSP].PtInRect( point)){
         ::SetCursor((HCURSOR)ArrowCursor[ALLDIRECT]);
      }else ::SetCursor((HCURSOR)ToolCursor[SelectItem]);
   }else if( !IsCapture && EditRect.PtInRect( point))
      ::SetCursor((HCURSOR)ToolCursor[SelectItem]);
   else{
      hArrowCur = AfxGetApp()->LoadStandardCursor( IDC_ARROW);
      ::SetCursor( hArrowCur);
   }  
   return TRUE;
}

/****************************************/
/*             */
/* MESSAGE     "WM_MDIACTIVATE"*/
/*             */
/****************************************/
void
CEditWnd::OnMDIActivate(
BOOL  bActivate,
CWnd*    pActivateWnd,
CWnd*    pDeactivateWnd)
{
   if( bActivate == FALSE){
      if( SelectItem == RECTCLIP || SelectItem == FREEFORM)
         WriteSelRectBitmap();
   }
}

/****************************************/
/*             */
/* MESSAGE     "WM_KEYDOWN"   */
/*             */
/****************************************/
void
CEditWnd::OnKeyDown(
UINT  nChar,
UINT  nRepCnt,
UINT  nFlags)
{
   if( nChar == VK_ESCAPE)
      WriteSelRectBitmap();
   else  CMDIChildWnd::OnKeyDown(nChar, nRepCnt, nFlags);
}

/****************************************/
/*             */
/* Draw Caption         */
/*             */
/****************************************/
void
CEditWnd::CaptionDraw()
{
COLORREF TextColor;
   CString  WndCaption;
   CRect CaptionRect;
   CBrush   CaptionBrush;
   CFont *OldFont;
   int   BkMode;
   CDC    dc;
   dc.Attach( ::GetDC( this->GetSafeHwnd()));

// Get brush with active caption color    
   CaptionRect.CopyRect( &EudcWndRect);
   if (bFocus)
   {
      CaptionBrush.CreateSolidBrush(::GetSysColor(COLOR_ACTIVECAPTION));
   }
   else
   {
      CaptionBrush.CreateSolidBrush(::GetSysColor(COLOR_INACTIVECAPTION));
   }
   CaptionRect.bottom = CAPTION_HEIGHT;
   dc.FillRect( &CaptionRect, &CaptionBrush);
   CaptionBrush.DeleteObject();

// Get font to draw caption
#ifdef BUILD_ON_WINNT
   OldFont = (CFont *)dc.SelectStockObject(DEFAULT_GUI_FONT);
#else
   OldFont = (CFont *)dc.SelectStockObject(SYSTEM_FONT);
#endif
   BkMode = dc.SetBkMode( TRANSPARENT);
   if (bFocus)
   {
      TextColor = dc.SetTextColor( ::GetSysColor(COLOR_CAPTIONTEXT));
   }
   else
   {
      TextColor = dc.SetTextColor( ::GetSysColor(COLOR_INACTIVECAPTIONTEXT));
   }
   WndCaption.LoadString( IDS_EDIT_STR);
   dc.TextOut( EudcWndRect.right /2 - 30, 1, WndCaption);
   dc.SelectObject( OldFont);
   dc.SetTextColor( TextColor);
   dc.SetBkMode( BkMode);
    ::ReleaseDC(NULL, dc.Detach());
}
               
/****************************************/
/*             */
/* Draw Grid line       */
/*             */
/****************************************/
void
CEditWnd::DrawGridLine(
CDC   *dc)
{
   CPen  GlyphPen;
register int   i;

// Create pen to draw grid
   GlyphPen.CreatePen( PS_SOLID, 1, COLOR_GRID);
   CPen *OldPen = dc->SelectObject( &GlyphPen);

// Draw grid
   for( i = ZoomRate - 1; i < EudcWndRect.right; i += ZoomRate){
      dc->MoveTo( i, CAPTION_HEIGHT-1);
      dc->LineTo( i, EudcWndRect.bottom);
   }
   for( i =ZoomRate +CAPTION_HEIGHT -1;i<EudcWndRect.bottom;i += ZoomRate){
      dc->MoveTo( 0, i);
      dc->LineTo( EudcWndRect.right, i);
   }
   dc->SelectObject( OldPen);
   GlyphPen.DeleteObject();
}

/****************************************/
/*             */
/* Draw OutLine         */
/*             */
/****************************************/
BOOL
CEditWnd::CurveFittingDraw(
CDC*  dc)
{
struct VHEAD   *vhd;
struct VDATA   *vp;
   CPen  CurvePen;
   CPoint   DrawPt;
   LPBYTE   pBuf;
   int   pcnt, TmpHdl, SetHdl;

   SetHdl = MKOUTHDL;

   DWORD wSize = (WORD)((( BITMAP_WIDTH +15)/16)*2)*(WORD)BITMAP_HEIGHT;
   pBuf = (LPBYTE)malloc(((( BITMAP_WIDTH +15) /16) *2) *BITMAP_HEIGHT);
   if( pBuf == NULL){
      return FALSE;
   }
   ImageBmp.GetBitmapBits( wSize, (LPVOID)pBuf);

   OInit();
   VDNew( SetHdl);
   if(( TmpHdl = OMakeOutline((LPBYTE)pBuf,
        BITMAP_WIDTH,SMOOTHLVL)) < 0){
      free( pBuf);
      OTerm();
      return FALSE;
   }
   if( MkPoly( TmpHdl, SetHdl) < 0){
      free( pBuf);
      OTerm();
      return FALSE;
   }

   VDGetHead( SetHdl, &vhd);
   if( VDGetNCont( SetHdl) > 0){
      CurvePen.CreatePen( PS_SOLID, 1, COLOR_CURVE);
      CPen *OldPen = dc->SelectObject( &CurvePen);
      CBrush *OldBrush = (CBrush *)dc->SelectStockObject( NULL_BRUSH);

      while ( vhd->next != NIL){
         vp = vhd->headp;
         pcnt = vhd->nPoints - 1;
         ZoomPoint( &DrawPt, vp->vd.x, vp->vd.y);
         dc->MoveTo( DrawPt.x, DrawPt.y);
         vp = vp->next;
         while( pcnt-- > 0){
            ZoomPoint( &DrawPt, vp->vd.x, vp->vd.y);
            dc->LineTo( DrawPt.x, DrawPt.y);
            vp = vp->next;
         }
         vhd = vhd->next;
      }
      dc->SelectObject( OldBrush);
      dc->SelectObject( OldPen);
      CurvePen.DeleteObject();
   }
   OTerm();
   free( pBuf);

   return TRUE;
}

/****************************************/
/*             */
/* Zoom coordinate of outline */
/*             */
/****************************************/
void
CEditWnd::ZoomPoint(
CPoint   *DrawPt,
int   x,
int   y)
{
   DWORD px, py;

   px = (DWORD)(x * EudcWndRect.right);
   py = (DWORD)(y * (EudcWndRect.bottom - CAPTION_HEIGHT));
   DrawPt->x = (int)( px/(BITMAP_WIDTH *4));
   DrawPt->y = (int)( py/(BITMAP_HEIGHT*4)) + CAPTION_HEIGHT;
}

/****************************************/
/*             */
/* Draw MoveRect rectangle    */
/*             */
/****************************************/
void
CEditWnd::DrawMoveRect(
CDC   *dc)
{
   CPen  *OldPen;
   CBrush   *OldBrush;

   OldPen = (CPen *)dc->SelectStockObject( BLACK_PEN);
   OldBrush = (CBrush *)dc->SelectStockObject( NULL_BRUSH);
   int OldMode = dc->SetROP2( R2_NOTXORPEN);

   dc->Rectangle( &ClipRect[DSP]);

   dc->SelectObject( OldPen);
   dc->SelectObject( OldBrush);
   dc->SetROP2( OldMode);
}

/****************************************/
/*             */
/* Draw clipping rectangle    */
/*             */
/****************************************/
void
CEditWnd::DrawStretchRect(
CDC   *dc)
{
   CPen  *OldPen;
   CBrush   *OldBrush;
   int   Left, Top;
   int   Right, Bottom;

   OldPen = (CPen *)dc->SelectStockObject( BLACK_PEN);
   OldBrush = (CBrush *)dc->SelectStockObject( BLACK_BRUSH);

   for( int i = 0; i < 8; i++){
//    Set left and right side of PickRect[]
      if( i == LUPPER || i == LLOWER || i == LMIDLE){
         Left  = ClipRect[DSP].left - Ratio;
         Right = ClipRect[DSP].left + Ratio;
      }else if( i == RUPPER || i == RLOWER || i == RMIDLE){
         Left  = ClipRect[DSP].right - Ratio;
         Right = ClipRect[DSP].right + Ratio;
      }else{
         Left  = ClipRect[DSP].left + ClipRect[DSP].Width()/2
            - Ratio;
         Right = ClipRect[DSP].left + ClipRect[DSP].Width()/2
            + Ratio;
      }

//    Set top and bottom side of PickRect[]
      if( i == LUPPER || i == RUPPER || i == MUPPER){
         Top    = ClipRect[DSP].top - Ratio;
         Bottom = ClipRect[DSP].top + Ratio;
      }else if( i == RMIDLE || i == LMIDLE){
         Top    = ClipRect[DSP].top + ClipRect[DSP].Height()/2
            - Ratio;
         Bottom = ClipRect[DSP].top + ClipRect[DSP].Height()/2
            + Ratio;
      }else{
         Top    = ClipRect[DSP].bottom - Ratio;
         Bottom = ClipRect[DSP].bottom + Ratio;
      }
      PickRect[i].SetRect( Left, Top, Right, Bottom);
      dc->InvertRect( &PickRect[i]);
   }
   dc->SelectObject( OldPen);
   dc->SelectObject( OldBrush);
}

/****************************************/
/*             */
/* Write Selected Rectangle   */
/*             */ 
/****************************************/
void           
CEditWnd::WriteSelRectBitmap()
{
   if( RectClipFlag){
      RectClipFlag = FALSE;
      DrawClipBmp();
      ToolTerm();
   }
}

/****************************************/
/*             */
/* Modurate coordinate     */
/*             */
/****************************************/
void
CEditWnd::CorrectMouseDownPoint(
CPoint   point)
{
   ptStart.x = point.x;
   ptStart.y = point.y - CAPTION_HEIGHT;
   if( ptStart.y < 0)
      ptStart.y = 0;

   if( SelectItem == FREEFORM){
      ptStart.x = (( ptStart.x + ZoomRate/2) /ZoomRate) *ZoomRate;
      ptStart.y = (( ptStart.y + ZoomRate/2) /ZoomRate) *ZoomRate;
   }else if( SelectItem != SLOPE){
      ptStart.x = ( ptStart.x /ZoomRate) *ZoomRate;
      ptStart.y = ( ptStart.y /ZoomRate) *ZoomRate;
   }else{
      ptStart.x = ( ptStart.x /ZoomRate) *ZoomRate +ZoomRate /2;
      ptStart.y = ( ptStart.y /ZoomRate) *ZoomRate +ZoomRate /2;
   }
   if( SelectItem == RECTBAND || SelectItem == RECTFILL   ||
       SelectItem == CIRCLE   || SelectItem == CIRCLEFILL ){
      if( ptStart.x > EudcWndRect.right - ZoomRate)
         ptStart.x -= ZoomRate;
      if( ptStart.y > EudcWndRect.bottom - CAPTION_HEIGHT - ZoomRate)
         ptStart.y -= ZoomRate;
      ptEnd.x = ptPrev.x = ptStart.x + ZoomRate;
      ptEnd.y = ptPrev.y = ptStart.y + ZoomRate;
   }else ptEnd = ptPrev = ptStart;
}

/****************************************/
/*             */
/* Modurate coordinate     */
/*             */
/****************************************/
void
CEditWnd::CorrectMouseUpPoint(
CPoint   point)
{
   ptPrev = ptEnd;
   ptEnd.x = point.x;
   ptEnd.y = point.y - CAPTION_HEIGHT;

   if( ptEnd.x < 0)  ptEnd.x = 0;
   if( ptEnd.y < 0)  ptEnd.y = 0;
   if( ptEnd.x > EudcWndRect.right){
      if( SelectItem == BRUSH)
         ptEnd.x = EudcWndRect.right - ZoomRate*2;
      else if( SelectItem == FREEFORM)
         ptEnd.x = EudcWndRect.right;
      else
         ptEnd.x = EudcWndRect.right - ZoomRate;
   }
   if( ptEnd.y > EudcWndRect.bottom - CAPTION_HEIGHT){
      if( SelectItem == BRUSH)
         ptEnd.y = EudcWndRect.bottom - CAPTION_HEIGHT
            - ZoomRate*2;
      else if( SelectItem == FREEFORM)
         ptEnd.y = EudcWndRect.bottom - CAPTION_HEIGHT;
      else
         ptEnd.y = EudcWndRect.bottom - CAPTION_HEIGHT
            - ZoomRate;
   }
   if( SelectItem == FREEFORM){
      ptEnd.x = (( ptEnd.x + ZoomRate/2) /ZoomRate) *ZoomRate ;
      ptEnd.y = (( ptEnd.y + ZoomRate/2) /ZoomRate) *ZoomRate ;
   }else if( SelectItem != SLOPE){
      ptEnd.x = ( ptEnd.x /ZoomRate)*ZoomRate;
      ptEnd.y = ( ptEnd.y /ZoomRate)*ZoomRate;
   }else{
      ptEnd.x = ( ptEnd.x /ZoomRate) *ZoomRate + ZoomRate /2;
      ptEnd.y = ( ptEnd.y /ZoomRate) *ZoomRate + ZoomRate /2;
   }
   if( SelectItem == RECTBAND || SelectItem == RECTFILL   ||
       SelectItem == CIRCLE   || SelectItem == CIRCLEFILL ){
      if( ptEnd.x - ptStart.x <= ZoomRate &&
         ptEnd.x - ptStart.x >= 0)
         ptEnd.x = ptStart.x + ZoomRate;
      if( ptStart.x - ptEnd.x <= ZoomRate &&
         ptStart.x - ptEnd.x > 0)
         ptEnd.x = ptStart.x - ZoomRate;
      if( ptStart.y - ptEnd.y <= ZoomRate &&
         ptStart.y - ptEnd.y > 0)
         ptEnd.y = ptStart.y - ZoomRate;
      if( ptEnd.y - ptStart.y <= ZoomRate &&
         ptEnd.y -ptStart.y >= 0)
         ptEnd.y = ptStart.y + ZoomRate;
   }
}

/****************************************/
/*             */
/* Move Selected Rectangle    */
/*             */
/****************************************/
BOOL
CEditWnd::MoveClipRect()
{
   int   Movex, Movey;
   int   Wid, High;
   BOOL  sts;

   sts = TRUE;
   ClipRect[PRV].CopyRect( &ClipRect[DSP]);

// Boundary condition
   Movex = ptEnd.x - ptPrev.x;
   Movey = ptEnd.y - ptPrev.y;
   Wid  = ClipRect[DSP].Width();
   High = ClipRect[DSP].Height();
   ClipRect[DSP].OffsetRect( Movex, Movey);

   if( ClipRect[DSP].left < 0){
      ClipRect[DSP].left = 0;
      ClipRect[DSP].right = Wid;
   }
   if( ClipRect[DSP].right > EudcWndRect.right){
      ClipRect[DSP].right = EudcWndRect.right + 1;
      ClipRect[DSP].left  = ClipRect[DSP].right - Wid;
   }
   if( ClipRect[DSP].top < CAPTION_HEIGHT){
      ClipRect[DSP].top = CAPTION_HEIGHT;
      ClipRect[DSP].bottom = CAPTION_HEIGHT +High;
   }
   if( ClipRect[DSP].bottom > EudcWndRect.bottom){
      ClipRect[DSP].bottom = EudcWndRect.bottom +1;
      ClipRect[DSP].top = ClipRect[DSP].bottom - High;
   }
   if( ClipRect[PRV].EqualRect( &ClipRect[DSP])){
      sts = FALSE;
   }
   return sts;
}

/************************************************/
/*                */
/* whether point is in rectangle or not   */
/*                */
/************************************************/
int
CEditWnd::CheckClipRect(
POINT    ClipPoint)
{
   for( int i = 0; i < 8; i++){
      if( PickRect[i].PtInRect( ClipPoint))
         return i;
   }
   return NCHECK;
}

/****************************************/
/*             */
/* Process to stretch rectangle  */
/*             */
/****************************************/
BOOL
CEditWnd::DrawStretchClipToDisp()
{
   CDC   SwapDC;
   CBitmap  SwapBmp;
   CRect SwapRect;
            
   CClientDC   dc( this);

   if( !SwapDC.CreateCompatibleDC( &dc))
      return FALSE;

   if( !SwapBmp.CreateCompatibleBitmap( &SwapDC, EudcWndRect.Width(),
            EudcWndRect.Height()))
      return FALSE;
   CBitmap *OldBitmap = SwapDC.SelectObject( &SwapBmp);

   SwapRect.CopyRect( &ClipRect[DSP]);
   if( EudcWndRect.right < SwapRect.right)
      SwapRect.right -= 1;
   if( EudcWndRect.bottom < SwapRect.bottom)
      SwapRect.bottom -= 1;
   
   SwapDC.StretchBlt( SwapRect.left, SwapRect.top,
         SwapRect.Width(), SwapRect.Height(),
         &CRTDrawDC, ClipRect[BMP].left, ClipRect[BMP].top,
         ClipRect[BMP].Width(), ClipRect[BMP].Height(),
         SRCCOPY);

   SetPickRect();
   CRTDrawDC.StretchBlt( ClipRect[BMP].left, ClipRect[BMP].top,
      ClipRect[BMP].Width(), ClipRect[BMP].Height(),
      &SwapDC, SwapRect.left, SwapRect.top,
      SwapRect.Width(), SwapRect.Height(), SRCCOPY);

   SwapDC.SelectObject( OldBitmap);
   SwapBmp.DeleteObject();
   SwapDC.DeleteDC();

   return TRUE;
}

/****************************************/
/*             */
/* Draw select rectangle to bitmap  */
/*             */
/****************************************/
void
CEditWnd::DrawClipBmp()
{
   CRect pRect;

   pRect.SetRect(( ClipRect[DSP].left + 1) /ZoomRate,
       ( ClipRect[DSP].top - CAPTION_HEIGHT + 1) /ZoomRate,
       ( ClipRect[DSP].right + 1)/ZoomRate,
       ( ClipRect[DSP].bottom - CAPTION_HEIGHT + 1) /ZoomRate);

   ImageDC.StretchBlt( pRect.left, pRect.top,
         pRect.Width(), pRect.Height(), &CRTDrawDC,
         ClipRect[BMP].left, ClipRect[BMP].top,
      ClipRect[BMP].Width(), ClipRect[BMP].Height(), SRCAND);
   SetValidRect();
   this->InvalidateRect( &ClipRect[VLD], FALSE);
   this->UpdateWindow();
}

/****************************************/
/*             */
/* Set size of clipping rectangle   */
/*             */
/****************************************/
void
CEditWnd::SetPickRect()
{
   ClipRect[BMP].SetRect( ClipRect[DSP].left /ZoomRate,
      ( ClipRect[DSP].top - CAPTION_HEIGHT) /ZoomRate,
        ClipRect[DSP].right /ZoomRate,
      ( ClipRect[DSP].bottom - CAPTION_HEIGHT) /ZoomRate);
}

/****************************************/
/*             */
/* Set size of clipping rectangle   */
/*             */
/****************************************/
void
CEditWnd::SetMoveRect()
{
   IllegalRect( &ptStart, &ptEnd);

   ClipRect[DSP].SetRect( ptStart.x, ptStart.y + CAPTION_HEIGHT,
      ptEnd.x + ZoomRate + 1,
      ptEnd.y + ZoomRate + 1 + CAPTION_HEIGHT);
   ClipRect[PRV].CopyRect( &ClipRect[DSP]);
}

/****************************************/
/*             */
/* Set size of clipping rectangle   */
/*             */
/****************************************/
void
CEditWnd::SetValidRect()
{
   ClipRect[VLD].SetRect( ClipRect[DSP].left - Ratio,
      ClipRect[DSP].top - Ratio,
      ClipRect[DSP].right + Ratio,
      ClipRect[DSP].bottom + Ratio);
}

/****************************************/
/*             */
/* Set size of clipping rectangle   */
/*             */
/****************************************/
void
CEditWnd::SetClickRect()
{
   ClipRect[PIN].SetRect( ClipRect[DSP].left + Ratio,
      ClipRect[DSP].top + Ratio,
      ClipRect[DSP].right - Ratio,
      ClipRect[DSP].bottom - Ratio);
}

/****************************************/
/*             */
/* Draw a figure to bitmap    */
/*             */
/****************************************/
void
CEditWnd::DrawRectBmp()
{
   CPen  *OldPen;
   CBrush   *OldBrush;
   CRect    BRect;
   CPoint   ptLT;
   CPoint   ptRB;

   ptLT.x = ptStart.x /ZoomRate;
   ptLT.y = ptStart.y /ZoomRate;
   ptRB.x = ptEnd.x   /ZoomRate;
   ptRB.y = ptEnd.y   /ZoomRate;
   
   if( ButtonFlag == LCLICK)
      OldPen = (CPen *)ImageDC.SelectStockObject( BLACK_PEN);
   else  OldPen = (CPen *)ImageDC.SelectStockObject( WHITE_PEN);

   if( SelectItem == RECTBAND || SelectItem == CIRCLE)
      OldBrush = (CBrush *)ImageDC.SelectStockObject( NULL_BRUSH);
   else if( ButtonFlag == LCLICK)
      OldBrush = (CBrush *)ImageDC.SelectStockObject( BLACK_BRUSH);
   else  OldBrush = (CBrush *)ImageDC.SelectStockObject( WHITE_BRUSH);

   BRect.SetRect( ptLT.x, ptLT.y, ptRB.x +1, ptRB.y +1);
   if( SelectItem == CIRCLE || SelectItem == CIRCLEFILL)
      ImageDC.Ellipse( &BRect);
   else if( SelectItem == RECTBAND || SelectItem == RECTFILL)
      ImageDC.Rectangle( &BRect);
   else{
      ImageDC.MoveTo( ptLT);
      ImageDC.LineTo( ptRB);
      if (SelectItem == ERASER)
         DrawPoint( ptEnd, TRUE);
      else
         DrawPoint( ptEnd, FALSE);
   }
   ImageDC.SelectObject( OldPen);
   ImageDC.SelectObject( OldBrush);
}

/****************************************/
/*             */
/* Draw 1Point       */
/*             */
/****************************************/
void
CEditWnd::DrawPoint( CPoint Pt, BOOL bErase)
{
   CBrush   PointBrush,*OldBrush1, *OldBrush2;
   CPoint   W;
   int   Wstep, i, j;
         
   CClientDC   dc( this);
   if( ButtonFlag == LCLICK && !bErase){
      if( FlagTmp)
         PointBrush.CreateSolidBrush( COLOR_FITTING);
      else  PointBrush.CreateSolidBrush( COLOR_BLACK);
   }else PointBrush.CreateSolidBrush( COLOR_WHITE);
   
   OldBrush1 = dc.SelectObject( &PointBrush);
   

   W = Pt;
   Wstep = ZoomRate;
   if( ZoomRate > 1 && GridShow)
      Wstep -= 1;
   for( i = 0; i < BrushWidth; i++, W.x += ZoomRate){
      W.y = Pt.y;
      for( j = 0; j < BrushWidth; j++ , W.y += ZoomRate)
         dc.PatBlt( W.x, W.y+CAPTION_HEIGHT,Wstep,Wstep,PATCOPY);
   }
   dc.SelectObject( OldBrush1);
   PointBrush.DeleteObject();
   
   if( ButtonFlag == LCLICK && !bErase)
      OldBrush2 = (CBrush *)ImageDC.SelectStockObject(BLACK_BRUSH);
   else  OldBrush2 = (CBrush *)ImageDC.SelectStockObject(WHITE_BRUSH);

   W.x = Pt.x /ZoomRate;
   W.y = Pt.y /ZoomRate;
   if( W.x < BITMAP_WIDTH && W.y < BITMAP_HEIGHT)
      ImageDC.PatBlt( W.x, W.y, BrushWidth, BrushWidth, PATCOPY);
   ImageDC.SelectObject( OldBrush2);
   
}

/****************************************/
/*             */
/* Degital differencial analyzer */
/*             */
/****************************************/
void
CEditWnd::DrawToPoint(BOOL bErase)
{
   CPoint   Pt, Start, End, Inc;
   int   Xf, Yf;
   int   Inc1, Inc2;
   int   Dx, Dy,  D, Tmp;
   BOOL  Slope;

   End.x = Xf = ptEnd.x /ZoomRate;
   End.y = Yf = ptEnd.y /ZoomRate;
   Start.x = ptPrev.x   /ZoomRate;
   Start.y = ptPrev.y   /ZoomRate;

   if( Xf >= Start.x)
      Inc.x = 1;
   else  Inc.x = -1;
   if( Yf >= Start.y)
      Inc.y = 1;
   else  Inc.y = -1;

   Dx = ( Xf - Start.x)*Inc.x;
   Dy = ( Yf - Start.y)*Inc.y;
   if( !Dx && !Dy)   return;
   if( Dx < Dy){
      Tmp = Dy;
      Dy = Dx;
      Dx = Tmp;
      Tmp = Inc.x;
      Inc.x = Inc.y;
      Inc.y = Tmp;
      Slope = TRUE;
   }else   Slope = FALSE;

   Inc1 = Dy*2;
   Inc2 = (Dy - Dx)*2;
   D = Inc1 - Dx;
   End.x = Start.x;
   End.y = Start.y;  
   while(1){
      Pt.x = End.x *ZoomRate;
      Pt.y = End.y *ZoomRate;
      DrawPoint( Pt, bErase);
      if( End.x == Xf && End.y == Yf)
         break;
      if( Slope){
         Tmp = End.x;
         End.x = End.y;
         End.y = Tmp;
      }
      End.x += Inc.x;
      if( D < 0)  D += Inc1;
      else{
         End.y += Inc.y;
         D += Inc2;
      }
      if( Slope){
         Tmp = End.x;
         End.x = End.y;
         End.y = Tmp;
      }
   }
}

/****************************************/
/*             */
/* Initialize tool width and color */
/*             */
/****************************************/
void
CEditWnd::ToolInit(
int   LRButton)
{
   this->SetCapture();
   ButtonFlag = LRButton;
   IsCapture = TRUE;
   if( SelectItem == PEN || SelectItem == SLOPE)
      BrushWidth = 1;
   else if( SelectItem == BRUSH || SelectItem == ERASER)
      BrushWidth = 2;
}

/****************************************/
/*             */ 
/* Rubberband stretch mode    */
/*             */
/****************************************/
void
CEditWnd::StretchMoveRect()
{
   CPen  *OldPen;
   CBrush   *OldBrush;
   int   Left, Top, Right, Bottom;

   CClientDC   dc( this);

   OldPen   = (CPen *)dc.SelectStockObject( BLACK_PEN);
   OldBrush = (CBrush *)dc.SelectStockObject( NULL_BRUSH);
   int OldMode = dc.SetROP2( R2_NOTXORPEN);
   dc.Rectangle( &ClipRect[PRV]);

   Left   = ClipRect[DSP].left;
   Top    = ClipRect[DSP].top;
   Right  = ClipRect[DSP].right;
   Bottom = ClipRect[DSP].bottom;
   switch( CheckNum){
      case RLOWER:
         ClipRect[DSP].SetRect( Left, Top,
            ptEnd.x + ZoomRate + 1,
            ptEnd.y + CAPTION_HEIGHT + ZoomRate + 1);

         if( ClipRect[DSP].Height() < ZoomRate*2)
            ClipRect[DSP].bottom = ClipRect[DSP].top
               + ZoomRate*2+1;

         if( ClipRect[DSP].Width() < ZoomRate*2)
            ClipRect[DSP].right = ClipRect[DSP].left
               + ZoomRate*2+1;
         break;
      case RMIDLE:
         ClipRect[DSP].SetRect( Left, Top,
               ptEnd.x + ZoomRate + 1, Bottom);

         if( ClipRect[DSP].Width() < ZoomRate*2)
            ClipRect[DSP].right = ClipRect[DSP].left
               + ZoomRate*2+1;
         break;
      case MLOWER:
         ClipRect[DSP].SetRect( Left, Top,
            Right, ptEnd.y + CAPTION_HEIGHT + ZoomRate + 1);

         if( ClipRect[DSP].Height() < ZoomRate*2)
            ClipRect[DSP].bottom = ClipRect[DSP].top
               + ZoomRate*2+1;
         break;
      case RUPPER:
         ClipRect[DSP].SetRect( Left, ptEnd.y + CAPTION_HEIGHT,
               ptEnd.x + ZoomRate + 1, Bottom);

         if( ClipRect[DSP].Height() < ZoomRate*2)
            ClipRect[DSP].top = ClipRect[DSP].bottom
               - ZoomRate*2+1;
         if( ClipRect[DSP].Width() < ZoomRate*2)
            ClipRect[DSP].right = ClipRect[DSP].left
               + ZoomRate*2+1;
         break;
      case LLOWER:
         ClipRect[DSP].SetRect( ptEnd.x, Top,
            Right, ptEnd.y + CAPTION_HEIGHT + ZoomRate + 1);

         if( ClipRect[DSP].Width() < ZoomRate*2)
            ClipRect[DSP].left = ClipRect[DSP].right
               - ZoomRate*2+1;
         if( ClipRect[DSP].Height() < ZoomRate*2)
            ClipRect[DSP].bottom = ClipRect[DSP].top
               + ZoomRate*2+1;
         break;
      case LMIDLE:
         ClipRect[DSP].SetRect( ptEnd.x, Top, Right, Bottom);

         if( ClipRect[DSP].Width() < ZoomRate*2)
            ClipRect[DSP].left = ClipRect[DSP].right
               - ZoomRate*2+1;
         break;
      case MUPPER:
         ClipRect[DSP].SetRect( Left, ptEnd.y + CAPTION_HEIGHT,
                  Right, Bottom);

         if( ClipRect[DSP].Height() < ZoomRate*2)
            ClipRect[DSP].top = ClipRect[DSP].bottom
               - ZoomRate*2+1;
         break;
      case LUPPER:
         ClipRect[DSP].SetRect( ptEnd.x,
            ptEnd.y + CAPTION_HEIGHT, Right, Bottom);

         if( ClipRect[DSP].Height() < ZoomRate*2)
            ClipRect[DSP].top = ClipRect[DSP].bottom
               - ZoomRate*2+1;
         if( ClipRect[DSP].Width() < ZoomRate*2)
            ClipRect[DSP].left = ClipRect[DSP].right
               - ZoomRate*2+1;
         break;
      default:
         break;
   }
   ClipRect[PRV].CopyRect( &ClipRect[DSP]);
   dc.Rectangle( &ClipRect[DSP]);
   dc.SelectObject( OldPen);
   dc.SelectObject( OldBrush);
   dc.SetROP2( OldMode);
}

/****************************************/
/*             */
/*       FreeForm       */
/*             */
/****************************************/
void
CEditWnd::SelectFreeForm(
BOOL  MouseSts)
{
   CPoint   Ep, Sp, Cp;
   CPoint   Fp, Inc;
   CPoint   Dp, Err;
   BOOL  Slope;
   int   D;
   int   Tmp;

   if( !MouseSts){
      Sp.x = ptPrev.x /ZoomRate;
      Sp.y = ptPrev.y /ZoomRate;
      Ep.x = Fp.x = ptEnd.x /ZoomRate;
      Ep.y = Fp.y = ptEnd.y /ZoomRate;
   }else{
      Sp.x = ptEnd.x /ZoomRate;
      Sp.y = ptEnd.y /ZoomRate;
      Ep.x = Fp.x = ptStart.x /ZoomRate;
      Ep.y = Fp.y = ptStart.y /ZoomRate;
   }

   if( Fp.x >= Sp.x)
      Inc.x = 1;
   else  Inc.x = -1;
   if( Fp.y >= Sp.y)
      Inc.y = 1;
   else  Inc.y = -1;

   Dp.x = ( Fp.x - Sp.x)*Inc.x;
   Dp.y = ( Fp.y - Sp.y)*Inc.y;
   if( !Dp.x && !Dp.y)  return;
   if( Dp.x < Dp.y){
      Tmp = Dp.y;
      Dp.y = Dp.x;
      Dp.x = Tmp;
      Tmp = Inc.x;
      Inc.x = Inc.y;
      Inc.y = Tmp;
      Slope = TRUE;
   }else   Slope = FALSE;

   Err.x = Dp.y * 2;
   Err.y = ( Dp.y - Dp.x) * 2;
   D = Err.x - Dp.x;
   Ep = Sp;
   while(1){
      m_SelectArray.Add( Ep);
      if( Ep.x == Fp.x && Ep.y == Fp.y)
         break;
      if( Slope){
         Tmp = Ep.x;
         Ep.x = Ep.y;
         Ep.y = Tmp;
      }
      Ep.x += Inc.x;
      if( D < 0)  D += Err.x;
      else{
         Ep.y += Inc.y;
         D += Err.y;
      }
      if( Slope){
         Tmp = Ep.x;
         Ep.x = Ep.y;
         Ep.y = Tmp;
      }
   }
}

/****************************************/
/*             */
/*       FreeForm       */
/*             */
/****************************************/
void
CEditWnd::DrawFreeForm(
BOOL  MouseSts)
{
   CPoint   Ep, Sp, Cp;
   CPoint   Fp, Inc;
   CPoint   Dp, Err;
   CPoint   P1, P2;
   BOOL  Slope;
   int   D;
   int   Tmp;

   CClientDC   dc( this);

   CPen  *OldPen = (CPen *)dc.SelectStockObject( BLACK_PEN);
   int OldMode = dc.SetROP2( R2_NOTXORPEN);

   if( !MouseSts){
      Sp.x = ptPrev.x;
      Sp.y = ptPrev.y + CAPTION_HEIGHT;
      Ep.x = Fp.x = ptEnd.x;
      Ep.y = Fp.y = ptEnd.y + CAPTION_HEIGHT;
   }else{
      Sp.x = ptEnd.x;
      Sp.y = ptEnd.y + CAPTION_HEIGHT;
      Ep.x = Fp.x = ptStart.x;
      Ep.y = Fp.y = ptStart.y + CAPTION_HEIGHT;
   }
   if( Fp.x >= Sp.x)
      Inc.x = ZoomRate;
   else  Inc.x = 0 - ZoomRate;
   if( Fp.y >= Sp.y)
      Inc.y = ZoomRate;
   else  Inc.y = 0 - ZoomRate;

   Dp.x = ( Fp.x - Sp.x)*Inc.x;
   Dp.y = ( Fp.y - Sp.y)*Inc.y;
   if( !Dp.x && !Dp.y)  return;
   if( Dp.x < Dp.y){
      Tmp = Dp.y;
      Dp.y = Dp.x;
      Dp.x = Tmp;
      Tmp = Inc.x;
      Inc.x = Inc.y;
      Inc.y = Tmp;
      Slope = TRUE;
   }else   Slope = FALSE;

   Err.x = Dp.y * 2;
   Err.y = ( Dp.y - Dp.x) * 2;
   D = Err.x - Dp.x;
   Ep = Sp;
   dc.MoveTo( Sp);
   while(1){
      if( Sp.x != Ep.x && Sp.y != Ep.y){
         if( Sp.y < Ep.y && Sp.x > Ep.x){
            Cp.x = Sp.x;
            Cp.y = Ep.y;
         }else if( Sp.y < Ep.y && Sp.x < Ep.x){
            Cp.x = Sp.x;
            Cp.y = Ep.y;
         }else if( Sp.y > Ep.y && Sp.x > Ep.x){
            Cp.y = Sp.y;
            Cp.x = Ep.x;
         }else{
            Cp.y = Sp.y;
            Cp.x = Ep.x;
         }
         dc.LineTo( Cp);
         dc.LineTo( Ep);
         P1 = Cp;
         P2 = Ep;
         m_pointArray.Add( P1);
         m_pointArray.Add( P2);
      }else if( Sp.x != Ep.x || Sp.y != Ep.y){
         dc.LineTo( Ep);
         P1 = Ep;
         m_pointArray.Add( P1);
      }
      Sp.x = Ep.x;
      Sp.y = Ep.y;
      if( Ep.x == Fp.x && Ep.y == Fp.y)
         break;
      if( Slope){
         Tmp = Ep.x;
         Ep.x = Ep.y;
         Ep.y = Tmp;
      }
      Ep.x += Inc.x;
      if( D < 0)  D += Err.x;
      else{
         Ep.y += Inc.y;
         D += Err.y;
      }
      if( Slope){
         Tmp = Ep.x;
         Ep.x = Ep.y;
         Ep.y = Tmp;
      }
   }
   dc.SelectObject( OldPen);
   dc.SetROP2( OldMode);
}

/****************************************/
/*             */
/*   Rubber Band( rectangle and circle)   */
/*             */
/****************************************/
void
CEditWnd::DrawRubberBand(
BOOL  StretchFlag)
{
   CRect RubberBandRect;
   CPoint   ptLT, ptRB;
   int   OldMode;

   CClientDC   dc( this);

   CPen  *OldPen   = (CPen *)dc.SelectStockObject( BLACK_PEN);
   CBrush   *OldBrush = (CBrush *)dc.SelectStockObject( NULL_BRUSH);
   OldMode = dc.SetROP2( R2_NOTXORPEN);

   if( !StretchFlag){
      ptLT.x = ptStart.x;
      ptLT.y = ptStart.y + CAPTION_HEIGHT;
      ptRB.x = ptPrev.x;
      ptRB.y = ptPrev.y  + CAPTION_HEIGHT;
      if( SelectItem != SLOPE)
         IllegalRect( &ptLT, &ptRB);
      RubberBandRect.SetRect( ptLT.x, ptLT.y,
         ptRB.x + ZoomRate + 1, ptRB.y + ZoomRate + 1);
      if( SelectItem == SLOPE){
         dc.MoveTo( ptLT);
         dc.LineTo( ptRB);
      }else if( SelectItem == CIRCLE || SelectItem == CIRCLEFILL)
         dc.Ellipse( &RubberBandRect);
      else  dc.Rectangle( &RubberBandRect);
   }
   ptLT.x = ptStart.x;
   ptLT.y = ptStart.y + CAPTION_HEIGHT;
   ptRB.x = ptEnd.x;
   ptRB.y = ptEnd.y + CAPTION_HEIGHT;
   ptPrev = ptRB;
   if( SelectItem != SLOPE)
      IllegalRect( &ptLT, &ptRB);
      RubberBandRect.SetRect( ptLT.x, ptLT.y,
         ptRB.x + ZoomRate + 1, ptRB.y + ZoomRate + 1);
   if( SelectItem == SLOPE){
      dc.MoveTo( ptLT);
      dc.LineTo( ptRB);
   }else if( SelectItem == CIRCLE || SelectItem == CIRCLEFILL)
      dc.Ellipse( &RubberBandRect);
   else  dc.Rectangle( &RubberBandRect);
   
   dc.SelectObject( OldPen);
   dc.SelectObject( OldBrush);
   dc.SetROP2( OldMode);
}

/****************************************/
/*             */
/* Correct coordinate of rectangle  */
/*             */
/****************************************/
void
CEditWnd::IllegalRect(
PPOINT   ptTL,
PPOINT   ptBR)
{
   int   Tmp;

   if( ptTL->x > ptBR->x){
      Tmp = ptTL->x;
      ptTL->x = ptBR->x;
      ptBR->x = Tmp; 
   }
   if( ptTL->y > ptBR->y){
      Tmp = ptTL->y;
      ptTL->y = ptBR->y;
      ptBR->y = Tmp;
   }
}

/****************************************/
/*             */
/* Process to term tool    */
/*             */
/****************************************/
void
CEditWnd::ToolTerm()
{
   if( IsCapture){
      IsCapture = FALSE;
      ReleaseCapture();
   }
   ButtonFlag = NCLICK;
}


/****************************************/
/*             */
/* Set Freeform selection     */
/*             */
/****************************************/
BOOL
CEditWnd::SetFreeForm()
{
   CBrush   EraseBrush;
   CBrush   BlackBrush;

   PickRgn.GetRgnBox( &ClipRect[BMP]);
   if( ClipRect[BMP].Width() < 3 ||
       ClipRect[BMP].Height() < 3){
      FreeRgn.GetRgnBox( &ClipRect[DSP]);
      ClipRect[DSP].right += 1;
      ClipRect[DSP].bottom += 1;
         return FALSE;
   }
   EraseBrush.CreateStockObject( WHITE_BRUSH);
   BlackBrush.CreateStockObject( BLACK_BRUSH);
   CRTDrawDC.FillRect( &ClipRect[BMP], &EraseBrush);
   CRTDrawDC.FillRgn( &PickRgn, &BlackBrush);
   EraseBrush.DeleteObject();
   BlackBrush.DeleteObject();

      CRTDrawDC.BitBlt( ClipRect[BMP].left, ClipRect[BMP].top,
      ClipRect[BMP].Width(), ClipRect[BMP].Height(),
      &ImageDC, ClipRect[BMP].left, ClipRect[BMP].top, SRCPAINT);


   FreeRgn.GetRgnBox( &ClipRect[DSP]);
   ClipRect[DSP].right += 1;
   ClipRect[DSP].bottom += 1;

   return TRUE;
}

/****************************************/
/*             */
/* Erase Freeform selection area */
/*             */
/****************************************/
void
CEditWnd::EraseFreeForm()
{
   CBrush   CutBrush;
   CutBrush.CreateSolidBrush( COLOR_WHITE );
      ImageDC.FillRgn( &PickRgn, &CutBrush);
   CutBrush.DeleteObject();
}

/****************************************/
/*             */
/* Erase rectangle selection area   */
/*             */
/****************************************/
void
CEditWnd::EraseRectangle()
{
   CRect pRect;
   CPen  *OldPen;
   CBrush   CutBrush;

   OldPen = (CPen *)ImageDC.SelectStockObject( NULL_PEN);
   CutBrush.CreateSolidBrush( COLOR_WHITE );
      CBrush *OldBrush = ImageDC.SelectObject( &CutBrush);

   pRect.CopyRect( &ClipRect[BMP]);
   pRect.right  += 1;
   pRect.bottom += 1;
      ImageDC.Rectangle( &pRect);
      ImageDC.SelectObject( OldPen);
      ImageDC.SelectObject( OldBrush);
   CutBrush.DeleteObject();

   RectClipFlag = FALSE;
   SetValidRect();
   this->InvalidateRect( &ClipRect[VLD], FALSE);
   this->UpdateWindow();
   RectClipFlag = TRUE;
}

/****************************************/
/*             */
/* Save character with same code */
/*             */
/****************************************/
#define ABORT  1
#define CANCEL 0
int 
CEditWnd::SaveEUDCCode(UINT msgBoxType)
{
  CClientDC dc(this);
   CFont cFont, *OldFont;
   LOGFONT  LogFont;
   DWORD wSize;
   LPBYTE   pBuf;
   LPBYTE   pBuf2;
   TCHAR BMPPath[MAX_PATH];
   TCHAR TTFPath[MAX_PATH];
   TCHAR *FilePtr;
   int   FontType, sts=0;
//fix for FontIsLinked
  BOOL firstTime = false;
//
   if( SelectItem == RECTCLIP || SelectItem == FREEFORM)
      WriteSelRectBitmap();

   lstrcpy(TTFPath, SelectEUDC.m_File);
   lstrcpy(BMPPath,TTFPath);
   if(( FilePtr = Mytcsrchr( BMPPath, '.')) != NULL)
      *FilePtr = '\0';
   lstrcat( BMPPath, TEXT(".EUF"));

    // The code is to fix the related bug #421829 & #438677
    // It delays 1 second to call EnabelEUDC(FALSE).
    DWORD dwStart = GetTickCount();

    // Stop if this has taken too long
    while (1)
    {
        if( GetTickCount() - dwStart >= 1000 )
            break;
    }

   if( !EnableEUDC( FALSE)){
      MessageBox(TEXT("EnableEUDC() Error"), TEXT("EudcEditor"), MB_OK);
    return ABORT;
   }

//fix for FontIsLinked
//create logFont first, then use this font to create new character
  OInit();
  if( !OExistTTF( TTFPath)){
    firstTime = TRUE;
     memset( &LogFont, 0, sizeof( LogFont));
    lstrcpy (LogFont.lfFaceName, CountryInfo.szForceFont);
     LogFont.lfHeight  = BITMAP_HEIGHT;
     LogFont.lfWidth   = BITMAP_WIDTH;
     LogFont.lfOutPrecision  = OUT_TT_ONLY_PRECIS;
     LogFont.lfCharSet = (BYTE)CountryInfo.CharacterSet;
     LogFont.lfPitchAndFamily = FF_ROMAN; //| FIXED_PITCH;
    if (CountryInfo.LangID == EUDC_JPN)
    {
      //  JPN platform, use fixed pitch font.
       LogFont.lfPitchAndFamily |= FIXED_PITCH;
    }
     if( !cFont.CreateFontIndirect( &LogFont)){
        OutputMessageBox(this->GetSafeHwnd(),
           IDS_ASSOCIATE_DLGTITLE,
           IDS_SELECTFONT_ERROR, TRUE);
      OTerm();
      EnableEUDC(TRUE);
        return ABORT;
    }
     OldFont = dc.SelectObject( &cFont);

    FontType = !SelectEUDC.m_FontTypeFlg? 1:0;
     if( OCreateTTF( dc.GetSafeHdc(), TTFPath, FontType))
    {
      dc.SelectObject(OldFont);
      cFont.DeleteObject();
      OTerm();
      EnableEUDC(TRUE);
       return ABORT;
    }
    dc.SelectObject(OldFont);
     cFont.DeleteObject();
  }

   wSize = (DWORD)((( BITMAP_WIDTH +15) /16) *2) *(WORD)BITMAP_HEIGHT;
   pBuf = (LPBYTE)malloc(((( BITMAP_WIDTH +15) /16) *2) *BITMAP_HEIGHT);
   if( pBuf == NULL){
    OTerm();
    EnableEUDC(TRUE);
      return ABORT;
   }
   pBuf2 = pBuf;
   ImageBmp.GetBitmapBits( wSize, (LPVOID)pBuf2);     

   if( OMakeOutline( (LPBYTE)pBuf2, BITMAP_WIDTH, SMOOTHLVL) < 0)
  {
    free(pBuf);
    OTerm();
    EnableEUDC(TRUE);
      return ABORT;
  }
   sts = OOutTTF( dc.GetSafeHdc(),
                   TTFPath,
                   (unsigned short)UpdateCode,
                   CountryInfo.bUnicodeMode);
  if (sts == -3) //tte file is being used by another process
  {
    free(pBuf);
    OTerm();
    EnableEUDC(TRUE);

    HINSTANCE hInst = AfxGetInstanceHandle();
    TCHAR szMessage[256];
    LoadString(hInst, IDS_OVERWRITEFAIL, szMessage, sizeof(szMessage) / sizeof(TCHAR));
    TCHAR szTitle[256];
    LoadString(hInst, IDS_MAINFRAMETITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
    if (MessageBox( szMessage, szTitle, msgBoxType) == IDCANCEL)
      return CANCEL;
    else
      return ABORT;
  }
  else if (sts < 0)
  {
    free(pBuf);
    OTerm();
    EnableEUDC(TRUE);

    OutputMessageBox( this->GetSafeHwnd(),
         IDS_MAINFRAMETITLE,
         IDS_NOTENOUGHMEMORY_ERROR, TRUE);
    return ABORT;
  }

//fix for FontIsLinked
  if (firstTime)
  {
      if (creatW31JEUDC(BMPPath))
    {
      free(pBuf);
      OTerm();
      EnableEUDC(TRUE);
      return ABORT;
    }
  }
//
   if( OpenW31JEUDC( BMPPath)){
    free(pBuf);
    OTerm();
    EnableEUDC(TRUE);
    return ABORT;
   }
   if( PutW31JEUDCFont((unsigned short)UpdateCode, pBuf2, BITMAP_WIDTH,
             BITMAP_HEIGHT, CountryInfo.bUnicodeMode)){
      CloseW31JEUDC();
    free(pBuf);
    OTerm();
    EnableEUDC(TRUE);
    return ABORT;
   }
   CloseW31JEUDC();
   BitmapDirty = FALSE;
   g_bKeepEUDCLink = TRUE;

  free(pBuf);
  OTerm();
  EnableEUDC(TRUE);
  return ABORT;
}

/****************************************/
/*             */
/* draw image for undo     */
/*             */
/****************************************/
void
CEditWnd::UndoImageDraw()
{
   CDC   UndoDC;

   if( !UndoBitmapFlag)
         CreateUndoBitmap();

      UndoDC.CreateCompatibleDC( &ImageDC);
      CBitmap *OldBitmap = UndoDC.SelectObject( &UndoImage);

      UndoDC.BitBlt( 0, 0, BITMAP_WIDTH, BITMAP_HEIGHT,
      &ImageDC, 0, 0, SRCCOPY);

   if( RectClipFlag && (SelectItem == RECTCLIP || SelectItem == FREEFORM)){
      CRect pRect;

      pRect.SetRect(( ClipRect[DSP].left + 1) /ZoomRate,
          ( ClipRect[DSP].top - CAPTION_HEIGHT +1) /ZoomRate,
          ( ClipRect[DSP].right + 1)/ZoomRate,
          ( ClipRect[DSP].bottom - CAPTION_HEIGHT +1) /ZoomRate);

      UndoDC.StretchBlt( pRect.left, pRect.top,
         pRect.Width(), pRect.Height(), &CRTDrawDC,
         ClipRect[BMP].left, ClipRect[BMP].top,
         ClipRect[BMP].Width(), ClipRect[BMP].Height(), SRCAND);
   }
      UndoDC.SelectObject( OldBitmap);
      UndoDC.DeleteDC();
   UndoBitmapFlag = TRUE;
}

/****************************************/
/*             */
/*    for Update     */
/*             */
/****************************************/
BOOL
CEditWnd::SelectCodes()
{
   int   xSize, ySize;
   int   wSize;
   LPBYTE   pBuf;
   TCHAR *FilePtr;
   TCHAR BMPPath[MAX_PATH];

   lstrcpy( BMPPath, SelectEUDC.m_File);
   if(( FilePtr = Mytcsrchr( BMPPath, '.')) != NULL)
      *FilePtr = '\0';
   lstrcat( BMPPath, TEXT(".EUF"));

   wSize = (int)((( BITMAP_WIDTH + 15) /16) *2) *(int)BITMAP_HEIGHT;
   pBuf = (LPBYTE)malloc( wSize);
   if( OpenW31JEUDC( BMPPath)){
      free( pBuf);
      return FALSE;
   }
   if( GetW31JEUDCFont((unsigned short)UpdateCode, pBuf, wSize,
              &xSize, &ySize, CountryInfo.bUnicodeMode)){
      CloseW31JEUDC();
      free( pBuf);
      return FALSE;
   }else if( xSize != BITMAP_WIDTH || ySize != BITMAP_HEIGHT){
      CloseW31JEUDC();
      free( pBuf);
      return FALSE;
   }
   CloseW31JEUDC();

   ImageBmp.SetBitmapBits( wSize, (LPVOID)pBuf);
   BitmapDirty = FALSE;
   free( pBuf);
   this->Invalidate( FALSE);
   this->UpdateWindow();
   return TRUE;
}

/****************************************/
/*             */
/* Clear bitmap data    */
/*             */
/****************************************/
BOOL
CEditWnd::UpdateBitmap()
{
   WORD  wSize;
   HANDLE   BitHandle;
   BYTE  *pBitmap;

   wSize = (WORD)((( BITMAP_WIDTH +15) /16) *2) *(WORD)BITMAP_HEIGHT;
   if(( BitHandle = LocalAlloc( LMEM_MOVEABLE, wSize)) == 0)
      return FALSE;

   if(( pBitmap = (BYTE *)LocalLock( BitHandle)) == NULL){
      LocalFree( BitHandle);
      return FALSE;
   }
   memset( pBitmap, 0xffff, wSize);

   ImageBmp.SetBitmapBits((DWORD)wSize, (const void far *)pBitmap);
   LocalUnlock( BitHandle);
   LocalFree( BitHandle);

   if(( SelectItem == RECTCLIP || SelectItem == FREEFORM) && RectClipFlag){
      RectClipFlag = FALSE;
      ToolTerm();
   }
   this->Invalidate( FALSE);
   this->UpdateWindow();
   BitmapDirty = FALSE;

   return TRUE;
}

/****************************************/
/*             */
/* Get bitmap dirty flag      */
/*             */
/****************************************/
BOOL
CEditWnd::GetBitmapDirty()
{
   return BitmapDirty;
}

/****************************************/
/*             */
/* Get bitmap dirty flag      */
/*             */
/****************************************/
BOOL
CEditWnd::SetBitmapDirty(
BOOL  Flg)
{
   BitmapDirty = Flg;
   return TRUE;
}

/****************************************/
/*             */
/* Call Charcter        */
/*             */
/****************************************/
void
CEditWnd::CallCharTextOut()
{
   CFont CallFont;
   CSize CharSize;
   BYTE  sWork[10];
   int   Length;
   int   xOffset, yOffset;

   EditLogFont.lfHeight  = BITMAP_HEIGHT; 
   EditLogFont.lfWeight  = 0;
   EditLogFont.lfQuality = PROOF_QUALITY;
   if( !CallFont.CreateFontIndirect( &EditLogFont))
      return;
   CFont *OldFont = ImageDC.SelectObject( &CallFont);

   if( !CallCode)
      Length = 0;

   else
   {
      sWork[0] = LOBYTE(CallCode);
     sWork[1] = HIBYTE(CallCode);
      sWork[2] = sWork[3] = 0;
      Length = 1;
   }
/*
   else if( !HIBYTE(CallCode)){
//    SBCS
      sWork[0] = LOBYTE(CallCode);
      sWork[1] = (BYTE)'\0';
      Length = 1;
   }else{
//    DBCS
      sWork[0] = HIBYTE(CallCode);
      sWork[1] = LOBYTE(CallCode);
      sWork[2] = (BYTE)'\0';
      Length = 2;
   }
*/
   if( Length){
      CRect TextImage;
/*
      GetTextExtentPoint32A( ImageDC.GetSafeHdc(), (LPCSTR)sWork,
            Length, &CharSize);
*/
      GetTextExtentPoint32W( ImageDC.GetSafeHdc(), (LPCWSTR)sWork,
            Length, &CharSize);

      TextImage.SetRect( 0, 0, BITMAP_WIDTH, BITMAP_HEIGHT);
      if( CharSize.cx < BITMAP_WIDTH)
         xOffset = ( BITMAP_HEIGHT - CharSize.cx) /2;
      else  xOffset = 0;

      if( CharSize.cy < BITMAP_HEIGHT)
         yOffset = ( BITMAP_WIDTH  - CharSize.cy) /2;
      else  yOffset = 0;

      if( EditLogFont.lfFaceName[0] == '@' &&
          Length == 1)
         xOffset = yOffset = 0;
/*    
         ExtTextOutA(ImageDC.GetSafeHdc(), xOffset, yOffset, ETO_OPAQUE,
         &TextImage, (LPCSTR)sWork, Length, NULL);
*/
         ExtTextOutW(ImageDC.GetSafeHdc(), xOffset, yOffset, ETO_OPAQUE,
         &TextImage, (LPCWSTR)sWork, Length, NULL);

   }
   ImageDC.SelectObject( OldFont);
   CallFont.DeleteObject();
   this->Invalidate( FALSE);
   this->UpdateWindow();
}

/****************************************/
/*             */
/* COMMAND     "Flip/Rotate"  */
/*             */
/****************************************/
void
CEditWnd::FlipRotate(
int   RadioItem)
{
   CDC   RotateDC;
   CBitmap RotateBMP;
   CBrush   wBrush;
   int   wSize;
   LPBYTE   pBuf1, pBuf2;
   LPBYTE   pPtr1, pPtr2;

   UndoImageDraw();
   BitmapDirty = TRUE;
   InitFlipRotate( &RotateDC, &RotateBMP);

   switch( RadioItem){
   case FLIP_HOR:
      if( !RectClipFlag){
         ImageDC.StretchBlt( BITMAP_WIDTH - 1, 0,
            0 - BITMAP_WIDTH, BITMAP_HEIGHT, &CRTDrawDC,
            0, 0, BITMAP_WIDTH, BITMAP_HEIGHT, SRCCOPY);
      }else{
         wBrush.CreateStockObject( WHITE_BRUSH);
         CRTDrawDC.FillRect( &ClipRect[BMP], &wBrush);
         wBrush.DeleteObject();

         CRTDrawDC.StretchBlt(
            ClipRect[BMP].right - 1, ClipRect[BMP].top,
            0 - ClipRect[BMP].Width(),
            ClipRect[BMP].Height(), &RotateDC,
            ClipRect[BMP].left, ClipRect[BMP].top,
            ClipRect[BMP].Width(),
            ClipRect[BMP].Height(), SRCCOPY);
      }
      break;

   case FLIP_VER:
      if( !RectClipFlag){
         ImageDC.StretchBlt( 0, BITMAP_HEIGHT - 1, BITMAP_WIDTH,
            0 - BITMAP_HEIGHT, &CRTDrawDC, 0, 0,
            BITMAP_WIDTH, BITMAP_HEIGHT, SRCCOPY);
      }else{
         wBrush.CreateStockObject( WHITE_BRUSH);
         CRTDrawDC.FillRect( &ClipRect[BMP], &wBrush);
         wBrush.DeleteObject();

         CRTDrawDC.StretchBlt(
            ClipRect[BMP].left,ClipRect[BMP].bottom - 1,
            ClipRect[BMP].Width(),
            0 - ClipRect[BMP].Height(), &RotateDC,
            ClipRect[BMP].left, ClipRect[BMP].top,
            ClipRect[BMP].Width(),
            ClipRect[BMP].Height(), SRCCOPY);
      }
      break;

   case ROTATE_9:
      wSize = (int)((( BITMAP_WIDTH +15) /16) *2)*(int)BITMAP_HEIGHT;
      pBuf1 = (LPBYTE)malloc( wSize);
      pBuf2 = (LPBYTE)malloc( wSize);
      if( !RectClipFlag){
         ImageBmp.GetBitmapBits( wSize, (LPVOID)pBuf1);
         CRTDrawBmp.GetBitmapBits( wSize, (LPVOID)pBuf2);
         pPtr1 = pBuf1;
         pPtr2 = pBuf2;
         RotateFigure90(pPtr1,pPtr2,BITMAP_WIDTH, BITMAP_HEIGHT);
         ImageBmp.SetBitmapBits( wSize, (LPVOID)pBuf1);
         CRTDrawBmp.SetBitmapBits( wSize, (LPVOID)pBuf2);

         free(pBuf1);
         free(pBuf2);
      }else{
         CPoint   Mid;  
         CRTDrawBmp.GetBitmapBits( wSize, (LPVOID)pBuf1);
         RotateBMP.GetBitmapBits(  wSize, (LPVOID)pBuf2);
         pPtr1 = pBuf1;
         pPtr2 = pBuf2;
         RotateFigure90(pPtr1,pPtr2,BITMAP_WIDTH, BITMAP_HEIGHT);

         int Lft = ClipRect[BMP].left;
         int Btm = ClipRect[BMP].bottom;
         int Wid = ClipRect[BMP].Width();
         int Hgt = ClipRect[BMP].Height();
         ClipRect[BMP].left = BITMAP_HEIGHT - Btm;
         ClipRect[BMP].top  = Lft;
         ClipRect[BMP].right = ClipRect[BMP].left + Hgt;
         ClipRect[BMP].bottom = ClipRect[BMP].top + Wid;

         Lft = ClipRect[DSP].left;
         Btm = ClipRect[DSP].bottom - CAPTION_HEIGHT - 1;
         Wid = ClipRect[DSP].Width();
         Hgt = ClipRect[DSP].Height();
         Mid.x = Lft
         +((ClipRect[DSP].Width()/2)/ZoomRate)*ZoomRate;
         Mid.y = ClipRect[DSP].top - CAPTION_HEIGHT
         +((ClipRect[DSP].Height()/2)/ZoomRate)*ZoomRate;

         Mid.x -= (((ClipRect[DSP].Height()/2)/ZoomRate)*ZoomRate);
         Mid.y -= (((ClipRect[DSP].Width()/2)/ZoomRate)*ZoomRate);
         if( Mid.x < 0)    ClipRect[DSP].left = 0;
         else{
            if( ClipRect[DSP].left + Hgt <=
               EudcWndRect.right){
               ClipRect[DSP].left = Mid.x;
            }else{
               ClipRect[DSP].left =
                  Mid.x - ((Mid.x + Hgt - EudcWndRect.right)/ZoomRate)*ZoomRate;
            }
         }
         if( Mid.y < 0)    ClipRect[DSP].top = CAPTION_HEIGHT;
         else{
            if( ClipRect[DSP].top + Wid   <= EudcWndRect.bottom){
               ClipRect[DSP].top =
                  CAPTION_HEIGHT + Mid.y;
            }else{
               ClipRect[DSP].top =
                  CAPTION_HEIGHT + Mid.y - (( CAPTION_HEIGHT + Mid.y + Wid - EudcWndRect.bottom)/ZoomRate)*ZoomRate;
            }
         }
         ClipRect[DSP].right = ClipRect[DSP].left + Hgt;
         ClipRect[DSP].bottom = ClipRect[DSP].top + Wid;
         CRTDrawBmp.SetBitmapBits( wSize, (LPVOID)pBuf1);
         RotateBMP.SetBitmapBits(  wSize, (LPVOID)pBuf2);
         free(pBuf1);
         free(pBuf2);
      }
      break;

   case ROTATE_18:
      if( !RectClipFlag){
         ImageDC.StretchBlt( BITMAP_WIDTH -1, BITMAP_HEIGHT-1,
            0-BITMAP_HEIGHT, 0-BITMAP_WIDTH, &CRTDrawDC,
            0, 0, BITMAP_WIDTH, BITMAP_HEIGHT, SRCCOPY);
      }else{
         wBrush.CreateStockObject( WHITE_BRUSH);
         CRTDrawDC.FillRect( &ClipRect[BMP], &wBrush);
         wBrush.DeleteObject();

         CRTDrawDC.StretchBlt(
            ClipRect[BMP].right-1, ClipRect[BMP].bottom-1,
            0 - ClipRect[BMP].Width(),
            0 - ClipRect[BMP].Height(), &RotateDC,
            ClipRect[BMP].left, ClipRect[BMP].top,
            ClipRect[BMP].Width(),
            ClipRect[BMP].Height(), SRCCOPY);
      }
      break;

   case ROTATE_27:
      wSize = (int)((( BITMAP_WIDTH +15) /16) *2) *(int)BITMAP_HEIGHT;
      pBuf1 = (LPBYTE)malloc( wSize);
      pBuf2 = (LPBYTE)malloc( wSize);
      if( !RectClipFlag){
         ImageBmp.GetBitmapBits( wSize, (LPVOID)pBuf1);
         CRTDrawBmp.GetBitmapBits( wSize, (LPVOID)pBuf2);
         pPtr1 = pBuf1;
         pPtr2 = pBuf2;
         RotateFigure270( pPtr1, pPtr2, BITMAP_WIDTH,
               BITMAP_HEIGHT);
         ImageBmp.SetBitmapBits( wSize, (LPVOID)pBuf1);
         CRTDrawBmp.SetBitmapBits( wSize, (LPVOID)pBuf2);

         free(pBuf1);
         free(pBuf2);
      }else{
         CPoint   Mid;
         CRTDrawBmp.GetBitmapBits( wSize, (LPVOID)pBuf1);
         RotateBMP.GetBitmapBits(  wSize, (LPVOID)pBuf2);
         pPtr1 = pBuf1;
         pPtr2 = pBuf2;
         RotateFigure270( pPtr1, pPtr2,
            BITMAP_WIDTH, BITMAP_HEIGHT);

         int Rgt = ClipRect[BMP].right;
         int Top = ClipRect[BMP].top;
         int Wid = ClipRect[BMP].Width();
         int Hgt = ClipRect[BMP].Height();
         ClipRect[BMP].left = Top;
         ClipRect[BMP].top  = BITMAP_WIDTH - Rgt;
         ClipRect[BMP].right = ClipRect[BMP].left + Hgt;
         ClipRect[BMP].bottom = ClipRect[BMP].top + Wid;

         Rgt = ClipRect[DSP].right - 1;
         Top = ClipRect[DSP].top - CAPTION_HEIGHT;
         Wid = ClipRect[DSP].Width();
         Hgt = ClipRect[DSP].Height();
         Mid.x = ClipRect[DSP].left
         + ((ClipRect[DSP].Width()/2)/ZoomRate)*ZoomRate;
         Mid.y = Top
         + ((ClipRect[DSP].Height()/2)/ZoomRate)*ZoomRate;
         Mid.x -= (((ClipRect[DSP].Height()/2)/ZoomRate)*ZoomRate);
         Mid.y -= (((ClipRect[DSP].Width()/2)/ZoomRate)*ZoomRate);
         if( Mid.x < 0)    ClipRect[DSP].left = 0;
         else{
            if( ClipRect[DSP].left + Hgt
               <= EudcWndRect.right){
               ClipRect[DSP].left = Mid.x;
            }else{
               ClipRect[DSP].left =
                  Mid.x - ((Mid.x + Hgt - EudcWndRect.right)/ZoomRate)*ZoomRate;
            }
         }
         if( Mid.y < 0)
            ClipRect[DSP].top = CAPTION_HEIGHT;
         else{
            if( ClipRect[DSP].top + Wid   <= EudcWndRect.bottom){
               ClipRect[DSP].top =
                  CAPTION_HEIGHT + Mid.y;
            }else{
               ClipRect[DSP].top =
                  CAPTION_HEIGHT + Mid.y - (( CAPTION_HEIGHT + Mid.y + Wid - EudcWndRect.bottom)/ZoomRate)*ZoomRate;
            }
         }
         ClipRect[DSP].right = ClipRect[DSP].left + Hgt;
         ClipRect[DSP].bottom = ClipRect[DSP].top + Wid;
            
         CRTDrawBmp.SetBitmapBits( wSize, (LPVOID)pBuf1);
         RotateBMP.SetBitmapBits(  wSize, (LPVOID)pBuf2);
         free(pBuf1);
         free(pBuf2);
      }
      break;

   default:
      break;
   }
   if( RectClipFlag){
      if( RotateBMP.Detach() != NULL)
         RotateBMP.DeleteObject();
      if( RotateDC.Detach() != NULL)
         RotateDC.DeleteDC();
   }
   this->Invalidate(FALSE);
   this->UpdateWindow();
}

/************************************************/
/*                */
/* Initialize before flip or rotate */
/*                */
/************************************************/
void
CEditWnd::InitFlipRotate(
CDC*  RotateDC,
CBitmap *RotateBMP)
{
   WORD  BitSize;
   HANDLE   BitInit;
   BYTE  *BitmapPtr;

   if( RectClipFlag){
      CClientDC   dc( this);
      if( !RotateDC->CreateCompatibleDC( &dc))
         return;

      BitSize = (WORD)((( BITMAP_WIDTH +15) /16) *2)
         * (WORD)BITMAP_HEIGHT;
      if(( BitInit = LocalAlloc( LMEM_MOVEABLE, BitSize))==0)
         return;

      if(( BitmapPtr = (BYTE *)LocalLock( BitInit)) == NULL){
         LocalFree( BitInit);
         return;
      }
      memset( BitmapPtr, 0xffff, BitSize);
      if( !RotateBMP->CreateBitmap(BITMAP_WIDTH,BITMAP_HEIGHT,
         1, 1, (LPSTR)BitmapPtr)){
         LocalUnlock( BitInit);
         LocalFree( BitInit);
         return;
      }
      LocalUnlock( BitInit);
      LocalFree( BitInit);    
      RotateDC->SelectObject( RotateBMP);

      RotateDC->BitBlt( 0, 0, BITMAP_WIDTH, BITMAP_HEIGHT,
         &CRTDrawDC, 0, 0, SRCCOPY);
   }else{
      CRTDrawDC.BitBlt( 0, 0, BITMAP_WIDTH, BITMAP_HEIGHT,
         &ImageDC, 0, 0, SRCCOPY);
   }
}

#define     set_p(a,i)  ((a)[(i)>>3] & (0x80>>((i)&7)))
/****************************************/
/*             */
/* Rotate 90         */
/*             */
/****************************************/
void
CEditWnd::RotateFigure90(
LPBYTE   pBuf1,
LPBYTE   pBuf2,
int   bWid,
int   bHgt)
{
   int   i, j, k, l;
   int   wSize, aSize;
   BYTE  Pt, *test;

   aSize = (int)(((( bWid + 15) /16) *2) *bHgt);
   wSize = (int)((( bWid  + 15) /16) *2);
   test = pBuf2;
   for( i = 0; i < wSize; i++){
      pBuf2 = test + aSize - wSize + i;
      for( j = 0; j < 8; j++){
         for( k = wSize-1; k >= 0; k--){
            memset( &Pt, 0x00, sizeof(BYTE));
            for( l = 0; l < 8; l++){
               if( set_p(pBuf2, j))
                  Pt |= (1<<(7-l));
               pBuf2 -= wSize;
            }
            *pBuf1++ = Pt;
         }
         pBuf2 = test + aSize - wSize + i;
      }
   }
   return;
}

/****************************************/
/*             */
/* Rotate 270        */
/*             */
/****************************************/
void
CEditWnd::RotateFigure270(
LPBYTE   pBuf1,
LPBYTE   pBuf2,
int   bWid,
int   bHgt)
{
   int   i, j, k, l;
   int   wSize, aSize;
   BYTE  Pt, *test;

   aSize = (int)(((( bWid + 15) /16) *2) *bHgt);
   wSize = (int)((( bWid  + 15) /16) *2);
   test = pBuf2;
   for( i = 0; i < wSize; i++){
      pBuf2 = test + wSize - 1 - i;
      for( j = 7; j >= 0; j--){
         for( k = wSize-1; k >= 0; k--){
            memset( &Pt, 0x00, sizeof(BYTE));
            for( l = 0; l < 8; l++){
               if( set_p(pBuf2, j))
                  Pt |= (1<<(7-l));
               pBuf2 += wSize;
            }
            *pBuf1++ = Pt;
         }
         pBuf2 = test + wSize - 1 - i;
      }
   }
   return;
}

/****************************************/
/*             */
/* Set Duplicate rectangle    */
/*             */
/****************************************/
void
CEditWnd::SetDuplicateRect(
RECT  *rect,
POINT    *point)
{
   LPBYTE pDupBmp;
   int   wSize;

   UndoImageDraw();
   BitmapDirty = TRUE;
   WriteSelRectBitmap();
   this->Invalidate( FALSE);
   this->UpdateWindow();

   wSize = ((( BITMAP_WIDTH +15) /16) *2) *BITMAP_HEIGHT;
   pDupBmp = (LPBYTE)malloc( wSize);
   DupBmp.GetBitmapBits( wSize, (LPVOID)pDupBmp);
   CRTDrawBmp.SetBitmapBits( wSize, (LPVOID)pDupBmp);
   free( pDupBmp);

   ClipRect[DSP].CopyRect( rect);
   ClipRect[PRV].CopyRect( rect);
   SetValidRect();
   SetClickRect();
   ClipRect[BMP].SetRect( DupRect.left /ZoomRate,
      ( DupRect.top - CAPTION_HEIGHT) /ZoomRate,
        DupRect.right /ZoomRate,
      ( DupRect.bottom - CAPTION_HEIGHT) /ZoomRate);
   RectClipFlag = TRUE;

   this->InvalidateRect( &ClipRect[VLD], FALSE);
   this->UpdateWindow();
}

void CEditWnd::OnClose() 
{
   // Don't allow user to use hot key to close this window
   
   //CMDIChildWnd::OnClose();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\eudcdlg.h ===
/**************************************************/
/*						                          */
/*						                          */
/*		Update EUDC Dialog		                  */
/*						                          */
/*						                          */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include "eudclist.h"

class CEudcDlg : public CDialog
{
public:
	CEudcDlg(CWnd* pParent = NULL);

	//{{AFX_DATA(CEudcDlg)
	enum { IDD = IDD_CUSTOMCODE };
	//}}AFX_DATA

protected:
	void SetViewCustomFont();

public:
	CEudcList	m_EditList;
	CViewEdit	m_ViewChar;
#ifdef BUILD_ON_WINNT
    CColumnHeading  m_ColumnHeading;
#endif //BUILD_ON_WINNT
CCustomListFrame	m_ListFrame;
CCustomInfoFrame	m_Frame;
CCustomInfoFrame	m_InfoFrame2;
CCustomInfoFrame	m_InfoFrame3;
	CComboBox	m_ComboRange;
	CStatic		m_StaticRange;
	BOOL		WorRFlag;

private:
	void	AdjustFileName();
	void	AdjustFontName();
	void	RegistRegFont();
	TCHAR	FileName[MAX_PATH];
	TCHAR	FontName[LF_FACESIZE];

protected:
	virtual BOOL OnInitDialog();
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

	//{{AFX_MSG(CEudcDlg)
	virtual void OnOK();
	afx_msg void OnSelchangeChinarange();
	virtual void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\eudcid.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
#define IDH_EUDC_ASSOCIATE	1010	;change
#define IDH_EUDC_ASSO_STANDARD	1011	;change
#define IDH_EUDC_ASSO_TYPEFACE	1015	;change
;#define IDH_EUDC_ASSO_FONT	1010	;delete
;#define IDH_EUDC_ASSO_FILE	1011	;delete
#define IDH_EUDC_ASSO_LIST	1012
#define IDH_EUDC_MODIFY		1013	;button
#define IDH_EUDC_REMOVE		1014	;button
#define IDH_EUDC_MODFILE	1020
#define IDH_EUDC_SELLIST	1030
#define IDH_EUDC_SELCODE	1031
#define IDH_EUDC_SELFONT	1032
#define IDH_EUDC_SELFILE	1033
#define IDH_EUDC_SELCHAR	1034
#define IDH_EUDC_REFLIST	1040
#define IDH_EUDC_REFCODE	1041
#define IDH_EUDC_REFFONT	1042
#define	IDH_EUDC_REFCHAR	1043
#define IDH_EUDC_IMPOBMP	1050
;#define IDH_EUDC_IMPOTT	1051	;delete
#define IDH_EUDC_FLIPH		1060	
#define IDH_EUDC_FLIPV		1061	
#define IDH_EUDC_ROTA90		1062	
#define IDH_EUDC_ROTA180	1063	
#define IDH_EUDC_ROTA270	1064	
#define IDH_EUDC_OK		1070	
#define IDH_EUDC_CANCEL		1071	;button
#define IDH_EUDC_BROWSE		1072	;button
#define IDH_EUDC_FONT		1073	;NEWbutton
#define IDH_EUDC_browse_TTF	1080
#define	IDH_EUDC_LINK_IMELIST	1090
#define	IDH_EUDC_BLINK_EDITTBL	1100
#define	IDH_EUDC_OUTCAUTION	1200
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\eudclist.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
#ifndef _EUDCLIST_H_
#define _EUDCLIST_H_

/************************************************/
/*						*/
/*	Character List (Update EUDC)		*/
/*						*/
/************************************************/

class CViewEdit :public CEdit
{
//	member function
public:
	CViewEdit();
	~CViewEdit();
  CFont EUDCFont;

private:
	void DrawConcave( CDC *dc, CRect rect);

protected:

	//{{AFX_MSG(CViewEdit)
	afx_msg void OnPaint();
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CCustomListFrame :public CStatic
{
//	member function
public:
	CCustomListFrame();
	~CCustomListFrame();

private:
	void DrawConcave( CDC *dc, CRect rect);

protected:

	//{{AFX_MSG(CCustomListFrame)
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CCustomInfoFrame :public CStatic
{
//	member function
public:
	CCustomInfoFrame();
	~CCustomInfoFrame();

private:
	void DrawConcave( CDC *dc, CRect rect);

protected:

	//{{AFX_MSG(CCustomInfoFrame)
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef BUILD_ON_WINNT
class CColumnHeading :public CWnd
{
//	member function
public:
	CColumnHeading();
	~CColumnHeading();

protected:

	//{{AFX_MSG(CColumnHeading)
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

//	member parameter
public:
	CFont	SysFFont;
};
#endif //BUILD_ON_WINNT

class CEudcList : public CEdit
{
	DECLARE_DYNCREATE( CEudcList)

//	Member function
public:
	CEudcList();
	~CEudcList();
	BOOL	CodeButtonClicked();
	void	SetInitEUDCCodeRange( int nIndex);
	void 	SetEUDCCodeRange( int nIndex);
	void 	CalcCharSize();

private:
	WORD 	GetNextCode( WORD Code);
	WORD 	CorrectEUDCCode( WORD Code, BOOL UporDown);
	WORD 	CorrectEUDCCodeKey( WORD Code, int MovePt, BOOL UporDown);
	WORD 	GetCodeScrPos( int Pos);
	int	GetBarPosition( WORD Code);
	void 	DrawConcave( CDC *dc, CRect rect, BOOL PtIn);
	void 	SearchSelectPosition();
	BOOL	IsCorrectChar( UINT i, UINT j);

//	Member parameter
public:
	CFont	EUDCFont;
	CFont	SysFFont;
	WORD 	EUDC_SView;
	WORD	EUDC_EView;
	WORD	EUDC_SCode;
	WORD	EUDC_ECode;
	WORD	SelectCode;
	int	cRange;
	int	BarRange;
	CPoint  LButtonPt;
	CSize 	CharSize;
	short	ScrlBarPos;

private:
	CRect	EditListRect;
	CSize 	FixSize;
	CPoint	WritePos;
	int	ySpace;
	int	m_Index;
	BYTE	CSpace[5];
	BOOL	FocusFlag;

protected:

	//{{AFX_MSG(CEudcList)
	afx_msg void OnPaint();
	afx_msg void OnVScroll( UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\eudcedit.cpp ===
/********************************************************/
/*							                            */
/*							                            */
/*	EUDC EDITOR     ( Windows 95)			            */
/*							                            */
/*		* Japanese Version			                    */
/*		* Korea	   Version			                    */
/*		* Chinese  Version			                    */
/*							                            */
/*                                                      */
/* Copyright (c) 1997-1999 Microsoft Corporation.       */
/********************************************************/

#include 	"stdafx.h"
#include 	<afxpriv.h>
#include 	"eudcedit.h"
#include 	"mainfrm.h"
#include	"registry.h"
#include	"util.h"
#include  "assocdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char 	BASED_CODE THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CEudcApp, CWinApp)
//{{AFX_MSG_MAP(CEudcApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
//}}AFX_MSG_MAP
	ON_COMMAND(ID_CONTEXT_HELP, CWinApp::OnContextHelp)
END_MESSAGE_MAP()

/* Global parameter */
INT	CAPTION_HEIGHT;		// height of caption
INT	BITMAP_WIDTH;		// width of bitmap
INT	BITMAP_HEIGHT;		// height of bitmap
TCHAR	HelpPath[MAX_PATH];	// help file path
TCHAR	ChmHelpPath[MAX_PATH];	// help file path for HtmlHelp
TCHAR	FontPath[MAX_PATH];	// font file path
DWORD	COLOR_GRID;		// grid color
DWORD	COLOR_FITTING;		// bitmap color on show outline
DWORD	COLOR_CURVE;		// color of outline
DWORD	COLOR_FACE;		// Win95 3D Face SystemColor
DWORD	COLOR_HLIGHT;		// Win95 3D HighLight System Color
DWORD	COLOR_SHADOW;		// Win95 3D Shadow SystemColor
DWORD	COLOR_WIN;		// Win95 Window System Color
CString	NotMemTtl;
CString	NotMemMsg;
HCURSOR	ToolCursor[NUMTOOL];	// cursor for tool
HCURSOR	ArrowCursor[NUMRESIZE];	// cursor for resize
COUNTRYINFO	CountryInfo;	// country information structure

/* Global function */
extern BOOL 	SetCountryInfo( UINT LocalCP);
BOOL     g_bKeepEUDCLink = TRUE;

extern "C" BOOL AnyLinkedFonts();


CEudcApp NEAR theApp;
/************************************************/
/*						*/
/*	Default Constructor			*/
/*						*/
/************************************************/
CEudcApp::CEudcApp()
{
}

/************************************************/
/*						*/
/*	Initialize Instance			*/
/*						*/
/************************************************/
BOOL
CEudcApp::InitInstance()
{
	CString	MainWndTitle;
	CRect	MainWndRect;
	UINT	MaxWndFlag;

//	Check whether EUDC editor can open or not
	if( !CheckPrevInstance())
		return FALSE;

    //
    // Cicero and Cicero TIP currently does not support EUDC mode.
    // Use IMM32's IMEs on eudcedit.exe.
    //
    DisableCUAS();

/*------------------------------------------------
 * check if it's Administrator
 *------------------------------------------------*/
  TCHAR winpath[MAX_PATH];
  HANDLE nfh;

  GetSystemWindowsDirectory( winpath, MAX_PATH);
#ifdef IN_FONTS_DIR // CAssocDlg::OnOK()
		lstrcat( winpath, TEXT("\\FONTS\\"));
#else
		lstrcat( winpath, TEXT("\\"));
#endif // IN_FONTS_DIR
  lstrcat(winpath, _T("eudcadm.tte"));
	nfh = CreateFile(winpath,
					GENERIC_WRITE,
					FILE_SHARE_DELETE,
					NULL,
					CREATE_ALWAYS,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( nfh  == INVALID_HANDLE_VALUE)
  {
    HINSTANCE hInst = AfxGetInstanceHandle();
    TCHAR szMessage[256];
    LoadString(hInst, IDS_ACCESSDENIED, szMessage, sizeof(szMessage) / sizeof(TCHAR));
    AfxMessageBox(szMessage, MB_OK, 0);
		return FALSE;
  }
	else
  {
    CloseHandle(nfh);
    DeleteFile(winpath);
  }

//	Set background color for dialog
	COLOR_FACE   = ::GetSysColor( COLOR_3DFACE);
	COLOR_HLIGHT = ::GetSysColor( COLOR_3DHILIGHT);
	COLOR_SHADOW = ::GetSysColor( COLOR_3DSHADOW);
	COLOR_WIN    = ::GetSysColor( COLOR_WINDOW);
//	SetDialogBkColor( COLOR_FACE);

//	Set 3d controls
	Enable3dControls();

//	Create registry subkey
	if( !CreateRegistrySubkey())
		return FALSE;

//	Open "EUDCEDIT.INI", read data
	if( !GetProfileText( &MainWndRect, &MaxWndFlag))
		return FALSE;

//	Get Language ID with GetSystemDefaultLCID()
//      Get area of EUDC from registry and WideCharToMultiByte().
	if( !GetCountryInfo())
		return FALSE;

#if WINVER >= 0x0500
//	Remember original font link status before we do anything
//pliu  g_bKeepEUDCLink = AnyLinkedFonts();
#endif

//      Get Cursor from resource
	if( !GetCursorRes())
		return FALSE;

//      Get font and help file path
	if( !GetFilePath())
		return FALSE;

//	Create MDI mainFrame window
	MainWndTitle.LoadString( IDS_MAINFRAMETITLE);
	CMainFrame* pMainFrame = new CMainFrame;


	if (!pMainFrame->Create( MainWndTitle,
	    WS_OVERLAPPEDWINDOW , MainWndRect,
	    MAKEINTRESOURCE( IDR_MAINFRAME))){
		return FALSE;
	}

	pMainFrame->ShowWindow( m_nCmdShow);
	if( MaxWndFlag){
		pMainFrame->ShowWindow( SW_SHOWMAXIMIZED);
	}
	pMainFrame->UpdateWindow();
	m_pMainWnd = pMainFrame;

	CAssocDlg dlg(m_pMainWnd);

	if (!dlg.InitSystemFontAssoc())
	{
		return FALSE;
	}
	pMainFrame->m_wndGuideBar.PositionStatusPane();
	pMainFrame->SendMessage(WM_COMMAND, ID_READ_CHAR, NULL);

	return TRUE;
}

BOOL
CEudcApp::ExitInstance()
{
    if (!g_bKeepEUDCLink && CountryInfo.bOnlyUnicode)
    {

        // The code is to fix the related bug #421829 & #438677
        // It delays 1 second to call EnabelEUDC(FALSE).
        DWORD dwStart = GetTickCount();

        // Stop if this has taken too long
        while (1)
        {
            if( GetTickCount() - dwStart >= 1000 )
                break;
        }
        EnableEUDC(FALSE);
        TCHAR szDefaultFace[LF_FACESIZE];
        TCHAR szFontPath[MAX_PATH];
        TCHAR *Ptr;

        GetStringRes(szDefaultFace, IDS_SYSTEMEUDCFONT_STR);

        if (InqTypeFace(szDefaultFace, szFontPath,MAX_PATH))
        {
            //
            // delete file eudc.tte
            //
            DeleteFile(szFontPath);
            if(( Ptr = Mytcsrchr( szFontPath, '.')) != NULL)
            {
                *Ptr = '\0';
                lstrcat( szFontPath, TEXT(".EUF"));
                //
                // delete file eudc.euf
                //
                DeleteFile(szFontPath);
            }
        }
        DeleteRegistrySubkey();
        EnableEUDC(TRUE);
    }
    return CWinApp::ExitInstance();
}

/************************************************/
/*						*/
/*	Check whether editor can open or not	*/
/*						*/
/************************************************/
BOOL
CEudcApp::CheckPrevInstance()
{
	HWND	hWnd;
	TCHAR	TitleBuf[50];

	GetStringRes(TitleBuf, IDS_MAINFRAMETITLE);

//	Search previous eudcedit mainframe.	
	hWnd = ::FindWindow( NULL, TitleBuf);
	if( hWnd == NULL)
		return TRUE;
	else 	::SetForegroundWindow( hWnd);

	return FALSE;
}

/************************************************/
/*						*/
/*	disable CUAS                            */
/*						*/
/************************************************/
void
CEudcApp::DisableCUAS()
{
    typedef BOOL (*PFNIMMDISABLETEXTFRAMESERVICE)(DWORD);

    PFNIMMDISABLETEXTFRAMESERVICE pfn;
    HMODULE hMod = LoadLibrary(TEXT("imm32.dll"));

    if (hMod)
    {
        pfn = (PFNIMMDISABLETEXTFRAMESERVICE)GetProcAddress(hMod,
                           "ImmDisableTextFrameService");

        if (pfn)
            pfn(-1);
    }
}

/************************************************/
/*						*/
/*	Correspond to waitting for Input	*/
/*						*/
/************************************************/
BOOL
CEudcApp::OnIdle(
LONG 	lCount)
{
	CWnd	*pWnd;

	if( !lCount){
		for( pWnd = m_pMainWnd->GetWindow( GW_HWNDFIRST); pWnd != NULL;
		     pWnd = pWnd->GetNextWindow( GW_HWNDNEXT)){
			if( m_pMainWnd == pWnd->GetParent()){
				if( pWnd == m_pMainWnd->GetActiveWindow() &&
				  ( ::GetCapture() == NULL))
					m_pMainWnd->SetActiveWindow();

				pWnd->SendMessage( WM_IDLEUPDATECMDUI,
						 (WPARAM)TRUE, 0L);
			}
		}
	}
	return CWinApp::OnIdle( lCount);
}
					
/************************************************/
/*						*/
/*   Open "EUDCEDIT.INI"			*/
/*   Set parameter of EUDC Editor		*/
/*						*/
/************************************************/
BOOL
CEudcApp::GetProfileText(
LPRECT 	MainWndRect,
UINT 	*MaxWndFlag)
{
	TCHAR	ProfileBuf[MAX_PATH], *pString;
	TCHAR	Separation[] = TEXT(" ,");
	INT	xScreen , yScreen;
	UINT	BitmapSiz;
	BYTE	Rcolor, Gcolor, Bcolor;
	CString	GridColor, CurvColor, FittColor, MainWnd;

//	Get system metrics
	CAPTION_HEIGHT = ::GetSystemMetrics( SM_CYCAPTION);
	xScreen = ::GetSystemMetrics( SM_CXSCREEN);
	yScreen = ::GetSystemMetrics( SM_CYSCREEN);

//	Read bitmapsize and maxflag
	BitmapSiz = this->GetProfileInt(TEXT("Bitmap"), TEXT("BitmapSize"), DEF_BITMAPSIZE);
	if( BitmapSiz <= 0)
		BitmapSiz = DEF_BITMAPSIZE;
	if( BitmapSiz > MAX_BITMAPSIZE)
		BitmapSiz = DEF_BITMAPSIZE;

	BitmapSiz = ((BitmapSiz + sizeof(WORD)-1)/sizeof(WORD))*sizeof(WORD);
	if( BitmapSiz > MAX_BITMAPSIZE)
		BitmapSiz = MAX_BITMAPSIZE;
	if( BitmapSiz < MIN_BITMAPSIZE)
		BitmapSiz = MIN_BITMAPSIZE;

	BITMAP_WIDTH  = BitmapSiz;
	BITMAP_HEIGHT = BitmapSiz;
	*MaxWndFlag = this->GetProfileInt(TEXT("WindowSize"), TEXT("MinMaxFlag"), 0);

//	Read color
	GridColor = this->GetProfileString(TEXT("Color"), TEXT("Grid"), TEXT("128 128 128"));
	CurvColor = this->GetProfileString(TEXT("Color"), TEXT("Curve"), TEXT("255 0 0"));
	FittColor = this->GetProfileString(TEXT("Color"), TEXT("Fitting"), TEXT("128 128 128"));

//	Read grid color
	ConvStringRes((TCHAR *)ProfileBuf, GridColor);
	if(( pString = Mytcstok( ProfileBuf, Separation)) == NULL)
		Rcolor = 0;
	else	Rcolor = (BYTE)Myttoi( pString);
	if(( pString = Mytcstok( NULL, Separation)) == NULL)
		Gcolor = 0;
	else	Gcolor = (BYTE)Myttoi( pString);
	if(( pString = Mytcstok( NULL, Separation)) == NULL)
		Bcolor = 0;
	else	Bcolor = (BYTE)Myttoi( pString);
	COLOR_GRID = RGB( Rcolor, Gcolor, Bcolor);

//	Read outline color
	ConvStringRes(ProfileBuf, CurvColor);
	if(( pString = Mytcstok( ProfileBuf, Separation)) == NULL)
		Rcolor = 0;
	else	Rcolor = (BYTE)Myttoi( pString);
	if(( pString = Mytcstok( NULL, Separation)) == NULL)
		Gcolor = 0;
	else	Gcolor = (BYTE)Myttoi( pString);
	if(( pString = Mytcstok( NULL, Separation)) == NULL)
		Bcolor = 0;
	else	Bcolor = (BYTE)Myttoi( pString);
	COLOR_CURVE = RGB( Rcolor, Gcolor, Bcolor);

//	Read bitmap color in show outline
	ConvStringRes(ProfileBuf, FittColor);
	if(( pString = Mytcstok( ProfileBuf, Separation)) == NULL)
		Rcolor = 0;
	else	Rcolor = (BYTE)Myttoi( pString);
	if(( pString = Mytcstok( NULL, Separation)) == NULL)
		Gcolor = 0;
	else	Gcolor = (BYTE)Myttoi( pString);
	if(( pString = Mytcstok( NULL, Separation)) == NULL)
		Bcolor = 0;
	else	Bcolor = (BYTE)Myttoi( pString);
	COLOR_FITTING = RGB( Rcolor, Gcolor, Bcolor);

//	Read main window size
	MainWnd = this->GetProfileString(TEXT("WindowSize"),TEXT("MainWindowSize"), TEXT(""));
	if( *MainWnd == '\0'){
		MainWndRect->left = 0;
		MainWndRect->top  = 0;
		MainWndRect->right = (xScreen/5)*4;
		MainWndRect->bottom =(yScreen/5)*4;
	}else{
		ConvStringRes(ProfileBuf, MainWnd);
		pString = Mytcstok( ProfileBuf, Separation);
		MainWndRect->left = Myttoi( pString);
		pString = Mytcstok( NULL, Separation);
		MainWndRect->top = Myttoi( pString);
		pString = Mytcstok( NULL, Separation);
		MainWndRect->right = Myttoi( pString);
		pString = Mytcstok( NULL, Separation);
		MainWndRect->bottom = Myttoi( pString);
	}
	return TRUE;
}

/************************************************/
/*						*/
/*	Get country information			*/
/*						*/
/************************************************/
BOOL
CEudcApp::GetCountryInfo()
{
	UINT	LocalCP;

	CountryInfo.CurrentRange = 0;
	CountryInfo.LangID = (int)GetSystemDefaultLCID();

	LocalCP = GetACP();

    CountryInfo.bUnicodeMode = FALSE;
	CountryInfo.bOnlyUnicode = FALSE;

	switch( CountryInfo.LangID){
	case EUDC_JPN:
		CountryInfo.CharacterSet = SHIFTJIS_CHARSET;
		break;
    case EUDC_HKG:
        CountryInfo.LangID = EUDC_CHT;
        //
        // fall through
        //
	case EUDC_CHT:
		CountryInfo.CharacterSet = CHINESEBIG5_CHARSET;
		break;
	case EUDC_KRW:
		CountryInfo.CharacterSet = HANGEUL_CHARSET;
		break;
    case EUDC_SIN:
        CountryInfo.LangID = EUDC_CHS;
        //
        // Fall through
        //
	case EUDC_CHS:
		CountryInfo.CharacterSet = GB2312_CHARSET;
		break;
	default:
    CHARSETINFO csi;
    if (TranslateCharsetInfo((DWORD*)IntToPtr(LocalCP), &csi, TCI_SRCCODEPAGE))
       CountryInfo.CharacterSet = csi.ciCharset;
		CountryInfo.bOnlyUnicode = TRUE;
   	CountryInfo.bUnicodeMode = TRUE;
    lstrcpy(CountryInfo.szForceFont, _T("Microsoft Sans Serif"));
		break;
	}
	if( !SetCountryInfo( LocalCP))
		return FALSE;
	else 	return TRUE;
}

/************************************************/
/*						*/
/*	Get Cursor resource file		*/
/*						*/
/************************************************/
BOOL
CEudcApp::GetCursorRes()
{
	int	i;

//	For tool cursor
	ToolCursor[PEN]        = this->LoadCursor(IDC_PENCIL);
	ToolCursor[BRUSH]      = this->LoadCursor(IDC_BRUSH);
	ToolCursor[CIRCLE]     = this->LoadStandardCursor(IDC_CROSS);
	ToolCursor[CIRCLEFILL] = this->LoadStandardCursor(IDC_CROSS);
	ToolCursor[SLOPE]      = this->LoadStandardCursor(IDC_CROSS);
	ToolCursor[RECTBAND]   = this->LoadStandardCursor(IDC_CROSS);
	ToolCursor[RECTFILL]   = this->LoadStandardCursor(IDC_CROSS);
	ToolCursor[FREEFORM]   = this->LoadStandardCursor(IDC_CROSS);
	ToolCursor[RECTCLIP]   = this->LoadStandardCursor(IDC_CROSS);
	ToolCursor[ERASER]     = this->LoadCursor(IDC_ERASER);
	for( i = PEN; i <= ERASER; i++){
		if( ToolCursor[i] == NULL){
			return FALSE;
		}
	}
	
//	For select rectangle cursur
	ArrowCursor[VERTICAL]  = this->LoadStandardCursor(
				 MAKEINTRESOURCE(IDC_SIZEWE));
	ArrowCursor[RIGHTSLOPE]= this->LoadStandardCursor(
				 MAKEINTRESOURCE(IDC_SIZENESW));
	ArrowCursor[LEFTSLOPE] = this->LoadStandardCursor(
				 MAKEINTRESOURCE(IDC_SIZENWSE));
	ArrowCursor[HORIZONTAL]= this->LoadStandardCursor(
				 MAKEINTRESOURCE(IDC_SIZENS));
	ArrowCursor[ALLDIRECT] = this->LoadStandardCursor(
				 MAKEINTRESOURCE(IDC_SIZEALL));
	for( i = VERTICAL; i <= ALLDIRECT; i++){
		if( ArrowCursor[i] == NULL){
			return FALSE;
		}
	}
	return TRUE;
}

/************************************************/
/*						*/
/*	Get help file path			*/
/*						*/
/************************************************/
BOOL
CEudcApp::GetFilePath()
{
	if( !GetSystemWindowsDirectory( FontPath, MAX_PATH))
		return FALSE;
	lstrcat(FontPath, TEXT("\\"));

	lstrcpy(HelpPath, FontPath);
    lstrcpy(ChmHelpPath, FontPath);
	lstrcat(HelpPath, TEXT("Help\\EUDCEDIT.HLP"));
    lstrcat(ChmHelpPath, TEXT("Help\\EUDCEDIT.CHM"));

	NotMemTtl.LoadString( IDS_MAINFRAMETITLE);
	NotMemMsg.LoadString( IDS_NOTENOUGHMEMORY_ERROR);

	return TRUE;
}

/************************************************/
/*						*/
/*	COMMAND 	"About"			*/
/*						*/
/************************************************/
void
CEudcApp::OnAppAbout()
{
	HICON	hIcon;
	TCHAR	TitleBuf[50];

	hIcon = LoadIcon( IDR_MAINFRAME);

	GetStringRes((TCHAR *)TitleBuf, IDS_MAINFRAMETITLE);
	ShellAbout( m_pMainWnd->GetSafeHwnd(), TitleBuf, TEXT(""), hIcon);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\eudclist.cpp ===
/**************************************************/
/*						                          */
/*						                          */
/*   EUDC Character List ( Japan, China, Korea)	  */
/*						                          */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include 	"stdafx.h"
#include 	"eudcedit.h"
#include 	"eudclist.h"
#include	"util.h"

#ifdef BUILD_ON_WINNT
#include    "extfunc.h"
#endif // BUILD_ON_WINNT


/* Matrics of Characterlist */
#define		NUM_CHAR	16	// Row  of matrics
#define		NUM_LINE	6	// Line of matrics

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE( CEudcList, CEdit)
BEGIN_MESSAGE_MAP( CEudcList, CEdit)
	//{{AFX_MSG_MAP( CEudcList)
	ON_WM_PAINT()
	ON_WM_VSCROLL()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_SETCURSOR()
	ON_WM_KEYDOWN()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_WM_RBUTTONUP()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

#ifdef BUILD_ON_WINNT
static CRect	rcColumnHead[NUM_CHAR];
#endif //BUILD_ON_WINNT
static CRect	rcEditChar[NUM_LINE][NUM_CHAR];
static CRect	rcEditCode[NUM_LINE];
static BYTE	ViewCode[NUM_LINE];
static BOOL   bHasGlyph;
#define EUDCCODEBASE    ((unsigned short)0xe000)

/****************************************/
/*					*/
/*	Default Constructor		*/
/*					*/
/****************************************/
CEudcList::CEudcList()
{
//	Initialize parameter( Japan, China and Korea)
	SetInitEUDCCodeRange( CountryInfo.CurrentRange);
	FocusFlag = FALSE;
}

/****************************************/
/*					*/
/*	Set coderange of EUDC		*/
/*					*/
/****************************************/
void
CEudcList::SetInitEUDCCodeRange(
int 	nIndex)
{
	m_Index = nIndex;
	EUDC_SCode = CountryInfo.sRange[m_Index];
	EUDC_ECode = CountryInfo.eRange[m_Index];

    EUDC_EView =(CountryInfo.eRange[m_Index] & 0xfff0) -(0x10*(NUM_LINE-1));
	if( SelectEUDC.m_Code[0] != '\0'){
		SelectCode = (WORD)Mytcstol(SelectEUDC.m_Code, (TCHAR **)0, 16);
		EUDC_SView = (WORD)Mytcstol(SelectEUDC.m_Code, (TCHAR **)0, 16);
		EUDC_SView &= 0xfff0;
		if( EUDC_EView <= EUDC_SView)
			EUDC_SView = EUDC_EView;
	}else{
		EUDC_SView = CountryInfo.sRange[m_Index] & 0xfff0;
		SelectCode = EUDC_SCode;
		
	}
	
#ifdef BUILD_ON_WINNT
    //In case of CHS, each range will have a different trail byte range
    //after user selects a new range, we have to correct them with
    //sOrigTralByte and eOrigTralByte and form new trail byte range.
    if (CountryInfo.LangID == EUDC_CHS && !CountryInfo.bUnicodeMode)
        CorrectTrailByteRange(m_Index);
#endif // BUILD_ON_WINNT

	LButtonPt.x = LButtonPt.y = 0;
	ScrlBarPos = (short)GetBarPosition( EUDC_SView);
	this->SetScrollPos( SB_VERT, ScrlBarPos, TRUE);
}

/****************************************/
/*					*/
/*	Set coderange of EUDC		*/
/*					*/
/****************************************/
void
CEudcList::SetEUDCCodeRange(
int 	nIndex)
{
	m_Index = nIndex;
	EUDC_SView = CountryInfo.sRange[m_Index] & 0xfff0;
    EUDC_EView =(CountryInfo.eRange[m_Index] & 0xfff0) -(0x10*(NUM_LINE-1));
	EUDC_SCode = CountryInfo.sRange[m_Index];
	EUDC_ECode = CountryInfo.eRange[m_Index];

#ifdef BUILD_ON_WINNT
    //In case of CHS, each range will have a different trail byte range
    //after user selects a new range, we have to correct them with
    //sOrigTralByte and eOrigTralByte and form new trail byte range.
    if (CountryInfo.LangID == EUDC_CHS && !CountryInfo.bUnicodeMode)
        CorrectTrailByteRange(m_Index);
#endif // BUILD_ON_WINNT

	SelectCode = (WORD)EUDC_SCode;
	LButtonPt.x = LButtonPt.y = 0;
	ScrlBarPos = (short)0;
	this->SetScrollPos( SB_VERT, ScrlBarPos, TRUE);
}


/****************************************/
/*					*/
/*	Destructor			*/
/*					*/
/****************************************/
CEudcList::~CEudcList()
{
    	SysFFont.DeleteObject();
   	EUDCFont.DeleteObject();
}

/****************************************/
/*					*/
/*	Correct it if code is illegal 	*/
/*					*/
/****************************************/
WORD
CEudcList::CorrectEUDCCode(
WORD 	Code,
BOOL 	UporDown)
{
COUNTRYINFO	Info;
	WORD	wCode;
	BYTE 	LByte, HByte;
	int	TralPos = 0;

	LByte = LOBYTE( Code);
	HByte = HIBYTE( Code);
	Info = CountryInfo;

    //decide code falls in which trail byte range
	for( int i = 0; i < Info.nTralByte; i++){
		if( LByte >= (Info.sTralByte[i] & 0xf0) &&
		    LByte <= (Info.eTralByte[i] & 0xf0)){
		    	goto RET;
		}else if( LByte < (Info.sTralByte[i] & 0xf0)){
			TralPos = i;
			break;
		}else	TralPos = i+1;
	}

#ifdef BUILD_ON_WINNT
    // If we are going up on the code range, make the code in the first
    // first line of next valid trailbyte. Otherwise make the code in
    // the last line the preivous valid range.
	if( UporDown){
		if( TralPos == Info.nTralByte){
            TralPos =0;
			HByte += 0x1;
		}
        LByte = Info.sTralByte[TralPos] & 0xf0;
	}else{
		if( TralPos ==0 ){
			HByte -= 0x1;
            TralPos = Info.nTralByte;
        }
	    LByte = Info.eTralByte[TralPos-1] & 0xf0;
	}
#else
	if( UporDown)
		if( TralPos == Info.nTralByte){
			LByte = (Info.sTralByte[0] & 0xf0);
			HByte += 0x1;
		}else 	LByte = (Info.sTralByte[TralPos] & 0xf0);
	else{
		if( !TralPos){
			LByte = (Info.eTralByte[Info.nTralByte-1] & 0xf0);
			HByte -= 0x1;
		}else	LByte = (Info.eTralByte[TralPos-1] & 0xf0);
	}
#endif // BUILD_ON_WINNT

RET:
	wCode = MAKEWORD( LByte, HByte);
	return wCode;
}

/****************************************/
/*					*/
/*	Get position of scrollbar	*/
/*					*/		
/****************************************/
#ifdef BUILD_ON_WINNT
int
CEudcList::GetBarPosition(
WORD 	Code)
{
COUNTRYINFO	Info;
	WORD 	NumPage=0, NumCode=0;
	BYTE	Space[MAX_LEADBYTES];
	int	TotalSpace=0,TralPos=0;
	int	Err;
    BOOL ValidCode=FALSE;

	Info = CountryInfo;
	NumPage = HIBYTE( Code) - HIBYTE( EUDC_SCode);

    // Calculate each code space block for each trail byte range
    // and decide how many of each we count.

    /* space before first trailbyte range */
	Space[0] = ( Info.sTralByte[0] & 0xf0);
	for( int i = 1; i < Info.nTralByte; i++){
		Space[i] = (( Info.sTralByte[i]   & 0xf0)
			 -  ( Info.eTralByte[i-1] & 0xf0) - 0x10);
	}

    /* space after last trailbyte range */
	Space[i] = (0xff - Info.eTralByte[Info.nTralByte-1]) & 0xf0;

    for (i = 0; i < Info.nTralByte; i++)
        if( LOBYTE( Code) >= (Info.sTralByte[i] & 0xf0) &&
            LOBYTE( Code) <= (Info.eTralByte[i] & 0xff)){
            ValidCode=TRUE; //within our trail byte range.
            TralPos=i;
            break;
        }

    if (!ValidCode)
        return(0);  //not within our trail byte range.

    for (i = 0; i < Info.nTralByte; i++){
        if (Info.sTralByte[TralPos] >  LOBYTE( EUDC_SCode )){
            if((Info.sTralByte[i])  > LOBYTE(EUDC_SCode)  && i <= TralPos)
                TotalSpace += Space[i] * (NumPage + 1);
            else
                TotalSpace += Space[i] * NumPage ;
        }else{
            if((Info.sTralByte[i] & 0xf0) < LOBYTE(EUDC_SCode) && i > TralPos)
                TotalSpace += Space[i] * (NumPage - 1);
            else
                TotalSpace += Space[i] * NumPage ;
        }

	}
    TotalSpace += Space[i] * NumPage;

    Err = EUDC_SCode & 0x000f;
	NumCode = Code - EUDC_SCode - TotalSpace + Err;
	return( NumCode /NUM_CHAR);
}
#else
int
CEudcList::GetBarPosition(
WORD 	Code)
{
COUNTRYINFO	Info;
	WORD 	NumPage, NumCode;
	BYTE	Space[MAX_LEADBYTES];
	int	LoSpace, HiSpace;
	int	Err;

	Info = CountryInfo;
	NumPage = HIBYTE( Code) - HIBYTE( EUDC_SCode);
	Space[0] = ( Info.sTralByte[0] & 0xf0);
	Space[1] = 0x00;
	for( int i = 1; i < Info.nTralByte; i++){
		Space[i] = (( Info.sTralByte[i]   & 0xf0)
			 -  ( Info.eTralByte[i-1] & 0xf0) - 0x10);
	}

	for( i = 0; i < Info.nTralByte; i++){
		if( LOBYTE( Code) >= (Info.sTralByte[i] & 0xf0) &&
		    LOBYTE( Code) <= (Info.eTralByte[i] & 0xff)){
		    	if( LOBYTE( EUDC_SCode) > Info.sTralByte[0]){
				LoSpace = ( Space[0] * NumPage);
				HiSpace = ( Space[1] * (i + NumPage - 1));
			}else{
				LoSpace = ( Space[0] * NumPage);
				HiSpace = ( Space[1] * (i + NumPage));
			}
			Err = EUDC_SCode & 0x000f;
			NumCode = Code - EUDC_SCode - LoSpace - HiSpace + Err;
			break;
		}
	}
	return( NumCode /NUM_CHAR);
}
#endif // BUILD_ON_WINNT

/****************************************/
/*					*/
/*	Calculate bar pos from code	*/
/*					*/
/****************************************/
WORD
CEudcList::GetCodeScrPos(
int 	Pos)
{
	WORD	i;
	WORD	Code = 0;
	WORD	NumLine  = 0;
	WORD	PNumLine = 0;

	if( !Pos)
        	return( EUDC_SCode & 0xfff0);
#ifdef BUILD_ON_WINNT
    // we dont't need to go through each char, instead we can examine each
    // line to make this faster
	for( i = EUDC_SCode; i <= EUDC_ECode;  i+= NUM_CHAR){
#else
	for( i = EUDC_SCode; i <= EUDC_ECode;  ++i){
#endif // BUILD_ON_WINNT
    		NumLine = (WORD)GetBarPosition( i);
        	if( NumLine >= Pos){
        		NumLine = PNumLine;
            		break;
        	}
        	PNumLine = NumLine;
   	}
	Code = i;
	Pos -= NumLine;
	Code &= 0xfff0;

	return Code;
}

#define	FIX_SPACE	6
#define	LINEWIDTH	4
/****************************************/
/*					*/
/*	Calcurate character size 	*/
/*					*/
/****************************************/
void
CEudcList::CalcCharSize()
{
	TCHAR	Dummy[] = TEXT("FA40");
	int	Sx;
	int	OldMode;

	CClientDC	dc( this);

	this->GetClientRect( &EditListRect);
	OldMode = dc.SetMapMode( MM_TEXT);

	CFont	*OldFont = dc.SelectObject( &SysFFont);
	GetTextExtentPoint32( dc.GetSafeHdc(), Dummy, 4, &FixSize);
	FixSize.cx += FIX_SPACE;
	dc.SelectObject( OldFont);

	CharSize.cy = ( EditListRect.Height()
		- (NUM_LINE-1)*LINEWIDTH - 2) / NUM_LINE;
	CharSize.cx = ( EditListRect.Width()
		- FixSize.cx - 2 - (NUM_CHAR*LINEWIDTH)) / NUM_CHAR;

	for( int i = 0; i < NUM_LINE; i++){
		rcEditCode[i].left   = 1;
		rcEditCode[i].top    = 1 + i*( CharSize.cy + LINEWIDTH);
		rcEditCode[i].right  = rcEditCode[i].left + FixSize.cx;
		rcEditCode[i].bottom = rcEditCode[i].top  + CharSize.cy;
		Sx = rcEditCode[i].right + LINEWIDTH;
		for( int j = 0; j < NUM_CHAR; j++){
			rcEditChar[i][j].left   = Sx +j*(CharSize.cx+LINEWIDTH);
			rcEditChar[i][j].top    = rcEditCode[i].top;
			rcEditChar[i][j].right  = rcEditChar[i][j].left
						+ CharSize.cx;
			rcEditChar[i][j].bottom = rcEditChar[i][j].top
						+ CharSize.cy;
		}
	}
#ifdef BUILD_ON_WINNT
	for( int j = 0; j < NUM_CHAR; j++){
		rcColumnHead[j].left   = Sx +j*(CharSize.cx+LINEWIDTH);
		rcColumnHead[j].top    = 1;
		rcColumnHead[j].right  = rcColumnHead[j].left + CharSize.cx;
		rcColumnHead[j].bottom = 1 + FixSize.cy;
    }
#endif //BUILD_ON_WINNT
	dc.SetMapMode( MM_TEXT);
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_PAINT"		*/
/*					*/
/****************************************/
void
CEudcList::OnPaint()
{
	register int	i, j, k;
	WORD    Code;
	CFont	*OldFont;
	BYTE    Glyph[800];
	BOOL    bGlyph = FALSE;

	CPaintDC	dc( this);
	int BottomCode = GetBarPosition((WORD)EUDC_EView);
	SetScrollRange( SB_VERT, 0, BottomCode, FALSE);
	this->SetScrollPos( SB_VERT, ScrlBarPos, TRUE);

	Code = EUDC_SView;
	int OldMapMode = dc.SetMapMode( MM_TEXT);
	dc.SetViewportOrg( 0, 0);
	OldFont = dc.SelectObject( &SysFFont);

	//
	// access *.euf to set bits in the array (800 * 8 = 6400)
	// to indicate a char has a glyph
	//
	bGlyph = GetGlyph(SelectEUDC.m_File, Glyph);
	for( i = 0; i < NUM_LINE; i++){
		BYTE	CodeArray[10];
		int	xOffset, yOffset;

//	Check character code
		dc.SelectObject( &SysFFont);
		Code = CorrectEUDCCode( Code, TRUE);
		wsprintf((LPTSTR)CodeArray, TEXT("%04X"), Code);

		dc.SetBkColor( COLOR_FACE);
		dc.SetTextColor(GetSysColor(COLOR_WINDOWTEXT)); // COLOR_BLACK);
		if( rcEditChar[i][0].Height() > FixSize.cy){
			yOffset = ( rcEditChar[i][0].Height() - FixSize.cy) /2;
		}else	yOffset = 0;

    ExtTextOut( dc.GetSafeHdc(), rcEditCode[i].left,
				rcEditCode[i].top  + yOffset,
				ETO_OPAQUE, &rcEditCode[i],
				(LPCTSTR)CodeArray, 4, NULL);

		dc.SelectObject( &EUDCFont);
		for( j = 0; j < NUM_CHAR; j++,Code++){
			BYTE	sOffset;
			CSize	cSize;
			BOOL	flg;
			int	wLength;

            //
            // see if the character has a glyph
            //
            bHasGlyph = TRUE;
            if(bGlyph == TRUE)
            {
                WORD  wIndex;
								if (CountryInfo.bUnicodeMode)
									wIndex = Code - EUDCCODEBASE;
								else
								{
									CHAR  pchar[3];
									WCHAR wpchar[2];
									pchar[0] = HIBYTE(Code);
									pchar[1] = LOBYTE(Code);
									pchar[2] = 0;
									MultiByteToWideChar(CP_ACP, 0, pchar, 2, wpchar, 1);
									wIndex = wpchar[0] - EUDCCODEBASE;
								}
                if((Glyph[wIndex>>3] & (0x80>>(wIndex%8))) == 0)
                    bHasGlyph = FALSE;
            }
            //fix for FontIsLinked
            else
              bHasGlyph = FALSE;
            //

			flg = FALSE;
			sOffset = LOBYTE( Code);
			for( k = 0; k < CountryInfo.nTralByte; k++){
				if( sOffset >= CountryInfo.sTralByte[k] &&
				    sOffset <= CountryInfo.eTralByte[k]){
				    	flg = TRUE;
				}
			}
			if((Code < CountryInfo.sRange[cRange])
			||(Code > CountryInfo.eRange[cRange]))
				flg = FALSE;


			if( !flg) 	continue;

			if (CountryInfo.bUnicodeMode){
                CodeArray[1] = HIBYTE(Code);
                CodeArray[0] = LOBYTE(Code);
                wLength = 1;
      }
			else{
                CodeArray[0] = HIBYTE(Code);
                CodeArray[1] = LOBYTE(Code);
								wLength = 2;
      }
    	CodeArray[2] = (BYTE)'\0';
			
			BOOL	PtIn;

			if(( rcEditChar[i][j].PtInRect( LButtonPt) ||
			     SelectCode == Code) && wLength != 0){
				TCHAR	CodeNum[10];

//				If character is selected by left clickking ,
//				Put it on dialog.
				PtIn = TRUE;
				SelectCode = Code;
				dc.SetBkColor(COLOR_FACE);
				dc.SetTextColor(GetSysColor(COLOR_WINDOWTEXT)); // COLOR_BLACK);
				wsprintf(CodeNum, TEXT("%04X"),Code);

				GetParent()->SetDlgItemText(IDC_CODECUST,CodeNum);

        if (CountryInfo.bUnicodeMode)
        {
           lstrcpyW((WCHAR *)ViewCode, (WCHAR *)CodeArray);
        }
        else
        {
           lstrcpyA((CHAR *)ViewCode, (CHAR *)CodeArray);
        }
				GetParent()->SendMessage( WM_VIEWUPDATE, 0, 0);
			}else{
				PtIn = FALSE;
				dc.SetBkColor( COLOR_FACE);
				dc.SetTextColor( GetSysColor(COLOR_WINDOWTEXT));  //COLOR_BLACK);
			}

      if (CountryInfo.bUnicodeMode)
			  GetTextExtentPoint32W( dc.GetSafeHdc(), (LPCWSTR)CodeArray, wLength, &cSize);
      else
    		GetTextExtentPoint32A( dc.GetSafeHdc(),	(LPCSTR)CodeArray, wLength, &cSize);

			if( rcEditChar[i][j].Width() > cSize.cx){
				xOffset = rcEditChar[i][j].Width() - cSize.cx;
				xOffset /= 2;
			}else	xOffset = 0;

			if( rcEditChar[i][j].Height() > cSize.cy){
				yOffset = rcEditChar[i][j].Height() - cSize.cy;
				yOffset /= 2;
			}else	yOffset = 0;

            if(bHasGlyph == TRUE)
            {
                if (CountryInfo.bUnicodeMode)
                {
#ifdef UNICODE
                    ExtTextOutW(dc.GetSafeHdc(),rcEditChar[i][j].left + xOffset,
                        rcEditChar[i][j].top + yOffset, ETO_OPAQUE,
                        &rcEditChar[i][j], (LPCWSTR)CodeArray, wLength, NULL);
		
#else
                    CHAR ViewTmp[2];
                    wLength = WideCharToMultiByte(CP_ACP, 0, (LPWSTR) CodeArray, 1, ViewTmp, 2, NULL, NULL);
                    ExtTextOutA(dc.GetSafeHdc(),rcEditChar[i][j].left + xOffset,
                        rcEditChar[i][j].top + yOffset, ETO_OPAQUE,
                        &rcEditChar[i][j], (LPCSTR)ViewTmp, wLength, NULL);
#endif
                }
                else
                {
                    ExtTextOutA(dc.GetSafeHdc(), rcEditChar[i][j].left + xOffset,
                        rcEditChar[i][j].top + yOffset, ETO_OPAQUE,
                        &rcEditChar[i][j], (LPCSTR)CodeArray,
                        wLength, NULL);
                }
            }
			DrawConcave( &dc, rcEditChar[i][j], PtIn);
		}
	}
	dc.SetMapMode( OldMapMode);
	dc.SelectObject( OldFont);

	LButtonPt.x = LButtonPt.y = 0;
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_VSCROLL"		*/
/*					*/
/****************************************/
void
CEudcList::OnVScroll(
UINT 	nSBCode,
UINT 	nPos,
CScrollBar* pScrollBar)
{
	int	MoveScr;
	BOOL	ThumbTrkFlag;
	BOOL	ThumbPosFlag;

	MoveScr = 0;
	ThumbTrkFlag = FALSE;
	ThumbPosFlag = FALSE;
	BarRange = GetBarPosition((WORD)EUDC_EView);
	SetScrollRange( SB_VERT, 0, BarRange, FALSE);
	switch( nSBCode)
	{
		case SB_LINEDOWN:
			if(( EUDC_SView + NUM_CHAR) <= EUDC_EView){
				MoveScr =  0 - (CharSize.cy + LINEWIDTH);
				EUDC_SView += NUM_CHAR;
				EUDC_SView  = CorrectEUDCCode(EUDC_SView,TRUE);
				ScrlBarPos = (short)GetBarPosition( EUDC_SView);
			}
			break;

		case SB_LINEUP:
			if(( EUDC_SView - NUM_CHAR) >= ( EUDC_SCode & 0xfff0)){
				MoveScr = CharSize.cy + LINEWIDTH;
				EUDC_SView -= NUM_CHAR;
				EUDC_SView = CorrectEUDCCode(EUDC_SView,FALSE);
				ScrlBarPos = (short)GetBarPosition( EUDC_SView);
			}
			break;

		case SB_PAGEDOWN:
			if(( EUDC_SView + NUM_CHAR*NUM_LINE) <= EUDC_EView){
				MoveScr = ( 0-(CharSize.cy+LINEWIDTH))*NUM_LINE;
				ScrlBarPos = (short)GetBarPosition( EUDC_SView);
				ScrlBarPos += NUM_LINE;
				EUDC_SView = GetCodeScrPos( ScrlBarPos);
			}else{
				MoveScr = ( 0-(CharSize.cy+LINEWIDTH))*NUM_LINE;
				EUDC_SView = EUDC_EView;
				ScrlBarPos = (short)GetBarPosition( EUDC_SView);	
			}
			break;

		case SB_PAGEUP:
			if(( EUDC_SView - NUM_CHAR*NUM_LINE)
				>= ( EUDC_SCode & 0xfff0)){
				MoveScr = (CharSize.cy + LINEWIDTH)*NUM_LINE;
				ScrlBarPos = (short)GetBarPosition( EUDC_SView);
				ScrlBarPos -= NUM_LINE;
				EUDC_SView = GetCodeScrPos( ScrlBarPos);
			}else{
				MoveScr = (CharSize.cy + LINEWIDTH)*NUM_LINE;
				EUDC_SView = (EUDC_SCode & 0xfff0);
				ScrlBarPos = (short)GetBarPosition( EUDC_SView);
			}
			break;

		case SB_TOP:
			EUDC_SView = ( EUDC_SCode & 0xfff0);
			ScrlBarPos = 0;
			break;

		case SB_BOTTOM:
			EUDC_SView = EUDC_EView;
			ScrlBarPos = (short)BarRange;
			break;

		case SB_THUMBPOSITION:
			ThumbPosFlag = TRUE;
			ScrlBarPos = (short)nPos;
			EUDC_SView = GetCodeScrPos( nPos);
			break;

		case SB_THUMBTRACK:
			ThumbTrkFlag = TRUE;
			break;

		default:
			break;
	}

	if( abs( MoveScr) < (CharSize.cy + LINEWIDTH)*NUM_LINE &&
		abs( MoveScr) > 0 && !ThumbTrkFlag){
		CRect	ScrllRect;
		CRect	ClintRect;

		GetClientRect( &ClintRect);
		ScrllRect.CopyRect( &ClintRect);
		if( MoveScr < 0){
			ClintRect.top = 0 - MoveScr;
			this->ScrollWindow( 0, MoveScr, &ClintRect, NULL);
			ScrllRect.top = ( 0 - MoveScr)*(NUM_LINE-1);			
		}else{
			ClintRect.top = LINEWIDTH;
			ClintRect.bottom = MoveScr*(NUM_LINE - 1);
			this->ScrollWindow( 0, MoveScr, &ClintRect, NULL);
			ScrllRect.top = 0;
			ScrllRect.bottom = ScrllRect.top + MoveScr;
		}
		this->InvalidateRect( &ScrllRect, FALSE);
	}else if(!ThumbTrkFlag && ( MoveScr || ThumbPosFlag)){
		this->Invalidate( TRUE);
	}
	this->SetScrollPos( SB_VERT, ScrlBarPos, TRUE);
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_LBUTTONDOWN"	*/
/*					*/
/****************************************/
void
CEudcList::OnLButtonDown(
UINT 	nFlags,
CPoint 	point)
{
	CRect	test;
	BOOL	PtIn;
unsigned int	i, j;

	PtIn = FALSE;
	this->SetFocus();
	for( i = 0; i < NUM_LINE; i++){
		for( j = 0; j < NUM_CHAR; j++){
			if( rcEditChar[i][j].PtInRect( point)){
				if( IsCorrectChar( i, j))
					PtIn = TRUE;
				break;
			}
		}
	}
	if( !PtIn){
		MessageBeep((UINT)-1);
		return;
	}

	LButtonPt = point;
	SearchSelectPosition();
	SelectCode = 0;


	for( i = 0; i < NUM_LINE; i++){
		for( j = 0; j < NUM_CHAR; j++){
			if( rcEditChar[i][j].PtInRect( LButtonPt)){

				test.SetRect( rcEditChar[i][j].left - 2,
						rcEditChar[i][j].top - 2,
						rcEditChar[i][j].right + 2,
						rcEditChar[i][j].bottom + 2);

				this->InvalidateRect( &test, FALSE);

				break;
			}
		}
	}


	this->UpdateWindow();

}

/****************************************/
/*					*/
/*	MESSAGE	"WM_LBUTTONDBLCLK"	*/
/*					*/
/****************************************/
void
CEudcList::OnLButtonDblClk(
UINT 	nFlags,
CPoint 	point)
{
	BOOL 	PtIn;
unsigned int	i, j;

	LButtonPt = point;
	this->Invalidate( FALSE);
	this->UpdateWindow();

	PtIn = FALSE;
	this->SetFocus();
	for( i = 0; i < NUM_LINE; i++){
		for( j = 0; j < NUM_CHAR; j++){
			if( rcEditChar[i][j].PtInRect( point)){
				if( IsCorrectChar( i, j))
					PtIn = TRUE;
				break;
			}
		}
	}
	if( !PtIn){
		MessageBeep((UINT)-1);
		return;
	}else{
		GetParent()->PostMessage( WM_COMMAND, IDOK, 0L);
	}
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_SETCURSOR"		*/
/*					*/
/****************************************/
BOOL
CEudcList::OnSetCursor(
CWnd* 	pWnd,
UINT 	nHitTest,
UINT 	message)
{
	::SetCursor( AfxGetApp()->LoadStandardCursor(IDC_ARROW));
	return TRUE;
}

/****************************************/
/*					*/
/*	Draw ConcaveRectangle		*/
/*					*/
/****************************************/
void
CEudcList::DrawConcave(
CDC 	*dc,
CRect 	rect,
BOOL 	PtIn)
{
	CBrush	ConBrush, *OldBrush;
	CRect	Rt, Rf;

	Rt.SetRect( rect.left-1, rect.top-1, rect.right+1, rect.bottom+1);
	Rf.CopyRect( &rect);

	if( !PtIn){
		ConBrush.CreateSolidBrush( COLOR_HLIGHT);
		OldBrush = dc->SelectObject( &ConBrush);
		dc->PatBlt( Rt.left, Rt.top, Rt.Width(), 1, PATCOPY);
		dc->PatBlt( Rt.left, Rt.top, 1, Rt.Height(), PATCOPY);
		dc->SelectObject( OldBrush);
		ConBrush.DeleteObject();

		ConBrush.CreateSolidBrush( COLOR_SHADOW);
		OldBrush = dc->SelectObject( &ConBrush);
		dc->PatBlt( Rt.left, Rt.bottom, Rt.Width(), 1, PATCOPY);
		dc->PatBlt( Rt.right, Rt.top, 1, Rt.Height()+1, PATCOPY);
		dc->SelectObject( OldBrush);
		ConBrush.DeleteObject();

		if( FocusFlag){
			CBrush	fBrush;
			CPen	fPen, *OldPen;

			fBrush.CreateStockObject( NULL_BRUSH);
			fPen.CreatePen( PS_SOLID, 1, COLOR_FACE);
			OldBrush = dc->SelectObject( &fBrush);
			OldPen   = dc->SelectObject( &fPen);
			dc->Rectangle( &Rf);
			dc->SelectObject( OldBrush);
			dc->SelectObject( OldPen);
			fBrush.DeleteObject();
			fPen.DeleteObject();
		}
	}else{
		ConBrush.CreateSolidBrush( COLOR_SHADOW);
		OldBrush = dc->SelectObject( &ConBrush);
	        dc->PatBlt( Rt.left, Rt.top, Rt.Width(), 1, PATCOPY);
		dc->PatBlt( Rt.left, Rt.top, 1, Rt.Height(), PATCOPY);
		dc->SelectObject( OldBrush);
		ConBrush.DeleteObject();

		ConBrush.CreateSolidBrush( COLOR_HLIGHT);
		OldBrush = dc->SelectObject( &ConBrush);
		dc->PatBlt( Rt.left, Rt.bottom, Rt.Width(), 1, PATCOPY);
		dc->PatBlt( Rt.right, Rt.top, 1, Rt.Height()+1, PATCOPY);
		dc->SelectObject( OldBrush);
		ConBrush.DeleteObject();

		if( FocusFlag){
			CBrush	fBrush;
			CPen	fPen, *OldPen;

			fBrush.CreateStockObject( NULL_BRUSH);
			fPen.CreatePen( PS_SOLID, 1, COLOR_SHADOW);
			OldBrush = dc->SelectObject( &fBrush);
			OldPen   = dc->SelectObject( &fPen);
			dc->Rectangle( &Rf);
			dc->SelectObject( OldBrush);
			dc->SelectObject( OldPen);
			fBrush.DeleteObject();
			fPen.DeleteObject();
		}
	}
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_KEYDOWN"		*/
/*					*/
/****************************************/
void
CEudcList::OnKeyDown(
UINT 	nChar,
UINT	nRepCnt,
UINT 	nFlags)
{
	int	sPos;
	int	ePos;
#ifdef BUILD_ON_WINNT
    int i;
	WORD	TmpCode;
#endif // BUILD_ON_WINNT

	if( nChar == VK_DOWN  || nChar == VK_UP  ||
	    nChar == VK_RIGHT || nChar == VK_LEFT){
		sPos = GetBarPosition( EUDC_SView);
		ePos = GetBarPosition( SelectCode);
		if( ePos - sPos >= NUM_LINE || ePos < sPos){
			EUDC_SView = SelectCode & 0xfff0;
			ScrlBarPos = (short)GetBarPosition( EUDC_SView);
			this->Invalidate(FALSE);
			this->UpdateWindow();
		}

		switch( nChar){

		case VK_DOWN:
			if( SelectCode + NUM_CHAR > EUDC_ECode)
				break;
#ifdef BUILD_ON_WINNT
			TmpCode = SelectCode + NUM_CHAR;
			TmpCode = CorrectEUDCCodeKey( TmpCode, NUM_CHAR, TRUE);
			sPos = GetBarPosition( EUDC_SView);
			ePos = GetBarPosition( TmpCode);
			for (i=0;i <= ePos - sPos - NUM_LINE; i++){
#else
			if( ePos - sPos >= NUM_LINE - 1){
#endif // BUILD_ON_WINNT
				this->SendMessage( WM_VSCROLL, SB_LINEDOWN, 0);
			}
			SearchSelectPosition();
			SelectCode += NUM_CHAR;
			SelectCode = CorrectEUDCCodeKey( SelectCode,
							NUM_CHAR, TRUE);
			SearchSelectPosition();
			this->UpdateWindow();
			break;

		case VK_UP:
			if( SelectCode - NUM_CHAR < EUDC_SCode)
				break;
#ifdef BUILD_ON_WINNT
			TmpCode = SelectCode - NUM_CHAR;
			TmpCode = CorrectEUDCCodeKey( TmpCode, NUM_CHAR, FALSE);
			sPos = GetBarPosition( EUDC_SView);
			ePos = GetBarPosition( TmpCode);
			for ( i=0; i < sPos - ePos; i++){
#else
			if( SelectCode - NUM_CHAR < EUDC_SView){
#endif // BUILD_ON_WINNT
				this->SendMessage( WM_VSCROLL, SB_LINEUP, 0);
			}

			SearchSelectPosition();
			SelectCode -= NUM_CHAR;
			SelectCode = CorrectEUDCCodeKey( SelectCode,
							NUM_CHAR, FALSE);
			SearchSelectPosition();
			this->UpdateWindow();
			break;

		case VK_LEFT:
			if( SelectCode - 1 < EUDC_SCode)
				break;
#ifdef BUILD_ON_WINNT
            TmpCode = SelectCode - 1;
            TmpCode = CorrectEUDCCodeKey( TmpCode, 1, FALSE);
            sPos = GetBarPosition( EUDC_SView);
            ePos = GetBarPosition( TmpCode);
            if( ePos < sPos){
#else
			if( SelectCode - 1 < EUDC_SView){
#endif // BUILD_ON_WINNT
                this->SendMessage( WM_VSCROLL, SB_LINEUP, 0);
            }
			SearchSelectPosition();
			SelectCode--;
			SelectCode = CorrectEUDCCodeKey( SelectCode, 1, FALSE);
			SearchSelectPosition();
			this->UpdateWindow();
			break;

		case VK_RIGHT:
#ifdef BUILD_ON_WINNT
            // Move to above...
#else
			WORD	TmpCode;
#endif // BUILD_ON_WINNT

			if( SelectCode + 1 > EUDC_ECode)
				break;
			TmpCode = SelectCode + 1;
			TmpCode = CorrectEUDCCodeKey( TmpCode, 1, TRUE);
			sPos = GetBarPosition( EUDC_SView);
			ePos = GetBarPosition( TmpCode);
			if( ePos - sPos >= NUM_LINE){
				this->SendMessage( WM_VSCROLL, SB_LINEDOWN, 0);
			}
			SearchSelectPosition();
			SelectCode++;
			SelectCode = CorrectEUDCCodeKey( SelectCode, 1, TRUE);
			SearchSelectPosition();
			this->UpdateWindow();
			break;
		}
	}else 	CEdit::OnKeyDown(nChar, nRepCnt, nFlags);
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_SETFOCUS"		*/
/*					*/
/****************************************/
void
CEudcList::OnSetFocus(
CWnd* 	pOldWnd)
{
	CEdit::OnSetFocus(pOldWnd);
	FocusFlag = TRUE;
	SearchSelectPosition();
	this->UpdateWindow();
	::HideCaret( NULL);
//	DestroyCaret();
}

/****************************************/
/*					*/
/*	Search select posistion		*/
/*					*/
/****************************************/
void
CEudcList::SearchSelectPosition()
{

	CRect	test;
	int	sViewPt, sCodePt;
unsigned int	i, j;


	sViewPt = GetBarPosition( EUDC_SView);
	sCodePt = GetBarPosition( SelectCode);

#ifdef BUILD_ON_WINNT
    // the new view does not contain previsouly selected char,
    // we don't need to redraw the concave.
    if (sCodePt < sViewPt || sCodePt > sViewPt+NUM_LINE)
        return;
#endif



	i = (unsigned int)(sCodePt - sViewPt);
	j = (unsigned int)(SelectCode & 0x000f);
	test.SetRect( rcEditChar[i][j].left - 2,
			rcEditChar[i][j].top - 2,
			rcEditChar[i][j].right + 2,
			rcEditChar[i][j].bottom + 2);
	this->InvalidateRect( &test, FALSE);

}

/****************************************/
/*					*/
/*	Correct it if code is illegal 	*/
/*					*/
/****************************************/
#ifdef BUILD_ON_WINNT
WORD
CEudcList::CorrectEUDCCodeKey(
WORD 	Code,
int 	MovePt,
BOOL 	UporDown)
{
COUNTRYINFO	Info;
	WORD	wCode;
	BYTE 	LByte, HByte, Tmp0;
	int	TralPos = 0;

	LByte = LOBYTE( Code);
	HByte = HIBYTE( Code);
	Info = CountryInfo;
	for( int i = 0; i < Info.nTralByte; i++){
		if( LByte >= Info.sTralByte[i] && LByte <= Info.eTralByte[i]){
		    	goto RET;
		}else if( LByte < Info.sTralByte[i]){
        /* decide which range of starting trailbyte we are less than */
			TralPos = i;
			break;
        }else	TralPos = i+1;
	}
	if( UporDown){  //code increasing
		if( TralPos == Info.nTralByte){ //greater than last eTrailByte
		    HByte += 0x1; //same as less than next sTraiByte
            TralPos=0;
        }

		if( MovePt < NUM_CHAR){  //
			LByte = Info.sTralByte[TralPos];
		}else{
            Tmp0 = LByte & 0x0f;
            LByte = Info.sTralByte[TralPos] & 0xf0;
            LByte |= Tmp0;
            if (LByte < Info.sTralByte[TralPos])
                LByte += NUM_CHAR;

		}
	}else{
		if( TralPos == 0){ //greater than last eTrailByte
            TralPos = Info.nTralByte;
		    HByte -= 0x1;
        }

		if( MovePt < NUM_CHAR){
			LByte = Info.eTralByte[TralPos-1];
	    }else{
            Tmp0 = LByte & 0x0f;
            LByte = Info.eTralByte[TralPos-1] & 0xf0;
            LByte |= Tmp0;
            if (LByte > Info.eTralByte[TralPos-1])
                LByte -= NUM_CHAR;
		}
	}
RET:
	wCode = MAKEWORD( LByte, HByte);
	return wCode;
}
#else
WORD
CEudcList::CorrectEUDCCodeKey(
WORD 	Code,
int 	MovePt,
BOOL 	UporDown)
{
COUNTRYINFO	Info;
	WORD	wCode;
	BYTE 	LByte, HByte;
	int	TralPos = 0;

	LByte = LOBYTE( Code);
	HByte = HIBYTE( Code);
	Info = CountryInfo;
	for( int i = 0; i < Info.nTralByte; i++){
		if( LByte >= Info.sTralByte[i] && LByte <= Info.eTralByte[i]){
		    	goto RET;
		}else if( LByte < Info.sTralByte[i]){
			TralPos = i;
			break;
		}else	TralPos = i+1;
	}
	if( UporDown)
		if( TralPos == Info.nTralByte){
			if( MovePt < NUM_CHAR){
				LByte = Info.sTralByte[0];
				HByte += 0x1;
			}else{
				LByte = Info.eTralByte[Info.nTralByte - 1];
			}
		}else if( MovePt < NUM_CHAR){
			LByte = Info.sTralByte[TralPos];
		}else{
			if( TralPos){
				BYTE	Tmp1;
				BYTE	Tmp2;

				Tmp1 = Info.eTralByte[TralPos-1] & 0xf0;
				Tmp2 = LByte & 0xf0;
				if( Tmp1 == Tmp2){
					LByte = Info.eTralByte[TralPos-1];
				}else{
					Tmp1 = LByte & 0x0f;
					LByte = Info.sTralByte[TralPos]	& 0xf0;
					LByte |= Tmp1;
				}
			}else{
				LByte += (Info.sTralByte[0] & 0xf0);
			}
		}
	else{
		if( !TralPos){
			if( MovePt < NUM_CHAR){
				LByte = Info.eTralByte[Info.nTralByte - 1];
				HByte -= 0x1;
			}else{
				BYTE	Tmp;

				Tmp = LByte & 0x0f;
				LByte = Info.eTralByte[Info.nTralByte - 1]&0xf0;
				LByte |= Tmp;
				HByte -= 0x1;
				if( LByte > Info.eTralByte[Info.nTralByte-1]){
					LByte = Info.eTralByte[Info.nTralByte-1];
				}
			}
		}else{
			BYTE	Tmp;

			Tmp = LByte & 0x0f;
			LByte = Info.eTralByte[TralPos-1] & 0xf0;
			LByte |= Tmp;
			if( LByte > Info.eTralByte[TralPos-1])
				LByte = Info.eTralByte[TralPos-1];

		}
	}
RET:
	wCode = MAKEWORD( LByte, HByte);
	return wCode;
}
#endif // BUILD_ON_WINNT

/****************************************/
/*					*/
/*	Whether correct or not?		*/
/*					*/
/****************************************/
BOOL
CEudcList::IsCorrectChar(
UINT 	i,
UINT 	j)
{
	int	sViewPt;
	WORD	wCode;
	BYTE	sOffset;
	BOOL	flg;

	flg = FALSE;
	BarRange = GetBarPosition((WORD)EUDC_EView);
	sViewPt = GetBarPosition( EUDC_SView);
	wCode = GetCodeScrPos( sViewPt + i);
	wCode |= j;

	sOffset = LOBYTE( wCode);
	for( int k = 0; k < CountryInfo.nTralByte; k++){
		if( sOffset >= CountryInfo.sTralByte[k] &&
		    sOffset <= CountryInfo.eTralByte[k]){
		    	flg = TRUE;
		}
	}
	return flg;
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_KILLFOCUS"		*/
/*					*/
/****************************************/
void
CEudcList::OnKillFocus(
CWnd* 	pNewWnd)
{
	FocusFlag = FALSE;
	SearchSelectPosition();
	this->UpdateWindow();
	CEdit::OnKillFocus( pNewWnd);
	::HideCaret( NULL);
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_RBUTTONUP"		*/
/*					*/
/****************************************/
void
CEudcList::OnRButtonUp(
UINT 	nFlags,
CPoint 	point)
{
	GetParent()->SendMessage( WM_CONTEXTMENU, (WPARAM)this->GetSafeHwnd(), 0);
}

BEGIN_MESSAGE_MAP( CViewEdit, CEdit)
	//{{AFX_MSG_MAP( CViewEdit)
	ON_WM_PAINT()
	ON_WM_SETCURSOR()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_RBUTTONUP()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/****************************************/
/*					*/
/*	Default Constructor		*/
/*					*/
/****************************************/
CViewEdit::CViewEdit()
{
}

/****************************************/
/*					*/
/*	Destructor			*/
/*					*/
/****************************************/
CViewEdit::~CViewEdit()
{
//fix for 261529  
  EUDCFont.DeleteObject();
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_PAINT"		*/
/*					*/
/****************************************/
void
CViewEdit::OnPaint()
{
	LOGFONT	LogFont;
	CFont	ViewFont, *OldFont;
	CSize	cSize;
	CRect	ViewRect;
	int	xOffset, yOffset;
	CPaintDC	dc( this);


	GetClientRect( &ViewRect);
	DrawConcave( &dc, ViewRect);

    if(bHasGlyph == FALSE) return;

	memset( &LogFont, 0, sizeof( LogFont));
//fix for 261529    
  EUDCFont.GetLogFont(&LogFont);

	if( ViewRect.Width() >= ViewRect.Height())
		LogFont.lfHeight = ViewRect.Height() - 10;
	else	LogFont.lfHeight = ViewRect.Width()  - 10;

  if( !ViewFont.CreateFontIndirect( &LogFont))
		return;
	OldFont = dc.SelectObject( &ViewFont);

#ifdef BUILD_ON_WINNT
    if (CountryInfo.bUnicodeMode)
	    GetTextExtentPoint32W(dc.GetSafeHdc(), (LPCWSTR)ViewCode, 1, &cSize);
    else
#endif //BUILD_ON_WINNT
	    GetTextExtentPoint32A(dc.GetSafeHdc(), (LPCSTR)ViewCode, 2, &cSize);

	if( ViewRect.Width() > cSize.cx){
		xOffset = ViewRect.Width() - cSize.cx;
		xOffset /= 2;
	}else	xOffset = 0;

	if( ViewRect.Height() > cSize.cy){
		yOffset = ViewRect.Height() - cSize.cy;
		yOffset /= 2;
	}else	yOffset = 0;

	dc.SetBkColor( COLOR_FACE);
	dc.SetTextColor(GetSysColor(COLOR_WINDOWTEXT)); // COLOR_BLACK);

    if (CountryInfo.bUnicodeMode)
	{
#ifdef UNICODE
	    ExtTextOutW(dc.GetSafeHdc(), xOffset, yOffset, ETO_OPAQUE,
		    &ViewRect, (LPCWSTR)ViewCode, 1, NULL);
#else
		CHAR ViewTmp[2];
		WideCharToMultiByte(CP_ACP, 0, (LPWSTR) ViewCode, 1, ViewTmp, 2, NULL, NULL);
		ExtTextOutA(dc.GetSafeHdc(), xOffset, yOffset, ETO_OPAQUE,
						&ViewRect, (LPCSTR)ViewTmp, 2, NULL);
#endif

	}
    else
	{
		ExtTextOutA(dc.GetSafeHdc(), xOffset, yOffset, ETO_OPAQUE,
			&ViewRect, (LPCSTR)ViewCode, 2, NULL);
	}
	dc.SelectObject( OldFont);
	ViewFont.DeleteObject();
}

/****************************************/
/*					*/
/*	Draw Concave Rect		*/
/*					*/
/****************************************/
void
CViewEdit::DrawConcave(
CDC 	*dc,
CRect 	rect)
{
	CBrush	ConBrush, *OldBrush;
	CRect	Rt;

	Rt.SetRect( rect.left-1, rect.top-1, rect.right, rect.bottom);

 	ConBrush.CreateSolidBrush(COLOR_FACE);
	OldBrush = dc->SelectObject( &ConBrush);
	dc->PatBlt( Rt.left, Rt.top, Rt.right, Rt.bottom, PATCOPY);
	dc->SelectObject( OldBrush);
	ConBrush.DeleteObject();

	ConBrush.CreateSolidBrush( COLOR_HLIGHT);
	OldBrush = dc->SelectObject( &ConBrush);
	dc->PatBlt( Rt.left, Rt.top, Rt.Width(), 1, PATCOPY);
	dc->PatBlt( Rt.left, Rt.top, 1, Rt.Height(), PATCOPY);
	dc->SelectObject( OldBrush);
	ConBrush.DeleteObject();

	ConBrush.CreateSolidBrush( COLOR_SHADOW);
	OldBrush = dc->SelectObject( &ConBrush);
	dc->PatBlt( Rt.left, Rt.bottom, Rt.Width(), 1, PATCOPY);
	dc->PatBlt( Rt.right, Rt.top, 1, Rt.Height()+1, PATCOPY);
	dc->SelectObject( OldBrush);
	ConBrush.DeleteObject();
}

BEGIN_MESSAGE_MAP( CCustomListFrame, CStatic)
	//{{AFX_MSG_MAP( CCustomListFrame)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/****************************************/
/*					*/
/*	Default Constructor		*/
/*					*/
/****************************************/
CCustomListFrame::CCustomListFrame()
{
}

/****************************************/
/*					*/
/*	Destructor			*/
/*					*/
/****************************************/
CCustomListFrame::~CCustomListFrame()
{
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_PAINT"		*/
/*					*/
/****************************************/
void
CCustomListFrame::OnPaint()
{
	CRect	FrameRect;
	CPaintDC	dc( this);

	this->GetClientRect( &FrameRect);
	this->DrawConcave( &dc, FrameRect);
}

/****************************************/
/*					*/
/*	Draw Concave Rect		*/
/*					*/
/****************************************/
void
CCustomListFrame::DrawConcave(
CDC 	*dc,
CRect 	rect)
{
	CBrush	ConBrush, *OldBrush;
	CRect	Rt;

	Rt.SetRect( rect.left-1, rect.top-1, rect.right, rect.bottom);

	ConBrush.CreateSolidBrush( COLOR_HLIGHT);
	OldBrush = dc->SelectObject( &ConBrush);
	dc->PatBlt( Rt.left, Rt.top, Rt.Width(), 1, PATCOPY);
	dc->PatBlt( Rt.left, Rt.top, 1, Rt.Height(), PATCOPY);
	dc->SelectObject( OldBrush);
	ConBrush.DeleteObject();

	ConBrush.CreateSolidBrush( COLOR_SHADOW);
	OldBrush = dc->SelectObject( &ConBrush);
	dc->PatBlt( Rt.left, Rt.bottom, Rt.Width(), 1, PATCOPY);
	dc->PatBlt( Rt.right, Rt.top, 1, Rt.Height()+1, PATCOPY);
	dc->SelectObject( OldBrush);
	ConBrush.DeleteObject();
}

BEGIN_MESSAGE_MAP( CCustomInfoFrame, CStatic)
	//{{AFX_MSG_MAP( CCustomInfoFrame)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/****************************************/
/*					*/
/*	Default Constructor		*/
/*					*/
/****************************************/
CCustomInfoFrame::CCustomInfoFrame()
{
}

/****************************************/
/*					*/
/*	Destructor			*/
/*					*/
/****************************************/
CCustomInfoFrame::~CCustomInfoFrame()
{
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_PAINT"		*/
/*					*/
/****************************************/
void
CCustomInfoFrame::OnPaint()
{
	CRect	FrameRect;
	CPaintDC	dc( this);

	this->GetClientRect( &FrameRect);
	this->DrawConcave( &dc, FrameRect);
}

/****************************************/
/*					*/
/*	Draw Concave Rect		*/
/*					*/
/****************************************/
void
CCustomInfoFrame::DrawConcave(
CDC 	*dc,
CRect 	rect)
{
	CBrush	ConBrush, *OldBrush;
	CRect	Rt;

	Rt.SetRect( rect.left-1, rect.top-1, rect.right, rect.bottom);

	ConBrush.CreateSolidBrush( COLOR_SHADOW);
	OldBrush = dc->SelectObject( &ConBrush);
	dc->PatBlt( Rt.left, Rt.top, Rt.Width(), 1, PATCOPY);
	dc->PatBlt( Rt.left, Rt.top, 1, Rt.Height(), PATCOPY);
	dc->SelectObject( OldBrush);
	ConBrush.DeleteObject();

	ConBrush.CreateSolidBrush( COLOR_HLIGHT);
	OldBrush = dc->SelectObject( &ConBrush);
	dc->PatBlt( Rt.left, Rt.bottom, Rt.Width(), 1, PATCOPY);
	dc->PatBlt( Rt.right, Rt.top, 1, Rt.Height()+1, PATCOPY);
	dc->SelectObject( OldBrush);
	ConBrush.DeleteObject();
}

BOOL CViewEdit::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	::SetCursor( AfxGetApp()->LoadStandardCursor(IDC_ARROW));
	return TRUE;
}

void CViewEdit::OnSetFocus(CWnd* pOldWnd)
{
	CEdit::OnSetFocus(pOldWnd);
	::HideCaret( NULL);
}

void CViewEdit::OnKillFocus(CWnd* pNewWnd)
{
	CEdit::OnKillFocus(pNewWnd);
	::HideCaret( NULL);
}

void CViewEdit::OnLButtonDown(UINT nFlags, CPoint point)
{
}

void CViewEdit::OnLButtonDblClk(UINT nFlags, CPoint point)
{
}

void CViewEdit::OnRButtonUp(UINT nFlags, CPoint point)
{
	GetParent()->SendMessage( WM_CONTEXTMENU, (WPARAM)this->GetSafeHwnd(), 0);
}

#ifdef BUILD_ON_WINNT

BEGIN_MESSAGE_MAP( CColumnHeading, CWnd)
    //{{AFX_MSG_MAP( CColumnHeading)
    ON_WM_PAINT()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
/****************************************/
/*					*/
/*	Default Constructor		*/
/*					*/
/****************************************/
CColumnHeading::CColumnHeading()
{
}

/****************************************/
/*					*/
/*	Destructor			*/
/*					*/
/****************************************/
CColumnHeading::~CColumnHeading()
{
    SysFFont.DeleteObject();
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_PAINT"		*/
/*					*/
/****************************************/
void
CColumnHeading::OnPaint()
{
    // column heading support
	CPaintDC	dc( this);
    TCHAR ColumnHead[2];
    CSize cSize;
    int	j,xOffset;

    dc.SetMapMode( MM_TEXT);
    dc.SelectObject( &SysFFont);
    dc.SetBkColor( COLOR_FACE);
    dc.SetTextColor(GetSysColor(COLOR_WINDOWTEXT)); // COLOR_BLACK);
    for( j = 0; j < NUM_CHAR; j++){
        wsprintf(ColumnHead, TEXT("%X"), j);
	    GetTextExtentPoint32(dc.GetSafeHdc(),
                ColumnHead, 1, &cSize);
        if( rcColumnHead[j].Width() > cSize.cx){
		    xOffset = rcColumnHead[j].Width() - cSize.cx;
	        xOffset /= 2;
	    }else	
            xOffset= 0;

        dc.ExtTextOut( rcColumnHead[j].left + xOffset,
             rcColumnHead[j].top,
             ETO_OPAQUE, &rcColumnHead[j],
             ColumnHead, 1, NULL);
    }
}


#endif //BUILD_ON_WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\extfunc.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//

/*****
 * FITCONIC.C
 *****/

int  FitConic(int  inLst,int  outLst,int  level,int  ufp);

/*****
 *	BMPOPE.C
 *****/

void  BMPInit(void);
int  BMPDefine(unsigned char  *buf,int  xWid,int  yWid);
int  BMPFreDef(int  bmpno);
int  BMPMkCont(int  BMPNo,int  wkBMP,int  refBMP,int  lsthdl);
int  rdot(int  BMP,int  x,int  y);
void  wdot(int  BMP,int  x,int  y,int  onoff);
int  ReverseRight(int  BMPNo,int  x,int  y);
int  BMPReverse(int  bmpNo);
int  BMPClear(int  bmpNo);

/*****
 *	W31JEUDC.C
 *****/
int  OpenW31JEUDC(TCHAR  *path);
void  CloseW31JEUDC(void);
int  GetW31JEUDCFont(unsigned short  code, LPBYTE buf,int  bufsiz,int  *xsiz,int  *ysiz, BOOL bUnicode);
int  PutW31JEUDCFont(unsigned short  code, LPBYTE buf,int  xsiz,int  ysiz, BOOL bUniocde);
int  IsWin95EUDCBmp(LPTSTR szBmpPath);
BOOL GetGlyph(TCHAR *path, BYTE* pGlyph);

/*****
 *	SMOOTH.C
 *****/
struct SMOOTHPRM	{
	int	SmoothLevel;
	int	UseConic;
	};

#define		SMOOTHLEVELMAX	8


int  SmoothVector(int  lstHdl,int  tmpLst,int  xinMesh,int yinMesh, int  outMesh,struct  SMOOTHPRM *prm,int  fp);
int  searchanchor(int  sn,struct  VDATA *sp,struct  VDATA * *ep,int  lim);
int  RemoveFp(int  lstHdl,int  outMesh,int  uFp);
int  toTTFFrame(int  lstH,struct  BBX *bbx);
int  SmoothLight(int  ioLst,int  tmpLst,int  width,int height, int  oWidth,int  ufpVal);
int  ConvMesh(int  lstH,int  inMesh,int  outMesh);

/*****
 *	DATAIF.C
 *****/
int  OInit(void);
int  OTerm(void);
#ifdef BUILD_ON_WINNT
int  OExistUserFont( TCHAR*path);
#endif // BUILD_ON_WINNT
int  OExistTTF(  TCHAR *path);
int  OCreateTTF( HDC hDC, TCHAR *path, int fontType);
int  OMakeOutline( UCHAR  *buf,int  siz,int  level);
int  OOutTTF(HDC hDC, TCHAR  *path,unsigned short  code, BOOL bUnicode);
/*****
 *	TTFFILE.C
 *****/
void  smtoi(short  *sval);
void  lmtoi(long  *lval);
void  sitom(short  *sval);
void  litom(long  *lval);
int  TTFReadHdr(HANDLE  fHdl,struct  TTFHeader *hdr);
int  TTFWriteHdr(HANDLE  fHdl,struct  TTFHeader *hdr);
int  TTFReadDirEntry(HANDLE fHdl,struct  TableEntry *entry,int  eCnt);
int  TTFWriteDirEntry(HANDLE  fHdl,struct  TableEntry *entry,int  eCnt);
int  TTFGetTableEntry(HANDLE  fH,struct  TableEntry *entry,char  *tag);
int  TTFReadTable(HANDLE  fH,struct  TableEntry *entry,void  *buf,int  bufsiz);
int  TTFReadFixedTable(HANDLE  fH,char  *buf,int  bufsiz,char  *tag);
int  TTFReadVarTable(HANDLE  fH,char  * *buf,unsigned int  *bufsiz,char  *tag);
int  TTFWriteTable(HANDLE fH,struct  TableEntry *entry,void  *buf,int  bufsiz);
int  TTFAppendTable(HANDLE  fH,struct  TableEntry *entry,void  *buf,int  siz);
int  TTFReadOrgFixedTable(HDC  hDC,char  *buf,int  bufsiz,char  *tag);
int  TTFReadOrgVarTable(HDC  hDC,char  * *buf,unsigned int  *bufsiz,char  *tag);
int  TTFCreate(HDC  hDC,TCHAR  *newf,struct  BBX *bbx,int  lstHdl,int  fontType);
int  TTFGetBBX(HDC  hDC,struct  BBX *bbx,short  *uPEm);
int  TTFTmpPath(TCHAR  *path,TCHAR  *tmpPath);
int  TTFAddEUDCChar(TCHAR *path,unsigned short  code,struct  BBX *bbx,int  lstH);
int  TTFOpen(TCHAR  *path);
int  TTFClose(void);
int  TTFGetEUDCBBX(TCHAR  *path,struct  BBX *bbx,short  *upem);
int  TTFAppend(unsigned short  code,struct  BBX *bbx,int  lsthdl);
int  TTFImpCopy(TCHAR  *sPath,TCHAR  *dPath);
int  TTFImpGlyphCopy(HANDLE  sFh,int  glyphID);
int  TTFImpGlyphWrite(int  glyphID, char *buf, int siz);
int  TTFImpTerm( HANDLE orgFh, int glyphID);
int  TTFLastError( void);
/*
 *	Create.c
 */
int creatW31JEUDC( TCHAR *path);

/*
 *	makepoly.c
 */

int	MkPoly(	int inlst, int outLst);

/*
 *	W31JBMP.C
 */
int  isW31JEUDCBMP( TCHAR *path);
int  OpenW31JBMP(TCHAR  *path,int  omd);
int  CloseW31JBMP(void);
int  GetW31JBMPnRecs( int *nRec, int *nGlyph, int *xsiz, int *ysiz);
int  GetW31JBMP(unsigned short  code,char  *buf,int  bufsiz,int  *xsiz,int  *ysiz);
int  GetW31JBMPRec(int  rec,LPBYTE buf,int  bufsiz,int  *xsiz,int  *ysiz,unsigned short  *code);
int  PutW31JBMPRec(int  rec,LPBYTE buf,int  xsiz,int  ysiz);
int  W31JrecTbl(int  * *recTbl, BOOL bIsWin95EUDC);
int  GetW31JBMPMeshSize( int *xsiz, int *ysiz);

/*
 *	code.c
 */

void  makeUniCodeTbl(void);
unsigned short  sjisToUniEUDC(unsigned short  code);
unsigned short  getMaxUniCode(void);

/*
 *	IMPORT.C
 */

int  Import(TCHAR  *eudcPath,TCHAR *bmpPath,TCHAR *ttfPath,int  oWidth,int  oHeight, int level, BOOL bIsWin95EUDC);

/*
 *	eten.c
 */
int  openETENBMP(TCHAR  *path,int  md);
int  closeETENBMP(void);
int  createETENBMP(TCHAR *path,int  wid,int  hei);
int  getETENBMPInf(int  *nRec, int *nGlyph,int  *wid,int  *hei, char *sign, 
WORD *bID);
int  readETENBMPRec(int  rec, LPBYTE buf,int  bufsiz,unsigned short  *code);
int  appendETENBMP(LPBYTE buf,unsigned short  code);
int  isETENBMP(TCHAR *path);
int  ETENrecTbl(int  * *recTbl);

#ifdef BUILD_ON_WINNT
/*
 * EUDCRANG.CPP  
 */
void    CorrectTrailByteRange(int nIndex);
void	SetTrailByteRange(UINT LocalCP);
#endif // BUILD_ON_WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\eudcrang.cpp ===
/**************************************************/
/*					                              */
/*					                              */
/*	Setting code range		                      */
/*					                              */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include	"stdafx.h"
#include	"eudcedit.h"
#include	"registry.h"
#ifdef BUILD_ON_WINNT
#include    "extfunc.h"
#endif // BUILD_ON_WINNT
#include    "util.h"

#define		S_UNICODE	0xE000
#define		E_UNICODE	0xE0ff

BOOL	SetCountryInfo( UINT LocalCP);
int		SetLeadByteRange(TCHAR * CodeRange,int nCode);
void	SetTrailByteRange();
#ifdef BUILD_ON_WINNT
void    CorrectTrailByteRange(int nIndex);
#endif // BUILD_ON_WINNT
/****************************************/
/*					*/
/*	Set Country Infomation		*/
/*					*/
/****************************************/
BOOL 
SetCountryInfo( 
UINT 	LocalCP)
{
	TCHAR	CodePage[10], szUnicode[] = TEXT("Unicode");
	TCHAR	Coderange[50];
	int nCode = 0;

	SetTrailByteRange(LocalCP);
	
	if (!CountryInfo.bOnlyUnicode){

/* Read EUDC Coderange from Registry */
#ifndef NEWREG
		/* Old Version */
		TCHAR 	CodeTmp[10];
		wsprintf( CodeTmp, TEXT("%d"), LocalCP);
		if( lstrlen( CodeTmp) == 3){
			lstrcpy(CodePage, TEXT("CP00"));
		}else{
			lstrcpy(CodePage, TEXT("CP0"));
		}
		lstrcat(CodePage, CodeTmp);
#else
		/* New Version */
		wsprintf( CodePage, TEXT("%d"), LocalCP);
#endif
		if( !InqCodeRange(CodePage, (BYTE *)Coderange, 50))
		return FALSE;
		
		if ((nCode = SetLeadByteRange ( Coderange, 0)) == -1)
			return FALSE;
	} //!CountryInfo.bOnlyUnicode	

#ifdef UNICODE
	// unicode range will always be the last one.
	lstrcpy(CodePage, szUnicode);
	if( !InqCodeRange(CodePage, (BYTE *)Coderange, 50))
		return FALSE;

	if (SetLeadByteRange (Coderange, nCode) == -1)
		return FALSE;
#else
	//
	//	Ansi version, we have to set end Unicode 
	//	code point to the last ansi range.
	//
	WCHAR RangeTmp[2];
	CHAR AnsiRange[2];
	CountryInfo.nRange = nCode+1;
	CountryInfo.nLeadByte = nCode+1;
	CountryInfo.sRange[nCode] = S_UNICODE;
	
	AnsiRange[0] = HIBYTE(CountryInfo.eRange[nCode-1]);
	AnsiRange[1] = LOBYTE(CountryInfo.eRange[nCode-1]);
	MultiByteToWideChar(CP_ACP, 0, AnsiRange,2,RangeTmp, 1);
	CountryInfo.eRange[nCode] = RangeTmp[0];
	CountryInfo.sLeadByte[nCode] = HIBYTE(CountryInfo.sRange[nCode]);
	CountryInfo.eLeadByte[nCode] = HIBYTE(CountryInfo.eRange[nCode]);
#endif

	
	return TRUE;

}

void 
SetTrailByteRange(
UINT LocalCP)
{
	WORD	UCode[MAX_CODE];
	BYTE	SCode[MAX_CODE], sTral, cTral;
	int	nTral = 0;
	
	if (!CountryInfo.bUnicodeMode){
		// calculate trailbyte range.
		UCode[0] = S_UNICODE;
		UCode[1] = '\0';
		WideCharToMultiByte( LocalCP, 0L, (const unsigned short *)UCode,
			-1, (char *)SCode, sizeof(SCode), NULL, NULL);
		sTral = cTral = SCode[1];
		CountryInfo.sTralByte[nTral] = sTral;

		for( WORD Cnt = S_UNICODE + 1; Cnt <= E_UNICODE; Cnt++){
			UCode[0] = Cnt;
			UCode[1] = '\0';

			WideCharToMultiByte( LocalCP, 0L, (const unsigned short *)UCode,
		 		-1, (char *)SCode, sizeof(SCode), NULL, NULL);

			if( cTral + 1 != SCode[1]){
				CountryInfo.eTralByte[nTral] = cTral;
				nTral++;
				if( sTral != SCode[1]){
					CountryInfo.sTralByte[nTral] = SCode[1];
				}
			}
			cTral = SCode[1];
			if( sTral == cTral)
				break;
		}
		CountryInfo.nTralByte = nTral;

		/* For Extend Wansung (test) */
		if( CountryInfo.LangID == EUDC_KRW){
			CountryInfo.nTralByte = 3;
			CountryInfo.sTralByte[0] = 0x41;
			CountryInfo.eTralByte[0] = 0x5a;
			CountryInfo.sTralByte[1] = 0x61;
			CountryInfo.eTralByte[1] = 0x7a;
			CountryInfo.sTralByte[2] = 0x81;
			CountryInfo.eTralByte[2] = 0xfe;
		}

		/* For CHS  we have to remember the original trail byte range and calculate
		 	 trail byte range dynamically 
		*/
		if( CountryInfo.LangID == EUDC_CHS){
			CountryInfo.nOrigTralByte = 2;
			CountryInfo.sOrigTralByte[0] = 0x40;
			CountryInfo.eOrigTralByte[0] = 0x7e;
			CountryInfo.sOrigTralByte[1] = 0x80;
			CountryInfo.eOrigTralByte[1] = 0xfe;

		//To start with, calculate trailbyte range for the default EUDC selection range.
			CorrectTrailByteRange(0); 

		}else{
			CountryInfo.nOrigTralByte = 0;
		}

	}else { //!CountryInfo.bUnicodeMode
		CountryInfo.nTralByte = 1;
		CountryInfo.sTralByte[0] = 0x00;
		CountryInfo.eTralByte[0] = 0xff;
	} //!CountryInfo.bUnicodeMode
}


int 
SetLeadByteRange( 
TCHAR * Coderange,
int nCode)
{
	// Calculate LeadByte Range 
	TCHAR	*pStr1, *pStr2;
	WORD	wLow, wHigh;
	
	pStr1 = pStr2 = Coderange;
	while(1){
		if(( pStr2 = Mytcschr( pStr1, '-')) != NULL){
			*pStr2 = '\0';
			wLow = (WORD)Mytcstol( pStr1, (TCHAR **)0, 16);
			CountryInfo.sRange[nCode] = wLow;
			CountryInfo.sLeadByte[nCode] = HIBYTE( wLow);	
			pStr2++;
			pStr1 = pStr2;
		}else	return -1;

		if(( pStr2 = Mytcschr( pStr1, ',')) != NULL){
			*pStr2 = '\0';
			wHigh = (WORD)Mytcstol( pStr1, (TCHAR **)0, 16);
			CountryInfo.eRange[nCode] = (unsigned short)wHigh;
			CountryInfo.eLeadByte[nCode] = HIBYTE( wHigh);	
			pStr2++;
			pStr1 = pStr2;
		}else{
			wHigh = (WORD)Mytcstol( pStr1, (TCHAR **)0, 16);
			CountryInfo.eRange[nCode] = (unsigned short)wHigh;
			CountryInfo.eLeadByte[nCode] = HIBYTE( wHigh);	
			break;
		}
		nCode++;
	}

	CountryInfo.nLeadByte = ++nCode;
	CountryInfo.nRange = nCode;
	return nCode;
}

#ifdef BUILD_ON_WINNT
/**************************************************************************\
 * CorrectTralByteRange                                                   * 
 * Correct trailbyte range of EUDC range with each of original trail byte *
 * ranges.  It is used by countries where EUDC trail byte range changes   *
 * with selection of different EUDC range, for example CHS.               *
\**************************************************************************/
void
CorrectTrailByteRange(
int nIndex)
{
    COUNTRYINFO *Info;
    int i, Unique=0;
    
	if (CountryInfo.bUnicodeMode)
		return;

    Info=&CountryInfo;
    for (i=0; i< Info->nOrigTralByte; i++){
        //take the smaller of the two ranges.
        Info->sTralByte[Unique] = max(LOBYTE(Info->sRange[nIndex]),
                                      Info->sOrigTralByte[i]);
        Info->eTralByte[Unique] = min(LOBYTE(Info->eRange[nIndex]),
                                      Info->eOrigTralByte[i]);

        //we keep valid ranges and overwrite invalid one with next loop 
        if (Info->eTralByte[Unique] >= Info->sTralByte[Unique])
            Unique +=1;
    }
    Info->nTralByte=Unique;
}
#endif // BUILD_ON_WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\eudcedit.h ===
/**************************************************/
/*						                          */
/*						                          */
/*	EUDC EDITOR (MAIN HEADER)		              */
/*						                          */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include 	"resource.h"
#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif
#include <htmlhelp.h>

/* EUDC editor defined windows message */
#define		WM_IMPORTGAGE	(WM_USER)	// start import
#define		WM_IMPORTSTOP	(WM_USER + 1)	// stop import
#define		WM_DUPLICATE	(WM_USER + 2)	// duplicate bitmap
#define		WM_VIEWUPDATE	(WM_USER + 3)	// view update

/* Country ID */
#define		EUDC_JPN	0x411		// Japanese
#define		EUDC_CHT	0x404		// Chinese (Taipei)
#define		EUDC_CHS	0x804		// Chinese (General)
#define		EUDC_HKG	0xc04		// Chinese (Hong Kong)
#define		EUDC_SIN	0x1004		// Chinese (Singapore)
#define		EUDC_KRW	0x412		// Korea   (Wansung)
#define   EUDC_HEBREW 0x40d
#define   EUDC_HINDI  0x439
#define   EUDC_TAMIL  0x449

/*
#ifdef BUILD_ON_WINNT
#define		EUDC_UNICODE	0xFFFF		// Unicode
#endif
*/

/* Smoothing level */
#define		SMOOTHLVL	1		// show outline
						// regist truetype
/* Code string size */
#define		MAX_CODE	5		// size of code string 

/* Tool */
#define		NOTSELECT	0		// "Not Selected"
#define		PEN		1		// "Pen" 
#define		SLOPE		2		// "Straight Line"
#define		RECTBAND	3		// "Hollow Ractangle"
#define		RECTFILL	4		// "Filled Rectangle"
#define		CIRCLE		5		// "Hollow Circle"
#define		CIRCLEFILL	6		// "Filled Circle"
#define		RECTCLIP	7		// "Rectangular Selection"
#define		BRUSH		8		// "Brush"
#define		FREEFORM	9		// "Freeform Selection"
#define		ERASER		10		// "Eraser"

/* Cursor */
#define		VERTICAL	0		// vertical arrow for resize 
#define		RIGHTSLOPE	1		// right arrow for resize
#define		LEFTSLOPE	2		// left arrow for resize
#define		HORIZONTAL	3		// horizontal arrow for resize
#define		ALLDIRECT	4		// all direct arrow for resize
#define		NUMRESIZE	5		// the number of resize cursor
#define		NUMTOOL		11		// the number of tool cursor

/* Color */
#define		COLOR_WHITE	RGB(255,255,255) // white
#define		COLOR_BLACK	RGB(  0,  0,  0) // black
#define		COLOR_LGRAY	RGB(192,192,192) // light Gray
#define		COLOR_DGRAY	RGB(128,128,128) // dark Gray
#define		COLOR_YELLO	RGB(255,255,  0) // yellow
#define		COLOR_BLUE	RGB(  0,  0,255) // blue
#define		COLOR_RED	RGB(255,  0,  0) // red

/* Bitmap size */
#define		MAX_BITMAPSIZE	256		// maximun of bitmap size
#define		MIN_BITMAPSIZE	16		// minimun of bitmap size
#define		DEF_BITMAPSIZE	64		// default of bitmap size

/* Selected font, file and code structure */
typedef struct _tagSELECTEUDC{
	TCHAR	m_Font[LF_FACESIZE];		// selected EUDC typeFace
	TCHAR	m_File[MAX_PATH];		// selected EUDC fileName
	TCHAR	m_FileTitle[MAX_PATH];		// selected EUDC fileTitle
	TCHAR	m_Code[MAX_CODE];		// selected EUDC code
	BOOL	m_FontTypeFlg;			// flag whether TTF or not
}SELECTEUDC;

/* EUDC coderange and languageID structure */
typedef struct _tagCOUNTRYINFO{
	INT	nRange;				// the number of code range
	USHORT	sRange[MAX_LEADBYTES];		// start of code range
	USHORT	eRange[MAX_LEADBYTES];		// end of code range
	INT	nLeadByte;			// the number of lead byte
	UCHAR	sLeadByte[MAX_LEADBYTES];	// start of lead byte
	UCHAR	eLeadByte[MAX_LEADBYTES];	// end of lead byte
	INT	nTralByte;			// the number of trail byte
	UCHAR	sTralByte[MAX_LEADBYTES];	// start of trail byte
	UCHAR	eTralByte[MAX_LEADBYTES];	// end of trail byte
    TCHAR   szForceFont[LF_FACESIZE];   // default font facename;

#ifdef BUILD_ON_WINNT
    BOOL bUnicodeMode;                      // user select unicode mode
	BOOL bOnlyUnicode;                      // We only have unicode 


/*  For CHS to keep the original trail byte range in order to dynamically 
 *  calculate trailbyte range with EUDC selection range.
 */
    INT nOrigTralByte;
	UCHAR	sOrigTralByte[MAX_LEADBYTES];	// start of trail byte
	UCHAR	eOrigTralByte[MAX_LEADBYTES];	// end of trail byte
#endif // BUILD_ON_WINNT

	INT	LangID;				// language ID
	INT	CharacterSet;			// Character Set
	INT	CurrentRange; 			// selected currently range 
}COUNTRYINFO;

/* DBCS coderange except EUDC */
/*typedef struct _tagDBCSINFO{
	INT	nLeadByte;			// the number of lead byte
	UCHAR	sLeadByte[MAX_LEADBYTES];	// start of lead byte
	UCHAR	eLeadByte[MAX_LEADBYTES];	// end of lead byte
	INT	nTralByte;			// the number of trail byte
	UCHAR	sTralByte[MAX_LEADBYTES];	// start of trail byte
	UCHAR	eTralByte[MAX_LEADBYTES];	// end of trail byte
}DBCSINFO;
*/



/* Global parameter */
extern HCURSOR	ToolCursor[NUMTOOL];		// tool cursor
extern HCURSOR	ArrowCursor[NUMRESIZE];		// resize cursor
extern INT	CAPTION_HEIGHT;			// height of caption
extern INT	BITMAP_HEIGHT;			// height of bitmap
extern INT	BITMAP_WIDTH;			// width of bitmap
extern DWORD	COLOR_GRID;			// grid color
extern DWORD	COLOR_CURVE;			// outline color
extern DWORD	COLOR_FITTING;			// bitmap color in show outline
extern DWORD	COLOR_FACE;			// Win95 3D Face System Color
extern DWORD	COLOR_SHADOW;			// Win95 3D Shadow Color	
extern DWORD	COLOR_HLIGHT;			// Win95 3D HighLight
extern DWORD	COLOR_WIN;			// Win95 Window Color
extern TCHAR	HelpPath[MAX_PATH];		// Help file path
extern TCHAR	ChmHelpPath[MAX_PATH];	// Help file path
extern TCHAR	FontPath[MAX_PATH];		// Font file path
extern CString	NotMemTtl;
extern CString	NotMemMsg;
extern SELECTEUDC	SelectEUDC;
extern COUNTRYINFO	CountryInfo;


class CEudcApp : public CWinApp
{
public:
	CEudcApp();
	virtual BOOL	InitInstance();
	virtual BOOL	ExitInstance();
	virtual BOOL	OnIdle(LONG lCount);

private:
	BOOL	CheckPrevInstance();
        void    DisableCUAS();
	BOOL	GetProfileText( LPRECT MainWndRect, UINT *MaxWndFlag);
	BOOL	GetCountryInfo();
	BOOL	GetCursorRes();
	BOOL	GetFilePath();

public:
	//{{AFX_MSG(CEudcApp)
	afx_msg void OnAppAbout();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef BUILD_ON_WINNT
//
// Hard codeded font face name
//
//
// Public API prototype definition.
//  (should be in wingdi.h)
//
extern "C" BOOL APIENTRY EnableEUDC(BOOL bEnable);
#endif // BUILD_ON_WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\fitconic.cpp ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//

#include	"stdafx.h"


#include	"vdata.h"
#include	"extfunc.h"
#define		sign(n)		(n < 0 ? 1 : 0)
#define		fpow(f)		((double)f*f)
#define		lpow(f)		((long)f*f)
#define		SPLINE_ATR	0x0001
#define	SMOOTHANCHOR	0x80
#define	SABUNMIN	(1*16)


int  FitConic(int  inLst,int  outLst,int  level,int  ufp);
static int  SetConic(struct  VDATA *svp,int  nElm,int  outLst,int  level);
static int  CurvTerm(struct  VDATA *svp,int  nElm,struct  VDATA * *term,int  level);
static void  sabun2(struct  VDATA *vp,struct  vecdata *vd);
static int  Fitting(struct  VDATA *sp,struct  VDATA *ep,int  nElm,int  outLst);
static void  onecurve(struct  VDATA *sp,struct  VDATA *midp,struct  VDATA *ep,struct  vecdata *cp);
static int  twocurve(struct  VDATA *sp,struct  VDATA *ep,int  nElm,struct  vecdata *cp,struct  vecdata *mid,struct  vecdata *cp2);
static long  getdist(struct  vecdata *lp1,struct  vecdata *lp2,struct  vecdata *p);
static int  CrsPnt(struct  vecdata *p1,struct  vecdata *p2,struct  vecdata *p3,struct  vecdata *p4,struct  vecdata *crsp);
static long  plen(struct  vecdata *p1,struct  vecdata *p2);
static int  isbind(struct  vecdata *v1,struct  vecdata *v2,struct  vecdata *v3);
static long  GetCurveHeight(struct  VDATA *sp,struct  VDATA *ep,int  nelm,struct  VDATA * *rvp,int  *pos);

static int	underFP;
/***********************************************************************
 *	Fit Conic Spline to Short Vector
 */
/* */	int
/* */	FitConic(
/* */		int	inLst, 
/* */		int	outLst,
/* */		int	level,		/* Smoothing Level 0-SMOOTHLEVELMAX-1 */
/* */		int	ufp)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
struct VHEAD	*vhd;
	int	sts;
struct VDATA	*svp, *evp;
	int	sp, ep;
	int	ncont;

	underFP = ufp;
	if ( (sts = VDGetHead( inLst, &vhd))!=0)
		goto	RET;
	VDNew( outLst);
	ncont=0;
	while ( vhd->next != NIL) {
	    svp = vhd->headp;
	    if ((sp=searchanchor(0,svp,&svp,vhd->nPoints))<vhd->nPoints){
		while(sp<vhd->nPoints) {
			ep = searchanchor(sp+1, svp->next,&evp, vhd->nPoints);

			if ((sts = SetConic( svp, ep-sp, outLst, level))<0)
				goto	RET;

			if ( ep >= vhd->nPoints)
				break;
			sp = ep;
			svp = evp;
		}
	    }
	    ncont++;
	    if ((sts = VDClose( outLst))<0)
		goto	RET;
	    vhd = vhd->next;
	}
RET:
	return( sts);
}
/***********************************************************************
 *	Set Conic Curves to specified category
 */
/* */	static int
/* */	SetConic ( struct VDATA *svp, int nElm, int outLst, int level)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
struct VDATA *vp;
	int	nPart;
	int	sts;

	
	sts = 0;
	while ( nElm > 0) {
		/* Divide non contigus */
		nPart = CurvTerm( svp,  nElm, &vp , level);
		sts = Fitting( svp, vp, nPart, outLst);
		svp = vp;
		nElm -= nPart;
	}
	return	sts;
}
/***********************************************************************
 *	Determine the part which is described with one Conic
 */
/* */	static int
/* */	CurvTerm(
/* */		struct VDATA *svp, 
/* */			int	nElm, 
/* */		struct VDATA **term,
/* */			int	level)
/*
 *	returns: none
 ***********************************************************************/
{
struct vecdata	sub1, sub2;
	int	ecnt;

	if ( nElm < 3) {
		for ( ecnt=0; ecnt < nElm; ecnt++)
			svp = svp->next;
		*term =  svp;
		return( nElm);
	}
	sabun2( svp, &sub1);
	for ( ecnt = 2; ecnt < nElm; ecnt++)	{
		svp = svp->next;
		sabun2( svp, &sub2);
		if ((sign(sub1.x)!=sign(sub2.x)
			&& abs(sub1.x)+abs(sub2.x)> SABUNMIN*(level+1))
		 || (sign(sub1.y)!=sign(sub2.y)
			 &&abs(sub1.y)+abs(sub2.y)> SABUNMIN*(level+1))) {
			*term = svp->next;
			return ecnt;
		}
		sub1 = sub2;
	}
	*term = svp->next->next;
	return	nElm;
}
/***********************************************************************
 *	2nd Sabun
 */
/* */	static void
/* */	sabun2( struct VDATA *vp, struct vecdata *vd)
/*
 *	returns : none
 ***********************************************************************/
{
	vd->x = vp->vd.x - vp->next->vd.x*2 + vp->next->next->vd.x;
	vd->y = vp->vd.y - vp->next->vd.y*2 + vp->next->next->vd.y;
	return;
}
/***********************************************************************
 *	Curve fit and set data
 */
/* */	static int
/* */	Fitting(
/* */		struct VDATA *sp,	/* Conic Start Point */
/* */		struct VDATA *ep,	/* Conic End Point */
/* */		int	nElm,
/* */		int	outLst)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
struct vecdata	vd;
struct vecdata	cp, mid, cp2;
	int	sts;

	if ( nElm==0) 
		return 0;
	else if ( nElm == 1) {
		vd = sp->vd;
		if ((sts = VDSetData( outLst, &vd))<0)
			goto	RET;
	}
	else if ( nElm == 2) {
		onecurve( sp , sp->next, ep,  &cp );
		vd = sp->vd;
		if ((sts = VDSetData( outLst, &vd))<0)
			goto	RET;
		cp.atr = SPLINE_ATR;
		if ((sts = VDSetData( outLst, &cp))<0)
			goto	RET;
	}
	else {
		if ( twocurve( sp, ep, nElm, &cp, &mid, &cp2)) {
			vd = sp->vd;
			if ((sts = VDSetData( outLst, &vd))<0)
				goto	RET;
			cp.atr = SPLINE_ATR;
			if ((sts = VDSetData( outLst, &cp))<0)
				goto	RET;
			mid.atr = 0;
			if ((sts = VDSetData( outLst, &mid))<0)
				goto	RET;
			cp2.atr = SPLINE_ATR;
			if ((sts = VDSetData( outLst, &cp2))<0)
				goto	RET;
		}
		else {
			vd = sp->vd;
			if ((sts = VDSetData( outLst, &vd))<0)
				goto	RET;
			cp.atr = SPLINE_ATR;
			if ((sts = VDSetData( outLst, &cp))<0)
				goto	RET;
		}
	}
RET:
	return	sts;
}
/***********************************************************************
 *	Fit One Curve
 */
/* */	static void
/* */	onecurve( 
/* */	struct VDATA *sp, 
/* */	struct VDATA *midp, 
/* */	struct VDATA *ep, 
/* */	struct vecdata *cp)
/*
 *	returns : none
 ***********************************************************************/
{
struct vecdata	p;

	p.x = (midp->vd.x*4 - sp->vd.x - ep->vd.x)/2;
	p.y = (midp->vd.y*4 - sp->vd.y - ep->vd.y)/2;

	if ( sp->vd.x < ep->vd.x) {
		if ( p.x > ep->vd.x)	p.x = ep->vd.x;
		if ( p.x < sp->vd.x)	p.x = sp->vd.x;
	}
	else {
		if ( p.x < ep->vd.x)	p.x = ep->vd.x;
		if ( p.x > sp->vd.x)	p.x = sp->vd.x;
	}
	if ( sp->vd.y < ep->vd.y) {
		if ( p.y > ep->vd.y)	p.y = ep->vd.y;
		if ( p.y < sp->vd.y)	p.y = sp->vd.y;
	}
	else {
		if ( p.y < ep->vd.y)	p.y = ep->vd.y;
		if ( p.y > sp->vd.y)	p.y = sp->vd.y;
	}
	*cp = p;
}
/**********************************************************************
 *	Fit with a pair of Conic
 */
/* */	static int
/* */	twocurve( 
/* */		struct VDATA *sp, 
/* */		struct VDATA *ep, 
/* */		int	nElm,
/* */		struct vecdata *cp,
/* */		struct vecdata *mid,
/* */		struct vecdata *cp2)
/*
 *	returns : 0, 1( pair)
 **********************************************************************/
{
struct  VDATA	*midvp, *maxvp;
	long	maxlen;
	int	twin;
	long	sclen, eclen;
	int	pos;
	int	cp1pos, cp2pos;

	/* Get Curve Peak */
	maxlen = GetCurveHeight( sp, ep, nElm, &maxvp, &pos);
	/*
	if ( plen( &sp->vd, &ep->vd)/25 > maxlen) {
		onecurve( sp , maxvp, ep,  cp );
		twin = 0;
	}
	else {
	*/
		onecurve( sp , maxvp, ep,  cp );
		sclen = plen( &sp->vd, cp);
		eclen = plen( &ep->vd, cp);
		midvp = maxvp;
		if ( sclen > eclen*4 
		  || sclen*4 < eclen
		  || (long)(maxvp->vd.x - sp->vd.x)*(cp->x-sp->vd.x)<0L
		  || (long)(maxvp->vd.y - sp->vd.y)*(cp->y-sp->vd.y)<0L
		  || ( plen( &sp->vd, &ep->vd)>25L*25*underFP
			&& plen( &sp->vd, &ep->vd)<maxlen*64)) {

			maxlen=GetCurveHeight(sp, midvp, pos, &maxvp, &cp1pos);
			onecurve( sp, maxvp, midvp,  cp );
			maxlen=GetCurveHeight(midvp,ep,nElm-pos,&maxvp,&cp2pos);
			onecurve( midvp , maxvp, ep,  cp2 );
			*mid = midvp->vd;
			twin = 1;
		}
		else  {
			twin = 0;
		}
/*
	}
*/
	return( twin);
}
/**********************************************************************
 *	distance of point from line
 */	
/* */	static long
/* */	getdist(
/* */	struct vecdata	*lp1,
/* */	struct vecdata	*lp2,	/* Line p1, p2 */
/* */	struct vecdata	*p)		/* Point */
/*
 *	return :  Disttance 2nd Value
 **********************************************************************/
{
	long	a, b, c;
	long	height;

	a = - ( lp2->y - lp1->y);
	b = lp2->x - lp1->x;
	c = (long)(-lp1->y) * lp2->x + (long)(lp1->x) * lp2->y;
	if ( a==0 && b==0)
		height = c;
	else {
		height = a*p->x + b*p->y+c;
		if ( labs(height)>46340L)
			height = (long)(fpow(height)/(fpow(a)+fpow(b)));
		else
			height = lpow(height)/(lpow(a)+lpow(b));
	}
	return( height);
}
/**********************************************************************
 *	Cross Point
 */
/* */	static int
/* */	CrsPnt(
/* */	struct	vecdata	*p1,		/* vector point p1 to p2 */
/* */	struct	vecdata	*p2,
/* */	struct	vecdata	*p3,		/* vector point p3 to p4 */
/* */	struct	vecdata	*p4,
/* */	struct	vecdata	*crsp)
/*
 *	returns : 0, -1(no cross)
 **********************************************************************/
{
	int	rel1x, rel1y, rel2x, rel2y;
	long	cmul, cmul2;
	int	sts;

	rel1x = p2->x - p1->x;	
	rel1y = p2->y - p1->y;	
	rel2x = p4->x - p3->x;	
	rel2y = p4->y - p3->y;	
	cmul = (long)rel1y*rel2x - (long)rel2y*rel1x;

	if (cmul == 0L)
		sts = -1;
	else {
		cmul2 = (long)rel2x * (p3->y - p1->y) - 
			(long)rel2y * (p3->x - p1->x);
		crsp->x = (int)(cmul2*rel1x/cmul) + p1->x;
		crsp->y = (int)(cmul2*rel1y/cmul) + p1->y;
		if ( (long)rel1x*(crsp->x-p1->x)<0
		   || (long)rel1y*(crsp->y-p1->y)<0
		   || (long)rel2x*(crsp->x-p4->x)<0
		   || (long)rel2y*(crsp->y-p4->y)<0)
			sts = -1;
		else	sts = 0;
	}

	return	sts;
}
/**********************************************************************
 *	distance of points
 */	
/* */	static long
/* */	plen(
/* */		struct vecdata	*p1,
/* */		struct vecdata	*p2)
/*
 *	return :  Disttance 2nd Value
 **********************************************************************/
{
	return( lpow((long)(p2->x-p1->x)) + lpow((long)(p2->y - p1->y)));
}
/**********************************************************************
 *	bind two conic to one
 */
/* */	static  int
/* */	isbind( 
/* */		struct vecdata	*v1,
/* */		struct vecdata	*v2,
/* */		struct vecdata	*v3)
/*
 *	returns : 0, 1
 **********************************************************************/
{
	int	l12, l23;

	l12  = v1->x - v2->x;
	l23  = v2->x - v3->x;
	if ( sign( l12)!=sign(l23))
		goto	NORET;
	l12  = abs( l12);
	l23  = abs( l23);
	if ( (l12-l23)!=0) {
		if ( l12 / abs(l12 - l23) <10)
			goto	NORET;
	}
	l12  = v1->y - v2->y;
	l23  = v2->y - v3->y;
	if ( sign( l12)!=sign(l23))
		goto	NORET;
	l12  = abs( l12);
	l23  = abs( l23);
	if ( (l12-l23)!=0) {
		if ( l12 / abs(l12 - l23) <10)
			goto	NORET;
	}
	return 1;
NORET:
	return 0;
}
/**********************************************************************
 *	Get Curve liaison Peak height
 */
/* */	static long
/* */	GetCurveHeight( 
/* */	struct VDATA	*sp, 
/* */	struct VDATA	*ep, 
/* */		int	nelm, 
/* */	struct VDATA * * rvp,
/* */		int	*pos)
/*
 *	returns : maxlength( 2nd value)
 **********************************************************************/
{
	int	ecnt;
struct VDATA	*vp, *maxvp;
	long	maxlen, len;
	int	maxpos;

	/* Get Curve Peak */
	vp = sp->next;
	maxvp = vp;
	maxlen = 0;
	maxpos = 0;
	for ( ecnt = 0; ecnt < nelm-1; ecnt++, vp = vp->next) {
		len = getdist( &sp->vd, &ep->vd, &vp->vd);
		if ( len > maxlen) {
			maxlen = len;
			maxvp = vp;
			maxpos = ecnt;
		}
	}
	*rvp = maxvp;
	*pos = maxpos;
	return maxlen;
}
/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\guidebar.h ===
/**************************************************/
/*					                              */
/*					                              */
/*		GuideBar		                          */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#ifndef __AFXEXT_H_
#include <afxext.h>
#endif

class CGuideBar : public CStatusBar
{
	DECLARE_DYNAMIC(CGuideBar)
public:
	CGuideBar();
	BOOL 	Create( CWnd* pOwnerWnd, UINT pID);
//	void 	RecalcLayout();
	virtual ~CGuideBar();
	CComboBox m_comboCharset;
	void	PositionStatusPane();

protected:


#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

private:
//	void 	DrawConcaveRect( CDC *pDC, int x, int y, CSize size);


protected:
	UINT    m_nColumns;
	CWnd*   m_pOwnerWnd;

private:
	BOOL    m_comboBoxAdded;

protected:
	//{{AFX_MSG(CGuideBar)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\imeblink.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
#ifndef RC_INVOKED
#pragma pack(1)
#endif

//	data structure of IME table 
typedef struct tagUSRDICIMHDR {
    WORD  uHeaderSize;                  // 0x00
    BYTE  idUserCharInfoSign[8];        // 0x02
    BYTE  idMajor;                      // 0x0A
    BYTE  idMinor;                      // 0x0B
    DWORD ulTableCount;                 // 0x0C
    WORD  cMethodKeySize;               // 0x10
    BYTE  uchBankID;                    // 0x12
    WORD  idInternalBankID;             // 0x13
    BYTE  achCMEXReserved1[43];         // 0x15
    WORD  uInfoSize;                    // 0x40
    BYTE  chCmdKey;                     // 0x42
    BYTE  idStlnUpd;                    // 0x43
    BYTE  cbField;                      // 0x44
    WORD  idCP;                         // 0x45
    BYTE  achMethodName[6];             // 0x47
    BYTE  achCSIReserved2[51];          // 0x4D
    BYTE  achCopyRightMsg[128];         // 0x80
} USRDICIMHDR;

#ifndef RC_INVOKED
#pragma pack()
#endif

typedef USRDICIMHDR FAR *LPUSRDICIMHDR;

typedef WCHAR UNALIGNED *LPUNATSTR;

#ifdef __cplusplus
extern "C"
{
#endif

HKL 
RegisterTable( 
HWND            hWnd,
LPUSRDICIMHDR   lpIsvUsrDic,
DWORD           dwFileSize,
UINT            uCodePage);

HKL 
MatchImeName( 
LPCTSTR         szStr);

int
CodePageInfo(
    UINT uCodePage);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\guidebar.cpp ===
/**************************************************/
/*					                              */
/*					                              */
/*		Guide Bar 		                          */
/*					                              */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/ 

#include 	"stdafx.h"
#include 	"eudcedit.h"
#include 	"guidebar.h"
#include	"registry.h"
#include	"util.h"




#define		GUIDEHIGH	50
#define		COMBOWIDTH	55
#define		COMBOHEIGHT	200



#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC( CGuideBar, CStatusBar)
BEGIN_MESSAGE_MAP( CGuideBar, CStatusBar)
	//{{AFX_MSG_MAP(CGuideBar)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/****************************************/
/*					*/
/*	Constructor			*/
/*					*/
/****************************************/
CGuideBar::CGuideBar()
{
	m_comboBoxAdded = FALSE;
}

/****************************************/
/*					*/
/*	Destructor			*/
/*					*/
/****************************************/
CGuideBar::~CGuideBar()
{
}

/****************************************/
/*					*/
/*	Create GuideBar 		*/
/*					*/
/****************************************/
BOOL 
CGuideBar::Create(
CWnd* 	pOwnerWnd, 
UINT 	pID)
{

	LONG lStyle;
	//
	// We don't want the sizegrip for this status bar because it is at
	// the top of the frame.  However MFC creates a sizegrip if the
	// parent window has a thickframe.  We temporarily turn off the bit
	// to fool MFC so that SBARS_GRIPSIZE is not set.
	//
	lStyle = ::SetWindowLong(pOwnerWnd->GetSafeHwnd(),
                             GWL_STYLE,
                             (pOwnerWnd->GetStyle() & ~WS_THICKFRAME));
	m_pOwnerWnd = pOwnerWnd;
	if (!CStatusBar::Create( pOwnerWnd, WS_CHILD | WS_VISIBLE
           | CBRS_TOP | CBRS_NOALIGN, AFX_IDW_STATUS_BAR))
	{
		return FALSE;
	}

	::SetWindowLong(pOwnerWnd->GetSafeHwnd(),  GWL_STYLE,  lStyle);
	return TRUE;
}

int
CGuideBar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	CRect rect;
	TCHAR	CharBuf[MAX_PATH];
	UINT nID = 0;

	if (CStatusBar::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_comboCharset.Create(WS_CHILD | WS_VISIBLE | WS_TABSTOP |
		CBS_DROPDOWNLIST | CBS_HASSTRINGS, rect, this, IDC_SELECTCHARSET)){
		return -1;
	}

	m_comboCharset.SendMessage(WM_SETFONT, (WPARAM) CStatusBar::GetFont()->GetSafeHandle());


	switch (CountryInfo.LangID){
	case EUDC_JPN:
		nID=IDS_SHIFTJIS;
		break;
	case EUDC_CHS:
		nID=IDS_GB2312;
		break;
	case EUDC_KRW:
		nID=IDS_HANGUL;
		break;
	case EUDC_CHT:
		nID=IDS_CHINESEBIG5;
		break;
	}

	if (nID){
		GetStringRes(CharBuf, nID);
		m_comboCharset.AddString(CharBuf);
	}

	GetStringRes(CharBuf, IDS_UNICODE);
	m_comboCharset.AddString(CharBuf);
	m_comboCharset.SetCurSel(0);
	return TRUE;
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_PAINT"		*/
/*					*/
/****************************************/
void 
CGuideBar::PositionStatusPane()
{

	TCHAR	CharBuf[MAX_PATH], BufTmp[MAX_PATH], *FilePtr;
	int	nWidth;
	UINT nStyle, nID;
	CRect rect;
	CSize StringSize;
	

	GetPaneInfo(0,nID,nStyle,nWidth);
	CDC* dc = this->GetDC();
	int nComboWidth;
	int nDlgBaseUnitX = LOWORD(GetDialogBaseUnits());
	nComboWidth = (nDlgBaseUnitX * COMBOWIDTH + 2) /4;

	if (!m_comboBoxAdded)
	{
		SetPaneInfo(0,nID, nStyle | SBPS_NOBORDERS,nWidth+nComboWidth);
		m_comboCharset.SetWindowPos( NULL, nWidth+nDlgBaseUnitX, 0,
			nComboWidth, COMBOHEIGHT, SWP_NOZORDER);
		m_comboBoxAdded = TRUE;
	}
	

//	Draw "Code:"
	if( SelectEUDC.m_Code[0] != '\0'){
		GetStringRes(CharBuf, IDS_CODE_STR);
		lstrcat( CharBuf, TEXT(" "));
		lstrcat( CharBuf, SelectEUDC.m_Code);
		SetPaneText (1, CharBuf, TRUE);	
		StringSize = dc->GetTextExtent(CharBuf,lstrlen(CharBuf)); 
  	GetPaneInfo(1,nID,nStyle,nWidth);
		SetPaneInfo(1,nID,nStyle,StringSize.cx + 3*nDlgBaseUnitX);
	}
	if( SelectEUDC.m_Font[0] != '\0'){
		GetStringRes(CharBuf, IDS_FONT_STR);
		lstrcat( CharBuf, TEXT(" "));
		lstrcat( CharBuf, SelectEUDC.m_Font);
		SetPaneText (2, CharBuf, TRUE);
		StringSize = dc->GetTextExtent(CharBuf,lstrlen(CharBuf)); 
		GetPaneInfo(2,nID,nStyle,nWidth);
		SetPaneInfo(2,nID,nStyle,StringSize.cx + 3*nDlgBaseUnitX);
	}
	

	if( SelectEUDC.m_Font[0] != TEXT('\0') && InqTypeFace(SelectEUDC.m_Font,
		SelectEUDC.m_File, sizeof( SelectEUDC.m_File)/sizeof(TCHAR))){
		GetStringRes(CharBuf, IDS_FILE_STR);
		lstrcat( CharBuf, TEXT(" "));
		lstrcpy( BufTmp, SelectEUDC.m_FileTitle);
		if(( FilePtr = Mytcsrchr( BufTmp, '.')) != NULL)
			*FilePtr = '\0';
		if( lstrlen((const TCHAR *)BufTmp) > 20){
			BufTmp[20] = '\0';
			lstrcat(BufTmp, TEXT(".."));
		}
		lstrcat( CharBuf, BufTmp);
		SetPaneText (3, CharBuf, TRUE);
		StringSize = dc->GetTextExtent(CharBuf,lstrlen(CharBuf)); 
		GetPaneInfo(3,nID,nStyle,nWidth);
		SetPaneInfo(3,nID,nStyle,StringSize.cx + 3*nDlgBaseUnitX);
	}
	UpdateWindow();
    this->ReleaseDC(dc);

}


#ifdef _DEBUG
void CGuideBar::AssertValid() const
{
	CStatusBar::AssertValid();
}
void CGuideBar::Dump(CDumpContext& dc) const
{
	CStatusBar::Dump(dc);
}
#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\imeblink.c ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
#include    <windows.h>
#include    <imm.h>
#include    "resource.h"
#include    "imeblink.h"

#define     UNICODE_CP      1200

/************************************************************/
/*  MatchImeName()                                          */
/************************************************************/
HKL MatchImeName(
    LPCTSTR szStr)
{
    TCHAR     szImeName[16];
    int       nLayout;
    HKL       hKL;
    HGLOBAL   hMem;
    HKL FAR * lpMem;
    int       i;

    nLayout = GetKeyboardLayoutList(0, NULL);

    // alloc temp buffer
    hMem = GlobalAlloc(GHND, sizeof(HKL) * nLayout);

    if (!hMem) {
        return (NULL);
    }

    lpMem = (HKL FAR *)GlobalLock(hMem);

    if (!lpMem) {
        GlobalFree(hMem);
        return (NULL);
    }

    // get all keyboard layouts, it includes all IMEs
    GetKeyboardLayoutList(nLayout, lpMem);

    for (i = 0; i < nLayout; i++) {
        LRESULT lRet;

        hKL = *(lpMem + i);

        lRet = ImmEscape(hKL, (HIMC)NULL, IME_ESC_IME_NAME, szImeName);

        if (!lRet) {                // this hKL can not ask name
            continue;
        }

        if (lstrcmp(szStr, szImeName) == 0) {
            goto MatchOvr;
        }
    }

    hKL = NULL;

MatchOvr:
    GlobalUnlock(hMem);
    GlobalFree(hMem);

    return (hKL);
}

/************************************************************/
/*  RegisterTable()                                         */
/************************************************************/
HKL RegisterTable(
    HWND          hWnd,
    LPUSRDICIMHDR lpIsvUsrDic,
    DWORD         dwFileSize,
    UINT          uCodePage)
{
    HKL    hKL;
   // HDC    hDC;
   // SIZE   lTextSize;
   // RECT   rcProcess;
    DWORD  i;
    LPBYTE lpCurr, lpEnd;
    BOOL   fRet;
    TCHAR  szStr[16];
   // TCHAR  szProcessFmt[32];
   // TCHAR  szResult[2][32];
   // TCHAR  szProcessInfo[48];
    WORD   wInternalCode[256];
    WORD   wAltInternalCode[256];

#ifdef UNICODE
    if (uCodePage == UNICODE_CP) {
        LPUNATSTR lpszMethodName;

        lpszMethodName = (LPUNATSTR)lpIsvUsrDic->achMethodName;

        for (i = 0; i < sizeof(lpIsvUsrDic->achMethodName) / sizeof(TCHAR); i++) {
            szStr[i] = *lpszMethodName++;
        }

        szStr[i] = '\0';
    } else {
        UINT uLen;

        uLen = MultiByteToWideChar(uCodePage, MB_PRECOMPOSED,
            (LPCSTR)lpIsvUsrDic->achMethodName,
            sizeof(lpIsvUsrDic->achMethodName),
            szStr,
            sizeof(szStr) / sizeof(TCHAR));
        if (uLen == 0)
        {
            uCodePage = CP_ACP;
            uLen = MultiByteToWideChar(uCodePage, MB_PRECOMPOSED,
                (LPCSTR)lpIsvUsrDic->achMethodName,
                sizeof(lpIsvUsrDic->achMethodName),
                szStr,
                sizeof(szStr) / sizeof(TCHAR));
        }

        szStr[uLen] = '\0';
    }
#else
    for (i = 0; i < sizeof(lpIsvUsrDic->achMethodName); i++) {
        szStr[i] = lpIsvUsrDic->achMethodName[i];
    }

    szStr[i] = '\0';
#endif

    hKL = MatchImeName(szStr);

    if (!hKL) {
        return (hKL);
    }

    // convert sequence code to internal code
    for (i = 0; i < sizeof(wInternalCode) / sizeof(WORD); i++) {
        LRESULT lRet;

        lRet = ImmEscape(hKL, (HIMC)NULL,
            IME_ESC_SEQUENCE_TO_INTERNAL, &i);

        if (HIWORD(lRet) == 0xFFFF) {
            // This is caused by sign extent in Win9x in the return value of
            // ImmEscape, it causes an invalid internal code.
            wAltInternalCode[i] = 0;
        } else {
            wAltInternalCode[i] = HIWORD(lRet);
        }

        wInternalCode[i] = LOWORD(lRet);

#ifndef UNICODE
        if (wAltInternalCode[i] > 0xFF) {
            // convert to multi byte string
            wAltInternalCode[i] = LOBYTE(wAltInternalCode[i]) << 8 |
                HIBYTE(wAltInternalCode[i]);
        }

        if (wInternalCode[i] > 0xFF) {
            // convert to multi byte string
            wInternalCode[i] = LOBYTE(wInternalCode[i]) << 8 |
                HIBYTE(wInternalCode[i]);
        }
#endif
    }

    // check for each record and register it
    // get to the first record and skip the Bank ID
    lpCurr = (LPBYTE)(lpIsvUsrDic + 1) + sizeof(WORD);
    lpEnd = (LPBYTE)lpIsvUsrDic + dwFileSize;

    for (; lpCurr < lpEnd;
        // internal code + sequence code + Bank ID of next record
        lpCurr += sizeof(WORD) + lpIsvUsrDic->cMethodKeySize + sizeof(WORD)) {

        int j;

        // quick way to init \0 for the register string
        *(LPDWORD)szStr = 0;

#ifdef UNICODE
        if (uCodePage == UNICODE_CP) {
            szStr[0] = *(LPUNATSTR)lpCurr;
        } else {
            CHAR szMultiByte[4];

            szMultiByte[0] = HIBYTE(*(LPTSTR)lpCurr);
            szMultiByte[1] = LOBYTE(*(LPTSTR)lpCurr);

            MultiByteToWideChar(uCodePage, MB_PRECOMPOSED,
                szMultiByte, 2, szStr, 2);
        }
#else
        szStr[1] = *lpCurr;
        szStr[0] = *(lpCurr + 1);
#endif

        for (i = 0, j = 0; i < lpIsvUsrDic->cMethodKeySize; i++) {
            if (!wAltInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)]) {
            } else if (wAltInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)] < 0xFF) {
                *(LPTSTR)&szStr[4 + j] = (TCHAR)
                    wAltInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)];
                j += sizeof(TCHAR) / sizeof(TCHAR);
            } else {
                *(LPWSTR)&szStr[4 + j] = (WCHAR)
                    wAltInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)];
                j += sizeof(WCHAR) / sizeof(TCHAR);
            }

            if (wInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)] < 0xFF) {
                *(LPTSTR)&szStr[4 + j] = (TCHAR)
                    wInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)];
                j += sizeof(TCHAR) / sizeof(TCHAR);
            } else {
                *(LPWSTR)&szStr[4 + j] = (WCHAR)
                    wInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)];
                j += sizeof(WCHAR) / sizeof(TCHAR);
            }
        }

        szStr[4 + j] = szStr[4 + j + 1] = szStr[4 + j + 2] = '\0';

        fRet = ImmRegisterWord(hKL, &szStr[4], IME_REGWORD_STYLE_EUDC,
            szStr);
    }

    return (hKL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\gagedlg.h ===
/**************************************************/
/*					                              */
/*					                              */
/*	Gage when import bitmap		                  */
/*		(Dialog)		                          */
/*					                              */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

class CEditGage : public CEdit
{
public:
	CEditGage();
	~CEditGage();

protected:
	//{{AFX_MSG(CEditGage)
	afx_msg void OnPaint();
	afx_msg void OnLButtonDown( UINT nFlags, CPoint point);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CGageDlg : public CDialog
{
public:
	CGageDlg(CWnd* pParent = NULL, 
			 LPTSTR szUserFont=NULL, 
			 PTSTR szBmpFile=NULL, 
			 LPTSTR szTtfFile=NULL,
			 BOOL bIsWin95EUDC = FALSE);   // standard constructor

	//{{AFX_DATA(CGageDlg)
	enum { IDD = IDD_GAGE };
	//}}AFX_DATA

	//{{AFX_VIRTUAL(CGageDlg)
	protected:
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL
private:
	CEditGage	m_EditGage;
	TCHAR m_szUserFont[MAX_PATH];
	TCHAR m_szTtfFile[MAX_PATH];
	TCHAR m_szBmpFile[MAX_PATH];
	BOOL m_bIsWin95EUDC;

protected:

	// Generated message map functions
	//{{AFX_MSG(CGageDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\gagedlg.cpp ===
/**************************************************/
/*					                              */
/*					                              */
/*	Gage when import bitmap		                  */ 
/*		(Dialog)		                          */
/*					                              */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include 	"stdafx.h"
#include 	"eudcedit.h"
#include 	"gagedlg.h"
#include	"extfunc.h"
#include	"util.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern TCHAR	UserFont[MAX_PATH];
extern TCHAR	EUDCTTF[MAX_PATH];
extern TCHAR	EUDCBMP[MAX_PATH];
static HWND	hDlg;
static UINT	nEUDC;
static UINT	cEUDC;
static BOOL	ExecuteFlag;
static BOOL	testtest;
extern BOOL 	g_bKeepEUDCLink;
BOOL	SendImportMessage( unsigned int cEudc, unsigned int nEudc);

/****************************************/
/*					*/
/*	Constructor			*/
/*					*/
/****************************************/
CGageDlg::CGageDlg( CWnd* pParent, LPTSTR szUserFont, LPTSTR szBmpFile, LPTSTR szTtfFile, BOOL bIsWin95EUDC)
	: CDialog(CGageDlg::IDD, pParent)
{

	lstrcpy (m_szTtfFile, szTtfFile? szTtfFile : EUDCTTF);
	lstrcpy (m_szBmpFile, szBmpFile? szBmpFile : EUDCBMP);
	lstrcpy (m_szUserFont, szUserFont? szUserFont : UserFont);
	m_bIsWin95EUDC = bIsWin95EUDC;


	//{{AFX_DATA_INIT(CGageDlg)
	//}}AFX_DATA_INIT
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_INITDIALOG"		*/
/*					*/
/****************************************/
BOOL 
CGageDlg::OnInitDialog()
{
	CString	DlgTitle;

	CDialog::OnInitDialog();

//	Implement "?" in this dialog.
	DlgTitle.LoadString( IDS_IMPORT_DLGTITLE);	
	this->SetWindowText( DlgTitle);

//	Set Dialog Title name.
	m_EditGage.SubclassDlgItem( IDC_GAGE, this);
	hDlg = this->GetSafeHwnd();

	testtest = FALSE;

	OutputMessageBox( this->GetSafeHwnd(),
                    IDS_MAINFRAMETITLE,
                    IDS_IMPORTFONT_MSG, TRUE);
	return TRUE;
}

/****************************************/
/*					*/
/*	COMMAND	"OK"			*/
/*					*/
/****************************************/
void 
CGageDlg::OnOK() 
{
	ExecuteFlag = FALSE;
	CDialog::OnOK();
}

/****************************************/
/*					*/
/*	Window procedure		*/
/*					*/
/****************************************/
LRESULT 
CGageDlg::WindowProc(
UINT 	message, 
WPARAM 	wParam, 
LPARAM 	lParam) 
{
	int	sts;

	if( message == WM_IMPORTGAGE){
		if( lParam){
			cEUDC = (UINT)wParam;
			nEUDC = (UINT)lParam;
			m_EditGage.Invalidate( FALSE);
			m_EditGage.UpdateWindow();
		}
		return (0L);
	}
	if( message == WM_IMPORTSTOP){
		ExecuteFlag = TRUE;

        // The code is to fix the related bug #421829 & #438677
        // It delays 1 second to call EnabelEUDC(FALSE).

        DWORD dwStart = GetTickCount();

        // Stop if this has taken too long
        while (1)
        {
            if( GetTickCount() - dwStart >= 1000 )
                break;
        }
        
		EnableEUDC( FALSE);
		sts = Import(m_szUserFont, m_szBmpFile, m_szTtfFile,
			BITMAP_WIDTH, BITMAP_HEIGHT, SMOOTHLVL, m_bIsWin95EUDC);
		//
		// we import some glyphs and will not delete the link.
		//
		g_bKeepEUDCLink = TRUE;
		EnableEUDC( TRUE);

		if( sts)	return (0L);	// for debug
		return (0L);
	}
	return CDialog::WindowProc( message, wParam, lParam);
}

/****************************************/
/*					*/
/*	Default Constructor		*/
/*					*/
/****************************************/
CEditGage::CEditGage()
{
}

/****************************************/
/*					*/
/*	Destructor			*/
/*					*/
/****************************************/
CEditGage::~CEditGage()
{
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_PAINT"		*/
/*					*/
/****************************************/
void 
CEditGage::OnPaint()
{
	TCHAR	cEUDCBuf[10];
	TCHAR	nEUDCBuf[10];
	TCHAR	ViewBuf[30];
	CRect	EditGageRect;
	CRect	BrueGageRect, WhiteGageRect;
	CBrush	wBrush, bBrush;
	CPaintDC	dc( this);

	this->GetClientRect( &EditGageRect);

	if( !testtest){
		testtest = TRUE;
		::SendMessage( hDlg, WM_IMPORTSTOP, (WPARAM)0, (LPARAM)0);
	}else{
		if( nEUDC){
			wsprintf( cEUDCBuf, TEXT("%d"), cEUDC);
			wsprintf( nEUDCBuf, TEXT("%d"), nEUDC);
			lstrcpy(ViewBuf, cEUDCBuf);
			lstrcat(ViewBuf, TEXT(" /"));
			lstrcat(ViewBuf, nEUDCBuf);
			GetParent()->SetDlgItemText( IDC_IMPORT_STATIC, (LPCTSTR)ViewBuf);
			BrueGageRect.CopyRect( &EditGageRect);
			WhiteGageRect.CopyRect( &EditGageRect);
			BrueGageRect.right = (cEUDC*EditGageRect.Width()) / nEUDC;
			WhiteGageRect.left = BrueGageRect.right;

			bBrush.CreateSolidBrush(COLOR_BLUE);
			dc.FillRect( &BrueGageRect, &bBrush);
			bBrush.DeleteObject();

			wBrush.CreateStockObject( WHITE_BRUSH);
			dc.FillRect( &WhiteGageRect, &wBrush);
			wBrush.DeleteObject();
		}
	}
	if( cEUDC >= nEUDC){
		::SendMessage( hDlg, WM_COMMAND, (WPARAM)IDOK, (LPARAM)0);
	}
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_ONLBUTTONDOWN"	*/
/*					*/
/****************************************/
void 
CEditGage::OnLButtonDown(
UINT 	nFlags, 
CPoint 	point)
{
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_SETCURSOR"		*/
/*					*/
/****************************************/
BOOL 
CEditGage::OnSetCursor(
CWnd* 	pWnd, 
UINT 	nHitTest, 
UINT 	message)
{
	::SetCursor( AfxGetApp()->LoadStandardCursor(IDC_ARROW));
	return TRUE;
}

BEGIN_MESSAGE_MAP( CEditGage, CEdit)
	//{{AFX_MSG_MAP( CEditGage)
	ON_WM_PAINT()
	ON_WM_LBUTTONDOWN()
	ON_WM_SETCURSOR()
	ON_WM_RBUTTONUP()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/****************************************/
/*					*/
/*	Send Import Message		*/
/*					*/
/****************************************/
BOOL 
SendImportMessage(
unsigned int 	cEudc,
unsigned int 	nEudc)
{
	MSG	msg;

	while( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE)){
		if( msg.message == WM_QUIT) 
			break;
		TranslateMessage( &msg);
		DispatchMessage( &msg);
	}
	if( !ExecuteFlag){
		cEudc = 0;
		nEudc = 0;
		return FALSE;
	}
	SendMessage( hDlg, WM_IMPORTGAGE, (WPARAM)cEudc, (LPARAM)nEudc);

	return TRUE;
}

BEGIN_MESSAGE_MAP(CGageDlg, CDialog)
	//{{AFX_MSG_MAP(CGageDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


void CEditGage::OnRButtonUp(UINT nFlags, CPoint point) 
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\imelist.h ===
/**************************************************/
/*                                                */
/*                                                */
/*      Chinese IME Link Dialog Class             */
/*                                                */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

typedef struct _tagREGWORDSTRUCT {
    HKL   hKL;
    BOOL  bUpdate;
    TCHAR szIMEName[16];
    UINT  uIMENameLen;
    TCHAR szReading[14];
    DWORD dwReadingLen;
} REGWORDSTRUCT;
typedef REGWORDSTRUCT FAR *LPREGWORDSTRUCT;

typedef struct _tagIMELINKREGWORD {
    HIMC          hOldIMC;
    HIMC          hRegWordIMC;
    BOOL          fCompMsg;
    UINT          nEudcIMEs;
    UINT          nCurrIME;
    TCHAR         szEudcCodeString[4];
    REGWORDSTRUCT sRegWordStruct[1];
} IMELINKREGWORD;
typedef IMELINKREGWORD FAR *LPIMELINKREGWORD;

typedef struct _tagIMERADICALRECT {
    UINT nStartIME;
    UINT nPerPageIMEs;
    SIZE lTextSize;
    SIZE lCurrReadingExtent;
    HWND hRegWordButton;
    HWND hScrollWnd;
    RECT rcRadical[1];
} IMERADICALRECT;
typedef IMERADICALRECT FAR *LPIMERADICALRECT;

typedef struct _tagCOUNTRYSETTING {
    UINT    uCodePage;
    LPCTSTR szCodePage;
} COUNTRYSETTING;

#define WM_EUDC_CODE            (WM_USER + 0x0400)
#define WM_EUDC_COMPMSG         (WM_USER + 0x0401)
#define WM_EUDC_SWITCHIME       (WM_USER + 0x0402)
#define WM_EUDC_REGISTER_BUTTON (WM_USER + 0x0403)
#define UPDATE_NONE             0
#define UPDATE_START            1
#define UPDATE_FINISH           2
#define UPDATE_ERROR            3
#define UPDATE_REGISTERED       4
#define GWLP_IMELINKREGWORD     0
#define GWLP_RADICALRECT        (GWLP_IMELINKREGWORD + sizeof(PVOID))
#define UI_MARGIN               3
#define CARET_MARGIN            2
#define RECT_IMENAME            0
#define RECT_RADICAL            1
#define RECT_NUMBER             (RECT_RADICAL + 1)
#define UNICODE_CP              1200
#define BIG5_CP                 950
#define ALT_BIG5_CP             938
#define GB2312_CP               936

#define SIGN_CWIN               0x4E495743
#define SIGN__TBL               0x4C42545F

void	ImeLink( HWND hWnd, UINT uCode, BOOL bUnicodeMode, HINSTANCE hInst);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\imelist.c ===
/**************************************************/
/*                                                */
/*                                                */
/*      Chinese IME List Dialog Class             */
/*                                                */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include  <windows.h>
#include  <windowsx.h>
#include  "imm.h"
#include  "imelist.h"
#include  "resource.h"


static const TCHAR  szRegWordCls[] = TEXT("Radical");
static const TCHAR  szImeLinkDlg[] = TEXT("ImeLinkDlg");

static HINSTANCE    hAppInst;

static DWORD    aIds[] =
{
    IDD_RADICAL, IDH_EUDC_LINK_IMELIST,
    0, 0
};

static const COUNTRYSETTING sCountry[] = {
    {
        BIG5_CP, TEXT("BIG5")
    }
    , {
        ALT_BIG5_CP, TEXT("BIG5")
    }
#if defined(UNICODE)
    , {
        UNICODE_CP, TEXT("UNICODE")
    }
#endif
    , {
        GB2312_CP, TEXT("GB2312")
    }
};


/****************************************/
/*                                      */
/*      Create IME string listbox       */
/*                                      */
/****************************************/
LPIMELINKREGWORD
RegWordCreate(
HWND    hWnd)
{
    LPIMERADICALRECT lpImeLinkRadical;
    LPIMELINKREGWORD lpImeLinkRegWord;
    LPREGWORDSTRUCT  lpRegWordStructTmp;
    HDC              hDC;
    HWND             hEudcEditWnd;
    UINT             nLayouts, i, nIMEs;
    HKL FAR         *lphKL;
    DWORD            dwSize;
    TCHAR            szStrBuf[16];
    SIZE             lTextSize;
    RECT             rcRect;
    TCHAR            szTitle[32];
    TCHAR            szMessage[256];

    hEudcEditWnd = GetWindow( GetParent( hWnd), GW_OWNER);

    nLayouts = GetKeyboardLayoutList( 0, NULL);

    if( !(lphKL = GlobalAlloc(GPTR, sizeof(HKL)*nLayouts)))
        return NULL;

    lpImeLinkRegWord = NULL;
    GetKeyboardLayoutList( nLayouts, lphKL);

    for( i = 0, nIMEs = 0; i < nLayouts; i++) {
        LRESULT lRet;
        HKL   hKL;
        TCHAR szImeEudcDic[MAX_PATH];

        hKL = *(lphKL + i);
        if( !(lRet = ImmIsIME( hKL)))
            continue;

        szImeEudcDic[0] = '\0';
        lRet = ImmEscape( hKL, (HIMC)NULL, IME_ESC_GET_EUDC_DICTIONARY,
            szImeEudcDic);

        if( !lRet){
            continue;
        }else if( szImeEudcDic[0]){
        }else{
            continue;
        }
        *(lphKL + nIMEs) = hKL;

        nIMEs++;
    }
    if( !nIMEs){
        LoadString( hAppInst, IDS_NOIME_TITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
        LoadString( hAppInst, IDS_NOIME_MSG, szMessage, sizeof(szMessage) / sizeof(TCHAR));

        MessageBox( hEudcEditWnd, szMessage, szTitle, MB_OK);
        goto RegWordCreateFreeHKL;
    }

    dwSize = sizeof( IMELINKREGWORD) - sizeof( REGWORDSTRUCT) +
        sizeof( REGWORDSTRUCT) * nIMEs;
    lpImeLinkRegWord = (LPIMELINKREGWORD)GlobalAlloc( GPTR, dwSize);

    if( !lpImeLinkRegWord){
        LoadString( hAppInst, IDS_NOMEM_TITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
        LoadString( hAppInst, IDS_NOMEM_MSG, szMessage, sizeof(szMessage) / sizeof(TCHAR));

        MessageBox( hEudcEditWnd, szMessage, szTitle, MB_OK);
        goto RegWordCreateFreeHKL;
    }

    lpImeLinkRegWord->nEudcIMEs = nIMEs;
    lpRegWordStructTmp = &lpImeLinkRegWord->sRegWordStruct[0];
    for( i = 0; i < nIMEs; i++){
        LRESULT lRet;
#ifndef UNICODE
        UINT    j, uInternal;
#endif
        UINT uReadingSize;

        lpRegWordStructTmp->hKL = *(lphKL + i);
        if( !(lRet = ImmEscape(lpRegWordStructTmp->hKL, (HIMC)NULL,
            IME_ESC_MAX_KEY, NULL))){
            lpImeLinkRegWord->nEudcIMEs--;
            continue;
        }

        uReadingSize = sizeof(TCHAR);

#ifndef UNICODE
        for (j = 0; j < 256; j++) {
            uInternal = ImmEscape(lpRegWordStructTmp->hKL, (HIMC)NULL,
                IME_ESC_SEQUENCE_TO_INTERNAL, &j);
            if (uInternal > 255) {
                uReadingSize = sizeof(WCHAR);
                break;
            }
        }
#endif

        if( lRet * uReadingSize > sizeof(lpRegWordStructTmp->szReading) - sizeof(TCHAR)){
            lpImeLinkRegWord->nEudcIMEs--;
            continue;
        }

        if( !(lRet = ImmEscape(lpRegWordStructTmp->hKL, (HIMC)NULL,
            IME_ESC_IME_NAME, lpRegWordStructTmp->szIMEName))){
            lpImeLinkRegWord->nEudcIMEs--;
            continue;
        }

        lpRegWordStructTmp->szIMEName[
            sizeof(lpRegWordStructTmp->szIMEName) / sizeof(TCHAR) - 1] = '\0';
        lpRegWordStructTmp->uIMENameLen =
            lstrlen( lpRegWordStructTmp->szIMEName);

        lpRegWordStructTmp++;
    }
    if( !lpImeLinkRegWord->nEudcIMEs){
        LoadString( hAppInst, IDS_NOIME_TITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
        LoadString( hAppInst, IDS_NOIME_MSG, szMessage, sizeof(szMessage) / sizeof(TCHAR));

        MessageBox( hEudcEditWnd, szMessage, szTitle, MB_OK);
        goto RegWordCreateFreeRegWord;
    }
    LoadString( hAppInst, IDS_CHINESE_CHAR, szStrBuf, sizeof( szStrBuf) / sizeof(TCHAR));
    hDC = GetDC(NULL);
    GetTextExtentPoint( hDC, szStrBuf, lstrlen( szStrBuf), &lTextSize);
    ReleaseDC(NULL, hDC);
    GetWindowRect( hWnd, &rcRect);

    nIMEs = (rcRect.bottom - rcRect.top) / (2 * lTextSize.cy);
    if( lpImeLinkRegWord->nEudcIMEs <= nIMEs){
        nIMEs = lpImeLinkRegWord->nEudcIMEs;
    }
    dwSize = sizeof(IMERADICALRECT) - sizeof(RECT) + sizeof(RECT) *
        RECT_NUMBER * nIMEs;
    lpImeLinkRadical = (LPIMERADICALRECT)GlobalAlloc( GPTR, dwSize);

    if( !lpImeLinkRadical){
        lpImeLinkRegWord->nEudcIMEs = 0;
        LoadString( hAppInst, IDS_NOMEM_TITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
        LoadString( hAppInst, IDS_NOMEM_MSG, szMessage, sizeof(szMessage) / sizeof(TCHAR));

        MessageBox( hEudcEditWnd, szMessage, szTitle, MB_OK);
        goto RegWordCreateFreeRegWord;
    }
    lpImeLinkRadical->nStartIME = 0;
    lpImeLinkRadical->nPerPageIMEs = nIMEs;
    lpImeLinkRadical->lTextSize = lTextSize;
    if( lpImeLinkRegWord->nEudcIMEs > nIMEs) {
        SCROLLINFO scInfo;
        lpImeLinkRadical->hScrollWnd = CreateWindowEx( 0,
            TEXT("scrollbar"), NULL, WS_CHILD|WS_VISIBLE|SBS_VERT,
            rcRect.right - rcRect.left - lTextSize.cx, 0,
            lTextSize.cx, rcRect.bottom - rcRect.top,
            hWnd, 0, hAppInst, NULL);

        scInfo.cbSize = sizeof(SCROLLINFO);
        scInfo.fMask = SIF_ALL;
        scInfo.nMin = 0;
        scInfo.nMax = lpImeLinkRegWord->nEudcIMEs - 1 + (nIMEs - 1);
        scInfo.nPage = nIMEs;
        scInfo.nPos = 0;
        scInfo.nTrackPos = 0;
        SetScrollInfo( lpImeLinkRadical->hScrollWnd,
            SB_CTL, &scInfo, FALSE);
    }
    for( i = 0; i < nIMEs; i++){
        UINT j, k;
        j = i * RECT_NUMBER + RECT_IMENAME;
        lpImeLinkRadical->rcRadical[j].left = lTextSize.cx;
        lpImeLinkRadical->rcRadical[j].top = lTextSize.cy *
            (i * 4 + 1) / 2 - UI_MARGIN;

        lpImeLinkRadical->rcRadical[j].right =
            lpImeLinkRadical->rcRadical[j].left + lTextSize.cx * 6;

        lpImeLinkRadical->rcRadical[j].bottom =
            lpImeLinkRadical->rcRadical[j].top + lTextSize.cy +
            UI_MARGIN * 2;

        k = i * RECT_NUMBER + RECT_RADICAL;
        lpImeLinkRadical->rcRadical[k].left =
            lpImeLinkRadical->rcRadical[j].right + lTextSize.cx;

        lpImeLinkRadical->rcRadical[k].top =
            lpImeLinkRadical->rcRadical[j].top;

        lpImeLinkRadical->rcRadical[k].right =
            lpImeLinkRadical->rcRadical[k].left + lTextSize.cx *
            (sizeof(lpRegWordStructTmp->szReading) / sizeof(TCHAR) / 2 - 1);

        lpImeLinkRadical->rcRadical[k].bottom =
            lpImeLinkRadical->rcRadical[k].top + lTextSize.cy +
            UI_MARGIN * 2;
    }
    SetWindowLongPtr(hWnd, GWLP_RADICALRECT, (LONG_PTR)lpImeLinkRadical);

RegWordCreateFreeRegWord:
    if( !lpImeLinkRegWord->nEudcIMEs){
        GlobalFree((HGLOBAL)lpImeLinkRegWord);
        lpImeLinkRegWord = NULL;
    }

RegWordCreateFreeHKL:
    GlobalFree((HGLOBAL)lphKL);
    return( lpImeLinkRegWord);
}

/****************************************/
/*                                      */
/*      Switch To Mouse Clicked IME     */
/*                                      */
/****************************************/
void
SwitchToThisIME(
HWND 	hWnd,
UINT 	uIndex)
{
    LPIMELINKREGWORD  lpImeLinkRegWord;
    LPREGWORDSTRUCT   lpRegWordStructTmp;
    LPIMERADICALRECT  lpImeLinkRadical;
    DWORD             fdwConversionMode, fdwSentenceMode;

    lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr( hWnd,
        GWLP_IMELINKREGWORD);

    if( lpImeLinkRegWord->nCurrIME == uIndex)
        return;

    if( uIndex >= lpImeLinkRegWord->nEudcIMEs){
        MessageBeep((UINT)-1);
        return;
    }
    lpImeLinkRadical = (LPIMERADICALRECT)GetWindowLongPtr(hWnd,
        GWLP_RADICALRECT);

    if( uIndex < lpImeLinkRadical->nStartIME){
        lpImeLinkRadical->nStartIME = uIndex;
    }else if(( uIndex - lpImeLinkRadical->nStartIME) >=
        lpImeLinkRadical->nPerPageIMEs){
        lpImeLinkRadical->nStartIME = uIndex -
            (lpImeLinkRadical->nPerPageIMEs - 1);
    }else{
    }
    SendMessage(hWnd, WM_EUDC_COMPMSG, 0, FALSE);
    lpRegWordStructTmp = &lpImeLinkRegWord->sRegWordStruct[uIndex];
    ActivateKeyboardLayout(lpRegWordStructTmp->hKL, 0);

    if( !ImmGetConversionStatus(lpImeLinkRegWord->hRegWordIMC,
        &fdwConversionMode, &fdwSentenceMode))
    {
        return;
    }
    
    fdwConversionMode = (fdwConversionMode | IME_CMODE_EUDC |
        IME_CMODE_NATIVE) | (fdwConversionMode & IME_CMODE_SOFTKBD);

    ImmSetConversionStatus(lpImeLinkRegWord->hRegWordIMC,
        fdwConversionMode, fdwSentenceMode);

    SendMessage(hWnd, WM_EUDC_COMPMSG, 0, TRUE);
    lpImeLinkRegWord->nCurrIME = uIndex;

    if(lpImeLinkRadical->hScrollWnd){
        SCROLLINFO scInfo;

        scInfo.cbSize = sizeof(SCROLLINFO);
        scInfo.fMask = SIF_POS;
        scInfo.nPos = lpImeLinkRegWord->nCurrIME;

        SetScrollInfo(lpImeLinkRadical->hScrollWnd,
            SB_CTL, &scInfo, FALSE);
    }
    InvalidateRect(hWnd, NULL, TRUE);

    *(LPTSTR)&lpRegWordStructTmp->szReading[
        lpRegWordStructTmp->dwReadingLen] = '\0';

    ImmSetCompositionString(lpImeLinkRegWord->hRegWordIMC, SCS_SETSTR,
        NULL, 0, lpRegWordStructTmp->szReading,
        lpRegWordStructTmp->dwReadingLen * sizeof(TCHAR));
    SetFocus(hWnd);
    return;
}

/****************************************/
/*                                      */
/*      MESSAGE "WM_IMECOMPOSITION"     */
/*                                      */
/****************************************/
void
WmImeComposition(
HWND   	hWnd,
LPARAM 	lParam)
{
    LPIMELINKREGWORD lpImeLinkRegWord;
    LPREGWORDSTRUCT  lpRegWordStructTmp;
    TCHAR            szReading[sizeof(lpRegWordStructTmp->szReading)/sizeof(TCHAR)];
    LONG             lRet;
    BOOL             bUpdate;

    lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr( hWnd,
        GWLP_IMELINKREGWORD);
    lpRegWordStructTmp = &lpImeLinkRegWord->sRegWordStruct[
        lpImeLinkRegWord->nCurrIME];

    lRet = ImmGetCompositionString(lpImeLinkRegWord->hRegWordIMC,
        GCS_COMPREADSTR, szReading, sizeof(szReading));
    if (lRet < 0) {
        lpRegWordStructTmp->bUpdate = UPDATE_ERROR;
        return;
    }
    if (lRet > (sizeof(szReading) - sizeof(TCHAR))) {
        lRet = sizeof(szReading) - sizeof(TCHAR);
    }
    szReading[lRet / sizeof(TCHAR)] = '\0';

    if( lpRegWordStructTmp->dwReadingLen != (DWORD)lRet / sizeof(TCHAR)){
        bUpdate = TRUE;
    }else if( lstrcmp(lpRegWordStructTmp->szReading, szReading)){
        bUpdate = TRUE;
    }else  bUpdate = FALSE;

    if( bUpdate){
        LPIMERADICALRECT lpImeLinkRadical;
        UINT             i;
        UINT             j, k;

        lpImeLinkRadical = (LPIMERADICALRECT)GetWindowLongPtr(hWnd,
            GWLP_RADICALRECT);

        lstrcpy( lpRegWordStructTmp->szReading, szReading);

        if( lParam & GCS_RESULTSTR){
            lpRegWordStructTmp->bUpdate = UPDATE_FINISH;
        }else{
            lpRegWordStructTmp->bUpdate = UPDATE_START;
        }

        lpRegWordStructTmp->dwReadingLen = (DWORD)lRet / sizeof(TCHAR);

        if( !IsWindowEnabled(lpImeLinkRadical->hRegWordButton)){
            EnableWindow(lpImeLinkRadical->hRegWordButton, TRUE);
        }

        i = lpImeLinkRegWord->nCurrIME - lpImeLinkRadical->nStartIME;
        j = i * RECT_NUMBER + RECT_IMENAME;
        InvalidateRect(hWnd, &lpImeLinkRadical->rcRadical[j], FALSE);

        k = i * RECT_NUMBER + RECT_RADICAL;

        InvalidateRect(hWnd, &lpImeLinkRadical->rcRadical[k], FALSE);
    }else if( lParam & GCS_RESULTSTR){
        LPIMERADICALRECT lpImeLinkRadical;
        UINT i;
        UINT j, k;

        lpImeLinkRadical = (LPIMERADICALRECT)GetWindowLongPtr(hWnd,
            GWLP_RADICALRECT);
        if( lpRegWordStructTmp->bUpdate){
            lpRegWordStructTmp->bUpdate = UPDATE_FINISH;
        }
        i = lpImeLinkRegWord->nCurrIME - lpImeLinkRadical->nStartIME;
        j = i * RECT_NUMBER + RECT_IMENAME;
        InvalidateRect(hWnd, &lpImeLinkRadical->rcRadical[j], FALSE);

        k = i * RECT_NUMBER + RECT_RADICAL;
        InvalidateRect(hWnd, &lpImeLinkRadical->rcRadical[k], FALSE);
    }
    return;
}

/************************************************************/
/*                                                          */
/*  lstrcmpn                                                */
/*                                                          */
/************************************************************/
int lstrcmpn(
    LPCTSTR lpctszStr1,
    LPCTSTR lpctszStr2,
    int     cCount)
{
    int i;

    for (i = 0; i < cCount; i++) {
        int iCmp = *lpctszStr1++ - *lpctszStr2++;
        if (iCmp) { return iCmp; }
    }

    return 0;
}

/****************************************/
/*                                      */
/*      CALLBACK  ENUMREADING           */
/*                                      */
/****************************************/
int CALLBACK
EnumReading(
LPCTSTR         lpszReading,
DWORD           dwStyle,
LPCTSTR         lpszString,
LPREGWORDSTRUCT lpRegWordStructTmp)
{
    int     iLen;
    DWORD   dwZeroSeq;
    LRESULT lRet;
    TCHAR   tszZeroSeq[8];

    iLen = lstrlen(lpszReading);

    if (iLen * sizeof(TCHAR) > sizeof(lpRegWordStructTmp->szReading) -
        sizeof(WORD)) {
        return (0);
    }

    lpRegWordStructTmp->dwReadingLen = (DWORD)iLen;

    lstrcpy(lpRegWordStructTmp->szReading, lpszReading);

    dwZeroSeq = 0;
    lRet = ImmEscape(lpRegWordStructTmp->hKL, (HIMC)NULL,
        IME_ESC_SEQUENCE_TO_INTERNAL, &dwZeroSeq);

    if (!lRet) { goto Over; }

    iLen = 0;

    if (LOWORD(lRet)) {
#ifdef UNICODE
        tszZeroSeq[iLen++] = LOWORD(lRet);
#else
        if (LOWORD(lRet) > 0xFF) {
            tszZeroSeq[iLen++] = HIBYTE(LOWORD(lRet));
            tszZeroSeq[iLen++] = LOBYTE(LOWORD(lRet));
        } else {
            tszZeroSeq[iLen++] = LOBYTE(LOWORD(lRet));
        }
#endif
    }

    if (HIWORD(lRet) == 0xFFFF) {
        // This is caused by sign extent in Win9x in the return value of
        // ImmEscape, it causes an invalid internal code.
    } else if (HIWORD(lRet)) {
#ifdef UNICODE
        tszZeroSeq[iLen++] = HIWORD(lRet);
#else
        if (HIWORD(lRet) > 0xFF) {
            tszZeroSeq[iLen++] = HIBYTE(HIWORD(lRet));
            tszZeroSeq[iLen++] = LOBYTE(HIWORD(lRet));
        } else {
            tszZeroSeq[iLen++] = LOBYTE(HIWORD(lRet));
        }
#endif
    } else {
    }

    for (; lpRegWordStructTmp->dwReadingLen > 0;
        lpRegWordStructTmp->dwReadingLen -= iLen) {
        if (lstrcmpn(&lpRegWordStructTmp->szReading[
            lpRegWordStructTmp->dwReadingLen - iLen], tszZeroSeq, iLen) != 0) {
            break;
        }
    }

Over:
    lpRegWordStructTmp->szReading[lpRegWordStructTmp->dwReadingLen] = '\0';

    return (1);
}

/****************************************/
/*                                      */
/*      EUDC CODE Calcurater            */
/*                                      */
/****************************************/
void
EudcCode(
HWND    hWnd,
DWORD   dwComboCode)
{
    LPIMELINKREGWORD lpImeLinkRegWord;
    LPREGWORDSTRUCT  lpRegWordStructTmp;
    UINT             i, uCode;
    BOOL             bUnicodeMode=FALSE;

    WCHAR            TmpCode[1];
    CHAR             TmpCodeAnsi[2];

    lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr(hWnd,
        GWLP_IMELINKREGWORD);

    uCode = LOWORD(dwComboCode);

    if (HIWORD(dwComboCode)) // the code is in unicode
        bUnicodeMode = TRUE;

#ifdef UNICODE
    if (bUnicodeMode) {
        lpImeLinkRegWord->szEudcCodeString[0] = (WCHAR)uCode;
        lpImeLinkRegWord->szEudcCodeString[1] = TEXT('\0');
    }else{
        TmpCodeAnsi[0] = HIBYTE(uCode);
        TmpCodeAnsi[1] = LOBYTE(uCode);
        //
        // convert to Unicode string
        //
        MultiByteToWideChar(GetACP(), MB_PRECOMPOSED,
            (LPCSTR)TmpCodeAnsi, 2,
            (LPWSTR)TmpCode, 1);

        lpImeLinkRegWord->szEudcCodeString[0] = (WCHAR)TmpCode[0];
        lpImeLinkRegWord->szEudcCodeString[1] = TEXT('\0');
    }
#else //UNICODE
    if (bUnicodeMode) {
        TmpCode[0] = (WCHAR) uCode;

        //
        //  Convert to Ansi byte string
        //
        WideCharToMultiByte(GetACP(), WC_COMPOSITECHECK,
            (LPWSTR)TmpCode, 1,
            (LPSTR)TmpCodeAnsi, 2,
            NULL, NULL);

        lpImeLinkRegWord->szEudcCodeString[0] = TmpCodeAnsi[0];
        lpImeLinkRegWord->szEudcCodeString[1] = TmpCodeAnsi[1];
    }else{
        lpImeLinkRegWord->szEudcCodeString[0] = HIBYTE(uCode);
        lpImeLinkRegWord->szEudcCodeString[1] = LOBYTE(uCode);
    }
#endif //UNICODE

    lpImeLinkRegWord->szEudcCodeString[2] =
        lpImeLinkRegWord->szEudcCodeString[3] = '\0';

    lpRegWordStructTmp = &lpImeLinkRegWord->sRegWordStruct[0];

    for( i = 0; i < lpImeLinkRegWord->nEudcIMEs; i++){
        lpRegWordStructTmp->bUpdate = UPDATE_NONE;
        lpRegWordStructTmp->szReading[0] = '\0';
        lpRegWordStructTmp->dwReadingLen = 0;

        ImmEnumRegisterWord(lpRegWordStructTmp->hKL, EnumReading,
            NULL, IME_REGWORD_STYLE_EUDC,
            lpImeLinkRegWord->szEudcCodeString,
            lpRegWordStructTmp);

        lpRegWordStructTmp->dwReadingLen =
            lstrlen( lpRegWordStructTmp->szReading);
        lpRegWordStructTmp++;
    }
    lpRegWordStructTmp = &lpImeLinkRegWord->sRegWordStruct[
        lpImeLinkRegWord->nCurrIME];

    ImmSetCompositionString(lpImeLinkRegWord->hRegWordIMC, SCS_SETSTR,
        NULL, 0, lpRegWordStructTmp->szReading,
        lpRegWordStructTmp->dwReadingLen * sizeof(TCHAR));

    InvalidateRect(hWnd, NULL, FALSE);
    return;
}

/****************************************/
/*                                      */
/*      Change To Mouse Clicked IME     */
/*                                      */
/****************************************/
void
ChangeToOtherIME(
HWND   	hWnd,
LPARAM 	lMousePos)
{
    LPIMERADICALRECT lpImeLinkRadical;
    POINT            ptMouse;
    UINT             i;
    BOOL             bFound;

    ptMouse.x = GET_X_LPARAM( lMousePos);
    ptMouse.y = GET_Y_LPARAM( lMousePos);

    lpImeLinkRadical = (LPIMERADICALRECT)GetWindowLongPtr( hWnd,
        GWLP_RADICALRECT);
    bFound = FALSE;
    for( i = 0; i < lpImeLinkRadical->nPerPageIMEs; i++){
        UINT j;

        j = i * RECT_NUMBER + RECT_RADICAL;
        if( PtInRect(&lpImeLinkRadical->rcRadical[j], ptMouse)){
            bFound = TRUE;
            break;
        }
    }
    if( !bFound) return;
    SwitchToThisIME( hWnd, lpImeLinkRadical->nStartIME + i);
    return;
}

/****************************************/
/*                                      */
/*      ScrollUP or Down IME LISTBOX    */
/*                                      */
/****************************************/
void
ScrollIME(
HWND   	hWnd,
WPARAM 	wParam)
{
    LPIMELINKREGWORD lpImeLinkRegWord;
    LPIMERADICALRECT lpImeLinkRadical;
    int              iLines;
    UINT             uIndex;

    lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr( hWnd,
        GWLP_IMELINKREGWORD);
    lpImeLinkRadical = (LPIMERADICALRECT)GetWindowLongPtr( hWnd,
        GWLP_RADICALRECT);

    switch( LOWORD( wParam)){
    case SB_PAGEDOWN:
        iLines = lpImeLinkRadical->nPerPageIMEs - 1;
        break;
    case SB_LINEDOWN:
        iLines = 1;
        break;
    case SB_PAGEUP:
        iLines = 1 - lpImeLinkRadical->nPerPageIMEs;
        break;
    case SB_LINEUP:
        iLines = -1;
        break;
    case SB_TOP:
        SwitchToThisIME(hWnd, 0);
        return;
    case SB_BOTTOM:
        SwitchToThisIME(hWnd, lpImeLinkRegWord->nEudcIMEs - 1);
        return;
    case SB_THUMBPOSITION:
        SwitchToThisIME(hWnd, HIWORD(wParam));
        return;
    default:
        return;
    }
    uIndex = lpImeLinkRegWord->nCurrIME;
    if( iLines > 0){
        uIndex += (UINT)iLines;
        if( uIndex >= lpImeLinkRegWord->nEudcIMEs){
            uIndex = lpImeLinkRegWord->nEudcIMEs - 1;
        }
    }else{
        UINT uLines;

        uLines = -iLines;
        if( uLines > uIndex){
            uIndex = 0;
        }else  uIndex -= uLines;
    }
    SwitchToThisIME(hWnd, uIndex);
    return;
}

/****************************************/
/*                                      */
/*      ScrollUP or Down IME LISTBOX    */
/*                                      */
/****************************************/
void
ScrollIMEByKey(
HWND   	hWnd,
WPARAM 	wParam)
{
    switch( wParam){
    case VK_NEXT:
        ScrollIME( hWnd, SB_PAGEDOWN);
        break;
    case VK_DOWN:
        ScrollIME( hWnd, SB_LINEDOWN);
        break;
    case VK_PRIOR:
        ScrollIME(hWnd, SB_PAGEUP);
        break;
    case VK_UP:
        ScrollIME(hWnd, SB_LINEUP);
        break;
    default:
        return;
    }
    return;
}

/****************************************/
/*                                      */
/*      Get Focus in RegWord List       */
/*                                      */
/****************************************/
void
RegWordGetFocus(
HWND    hWnd)
{
    LPIMELINKREGWORD lpImeLinkRegWord;
    LPIMERADICALRECT lpImeLinkRadical;
    UINT             i;

    lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr( hWnd,
        GWLP_IMELINKREGWORD);
    lpImeLinkRadical = (LPIMERADICALRECT)GetWindowLongPtr( hWnd,
        GWLP_RADICALRECT);

    CreateCaret( hWnd, NULL, 2, lpImeLinkRadical->lTextSize.cy +
        CARET_MARGIN * 2);
    if( lpImeLinkRegWord->nCurrIME < lpImeLinkRadical->nStartIME){
        lpImeLinkRegWord->nCurrIME = lpImeLinkRadical->nStartIME;
    }else if(( lpImeLinkRegWord->nCurrIME - lpImeLinkRadical->nStartIME) >=
        lpImeLinkRadical->nPerPageIMEs) {
        lpImeLinkRegWord->nCurrIME = lpImeLinkRadical->nStartIME +
            lpImeLinkRadical->nPerPageIMEs - 1;
    }
    i = lpImeLinkRegWord->nCurrIME - lpImeLinkRadical->nStartIME;
    i = (i * RECT_NUMBER) + RECT_RADICAL;
    SetCaretPos(lpImeLinkRadical->rcRadical[i].left +
        lpImeLinkRadical->lCurrReadingExtent.cx + 2,
        lpImeLinkRadical->rcRadical[i].top + UI_MARGIN - CARET_MARGIN);
    ShowCaret(hWnd);
    return;
}

/****************************************/
/*                                      */
/*      MESSAGE "WM_PAINT"              */
/*                                      */
/****************************************/
void RegWordPaint(
HWND    hWnd)
{
    LPIMERADICALRECT lpImeLinkRadical;
    LPIMELINKREGWORD lpImeLinkRegWord;
    LPREGWORDSTRUCT  lpRegWordStructTmp;
    PAINTSTRUCT      ps;
    HDC              hDC;
    UINT             i;
    UINT             nShowIMEs;

    lpImeLinkRadical = (LPIMERADICALRECT)GetWindowLongPtr(hWnd,
        GWLP_RADICALRECT);
    lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr(hWnd,
        GWLP_IMELINKREGWORD);
    lpRegWordStructTmp = &lpImeLinkRegWord->sRegWordStruct[
        lpImeLinkRadical->nStartIME];
    HideCaret(hWnd);

    hDC = BeginPaint(hWnd, &ps);

    nShowIMEs = lpImeLinkRegWord->nEudcIMEs - lpImeLinkRadical->nStartIME;
    if( nShowIMEs > lpImeLinkRadical->nPerPageIMEs){
        nShowIMEs = lpImeLinkRadical->nPerPageIMEs;
    }
    for( i = 0; i < nShowIMEs; i++){
        RECT rcSunken;
        UINT j, k;

        k = i * RECT_NUMBER + RECT_RADICAL;
        rcSunken = lpImeLinkRadical->rcRadical[k];
        rcSunken.left -= 2;
        rcSunken.top -= 2;
        rcSunken.right += 2;
        rcSunken.bottom += 2;
        DrawEdge(hDC, &rcSunken, BDR_SUNKENOUTER, BF_RECT);
        SetBkColor(hDC, GetSysColor(COLOR_BTNFACE));
        if( lpRegWordStructTmp->bUpdate == UPDATE_ERROR){
            SetTextColor(hDC, RGB(0xFF, 0x00, 0x00));
        }else if(lpRegWordStructTmp->bUpdate == UPDATE_START){
            SetTextColor(hDC, RGB(0xFF, 0xFF, 0x00));
        }else if(lpRegWordStructTmp->bUpdate == UPDATE_REGISTERED){
            SetTextColor(hDC, RGB(0x00, 0x80, 0x00));
        }else{
            SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
        }
        j = i * RECT_NUMBER + RECT_IMENAME;

        ExtTextOut(hDC, lpImeLinkRadical->rcRadical[j].left,
            lpImeLinkRadical->rcRadical[j].top,
            ETO_OPAQUE | ETO_CLIPPED, &lpImeLinkRadical->rcRadical[j],
            lpRegWordStructTmp->szIMEName,
            lpRegWordStructTmp->uIMENameLen, NULL);

        if(( lpImeLinkRegWord->nCurrIME - lpImeLinkRadical->nStartIME) == i){
            SetBkColor(hDC, GetSysColor(COLOR_WINDOW));
            SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));

            GetTextExtentPoint(hDC, lpRegWordStructTmp->szReading,
                lpRegWordStructTmp->dwReadingLen,
                &lpImeLinkRadical->lCurrReadingExtent);

            SetCaretPos(lpImeLinkRadical->rcRadical[k].left +
                lpImeLinkRadical->lCurrReadingExtent.cx + 2,
                lpImeLinkRadical->rcRadical[k].top +
                UI_MARGIN - CARET_MARGIN);

        }else{
            SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
        }
        ExtTextOut(hDC, lpImeLinkRadical->rcRadical[k].left,
            lpImeLinkRadical->rcRadical[k].top + UI_MARGIN,
            ETO_OPAQUE, &lpImeLinkRadical->rcRadical[k],
            lpRegWordStructTmp->szReading,
            lpRegWordStructTmp->dwReadingLen, NULL);
        lpRegWordStructTmp++;
    }
    EndPaint(hWnd, &ps);
    ShowCaret(hWnd);
    return;
}

/****************************************/
/*                                      */
/*      Registry Word Window Proc       */
/*                                      */
/****************************************/
LRESULT CALLBACK
RegWordWndProc(
HWND   	hWnd,
UINT   	uMsg,
WPARAM 	wParam,
LPARAM 	lParam)
{
    switch( uMsg){
    case WM_CREATE:
        {
            LPIMELINKREGWORD lpImeLinkRegWord;
            UINT uIndex;

            SetWindowLongPtr( hWnd, GWLP_IMELINKREGWORD, 0L);
            SetWindowLongPtr( hWnd, GWLP_RADICALRECT, 0L);
            if( !(lpImeLinkRegWord = RegWordCreate( hWnd)))
                return (-1);
            lpImeLinkRegWord->fCompMsg = TRUE;
            lpImeLinkRegWord->nCurrIME = 0xFFFFFFFF;
            lpImeLinkRegWord->hRegWordIMC = ImmCreateContext();
            if( !lpImeLinkRegWord->hRegWordIMC){
                return (-1);
            }
            lpImeLinkRegWord->hOldIMC = ImmAssociateContext( hWnd,
                lpImeLinkRegWord->hRegWordIMC);

            SetWindowLongPtr(hWnd, GWLP_IMELINKREGWORD, (LONG_PTR)lpImeLinkRegWord);

            uIndex = 0;
            SwitchToThisIME(hWnd, 0);

            PostMessage( hWnd, WM_EUDC_SWITCHIME, 0, uIndex);
        }
        break;
    case WM_EUDC_COMPMSG:
        {
            LPIMELINKREGWORD lpImeLinkRegWord;

            lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr(hWnd,
                GWLP_IMELINKREGWORD);
            lpImeLinkRegWord->fCompMsg = (BOOL)lParam;
        }
        break;
    case WM_EUDC_SWITCHIME:
        {
            LPIMELINKREGWORD lpImeLinkRegWord;

            lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr( hWnd,
                GWLP_IMELINKREGWORD);

            lpImeLinkRegWord->nCurrIME = 0xFFFFFFFF;

            SwitchToThisIME( hWnd, (UINT)lParam);
        }
        break;
    case WM_IME_STARTCOMPOSITION:
    case WM_IME_ENDCOMPOSITION:
        break;
    case WM_IME_COMPOSITION:
        {
            LPIMELINKREGWORD lpImeLinkRegWord;

            lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr(hWnd,
                GWLP_IMELINKREGWORD);
            if( lpImeLinkRegWord->fCompMsg){
                WmImeComposition(hWnd, lParam);
            }
        }
        break;
    case WM_IME_NOTIFY:
        switch( wParam){
        case IMN_OPENSTATUSWINDOW:
        case IMN_CLOSESTATUSWINDOW:
        case IMN_OPENCANDIDATE:
        case IMN_CHANGECANDIDATE:
        case IMN_CLOSECANDIDATE:
            break;
        default:
            return DefWindowProc( hWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_IME_SETCONTEXT:
        return DefWindowProc( hWnd, uMsg, wParam,
            lParam & ~(ISC_SHOWUIALL));
    case WM_EUDC_REGISTER_BUTTON:
        {
            LPIMERADICALRECT lpImeRadicalRect;

            lpImeRadicalRect = (LPIMERADICALRECT)GetWindowLongPtr(hWnd,
                GWLP_RADICALRECT);
            lpImeRadicalRect->hRegWordButton = (HWND)lParam;
        }
        break;
    case WM_EUDC_CODE:
        EudcCode(hWnd, (DWORD)lParam);
        break;
    case WM_LBUTTONDOWN:
        ChangeToOtherIME(hWnd, lParam);
        break;
    case WM_VSCROLL:
        ScrollIME(hWnd, wParam);
        break;
    case WM_KEYDOWN:
        ScrollIMEByKey(hWnd, wParam);
        break;
    case WM_SETFOCUS:
        RegWordGetFocus(hWnd);
        break;
    case WM_KILLFOCUS:
        DestroyCaret();
        break;
    case WM_PAINT:
        RegWordPaint(hWnd);
        break;
    case WM_DESTROY:
        {
            LPIMERADICALRECT lpImeRadicalRect;
            LPIMELINKREGWORD lpImeLinkRegWord;

            lpImeRadicalRect = (LPIMERADICALRECT)GetWindowLongPtr(hWnd,
                GWLP_RADICALRECT);
            if( lpImeRadicalRect){
                GlobalFree((HGLOBAL)lpImeRadicalRect);
            }
            lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr(hWnd,
                GWLP_IMELINKREGWORD);
            if (!lpImeLinkRegWord) {
                break;
            }

            ImmAssociateContext(hWnd, lpImeLinkRegWord->hOldIMC);
            ImmDestroyContext(lpImeLinkRegWord->hRegWordIMC);
            GlobalFree((HGLOBAL)lpImeLinkRegWord);
        }
        break;
    default:
        return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }
    return (0L);
}

/****************************************/
/*                                      */
/*      Regist IME String               */
/*                                      */
/****************************************/
int
RegisterThisEudc(
HWND    hWnd)
{
    LPIMELINKREGWORD lpImeLinkRegWord;
    LPREGWORDSTRUCT  lpRegWordStructTmp;
    UINT             i;
    int              iRet;

    lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr(hWnd,
        GWLP_IMELINKREGWORD);
    lpRegWordStructTmp = &lpImeLinkRegWord->sRegWordStruct[0];
    iRet = -1;

    for( i = 0; i < lpImeLinkRegWord->nEudcIMEs; i++, lpRegWordStructTmp++){
        if (( lpRegWordStructTmp->bUpdate == UPDATE_NONE) ||
            ( lpRegWordStructTmp->bUpdate == UPDATE_REGISTERED))
				{
        }
				else if( lpRegWordStructTmp->bUpdate != UPDATE_FINISH){
            TCHAR szStrBuf[128];
            int   iYesNo;
            if( iRet != -1){
                continue;
            }
            LoadString( hAppInst, IDS_QUERY_NOTFINISH, szStrBuf,
                sizeof(szStrBuf) / sizeof(TCHAR));

            iYesNo = MessageBox(hWnd, szStrBuf,
                lpRegWordStructTmp->szIMEName,
                MB_APPLMODAL|MB_YESNO|MB_DEFBUTTON1);
            if( iYesNo == IDYES){
                iRet = i;
            }
        }else{
            BOOL  fRet;
            TCHAR szStrBuf[128];
            int   iYesNo;

            fRet = ImmRegisterWord(lpRegWordStructTmp->hKL,
                lpRegWordStructTmp->szReading,
                IME_REGWORD_STYLE_EUDC,
                lpImeLinkRegWord->szEudcCodeString);
            if( fRet){
                lpRegWordStructTmp->bUpdate = UPDATE_REGISTERED;
                continue;
            }else{
                lpRegWordStructTmp->bUpdate = UPDATE_ERROR;
            }
            if( iRet != -1){
                continue;
            }
            LoadString(hAppInst, IDS_QUERY_REGISTER, szStrBuf,
                sizeof(szStrBuf) / sizeof(TCHAR));
            iYesNo = MessageBox(hWnd, szStrBuf,
                lpRegWordStructTmp->szIMEName,
                MB_APPLMODAL|MB_YESNO|MB_DEFBUTTON1);
            if( iYesNo == IDYES){
                iRet = i;
            }
        }
    }
    InvalidateRect( hWnd, NULL, FALSE);
    return (iRet);
}

/****************************************/
/*                                      */
/*      CodePage Info                   */
/*                                      */
/****************************************/
int CodePageInfo(
    UINT    uCodePage)
{
    int i;

    for (i = 0; i < sizeof(sCountry) / sizeof(COUNTRYSETTING); i++) {
        if (sCountry[i].uCodePage == uCodePage) {
            return(i);
        }
    }

    return (-1);
}

/****************************************/
/*                                      */
/*  IME LINK LISTBOX DIALOG             */
/*                                      */
/****************************************/
INT_PTR CALLBACK
ImeLinkDlgProc(
HWND    hDlg,
UINT   	uMsg,
WPARAM 	wParam,
LPARAM 	lParam)
{
    switch( uMsg){
    case WM_INITDIALOG:
        {
            HWND    hRadicalWnd, hRegWordButton;
            int     cbString;
            UINT    uCode;
            BOOL    bUnicodeMode=FALSE;
#ifdef UNICODE
            UINT    uCodePage, uNativeCode;
            int     i;
#endif
            TCHAR  szTitle[128];
//            LONG   WindowStyle;

//            WindowStyle = GetWindowLong( hDlg, GWL_EXSTYLE);
//            WindowStyle |= WS_EX_CONTEXTHELP;
//            SetWindowLong( hDlg, GWL_EXSTYLE, WindowStyle);

            cbString = GetWindowText(hDlg, szTitle, sizeof(szTitle) /
                sizeof(TCHAR));

            uCode = LOWORD((DWORD)lParam);
            if (HIWORD((DWORD)lParam))
                bUnicodeMode = TRUE;

#ifdef UNICODE
            if (bUnicodeMode){
                uCodePage = GetACP();

                i = CodePageInfo(uCodePage);

                if (uCodePage == UNICODE_CP || i == -1) {
                    wsprintf(&szTitle[cbString], TEXT("%4X"), (UINT)lParam);
                } else {
                    uNativeCode = 0;

                    WideCharToMultiByte(uCodePage, WC_COMPOSITECHECK,
                        (LPCWSTR)&uCode, 1,
                        (LPSTR)&uNativeCode, sizeof(uNativeCode),
                        NULL, NULL);

                    // convert to multi byte string
                    uNativeCode = LOBYTE(uNativeCode) << 8 | HIBYTE(uNativeCode);

                    wsprintf(&szTitle[cbString], TEXT("%4X (%s - %4X)"),
                        (UINT)uCode, sCountry[i].szCodePage, (UINT)uNativeCode);
                }
            }else{
                wsprintf( &szTitle[cbString], TEXT("%4X"), (UINT)uCode);
            }
#else
            wsprintf( &szTitle[cbString], "%4X", (UINT)uCode);
#endif            	
            SetWindowText( hDlg, szTitle);
            hRadicalWnd = GetDlgItem(hDlg, IDD_RADICAL);
            SendMessage( hRadicalWnd, WM_EUDC_CODE, 0, lParam);

            hRegWordButton = GetDlgItem(hDlg, IDOK);
            EnableWindow( hRegWordButton, FALSE);
            SendMessage( hRadicalWnd, WM_EUDC_REGISTER_BUTTON, 0,
                (LPARAM)hRegWordButton);
        }
        return (TRUE);
    case WM_COMMAND:
        switch( wParam){
        case IDOK:
            {
                HWND    hRadicalWnd;

                hRadicalWnd = GetDlgItem(hDlg, IDD_RADICAL);
                if( RegisterThisEudc(hRadicalWnd) == -1){
                    EndDialog(hDlg, TRUE);
                }else SetFocus(hRadicalWnd);
            }
            break;
        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            break;
        default:
            return (FALSE);
        }
        return( TRUE);
    case WM_IME_NOTIFY:
        switch( wParam){
        case IMN_OPENSTATUSWINDOW:
        case IMN_CLOSESTATUSWINDOW:
            return (TRUE);
        default:
            return (FALSE);
        }
    case WM_HELP:
        {/*
            TCHAR HelpPath[MAX_PATH];

            if( !GetSystemWindowsDirectory( HelpPath, MAX_PATH))
                return FALSE;
            lstrcat(HelpPath, TEXT("\\HELP\\EUDCEDIT.HLP"));
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                HelpPath, HELP_WM_HELP, (DWORD_PTR)(LPDWORD)aIds);
         */
        }
        return FALSE;
    case WM_CONTEXTMENU:
        {/*
            TCHAR HelpPath[MAX_PATH];

            if( !GetSystemWindowsDirectory( HelpPath, MAX_PATH))
                return FALSE;
            lstrcat(HelpPath, TEXT("\\HELP\\EUDCEDIT.HLP"));
            WinHelp((HWND)wParam, HelpPath,
                HELP_CONTEXTMENU, (DWORD_PTR)(LPDWORD)aIds);
         */
        }
        return FALSE;
    default:
        return( FALSE);
    }
    return (TRUE);
}

/****************************************/
/*                                      */
/*      COMMAND "IME LINK"              */
/*                                      */
/****************************************/
void
ImeLink(
HWND        hWnd,
UINT        uCode,
BOOL        bUnicodeMode,
HINSTANCE   hInst)
{
    static  BOOL bFirstTime[20];
    int ii;
    
    WNDCLASSEX  wcClass;
    UINT        nLayouts;
    HKL FAR    *lphKL;
    TCHAR       szTitle[32];
    TCHAR       szMessage[256];
    UINT        i, nIMEs;
    HKL         hOldKL;

    for (ii = 0; ii < 20; ii++)
      bFirstTime[ii] = TRUE;

    hAppInst = hInst;

    nLayouts = GetKeyboardLayoutList(0, NULL);

    lphKL = GlobalAlloc(GPTR, sizeof(HKL) * nLayouts);

    if (!lphKL) {
        LoadString(hAppInst, IDS_NOMEM_TITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
        LoadString(hAppInst, IDS_NOMEM_MSG, szMessage, sizeof(szMessage) /sizeof(TCHAR));
        MessageBox(hWnd, szMessage, szTitle, MB_OK);
        return;
    }

    GetKeyboardLayoutList(nLayouts, lphKL);
    for (i = 0, nIMEs = 0; i < nLayouts; i++) {
        LRESULT  lRet;
        HKL   hKL;
        TCHAR szImeEudcDic[80];

        hKL = *(lphKL + i);
        lRet = ImmIsIME(hKL);
        if (!lRet) {
            continue;
        }
        szImeEudcDic[0] = '\0';

        lRet = ImmEscape(hKL, (HIMC)NULL, IME_ESC_GET_EUDC_DICTIONARY,
            szImeEudcDic);

        if (!lRet) {
            continue;
        }

        if (szImeEudcDic[0]) {
            lRet = TRUE;
        } 
        else if( !bFirstTime[i]) {
        } 
        else {
            lRet = ImmConfigureIME(hKL, hWnd, IME_CONFIG_SELECTDICTIONARY, NULL);
        }
        if (!lRet) {
            continue;
        }
        else {
          bFirstTime[i] = FALSE;
        }

        if (szImeEudcDic[0] == '\0') {
            lRet = ImmEscape(hKL, (HIMC)NULL, IME_ESC_GET_EUDC_DICTIONARY,
                szImeEudcDic);

            if (!lRet) {
                continue;
            } else if (szImeEudcDic[0] == '\0') {
                continue;
            } else {
            }
        } else {
        }
        nIMEs++;
    }
    GlobalFree((HGLOBAL)lphKL);

    if (!nIMEs) {
        LoadString(hAppInst, IDS_NOIME_TITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
        LoadString(hAppInst, IDS_NOIME_MSG, szMessage, sizeof(szMessage) / sizeof(TCHAR));
        MessageBox(hWnd, szMessage, szTitle, MB_OK);
        return;
    }

    if( !GetClassInfoEx( hAppInst, szRegWordCls, &wcClass)){
        wcClass.cbSize = sizeof(WNDCLASSEX);
        wcClass.style = CS_HREDRAW|CS_VREDRAW;
        wcClass.lpfnWndProc = RegWordWndProc;
        wcClass.cbClsExtra = 0;
        wcClass.cbWndExtra = 2 * sizeof(PVOID);
        wcClass.hInstance = hAppInst;
        wcClass.hIcon = NULL;
        wcClass.hCursor = LoadCursor(NULL, IDC_ARROW);
        wcClass.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
        wcClass.lpszMenuName = NULL;
        wcClass.lpszClassName = szRegWordCls;
        wcClass.hIconSm = NULL;
        RegisterClassEx( &wcClass);
    }
    hOldKL = GetKeyboardLayout(0);
    DialogBoxParam(hAppInst, szImeLinkDlg, hWnd, ImeLinkDlgProc,
        (LPARAM) MAKELONG(uCode , bUnicodeMode ? 0xffff : 0));
    ActivateKeyboardLayout(hOldKL, 0);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\imprtdlg.cpp ===
/**************************************************/
/*					                              */
/*					                              */
/*	Convert from bmp to ttf		                  */
/*		(Dialogbox)		                          */
/*					                              */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include 	"stdafx.h"
#include 	"eudcedit.h"
#include 	"imprtdlg.h"
#include	"ttfstruc.h"
#include	"extfunc.h"
#include	"util.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

TCHAR	UserFont[MAX_PATH];
TCHAR	EUDCTTF[MAX_PATH];
TCHAR	EUDCBMP[MAX_PATH];

/****************************************/
/*					*/
/*	Default Constructor		*/
/*					*/
/****************************************/
CImportDlg::CImportDlg( CWnd* pParent)
	: CDialog(CImportDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CImportDlg)
	//}}AFX_DATA_INIT
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_INITDIALOG"		*/
/*					*/
/****************************************/
BOOL
CImportDlg::OnInitDialog()
{
	CString	DlgTitle;

	CDialog::OnInitDialog();

//	Implement "?" in this dialogbox.
//	LONG WindowStyle = GetWindowLong( this->GetSafeHwnd(), GWL_EXSTYLE);
//	WindowStyle |= WS_EX_CONTEXTHELP;
//	SetWindowLong( this->GetSafeHwnd(), GWL_EXSTYLE, WindowStyle);

//	Set dialog title name.
	DlgTitle.LoadString( IDS_IMPORT_DLGTITLE);
	this->SetWindowText( DlgTitle);

	return TRUE;
}

/****************************************/
/*					*/
/*	COMMAND	"BROWSE"		*/
/*					*/
/****************************************/
void
CImportDlg::OnFileBrowse()
{
OPENFILENAME	ofn;
	CString	DlgTtl, DlgMsg;
	CString	sFilter;
	CWnd	*cWnd;
	TCHAR	chReplace;
	TCHAR 	szFilter[MAX_PATH];
	TCHAR	szFileName[MAX_PATH];
	TCHAR	szTitleName[MAX_PATH];
	TCHAR	szDirName[MAX_PATH];

	if( CountryInfo.LangID == EUDC_JPN){
//		Set filter of file( from string table)
		GetStringRes(szFilter, IDS_IMPORT_JAPAN_FILTER);
		int StringLength = lstrlen( szFilter);

		chReplace = szFilter[StringLength-1];
		for( int i = 0; szFilter[i]; i++){
			if( szFilter[i] == chReplace)
				szFilter[i] = '\0';
		}
		GetSystemWindowsDirectory( szDirName, sizeof(szDirName)/sizeof(TCHAR));
		lstrcpy( szFileName, TEXT("USERFONT.FON"));
		DlgTtl.LoadString( IDS_BROWSEUSER_DLGTITLE);

//		Set data in structure of OPENFILENAME
		ofn.lStructSize = sizeof( OPENFILENAME);
		ofn.hInstance = AfxGetInstanceHandle();
		ofn.hwndOwner = this->GetSafeHwnd();
		ofn.lpstrFilter = szFilter;
		ofn.lpstrCustomFilter = NULL;
		ofn.nMaxCustFilter = 0;
		ofn.nFilterIndex = 0;
		ofn.lpstrFile = szFileName;
		ofn.lpstrFileTitle = szTitleName;
		ofn.nMaxFileTitle = sizeof( szTitleName) / sizeof(TCHAR);
		ofn.nMaxFile = sizeof( szFileName) / sizeof(TCHAR);
		ofn.lpstrInitialDir = szDirName;
		ofn.Flags = OFN_HIDEREADONLY | OFN_NOCHANGEDIR
			 | OFN_PATHMUSTEXIST;
		ofn.lpstrDefExt = NULL;
		ofn.lpstrTitle = DlgTtl;

		if( !GetOpenFileName( &ofn)){
			return;
		}

		memcpy( UserFont, ofn.lpstrFile, sizeof( UserFont));
		this->SetDlgItemText( IDC_BMP_IMPUT, ofn.lpstrFile);
#ifdef BUILD_ON_WINNT
        if( OExistUserFont( UserFont) != 1){
			OutputMessageBoxEx( this->GetSafeHwnd(),
				IDS_IMPORT_DLGTITLE,
				AFX_IDP_FAILED_INVALID_PATH, TRUE, UserFont);

			cWnd = this->GetDlgItem( IDC_BMP_IMPUT);
			GotoDlgCtrl( cWnd);
			return;
        }
#endif // BUILD_ON_WINNT
		if( isW31JEUDCBMP( UserFont) != 1){
			OutputMessageBox( this->GetSafeHwnd(),
				IDS_IMPORT_DLGTITLE,
				IDS_NOTUSERFONT_MSG, TRUE);

			cWnd = this->GetDlgItem( IDC_BMP_IMPUT);
			GotoDlgCtrl( cWnd);
			return;
		}
		cWnd = GetDlgItem( IDOK);
		GotoDlgCtrl( cWnd);
	}else if( CountryInfo.LangID == EUDC_CHT ||
		  CountryInfo.LangID == EUDC_CHS ){
//		Set filter of file( from string table)
		GetStringRes(szFilter, IDS_IMPORT_CHINA_FILTER);
		int StringLength = lstrlen( szFilter);

		chReplace = szFilter[StringLength-1];
		for( int i = 0; szFilter[i]; i++){
			if( szFilter[i] == chReplace)
				szFilter[i] = '\0';
		}
		GetSystemWindowsDirectory( szDirName, sizeof(szDirName)/sizeof(TCHAR));
		lstrcpy( szFileName, TEXT("*.*"));
		DlgTtl.LoadString( IDS_BROWSEUSER_DLGTITLE);

//		Set data in structure of OPENFILENAME
		ofn.lStructSize = sizeof( OPENFILENAME);
		ofn.hwndOwner = this->GetSafeHwnd();
		ofn.hInstance = AfxGetInstanceHandle();
		ofn.lpstrFilter = szFilter;
		ofn.lpstrCustomFilter = NULL;
		ofn.nMaxCustFilter = 0;
		ofn.nFilterIndex = 0;
		ofn.lpstrFileTitle = szTitleName;
		ofn.nMaxFileTitle = sizeof( szTitleName) / sizeof(TCHAR);
		ofn.lpstrFile = szFileName;
		ofn.nMaxFile = sizeof( szFileName) / sizeof(TCHAR);
		ofn.lpstrInitialDir = szDirName;
		ofn.Flags = OFN_HIDEREADONLY | OFN_NOCHANGEDIR
			 | OFN_PATHMUSTEXIST;
		ofn.lpstrDefExt = NULL;
		ofn.lpstrTitle = DlgTtl;

		if( !GetOpenFileName( &ofn))
			return;

		memcpy( UserFont, ofn.lpstrFile, sizeof( UserFont));
		this->SetDlgItemText( IDC_BMP_IMPUT, ofn.lpstrFile);
#ifdef BUILD_ON_WINNT
        if( OExistUserFont( UserFont) != 1){
			OutputMessageBoxEx( this->GetSafeHwnd(),
				IDS_IMPORT_DLGTITLE,
				AFX_IDP_FAILED_INVALID_PATH, TRUE, UserFont);

			cWnd = this->GetDlgItem( IDC_BMP_IMPUT);
			GotoDlgCtrl( cWnd);
			return;
        }
#endif // BUILD_ON_WINNT
		if( isETENBMP( UserFont) != 1){
			OutputMessageBox( this->GetSafeHwnd(),
				IDS_IMPORT_DLGTITLE,
				IDS_NOTUSERFONT_MSG, TRUE);

			cWnd = this->GetDlgItem( IDC_BMP_IMPUT);
			GotoDlgCtrl( cWnd);
			return;
		}
		cWnd = GetDlgItem( IDOK);
		GotoDlgCtrl( cWnd);
	}
}

/****************************************/
/*					*/
/*	COMMAND	"IDOK"			*/
/*					*/
/****************************************/
void
CImportDlg::OnOK()
{
	TCHAR 	*FilePtr;
	CWnd	*cWnd;

	lstrcpy(EUDCTTF,SelectEUDC.m_File);
	lstrcpy( EUDCBMP, EUDCTTF);
	if(( FilePtr = Mytcsrchr( EUDCBMP, '.')) != NULL)
		*FilePtr = '\0';
	lstrcat( EUDCBMP, TEXT(".EUF"));
	if( !this->GetDlgItemText(IDC_BMP_IMPUT, UserFont, MAX_PATH)){
		OutputMessageBox( this->GetSafeHwnd(),
			IDS_IMPORT_DLGTITLE,
			IDS_NOTUSERFONT_MSG, TRUE);

		cWnd = this->GetDlgItem( IDC_BMP_IMPUT);
		GotoDlgCtrl( cWnd);
		return;
	}
	if( CountryInfo.LangID == EUDC_JPN){
#ifdef BUILD_ON_WINNT
        if( OExistUserFont( UserFont) != 1){
			OutputMessageBoxEx( this->GetSafeHwnd(),
				IDS_IMPORT_DLGTITLE,
				AFX_IDP_FAILED_INVALID_PATH, TRUE, UserFont);

			cWnd = this->GetDlgItem( IDC_BMP_IMPUT);
			GotoDlgCtrl( cWnd);
			return;
        }
#endif // BUILD_ON_WINNT
		if( isW31JEUDCBMP( UserFont) != 1){
			OutputMessageBox( this->GetSafeHwnd(),
				IDS_IMPORT_DLGTITLE,
				IDS_NOTUSERFONT_MSG, TRUE);

			cWnd = this->GetDlgItem( IDC_BMP_IMPUT);
			GotoDlgCtrl( cWnd);
			return;
		}
	}else{
#ifdef BUILD_ON_WINNT
        if( OExistUserFont( UserFont) != 1){
			OutputMessageBoxEx( this->GetSafeHwnd(),
				IDS_IMPORT_DLGTITLE,
				AFX_IDP_FAILED_INVALID_PATH, TRUE, UserFont);

			cWnd = this->GetDlgItem( IDC_BMP_IMPUT);
			GotoDlgCtrl( cWnd);
			return;
        }
#endif // BUILD_ON_WINNT
		if( isETENBMP( UserFont) != 1){
			OutputMessageBox( this->GetSafeHwnd(),
				IDS_IMPORT_DLGTITLE,
				IDS_NOTUSERFONT_MSG, TRUE);

			cWnd = this->GetDlgItem( IDC_BMP_IMPUT);
			GotoDlgCtrl( cWnd);
			return;
		}
	}
	EndDialog(IDOK);
}

static DWORD aIds[] =
{
  IDC_STATICBMP,    IDH_EUDC_IMPOBMP,
	IDC_BMP_IMPUT,		IDH_EUDC_IMPOBMP,
	IDC_FILE_BROWSE,	IDH_EUDC_BROWSE,
	0,0
};

/****************************************/
/*					*/
/*	Window procedure		*/
/*					*/
/****************************************/
LRESULT
CImportDlg::WindowProc(
UINT 	message,
WPARAM 	wParam,
LPARAM 	lParam)
{/*
	if( message == WM_HELP){
		::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
			HelpPath, HELP_WM_HELP, (DWORD_PTR)(LPTSTR)aIds);
		return(0);
	}
	if( message == WM_CONTEXTMENU){
		::WinHelp((HWND)wParam, HelpPath,
			HELP_CONTEXTMENU, (DWORD_PTR)(LPTSTR)aIds);
		return(0);
	}
 */
	return CDialog::WindowProc(message, wParam, lParam);
}

BEGIN_MESSAGE_MAP(CImportDlg, CDialog)
	//{{AFX_MSG_MAP(CImportDlg)
	ON_BN_CLICKED(IDC_FILE_BROWSE, OnFileBrowse)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\imprtdlg.h ===
/**************************************************/
/*					                              */
/*	Import Bimmap(Windows 3.1)	                  */ 
/*		(Dialogbox)		                          */
/*					                              */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

class CImportDlg : public CDialog
{
public:
	CImportDlg(CWnd* pParent = NULL);   // standard constructor

	//{{AFX_DATA(CImportDlg)
	enum { IDD = IDD_IMPORT };
	//}}AFX_DATA
private:
	char	UserFontTitle[MAX_PATH];
	char	EUDCFontTitle[MAX_PATH];

	//{{AFX_VIRTUAL(CImportDlg)
	protected:
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

protected:

	//{{AFX_MSG(CImportDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnFileBrowse();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\memop.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
#include "common.h"

extern void FAR *memory_alloc(unsigned int bytes);
extern void memory_free(void FAR *p);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\import.cpp ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
/*
 *	Import function for W31JEUDC and ETEN
 *----------------------------------------------
 *   bitmap proccessing steps
 *	1. Read bitmap
 *	2. Make outline
 *	3. Smoothing
 *	4. Rasterize -> editting bitmap image
 *	5. Make outline
 *	6. Smoothing
 *	7. Fitting
 *	8. Output TTF and bitmap
 *
 *   File proccessing
 *	1.Copy .EUF as temp to update
 *	2.Copy TTF tables as temp to update
 *	3.Make input bitamp code-rec table
 *	4.Per glyph proc.
 *	5.Replace files
 *
 *   Per glyph proccessing
 *	1.judge to merge to make glyph with input bitmap code-rec table.
 *	2.merge or make glyphdata and metrics
 *
 */

#include	"stdafx.h"
#include	"eudcedit.h"

#pragma		pack(2)
extern BOOL	SendImportMessage(unsigned int cEUDC, unsigned int nRec);

#include	"vdata.h"
#include	"ttfstruc.h"
#include	"extfunc.h"

#define		OUTLSTH		0
#define		TMPLSTH		1
#define		EUDCCODEBASE	((unsigned short)0xe000)


static void  pline(int  bmpNo,int  sx,int  sy,int  tx,int  ty);
static int  rasterize(int  lstHdl,int  bmpNo, int mesh, int outSiz);
static int  initmem(int  iSiz,int  oSiz);
static void  termmem(void);
static int  modmem(int  iSiz);
int  Import(TCHAR *eudcPath, TCHAR *bmpPath,TCHAR *ttfPath,int  oWidth,int  oHeight,int level, BOOL bIsWin95EUDC);
/* For Import static */
static	int	iBmpSiz;
static	int	oBmpSiz;
static	BYTE	*rBuf, *wkBuf, *refBuf;
static	BYTE	*oBuf, *owkBuf, *orefBuf;
static	int	iBmpNo, wkBmpNo, refBmpNo;
static	int	oBmpNo, owkBmpNo, orefBmpNo;
static  int	*recTbl=0;

static void
pline( int bmpNo, int sx, int sy, int tx, int ty)
{
	int	dx, dy;
	int	dx2, dy2;
	int	exy;
	int	tmp;
	

	dx = abs( sx - tx);
	dy = abs( sy - ty);
	dx2 = dx*2;
	dy2 = dy*2;

	if ( dx==0) {
		if( sy>ty) {
			while ( sy>ty) {
				sy--;
				ReverseRight( bmpNo, sx, sy);
			}
		}
		else if ( sy < ty) {
			while ( sy < ty) {
				ReverseRight( bmpNo, sx, sy);
				sy++;
			}
		}
	}
	else if ( dy==0)
		;
/*Loose*/
	else if ( dx >= dy){
		if (sx > tx) {
			tmp = tx;
			tx = sx;
			sx = tmp;
			tmp = ty;
			ty = sy;
			sy = tmp;
		}
		exy = -dx ;
	
		if ( sy < ty ) {
			while ( sx <= tx) {
				exy += dy2;
				sx++;
				if ( exy > 0) {
					exy -= dx2;
					if ( sy!=ty)
						ReverseRight( bmpNo, sx, sy);
					sy++;
				}
			}
		}
		else {
			while ( sx <= tx) {
				exy += dy2;
				sx++;
				if ( exy > 0) {
					exy -= dx2;
					sy--;
					if ( sy >= ty)
						ReverseRight( bmpNo, sx, sy);
				}
			}
		}
		
/*Steep*/	
	}
	else {	
		if (sy > ty) {
			tmp = tx;
			tx = sx;
			sx = tmp;
			tmp = ty;
			ty = sy;
			sy = tmp;
		}
		exy = -dy ;
	/*	while ( sy <= ty) { */
		while ( sy < ty) { 
			ReverseRight( bmpNo, sx, sy);
			exy += dx2;
			if ( exy >= 0) {	
				exy -= dy2;
				if ( sx < tx)	sx++;
				else		sx--;
			}
			sy++;
		}
	}
}
static int
rasterize( int lstHdl, int bmpNo, int mesh, int outSiz)
/* lstHdl : abs coord*/
{
	int	nliais, nelm;
	int	liais;
struct VHEAD	*vhead;
struct VDATA	*vp;
struct vecdata	lvd, cvd;
	if ( (nliais = VDGetNCont( lstHdl))<0)
		goto	ERET;

	BMPClear( bmpNo);
	if ( VDGetHead( lstHdl, &vhead)) 
		goto	ERET;
	for ( liais = 0; liais < nliais; liais++) {
		nelm = vhead->nPoints;
		lvd = vhead->headp->vd;
		lvd.x = (lvd.x * outSiz+mesh/2)/mesh;
		lvd.y = (lvd.y * outSiz+mesh/2)/mesh;
		vp = vhead->headp->next;
		while ( nelm-- > 0) {
			cvd = vp->vd;
			cvd.x = (cvd.x * outSiz+mesh/2)/mesh;
			cvd.y = (cvd.y * outSiz+mesh/2)/mesh;
			pline( bmpNo, lvd.x, lvd.y, cvd.x, cvd.y);
			lvd = cvd;
			vp = vp->next;
		}
		vhead = vhead->next;
	}
	return 0;
ERET:
	return -1;
}
static int
initmem( int iSiz,  int oSiz)
{
	iBmpSiz = (iSiz+15)/16*2*iSiz;
	
	rBuf = wkBuf = refBuf = 0;
	oBuf = owkBuf = orefBuf = 0;

	if ( (rBuf = (LPBYTE)malloc( iBmpSiz))==0)
		goto	ERET;
	if ( (wkBuf =(LPBYTE)malloc( iBmpSiz))==0)
		goto	ERET;
	if ( (refBuf =(LPBYTE)malloc( iBmpSiz))==0)
		goto	ERET;

	if ( (iBmpNo = BMPDefine( rBuf, iSiz, iSiz))<0)
		goto	ERET;
	if ( (wkBmpNo = BMPDefine( wkBuf, iSiz, iSiz))<0)
		goto	ERET;
	if ( (refBmpNo = BMPDefine( refBuf, iSiz, iSiz))<0)
		goto	ERET;

	oBmpSiz = (oSiz+15)/16*2*oSiz;

	if ( (oBuf = (LPBYTE)malloc( oBmpSiz))==0)
		goto	ERET;
	if ( (owkBuf = (LPBYTE)malloc( oBmpSiz))==0)
		goto	ERET;
	if ( (orefBuf = (LPBYTE)malloc( oBmpSiz))==0)
		goto	ERET;

	if ( (oBmpNo = BMPDefine( oBuf, oSiz, oSiz))<0)
		goto	ERET;
	if ( (owkBmpNo = BMPDefine( owkBuf, oSiz, oSiz))<0)
		goto	ERET;
	if ( (orefBmpNo = BMPDefine( orefBuf, oSiz, oSiz))<0)
		goto	ERET;
	return 0;
ERET:
	return -1;
}
static void
termmem()
{
	if ( rBuf )	free( rBuf);
	if ( refBuf )	free( refBuf);
	if ( wkBuf )	free( wkBuf);
	if ( oBuf )	free( oBuf);
	if ( orefBuf )	free( orefBuf);
	if ( owkBuf )	free( owkBuf);

	oBuf = wkBuf = refBuf = 0;
	rBuf = orefBuf = owkBuf = 0;
	recTbl = 0;
}
static int
modmem( int iSiz)
{
	free( rBuf);
	free( wkBuf);
	free( refBuf);
	BMPFreDef( iBmpNo);
	BMPFreDef( wkBmpNo);
	BMPFreDef( refBmpNo);
	if ( (rBuf = (LPBYTE)malloc( iBmpSiz))==0)
		goto	ERET;
	if ( (wkBuf = (LPBYTE)malloc( iBmpSiz))==0)
		goto	ERET;
	if ( (refBuf = (LPBYTE)malloc( iBmpSiz))==0)
		goto	ERET;

	if ( (iBmpNo = BMPDefine( rBuf, iSiz, iSiz))<0)
		goto	ERET;
	if ( (wkBmpNo = BMPDefine( wkBuf, iSiz, iSiz))<0)
		goto	ERET;
	if ( (refBmpNo = BMPDefine( refBuf, iSiz, iSiz))<0)
		goto	ERET;
	return 0;
ERET:
	return -1;
}
/*********************************************************************
 *	Make rec-gid table of input bitmap
 */
/* */	static int
/* */	makeRecTbl(
/* */	 	int	nRec,
/* */		BOOL bIsWin95EUDC)
/*
 *	returns : none
 *********************************************************************/
{
	int	sts;

	if ( CountryInfo.LangID == EUDC_JPN || bIsWin95EUDC)
		sts = W31JrecTbl(&recTbl, bIsWin95EUDC);
	else
		sts = ETENrecTbl(&recTbl);
				
	return sts;
}
static int
impSub( 
	int	rec,
struct	BBX	*bbx,
	short	uPEm,
	int	oWidth, 	/* output bmp width */
	int	oHeight,	/* output bmp height(==width) */
struct SMOOTHPRM *prm,
	BOOL bIsWin95EUDC)
{
	int	rdsiz;
	int	width, height;
	char	UserFontSign[8];
	WORD	BankID;
unsigned short	code;
	int	sts;
	int	nRec;
	int	nGlyph;
	BOOL bUnicode;

	/* Read EUDC Bitmap */
	if ( CountryInfo.LangID == EUDC_JPN || bIsWin95EUDC) {
		rdsiz = GetW31JBMPRec( rec, (LPBYTE)rBuf, iBmpSiz, &width, &height, &code);
		if ( rdsiz < 0)
    {
      sts = -1;
			goto	ERET;
    }
		else if ( rdsiz==0)
			return 0;
		if ( rdsiz > iBmpSiz) {
			iBmpSiz = rdsiz;
			modmem( width);
			if ( GetW31JBMPRec( rec, (LPBYTE)rBuf, iBmpSiz,
					 &width, &height, &code)<0)
      {
        sts = -1;
				goto	ERET;
      }
		}

	}
	else {
		if ( getETENBMPInf( &nRec, &nGlyph, &width, &height,
		     UserFontSign, &BankID)) {
			sts = -2;
			goto	ERET;
		}
		iBmpSiz = (width+7)/8*height;
		if (readETENBMPRec( rec, (LPBYTE)rBuf, iBmpSiz, &code)) {
			sts = -3;
			goto	ERET;
		}
	}	
	if( !memcmp( UserFontSign,"CMEX_PTN", 8) && BankID == 0x8001 || bIsWin95EUDC)
		bUnicode = TRUE;
	else	bUnicode = FALSE;

	/* vectorize */
	if( memcmp( UserFontSign,"CMEX_PTN", 8))
		BMPReverse( iBmpNo);
	if ( (BMPMkCont(  iBmpNo, wkBmpNo, refBmpNo, OUTLSTH))<0) {
		sts = -4;
		goto	ERET;
	}

	/* Smoothing */
	if (SmoothLight( OUTLSTH, TMPLSTH, width, height, oWidth*4, 16)) {
		sts = -5;
		goto	ERET;
	}
	rasterize( OUTLSTH, oBmpNo, oWidth*4, oWidth);

	/* Write Bitmap */
	BMPReverse( oBmpNo);

	if (PutW31JEUDCFont(code,(LPBYTE)oBuf,  oWidth, oWidth, bUnicode)) {
		sts = -6;
		goto	ERET;
	}
	BMPReverse( oBmpNo);

	if ( BMPMkCont(  oBmpNo, owkBmpNo, orefBmpNo, OUTLSTH)<0) {
		sts = -7;
		goto	ERET;
	}
	if (SmoothVector( OUTLSTH, TMPLSTH, oWidth, oHeight, oWidth*4,prm , 16)) {
		sts = -8;
		goto	ERET;
	}

	if (ConvMesh( OUTLSTH,oWidth*4, uPEm)) {
		sts = -9;
		goto	ERET;
	}
	if ( RemoveFp( OUTLSTH, uPEm, 16)) {
		sts = -10;
		goto	ERET;
	}
	if ( toTTFFrame( OUTLSTH, bbx)) {
		sts = -11;
		goto	ERET;
	}

	if( !bUnicode) 
		code = sjisToUniEUDC( code);

	/* write TTF */
	if ( TTFAppend( code, bbx, OUTLSTH)) {
		sts = -12;
		goto	ERET;
	}
	return 0;
ERET:
	return sts;
}
/*********************************************************************
 *	Import WIN31J EUDC or ETEN contiguous
 */
/* */	int
/* */	Import( 
/* */		TCHAR	*eudcPath, 	/* W31J EUDC Bitmap .fon*/
/* */		TCHAR	*bmpPath, 	/* Win95 EUDCEDIT bitmap .euf*/
/* */		TCHAR	*ttfPath,	/* TTF EUDC .ttf */
/* */		int	oWidth, 	/* output bmp width */
/* */		int	oHeight,	/* output bmp height(==width) */
/* */		int	level,
/* */		BOOL bIsWin95EUDC)
/*
 *	returns : 0, -1
 *********************************************************************/
{
	int	nRec;
	int	rec;
	int	width, height;
	char	UserFontSign[8];
	short	uPEm;
struct BBX	bbx;
	WORD	BankID;
	unsigned short	maxC;
	TCHAR	tmpPath[MAX_PATH];
	TCHAR	savPath[MAX_PATH];
	HANDLE	orgFh=INVALID_HANDLE_VALUE;
	int	sts;
struct SMOOTHPRM	prm;
	int	nGlyph;
	int	gCnt;
	int	cancelFlg;

//	orgFh = 0;
	BMPInit();
	VDInit();
	makeUniCodeTbl();
	maxC = getMaxUniCode();
	prm.SmoothLevel = level;
	prm.UseConic = 1;

	TTFTmpPath( ttfPath, tmpPath);
	if ( TTFImpCopy( ttfPath, tmpPath))
		goto	ERET;

	/* Open W31J EUDC bitmap font file userfont.fon or CWin31 ETEN*/
	if ( CountryInfo.LangID == EUDC_JPN || bIsWin95EUDC) {
		if (OpenW31JBMP( eudcPath, 0))
			goto	ERET;
	}
	else {
		if (openETENBMP( eudcPath, 0))
			goto	ERET;
	}

	/* Open EUDCEDIT .EUF File */
	if ( OpenW31JEUDC( bmpPath))
  {
    if (creatW31JEUDC(bmpPath))
		  goto	ERET;
    else
      if (OpenW31JEUDC( bmpPath))
        goto ERET;
  }

	if ( CountryInfo.LangID == EUDC_JPN || bIsWin95EUDC) {
		/* get number of record */
		if ( GetW31JBMPnRecs(&nRec, &nGlyph, &width, &height))
			goto	ERET;
		iBmpSiz = (width + 7)/8 * height;
	}
	else{
		if ( getETENBMPInf( &nRec, &nGlyph, &width, &height, 
		     UserFontSign, &BankID))
			goto	ERET;
		iBmpSiz = (width+7)/8*height;

	}

	/* Limit nRec */
	if ( nRec > (int)( maxC-EUDCCODEBASE+1))
		nRec = (int)( maxC-EUDCCODEBASE+1);
	initmem( width, oWidth);

	if ( makeRecTbl( nRec, bIsWin95EUDC))
		goto	ERET;

	/* Get BBX */
	if ( TTFGetEUDCBBX( ttfPath, &bbx, &uPEm))
		goto	ERET;
	/* Open temporaly */
	if ( TTFOpen( tmpPath))
		goto	ERET;

	/* Open Original */
	orgFh = CreateFile(ttfPath,
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( orgFh == INVALID_HANDLE_VALUE)
		goto	ERET;
	/* copy missing glyph*/
	TTFImpGlyphCopy(orgFh, 0);
	/* per glyph */
	gCnt = 0;
	cancelFlg = 0;
	for ( rec = 0; rec < nRec; rec++) {
		if ( recTbl[rec]>= 0) {
			gCnt++;
			if ( gCnt < nGlyph) {
				if (SendImportMessage((unsigned int)gCnt,
						(unsigned int)nGlyph)==0)
					cancelFlg=1;
			}
		}
		if ( cancelFlg==0 && recTbl[rec]>= 0) {
			if ((sts = impSub(recTbl[rec],&bbx,uPEm,oWidth, oHeight,&prm,bIsWin95EUDC))<0)
				goto	ERET;
	 		else if (sts >0)
				break;
		}
		else {
			if (TTFImpGlyphCopy(orgFh, rec+2)) 
				goto	ERET;
		}
	}

	SendImportMessage((unsigned int)nGlyph, (unsigned int)nGlyph);

	if ( TTFImpTerm(orgFh, rec+2))
		goto ERET;
	
	
	CloseHandle( orgFh);
	
	if ( TTFClose())
		goto ERET;

	if ( CountryInfo.LangID == EUDC_JPN || bIsWin95EUDC) {
		if (CloseW31JBMP())
			goto	ERET;
	
	}
	else {
		if (closeETENBMP())
			goto	ERET;
	}
	CloseW31JEUDC();

	/* Replace file */
	TTFTmpPath( ttfPath, savPath);
	if ( DeleteFile( savPath)==0)
		goto	ERET;
	if (MoveFile( ttfPath, savPath)==0)
		goto	ERET;
	if (MoveFile( tmpPath, ttfPath)==0)
		goto	ERET;

	if ( DeleteFile( savPath)==0)
		goto	ERET;
	VDTerm();
	termmem();
	return 0;
ERET:
	if ( orgFh != INVALID_HANDLE_VALUE) {
		CloseHandle( orgFh);
		orgFh = INVALID_HANDLE_VALUE;
	}
	TTFClose();
	CloseW31JBMP();
	CloseW31JEUDC();
	VDTerm();
	termmem();
	return -1;
}
/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\mainfrm.h ===
/**************************************************/
/*						                          */
/*						                          */
/*	MDI mainframe window class		              */
/*						                          */
/*						                          */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include	"guidebar.h"

class CMainFrame : public CMDIFrameWnd
{
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();
	BOOL 	Create( LPCTSTR WndTitle, DWORD WndStyle, RECT MainWndRect, LPCTSTR nID);
	BOOL 	OpenReferWindow();
	BOOL	OutputSaveMessage();
	BOOL	CustomActivate();
	CGuideBar	m_wndGuideBar;

private:
	WORD	CorrectCode( WORD Code, BOOL UporDown);	
	UINT	SetReffCode( BOOL EditorRefer);

private:
	BOOL 	CustomWndOpen;
	BOOL 	RefferWndVisible;
	BOOL	ToolBarVisible;
	BOOL 	GuideBarVisible;
	CRect	EudcWndRect;
	CRect	ReffWndRect;

protected:
	CToolBar	m_wndToolBar;

public:
	virtual ~CMainFrame();

protected:
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext *pContext);

#ifdef _DEBUG
	virtual	void AssertValid() const;
	virtual	void Dump(CDumpContext& dc) const;
#endif

private:
	BOOL CreateToolBar();
	BOOL CreateGuideBar();
	BOOL CreateReferWnd();
	void SetEudcWndPos();
	void SetReffWndPos();
	void CalcEudcWndRect();
	void CalcReffWndRect();

protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnStylesBar(UINT nID);
	afx_msg void OnUpdateStylesBar(CCmdUI* pCmdUI);
	afx_msg void OnUpdateToolbar(CCmdUI* pCmdUI);
	afx_msg void OnDestroy();
	afx_msg void OnRefferfileNew();
	afx_msg void OnReadChar();
	afx_msg void OnUpdateRefferfileNew(CCmdUI* pCmdUI);
	afx_msg void OnToolbar();
	afx_msg void OnRefferClose();
	afx_msg void OnUpdateRefferClose(CCmdUI* pCmdUI);
	afx_msg void OnClose();
	afx_msg void OnShowGrid();
	afx_msg void OnUpdateShowGrid(CCmdUI* pCmdUI);
	afx_msg void OnSelectfamily();
	afx_msg void OnSavechar();
	afx_msg void OnUpdateSavechar(CCmdUI* pCmdUI);
	afx_msg void OnSaveCharas();
	afx_msg void OnUpdateSaveCharas(CCmdUI* pCmdUI);
	afx_msg void OnLinkime();
	afx_msg void OnInitMenu(CMenu* pMenu);
	afx_msg void OnUpdateReadChar(CCmdUI* pCmdUI);
	afx_msg void OnUpdateLinkime(CCmdUI* pCmdUI);
	afx_msg void OnNextcode();
	afx_msg void OnUpdateNextcode(CCmdUI* pCmdUI);
	afx_msg void OnPrevcode();
	afx_msg void OnUpdatePrevcode(CCmdUI* pCmdUI);
	afx_msg void OnCallChar();
	afx_msg void OnUpdateCallChar(CCmdUI* pCmdUI);
	afx_msg void OnImportFile();
	afx_msg void OnUpdateImportFile(CCmdUI* pCmdUI);
	afx_msg void OnLinkbatchmode();
	afx_msg void OnUpdateLinkbatchmode(CCmdUI* pCmdUI);
	afx_msg void OnHelp();
	afx_msg void OnFitCurve();
	afx_msg void OnUpdateFitCurve(CCmdUI* pCmdUI);
	afx_msg void OnRotate();
	afx_msg void OnUpdateRotate(CCmdUI* pCmdUI);
	afx_msg void OnPalettebrush();
	afx_msg void OnUpdatePalettebrush(CCmdUI* pCmdUI);
	afx_msg void OnPalettecircle();
	afx_msg void OnUpdatePalettecircle(CCmdUI* pCmdUI);
	afx_msg void OnPalettecirclefill();
	afx_msg void OnUpdatePalettecirclefill(CCmdUI* pCmdUI);
	afx_msg void OnPalettefreeform();
	afx_msg void OnUpdatePalettefreeform(CCmdUI* pCmdUI);
	afx_msg void OnPalettepen();
	afx_msg void OnUpdatePalettepen(CCmdUI* pCmdUI);
	afx_msg void OnPaletterect();
	afx_msg void OnUpdatePaletterect(CCmdUI* pCmdUI);
	afx_msg void OnPaletterectband();
	afx_msg void OnUpdatePaletterectband(CCmdUI* pCmdUI);
	afx_msg void OnPaletterectfill();
	afx_msg void OnUpdatePaletterectfill(CCmdUI* pCmdUI);
	afx_msg void OnPaletteeraser();
	afx_msg void OnUpdatePaletteeraser(CCmdUI* pCmdUI);
	afx_msg void OnPaletteslope();
	afx_msg void OnUpdatePaletteslope(CCmdUI* pCmdUI);
	afx_msg void OnSelectCharSet();

	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\mainfrm.cpp ===
/**************************************************/
/*						                          */
/*						                          */
/*	MDI Mainframe window class		              */
/*						                          */
/*						                          */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include 	"stdafx.h"
#include 	"eudcedit.h"
#include 	"mainfrm.h"
#include 	"editwnd.h"
#include 	"refrwnd.h"
#include 	"eudcdlg.h"
#include 	"refrdlg.h"
#include	"registry.h"
#include	"assocdlg.h"
#include	"imprtdlg.h"
#include	"gagedlg.h"
#include	"blinkdlg.h"
#include	"util.h"
#include	"rotatdlg.h"
#include	"extfunc.h"
extern "C"
{
#include	"imelist.h"
}

#define		BUFFERMAX	800

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//	Global paramter
BOOL	TitleFlag;
extern CPoint	PalettePt;
CEditWnd	*pEditChild;
CRefrWnd *pRefrChild;
extern BOOL SetCountryInfo(UINT LocalCP);

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)
BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_COMMAND_EX(IDW_STYLES, OnStylesBar)
	ON_UPDATE_COMMAND_UI(IDW_STYLES, OnUpdateStylesBar)
	ON_UPDATE_COMMAND_UI(ID_TOOLBAR, OnUpdateToolbar)
	ON_WM_DESTROY()
	ON_COMMAND(ID_REFFERFILE_NEW, OnRefferfileNew)
	ON_COMMAND(ID_READ_CHAR, OnReadChar)
	ON_UPDATE_COMMAND_UI(ID_REFFERFILE_NEW, OnUpdateRefferfileNew)
	ON_COMMAND(ID_TOOLBAR, OnToolbar)
	ON_COMMAND(ID_REFFER_CLOSE, OnRefferClose)
	ON_UPDATE_COMMAND_UI(ID_REFFER_CLOSE, OnUpdateRefferClose)
	ON_WM_CLOSE()
	ON_COMMAND(ID_SHOW_GRID, OnShowGrid)
	ON_UPDATE_COMMAND_UI(ID_SHOW_GRID, OnUpdateShowGrid)
	ON_COMMAND(ID_SELECTFAMILY, OnSelectfamily)
	ON_COMMAND(ID_SAVECHAR, OnSavechar)
	ON_UPDATE_COMMAND_UI(ID_SAVECHAR, OnUpdateSavechar)
	ON_COMMAND(ID_SAVE_CHARAS, OnSaveCharas)
	ON_UPDATE_COMMAND_UI(ID_SAVE_CHARAS, OnUpdateSaveCharas)
	ON_COMMAND(ID_LINKIME, OnLinkime)
	ON_WM_INITMENU()
	ON_UPDATE_COMMAND_UI(ID_READ_CHAR, OnUpdateReadChar)
	ON_UPDATE_COMMAND_UI(ID_LINKIME, OnUpdateLinkime)
	ON_COMMAND(ID_NEXTCODE, OnNextcode)
	ON_UPDATE_COMMAND_UI(ID_NEXTCODE, OnUpdateNextcode)
	ON_COMMAND(ID_PREVCODE, OnPrevcode)
	ON_UPDATE_COMMAND_UI(ID_PREVCODE, OnUpdatePrevcode)
	ON_COMMAND(ID_CALL_CHAR, OnCallChar)
	ON_UPDATE_COMMAND_UI(ID_CALL_CHAR, OnUpdateCallChar)
	ON_COMMAND(ID_IMPORT_FILE, OnImportFile)
	ON_UPDATE_COMMAND_UI(ID_IMPORT_FILE, OnUpdateImportFile)
	ON_COMMAND(ID_LINKBATCHMODE, OnLinkbatchmode)
	ON_UPDATE_COMMAND_UI(ID_LINKBATCHMODE, OnUpdateLinkbatchmode)
	ON_COMMAND(ID_HELP, OnHelp)
	ON_COMMAND(ID_FIT_CURVE, OnFitCurve)
	ON_UPDATE_COMMAND_UI(ID_FIT_CURVE, OnUpdateFitCurve)
	ON_COMMAND(ID_ROTATE, OnRotate)
	ON_UPDATE_COMMAND_UI(ID_ROTATE, OnUpdateRotate)
	ON_COMMAND(ID_PALETTEBRUSH, OnPalettebrush)
	ON_UPDATE_COMMAND_UI(ID_PALETTEBRUSH, OnUpdatePalettebrush)
	ON_COMMAND(ID_PALETTECIRCLE, OnPalettecircle)
	ON_UPDATE_COMMAND_UI(ID_PALETTECIRCLE, OnUpdatePalettecircle)
	ON_COMMAND(ID_PALETTECIRCLEFILL, OnPalettecirclefill)
	ON_UPDATE_COMMAND_UI(ID_PALETTECIRCLEFILL, OnUpdatePalettecirclefill)
	ON_COMMAND(ID_PALETTEFREEFORM, OnPalettefreeform)
	ON_UPDATE_COMMAND_UI(ID_PALETTEFREEFORM, OnUpdatePalettefreeform)
	ON_COMMAND(ID_PALETTEERASER, OnPaletteeraser)
	ON_UPDATE_COMMAND_UI(ID_PALETTEERASER, OnUpdatePaletteeraser)
	ON_COMMAND(ID_PALETTEPEN, OnPalettepen)
	ON_UPDATE_COMMAND_UI(ID_PALETTEPEN, OnUpdatePalettepen)
	ON_COMMAND(ID_PALETTERECT, OnPaletterect)
	ON_UPDATE_COMMAND_UI(ID_PALETTERECT, OnUpdatePaletterect)
	ON_COMMAND(ID_PALETTERECTBAND, OnPaletterectband)
	ON_UPDATE_COMMAND_UI(ID_PALETTERECTBAND, OnUpdatePaletterectband)
	ON_COMMAND(ID_PALETTERECTFILL, OnPaletterectfill)
	ON_UPDATE_COMMAND_UI(ID_PALETTERECTFILL, OnUpdatePaletterectfill)
	ON_COMMAND(ID_PALETTESLOPE, OnPaletteslope)
	ON_UPDATE_COMMAND_UI(ID_PALETTESLOPE, OnUpdatePaletteslope)
	ON_CBN_SELCHANGE(IDC_SELECTCHARSET, OnSelectCharSet)

	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT BASED_CODE Palette[] =
{
//	Correspond to palette bitmap data
	ID_PALETTEPEN,
	ID_PALETTEBRUSH,
	ID_PALETTESLOPE,
	ID_PALETTERECT,
	ID_PALETTERECTFILL,
	ID_PALETTECIRCLE,
	ID_PALETTECIRCLEFILL,
	ID_PALETTERECTBAND,
	ID_PALETTEFREEFORM,
	ID_PALETTEERASER
};

/************************************************/
/*						*/
/*	Constructor				*/
/*						*/	
/************************************************/
CMainFrame::CMainFrame()
{
	CustomWndOpen = FALSE;		// Whether edit open or not
	RefferWndVisible = FALSE;	// Whether referrence visible or not
	ToolBarVisible = TRUE;		// Whether toolbox visible or not
	GuideBarVisible = TRUE;		// Whether guidebar visible or not
}

/************************************************/
/*						*/
/*	Destructor				*/
/*						*/
/************************************************/
CMainFrame::~CMainFrame()
{
}

/************************************************/
/*						*/
/*	Create MDI mainframe window 		*/
/*						*/
/************************************************/
BOOL
CMainFrame::Create(
LPCTSTR WndTitle,
DWORD 	WndStyle,
RECT 	MainWndRect,
LPCTSTR 	nID)
{
//	Register MDI mainframe window class
	const TCHAR *MainWndClass =
	AfxRegisterWndClass( 0, AfxGetApp()->LoadStandardCursor(IDC_ARROW),
		 	(HBRUSH)(COLOR_WINDOW+1),
		 	 AfxGetApp()->LoadIcon(IDR_MAINFRAME));

	if( !CFrameWnd::Create( MainWndClass,
		WndTitle, WndStyle, MainWndRect, NULL, nID))
		return FALSE;

	return TRUE;
}

/************************************************/
/*						*/
/*	Process before MDI mainframe create	*/
/*						*/
/************************************************/
int
CMainFrame::OnCreate(
LPCREATESTRUCT lpCreateStruct)
{
	if( CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	if( !LoadAccelTable( MAKEINTRESOURCE(IDR_MAINFRAME)))
		return -1;
	if( !CreateGuideBar())
		return -1;
	if( !CreateToolBar())
		return -1;
	EnableDocking(CBRS_ALIGN_ANY);

	if( !CreateReferWnd())
		return -1;
	m_wndToolBar.EnableDocking(CBRS_ALIGN_TOP | CBRS_ALIGN_LEFT);
	DockControlBar(&m_wndToolBar);
 	return 0;
}

/************************************************/
/*						*/
/*	Create client area			*/
/*						*/
/************************************************/
BOOL
CMainFrame::OnCreateClient(
LPCREATESTRUCT	lpcs,
CCreateContext 	*pContext)
{
	if( !CMDIFrameWnd::CreateClient( lpcs, NULL))
		return FALSE;

	return TRUE;
}

/************************************************/
/*						*/
/*	Create tool bar ( left side)		*/
/*						*/
/************************************************/
BOOL
CMainFrame::CreateToolBar()
{
	if( !m_wndToolBar.Create( this, WS_CHILD | WS_VISIBLE | CBRS_LEFT |
			CBRS_TOOLTIPS, 0)||
	    !m_wndToolBar.LoadBitmap( IDR_MAINFRAME)   ||
	    !m_wndToolBar.SetButtons( Palette,
	    sizeof( Palette)/sizeof( UINT)))
		return FALSE;
	else
		return TRUE;
}



/************************************************/
/*						*/
/*	Create Guideline bar ( upper side)	*/
/*						*/
/************************************************/
BOOL
CMainFrame::CreateGuideBar()
{
	const UINT nIndicators[] = {IDS_CHARSET_STR,
								IDS_CODE_STR,
								IDS_FONT_STR,
								IDS_FILE_STR};
	
	if( !m_wndGuideBar.Create( this, ID_TOOLBAR) ||
		!m_wndGuideBar.SetIndicators(nIndicators,
			sizeof(nIndicators)/sizeof(UINT)))
		return FALSE;
	else{
		m_wndGuideBar.PositionStatusPane();	
		return TRUE;
	}
}




/************************************************/
/*						*/
/*	COMMAND 	"ASSOCIATIONS"		*/
/*						*/
/************************************************/
void
CMainFrame::OnSelectfamily()
{
	CAssocDlg	dlg;

	if( CustomWndOpen){
		if( !OutputSaveMessage())
			return;
	}
	if( dlg.DoModal() == IDOK){
		if( CustomWndOpen){
			pEditChild->UpdateBitmap();
			pEditChild->SelectCodes();
		}
		m_wndGuideBar.PositionStatusPane();
	
	}
}

/************************************************/
/*						*/
/*	COMMAND 	"SELECTCODE"		*/
/*						*/
/************************************************/
void
CMainFrame::OnReadChar()
{
	CEudcDlg	dlg;

	if( CustomWndOpen){
		if( !OutputSaveMessage())
			return;
	}
	dlg.WorRFlag = FALSE;
	if( dlg.DoModal() == IDOK){
		AfxGetApp()->DoWaitCursor(1);

		EudcWndRect.SetRectEmpty();
		if( !CustomWndOpen){
//			CalcEudcWndRect();
			CEditWnd *pEudcWnd = new CEditWnd;
			if( !pEudcWnd->Create( TEXT("EDITWINDOW"),
			    WS_CHILD | WS_VISIBLE | WS_BORDER,
			    EudcWndRect,this))
				return;
					
			pEditChild = pEudcWnd;
			SetEudcWndPos();			
			pEudcWnd->ShowWindow( SW_SHOWNORMAL);
			pEudcWnd->UpdateWindow();
			CustomWndOpen = TRUE;
		}
		pEditChild->UpdateBitmap();
		pEditChild->UpdateCode = dlg.m_EditList.SelectCode;
		pEditChild->SelectCodes();
		wsprintf( SelectEUDC.m_Code, TEXT("%X"), dlg.m_EditList.SelectCode);
	
		CountryInfo.CurrentRange = dlg.m_EditList.cRange;
		m_wndGuideBar.PositionStatusPane();
	
		AfxGetApp()->DoWaitCursor( -1);
	}
}

/************************************************/
/*						*/
/*	COMMAND		"SELECTCODE" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateReadChar(
CCmdUI* pCmdUI)
{
	if( SelectEUDC.m_Font[0] != TEXT('\0') &&
		InqTypeFace((TCHAR *)SelectEUDC.m_Font,
	  ( TCHAR *)SelectEUDC.m_File, sizeof( SelectEUDC.m_File)/sizeof(TCHAR)))
		pCmdUI->Enable( TRUE);
	else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"REGISTER"		*/
/*						*/
/************************************************/
void
CMainFrame::OnSavechar()
{
	AfxGetApp()->DoWaitCursor(1);
	pEditChild->SaveEUDCCode(MB_OK);
	AfxGetApp()->DoWaitCursor(-1);
}

/************************************************/
/*						*/
/*	COMMAND 	"REGISTER" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateSavechar(
CCmdUI* pCmdUI)
{
	if( InqTypeFace((TCHAR *)SelectEUDC.m_Font,
	  ( TCHAR *)SelectEUDC.m_File,
	    sizeof( SelectEUDC.m_File )/sizeof(TCHAR)) && CustomWndOpen)
		pCmdUI->Enable( TRUE);
	else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"REGISTER AS"		*/
/*						*/
/************************************************/
void
CMainFrame::OnSaveCharas()
{
	CEudcDlg	dlg;

	dlg.WorRFlag = TRUE;
	if( dlg.DoModal() == IDOK){
		AfxGetApp()->DoWaitCursor(1);

		pEditChild->UpdateCode = dlg.m_EditList.SelectCode;
		pEditChild->SaveEUDCCode(MB_OK);
		wsprintf( SelectEUDC.m_Code, TEXT("%X"), dlg.m_EditList.SelectCode);
		CountryInfo.CurrentRange = dlg.m_EditList.cRange;
		m_wndGuideBar.PositionStatusPane();

		AfxGetApp()->DoWaitCursor(-1);
	}
}

/************************************************/
/*						*/
/*	COMMAND 	"REGISTER AS" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateSaveCharas(
CCmdUI* pCmdUI)
{		
	if( InqTypeFace((TCHAR *)SelectEUDC.m_Font,
	  ( TCHAR *)SelectEUDC.m_File,
	    sizeof( SelectEUDC.m_File )/sizeof(TCHAR)) && CustomWndOpen)
		pCmdUI->Enable( TRUE);
	else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"IMPORT"		*/
/*						*/
/************************************************/
void
CMainFrame::OnImportFile()
{
	CImportDlg	dlg1;
	BOOL		Tmp;

	if( CustomWndOpen){
		if( !OutputSaveMessage())
			return;
	}
  if (!OExistTTF(SelectEUDC.m_File))
  {
    OutputMessageBox(this->GetSafeHwnd(), IDS_MAINFRAMETITLE, IDS_NOTTE, TRUE);
    return;
  }
	if( dlg1.DoModal() == IDOK){
		if( CustomWndOpen){
			Tmp = FALSE;	
			if( pEditChild->FlagTmp){
				Tmp = TRUE;
				this->SendMessage( WM_COMMAND,
					ID_FIT_CURVE, 0L);
			}
		}
		CGageDlg	dlg2;
		if( dlg2.DoModal() == IDOK){
			;
		}
		if( CustomWndOpen){
			if( Tmp){
				this->SendMessage( WM_COMMAND,
					ID_FIT_CURVE, 0L);
			}
		}
	}else	;
}
/************************************************/
/*						*/
/*	COMMAND		"IMPORT" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateImportFile(
CCmdUI* pCmdUI)
{
	if(InqTypeFace((TCHAR *)SelectEUDC.m_Font,
	               (TCHAR *)SelectEUDC.m_File, 
                 sizeof( SelectEUDC.m_File)/sizeof(TCHAR)))
		pCmdUI->Enable( TRUE);
	else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND		"Select Charset"	*/
/*						*/
/************************************************/

void
CMainFrame::OnSelectCharSet()
{
	CHAR CPCode[2];
	WCHAR UCode[1];
	CEudcDlg dlg;
	UINT LocalCP =GetACP();
	if (m_wndGuideBar.m_comboCharset.GetCurSel() ==
		m_wndGuideBar.m_comboCharset.GetCount()-1){
		//We are switching to unicode.
		if ( CountryInfo.bUnicodeMode )
			// We are already in unicode mode.  No change.
			return;
		CountryInfo.CurrentRange = CountryInfo.nRange-1;
		CountryInfo.bUnicodeMode =TRUE;
		SetTrailByteRange(LocalCP);
		if( SelectEUDC.m_Code[0] != '\0'){
			CPCode[0]= HIBYTE(Mytcstol(SelectEUDC.m_Code, (TCHAR **)0, 16));
			CPCode[1]= LOBYTE(Mytcstol(SelectEUDC.m_Code, (TCHAR **)0, 16));
			MultiByteToWideChar(LocalCP, 0, CPCode,2, UCode,1);
			wsprintf( SelectEUDC.m_Code, TEXT("%X"),UCode[0]);
			m_wndGuideBar.PositionStatusPane();
			pEditChild->UpdateCode = UCode[0];
			dlg.m_EditList.SelectCode = UCode[0];
		}
	}else{
		//We are switching to code page
		if ( !CountryInfo.bUnicodeMode )
			// We are already in code page mode.  No change.
			return;

		CountryInfo.bUnicodeMode = FALSE;
		SetTrailByteRange(LocalCP);
		if( SelectEUDC.m_Code[0] != '\0'){
			BOOL bNotConverted;
			UCode[0] = (WCHAR)Mytcstol(SelectEUDC.m_Code, (TCHAR **)0, 16);
			WideCharToMultiByte(LocalCP, 0,UCode,1, CPCode,2, NULL, &bNotConverted);
			TCHAR CodeTmp[16] = {0};

      // fix for 7831
      BOOL bValidCode = TRUE;
      if (CountryInfo.LangID == EUDC_CHS)
      {
        bValidCode = FALSE;
        WORD wdCode = MAKEWORD(CPCode[1], CPCode[0]);
			  BYTE sOffset = LOBYTE(wdCode);
        int  kk;
        for (kk = 0; kk < CountryInfo.nRange-1; kk++)
        {
          if ((wdCode >= CountryInfo.sRange[kk]) &&
              (wdCode <= CountryInfo.eRange[kk]))
              break;
        }
        CorrectTrailByteRange(kk);
	      for( kk = 0; kk < CountryInfo.nTralByte; kk++)
        {
				  if( sOffset >= CountryInfo.sTralByte[kk] &&
				      sOffset <= CountryInfo.eTralByte[kk])
          {
				   	  bValidCode = TRUE;
              break;
          }
        }
      }
      // end of fix for 7831

			if (bNotConverted || !bValidCode){
				OutputMessageBox( this->GetSafeHwnd(),
					IDS_MAINFRAMETITLE,
					IDS_INVALID_CODE_MSG, TRUE);
				
				if( CustomWndOpen){
					CountryInfo.bUnicodeMode = TRUE;
					OutputSaveMessage();
					CountryInfo.bUnicodeMode = FALSE;
				}
				CountryInfo.CurrentRange = 0;
				dlg.m_EditList.SetInitEUDCCodeRange(CountryInfo.CurrentRange);
				dlg.m_EditList.SelectCode=CountryInfo.sRange[CountryInfo.CurrentRange];
				pEditChild->SelectCodes();
				wsprintf( SelectEUDC.m_Code, TEXT("%X"), dlg.m_EditList.SelectCode);
				OnReadChar();
				return;
			}else{
				wsprintf( CodeTmp, TEXT("%X"), (BYTE)CPCode[0]);
				SelectEUDC.m_Code[0] = CodeTmp[0];
				SelectEUDC.m_Code[1] = CodeTmp[1];
				wsprintf( CodeTmp, TEXT("%X"), (BYTE)CPCode[1]);
				SelectEUDC.m_Code[2] = CodeTmp[0];
				SelectEUDC.m_Code[3] = CodeTmp[1];
				dlg.m_EditList.SelectCode = (WORD)Mytcstol(SelectEUDC.m_Code, (TCHAR **)0, 16);
				for (int i=0;i<CountryInfo.nRange - 1; i++)
				{
					if (dlg.m_EditList.SelectCode >= CountryInfo.sRange[i] &&
						dlg.m_EditList.SelectCode <= CountryInfo.eRange[i])
					{
							CountryInfo.CurrentRange = i;
					}
				}
			}
			m_wndGuideBar.PositionStatusPane();
			pEditChild->UpdateCode = dlg.m_EditList.SelectCode;

			
		}
        else
        {
            CountryInfo.CurrentRange = 0;
        }
	}
	dlg.m_EditList.SetInitEUDCCodeRange( CountryInfo.CurrentRange);
}

/************************************************/
/*						*/
/*	COMMAND  	"CALL"			*/
/*						*/
/************************************************/
void
CMainFrame::OnCallChar()
{
	UINT	Result;

	if( CustomWndOpen){
		if( !OutputSaveMessage())
			return;
	}
	if(( Result = SetReffCode( TRUE)) == IDOK){
		pEditChild->UpdateBitmap();
		pEditChild->CallCharTextOut();
	}
}

/************************************************/
/*						*/
/*	COMMAND 	"CALL" (Update)		*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateCallChar(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen)
		pCmdUI->Enable( TRUE);
	else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"LINK"			*/
/*						*/
/************************************************/
void
CMainFrame::OnLinkime()
{
#if 0
	CIMEDlg		dlg;
	dlg.EudcCode = pEditChild->UpdateCode;
	dlg.DoModal();
#endif
	ImeLink( this->GetSafeHwnd(),
		pEditChild->UpdateCode,
		CountryInfo.bUnicodeMode ? TRUE : FALSE,
		AfxGetInstanceHandle());
}

/************************************************/
/*						*/
/*	COMMAND 	"LINK" (Update)		*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateLinkime(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen &&
	  ( CountryInfo.LangID == EUDC_CHT ||
	    CountryInfo.LangID == EUDC_CHS )){
		pCmdUI->Enable(TRUE);
	}else	pCmdUI->Enable(FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"BATCHLINK"		*/
/*						*/
/************************************************/
void
CMainFrame::OnLinkbatchmode()
{
	CBLinkDlg	dlg;

	dlg.DoModal();
}

/************************************************/
/*						*/
/*	COMMAND 	"BATCHLINK" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateLinkbatchmode(
CCmdUI* pCmdUI)
{
#ifdef BUILD_ON_WINNT
//
//  IME batch link should be font independent feature
// and available after launch EUDCEDIT. The batch link
// menu item is grayed after launching EUDCEDIT.
//  It will be enabled after font association and EUDC
// code are selected.
//  But font association and EUDC code selection do not
// have any relationship with IME batch link.
//  The user does not need to select font association
// and EUDC code if they want to do IME batch link only.
//
// NTRaid #19424.
//
	if( CountryInfo.LangID == EUDC_CHT ||
	    CountryInfo.LangID == EUDC_CHS ){
		pCmdUI->Enable(TRUE);
	}else	pCmdUI->Enable(FALSE);
#else
	if( CustomWndOpen &&
	  ( CountryInfo.LangID == EUDC_CHT ||
	    CountryInfo.LangID == EUDC_CHS )){
		pCmdUI->Enable(TRUE);
	}else	pCmdUI->Enable(FALSE);
#endif // BUILD_ON_WINNT
}

/************************************************/
/*						*/
/*	COMMAND 	"GUIDEBAR"		*/
/*						*/
/************************************************/
BOOL
CMainFrame::OnStylesBar(
UINT 	nID)
{
	GuideBarVisible = !GuideBarVisible;


	if( GuideBarVisible)
		m_wndGuideBar.ShowWindow(SW_SHOWNA);
	else	m_wndGuideBar.ShowWindow(SW_HIDE);
	m_wndGuideBar.PositionStatusPane();
	this->SendMessage( WM_SIZE);

	return TRUE;
}

/************************************************/
/*						*/
/*	COMMAND 	"GUIDEBAR" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateStylesBar(
CCmdUI* pCmdUI)
{
	pCmdUI->SetCheck(GuideBarVisible);
}

/************************************************/
/*						*/
/*	COMMAND 	"TOOLBOX"		*/
/*						*/
/************************************************/
void
CMainFrame::OnToolbar()
{
    ToolBarVisible = !ToolBarVisible;
	if( ToolBarVisible)
    {
        DockControlBar(&m_wndToolBar);
		m_wndToolBar.ShowWindow( SW_SHOWNORMAL);
	}else{
        if (m_wndToolBar.IsFloating())
        {
		    m_wndToolBar.GetParentOwner()->ShowWindow( SW_HIDE);
        }
        else
        {
		    m_wndToolBar.ShowWindow( SW_HIDE);
        }
	}	
	this->SendMessage(WM_SIZE);
}

/************************************************/
/*						*/
/*	COMMAND		"TOOLBOX" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateToolbar(
CCmdUI* pCmdUI)
{
    ToolBarVisible = m_wndToolBar.IsWindowVisible();
	pCmdUI->SetCheck(ToolBarVisible);
}

/************************************************/
/*						*/
/*	COMMAND 	"GRID"			*/
/*						*/
/************************************************/
void
CMainFrame::OnShowGrid()
{
	pEditChild->GridShow = !pEditChild->GridShow;
	pEditChild->Invalidate( FALSE);
	pEditChild->UpdateWindow();
	if( RefferWndVisible){
		pRefrChild->GridShow = !pRefrChild->GridShow;
		pRefrChild->Invalidate(FALSE);
		pRefrChild->UpdateWindow();
	}
}

/************************************************/
/*						*/
/*	COMMAND 	"GRID" (Update)		*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateShowGrid(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen){
		pCmdUI->Enable(1);
		pCmdUI->SetCheck( pEditChild->GridShow);
	}else 	pCmdUI->Enable(0);
}

/************************************************/
/*						*/
/*	COMMAND 	"NEXT CODE"		*/
/*						*/
/************************************************/
void
CMainFrame::OnNextcode()
{
	if( CustomWndOpen){
		if( !OutputSaveMessage())
			return;
	}
	EudcWndRect.SetRectEmpty();
	pEditChild->UpdateBitmap();
	pEditChild->UpdateCode++;
	pEditChild->UpdateCode = CorrectCode( pEditChild->UpdateCode, TRUE);
	pEditChild->SelectCodes();
	wsprintf( SelectEUDC.m_Code, TEXT("%X"), pEditChild->UpdateCode);
	
	m_wndGuideBar.PositionStatusPane();
}

/************************************************/
/*						*/
/*	COMMAND 	"NEXT CODE" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateNextcode(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen &&
	  ( InqTypeFace((TCHAR *)SelectEUDC.m_Font,
	  (TCHAR *)SelectEUDC.m_File, sizeof( SelectEUDC.m_File)/sizeof(TCHAR)))){
		if( CountryInfo.eRange[CountryInfo.CurrentRange]
				<= pEditChild->UpdateCode)
			pCmdUI->Enable( FALSE);
		else	pCmdUI->Enable( TRUE);
	}else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"PREV CODE"		*/
/*						*/
/************************************************/
void
CMainFrame::OnPrevcode()
{
	if( CustomWndOpen){
		if( !OutputSaveMessage())
			return;
	}
	EudcWndRect.SetRectEmpty();
	pEditChild->UpdateBitmap();
	pEditChild->UpdateCode--;
	pEditChild->UpdateCode = CorrectCode( pEditChild->UpdateCode, FALSE);
	pEditChild->SelectCodes();
	wsprintf( SelectEUDC.m_Code, TEXT("%X"), pEditChild->UpdateCode);

	m_wndGuideBar.PositionStatusPane();
}

/************************************************/
/*						*/
/*	COMMAND 	"PREV CODE" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdatePrevcode(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen &&
	  ( InqTypeFace((TCHAR *)SelectEUDC.m_Font,
	  (TCHAR *)SelectEUDC.m_File, sizeof( SelectEUDC.m_File)/sizeof(TCHAR)))){
		if( CountryInfo.sRange[CountryInfo.CurrentRange]
				>= pEditChild->UpdateCode)
			pCmdUI->Enable( FALSE);
		else	pCmdUI->Enable( TRUE);
	}else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"SHOW OUTLINE"		*/
/*						*/
/************************************************/
void
CMainFrame::OnFitCurve()
{
	if( CustomWndOpen){
		pEditChild->FlagTmp = !pEditChild->FlagTmp;

		pEditChild->Invalidate(FALSE);
		pEditChild->UpdateWindow();
	}
}

/************************************************/
/*						*/
/*	COMMAND 	"SHOW OUTLINE"(Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateFitCurve(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen){
		pCmdUI->Enable(TRUE);
		pCmdUI->SetCheck( pEditChild->FlagTmp);
	}else	pCmdUI->Enable(FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"PEN"			*/
/*						*/
/************************************************/
void
CMainFrame::OnPalettepen()
{
	pEditChild->SelectItem = PEN;
	pEditChild->WriteSelRectBitmap();
	pEditChild->MDIActivate();
}

/************************************************/
/*						*/
/*	COMMAND 	"PEN" (Update)		*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdatePalettepen(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen){
		pCmdUI->Enable( TRUE);
		if( pEditChild->SelectItem == PEN)
			pCmdUI->SetRadio( TRUE);
		else	pCmdUI->SetRadio( FALSE);
	}else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"BRUSh"			*/
/*						*/
/************************************************/
void
CMainFrame::OnPalettebrush()
{
	pEditChild->SelectItem = BRUSH;
	pEditChild->WriteSelRectBitmap();
	pEditChild->MDIActivate();
}

/************************************************/
/*						*/
/*	COMMAND 	"BRUSH" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdatePalettebrush(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen){
		pCmdUI->Enable( TRUE);
		if( pEditChild->SelectItem == BRUSH)
			pCmdUI->SetRadio( TRUE);
		else	pCmdUI->SetRadio( FALSE);
	}else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"STRAIGHT LINE"		*/
/*						*/
/************************************************/
void
CMainFrame::OnPaletteslope()
{
	pEditChild->SelectItem = SLOPE;
	pEditChild->WriteSelRectBitmap();
	pEditChild->MDIActivate();
}

/************************************************/
/*						*/
/*	COMMAND 	"STRAIGHT LINE"(Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdatePaletteslope(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen){
		pCmdUI->Enable( TRUE);
		if( pEditChild->SelectItem == SLOPE)
			pCmdUI->SetRadio( TRUE);
		else	pCmdUI->SetRadio( FALSE);
	}else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"RECTANGLE" 		*/
/*						*/
/************************************************/
void
CMainFrame::OnPaletterect()
{
	pEditChild->SelectItem = RECTBAND;
	pEditChild->WriteSelRectBitmap();
	pEditChild->MDIActivate();
}

/************************************************/
/*						*/
/*	COMMAND 	"RECTANGLE" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdatePaletterect(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen){
		pCmdUI->Enable( TRUE);
		if( pEditChild->SelectItem == RECTBAND)
			pCmdUI->SetRadio( TRUE);
		else	pCmdUI->SetRadio( FALSE);
	}else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"FILRECTANGLE" 		*/
/*						*/
/************************************************/
void
CMainFrame::OnPaletterectfill()
{
	pEditChild->SelectItem = RECTFILL;
	pEditChild->WriteSelRectBitmap();
	pEditChild->MDIActivate();
}

/************************************************/
/*						*/
/*	COMMAND 	"FILRECTANGLE" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdatePaletterectfill(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen){
		pCmdUI->Enable( TRUE);
		if( pEditChild->SelectItem == RECTFILL)
			pCmdUI->SetRadio( TRUE);
		else	pCmdUI->SetRadio( FALSE);
	}else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"CIRCLE" 		*/
/*						*/
/************************************************/
void
CMainFrame::OnPalettecircle()
{
	pEditChild->SelectItem = CIRCLE;
	pEditChild->WriteSelRectBitmap();
	pEditChild->MDIActivate();
}

/************************************************/
/*						*/
/*	COMMAND 	"CIRCLE" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdatePalettecircle(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen){
		pCmdUI->Enable( TRUE);
		if( pEditChild->SelectItem == CIRCLE)
			pCmdUI->SetRadio( TRUE);
		else	pCmdUI->SetRadio( FALSE);
	}else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"FILCIRCLE" 		*/
/*						*/
/************************************************/
void
CMainFrame::OnPalettecirclefill()
{
	pEditChild->SelectItem = CIRCLEFILL;
	pEditChild->WriteSelRectBitmap();
	pEditChild->MDIActivate();
}

/************************************************/
/*						*/
/*	COMMAND 	"FILCIRCLE" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdatePalettecirclefill(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen){
		pCmdUI->Enable( TRUE);
		if( pEditChild->SelectItem == CIRCLEFILL)
			pCmdUI->SetRadio( TRUE);
		else	pCmdUI->SetRadio( FALSE);
	}else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"FREEFORM" 		*/
/*						*/
/************************************************/
void
CMainFrame::OnPalettefreeform()
{
	pEditChild->SelectItem = FREEFORM;
	pRefrChild->SelectItems = FREEFORM;
	pEditChild->WriteSelRectBitmap();
	pEditChild->MDIActivate();
}

/************************************************/
/*						*/
/*	COMMAND 	"FREEFORM" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdatePalettefreeform(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen){
		pCmdUI->Enable( TRUE);
		if( pEditChild->SelectItem == FREEFORM)
			pCmdUI->SetRadio( TRUE);
		else	pCmdUI->SetRadio( FALSE);
	}else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"ERASER" 		*/
/*						*/
/************************************************/
void
CMainFrame::OnPaletteeraser()
{
	pEditChild->SelectItem = ERASER;
	pEditChild->WriteSelRectBitmap();
	pEditChild->MDIActivate();
}

/************************************************/
/*						*/
/*	COMMAND 	"ERASER" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdatePaletteeraser(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen){
		pCmdUI->Enable( TRUE);
		if( pEditChild->SelectItem == ERASER)
			pCmdUI->SetRadio( TRUE);
		else	pCmdUI->SetRadio( FALSE);
	}else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"RECTBAND" 		*/
/*						*/
/************************************************/
void
CMainFrame::OnPaletterectband()
{
	pEditChild->SelectItem = RECTCLIP;
	pRefrChild->SelectItems = RECTCLIP;
	pEditChild->WriteSelRectBitmap();
	pEditChild->MDIActivate();
}

/************************************************/
/*						*/
/*	COMMAND 	"RECTBAND"(Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdatePaletterectband(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen){
		pCmdUI->Enable( TRUE);
		if( pEditChild->SelectItem == RECTCLIP)
			pCmdUI->SetRadio( TRUE);
		else	pCmdUI->SetRadio( FALSE);
	}else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"FLIP/ROTATE"		*/
/*						*/
/************************************************/
void
CMainFrame::OnRotate()
{
CRotateDlg	dlg;

	if( CustomWndOpen){
		if( dlg.DoModal() == IDOK){
			pEditChild->FlipRotate( dlg.RadioItem);
		}
	}
}

/************************************************/
/*						*/
/*	COMMAND 	"FLIP/ROTATE" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateRotate(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen){
		pCmdUI->Enable(TRUE);
	}else	pCmdUI->Enable(FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"REFERRENCE"		*/
/*						*/
/************************************************/
void
CMainFrame::OnRefferfileNew()
{
	UINT	Result;

	if( !RefferWndVisible){
		if(( Result = SetReffCode( FALSE)) == IDOK){
			SetReffWndPos();
			pRefrChild->UpdateBitmap();
			pRefrChild->GridShow = pEditChild->GridShow;
			pRefrChild->ShowWindow(SW_SHOWNORMAL);
			pRefrChild->UpdateWindow();
			RefferWndVisible = TRUE;
			if( CustomWndOpen)
				SetEudcWndPos();
		}
	}else{
		if(( Result = SetReffCode( FALSE)) == IDOK){
			pRefrChild->UpdateBitmap();
		}
	}
}

/************************************************/
/*						*/
/*	COMMAND 	"REFERRENCE" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateRefferfileNew(
CCmdUI* pCmdUI)
{
	pCmdUI->Enable( CustomWndOpen);	
}

/************************************************/
/*						*/
/*	COMMAND 	"CLOSE REF"		*/
/*						*/
/************************************************/
void
CMainFrame::OnRefferClose()
{
	RefferWndVisible = FALSE;
	pRefrChild->ShowWindow( SW_HIDE);
	pRefrChild->UpdateWindow();
	SetEudcWndPos();
}

/************************************************/
/*						*/
/*	COMMAND 	"CLOSE REF"(Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateRefferClose(
CCmdUI* pCmdUI)
{
	pCmdUI->Enable(RefferWndVisible);	
}

/************************************************/
/*						*/
/*	COMMAND 	"HELP TOPICS"		*/
/*						*/
/************************************************/
void
CMainFrame::OnHelp()
{
	if( this->IsWindowEnabled())
    {
        // BUGBUG: work around for bug in HtmlHelp API (unicode version doesn't work)
		//::HtmlHelp (this->GetSafeHwnd(), ChmHelpPath, HH_DISPLAY_TOPIC,(DWORD)0);
        ::HtmlHelpA (::GetDesktopWindow(), "eudcedit.chm", HH_DISPLAY_TOPIC,(DWORD)0);
    }
}

/************************************************/
/*						*/
/*	if bitmap is dirty, output message	*/
/*						*/
/************************************************/
BOOL
CMainFrame::OutputSaveMessage()
{
	int	Result;

	Result = IDYES;
	if( pEditChild->GetBitmapDirty()){
		Result = OutputMessageBox( this->GetSafeHwnd(),
			IDS_MAINFRAMETITLE,
			IDS_SAVEORNOT, FALSE);
		if( Result == IDYES){
			AfxGetApp()->DoWaitCursor(1);
			if (!pEditChild->SaveEUDCCode(MB_OKCANCEL))
        Result = IDCANCEL;
			AfxGetApp()->DoWaitCursor(-1);
		}else if( Result == IDNO){
			pEditChild->SetBitmapDirty( FALSE);
		}
	}
	if( Result == IDCANCEL)
		return FALSE;
	else	return TRUE;
}

/************************************************/
/*						*/
/*	Create refferrence window		*/
/*						*/
/************************************************/
BOOL
CMainFrame::CreateReferWnd()
{
	ReffWndRect.SetRectEmpty();
	CalcReffWndRect();

	CRefrWnd *pReffWnd = new CRefrWnd;
	if( !pReffWnd->Create( TEXT("REFERWINDOW"),
	    WS_CHILD | WS_BORDER, ReffWndRect, this))
		return FALSE;
				
	pRefrChild = pReffWnd;
	RefferWndVisible = FALSE;

	return TRUE;
}

/************************************************/
/*						*/
/*	Change size of edit window		*/
/*						*/
/************************************************/
void
CMainFrame::SetEudcWndPos()
{
	CalcEudcWndRect();
	pEditChild->MoveWindow( EudcWndRect.left, EudcWndRect.top,
		EudcWndRect.Width(), EudcWndRect.Height(), TRUE);
}

/************************************************/
/*						*/
/*	Calcurate size of edit window		*/
/*						*/
/************************************************/
void
CMainFrame::CalcEudcWndRect()
{
	CRect	CalcRect;
	CSize	Frame;
	int	Twice;
	int	Remain;

    //
    // Try to determine the proper value of the Frame. Can be
    // different depending with Theme is used. The Luna Theme
    // take more prixel for the width of the frame.
    //
	CRect* FrameBefore = new CRect(0, 0, BITMAP_WIDTH, BITMAP_HEIGHT);
    CRect  FrameAfter;
    pEditChild->MoveWindow(FrameBefore, TRUE);
    pEditChild->GetClientRect(&FrameAfter);
    
	Frame.cx = FrameBefore->Width() - FrameAfter.Width();
	Frame.cy = FrameBefore->Height() - FrameAfter.Height();

	GetClientRect( &EudcWndRect);
	if( GuideBarVisible){
		m_wndGuideBar.GetWindowRect( &CalcRect);
		EudcWndRect.bottom -= CalcRect.Height();
	}
	if( ToolBarVisible){
		m_wndToolBar.GetWindowRect( &CalcRect);
		EudcWndRect.right -= CalcRect.Width();
	}

	if( RefferWndVisible)
		EudcWndRect.right = EudcWndRect.right /2;

	if( EudcWndRect.Width() < EudcWndRect.Height()){
		Twice  = EudcWndRect.Width() /BITMAP_WIDTH;
		Remain = EudcWndRect.Width() %BITMAP_WIDTH;
		if( Remain < Frame.cx )
			Twice -= 1;
		if( Twice <= 0)		Twice = 1;
		EudcWndRect.left   = 0;
		EudcWndRect.right  = EudcWndRect.left + BITMAP_WIDTH *Twice
				   + Frame.cx;
		EudcWndRect.bottom = BITMAP_HEIGHT*Twice + Frame.cy
				   + CAPTION_HEIGHT;
	}else{
		Twice  = EudcWndRect.Height() /BITMAP_HEIGHT;
		Remain = EudcWndRect.Height() %BITMAP_HEIGHT;
		if( Remain < CAPTION_HEIGHT + Frame.cy )
			Twice -= 1;
		if( Twice <= 0)		Twice = 1;
		EudcWndRect.left   = 0;
		EudcWndRect.right  = EudcWndRect.left + BITMAP_WIDTH *Twice
				   + Frame.cx;
		EudcWndRect.bottom = BITMAP_HEIGHT*Twice + Frame.cy + CAPTION_HEIGHT;
	}
}

/************************************************/
/*						*/
/*	Change size of referrence window	*/
/*						*/
/************************************************/
void
CMainFrame::SetReffWndPos()
{
 	CalcReffWndRect();
	pRefrChild->MoveWindow( ReffWndRect.left, ReffWndRect.top,
		 ReffWndRect.Width(), ReffWndRect.Height(), TRUE);
}

/************************************************/
/*						*/
/*	Calcurate size of referrence window	*/
/*						*/
/************************************************/
void
CMainFrame::CalcReffWndRect()
{
	CRect	CalcRect;
	CSize	Frame;
	int	Twice;
	int	Remain;

	Frame.cx = ( GetSystemMetrics( SM_CXFRAME)
		   - GetSystemMetrics( SM_CXBORDER)) * 2;
  	Frame.cy = ( GetSystemMetrics( SM_CYFRAME)
		   - GetSystemMetrics( SM_CYBORDER)) * 2;
	GetClientRect( &ReffWndRect);
	if( GuideBarVisible){
		m_wndGuideBar.GetWindowRect( &CalcRect);
		ReffWndRect.bottom -= CalcRect.Height();
	}
	if( ToolBarVisible){
		m_wndToolBar.GetWindowRect( &CalcRect);
		ReffWndRect.right -= CalcRect.Width();
	}

	ReffWndRect.left  = ReffWndRect.right /2;
	if( ReffWndRect.Width() < ReffWndRect.Height()){
		Twice  = ReffWndRect.Width() /BITMAP_WIDTH;
		Remain = ReffWndRect.Width() %BITMAP_WIDTH;
		if( Remain < Frame.cx + 4)
			Twice -= 1;
		if( Twice <= 0){/*
			if( RefferWndVisible){
				pRefrChild->ShowWindow( SW_HIDE);
				pRefrChild->UpdateWindow();
				RefferWndVisible = FALSE;
			}*/
		}
		ReffWndRect.right  = ReffWndRect.left + BITMAP_WIDTH*Twice
				   + Frame.cx;
		ReffWndRect.bottom = BITMAP_HEIGHT*Twice + Frame.cy
				   + CAPTION_HEIGHT;
	}else{
		Twice  = ReffWndRect.Height() /BITMAP_HEIGHT;
		Remain = ReffWndRect.Height() %BITMAP_HEIGHT;
		if( Remain < CAPTION_HEIGHT + Frame.cy + 4)
			Twice -= 1;
		if( Twice <= 0)		Twice = 1;
		ReffWndRect.right  = ReffWndRect.left + BITMAP_WIDTH*Twice
				   + Frame.cx;
		ReffWndRect.bottom = BITMAP_HEIGHT*Twice + Frame.cy
				   + CAPTION_HEIGHT;
	}
}

/************************************************/
/*						*/
/*	MESSAGE		"WM_SIZE"		*/
/*						*/
/************************************************/
void
CMainFrame::OnSize(
UINT 	nType,
int 	cx,
int 	cy)
{
	CMDIFrameWnd::OnSize(nType, cx, cy);
	if( RefferWndVisible){
		SetReffWndPos();
	}
	if( CustomWndOpen){
		SetEudcWndPos();
	}

	if( !ToolBarVisible){
		m_wndToolBar.Invalidate( FALSE);
		m_wndToolBar.UpdateWindow();
	}

}

/************************************************/
/*						*/
/*	MESSAGE	"WM_DESTROY"			*/
/*	Write "EUDCEDIT.INI"			*/
/*						*/
/************************************************/
void
CMainFrame::OnDestroy()
{
	TCHAR	ProfileBuf[BUFFERMAX];
	TCHAR	SelectName1[] = TEXT("WindowSize");
	TCHAR	SelectName2[] = TEXT("Bitmap");
	TCHAR	SelectName3[] = TEXT("Color");
	TCHAR	EntryName1[]  = TEXT("MainWindowSize");
	TCHAR	EntryName2[]  = TEXT("MinMaxFlag");
	TCHAR 	EntryName3[]  = TEXT("BitmapSize");
	TCHAR	EntryName4[]  = TEXT("Grid");
	TCHAR	EntryName5[]  = TEXT("Curve");
	TCHAR	EntryName6[]  = TEXT("Fitting");
	TCHAR 	EudcIniFile[] = TEXT("Eudcedit.ini");
	CRect	rect;
	short	MaxWndFlag;

 	if( IsZoomed())
		MaxWndFlag = 1;
	else	MaxWndFlag = 0;

	wsprintf( ProfileBuf,TEXT("%d %d %d"), GetRValue(COLOR_GRID),
		GetGValue(COLOR_GRID), GetBValue(COLOR_GRID));
	::WritePrivateProfileString( SelectName3, EntryName4,
		ProfileBuf, EudcIniFile);
						
	wsprintf( ProfileBuf,TEXT("%d %d %d"), GetRValue(COLOR_CURVE),
		GetGValue(COLOR_CURVE), GetBValue(COLOR_CURVE));
	::WritePrivateProfileString( SelectName3, EntryName5,
		ProfileBuf, EudcIniFile);

	wsprintf( ProfileBuf,TEXT("%d %d %d"), GetRValue(COLOR_FITTING),
		GetGValue(COLOR_FITTING), GetBValue(COLOR_FITTING));
	::WritePrivateProfileString( SelectName3, EntryName6,
		ProfileBuf, EudcIniFile);

	wsprintf( ProfileBuf, TEXT("%d"), BITMAP_WIDTH);
	::WritePrivateProfileString( SelectName2, EntryName3,
		ProfileBuf, EudcIniFile);

	wsprintf( ProfileBuf, TEXT("%d"), MaxWndFlag);
	::WritePrivateProfileString( SelectName1, EntryName2,
		ProfileBuf, EudcIniFile);

	if( !MaxWndFlag && !IsIconic()){	
		GetWindowRect( &rect);
		wsprintf( ProfileBuf, TEXT("%d %d %d %d"), rect.left, rect.top,
			rect.right, rect.bottom);

		::WritePrivateProfileString( SelectName1, EntryName1,
			ProfileBuf, EudcIniFile);
	}
	CMDIFrameWnd::OnDestroy();
}

/************************************************/
/*						*/
/*	MESSAGE		"WM_CLOSE"		*/
/*						*/
/************************************************/
void
CMainFrame::OnClose()
{
	CString	MsgTitle;
	CString Msg;
	int	result;

	if( CustomWndOpen){
		if(( pEditChild->GetBitmapDirty()) &&
		   ( InqTypeFace((TCHAR *)SelectEUDC.m_Font,
		   (TCHAR *)SelectEUDC.m_File, sizeof( SelectEUDC.m_File)/sizeof(TCHAR)))){
			MsgTitle.LoadString( IDS_MAINFRAMETITLE);
			Msg.LoadString( IDS_SAVEORNOT);
			result = MessageBox( Msg, MsgTitle,
					 MB_ICONQUESTION | MB_YESNOCANCEL);
			if( result == IDYES){
				AfxGetApp()->DoWaitCursor(1);
				if (!pEditChild->SaveEUDCCode(MB_OKCANCEL))
          result = IDCANCEL;
				AfxGetApp()->DoWaitCursor(-1);
			}
			if( result == IDCANCEL)
				return;
		}
	}		
	CMDIFrameWnd::OnClose();
}

/************************************************/
/*						*/
/*	MESSAGE		"WM_INITMENU"		*/
/*						*/
/************************************************/
void
CMainFrame::OnInitMenu(
CMenu* 	pMenu)
{
	CMDIFrameWnd::OnInitMenu(pMenu);

	if( CountryInfo.LangID != EUDC_CHT &&
	    CountryInfo.LangID != EUDC_CHS ){
		pMenu->DeleteMenu( ID_LINKIME, MF_BYCOMMAND);
		pMenu->DeleteMenu( ID_LINKBATCHMODE, MF_BYCOMMAND);
		if (CountryInfo.LangID != EUDC_JPN)
			pMenu->DeleteMenu( ID_IMPORT_FILE, MF_BYCOMMAND);
		this->DrawMenuBar();
	}
}

/************************************************/
/*						*/
/*	Correct it if code is illegal range	*/
/*						*/
/************************************************/
WORD
CMainFrame::CorrectCode(
WORD 	Code,
BOOL 	UporDown)
{
COUNTRYINFO	Info;
	WORD	wCode;
	BYTE 	LByte, HByte;
	int	TralPos = 0;

	LByte = LOBYTE( Code);
	HByte = HIBYTE( Code);
	Info = CountryInfo;
	for( int i = 0; i < Info.nTralByte; i++){
		if( LByte >= (Info.sTralByte[i]) &&
		    LByte <= (Info.eTralByte[i])){
		    	goto RET;
		}else if( LByte < (Info.sTralByte[i])){
			TralPos = i;
			break;
		}else	TralPos = i+1;
	}
	if( UporDown)
		if( TralPos == Info.nTralByte){
			LByte = (Info.sTralByte[0]);
			HByte += 0x1;
		}else 	LByte = (Info.sTralByte[TralPos]);
	else{
		if( !TralPos){
			LByte = (Info.eTralByte[Info.nTralByte-1]);
			HByte -= 0x1;
		}else	LByte = (Info.eTralByte[TralPos-1]);
	}
RET:
	wCode = MAKEWORD( LByte, HByte);
	return wCode;
}

/************************************************/
/*						*/
/*	Set Reference dialog			*/
/*						*/
/************************************************/
UINT
CMainFrame::SetReffCode( BOOL EditorRefer)
{
CRefrDlg	dlg;
	UINT	Result;

	TitleFlag = EditorRefer;
	if(( Result = (UINT)dlg.DoModal()) == IDOK){
		if( !EditorRefer){
			if( dlg.m_CodeList.SelectCode){
				pRefrChild->ReferCode =
					dlg.m_CodeList.SelectCode;
			}else	pRefrChild->ReferCode = 0;
		}else{
			if( dlg.m_CodeList.SelectCode)
				pEditChild->CallCode =
					dlg.m_CodeList.SelectCode;
			else	pEditChild->CallCode = 0;
		}
	}else{
		if( !EditorRefer)
			pRefrChild->ReferCode = 0;
		else 	pEditChild->CallCode = 0;
	}

	return Result;
}

/************************************************/
/*						*/
/*	Window procedure			*/
/*						*/
/************************************************/
LRESULT
CMainFrame::WindowProc(
UINT 	message,
WPARAM 	wParam,
LPARAM 	lParam)
{
	CRect	WorkRect;
	CRect	rect;
	CRect	Dummy;
	RECT	*Rect;
	POINT	*Point;
	int	Zm;

	if( message == WM_DUPLICATE){
		Zm = pEditChild->ZoomRate;
		pEditChild->GetClientRect( &WorkRect);
		pEditChild->ClientToScreen( &WorkRect);
		Point = (LPPOINT)lParam;
		Rect  = (LPRECT)wParam;
		pEditChild->ScreenToClient( Point);

		Rect->left = ((Point->x - Rect->left) /Zm) *Zm;
		Rect->top  = ((Point->y - Rect->top - CAPTION_HEIGHT)
				/Zm) *Zm + CAPTION_HEIGHT;
		Rect->right  = Rect->left + Rect->right;
		Rect->bottom = Rect->top  + Rect->bottom;

		pEditChild->ClientToScreen( Rect);
		if( Dummy.IntersectRect( &WorkRect, Rect)){
			if( Dummy.EqualRect( Rect)){
				pEditChild->ScreenToClient( Rect);
				pEditChild->SetDuplicateRect( Rect, Point);
			}else{
				int	Tmp;

				rect.SetRect( Rect->left, Rect->top,
						Rect->right, Rect->bottom);
				if( rect.left < WorkRect.left){
					Tmp = WorkRect.left - rect.left;
					rect.OffsetRect( Tmp, 0);
				}
				if( rect.top < WorkRect.top + CAPTION_HEIGHT){
					Tmp = WorkRect.top + CAPTION_HEIGHT
						- rect.top;
					rect.OffsetRect( 0, Tmp);
				}
				if( rect.right > WorkRect.right){
					Tmp = WorkRect.right - rect.right + 1;
					rect.OffsetRect( Tmp, 0);
				}
				if( rect.bottom > WorkRect.bottom){
					Tmp = WorkRect.bottom - rect.bottom + 1;
					rect.OffsetRect( 0, Tmp);
				}
				pEditChild->ScreenToClient( &rect);
				pEditChild->SetDuplicateRect( &rect, Point);
			}
			pRefrChild->RectVisible = FALSE;
			pEditChild->MDIActivate();
			if( pRefrChild->SelectItems == FREEFORM)
				pEditChild->SelectItem = FREEFORM;
			else	pEditChild->SelectItem = RECTCLIP;
		}else{
			pRefrChild->Invalidate( FALSE);
			pRefrChild->UpdateWindow();
		}
		return (0L);
	}else 	return CFrameWnd::WindowProc( message, wParam, lParam);
}

/************************************************/
/*						*/
/*	Activate Edit Window			*/
/*						*/
/************************************************/
BOOL CMainFrame::CustomActivate()
{
	pEditChild->MDIActivate();
	return TRUE;
}

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CMDIFrameWnd::AssertValid();
}
void CMainFrame::Dump(CDumpContext& dc) const
{
	CMDIFrameWnd::Dump(dc);
}
#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\refrdlg.cpp ===
/**************************************************/
/*					                              */
/*					                              */
/*	Reference other characters	                  */
/*		(Dialog)		                          */
/*					                              */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include 	"stdafx.h"
#include 	"eudcedit.h"
#include 	"refrdlg.h"
#include	"util.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BOOL	CodeFocus;
BOOL	CharFocus;
BOOL	CompFinalized;
CHOOSEFONT	chf;
extern 	LOGFONT	ReffLogFont;
extern 	LOGFONT	EditLogFont;
extern 	BOOL	TitleFlag;
static 	BOOL 	CALLBACK ComDlg32DlgProc(HWND hDlg, UINT uMsg,
		WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK EditCharProc( HWND  hwnd, UINT  uMsg,
                                     WPARAM wParam, LPARAM  lParam);
HIMC hImcCode = NULL;

BEGIN_MESSAGE_MAP(CRefrDlg, CDialog)
	//{{AFX_MSG_MAP(CRefrDlg)
	ON_BN_CLICKED(IDC_BUTTOMFONT, OnClickedButtomfont)
	ON_EN_CHANGE(IDC_EDITCODE, OnChangeEditcode)
	ON_EN_SETFOCUS(IDC_EDITCODE, OnSetfocusEditcode)
	ON_EN_KILLFOCUS(IDC_EDITCODE, OnKillfocusEditcode)
	ON_EN_SETFOCUS(IDC_EDITCHAR, OnSetfocusEditchar)
	ON_EN_KILLFOCUS(IDC_EDITCHAR, OnKillfocusEditchar)
	ON_EN_CHANGE(IDC_EDITCHAR, OnChangeEditchar)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


LRESULT CALLBACK EditCharProc( HWND  hwnd, UINT  uMsg,
                               WPARAM wParam, LPARAM  lParam)
{
    switch (uMsg)
    {
        case WM_CHAR:
        {
        	//
	        // We always delete whatever in edit window before
	        // proceeding to avoid multiple characters in the
	        // window
	        //
		SetWindowText(hwnd, TEXT(""));
        	CompFinalized = TRUE;
            break;
        }
        case WM_IME_COMPOSITION:
        {
            if (lParam & CS_INSERTCHAR)
            {
                // This is KOR ime only.  We want to clear the edit
                // window when the first and only the first composition
                // char is entered.
                //

                if (CompFinalized)
                {
                    SetWindowText(hwnd, TEXT(""));
                }
        	    CompFinalized = FALSE;
            }
            break;
        }

	}

	return(AfxWndProc(hwnd, uMsg, wParam, lParam));
}

/****************************************/
/*					*/
/*	Default Constructor		*/
/*					*/
/****************************************/
CRefrDlg::CRefrDlg( CWnd* pParent)
	: CDialog(CRefrDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CRefrDlg)
	//}}AFX_DATA_INIT
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_INITDIALOG"		*/
/*					*/
/****************************************/
BOOL
CRefrDlg::OnInitDialog()
{
	CString	DialogTitle;
	LOGFONT	LogFont;
	CWnd	*ViewWnd;
	CRect	CharViewRect;
	HWND 	hWndCode;
	HWND    hWndChar;

	CDialog::OnInitDialog();

//	Implement "?" in this dialog.
	LONG WindowStyle = GetWindowLong( this->GetSafeHwnd(), GWL_EXSTYLE);
	WindowStyle |= WS_EX_CONTEXTHELP;
	SetWindowLong( this->GetSafeHwnd(), GWL_EXSTYLE, WindowStyle);

//	Set Dialog title name.
	if( !TitleFlag)
		DialogTitle.LoadString( IDS_REFERENCE_DLGTITLE);
	else	DialogTitle.LoadString( IDS_CALL_DLGTITLE);
	this->SetWindowText( DialogTitle);

//	Subclass Dialog Control Item
	m_CodeList.SubclassDlgItem( ID_REFERCODE, this);
	m_RefListFrame1.SubclassDlgItem( IDC_LISTFRAME1, this);
	m_RefInfoFrame.SubclassDlgItem(  IDC_INFOFRAME, this);
	m_ColumnHeadingR.SubclassDlgItem( IDC_COLUMNHEADINGR, this);
	m_EditChar.SubclassDlgItem( IDC_EDITCHAR, this);
	hWndChar = this->GetDlgItem(IDC_EDITCHAR)->GetSafeHwnd();
	if (GetWindowLongPtr(hWndChar, GWLP_WNDPROC) == (LONG_PTR)AfxWndProc)
	{
		SetWindowLongPtr(hWndChar, GWLP_WNDPROC, (LONG_PTR)EditCharProc);
	}
	hWndCode = GetDlgItem(IDC_EDITCODE)->GetSafeHwnd();
	if (hWndCode && ::IsWindow(hWndCode))
	{
		hImcCode = ImmAssociateContext(hWndCode, NULL);
	}

	GetFont()->GetObject( sizeof(LOGFONT), &LogFont);
	m_CodeList.SysFFont.CreateFontIndirect( &LogFont);
	m_CodeList.CalcCharSize();
	m_CodeList.SendMessage( WM_SETFONT,
		(WPARAM)m_CodeList.SysFFont.GetSafeHandle(),
		MAKELPARAM( TRUE, 0));
	m_ColumnHeadingR.SysFFont.CreateFontIndirect( &LogFont);
	ViewWnd = this->GetDlgItem( IDC_EDITCHAR);
	ViewWnd->GetClientRect( &CharViewRect);
	if( CharViewRect.Width() >= CharViewRect.Height())
		vHeight = CharViewRect.Height() - 10;
	else	vHeight = CharViewRect.Width()  - 10;

	if( !TitleFlag){
		memcpy( &m_CodeList.rLogFont, &ReffLogFont, sizeof( LOGFONT));
		m_CodeList.rLogFont.lfHeight = vHeight;
		m_CodeList.ViewFont.CreateFontIndirect( &m_CodeList.rLogFont);
		
		if( m_CodeList.CharSize.cx >= m_CodeList.CharSize.cy)
			m_CodeList.rLogFont.lfHeight = m_CodeList.CharSize.cy-2;
		else	m_CodeList.rLogFont.lfHeight = m_CodeList.CharSize.cx-2;
		m_CodeList.CharFont.CreateFontIndirect( &m_CodeList.rLogFont);

		lstrcpy( (TCHAR *)FontName,
			(const TCHAR *)m_CodeList.rLogFont.lfFaceName);
		AdjustFontName();
		this->SetDlgItemText( IDC_EDITFONT, (LPTSTR)FontName);
	}else{
		memcpy( &m_CodeList.cLogFont, &EditLogFont, sizeof( LOGFONT));
		m_CodeList.cLogFont.lfHeight = vHeight;
		m_CodeList.ViewFont.CreateFontIndirect( &m_CodeList.cLogFont);

		if( m_CodeList.CharSize.cx >= m_CodeList.CharSize.cy)
			m_CodeList.cLogFont.lfHeight = m_CodeList.CharSize.cy-2;
		else	m_CodeList.cLogFont.lfHeight = m_CodeList.CharSize.cx-2;
		m_CodeList.CharFont.CreateFontIndirect( &m_CodeList.cLogFont);

		lstrcpy( (TCHAR *)FontName,
			(const TCHAR *)m_CodeList.cLogFont.lfFaceName);
		AdjustFontName();
		this->SetDlgItemText( IDC_EDITFONT, (LPTSTR)FontName);
	}
	m_CodeList.SetCodeRange();
	SetViewFont();
	m_CodeList.EnableScrollBar(SB_VERT, ESB_ENABLE_BOTH);
	m_CodeList.Invalidate( FALSE);
	m_CodeList.UpdateWindow();

	CodeFocus = FALSE;
	CharFocus = FALSE;
	CompFinalized=TRUE;
	this->SendDlgItemMessage(IDC_EDITCODE, EM_LIMITTEXT,
		(WPARAM)4, (LPARAM)0);
	this->SendDlgItemMessage(IDC_EDITCHAR, EM_LIMITTEXT,
		(WPARAM)1, (LPARAM)0);

	return TRUE;
}
void
CRefrDlg::OnDestroy()
{
	if (hImcCode)
	{
		HWND 	hWndCode;
		hWndCode = GetDlgItem(IDC_EDITCODE)->GetSafeHwnd();
		if (hWndCode && ::IsWindow(hWndCode))
		{
			ImmAssociateContext(hWndCode, hImcCode);
			hImcCode = NULL;
		}
	}
}

/****************************************/
/*					*/
/*	Set font on ViewEdit		*/
/*					*/
/****************************************/
void
CRefrDlg::SetViewFont()
{
	HWND	hWnd;

	hWnd = ::GetDlgItem( this->GetSafeHwnd(), IDC_EDITCHAR);
	::SendMessage( hWnd, WM_SETFONT,
		(WPARAM)m_CodeList.ViewFont.m_hObject, MAKELPARAM(TRUE,0));
}

/****************************************/
/*					*/
/*	COMMAND	"FONT"			*/
/*					*/
/****************************************/
void
CRefrDlg::OnClickedButtomfont()
{
	HDC hDC;

	hDC = ::GetDC( this->GetSafeHwnd());
	chf.hDC = ::CreateCompatibleDC( hDC);
	::ReleaseDC( this->GetSafeHwnd(), hDC);
	if( !TitleFlag){
		m_CodeList.rLogFont.lfHeight = 40;
		chf.lpLogFont = &m_CodeList.rLogFont;
	}else{
		m_CodeList.cLogFont.lfHeight = 40;
		chf.lpLogFont = &m_CodeList.cLogFont;
	}
	chf.lStructSize = sizeof(CHOOSEFONT);
	chf.hwndOwner = this->GetSafeHwnd();
	chf.rgbColors = GetSysColor(COLOR_WINDOWTEXT); //COLOR_BLACK;
	chf.lCustData = 0;
	chf.hInstance = AfxGetInstanceHandle();
	chf.lpszStyle = (LPTSTR)NULL;
	chf.nFontType = SCREEN_FONTTYPE;
	chf.lpfnHook = (LPCFHOOKPROC)(FARPROC)ComDlg32DlgProc;
	chf.lpTemplateName = (LPTSTR)MAKEINTRESOURCE(FORMATDLGORD31);
	chf.Flags = CF_SCREENFONTS | CF_NOSIMULATIONS | CF_ENABLEHOOK |
     			CF_ENABLETEMPLATE | CF_INITTOLOGFONTSTRUCT;

	if( ChooseFont( &chf ) == FALSE){
		::DeleteDC( chf.hDC);
        	return ;
   	}
	::DeleteDC( chf.hDC);
	m_CodeList.SetCodeRange();
	m_CodeList.ResetParam();
	this->SetDlgItemText( IDC_EDITCODE, TEXT(""));
	this->SetDlgItemText( IDC_EDITCHAR, TEXT(""));

	m_CodeList.CharFont.DeleteObject();
	m_CodeList.ViewFont.DeleteObject();
	if( !TitleFlag){
		lstrcpy( (TCHAR *)FontName,
			(const TCHAR *)m_CodeList.rLogFont.lfFaceName);
		AdjustFontName();
		this->SetDlgItemText( IDC_EDITFONT, FontName);

		m_CodeList.rLogFont.lfHeight  = vHeight;
		m_CodeList.rLogFont.lfQuality = PROOF_QUALITY;
		m_CodeList.ViewFont.CreateFontIndirect( &m_CodeList.rLogFont);

		if( m_CodeList.CharSize.cx >= m_CodeList.CharSize.cy)
			m_CodeList.rLogFont.lfHeight = m_CodeList.CharSize.cy-2;
		else	m_CodeList.rLogFont.lfHeight = m_CodeList.CharSize.cx-2;
		m_CodeList.CharFont.CreateFontIndirect( &m_CodeList.rLogFont);
	}else{
		lstrcpy(FontName,
			(const TCHAR *)m_CodeList.cLogFont.lfFaceName);
		AdjustFontName();
		this->SetDlgItemText( IDC_EDITFONT, FontName);

		m_CodeList.cLogFont.lfHeight = vHeight;
		m_CodeList.cLogFont.lfQuality = PROOF_QUALITY;
		m_CodeList.ViewFont.CreateFontIndirect( &m_CodeList.cLogFont);

		if( m_CodeList.CharSize.cx >= m_CodeList.CharSize.cy)
			m_CodeList.cLogFont.lfHeight = m_CodeList.CharSize.cy-2;
		else	m_CodeList.cLogFont.lfHeight = m_CodeList.CharSize.cx-2;
		m_CodeList.CharFont.CreateFontIndirect( &m_CodeList.cLogFont);
	}
	SetViewFont();
	m_CodeList.Invalidate( TRUE);
	m_CodeList.UpdateWindow();

	CWnd *cWnd = GetDlgItem( ID_REFERCODE);
	GotoDlgCtrl( cWnd);

   	return;
}

/****************************************/
/*					*/
/*	Adjust Font Name		*/
/*					*/
/****************************************/
void
CRefrDlg::AdjustFontName()
{
CClientDC	dc(this);
	CRect	ViewFontRect;
	CSize	FontNameSize, CharSize;
	int	i;

	CWnd *cWnd = GetDlgItem( IDC_EDITFONT);
	cWnd->GetClientRect( &ViewFontRect);

	GetTextExtentPoint32( dc.GetSafeHdc(), (const TCHAR *)FontName,
		lstrlen((const TCHAR *)FontName), &FontNameSize);

	if( ViewFontRect.Width() <= FontNameSize.cx){
		GetTextExtentPoint32( dc.GetSafeHdc(), TEXT("<<"), 2, &CharSize);
		i = ( ViewFontRect.Width() /CharSize.cx) * 2;
		FontName[i-2] = '.';
		FontName[i-1] = '.';
		FontName[i] = '\0';
	}	
}

/****************************************/
/*					*/
/*	jump Reference code		*/	
/*					*/
/****************************************/
void CRefrDlg::JumpReferCode()
{
	if( !m_CodeList.CodeButtonClicked())
	{
		if (CharFocus && !CompFinalized)
		{
			//
			// We want to cancel ime composition with wParam = 0, lParam
			// contains CS_INSERTCHAR.
			//
			this->SendDlgItemMessage(IDC_EDITCHAR,
                                     WM_IME_COMPOSITION,
                                     0,
                                     CS_INSERTCHAR | CS_NOMOVECARET |
                                     GCS_COMPSTR | GCS_COMPATTR);
		}
		OutputMessageBox( this->GetSafeHwnd(),
			IDS_ILLEGALCODE_TITLE,
			IDS_ILLEGALCODE_MSG, TRUE);

	}else{

		if (CharFocus)
		{
		//
		// We don't want to highlight an interim KOR IME composition.
		//
			if (CompFinalized)
			{
				this->SendDlgItemMessage(IDC_EDITCHAR, EM_SETSEL, 0, -1);
			}
		}
		else
		{
			this->SendDlgItemMessage(IDC_EDITCODE, EM_SETSEL, 0, -1);
		}
	}
}

/****************************************/
/*					*/
/*	COMMAND "IDOK"			*/
/*					*/
/****************************************/
void
CRefrDlg::OnOK()
{
	if( !m_CodeList.SelectCode){
		OutputMessageBox( this->GetSafeHwnd(),
			IDS_REFERENCE_DLGTITLE,
			IDS_NOTSELCHARACTER_MSG, TRUE);
		return;
	}
	if( !TitleFlag){
		memcpy( &ReffLogFont, &m_CodeList.rLogFont, sizeof( LOGFONT));
	}else{
		memcpy( &EditLogFont, &m_CodeList.cLogFont, sizeof( LOGFONT));
	}
	CDialog::OnOK();
}

/****************************************/
/*					*/
/*	COMMAND "IDCANCEL"		*/
/*					*/
/****************************************/
void
CRefrDlg::OnCancel()
{
 	m_CodeList.SelectCode = 0;		

	CDialog::OnCancel();
}

/****************************************/
/*					*/
/*	MESSAGE "EM_CHANGE"		*/
/*					*/
/****************************************/
void CRefrDlg::OnChangeEditcode()
{
	TCHAR	EditCode[5];
	int i;

	EditCode[0] = '\0';
	this->GetDlgItemText(IDC_EDITCODE, EditCode, sizeof(EditCode)/sizeof(TCHAR));
	
	for (i=0; i<lstrlen(EditCode); i++)
	{
		if ( EditCode[i] <  TEXT('0') ||
		     (EditCode[i] > TEXT('9') && EditCode[i] < TEXT('A')) ||
		     (EditCode[i] > TEXT('F') && EditCode[i] < TEXT('a')) ||
		     EditCode[i] > TEXT('f'))
		{
			OutputMessageBox( this->GetSafeHwnd(),
								IDS_ILLEGALCODE_TITLE,
								IDS_ILLEGALCODE_MSG, TRUE);
			this->SendDlgItemMessage(IDC_EDITCODE, EM_SETSEL, 0, -1);
			return;
		}
	}
		
	if( lstrlen( EditCode) == 4 && CodeFocus)
	{
		JumpReferCode();
	}
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_SETFOCUS"		*/
/*					*/
/****************************************/
void
CRefrDlg::OnSetfocusEditcode()
{
	this->SendDlgItemMessage(IDC_EDITCODE, EM_SETSEL, 0, -1);
	CodeFocus = TRUE;
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_KILLFOCUS"		*/
/*					*/
/****************************************/
void
CRefrDlg::OnKillfocusEditcode()
{
	CodeFocus = FALSE;
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_SETFOCUS"		*/
/*					*/
/****************************************/
void
CRefrDlg::OnSetfocusEditchar()
{
	if (CompFinalized)
	{
	    this->SendDlgItemMessage( IDC_EDITCHAR, EM_SETSEL, 0, -1);
	}
	CharFocus = TRUE;
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_KILLFOCUS"		*/
/*					*/
/****************************************/
void
CRefrDlg::OnKillfocusEditchar()
{
	CharFocus = FALSE;
}

/****************************************/
/*					*/
/*	MESSAGE	"EM_CHANGE"		*/
/*					*/
/****************************************/
void
CRefrDlg::OnChangeEditchar()
{
	WCHAR	EditChar[5] = {0};

	EditChar[0]=TEXT('\0');
#ifdef UNICODE
  ::GetDlgItemTextW(this->GetSafeHwnd(),IDC_EDITCHAR, (LPWSTR)EditChar, sizeof(EditChar)/sizeof(WCHAR));
#else
  CHAR eChar[4];
  int nchar = ::GetDlgItemText(this->GetSafeHwnd(),IDC_EDITCHAR, (LPSTR)eChar, sizeof(eChar));
  MultiByteToWideChar(CP_ACP, 0, eChar, nchar, EditChar, sizeof(EditChar)/sizeof(EditChar[0]));
#endif

	if( CharFocus && EditChar[0] != TEXT('\0') )
	{
		int iPos = 1;
/*
#ifndef UNICODE
		if (IsDBCSLeadByte(EditChar[0]))
		{
			iPos = 2;
		}
#endif
*/
		EditChar[iPos]=TEXT('\0');
		JumpReferCode();
	}
}

/****************************************/
/*					*/
/*	Callback function		*/
/*					*/
/****************************************/
static BOOL CALLBACK
ComDlg32DlgProc(
HWND 	hDlg,
UINT 	uMsg,
WPARAM 	wParam,
LPARAM 	lParam)
{
	switch (uMsg)
	{
		case WM_INITDIALOG:
 			long	WindowStyle;

			WindowStyle = GetWindowLong( hDlg, GWL_EXSTYLE);
			WindowStyle |= WS_EX_CONTEXTHELP;
			SetWindowLong( hDlg, GWL_EXSTYLE, WindowStyle);
			break;

		default:
			return FALSE;
	}
	return TRUE;
}

static DWORD aIds[] =
{
	ID_REFERCODE,	IDH_EUDC_REFLIST,
	IDC_COLUMNHEADINGR,	IDH_EUDC_REFLIST,
	IDC_STATICC,	IDH_EUDC_REFCODE,
	IDC_EDITCODE,	IDH_EUDC_REFCODE,
	IDC_STATICS,	IDH_EUDC_REFCHAR,
	IDC_EDITCHAR, 	IDH_EUDC_REFCHAR,
	IDC_STATICF,	IDH_EUDC_REFFONT,
	IDC_EDITFONT,	IDH_EUDC_REFFONT,
	IDC_INFOFRAME,	IDH_EUDC_REFFONT,
	IDC_BUTTOMFONT,	IDH_EUDC_FONT,
//	IDOK, IDH_EUDC_OK,
//	IDCANCEL, IDH_EUDC_CANCEL,
	0,0
};

static DWORD aIdsCall[] =
{
	ID_REFERCODE,	IDH_EUDC_CALLLIST,
	IDC_COLUMNHEADINGR,	IDH_EUDC_CALLLIST,
	IDC_STATICC,	IDH_EUDC_CALLCODE,
	IDC_EDITCODE,	IDH_EUDC_CALLCODE,
	IDC_STATICS,	IDH_EUDC_CALLCHAR,
	IDC_EDITCHAR, 	IDH_EUDC_CALLCHAR,
	IDC_STATICF,	IDH_EUDC_CALLFONT,
	IDC_EDITFONT,	IDH_EUDC_CALLFONT,
	IDC_INFOFRAME,	IDH_EUDC_CALLFONT,
	IDC_BUTTOMFONT,	IDH_EUDC_FONT,
//	IDOK, IDH_EUDC_OK,
//	IDCANCEL, IDH_EUDC_CANCEL,
	0,0
};

/****************************************/
/*					*/
/*	Window procedure		*/
/*					*/
/****************************************/
LRESULT
CRefrDlg::WindowProc(
UINT 	message,
WPARAM 	wParam,
LPARAM 	lParam)
{
	if( message == WM_HELP){
		::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
			HelpPath, HELP_WM_HELP, (DWORD_PTR)(LPTSTR)(TitleFlag ? aIdsCall:aIds));
		return(0);
	}
	if( message == WM_CONTEXTMENU){
		::WinHelp((HWND)wParam, HelpPath,
			HELP_CONTEXTMENU, (DWORD_PTR)(LPTSTR)(TitleFlag ? aIdsCall : aIds));
		return(0);
	}
	return CDialog::WindowProc( message, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\makepoly.cpp ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//

#include	"stdafx.h"


#include	"vdata.h"

#define		UNDERFP	0
#define		NMAX	129

int	MkPoly(	int inlst, int outLst);
static int DDACon(struct vecdata *s,struct vecdata *cp,struct vecdata *e,int lstHdl);
static int  fsqrt(int  n);
/***********************************************************************
 *	Make Poly line
 */
/* */	int
/* */	MkPoly(
/* */		int	inLst,
/* */		int	outLst)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
struct VHEAD	*vhd;
	int	pcnt,
		sts;
struct VDATA	*vp;

	if ( (sts = VDGetHead( inLst, &vhd))!=0)
		goto	RET;
	VDNew( outLst);
	while ( vhd->next != NIL) {
		vp = vhd->headp;
		pcnt = vhd->nPoints;
		while ( pcnt >0) {
			if ( vp->next->vd.atr &1) {
				sts = DDACon( &vp->vd, &vp->next->vd,
					&vp->next->next->vd, outLst);
				if ( sts)
					goto	RET;
				vp = vp->next;
				pcnt--;
				if ( pcnt>0) {
					vp = vp->next;
					pcnt--;
				}
			}
			else {
				if ( (sts = VDSetData( outLst, &vp->vd))<0)
					goto	RET;
				vp = vp->next;
				pcnt--;
			}
		}
		vhd = vhd->next;
		if ( (sts = VDClose( outLst))<0)
			goto	RET;
	}
RET:
	return( sts);
}


static int	lowsqr[NMAX] = {
			   1,   2,   2,   3,   3,
			   4,   4,   4,   4,   5,
			   5,   5,   5,   6,   6,
			   6,   6,   6,   6,   7,

			   7,   7,   7,   7,   7,
			   8,   8,   8,   8,   8,
			   8,   8,   8,   9,   9,
			   9,   9,   9,   9,   9,

			   9,  10,  10,  10,  10,
			  10,  10,  10,  10,  10,
			  10,  11,  11,  11,  11,
			  11,  11,  11,  11,  11,

			  11,  12,  12,  12,  12,
			  12,  12,  12,  12,  12,
			  12,  12,  12,  13,  13,
			  13,  13,  13,  13,  13,

			  13,  13,  13,  13,  13,
			  14,  14,  14,  14,  14,
			  14,  14,  14,  14,  14,
			  14,  14,  14,  14,  15,

			  15,  15,  15,  15,  15,
			  15,  15,  15,  15,  15,
			  15,  15,  15,  16,  16,
			  16,  16,  16,  16,  16,

			  16,  16,  16,  16,  16,
			  16,  16,  16,  16,
			   };

static int	sqrtbl[NMAX] = {
			    1,    4,    9,   16,   25,
			   36,   49,   64,   81,  100,
			  121,  144,  169,  196,  225,
			  256,  289,  324,  361,  400,
			  441,  484,  529,  576,  625,
			  676,  729,  784,  841,  900,
			  961, 1024, 1089, 1156, 1225,
			 1296, 1369, 1444, 1521, 1600,
			 1681, 1764, 1849, 1936, 2025,
			 2116, 2209, 2304, 2401, 2500,
			 2601, 2704, 2809, 2916, 3025,
			 3136, 3249, 3364, 3481, 3600,
			 3721, 3844, 3969, 4096, 4225,
			 4356, 4489, 4624, 4761, 4900,
			 5041, 5181, 5329, 5476, 5625, 
			 5776, 5929, 6084, 6241, 6400,
			 6561, 6724, 6889, 7056, 7225,
			 7396, 7569, 7744, 7921, 8100,
			 8281, 8464, 8649, 8836, 9025,
			 9216, 9409, 9604, 9801, 10000,
			 10201, 10404, 10609, 10816, 11025,
			 11236, 11449, 11664, 11881, 12100,
			 12321, 12544, 12769, 12996, 13225,
			 13456, 13689, 13924, 14161, 14400,
			 14641, 14884, 15129, 15376, 15625,
			 15876, 16129, 16384, 16641 
			 };

/************************************************************
 *	DDA Poly line generate
 */
/* */	static int
/* */	DDACon(
/* */		struct vecdata	*s,
/* */		struct vecdata	*cp,
/* */		struct vecdata	*e,
/* */			int	lstHdl)
/*
 *	returns :  0, -1
 ************************************************************/
{
	int	n2xmax, n2ymax, n2max;
	int	i, n;
	long	f1x,		/* for f1@ */
		fx,		/* for F(i) */
		px,		/* for G(i) */
		g1x, g2x;
	long	f1y,		/* for f1@ */
		fy,		/* for F(i) */
		py,		/* for G(i) */
		g1y, g2y;
	int	sts, num;
	long	relx, rely; 	/* ΍W */
	int	n2, n2hlf;
struct vecdata	pntdata;

	/* Set Start Point */
	if ( (sts= VDSetData( lstHdl, s))<0)
		goto	RET;

	/*  N߂ */
	n2xmax = (e->x - cp->x) - ( cp->x - s->x);

	if ( n2xmax < 0)	n2xmax = -n2xmax;
	else if ( n2xmax == 0 && cp->x==s->x)
		goto	TERM_SET;

	n2ymax = (e->y - cp->y) - ( cp->y - s->y);
	if ( n2ymax < 0)	n2ymax = -n2ymax;
	else if ( n2ymax == 0 && cp->y==s->y)
		goto	TERM_SET;

	if ( n2xmax > n2ymax)		n2max = (n2xmax*2) >> UNDERFP;
	else				n2max = (n2ymax*2) >> UNDERFP;
	n = fsqrt( n2max); 

	/* _̍W߂ */ 
	if ( n > 1) {
		n2 = n*n;
		n2hlf = (n*n)/2;	 /* Expect Optimize */

		px = (long)s->x*n2;
		py = (long)s->y*n2;

		g2x = (e->x - cp->x) - (cp->x - s->x);
		g2y = (e->y - cp->y) - (cp->y - s->y);

		g1x = (long)n*(cp->x - s->x) *2;
		g1y = (long)n*(cp->y - s->y) *2;

		f1x = g2x*2;
		f1y = g2y*2;

		fx = g1x + g2x;
		fy = g1y + g2y;

		px += fx;
		py += fy;

		/* ŏ̓_߂ : n_̑΍WvZ */
		relx = fx;
		rely = fy;
		if (relx >= 0)	relx += n2hlf;
		else		relx -= n2hlf;
		if (rely >= 0)	rely += n2hlf;
		else		rely -= n2hlf;

		pntdata.x = (int)(relx / n2 + s->x);
		pntdata.y = (int)(rely / n2 + s->y);
		pntdata.atr = 0;
		if ( (sts= VDSetData( lstHdl, &pntdata ))<0)
			goto	RET;
		if (n > 2) {
			num = n - 1;
			for ( i = 2; i < num; i++) {
				fx += f1x;
				fy += f1y;

				px +=  fx;
				py +=  fy;

				/* ŏƍŌ̓_ȊO̓_΍WŌvZ */
				pntdata.x = (int)((px + n2hlf) /n2);
				pntdata.y = (int)((py + n2hlf) /n2);
				if ( (sts= VDSetData(lstHdl, &pntdata ))<0)
					goto	RET;
			}
			fx += f1x;
			fy += f1y;

			px +=  fx;
			py +=  fy;

			relx = px - (long)e->x*n2;
			rely = py - (long)e->y*n2;
			if (relx >= 0)	relx += n2hlf;
			else		relx -= n2hlf;
			if (rely >= 0)	rely += n2hlf;
			else		rely -= n2hlf;
	
			/* Ō̓_߂ : I_̑΍WvZ */
			pntdata.x = (int)(relx / n2 + e->x);
			pntdata.y = (int)(rely / n2 + e->y);
			if ( (sts= VDSetData(lstHdl, &pntdata))<0)
				goto	RET;
		}
	}
TERM_SET:

	/* Ȑ̏I_͐ݒ肵Ȃ */
RET:
	return( sts);
}
/************************************************************
 *	Fast SQRT (N̕߂)
 */
/* */	static int
/* */	fsqrt( int n)
/*
 *	returns : 
 ************************************************************/
{
	int	i;

	if ( n < NMAX*2) {
		i = lowsqr[ n/2];
	}
	else {
		for ( i=0; i<NMAX; i++ )
			if ( sqrtbl[i] > n)	break;
		i++;
	}
	return( i );
}
/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\refrdlg.h ===
/**************************************************/
/*					                              */
/*					                              */
/*	Reference other characters	                  */
/*		(Dialog)		                          */
/*					                              */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include "refrlist.h"
#include "eudclist.h"

class CRefrDlg : public CDialog
{

public:
	CRefrDlg(CWnd* pParent = NULL);

	//{{AFX_DATA(CRefrDlg)
	enum { IDD = IDD_REFERENCE };
	//}}AFX_DATA

private:
	void 	SetViewFont();
	void 	JumpReferCode();
	void 	AdjustFontName();

private:
	int	vHeight;
	TCHAR	FocusCode[5];
	TCHAR	FocusChar[3];
	TCHAR	FontName[LF_FACESIZE];
	CRefListFrame	m_RefListFrame1;
	CRefInfoFrame	m_RefInfoFrame;
	CColumnHeading	m_ColumnHeadingR;
	CEdit       m_EditChar;

public:
	CRefrList	m_CodeList;

protected:
	virtual BOOL OnInitDialog();
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

	//{{AFX_MSG(CRefrDlg)
	afx_msg void OnClickedButtomfont();
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnChangeEditcode();
	afx_msg void OnSetfocusEditcode();
	afx_msg void OnKillfocusEditcode();
	afx_msg void OnSetfocusEditchar();
	afx_msg void OnKillfocusEditchar();
	afx_msg void OnChangeEditchar();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\refrlist.h ===
/**************************************************/
/*						                          */
/*	Character List (Referrence Dialog)	          */		
/*						                          */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

class CRefListFrame :public CStatic
{
//	member function
public:
	CRefListFrame();
	~CRefListFrame();

private:
	void DrawConcave( CDC *dc, CRect rect);

protected:

	//{{AFX_MSG(CRefListFrame)
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CRefInfoFrame :public CStatic
{
//	member function
public:
	CRefInfoFrame();
	~CRefInfoFrame();

private:
	void DrawConcave( CDC *dc, CRect rect);

protected:

	//{{AFX_MSG(CRefInfoFrame)
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CRefrList : public CEdit
{
	DECLARE_DYNCREATE( CRefrList)

//	Member function
public:
	CRefrList();
	~CRefrList();

public:
	BOOL	CodeButtonClicked();
	void	SetCodeRange();
	void	ResetParam();
	void 	CalcCharSize();

private:
	int	CheckCharType( WORD Code);
	int	GetBarPosition( WORD Code);
	WORD 	CalculateCode( WORD Start, WORD End);
	WORD 	GetPlusCode( WORD Code, int ScrollNum);
	WORD 	GetMinusCode( WORD Code, int ScrollNum);
	WORD 	GetPlusCodeKey( WORD Code, int ScrollNum);
	WORD 	GetMinusCodeKey( WORD Code, int ScrollNum);
	WORD 	GetCodeScrPos( int Pos);
	BOOL 	IsCheckedCode( WORD CodeStock);
	BOOL	IsCorrectChar( UINT i, UINT j);
	void 	SearchKeyPosition( BOOL Flg);
	void 	DrawConcave( CDC *dc, CRect rect, BOOL PtIn);

//	Member parameter
public:
	CPoint	LButtonPt;
	WORD 	ViewStart;
	WORD	ViewEnd;
	WORD	SelectCode;
	short	ScrlBarPos;
	CFont	SysFFont;
	CFont	CharFont;
	CFont	ViewFont;
	CSize 	CharSize;
	int	PointSize;
	LOGFONT	rLogFont;
	LOGFONT	cLogFont;
	DWORD   dwCodePage;

private:
	CRect	CodeListRect;
	CPoint	WritePos;
	CSize 	FixSize;
	WORD	StartCode;
	WORD	EndCode;
	WORD	BottomCode;
	int	xSpace;
	int	ySpace;
	int	CHN;
	BOOL	FocusFlag;

protected:
	//{{AFX_MSG(CRefrList)
	afx_msg void OnPaint();
	afx_msg void OnVScroll( UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\refrlist.cpp ===
/**************************************************/
/*						                          */
/*						                          */
/*	Character List( Referrence Dialog)	          */
/*						                          */
/*						                          */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include 	"stdafx.h"
#include 	"eudcedit.h"
#include 	"refrlist.h"
#include    "util.h"

//	6 * 16 Matrics
#define		NUM_CHAR	16
#define		NUM_LINE	6

//	Type of Character Code
#define		CHAR_INIT	0	// Initial value
#define		CHAR_SBCS	1	// SBCS
#define		CHAR_DBCS1	2	// DBCS1
#define		CHAR_DBCS2	3	// DBCS2
#define		CHAR_EUDC	4	// EUDC
#define		CHAR_ETC	5	// Other

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE( CRefrList, CEdit)
BEGIN_MESSAGE_MAP( CRefrList, CEdit)
	//{{AFX_MSG_MAP( CRefrList)
	ON_WM_PAINT()
	ON_WM_VSCROLL()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_SETCURSOR()
	ON_WM_KEYDOWN()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_WM_RBUTTONUP()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//	Range of character code( high byte)
static WORD HiByteRange[][10] =
{
//    JPN             CHT             KRW             CHS             OTHER
	{ 0x00a0, 0xfca0, 0x00a0, 0xfea0, 0x00a0, 0xfea0, 0x00a0, 0xfea0, 0x00a0, 0x00a0}, // CHAR_INIT
	{ 0x0020, 0x00ff, 0x0020, 0x00ff, 0x0020, 0x00ff, 0x0020, 0x00ff, 0x0020, 0x00ff}, // CHAR_SBCS
	{ 0x8140, 0x9fff, 0x8140, 0xa0ff, 0x8140, 0x8fff, 0x8140, 0xafff, 0x0020, 0x00ff}, // CHAR_DBCS1
	{ 0xe040, 0xeaff, 0xa140, 0xf9ff, 0x9040, 0x9fff, 0xb040, 0xf7ff, 0x0020, 0x00ff}, // CHAR_DBCS2
	{ 0xf040, 0xfcff, 0xfa40, 0xfeff, 0xa040, 0xfeff, 0xf840, 0xfeff, 0x0020, 0x00ff}, // CHAR_EUDC
};

//	Range of character code( low byte)
static WORD LoByteRange[][10] =
{
	{ 0x0020, 0x00ff, 0x0020, 0x00ff, 0x0020, 0x00ff, 0x0020, 0x00ff, 0x0020, 0x00ff },
	{ 0x0040, 0x007e, 0x0040, 0x007e, 0x0041, 0x005a, 0x0040, 0x007e, 0x0040, 0x007e },
	{ 0x0080, 0x00fc, 0x0080, 0x00fe, 0x0061, 0x007a, 0x0080, 0x00fe, 0x0040, 0x007e },
	{ 0x0080, 0x00fc, 0x0080, 0x00fe, 0x0081, 0x00fe, 0x0080, 0x00fe, 0x0040, 0x007e },
	{ 0x0000, 0x003f, 0x0000, 0x003f, 0x0000, 0x003f, 0x0000, 0x003f, 0x0040, 0x007e },
};

extern LOGFONT	ReffLogFont;
extern LOGFONT	EditLogFont;
extern BOOL	TitleFlag;
extern BOOL	CodeFocus;
extern BOOL	CharFocus;
static CRect	rcReferChar[NUM_LINE][NUM_CHAR];
static CRect	rcReferCode[NUM_LINE];

/****************************************/
/*					*/
/*	Default Constructor		*/
/*					*/
/****************************************/
CRefrList::CRefrList()
{
/*
//	Initialize static parameter
	if( CountryInfo.LangID == EUDC_CHT)
		CHN = 2;
	else if( CountryInfo.LangID == EUDC_JPN)
		CHN = 0;
	else if( CountryInfo.LangID == EUDC_KRW)
		CHN = 4;
	else if( CountryInfo.LangID == EUDC_CHS)
		CHN = 6;
	else 	CHN = 8;
*/
	FocusFlag = FALSE;
}
								
/****************************************/
/*					*/
/*	Destructor( Virtual)		*/
/*					*/
/****************************************/
CRefrList::~CRefrList()
{
    SysFFont.DeleteObject();
    CharFont.DeleteObject();
		ViewFont.DeleteObject();
}
			      		
/****************************************/
/*					*/
/*	Set intitial code range		*/
/*					*/
/****************************************/
void
CRefrList::SetCodeRange()
{
    CHARSETINFO CharsetInfo;
    BYTE CharSet;

		SelectCode = 0x0020;
		ScrlBarPos = 0;
		StartCode  = 0x0020;
		EndCode    = 0xffff;
		ViewStart  = 0x0020;
		ViewEnd    = 0xffa0;
/*
	SelectCode = HiByteRange[CHAR_SBCS][CHN];
	ScrlBarPos = 0;
	StartCode  = HiByteRange[CHAR_SBCS][CHN];
	ViewStart  = HiByteRange[CHAR_SBCS][CHN];
	if( !TitleFlag){
		if( rLogFont.lfCharSet == CountryInfo.CharacterSet){
//			Correspond to DBCS		    	
			ViewEnd = HiByteRange[CHAR_INIT][CHN+1];
			EndCode	= HiByteRange[CHAR_EUDC][CHN+1];
		}else{
//			Correspond to SBCS
			ViewEnd = HiByteRange[CHAR_INIT][CHN];
			EndCode	= HiByteRange[CHAR_SBCS][CHN+1];
		}
        CharSet = rLogFont.lfCharSet;

	}else{
		if( cLogFont.lfCharSet == CountryInfo.CharacterSet){
			ViewEnd = HiByteRange[CHAR_INIT][CHN+1];
			EndCode	= HiByteRange[CHAR_EUDC][CHN+1];
		}else{
			ViewEnd = HiByteRange[CHAR_INIT][CHN];
			EndCode	= HiByteRange[CHAR_SBCS][CHN+1];
		}
        CharSet = cLogFont.lfCharSet;
	}

    if(CharSet == SYMBOL_CHARSET)
    {
        dwCodePage = 1252;
    }
    else if(TranslateCharsetInfo((DWORD *)CharSet,&CharsetInfo,TCI_SRCCHARSET))
    {
        dwCodePage = CharsetInfo.ciACP;
    }
    else
    {
        dwCodePage = CP_ACP;
    }
*/
}

/****************************************/
/*					*/
/*	Check type of character code	*/
/*					*/
/****************************************/
int
CRefrList::CheckCharType(
WORD 	Code)
{
	/*
	if( !( Code & 0xff00))
		return	CHAR_SBCS;
	else if(( Code >= HiByteRange[CHAR_DBCS1][CHN]) &&
	        ( Code <= HiByteRange[CHAR_DBCS1][CHN+1]))
		return  CHAR_DBCS1;
	else if(( Code >= HiByteRange[CHAR_DBCS2][CHN]) &&
		( Code <= HiByteRange[CHAR_DBCS2][CHN+1]))
	 	return  CHAR_DBCS2;
	else if(( Code >= HiByteRange[CHAR_EUDC][CHN])  &&
		( Code <= HiByteRange[CHAR_EUDC][CHN+1]))
		return  CHAR_EUDC;
	else	return  CHAR_ETC;
	*/
	return 0;
}

/****************************************/
/*					*/
/*	Increase character code		*/
/*					*/
/****************************************/
WORD
CRefrList::GetPlusCode(
WORD 	Code,
int 	ScrollNum)
{
	WORD	PrevCode;
	WORD 	LowByte, HighByte;
	int	CharType;
	int	CharType1, CharType2;
	int	Offset;

	Code += (WORD)ScrollNum;
/*
	PrevCode = (WORD)(Code - (WORD)ScrollNum);
	CharType1 = CheckCharType( PrevCode);
	CharType2 = CheckCharType( Code);
	if( CharType1 != CharType2){
		if( CharType1 == CHAR_EUDC)
			Code = PrevCode;		
		else{
			Offset = Code - HiByteRange[CharType1][CHN+1];
			Code = (WORD)( HiByteRange[CharType1+1][CHN] +Offset-1);
		}
	}
	CharType = CheckCharType( Code);
	if( CharType != CHAR_SBCS){
		LowByte  = Code & 0x00ff;
		HighByte = Code & 0xff00;
		if( LowByte <= LoByteRange[4][CHN+1] &&
		    LowByte >= LoByteRange[4][CHN] ){
#if 0
			if( CountryInfo.LangID == EUDC_CHS)
				LowByte = 0x00a0;
			else	LowByte = 0x0040;
#endif
			LowByte = 0x0040;
		}
		Code = ( HighByte | LowByte);
	}
*/
	return Code;
}
					
/****************************************/
/*					*/
/*	Decrease Character Code		*/
/*					*/
/****************************************/
WORD
CRefrList::GetMinusCode(
WORD 	Code,
int 	ScrollNum)
{
	WORD	PrevCode;
	int	CharType;
	int	CharType1, CharType2;
	int	Offset;

	Code -= (WORD)ScrollNum;
/*
	PrevCode = (WORD)( Code + (WORD)ScrollNum);
	CharType1 = CheckCharType( Code);
	CharType2 = CheckCharType( PrevCode);
	if( CharType1 != CharType2){
	 	if( CharType2 == CHAR_SBCS)
			return (WORD)HiByteRange[CHAR_SBCS][CHN];
		else{
			Offset = HiByteRange[CharType2][CHN] - Code;
			return (WORD)(HiByteRange[CharType2-1][CHN+1]-Offset+1);
		}	
	}
	CharType = CheckCharType( Code);
	if( CharType != CHAR_SBCS){
		WORD 	LowByte;
		WORD	HighByte;
		WORD	Tmp;

		LowByte  = Code & 0x00ff;
		HighByte = Code & 0xff00;
		if( LowByte <= LoByteRange[4][CHN+1] &&
		    LowByte >= LoByteRange[4][CHN] ){
			LowByte = 0xf0;
			Tmp = ( HighByte >> 8);
			Tmp -= 0x1;
			HighByte = Tmp << 8;
		}
		Code = ( HighByte | LowByte);
	}
*/
	return Code;
}
					
/****************************************/
/*					*/
/*	Calculate scroll position	*/
/*					*/	
/****************************************/
int
CRefrList::GetBarPosition(
WORD 	Code)
{
	short   i, StartType, EndType;
	int     Pos = 0;

	Pos = (Code - StartCode) /NUM_CHAR;
	return Pos;
/*
	StartType = CheckCharType( StartCode);
	EndType   = CheckCharType( Code);
	if( EndType == CHAR_SBCS){
		Pos = ( Code - HiByteRange[CHAR_SBCS][CHN]) /NUM_CHAR;
		return Pos;

	}

	for (i = StartType; i < EndType; i++){
		if( i == CHAR_SBCS){
			Pos += (HiByteRange[CHAR_SBCS][CHN+1]
				- HiByteRange[CHAR_SBCS][CHN] + 1) / NUM_CHAR;
		}else{
        		Pos += CalculateCode( HiByteRange[i][CHN],
        			HiByteRange[i][CHN+1]) / NUM_CHAR;
		}
	}
	Pos += CalculateCode( HiByteRange[i][CHN], Code) / NUM_CHAR;
	return Pos;
*/
}
					
/****************************************/
/*					*/
/*	Calculate character code	*/
/*					*/
/****************************************/
WORD
CRefrList::CalculateCode(
WORD 	Start,
WORD 	End)
{
	WORD 	PageNum = 0;
	WORD	CodeNum = 0;

    	if ( Start >= End )
         	return 0;

    	PageNum = HIBYTE(End) - HIBYTE(Start);
#if 0
	if( CountryInfo.LangID == EUDC_CHS){
		if( HIBYTE(End)){
			WORD	LoCode;
			WORD	HiCode;

			HiCode = End & 0xff00;
			LoCode = End & 0x00ff;
			if( LoCode < 0xa0)
				LoCode = 0xa0;
			End = HiCode | LoCode;
		}
		CodeNum	= End - Start - PageNum * 0x00a0;
	}else   CodeNum = End - Start - PageNum * 0x0040;
#endif
	CodeNum = End - Start - PageNum * 0x0040;

    	return CodeNum;
}
					
/****************************************/
/*					*/
/*  	Calculate code from scroll pos	*/
/*					*/
/****************************************/
WORD
CRefrList::GetCodeScrPos(
int 	Pos)
{
	short	i, StartType, EndType;
	WORD	Code = 0;
	WORD	NumLine = 0, PNumLine = 0;

	if (Pos == 0)
		return StartCode;
	if (Pos >= BottomCode)
	  return ViewEnd;
	Code = StartCode + Pos * NUM_CHAR;
	Code &= 0xfff0;
	return Code;

/*
	if( !Pos)
        	return HiByteRange[1][CHN];
	if( Pos >= BottomCode)
        	return ViewEnd;

	StartType = CheckCharType( HiByteRange[1][CHN]);
	EndType   = CheckCharType( HiByteRange[4][CHN+1]);
	for( i = StartType; i <= EndType; ++i){
    if( i == CHAR_SBCS )
      NumLine += (HiByteRange[i][CHN+1] - HiByteRange[i][CHN] + 1) /NUM_CHAR;
    else
    	NumLine += CalculateCode( HiByteRange[i][CHN],HiByteRange[i][CHN+1])/NUM_CHAR;
    if( NumLine > Pos){
			NumLine = PNumLine;
      break;
    }
    PNumLine = NumLine;
	}
	Code = HiByteRange[i][CHN];
	Pos -= NumLine;
  while( Code < HiByteRange[i][CHN+1]){
    NumLine = CalculateCode( HiByteRange[i][CHN], Code) /NUM_CHAR;
    if( Pos <= NumLine){
	        	break;
		}
    Code += NUM_CHAR;
  }

	Code &= 0xfff0;
	return Code;
*/
}
					
/****************************************/
/*					*/
/*	Jump view if editbox get focus	*/
/*					*/
/****************************************/
BOOL
CRefrList::CodeButtonClicked()
{
	WCHAR CodeValue[15] = {0};
	WCHAR	CharValue[15] = {0};
	WORD	Code1, Code2;

	Code1 = (WORD)0;
	Code2 = (WORD)0;
#ifdef UNICODE
  ::GetDlgItemTextW(GetParent()->GetSafeHwnd(), IDC_EDITCODE, CodeValue, 15);
  ::GetDlgItemTextW(GetParent()->GetSafeHwnd(), IDC_EDITCHAR, CharValue, 15);
#else
	CHAR CodeValueA[15];
	CHAR CharValueA[15];
  ::GetDlgItemText(GetParent()->GetSafeHwnd(), IDC_EDITCODE, CodeValueA, 15);
  int nchar = ::GetDlgItemText(GetParent()->GetSafeHwnd(), IDC_EDITCHAR, CharValueA, 15);
  MultiByteToWideChar(CP_ACP, 0, CodeValueA, 4, CodeValue, sizeof(CodeValue)/sizeof(CodeValue[0]));
  MultiByteToWideChar(CP_ACP, 0, CharValueA, nchar, CharValue, sizeof(CharValue)/sizeof(CharValue[0]));
#endif

  /*	::GetDlgItemTextA( GetParent()->GetSafeHwnd(),IDC_EDITCHAR, CharValue, 15); */

	if( CodeValue[0] == '\0' && CharValue[0] == '\0')
		return TRUE;

	if( CodeValue[0] == '\0')
		Code2 = 0xffff;
	else	Code2 = (WORD)wcstol((LPWSTR)CodeValue, (WCHAR **)0, 16);
		
	if( CharValue[0] == '\0')
		Code1 = 0xffff;
	else
		Code1  = CharValue[0];
	
	if( CodeFocus){
		if( !IsCheckedCode( Code2))
			goto Error;
		SelectCode = Code2;		
	}

	if( CharFocus){
		if( !IsCheckedCode( Code1))
			goto Error;
		SelectCode = Code1;		
	}
		
	if( SelectCode >= ViewEnd)
		ViewStart = ViewEnd;
	else	ViewStart = SelectCode & 0xfff0;

 	BottomCode = (WORD)GetBarPosition((WORD)ViewEnd);
 	this->SetScrollRange( SB_VERT, 0, BottomCode, FALSE);
	ScrlBarPos = (short)GetBarPosition( ViewStart);
	this->SetScrollPos( SB_VERT, ScrlBarPos, TRUE);
	this->InvalidateRect( &CodeListRect, TRUE);
	this->UpdateWindow();
	return TRUE;
Error:
	return FALSE;
}
					
/****************************************/
/*					*/
/*	Check Character Code Range	*/
/*					*/
/****************************************/
BOOL
CRefrList::IsCheckedCode(
WORD 	CodeStock)
{
	WORD	Offset;
	int	CharType;
	int	CharType1;
/*
	if(( CharType = CheckCharType( CodeStock)) == CHAR_ETC)
		return FALSE;
	CharType1 = CheckCharType( ViewEnd);

	Offset = CodeStock & 0x00ff;
	if( CharType == CHAR_SBCS){
		if( Offset < LoByteRange[0][CHN])
			return FALSE;
	}else{
		if( CharType1 == CHAR_SBCS)
			return FALSE;
		if( Offset >= LoByteRange[4][CHN] &&
		    Offset <= LoByteRange[4][CHN+1] )
			return FALSE;
		if(( Offset >= LoByteRange[1][CHN]  &&
		     Offset <= LoByteRange[1][CHN+1]) ||
		   ( Offset >= LoByteRange[2][CHN]  &&
		     Offset <= LoByteRange[2][CHN+1]) ||
		   ( Offset >= LoByteRange[3][CHN]  &&
		     Offset <= LoByteRange[3][CHN+1])){
				;
		}else	return FALSE;
	}
*/
	return TRUE;
}

#define	FIX_SPACE	6
#define	LINEWIDTH	4
/****************************************/
/*					*
/*	Calcurate character size	*/
/*					*/
/****************************************/
void
CRefrList::CalcCharSize()
{
	char	Dummy[] = "FA40";
	int	Sx;

	CClientDC	dc( this);
	this->GetClientRect( &CodeListRect);

	CFont	*OldFont = dc.SelectObject( &SysFFont);
	GetTextExtentPoint32A( dc.GetSafeHdc(), Dummy, 4, &FixSize);
	FixSize.cx += FIX_SPACE;
	dc.SelectObject( OldFont);

	CharSize.cy = ( CodeListRect.Height()
			- ((NUM_LINE-1)*LINEWIDTH) - 2) /NUM_LINE;
	CharSize.cx = ( CodeListRect.Width()
			- FixSize.cx - 2 - (NUM_CHAR*LINEWIDTH)) / NUM_CHAR;

	for( int i = 0; i < NUM_LINE; i++){
		rcReferCode[i].left   = 1;
		rcReferCode[i].top    = 1 + i*(CharSize.cy + LINEWIDTH);
		rcReferCode[i].right  = rcReferCode[i].left + FixSize.cx;
		rcReferCode[i].bottom = rcReferCode[i].top  + CharSize.cy;
		Sx = rcReferCode[i].right + LINEWIDTH;
		for( int j = 0; j < NUM_CHAR; j++){
			rcReferChar[i][j].left   = Sx + j*( CharSize.cx
						 + LINEWIDTH);
			rcReferChar[i][j].top    = rcReferCode[i].top;
			rcReferChar[i][j].right  = rcReferChar[i][j].left
						+ CharSize.cx;
			rcReferChar[i][j].bottom = rcReferChar[i][j].top
						+ CharSize.cy;
		}
	}
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_PAINT"		*/
/*					*/
/****************************************/
void
CRefrList::OnPaint()
{
register int	i, j;
	WORD	Code;

	CPaintDC	dc( this);

	int BottomCode = GetBarPosition((WORD)ViewEnd);
	this->SetScrollRange( SB_VERT, 0, BottomCode, FALSE);
	this->SetScrollPos( SB_VERT, ScrlBarPos, TRUE);

//	Initialize character code
	Code = ViewStart;

//	Change Mapping mode
	int OldMode = dc.SetMapMode(MM_TEXT);
	dc.SetViewportOrg( 0, 0);
	CFont	*OldFont = dc.SelectObject( &SysFFont);

	for( i = 0; i < NUM_LINE; i++){
		int	xOffset, yOffset;
		TCHAR	Work[5];
		int	wLength, CharType;

//		Draw character code on character list to display
		dc.SelectObject( &SysFFont);
		wsprintf(Work, _T("%04X"), Code);
		dc.SetBkColor( COLOR_FACE);
		dc.SetTextColor(GetSysColor(COLOR_WINDOWTEXT));  //COLOR_BLACK);

		if( rcReferCode[i].Height() > FixSize.cy){
			yOffset = (rcReferCode[i].Height() - FixSize.cy) /2;
		}else	yOffset = 0;

        ::ExtTextOut(dc, rcReferCode[i].left + FIX_SPACE/2,
				      rcReferCode[i].top  + yOffset,
			        ETO_OPAQUE, &rcReferCode[i],
			        (TCHAR *)Work, 4, NULL);

		dc.SelectObject( &CharFont);
		for( j = 0; j < NUM_CHAR; j++ , Code = GetPlusCode( Code, 1)){
			WORD	Offset;
			CSize	cSize;
      WCHAR Work1[5];
			Work1[0] = Code;
			Work1[1] = 0;
			wLength = 1;
/*
			if(( CharType = CheckCharType( Code)) == CHAR_SBCS){
				Work[0] = LOBYTE(Code);
				wLength = 1;

			}else if( CharType == CHAR_DBCS1 ||
				  CharType == CHAR_DBCS2 ||
				  CharType == CHAR_EUDC  ){
				Offset = Code & 0x00ff;
				if(( Offset <= LoByteRange[1][CHN+1]  &&
				     Offset >= LoByteRange[1][CHN]) ||
				   ( Offset <= LoByteRange[2][CHN+1]  &&
				     Offset >= LoByteRange[2][CHN]) ||
				   ( Offset <= LoByteRange[3][CHN+1]  &&
				     Offset >= LoByteRange[3][CHN]) ){
	   					Work[0] = (BYTE)((Code>>8) & 0x00ff);
    	        		Work[1] = (BYTE) (Code & 0x00ff);
        	    		wLength = 2;
				}else{
					continue;				
				}
	   		}else	wLength = 0;
            		Work[wLength] = (BYTE)'\0';

#ifdef UNICODE
            WCHAR wszCodeTemp[2];
            wLength = MultiByteToWideChar(dwCodePage,
                                              0,
                                              (LPSTR) Work,
                                              wLength,
                                              wszCodeTemp,
                                              1);
                Work[0] = LOBYTE(wszCodeTemp[0]);
                Work[1] = HIBYTE(wszCodeTemp[0]);
                Work[2] = '\0';
#endif
*/
			BOOL	PtIn;
			if( rcReferChar[i][j].PtInRect( LButtonPt) ||
			    SelectCode == Code){
				TCHAR 	CodeNum[10];

//				If character is selected by clickking
//			 	left button, draw it on dialog
				PtIn = TRUE;
				SelectCode = Code;
				dc.SetBkColor( COLOR_FACE);
				dc.SetTextColor(GetSysColor(COLOR_WINDOWTEXT)); // COLOR_BLACK);
				wsprintf((TCHAR *)CodeNum, _T("%04X"), Code);

				if (!CodeFocus)
				{
          ::SetDlgItemText(GetParent()->GetSafeHwnd(), IDC_EDITCODE, (LPCTSTR)CodeNum);
				}

				if (!CharFocus)
				{
#ifdef UNICODE
          ::SetDlgItemTextW(GetParent()->GetSafeHwnd(), IDC_EDITCHAR, (LPCWSTR)Work1);
#else
          CHAR Work2[4];
          int nchar=WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)Work1, 1, (LPSTR)Work2, sizeof(Work2), 0,0);
          Work2[nchar]=0;
          ::SetDlgItemText(GetParent()->GetSafeHwnd(), IDC_EDITCHAR, (LPCSTR)Work2);
#endif        
        }

			}else{
				PtIn = FALSE;
				dc.SetBkColor( COLOR_FACE);
				dc.SetTextColor(GetSysColor(COLOR_WINDOWTEXT)); // COLOR_BLACK);
			}
			BOOL sts = GetTextExtentPoint32W( dc.GetSafeHdc(),
				(LPCWSTR)Work1, wLength, &cSize);

			if( rcReferChar[i][j].Width() > cSize.cx){
				xOffset = rcReferChar[i][j].Width() - cSize.cx;
				xOffset /= 2;
			}else	xOffset = 0;

			if( rcReferChar[i][j].Height() > cSize.cy){
				yOffset = rcReferChar[i][j].Height() - cSize.cy;
				yOffset /= 2;
			}else	yOffset = 0;

//			Draw character code on character list
			ExtTextOutW(dc.GetSafeHdc(), rcReferChar[i][j].left + xOffset,
				       rcReferChar[i][j].top  + yOffset,
				       ETO_OPAQUE, &rcReferChar[i][j],
				       (LPCWSTR)Work1, wLength, NULL);
			DrawConcave( &dc, rcReferChar[i][j], PtIn);
		}
    }
    dc.SelectObject( OldFont);
	dc.SetMapMode(OldMode);
	LButtonPt.x = 0;
	LButtonPt.y = 0;
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_VSCROLL"		*/
/*					*/
/****************************************/
void
CRefrList::OnVScroll(
UINT 		nSBCode,
UINT 		nPos,
CScrollBar	*pScrollBar)
{
	int	MoveScr;
	BOOL 	ThumbTrkFlag, ThumbPosFlag;

	BottomCode = (WORD)GetBarPosition((WORD)ViewEnd);
	this->SetScrollRange( SB_VERT, 0, BottomCode, FALSE);

	MoveScr = 0;
	ThumbTrkFlag = ThumbPosFlag = FALSE;
	switch( nSBCode){
		case SB_LINEDOWN:
			if(( ViewStart + NUM_CHAR) <= ViewEnd){
				MoveScr = 0 - (CharSize.cy + LINEWIDTH);
				ViewStart  = GetPlusCode( ViewStart,NUM_CHAR);
				ScrlBarPos = (short)GetBarPosition( ViewStart);
			}
			break;

		case SB_LINEUP:
			if(( ViewStart - NUM_CHAR) >= StartCode){
				MoveScr = CharSize.cy + LINEWIDTH;
				ViewStart  = GetMinusCode(ViewStart,NUM_CHAR);
				ScrlBarPos = (short)GetBarPosition( ViewStart);
			}
			break;

		case SB_PAGEDOWN:
			if(( ViewStart + NUM_CHAR*NUM_LINE) <= ViewEnd){
				MoveScr = ( 0 -(CharSize.cy+LINEWIDTH)) *NUM_LINE;
				ScrlBarPos = (short)GetBarPosition( ViewStart);
				ScrlBarPos += NUM_LINE;
				ViewStart = GetCodeScrPos( ScrlBarPos);
 			}else{
				MoveScr = ( 0 -(CharSize.cy+LINEWIDTH)) *NUM_LINE;
				ViewStart = ViewEnd;
				ScrlBarPos = (short)GetBarPosition( ViewStart);
			}
			break;

		case SB_PAGEUP:
			if(( ViewStart - NUM_CHAR*NUM_LINE) >= StartCode &&
				 ViewStart >= NUM_CHAR*NUM_LINE){
				MoveScr =  (CharSize.cy + LINEWIDTH) *NUM_LINE;
				ScrlBarPos = (short)GetBarPosition( ViewStart);
				ScrlBarPos -= NUM_LINE;
				ViewStart = GetCodeScrPos( ScrlBarPos);
			}else{
				MoveScr = (CharSize.cy + LINEWIDTH) *NUM_LINE;
				ViewStart = StartCode;
				ScrlBarPos = (short)GetBarPosition( ViewStart);
			}
			break;

		case SB_THUMBPOSITION:
			ThumbPosFlag = TRUE;
			ScrlBarPos = (short)nPos;
			ViewStart = GetCodeScrPos( nPos);
			break;

		case SB_THUMBTRACK:
			ThumbTrkFlag = TRUE;
			break;

		case SB_TOP:
			ViewStart = StartCode;
			ScrlBarPos = 0;
			break;

		case SB_BOTTOM:
			ViewStart = ViewEnd;
			ScrlBarPos = BottomCode;
			break;

		default:
			break;
	}
	if( abs( MoveScr) <= (CharSize.cy + LINEWIDTH) &&
	    abs( MoveScr) > 0 && !ThumbTrkFlag){
		CRect	ScrllRect;
		CRect	ClintRect;

		GetClientRect( &ClintRect);
		ScrllRect.CopyRect( &ClintRect);
		if( MoveScr < 0){
			ClintRect.top = 0 - MoveScr;
			this->ScrollWindow( 0, MoveScr, &ClintRect, NULL);
			ScrllRect.top = ( 0-MoveScr)*(NUM_LINE -1);
		}else{
			ClintRect.top = 0;
			ClintRect.bottom = MoveScr*(NUM_LINE -1);
			this->ScrollWindow( 0, MoveScr, &ClintRect, NULL);
			ScrllRect.top = 0;
			ScrllRect.bottom = ScrllRect.top + MoveScr;
		}
		this->InvalidateRect( &ScrllRect, FALSE);
	}else if( !ThumbTrkFlag && ( MoveScr || ThumbPosFlag)){
		this->InvalidateRect( &CodeListRect, TRUE);
	}
	this->SetScrollPos( SB_VERT, ScrlBarPos, TRUE);
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_LBUTTONDOWN"	*/
/*					*/
/****************************************/
void
CRefrList::OnLButtonDown(
UINT	,
CPoint 	point)
{
	CRect	test;
	BOOL	PtIn;
unsigned int	i, j;

	PtIn = FALSE;
	this->SetFocus();
	for( i = 0; i < NUM_LINE; i++){
		for( j = 0; j < NUM_CHAR; j++){
			if( rcReferChar[i][j].PtInRect( point)){
				if( IsCorrectChar( i, j))
					PtIn = TRUE;
				break;
			}
		}
	}

	if( !PtIn){
		MessageBeep((UINT)-1);
		return;
	}

	LButtonPt = point;
	SearchKeyPosition( TRUE);
	SelectCode = 0;

	for( i = 0; i < NUM_LINE; i++){
		for( j = 0; j < NUM_CHAR; j++){
			if( rcReferChar[i][j].PtInRect( LButtonPt)){
				test.SetRect( rcReferChar[i][j].left - 2,
					      rcReferChar[i][j].top - 2,
					      rcReferChar[i][j].right + 2,
					      rcReferChar[i][j].bottom + 2);
				this->InvalidateRect( &test, FALSE);
				break;
			}
		}
	}
	this->UpdateWindow();
}
					
/****************************************/
/*					*/
/*	MESSAGE	"WM_LBUTTONDBLCLK"	*/
/*					*/
/****************************************/	
void
CRefrList::OnLButtonDblClk(
UINT 	nFlags,
CPoint 	point)
{
	BOOL	PtIn;
unsigned int	i, j;

	LButtonPt = point;
	this->InvalidateRect( &CodeListRect, FALSE);
	this->UpdateWindow();

 	PtIn = FALSE;
	this->SetFocus();
	for( i = 0; i < NUM_LINE; i++){
		for( j = 0; j < NUM_CHAR; j++){
			if( rcReferChar[i][j].PtInRect( point)){
				if( IsCorrectChar( i, j))
					PtIn = TRUE;
				break;
			}
		}
	}
	if( !PtIn){
		MessageBeep((UINT)-1);
		return;
	}else{
		GetParent()->PostMessage( WM_COMMAND, IDOK, 0L);
	}
}
					
/****************************************/
/*					*/
/*	MESSAGE	"WM_SETCURSOR"		*/
/*					*/
/****************************************/
BOOL
CRefrList::OnSetCursor(
CWnd* 	pWnd,
UINT 	nHitTest,
UINT 	message)
{
	::SetCursor( AfxGetApp()->LoadStandardCursor(IDC_ARROW));
	return TRUE;
}

/****************************************/
/*					*/
/*	Reset parameter			*/
/*					*/
/****************************************/
void
CRefrList::ResetParam()
{
	LButtonPt.x = LButtonPt.y = 0;
/*
	SelectCode = HiByteRange[CHAR_SBCS][CHN];
*/
	SelectCode = 0x0020;
	ScrlBarPos = 0;
	this->SetScrollPos( SB_VERT, ScrlBarPos, TRUE);
}

/****************************************/
/*					*/
/*	Draw Concave ractangle		*/
/*					*/
/****************************************/
void
CRefrList::DrawConcave(
CDC 	*dc,
CRect 	rect,
BOOL 	PtIn)
{
	CBrush	ConBrush, *OldBrush;
	CRect	Rt;

	Rt.SetRect( rect.left-1, rect.top-1, rect.right+1, rect.bottom+1);

	if( !PtIn){
		ConBrush.CreateSolidBrush( COLOR_HLIGHT);
		OldBrush = dc->SelectObject( &ConBrush);
		dc->PatBlt( Rt.left, Rt.top, Rt.Width(), 1, PATCOPY);
		dc->PatBlt( Rt.left, Rt.top, 1, Rt.Height(), PATCOPY);
		dc->SelectObject( OldBrush);
		ConBrush.DeleteObject();

		ConBrush.CreateSolidBrush( COLOR_SHADOW);
		OldBrush = dc->SelectObject( &ConBrush);
		dc->PatBlt( Rt.left, Rt.bottom, Rt.Width(), 1, PATCOPY);
		dc->PatBlt( Rt.right, Rt.top, 1, Rt.Height()+1, PATCOPY);
		dc->SelectObject( OldBrush);
		ConBrush.DeleteObject();

		if( FocusFlag){
			CBrush	fBrush;
			CPen 	fPen, *OldPen;

			fBrush.CreateStockObject( NULL_BRUSH);
			fPen.CreatePen( PS_SOLID, 1, COLOR_FACE);
			OldBrush = dc->SelectObject( &fBrush);
			OldPen   = dc->SelectObject( &fPen);
			dc->Rectangle( &rect);
			dc->SelectObject( OldBrush);
			dc->SelectObject( OldPen);
			fBrush.DeleteObject();
			fPen.DeleteObject();
		}
	}else{
		ConBrush.CreateSolidBrush( COLOR_SHADOW);
		OldBrush = dc->SelectObject( &ConBrush);
		dc->PatBlt( Rt.left, Rt.top, Rt.Width(), 1, PATCOPY);
		dc->PatBlt( Rt.left, Rt.top, 1, Rt.Height(), PATCOPY);
		dc->SelectObject( OldBrush);
		ConBrush.DeleteObject();

		ConBrush.CreateSolidBrush( COLOR_HLIGHT);
		OldBrush = dc->SelectObject( &ConBrush);
		dc->PatBlt( Rt.left, Rt.bottom, Rt.Width(), 1, PATCOPY);
		dc->PatBlt( Rt.right, Rt.top, 1, Rt.Height()+1, PATCOPY);
		dc->SelectObject( OldBrush);
		ConBrush.DeleteObject();

		if( FocusFlag){
			CBrush	fBrush;
			CPen 	fPen, *OldPen;

			fBrush.CreateStockObject( NULL_BRUSH);
			fPen.CreatePen( PS_SOLID, 1, COLOR_SHADOW);
			OldBrush = dc->SelectObject( &fBrush);
			OldPen   = dc->SelectObject( &fPen);
			dc->Rectangle( &rect);
			dc->SelectObject( OldBrush);
			dc->SelectObject( OldPen);
			fBrush.DeleteObject();
			fPen.DeleteObject();
		}
	}
}
/****************************************/
/*					*/
/*	MESSAGE	"WM_KEYDOWN"		*/
/*					*/
/****************************************/
void
CRefrList::OnKeyDown(
UINT 	nChar,
UINT 	nRepCnt,
UINT 	nFlags)
{
	int	sPos;
	int	ePos;

	if( nChar == VK_UP   || nChar == VK_DOWN ||
	    nChar == VK_LEFT || nChar == VK_RIGHT){
		sPos = GetBarPosition( ViewStart);
		ePos = GetBarPosition( SelectCode);
		if( ePos - sPos >= NUM_LINE || ePos < sPos){
			ViewStart = SelectCode & 0xfff0;
			ScrlBarPos = (short)GetBarPosition( ViewStart);
			this->Invalidate(FALSE);
			this->UpdateWindow();
		}

	    	switch( nChar){
		case VK_UP:
			if( SelectCode - NUM_CHAR < StartCode)
				break;
			if( SelectCode - NUM_CHAR < ViewStart){
				this->SendMessage(WM_VSCROLL, SB_LINEUP, 0);
			}
			SearchKeyPosition(FALSE);
			SelectCode = GetMinusCodeKey( SelectCode, NUM_CHAR);
			SearchKeyPosition(FALSE);
			break;
		case VK_DOWN:

			if( SelectCode + NUM_CHAR > EndCode)
				break;
			if( ePos - sPos >= NUM_LINE - 1){
				this->SendMessage(WM_VSCROLL, SB_LINEDOWN, 0);
			}
			SearchKeyPosition(FALSE);
			SelectCode = GetPlusCodeKey( SelectCode, NUM_CHAR);
			SearchKeyPosition(FALSE);
			break;
		case VK_LEFT:
			if( SelectCode - 1 < StartCode)
				break;
			if( SelectCode - 1 < ViewStart){
				this->SendMessage(WM_VSCROLL, SB_LINEUP, 0);
			}
			SearchKeyPosition(FALSE);
			SelectCode = GetMinusCodeKey( SelectCode, 1);
			SearchKeyPosition(FALSE);
			break;
		case VK_RIGHT:
			WORD 	TmpCode;
			int	TmpPos;

			if( SelectCode + 1 > EndCode)
				break;
			TmpCode = GetPlusCodeKey( SelectCode, 1);
			sPos = GetBarPosition( ViewStart);
			ePos = GetBarPosition( SelectCode);
			TmpPos = GetBarPosition( TmpCode);
			if( TmpPos - sPos >= NUM_LINE){
				this->SendMessage(WM_VSCROLL, SB_LINEDOWN, 0);
			}
			SearchKeyPosition(FALSE);
			SelectCode = GetPlusCodeKey( SelectCode, 1);
			SearchKeyPosition(FALSE);
			break;
		}

	}else 	CEdit::OnKeyDown(nChar, nRepCnt, nFlags);
}

/****************************************/
/*					*/
/*	Search focus position		*/
/*					*/
/****************************************/
void
CRefrList::SearchKeyPosition(
BOOL	Flg)
{
	CRect	test;
	int	sViewPt, sCodePt;
	int	sType, eType;
unsigned int	i, j;

	sViewPt = GetBarPosition( ViewStart);
	sCodePt = GetBarPosition( SelectCode);
	if(( sViewPt > sCodePt || abs( sCodePt - sViewPt) >= NUM_LINE) && Flg){
		this->Invalidate( FALSE);
		return;
	}
	i = (unsigned int)(sCodePt - sViewPt);
	j = (unsigned int)(SelectCode & 0x000f);
/*
	sType = CheckCharType( ViewStart);
	eType = CheckCharType( SelectCode);
	if( sType != eType && sType != CHAR_SBCS)
		i++;
*/
	test.SetRect( rcReferChar[i][j].left - 2,
		      rcReferChar[i][j].top - 2,
		      rcReferChar[i][j].right + 2,
		      rcReferChar[i][j].bottom + 2);
	this->InvalidateRect( &test, FALSE);
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_SETFOCUS"		*/
/*					*/
/****************************************/
void
CRefrList::OnSetFocus(
CWnd* 	pOldWnd)
{
	CEdit::OnSetFocus(pOldWnd);
	this->HideCaret();
	FocusFlag = TRUE;
	SearchKeyPosition(TRUE);
	this->UpdateWindow();
}

/****************************************/
/*					*/
/*	SearchCode			*/
/*					*/
/****************************************/
BOOL
CRefrList::IsCorrectChar(
UINT 	i,
UINT 	j)
{
	int	sViewPt, CharType;
	WORD	wCode;
	WORD	sOffset;
	BOOL	flg;

	flg = FALSE;
	BottomCode = (WORD)GetBarPosition((WORD)ViewEnd);
	sViewPt = GetBarPosition( ViewStart);
	wCode = GetCodeScrPos( sViewPt + i);
	wCode |= j;	

/*
	CharType = CheckCharType( wCode);	
	sOffset = wCode & 0x00ff;
	if( CharType == CHAR_SBCS){
		if( sOffset >= LoByteRange[0][CHN] &&
		    sOffset <= LoByteRange[0][CHN+1])
		    	flg = TRUE;
	}else{
		if(( sOffset >= LoByteRange[1][CHN] &&
		     sOffset <= LoByteRange[1][CHN+1]) ||
		   ( sOffset >= LoByteRange[2][CHN] &&
		     sOffset <= LoByteRange[2][CHN+1]) ||
		   ( sOffset >= LoByteRange[3][CHN] &&
		     sOffset <= LoByteRange[3][CHN+1]))
		     	flg = TRUE;
	}

	return flg;
*/
	return TRUE;
}

/****************************************/
/*					*/
/*	Increase key focus		*/
/*					*/
/****************************************/
WORD
CRefrList::GetPlusCodeKey(
WORD 	Code,
int 	ScrollNum)
{
  /*
	WORD	PrevCode;
	WORD 	LowByte, HighByte;
	WORD	LLByte;
	int	CharType;
	int	CharType1, CharType2;
	int	Offset;
  */
	Code += (WORD)ScrollNum;
	/*
  PrevCode = (WORD)(Code - (WORD)ScrollNum);
	CharType1 = CheckCharType( PrevCode);
	CharType2 = CheckCharType( Code);
	if( CharType1 != CharType2){
		if( CharType1 == CHAR_EUDC)
			Code = PrevCode;		
		else{
			Offset = Code - HiByteRange[CharType1][CHN+1];
			Code = (WORD)( HiByteRange[CharType1+1][CHN] +Offset-1);
		}
	}
	CharType = CheckCharType( Code);
	if( CharType != CHAR_SBCS){
		LowByte  = Code & 0x00ff;
		HighByte = Code & 0xff00;
		LLByte	 = Code & 0x000f;
		if( LowByte <= LoByteRange[4][CHN+1] &&
		    LowByte >= LoByteRange[4][CHN] ){
			LowByte = 0x0040 + LLByte;
		}
		Code = ( HighByte | LowByte);
	}*/
	return Code;
}
					
/****************************************/
/*					*/
/*	Decrease focus key		*/
/*					*/
/****************************************/
WORD
CRefrList::GetMinusCodeKey(
WORD 	Code,
int 	ScrollNum)
{
  /*
	WORD	PrevCode;
	WORD	LLByte;
	int	CharType;
	int	CharType1, CharType2;
	int	Offset;
  */
	Code -= (WORD)ScrollNum;
  /*
	PrevCode = (WORD)( Code + (WORD)ScrollNum);
	CharType1 = CheckCharType( Code);
	CharType2 = CheckCharType( PrevCode);
	if( CharType1 != CharType2){
	 	if( CharType2 == CHAR_SBCS)
			return (WORD)HiByteRange[CHAR_SBCS][CHN];
		else{
			Offset = HiByteRange[CharType2][CHN] - Code;
			return (WORD)(HiByteRange[CharType2-1][CHN+1]-Offset+1);
		}	
	}
	CharType = CheckCharType( Code);
	if( CharType != CHAR_SBCS){
		WORD 	LowByte;
		WORD	HighByte;
		WORD	Tmp;

		LowByte  = Code & 0x00ff;
		HighByte = Code & 0xff00;
		LLByte	 = Code & 0x000f;
		if( LowByte <= LoByteRange[4][CHN+1] &&
		    LowByte >= LoByteRange[4][CHN] ){
			LowByte = 0xf0 + LLByte;
			Tmp = ( HighByte >> 8);
			Tmp -= 0x1;
			HighByte = Tmp << 8;
		}
		Code = ( HighByte | LowByte);
	}*/
	return Code;
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_KILLFOCUS"		*/
/*					*/
/****************************************/
void
CRefrList::OnKillFocus(
CWnd* 	pNewWnd)
{
	CEdit::OnKillFocus(pNewWnd);
	FocusFlag = FALSE;
	SearchKeyPosition(TRUE);
	this->UpdateWindow();
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_RBUTTONUP"		*/
/*					*/
/****************************************/
void
CRefrList::OnRButtonUp(
UINT 	nFlags,
CPoint 	point)
{
	GetParent()->SendMessage( WM_CONTEXTMENU, (WPARAM)this->GetSafeHwnd(), 0);
}

BEGIN_MESSAGE_MAP( CRefListFrame, CStatic)
	//{{AFX_MSG_MAP( CRefListFrame)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/****************************************/
/*					*/
/*	Default Constructor		*/
/*					*/
/****************************************/
CRefListFrame::CRefListFrame()
{
}

/****************************************/
/*					*/
/*		Destructor		*/
/*					*/
/****************************************/
CRefListFrame::~CRefListFrame()
{
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_PAINT"		*/
/*					*/
/****************************************/
void
CRefListFrame::OnPaint()
{
	CRect	FrameRect;
	CPaintDC	dc( this);

	this->GetClientRect( &FrameRect);
	this->DrawConcave( &dc, FrameRect);
}

/****************************************/
/*					*/
/*	Draw Concave Rect		*/
/*					*/				
/****************************************/
void
CRefListFrame::DrawConcave(
CDC 	*dc,
CRect 	rect)
{
	CBrush	ConBrush, *OldBrush;
	CRect	Rt;

	Rt.SetRect( rect.left-1, rect.top-1, rect.right, rect.bottom);

	ConBrush.CreateSolidBrush( COLOR_HLIGHT);
	OldBrush = dc->SelectObject( &ConBrush);
	dc->PatBlt( Rt.left, Rt.top, Rt.Width(), 1, PATCOPY);
	dc->PatBlt( Rt.left, Rt.top, 1, Rt.Height(), PATCOPY);
	dc->SelectObject( OldBrush);
	ConBrush.DeleteObject();

	ConBrush.CreateSolidBrush( COLOR_SHADOW);
	OldBrush = dc->SelectObject( &ConBrush);
	dc->PatBlt( Rt.left, Rt.bottom, Rt.Width(), 1, PATCOPY);
	dc->PatBlt( Rt.right, Rt.top, 1, Rt.Height()+1, PATCOPY);
	dc->SelectObject( OldBrush);
	ConBrush.DeleteObject();
}

BEGIN_MESSAGE_MAP( CRefInfoFrame, CStatic)
	//{{AFX_MSG_MAP( CRefInfoFrame)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/****************************************/
/*					*/
/*	Default Constructor		*/
/*					*/
/****************************************/
CRefInfoFrame::CRefInfoFrame()
{
}

/****************************************/
/*					*/
/*	Destructor			*/
/*					*/
/****************************************/
CRefInfoFrame::~CRefInfoFrame()
{
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_PAINT"		*/
/*					*/
/****************************************/
void
CRefInfoFrame::OnPaint()
{
	CRect	FrameRect;
	CPaintDC	dc( this);

	this->GetClientRect( &FrameRect);
	this->DrawConcave( &dc, FrameRect);
}

/****************************************/
/*					*/
/*	Draw Concave Rect		*/
/*					*/
/****************************************/
void
CRefInfoFrame::DrawConcave(
CDC 	*dc,
CRect 	rect)
{
	CBrush	ConBrush, *OldBrush;
	CRect	Rt;

	Rt.SetRect( rect.left-1, rect.top-1, rect.right, rect.bottom);

	ConBrush.CreateSolidBrush( COLOR_SHADOW);
	OldBrush = dc->SelectObject( &ConBrush);
	dc->PatBlt( Rt.left, Rt.top, Rt.Width(), 1, PATCOPY);
	dc->PatBlt( Rt.left, Rt.top, 1, Rt.Height(), PATCOPY);
	dc->SelectObject( OldBrush);
	ConBrush.DeleteObject();

	ConBrush.CreateSolidBrush( COLOR_HLIGHT);
	OldBrush = dc->SelectObject( &ConBrush);
	dc->PatBlt( Rt.left, Rt.bottom, Rt.Width(), 1, PATCOPY);
	dc->PatBlt( Rt.right, Rt.top, 1, Rt.Height()+1, PATCOPY);
	dc->SelectObject( OldBrush);
	ConBrush.DeleteObject();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\refrwnd.h ===
/**************************************************/
/*                                           */
/*                                           */
/* MDI Child Window (reference)                */
/*                                           */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include <afxtempl.h>
class CRefrWnd : public CMDIChildWnd
{
   DECLARE_DYNCREATE(CRefrWnd)
public:
   CRefrWnd();       
   BOOL Create( LPCTSTR szTitle, LONG Style, RECT ReffWndRect, CMDIFrameWnd* Parent);
   BOOL UpdateBitmap();
   void CaptionDraw();

private:
   void DrawFreeForm( BOOL MouseSts);
   void SelectFreeForm( BOOL MouseSts);
   BOOL CreateNewBitmap();
   BOOL ClipPickValueInit();
   BOOL InitSelectLogfont();
   BOOL ClipImageCopy();
   BOOL LoadCloseBitmap();
   void DrawGridLine( CDC *dc);
// void CaptionDraw( CDC *dc);
   void RubberBand( BOOL TestFlag);
   void RubberBandPaint( CDC *dc);
   void IllegalRect( PPOINT ptTL, PPOINT ptBR);
   void CorrectMouseDownPt( CPoint point);
   void CorrectMouseUpPt( CPoint point);
   void MoveRectangle( CPoint point);

public:
   BOOL  GridShow;
   WORD  ReferCode;
   BOOL  RectVisible;
   BOOL  bFocus;
   int   SelectItems;

private:
   CBitmapButton  CloseBtm;
   CBitmap  ImageBmp;
   CDC   ImageDC;
   BOOL  IsCapture;
   BOOL  ValidateFlag;
   CPoint   ptStart;
   CPoint   ptEnd;
   CPoint   ptPrev;
   CPoint   m_ptMouse;
   CPoint   m_ptLast;
   int   ZoomRate;
   UINT  ClipboardFormat;
   CRect PickRect;
   CRect MoveRect;
   CRect ReffWndRect;
   CRgn  FreeRgn, PickRgn;
   CArray<CPoint,CPoint>   m_pointArray;
   CArray<CPoint,CPoint>   m_selectArray;
   BOOL  m_bCloseOnLeft;

protected:
   virtual ~CRefrWnd();
   static CMenu NEAR menu;

   //{{AFX_MSG(CRefrWnd)
   afx_msg void OnClickClose();
   afx_msg void OnPaint();
   afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
   afx_msg void OnSize(UINT nType, int cx, int cy);
   afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
   afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
   afx_msg void OnMouseMove(UINT nFlags, CPoint point);
   afx_msg void OnGaijiCopy();   
   afx_msg void OnUpdateGaijiCopy( CCmdUI* pCmdUI);
   afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
   afx_msg void OnMDIActivate(BOOL bActivate, CWnd* pActivateWnd, CWnd* pDeactivateWnd);                          
   afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    //afx_msg void OnActivate( UINT nState, CWnd* pWndOther, BOOL bMinimized );
    //afx_msg int OnMouseActivate( CWnd* pDesktopWnd, UINT nHitTest, UINT message );

   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\registry.cpp ===
/**************************************************/
/*					                              */
/*					                              */
/*	Registry Key Function		                  */
/*					                              */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include 	"stdafx.h"
#include 	"eudcedit.h"
#include 	"registry.h"
#include	"util.h"

static TCHAR subkey1[] = TEXT("EUDC");
static TCHAR subkey2[] = TEXT("System\\CurrentControlSet\\control\\Nls\\Codepage\\EUDCCodeRange");
static TCHAR SubKey[MAX_PATH];

#ifdef IN_FONTS_DIR // IsFileUnderWindowsRoot()
LPTSTR
IsFileUnderWindowsRoot(
LPTSTR TargetPath)
{
    TCHAR  WindowsRoot[MAX_PATH+1];
    UINT  WindowsRootLength;

    WindowsRootLength = GetSystemWindowsDirectory(WindowsRoot,MAX_PATH);

    if( lstrcmpi(WindowsRoot,TargetPath) == 0)
        return (TargetPath + WindowsRootLength);

    return NULL;
}

void AdjustTypeFace(WCHAR *orgName, WCHAR *newName)
{ 
  if (!lstrcmpW(orgName, L"\x5b8b\x4f53"))
    lstrcpy(newName, TEXT("Simsun"));
  else if (!lstrcmpW(orgName, L"\x65b0\x7d30\x660e\x9ad4"))
    lstrcpy(newName, TEXT("PMingLiU"));
  else if (!lstrcmpW(orgName, L"\xFF2d\xFF33\x0020\xFF30\x30b4\x30b7\x30c3\x30af"))
    lstrcpy(newName, TEXT("MS PGothic"));
  else if (!lstrcmpW(orgName, L"\xad74\xb9bc"))
    lstrcpy(newName, TEXT("Gulim"));
  else
    lstrcpy(newName, orgName);
}

#endif // IN_FONTS_DIR

/****************************************/
/*					*/
/*	Inquiry EUDC registry		*/
/*					*/
/****************************************/
BOOL
InqTypeFace(
TCHAR 	*typeface,
TCHAR 	*filename,
INT 	bufsiz)
{
	HKEY 	phkey;
	DWORD 	cb, dwType;
	LONG 	rc;
	TCHAR	FaceName[LF_FACESIZE];
	TCHAR	SysName[LF_FACESIZE];
#ifdef BUILD_ON_WINNT // InqTypeFace()
    TCHAR    FileName[MAX_PATH];
#endif // BUILD_ON_WINNT

	GetStringRes(SysName, IDS_SYSTEMEUDCFONT_STR);
	if( !lstrcmp(typeface, SysName)){
		lstrcpy(FaceName,TEXT("SystemDefaultEUDCFont"));
  }else {
#ifdef IN_FONTS_DIR
    AdjustTypeFace(typeface, FaceName);
#else
    lstrcpy(FaceName, typeface);
#endif
  }
	if( RegOpenKeyEx( HKEY_CURRENT_USER, (LPCTSTR)SubKey, 0,
	    KEY_ALL_ACCESS, &phkey) != ERROR_SUCCESS){
		return FALSE;
	}

#ifdef IN_FONTS_DIR // InqTypeFace()
	cb = (DWORD)MAX_PATH*sizeof(WORD)/sizeof(BYTE);
	rc = RegQueryValueEx(phkey, FaceName, 0, &dwType, 
		(LPBYTE)FileName, &cb);
	RegCloseKey(phkey);

    /*
     * if there is some error or no data, just return false.
     */
    if ((rc != ERROR_SUCCESS) || (FileName[0] == '\0')) {
        return (FALSE);
    }

    /*
     * expand %SystemRoot% to Windows direcotry.
     */
    ExpandEnvironmentStrings((LPCTSTR)FileName,(LPTSTR)filename,bufsiz);
#else
	cb = (DWORD)bufsiz*sizeof(WORD)/sizeof(BYTE);
	rc = RegQueryValueEx(phkey, (TCHAR *)FaceName, 0, &dwType, 
		(LPBYTE)filename, &cb);
	RegCloseKey(phkey);

	if ((rc != ERROR_SUCCESS) || (filename[0] == '\0')) {
        return (FALSE);
    }
#endif // IN_FONTS_DIR

#ifdef BUILD_ON_WINNT // InqTypeFace()
    /*
     * if this is not 'full path'. Build 'full path'.
     *
     *   EUDC.TTE -> C:\WINNT40\FONTS\EUDC.TTE
     *               0123456...
     *
     * 1. filename should have drive letter.
     * 2. filename should have one '\\' ,at least, for root.
     */
    if ((filename[1] != ':') || (Mytcsstr((const TCHAR *)filename,TEXT("\\")) == NULL)) {
        /* backup original.. */
        lstrcpy(FileName, (const TCHAR *)filename);

        /* Get windows directory */
        GetSystemWindowsDirectory((TCHAR *)filename, MAX_PATH);

#ifdef IN_FONTS_DIR // InqTypeFace()
        lstrcat((TCHAR *)filename, TEXT("\\FONTS\\"));
#else
        strcat((char *)filename, "\\");
#endif // IN_FONTS_DIR
        lstrcat((TCHAR *) filename, FileName);
    }
#endif // BUILD_ON_WINNT

#ifdef IN_FONTS_DIR // InqTypeFace()
	return (TRUE);
#else
	return rc == ERROR_SUCCESS && filename[0] != '\0' ? TRUE : FALSE;
#endif
}

/****************************************/
/*					*/
/*	Registry EUDC font and file	*/
/*					*/
/****************************************/
BOOL 
RegistTypeFace(
TCHAR 	*typeface, 
TCHAR	*filename)
{
	HKEY 	phkey;
	LONG 	rc;
	TCHAR	FaceName[LF_FACESIZE];
	TCHAR	SysName[LF_FACESIZE];
#ifdef IN_FONTS_DIR // RegistTypeFace()
    LPTSTR   SaveFileName;
    TCHAR    FileName[MAX_PATH];
#endif // IN_FONTS_DIR

	GetStringRes((TCHAR *)SysName, IDS_SYSTEMEUDCFONT_STR);
	if( !lstrcmp((const TCHAR *)typeface, (const TCHAR *)SysName)){
		lstrcpy(FaceName, TEXT("SystemDefaultEUDCFont"));
  }else{
#ifdef IN_FONTS_DIR
    AdjustTypeFace(typeface, FaceName);
#else
    lstrcpy(FaceName, (const TCHAR *)typeface);
#endif
  }
	if( RegOpenKeyEx( HKEY_CURRENT_USER, (LPCTSTR)SubKey, 0,
	    KEY_ALL_ACCESS, &phkey) != ERROR_SUCCESS){
		return FALSE;
	}

#ifdef IN_FONTS_DIR // RegistTypeFace()
    /*
     * if registry data contains full path, and the file is under windows
     * directory, replace the hardcodeed path with %SystemRoot%....
     */
    if( (SaveFileName = IsFileUnderWindowsRoot((LPTSTR)filename)) != NULL) {
        lstrcpy(FileName, TEXT("%SystemRoot%"));
        if( *SaveFileName != '\\' ) lstrcat(FileName, TEXT("\\"));
        lstrcat(FileName, SaveFileName );
    } else {
        lstrcpy(FileName, (TCHAR *)filename );
    }
	rc = RegSetValueEx( phkey, (LPCTSTR)FaceName, 0,
		REG_SZ, (const BYTE *)FileName, (lstrlen((LPCTSTR)FileName)+1)*sizeof(WORD)/sizeof(BYTE));
#else
	rc = RegSetValueEx( phkey, (LPCTSTR)FaceName, 0,
		REG_SZ, (const BYTE *)filename, (lstrlen((LPCTSTR)filename)+1)*sizeof(WORD)/sizeof(BYTE));
#endif // IN_FONTS_DIR
	RegCloseKey(phkey);
	return rc == ERROR_SUCCESS ? TRUE : FALSE;
}

/****************************************/
/*					*/
/*	Delete Registry string		*/
/*					*/
/****************************************/
BOOL 
DeleteReg( 
TCHAR	*typeface)
{
	HKEY phkey;
	LONG rc;
	TCHAR	FaceName[LF_FACESIZE];
	TCHAR	SysName[LF_FACESIZE];

	GetStringRes((TCHAR *)SysName, IDS_SYSTEMEUDCFONT_STR);
	if( !lstrcmp((const TCHAR *)typeface, (const TCHAR *)SysName)){
		lstrcpy((TCHAR *)FaceName, TEXT("SystemDefaultEUDCFont"));
  }else{
#ifdef IN_FONTS_DIR
    AdjustTypeFace(typeface, FaceName);
#else
    lstrcpy((TCHAR *)FaceName, (const TCHAR *)typeface);
#endif
  }
	if( RegOpenKeyEx(HKEY_CURRENT_USER, (LPCTSTR)SubKey, 0,
	    KEY_ALL_ACCESS, &phkey) != ERROR_SUCCESS){
		return FALSE;
	}
	rc = RegDeleteValue( phkey, (LPTSTR)FaceName);
	RegCloseKey(phkey);

	return rc == ERROR_SUCCESS ? TRUE : FALSE;
}

/****************************************/
/*					*/
/*	Create Registry Subkey		*/
/*					*/
/****************************************/
BOOL
CreateRegistrySubkey()
{
	HKEY 	phkey;
	DWORD 	dwdisp;
    int	    LocalCP;
	TCHAR	CodePage[10];
	int	result;

	/* New Registry	*/
	LocalCP = GetACP();

  	wsprintf( CodePage, TEXT("%d"), LocalCP);
    lstrcpy(SubKey, subkey1);
	lstrcat(SubKey, TEXT("\\"));
	lstrcat(SubKey, CodePage);

	if( RegOpenKeyEx( HKEY_CURRENT_USER, (LPCTSTR)SubKey, 0,
	    KEY_ALL_ACCESS, &phkey) != ERROR_SUCCESS){
		result = RegCreateKeyEx(HKEY_CURRENT_USER, 
			(LPCTSTR)SubKey, 0, TEXT(""),
			REG_OPTION_NON_VOLATILE, 
			KEY_ALL_ACCESS, NULL, &phkey, &dwdisp);
		if( result == ERROR_SUCCESS)
			RegCloseKey( phkey);
		else	return FALSE;
	}else 	RegCloseKey(phkey);

	return TRUE;
}

/****************************************/
/*					*/
/*	Inquiry Code range registry	*/
/*					*/
/****************************************/
BOOL 
InqCodeRange( 
TCHAR 	*Codepage, 
BYTE 	*Coderange, 
INT 	bufsiz)
{
	HKEY phkey;
	DWORD cb, dwType;
	LONG rc;

	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPCTSTR)subkey2, 0,
	    KEY_READ, &phkey) != ERROR_SUCCESS) {
		return FALSE;
	}
	cb = (DWORD)bufsiz * sizeof(WORD)/sizeof(BYTE);
	rc = RegQueryValueEx(phkey, (TCHAR *)Codepage, 0, &dwType, 
		(LPBYTE)Coderange, &cb);

	RegCloseKey(phkey);

	return rc == ERROR_SUCCESS && Coderange[0] != '\0' ? TRUE : FALSE;
}

BOOL
DeleteRegistrySubkey()
{
	HKEY 	phkey;

	if( RegOpenKeyEx( HKEY_CURRENT_USER, (LPCTSTR)SubKey, 0,
	    KEY_ALL_ACCESS, &phkey) == ERROR_SUCCESS){
		RegCloseKey(phkey);
		return RegDeleteKey(HKEY_CURRENT_USER, (LPCTSTR)SubKey);
	
	}

	return TRUE;
}

BOOL
FindFontSubstitute(TCHAR *orgFontName, TCHAR *sbstFontName)
{
  static TCHAR fsKey[] = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes");

  *sbstFontName = 0;
  lstrcpy(sbstFontName, orgFontName);
	HKEY phkey;

	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPCTSTR)fsKey, 0,
	    KEY_QUERY_VALUE, &phkey) != ERROR_SUCCESS) {
		return FALSE;
	}

  DWORD valueNameSize = LF_FACESIZE + 50; //should be facename + ',' + codepage
  TCHAR valueName[LF_FACESIZE + 50]; 
  DWORD valueType;
  DWORD valueDataSize = (LF_FACESIZE + 50) * sizeof(TCHAR); //should be facename + ',' + codepage
  BYTE  valueData[(LF_FACESIZE + 50) * sizeof(TCHAR)];
  LONG  ret;
  DWORD idx = 0;
  while ((ret = RegEnumValue(phkey, idx, valueName, &valueNameSize, 0, 
                        &valueType, valueData, &valueDataSize)) != ERROR_NO_MORE_ITEMS)
  {
    if (ret != ERROR_SUCCESS)
    {
      RegCloseKey(phkey);
      return FALSE;
    }
    Truncate(valueName, _T(','));
    if (!lstrcmpi(valueName, orgFontName))
    {
      Truncate((TCHAR *)valueData, _T(','));
      lstrcpy(sbstFontName, (TCHAR *)valueData);
      break;
    }
    idx ++;
    valueNameSize = LF_FACESIZE + 50;
    valueDataSize = (LF_FACESIZE + 50) * sizeof(TCHAR); 
  } 
  
  RegCloseKey(phkey);
  return TRUE;
}

void Truncate(TCHAR *str, TCHAR delim)
{
  TCHAR *pchr = _tcschr(str, delim);
  if (pchr)
    *pchr = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\refrwnd.cpp ===
/**************************************************/
/*                                           */
/*                                           */
/* MDI Child Window( Reference)                */
/*                                           */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include    "stdafx.h"
#include    "eudcedit.h"
#include    "refrwnd.h"
#include    "editwnd.h"
#include    "mainfrm.h"

#define     FREELIAIS   1000

LOGFONT     ReffLogFont;
CBitmap     DupBmp;
CRect    DupRect;

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
extern CEditWnd *pEditChild;

CMenu NEAR CRefrWnd::menu;
IMPLEMENT_DYNCREATE(CRefrWnd, CMDIChildWnd)
BEGIN_MESSAGE_MAP(CRefrWnd, CMDIChildWnd)
   //{{AFX_MSG_MAP(CRefrWnd)
   ON_BN_CLICKED( IDB_CLOSE_REF, OnClickClose)
   ON_WM_PAINT()
   ON_WM_CREATE()
   ON_WM_SIZE()
   ON_WM_LBUTTONDOWN()
   ON_WM_LBUTTONUP()
   ON_WM_MOUSEMOVE()
   ON_COMMAND(ID_GAIJI_COPY, OnGaijiCopy)
   ON_UPDATE_COMMAND_UI(ID_GAIJI_COPY, OnUpdateGaijiCopy)
   ON_WM_SETCURSOR()
   ON_WM_MDIACTIVATE()
   ON_WM_KEYDOWN()
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/****************************************/
/*             */
/* Create reference Window    */
/*             */
/****************************************/
BOOL
CRefrWnd::Create(
LPCTSTR  szTitle,
LONG  Style,
RECT  ReffWndRect,
CMDIFrameWnd* Parent)
{
// Set Mainframe menu for reference
   if( menu.m_hMenu == NULL)
      menu.LoadMenu( IDR_MAINFRAME);
   m_hMenuShared = menu.m_hMenu;

// Register WindowClass
   const TCHAR *pszReffWndClass =
      AfxRegisterWndClass( CS_BYTEALIGNCLIENT,
         NULL, (HBRUSH)(COLOR_WINDOW + 1), NULL);

   return CMDIChildWnd::Create( pszReffWndClass,
         szTitle, Style, ReffWndRect, Parent);
}

/****************************************/
/*             */
/* Process before window create  */
/*             */
/****************************************/
int
CRefrWnd::OnCreate(
LPCREATESTRUCT lpCreateStruct)
{
   if( CMDIChildWnd::OnCreate( lpCreateStruct) == -1)
      return -1;
// Check if m_hWnd is mirrored then we need to set the colse button on the other side.
   m_bCloseOnLeft = (BOOL)(GetWindowLongPtr(m_hWnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL);
// Then turn off miroring if any.
   if (m_bCloseOnLeft) {
       ModifyStyleEx( WS_EX_LAYOUTRTL, 0);
   }

   if( !CreateNewBitmap())
      return -1;
   if( !ClipPickValueInit())
      return -1;
   if( !InitSelectLogfont())
      return -1;
   if( !LoadCloseBitmap())
      return -1;

   return 0;
}

/****************************************/
/*             */
/* Create New Bitmap    */
/*             */
/****************************************/
BOOL
CRefrWnd::CreateNewBitmap()
{
   WORD  wSize;
   HANDLE   BmpHdl;
   BYTE  *pBmp;

   CClientDC   dc( this);

   if( !ImageDC.CreateCompatibleDC( &dc))
      return FALSE;

   wSize = (WORD)((( BITMAP_WIDTH +15) /16) *2) *(WORD)BITMAP_HEIGHT;
   if(( BmpHdl = LocalAlloc( LMEM_MOVEABLE, wSize)) == 0)
      return FALSE;

   if(( pBmp = (BYTE *)LocalLock( BmpHdl)) == NULL){
      LocalUnlock( BmpHdl);
      LocalFree( BmpHdl);
      return FALSE;
   }
   memset( pBmp, 0xffff, wSize);
   if( !ImageBmp.CreateBitmap( BITMAP_WIDTH, BITMAP_HEIGHT,
       1, 1, (LPSTR)pBmp)){
      LocalUnlock( BmpHdl);
      LocalFree( BmpHdl);
      return FALSE;
   }
   LocalUnlock( BmpHdl);
   LocalFree( BmpHdl);
   ImageDC.SelectObject( &ImageBmp);

   return TRUE;
}

/****************************************/
/*             */
/* Initialize clipboard format   */
/*             */
/****************************************/
BOOL
CRefrWnd::ClipPickValueInit()
{
   if( !( ClipboardFormat = RegisterClipboardFormat(TEXT("EudcEdit"))))
      return FALSE;
   else  return TRUE;
}

/****************************************/
/*             */
/* Initialize selected logfont   */
/*             */
/****************************************/
BOOL
CRefrWnd::InitSelectLogfont()
{
   CFont cFont;

#ifdef BUILD_ON_WINNT
   cFont.CreateStockObject(DEFAULT_GUI_FONT);
#else
   cFont.CreateStockObject( SYSTEM_FONT);
#endif
   cFont.GetObject( sizeof(LOGFONT), &ReffLogFont);
   cFont.DeleteObject();

   return TRUE;
}

/****************************************/
/*             */
/* Load Close Bitmap (to close)  */
/*             */
/****************************************/
BOOL
CRefrWnd::LoadCloseBitmap()
{
   CRect rect;

   this->GetClientRect( &rect);
   rect.top = 2;
   rect.bottom = CAPTION_HEIGHT - 2;
   rect.right -= 2;
   rect.left = rect.right - ( rect.bottom - rect.top) - 5;

   if( !CloseBtm.Create( NULL, WS_CHILD | WS_VISIBLE | BS_OWNERDRAW |
       WS_EX_TOPMOST | BS_PUSHBUTTON, rect, this, IDB_CLOSE_REF) ||
       !CloseBtm.LoadBitmaps( IDB_CLOSEBMP, IDB_CLOSEBMPP))
      return FALSE;
   else{
      CloseBtm.SizeToContent();
      return TRUE;
   }
}

/****************************************/
/*             */
/* Default Constructor     */
/*             */
/****************************************/
CRefrWnd::CRefrWnd()
{
   RectVisible = FALSE;
   IsCapture = FALSE;
   SelectItems = RECTCLIP;
   GridShow = TRUE;
   bFocus = FALSE;
   m_bCloseOnLeft = FALSE;
}

/****************************************/
/*             */
/* Destructor        */
/*             */
/****************************************/
CRefrWnd::~CRefrWnd()
{
   if( ImageBmp.Detach() != NULL)
      ImageBmp.DeleteObject();
   if( ImageDC.Detach() != NULL)
      ImageDC.DeleteDC();
  menu.DestroyMenu();
}

/****************************************/
/*             */
/* MESSAGE "WM_PAINT"      */
/*             */
/****************************************/
void
CRefrWnd::OnPaint()
{
   CString  WndCaption;
   CFont RefferFont;
   BYTE  sWork[10];
   CSize CharSize;
   short    xOffset, yOffset;
   int   Length;

   CPaintDC dc( this);

   this->GetClientRect( &ReffWndRect);

   ZoomRate = ReffWndRect.right /BITMAP_WIDTH;
   ReffLogFont.lfHeight  = BITMAP_HEIGHT; 
   ReffLogFont.lfWidth  = 0;  
   ReffLogFont.lfQuality = PROOF_QUALITY;
   if( !RefferFont.CreateFontIndirect( &ReffLogFont))
      return;
   CFont *OldFont = ImageDC.SelectObject( &RefferFont);

   if( !ReferCode)
      Length = 0;
/*
   else if( !(ReferCode & 0xff00)){
//    SBCS
      sWork[0] = (BYTE)( ReferCode & 0x00ff);
      sWork[1] = (BYTE)'\0';
      Length = 1;
   }else{
//    DBCS
      sWork[0] = (BYTE)(( ReferCode & 0xff00) >> 8);
      sWork[1] = (BYTE)( ReferCode & 0x00ff);
      sWork[2] = (BYTE)'\0';
      Length = 2;
   }
*/
  else
  {
    sWork[0] = LOBYTE(ReferCode);
    sWork[1] = HIBYTE(ReferCode);
    Length = 1;
  }
   if( Length){
      CRect TextImage;

      GetTextExtentPoint32W( ImageDC.GetSafeHdc(), (const unsigned short *)sWork,
         Length, &CharSize);
/*
      GetTextExtentPoint32A( ImageDC.GetSafeHdc(), (LPCSTR)sWork,
         Length, &CharSize);*/
      TextImage.SetRect( 0, 0, BITMAP_WIDTH, BITMAP_HEIGHT);

      if( CharSize.cx < BITMAP_WIDTH)
         xOffset = (short)(( BITMAP_HEIGHT - CharSize.cx) /2);
      else  xOffset = 0;
      if( CharSize.cy < BITMAP_HEIGHT)
         yOffset = (short)(( BITMAP_WIDTH  - CharSize.cy) /2);
      else  yOffset = 0;
/*
      if( ReffLogFont.lfFaceName[0] == '@' && Length == 2)
         xOffset = yOffset = 0;
*/
      if( ReffLogFont.lfFaceName[0] == '@' && Length == 1)
         xOffset = yOffset = 0;
/*
      ExtTextOutA(ImageDC.GetSafeHdc(), xOffset, yOffset, ETO_OPAQUE,
            &TextImage, (LPCSTR)sWork, Length, NULL);
*/
      ExtTextOutW(ImageDC.GetSafeHdc(), xOffset, yOffset, ETO_OPAQUE,
            &TextImage, (const unsigned short *)sWork, Length, NULL);
   }

   dc.StretchBlt( 0, CAPTION_HEIGHT, ReffWndRect.Width(),
         ReffWndRect.Height() - CAPTION_HEIGHT,
         &ImageDC, 0, 0, BITMAP_WIDTH, BITMAP_HEIGHT,SRCCOPY);

   CRect rect;

   rect.CopyRect( &ReffWndRect);
   rect.top = 2;
   rect.bottom = CAPTION_HEIGHT - 2;
   if (m_bCloseOnLeft) {
       rect.left += 2;
       rect.right = rect.left + ( rect.bottom - rect.top) - 2;
   } else {
       rect.right -= 2;
       rect.left = rect.right - ( rect.bottom - rect.top) - 2;
   }
   CloseBtm.SetWindowPos( NULL, rect.left, rect.top,
         0, 0, SWP_NOSIZE );

   CaptionDraw();

   if( RectVisible)
      RubberBandPaint( &dc);
   if( GridShow && ZoomRate >= 2)
      DrawGridLine( &dc);

   ImageDC.SelectObject( OldFont);
   RefferFont.DeleteObject();
   return;
}

/****************************************/
/*             */
/* Draw Caption         */
/*             */
/****************************************/
void
CRefrWnd::CaptionDraw()
{
COLORREF TextColor;
   CString  WndCaption;
   CRect CaptionRect;
   CBrush   CaptionBrush;
   CFont *OldFont;
   int   BkMode;
   CDC    dc;
   dc.Attach( ::GetDC( this->GetSafeHwnd()));


// Get brush with active caption color    
   CaptionRect.CopyRect( &ReffWndRect);
   if (bFocus)
   {
      CaptionBrush.CreateSolidBrush(::GetSysColor( COLOR_ACTIVECAPTION));
   }
   else
   {
      CaptionBrush.CreateSolidBrush(::GetSysColor(COLOR_INACTIVECAPTION));
   }
   CaptionRect.bottom = CAPTION_HEIGHT;
   dc.FillRect( &CaptionRect, &CaptionBrush);
   CaptionBrush.DeleteObject();

// Get font to draw caption
#ifdef BUILD_ON_WINNT
   OldFont = (CFont *)dc.SelectStockObject(DEFAULT_GUI_FONT);
#else
   OldFont = (CFont *)dc.SelectStockObject(SYSTEM_FONT);
#endif
   BkMode = dc.SetBkMode( TRANSPARENT);
   if (bFocus)
   {
      TextColor = dc.SetTextColor( ::GetSysColor(COLOR_CAPTIONTEXT));
   }
   else
   {
      TextColor = dc.SetTextColor( ::GetSysColor(COLOR_INACTIVECAPTIONTEXT));
   }
   WndCaption.LoadString( IDS_REFERENCE_STR);
   dc.TextOut( ReffWndRect.right /2 - 30, 1, WndCaption);
   dc.SelectObject( OldFont);
   dc.SetTextColor( TextColor);
   dc.SetBkMode( BkMode);

   //
   // redraw the close button.
   //
   CloseBtm.Invalidate(FALSE);

   ::ReleaseDC( NULL, dc.Detach());
   return;
}
               
/****************************************/
/*             */
/* Draw Grid         */
/*             */
/****************************************/
void
CRefrWnd::DrawGridLine(
CDC   *dc)
{
   CPen  GlyphPen;
register int   i;

// Create pen to draw grid
   GlyphPen.CreatePen( PS_SOLID, 1, COLOR_GRID);
   CPen *OldPen = dc->SelectObject( &GlyphPen);

// Draw grid
   for( i = ZoomRate - 1; i < ReffWndRect.right; i += ZoomRate){
      dc->MoveTo( i, CAPTION_HEIGHT-1);
      dc->LineTo( i, ReffWndRect.bottom);
   }
   for( i =ZoomRate +CAPTION_HEIGHT -1;i<ReffWndRect.bottom;i += ZoomRate){
      dc->MoveTo( 0, i);
      dc->LineTo( ReffWndRect.right, i);
   }
   dc->SelectObject( OldPen);
   GlyphPen.DeleteObject();
}

/****************************************/
/*             */
/* Draw RubberBand         */
/*             */
/****************************************/
void
CRefrWnd::RubberBandPaint(
CDC   *dc)
{
   CPen  *OldPen;
   CBrush   *OldBrush;
   int   OldMode;

   OldPen = (CPen *)dc->SelectStockObject( BLACK_PEN);
   OldBrush = (CBrush *)dc->SelectStockObject( NULL_BRUSH);
   OldMode = dc->SetROP2( R2_NOTXORPEN);

   dc->Rectangle( &MoveRect);
   dc->SelectObject( OldPen);
   dc->SelectObject( OldBrush);
   dc->SetROP2( OldMode);
}

/****************************************/
/*             */
/* MESSAGE  "WM_LBUTTONDOWN"  */
/*             */
/****************************************/
void
CRefrWnd::OnLButtonDown(
UINT  ,
CPoint   point)
{
   CRect CaptionRect;

   CaptionRect.CopyRect( &ReffWndRect);
   CaptionRect.top = CAPTION_HEIGHT;
   if( !CaptionRect.PtInRect( point))
      return;

   IsCapture = TRUE;
   this->SetCapture();
   CorrectMouseDownPt( point);

   if( RectVisible){
      if( MoveRect.PtInRect( point)){
         RectVisible = FALSE;
         this->InvalidateRect( &MoveRect, FALSE);
         this->UpdateWindow();
         RectVisible = TRUE;
         m_ptMouse.x = point.x - MoveRect.left;
         m_ptMouse.y = point.y - MoveRect.top;
         this->ClientToScreen( &point);
         MoveRectangle( point);
         m_ptLast = point;
         return;
      }else{
         RectVisible = FALSE;
         this->InvalidateRect( &MoveRect, FALSE);
         this->UpdateWindow();
      }
   }
   if( SelectItems == RECTCLIP)
      RubberBand( TRUE);
   else{
      CPoint   Sp;
      
      Sp.x = ptStart.x;
      Sp.y = ptStart.y + CAPTION_HEIGHT;
      m_pointArray.RemoveAll();
      m_selectArray.RemoveAll();
      m_pointArray.Add( Sp);
      Sp.x = ptStart.x /ZoomRate;
      Sp.y = ptStart.y /ZoomRate;
      m_selectArray.Add( Sp);
   }
}

/****************************************/
/*             */
/* MESSAGE  "WM_MOUSEMOVE"       */
/*             */
/****************************************/
void
CRefrWnd::OnMouseMove(
UINT  ,
CPoint   point)
{
   if( IsCapture){
      CorrectMouseUpPt( point);
      if( ptEnd.x == ptPrev.x && ptEnd.y == ptPrev.y)
         return;

      if( RectVisible){
         this->ClientToScreen( &point);
         MoveRectangle( m_ptLast);
         m_ptLast = point;
         MoveRectangle( m_ptLast);
      }else{
         if( SelectItems == RECTCLIP)
            RubberBand( FALSE);
         else{
            DrawFreeForm( FALSE);
            SelectFreeForm( FALSE);
         }
      }
   }
}

/****************************************/
/*             */
/* MESSAGE  "WM_LBUTTONUP"    */
/*             */
/****************************************/
void
CRefrWnd::OnLButtonUp(
UINT  ,
CPoint   point)
{
   CRect WorkRect;
   int   wSize;
   char  *pDupBmp;

   if (!bFocus)
      {
      bFocus = TRUE;
      CaptionDraw();
      pEditChild->bFocus = FALSE;
      pEditChild->CaptionDraw();
   }

   if( IsCapture){
      CorrectMouseUpPt( point);
      if( RectVisible){
         MoveRectangle( m_ptLast);

         WorkRect.CopyRect( &MoveRect);
         WorkRect.left = ptStart.x - MoveRect.left;
         WorkRect.top  = ptStart.y - MoveRect.top+CAPTION_HEIGHT;
         WorkRect.right = MoveRect.Width();
         WorkRect.bottom = MoveRect.Height();
         this->ClientToScreen( &point);
         DupBmp.CreateBitmap( BITMAP_WIDTH, BITMAP_HEIGHT,
            1, 1, NULL);
         wSize = ((( BITMAP_WIDTH +15) /16) *2) *BITMAP_HEIGHT;
         pDupBmp = (char *)malloc( wSize);

         if( SelectItems == FREEFORM){
            CBitmap hStdBitmap;
               CDC   hStdDC;
            CBrush   BlackBrush;

               hStdDC.CreateCompatibleDC( &ImageDC);
               hStdBitmap.CreateCompatibleBitmap( &ImageDC,
                  BITMAP_WIDTH, BITMAP_HEIGHT);
               CBitmap *hOldSObj =
               hStdDC.SelectObject( &hStdBitmap);

               hStdDC.PatBlt( 0, 0, BITMAP_WIDTH,
               BITMAP_HEIGHT, WHITENESS);

            BlackBrush.CreateStockObject( BLACK_BRUSH);
            hStdDC.FillRgn( &PickRgn, &BlackBrush);
            BlackBrush.DeleteObject();
               hStdDC.BitBlt( 0, 0, BITMAP_WIDTH,
               BITMAP_HEIGHT, &ImageDC,0, 0, SRCPAINT);
            hStdBitmap.GetBitmapBits( wSize,
               (LPVOID)pDupBmp);

            hStdDC.SelectObject( &hOldSObj);
            hStdBitmap.DeleteObject();
            hStdDC.DeleteDC();
         }else{
            ImageBmp.GetBitmapBits( wSize, (LPVOID)pDupBmp);
         }
         DupBmp.SetBitmapBits( wSize, (LPVOID)pDupBmp);
         free( pDupBmp);

         DupRect.CopyRect( &MoveRect);
         AfxGetMainWnd()->SendMessage( WM_DUPLICATE,
            (WPARAM)&WorkRect,(LPARAM)&point);
         DupBmp.DeleteObject();

      }else if( SelectItems == RECTCLIP){
         IllegalRect( &ptStart, &ptEnd);
         MoveRect.SetRect( ptStart.x, ptStart.y + CAPTION_HEIGHT,
            ptEnd.x + ZoomRate + 1,
            ptEnd.y + ZoomRate + CAPTION_HEIGHT + 1);

         if( abs( ptEnd.x - ptStart.x) < ZoomRate*2 ||
             abs( ptEnd.y - ptStart.y) < ZoomRate*2){
            this->InvalidateRect( &MoveRect, FALSE);
            this->UpdateWindow();
         }else{
            RectVisible = TRUE;
            this->InvalidateRect( &MoveRect, FALSE);
            this->UpdateWindow();
         }
         PickRect.SetRect(ptStart.x/ZoomRate, ptStart.y/ZoomRate,
            ( ptEnd.x+ZoomRate)/ZoomRate,
            ( ptEnd.y+ZoomRate)/ZoomRate);
      }else{
         CPoint   nArray[FREELIAIS];
         CPoint   pArray[FREELIAIS];

         DrawFreeForm( FALSE);
         SelectFreeForm( FALSE);
         DrawFreeForm( TRUE);
         SelectFreeForm( TRUE);

         if( m_pointArray.GetSize()  >= FREELIAIS ||
             m_selectArray.GetSize() >= FREELIAIS ){
               IsCapture = FALSE;
            ReleaseCapture();
            this->Invalidate( FALSE);
            this->UpdateWindow();
            return;
         }
         for( int i = 0; i < m_pointArray.GetSize(); i++)
            nArray[i] = m_pointArray[i];
         for( int k = 0; k < m_selectArray.GetSize(); k++)
            pArray[k] = m_selectArray[k];

         if( FreeRgn.GetSafeHandle() != NULL)
            FreeRgn.DeleteObject();

         if( PickRgn.GetSafeHandle() != NULL)
            PickRgn.DeleteObject();

         FreeRgn.CreatePolygonRgn( nArray,
            (int)(m_pointArray.GetSize()), ALTERNATE);
         PickRgn.CreatePolygonRgn( pArray,
            (int)(m_selectArray.GetSize()), ALTERNATE);

         if( FreeRgn.GetSafeHandle() == NULL ||
             PickRgn.GetSafeHandle() == NULL ){
            m_pointArray.RemoveAll();
            m_selectArray.RemoveAll();
         }else{
            RectVisible = TRUE;
            FreeRgn.GetRgnBox( &MoveRect);
            PickRgn.GetRgnBox( &PickRect);
            if( PickRect.Width()  < 3 ||
                PickRect.Height() < 3){
                  RectVisible = FALSE;
               FreeRgn.DeleteObject();
               PickRgn.DeleteObject();
            }
            MoveRect.right += 1;
            MoveRect.bottom += 1;
            this->InvalidateRect( &MoveRect);
            this->UpdateWindow();

         }
      }
      IsCapture = FALSE;
   }
   ReleaseCapture();
}

/****************************************/
/*             */
/* Correct Mouse Down Point   */
/*             */
/****************************************/
void
CRefrWnd::CorrectMouseDownPt(
CPoint   point)
{
   CRect WorkRect;

   WorkRect.CopyRect( &ReffWndRect);
   ptStart.x = point.x;
   ptStart.y = point.y - CAPTION_HEIGHT;
   if( ptStart.y < 0)
      ptStart.y = 0;

   if( SelectItems == RECTCLIP){
      ptStart.x = ( ptStart.x /ZoomRate) *ZoomRate;
      ptStart.y = ( ptStart.y /ZoomRate) *ZoomRate;
   }else{
      ptStart.x = (( ptStart.x + ZoomRate/2) /ZoomRate) *ZoomRate;
      ptStart.y = (( ptStart.y + ZoomRate/2) /ZoomRate) *ZoomRate;
   }
   ptEnd = ptPrev = ptStart;
}

/****************************************/
/*             */
/* Correct Mouse Up point     */
/*             */
/****************************************/
void
CRefrWnd::CorrectMouseUpPt(
CPoint   point)
{
   ptPrev = ptEnd;
   ptEnd.x = point.x;
   ptEnd.y = point.y - CAPTION_HEIGHT;
   CRect WorkRect;
   WorkRect.CopyRect( &ReffWndRect);
   if( ptEnd.x < 0)  ptEnd.x = 0;
   if( ptEnd.y < 0)  ptEnd.y = 0;
   if( ptEnd.x > WorkRect.right){
      if( SelectItems == RECTCLIP)
         ptEnd.x = WorkRect.right - ZoomRate;
      else  ptEnd.x = WorkRect.right;     
   }
   if( ptEnd.y > WorkRect.bottom - CAPTION_HEIGHT){
      if( SelectItems == RECTCLIP){
         ptEnd.y = WorkRect.bottom - CAPTION_HEIGHT
            - ZoomRate;
      }else ptEnd.y = WorkRect.bottom - CAPTION_HEIGHT;
   }

   if( SelectItems == RECTCLIP){
      ptEnd.x = ( ptEnd.x /ZoomRate) *ZoomRate;
      ptEnd.y = ( ptEnd.y /ZoomRate) *ZoomRate;
   }else{
      ptEnd.x = (( ptEnd.x + ZoomRate/2) /ZoomRate) *ZoomRate;
      ptEnd.y = (( ptEnd.y + ZoomRate/2) /ZoomRate) *ZoomRate;
   }
   if( SelectItems == RECTCLIP){
      if( ptEnd.x - ptStart.x <= ZoomRate &&
         ptEnd.x - ptStart.x >= 0)
         ptEnd.x = ptStart.x + ZoomRate;
      if( ptStart.x - ptEnd.x <= ZoomRate &&
         ptStart.x - ptEnd.x > 0)
         ptEnd.x = ptStart.x - ZoomRate;
      if( ptStart.y - ptEnd.y <= ZoomRate &&
         ptStart.y - ptEnd.y > 0)
         ptEnd.y = ptStart.y - ZoomRate;
      if( ptEnd.y - ptStart.y <= ZoomRate &&
         ptEnd.y - ptStart.y >= 0)
         ptEnd.y = ptStart.y + ZoomRate;
   }
}

/****************************************/
/*             */
/* Correct Illegal rectangle  */
/*             */
/****************************************/
void
CRefrWnd::IllegalRect(
PPOINT   ptTL,
PPOINT   ptBR)
{
   int   Tmp;

   if( ptTL->x > ptBR->x){
      Tmp = ptTL->x;
      ptTL->x = ptBR->x;
      ptBR->x = Tmp; 
   }
   if( ptTL->y > ptBR->y){
      Tmp = ptTL->y;
      ptTL->y = ptBR->y;
      ptBR->y = Tmp;
   }
}

/****************************************/
/*             */
/* COMMAND  "COPY"         */
/*             */
/****************************************/
void
CRefrWnd::OnGaijiCopy()
{
   ClipImageCopy();
   CMainFrame *pMain = new CMainFrame;
   pMain->CustomActivate();
   delete pMain;
}

/************************************************/
/*                */
/* COMMAND  "COPY" (Update)         */
/*                */
/************************************************/
void
CRefrWnd::OnUpdateGaijiCopy(
CCmdUI   *pCmdUI)
{
   if( RectVisible)
      pCmdUI->Enable(TRUE);
   else  pCmdUI->Enable(FALSE);
}

/****************************************/
/*             */
/* Copy Bitmap data     */
/*             */
/****************************************/
BOOL
CRefrWnd::ClipImageCopy()
{
   CBitmap hStdBitmap;
      CDC hStdDC;

      hStdDC.CreateCompatibleDC( &ImageDC);
      hStdBitmap.CreateCompatibleBitmap( &ImageDC,
               PickRect.Width(), PickRect.Height());
      CBitmap *hOldSObj = hStdDC.SelectObject( &hStdBitmap);

      hStdDC.PatBlt( 0, 0, PickRect.Width(), PickRect.Height(), WHITENESS);
   if( SelectItems == FREEFORM){
      CBrush   BlackBrush;

      BlackBrush.CreateStockObject( BLACK_BRUSH);
      PickRgn.OffsetRgn( 0 - PickRect.left, 0 - PickRect.top);
      hStdDC.FillRgn( &PickRgn, &BlackBrush);
      BlackBrush.DeleteObject();
         hStdDC.BitBlt( 0, 0, PickRect.Width(), PickRect.Height(),
         &ImageDC, PickRect.left, PickRect.top, SRCPAINT);
   }else{
         hStdDC.BitBlt( 0, 0, PickRect.Width(), PickRect.Height(),
         &ImageDC, PickRect.left, PickRect.top, SRCCOPY);
   }     

      if (!this->OpenClipboard()) {
      hStdDC.SelectObject( hOldSObj);
      hStdBitmap.DeleteObject();
            hStdDC.DeleteDC();
            return FALSE;
      }
      EmptyClipboard();

      if( !SetClipboardData( CF_BITMAP, hStdBitmap.Detach())) {
      hStdDC.SelectObject( hOldSObj);
      hStdBitmap.DeleteObject();
            hStdDC.DeleteDC();
            CloseClipboard();
            return FALSE;
      }
      CloseClipboard();
   hStdDC.SelectObject( hOldSObj);
   hStdBitmap.DeleteObject();
      hStdDC.DeleteDC();

   RectVisible = FALSE;
      this->InvalidateRect( &MoveRect, FALSE);
   this->UpdateWindow();
      return TRUE;
}

/****************************************/
/*             */
/* Draw Rubber Band rectanble */
/*             */
/****************************************/
void
CRefrWnd::RubberBand(
BOOL  TestFlag)
{
   CPen  *OldPen;
   CBrush   *OldBrush;
   CPoint   ptTL;
   CPoint   ptBR;

   CClientDC   dc( this);

   OldPen = (CPen *)dc.SelectStockObject( BLACK_PEN);
   OldBrush = (CBrush *)dc.SelectStockObject( NULL_BRUSH);
   int OldMode = dc.SetROP2( R2_NOTXORPEN);

   CRect BRect;
   if( !TestFlag){
      ptTL.x = ptStart.x;
      ptTL.y = ptStart.y + CAPTION_HEIGHT;
      ptBR.x = ptPrev.x;
      ptBR.y = ptPrev.y  + CAPTION_HEIGHT;
      IllegalRect( &ptTL, &ptBR);

      BRect.SetRect( ptTL.x, ptTL.y,
         ptBR.x + ZoomRate +1, ptBR.y + ZoomRate +1);
      dc.Rectangle( &BRect);
   }
   ptTL.x = ptStart.x;
   ptTL.y = ptStart.y + CAPTION_HEIGHT;
   ptBR.x = ptEnd.x;
   ptBR.y = ptEnd.y   + CAPTION_HEIGHT;
   IllegalRect( &ptTL, &ptBR);
   ptPrev = ptBR;
   BRect.SetRect( ptTL.x, ptTL.y, ptBR.x + ZoomRate +1,ptBR.y+ZoomRate+1);
   dc.Rectangle( &BRect);

   dc.SelectObject( OldPen);
   dc.SelectObject( OldBrush);
   dc.SetROP2( OldMode);
}

/****************************************/
/*             */
/* Initialize bitmap data     */
/*             */
/****************************************/
BOOL
CRefrWnd::UpdateBitmap()
{
   WORD  wSize;
   HANDLE   BitHandle;
   BYTE  *pBitmap;

   wSize = (WORD)((( BITMAP_WIDTH + 15) /16) *2) *(WORD)BITMAP_HEIGHT;
   if(( BitHandle = LocalAlloc( LMEM_MOVEABLE, wSize)) == 0)
      return FALSE;

   if(( pBitmap = (BYTE *)LocalLock( BitHandle)) == NULL){
      LocalUnlock( BitHandle);
      LocalFree( BitHandle);
      return FALSE;
   }
   memset( pBitmap, 0xffff, wSize);

   ImageBmp.SetBitmapBits((DWORD)wSize, (const void far *)pBitmap);
   LocalUnlock( BitHandle);
   LocalFree( BitHandle);

   RectVisible = FALSE;
   this->Invalidate(FALSE);
   this->UpdateWindow();

   return TRUE;
}

/****************************************/
/*             */
/* MESSAGE  "WM_SETCURSOR"    */
/*             */
/****************************************/
BOOL
CRefrWnd::OnSetCursor(
CWnd*    pWnd,
UINT  nHitTest,
UINT  message)
{
   CPoint   point;
   CRect CaptionRect;
   HCURSOR  hArrowCur;

   GetCursorPos( &point);
   this->GetClientRect( &CaptionRect);
   this->ScreenToClient( &point);
   CaptionRect.top = CAPTION_HEIGHT;

   if( CaptionRect.PtInRect( point))
      if( MoveRect.PtInRect( point) && RectVisible)
         ::SetCursor((HCURSOR)ArrowCursor[ALLDIRECT]);
      else  ::SetCursor((HCURSOR)ToolCursor[SelectItems]);
   else{
      hArrowCur = AfxGetApp()->LoadStandardCursor(IDC_ARROW);
      ::SetCursor( hArrowCur);   
   }
   return TRUE;
}

/****************************************/
/*             */
/* MESSAGE "WM_MDIACTIVATE"   */
/*             */
/****************************************/
void
CRefrWnd::OnMDIActivate(
BOOL  bActivate,
CWnd*    pActivateWnd,
CWnd*    pDeactivateWnd)
{
   if( bActivate == FALSE){
      RectVisible = FALSE;
      this->InvalidateRect( &MoveRect, FALSE);
      this->UpdateWindow();
   }
}

/****************************************/
/*             */
/* MESSAGE  "WM_SIZE"      */
/*             */
/****************************************/
void
CRefrWnd::OnSize(
UINT  nType,
int   cx,
int   cy)
{
   int   NewZoomRate;

   NewZoomRate = cx / BITMAP_WIDTH;
   if( RectVisible && NewZoomRate > 1){
      MoveRect.left = ( MoveRect.left /ZoomRate) * NewZoomRate;

      MoveRect.top = ((( MoveRect.top - CAPTION_HEIGHT)
         / ZoomRate) * NewZoomRate) + CAPTION_HEIGHT;

      MoveRect.right = ( MoveRect.right /ZoomRate) * NewZoomRate + 1;

      MoveRect.bottom = ((( MoveRect.bottom -CAPTION_HEIGHT)
         / ZoomRate) * NewZoomRate) + CAPTION_HEIGHT + 1;

   }else if( RectVisible && NewZoomRate <= 1){
      RectVisible = FALSE;
   }
   CMDIChildWnd::OnSize(nType, cx, cy);

   this->Invalidate(FALSE);
   this->UpdateWindow();
}

/****************************************/
/*             */
/*    Select FreeForm      */
/*             */
/****************************************/
void
CRefrWnd::SelectFreeForm(
BOOL  MouseSts)
{
   CPoint   Ep, Sp, Cp;
   CPoint   Fp, Inc;
   CPoint   Dp, Err;
   BOOL  Slope;
   int   D;
   int   Tmp;

   if( !MouseSts){
      Sp.x = ptPrev.x /ZoomRate;
      Sp.y = ptPrev.y /ZoomRate;
      Ep.x = Fp.x = ptEnd.x /ZoomRate;
      Ep.y = Fp.y = ptEnd.y /ZoomRate;
   }else{
      Sp.x = ptEnd.x /ZoomRate;
      Sp.y = ptEnd.y /ZoomRate;
      Ep.x = Fp.x = ptStart.x /ZoomRate;
      Ep.y = Fp.y = ptStart.y /ZoomRate;
   }

   if( Fp.x >= Sp.x)
      Inc.x = 1;
   else  Inc.x = -1;

   if( Fp.y >= Sp.y)
      Inc.y = 1;
   else  Inc.y = -1;

   Dp.x = ( Fp.x - Sp.x)*Inc.x;
   Dp.y = ( Fp.y - Sp.y)*Inc.y;
   if( !Dp.x && !Dp.y)
      return;
   if( Dp.x < Dp.y){
      Tmp = Dp.y;
      Dp.y = Dp.x;
      Dp.x = Tmp;
      Tmp = Inc.x;
      Inc.x = Inc.y;
      Inc.y = Tmp;
      Slope = TRUE;
   }else   Slope = FALSE;

   Err.x = Dp.y * 2;
   Err.y = ( Dp.y - Dp.x) * 2;
   D = Err.x - Dp.x;

   Ep = Sp;
   while(1){
      m_selectArray.Add( Ep);
      
      if( Ep.x == Fp.x && Ep.y == Fp.y)
         break;
      if( Slope){
         Tmp = Ep.x;
         Ep.x = Ep.y;
         Ep.y = Tmp;
      }
      Ep.x += Inc.x;
      if( D < 0)
         D += Err.x;
      else{
         Ep.y += Inc.y;
         D += Err.y;
      }
      if( Slope){
         Tmp = Ep.x;
         Ep.x = Ep.y;
         Ep.y = Tmp;
      }
   }
}

/****************************************/
/*             */
/*    Draw FreeForm        */
/*             */
/****************************************/
void
CRefrWnd::DrawFreeForm(
BOOL  MouseSts)
{
   CPoint   Ep, Sp, Cp;
   CPoint   Fp, Inc;
   CPoint   Dp, Err;
   CPoint   P1, P2;
   BOOL  Slope;
   int   D;
   int   Tmp;

   CClientDC   dc( this);

   CPen  *OldPen = (CPen *)dc.SelectStockObject( BLACK_PEN);
   int OldMode = dc.SetROP2( R2_NOTXORPEN);

   if( !MouseSts){
      Sp.x = ptPrev.x;
      Sp.y = ptPrev.y + CAPTION_HEIGHT;
      Ep.x = Fp.x = ptEnd.x;
      Ep.y = Fp.y = ptEnd.y + CAPTION_HEIGHT;
   }else{
      Sp.x = ptEnd.x;
      Sp.y = ptEnd.y + CAPTION_HEIGHT;
      Ep.x = Fp.x = ptStart.x;
      Ep.y = Fp.y = ptStart.y + CAPTION_HEIGHT;
   }

   if( Fp.x >= Sp.x)
      Inc.x = ZoomRate;
   else  Inc.x = 0 - ZoomRate;

   if( Fp.y >= Sp.y)
      Inc.y = ZoomRate;
   else  Inc.y = 0 - ZoomRate;

   Dp.x = ( Fp.x - Sp.x)*Inc.x;
   Dp.y = ( Fp.y - Sp.y)*Inc.y;
   if( !Dp.x && !Dp.y)
      return;
   if( Dp.x < Dp.y){
      Tmp = Dp.y;
      Dp.y = Dp.x;
      Dp.x = Tmp;
      Tmp = Inc.x;
      Inc.x = Inc.y;
      Inc.y = Tmp;
      Slope = TRUE;
   }else   Slope = FALSE;

   Err.x = Dp.y * 2;
   Err.y = ( Dp.y - Dp.x) * 2;
   D = Err.x - Dp.x;

   Ep = Sp;
   dc.MoveTo( Sp);
   while(1){
      if( Sp.x != Ep.x && Sp.y != Ep.y){
         if( Sp.y < Ep.y && Sp.x > Ep.x){
            Cp.x = Sp.x;
            Cp.y = Ep.y;
         }else if( Sp.y < Ep.y && Sp.x < Ep.x){
            Cp.x = Sp.x;
            Cp.y = Ep.y;
         }else if( Sp.y > Ep.y && Sp.x > Ep.x){
            Cp.y = Sp.y;
            Cp.x = Ep.x;
         }else{
            Cp.y = Sp.y;
            Cp.x = Ep.x;
         }
         dc.LineTo( Cp);
         dc.LineTo( Ep);
         P1 = Cp;
         P2 = Ep;
         m_pointArray.Add( P1);
         m_pointArray.Add( P2);
      }else if( Sp.x != Ep.x || Sp.y != Ep.y){
         dc.LineTo( Ep);
         P1 = Ep;

         m_pointArray.Add( P1);
      }
      Sp.x = Ep.x;
      Sp.y = Ep.y;
      
      if( Ep.x == Fp.x && Ep.y == Fp.y)
         break;
      if( Slope){
         Tmp = Ep.x;
         Ep.x = Ep.y;
         Ep.y = Tmp;
      }
      Ep.x += Inc.x;
      if( D < 0)
         D += Err.x;
      else{
         Ep.y += Inc.y;
         D += Err.y;
      }
      if( Slope){
         Tmp = Ep.x;
         Ep.x = Ep.y;
         Ep.y = Tmp;
      }
   }
   dc.SelectObject( OldPen);
   dc.SetROP2( OldMode);
}

/****************************************/
/*             */
/* Move Rectangle       */
/*             */
/****************************************/
void
CRefrWnd::MoveRectangle(
CPoint   point)
{
   CDC   dc;

   dc.Attach( ::GetDC( NULL));
   
   dc.PatBlt( point.x - m_ptMouse.x, point.y - m_ptMouse.y,
         MoveRect.Width(), 2, PATINVERT);

   dc.PatBlt( point.x - m_ptMouse.x + MoveRect.Width(),
         point.y - m_ptMouse.y, 2, MoveRect.Height(), PATINVERT);

   dc.PatBlt( point.x - m_ptMouse.x, point.y - m_ptMouse.y
       + MoveRect.Height(), MoveRect.Width() + 2, 2, PATINVERT);

   dc.PatBlt( point.x - m_ptMouse.x, point.y - m_ptMouse.y + 2, 2,
         MoveRect.Height() - 2, PATINVERT);

   ::ReleaseDC( NULL, dc.Detach());
}

/****************************************/
/*             */
/* COMMAND  "Close Ref"    */
/*             */
/****************************************/
void
CRefrWnd::OnClickClose()
{
   AfxGetMainWnd()->SendMessage( WM_COMMAND, ID_REFFER_CLOSE, 0);
}

/****************************************/
/*             */
/* MESSAGE  "WM_KEYDOWN"      */
/*             */
/****************************************/
void
CRefrWnd::OnKeyDown(
UINT  nChar,
UINT  nRepCnt,
UINT  nFlags)
{
   if( nChar == VK_ESCAPE){
      if( RectVisible){
         RectVisible = FALSE;
         this->Invalidate(FALSE);
         this->UpdateWindow();
      }
   }else    CMDIChildWnd::OnKeyDown(nChar, nRepCnt, nFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\registry.h ===
/**************************************************/	
/*					                              */
/*					                              */
/*	Regist functions		                      */
/*					                              */
/*					                              */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

BOOL InqTypeFace(TCHAR *typeface, TCHAR *filename, INT bufsiz);
BOOL RegistTypeFace(TCHAR *typeface, TCHAR *filename);
BOOL DeleteReg(TCHAR *typeface);
BOOL CreateRegistrySubkey();
BOOL InqCodeRange(TCHAR *Codepage, BYTE *Coderange, INT bufsiz);
BOOL DeleteRegistrySubkey();
BOOL FindFontSubstitute(TCHAR *orgFontName, TCHAR *sbstFontName);
void Truncate(TCHAR *str, TCHAR delim);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\rotatdlg.h ===
/**************************************************/
/*					                              */
/*					                              */
/*	Rotate bimap in Edit window	                  */
/*					                              */
/*					                              */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#define		NOTSEL		0
#define		FLIP_HOR	1
#define		FLIP_VER	2
#define		ROTATE_9	3
#define		ROTATE_18	4
#define		ROTATE_27	5

class CRotateDlg : public CDialog
{
public:
	CRotateDlg(CWnd* pParent = NULL);   // standard constructor

	//{{AFX_DATA(CRotateDlg)
	enum { IDD = IDD_ROTATECHAR };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	//{{AFX_VIRTUAL(CRotateDlg)
	protected:
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

public:
	int	RadioItem;

protected:

	//{{AFX_MSG(CRotateDlg)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	afx_msg void OnFliphor();
	afx_msg void OnFlipver();
	afx_msg void OnRotate180();
	afx_msg void OnRotate270();
	afx_msg void OnRotate90();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\smooth.cpp ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//

#include	"stdafx.h"

#include	"vdata.h"
#include	"extfunc.h"
#include	"ttfstruc.h"

/* Smooth sort */
#define		SMOOTH		0x8000
#define		NOSMOOTH	0x4000
#define		BACKWARD	0x2000		/* NOSMOOTH is forward vector */
#define		FOREWARD	0x1000		/* NOSMOOTH is backward vector*/

/* Curve Type */
#define		SPLINE_ATR	0x0001

/* Smoothing anchor Point */
#define		SMOOTHANCHOR	0x0080
	/* Smoothing anchor point is based 90degree Rule */
/* for turning */
#define		TURN_OU		1		/*  */
#define		TURN_TOTSU	2		/*  */

#define		sign(n)		(n < 0 ? 1 : 0)

#define		LONGMIN		5


int  SmoothVector(int  lstHdl,int  tmpLst,int  xinMesh,int yinMesh, int  outMesh,struct  SMOOTHPRM *prm,int  fp);
static int  BindVector(int  inLst,int  outLst);
static int  BindPoint(int  inLst,int  outLst);
static int  DetectNoSmooth(int  lsthdl);
static void  turnsort(struct  VDATA *vp);
static void  generalsmooth(struct  VDATA *vp);
static int  isturn(struct  VDATA *vp);
static int  islong(struct  VDATA *vp);
static void  longline(struct  VDATA *vp);
static int  ZoomPoint(int  lstHdl,int  xinMesh,int yinMesh, int  outMesh,int  uFp);
static int  preproc1(int  inLst,int  outLst);
static int  diveachside(struct  VDATA *vp,int  outLst);
static int  divoneside(struct  VDATA *vp,int  outLst);
static int divVec( int ilst, int olst, int divN);
static int  Smooth1(int  inLst,int  outLst,int  weight1,int  weight2,int  weight3);
static int  Smooth2(int  inLst,int  outLst);
int  searchanchor(int  sn,struct  VDATA *sp,struct  VDATA * *ep,int  lim);
static int  smooth1sub(struct  VDATA *vp,int  np,int  outLst,int  w1,int  w2,int  w3);
static int  smooth2sub(struct  VDATA *vp,int  np,int  outLst);
int  RemoveFp(int  lstHdl,int  outMesh,int  uFp);
static int  BindLinears(int  inLst,int  outLst);
static int  DelZeroVec(int  inLst,int  outLst);
int  toTTFFrame(int  lstH,struct  BBX *bbx);
static int  lightSub(int  inLst,int  outLst);
int  SmoothLight(int  ioLst,int  tmpLst,int  width,int height, int  oWidth,int  ufpVal);
int  ConvMesh(int  lstH,int  inMesh,int  outMesh);
static int
straightCurve( int iLst, int oLst)
{
struct VHEAD	*vhd;
struct VDATA	*vp;
struct vecdata	rel, nxtrel;
	int	np;
	int	sts;
struct vecdata	svd;

	if ( (sts = VDGetHead( iLst, &vhd))!=0)
		goto	RET;
	VDNew(oLst);

	while ( vhd->next!=NIL) {
		/* No point data is not Allowed */
		/* Set Origin */
		vp = vhd->headp;
		if ((sts = VDSetData(oLst, &vp->vd))!=0)
			goto	RET;
		vp=vp->next;
		for ( np = 1; np < vhd->nPoints; np++,vp = vp->next) {
			if ( vp->vd.atr & SPLINE_ATR) {
				rel.x = vp->vd.x - vp->prev->vd.x;
				rel.y = vp->vd.y - vp->prev->vd.y;
				nxtrel.x= vp->next->vd.x - vp->vd.x;
				nxtrel.y= vp->next->vd.y - vp->vd.y;
				if ((long)rel.x*nxtrel.y==(long)rel.y*nxtrel.x){
					vp = vp->next;
					np++;
					svd = vp->vd;
					svd.atr &= ~SPLINE_ATR;
					if ((sts = VDSetData(oLst, &svd))!=0)
						goto	RET;
				}
				else {
					if ((sts = VDSetData(oLst, &vp->vd))!=0)
						goto	RET;
					vp = vp->next;
					np++;
					if ( np >= vhd->nPoints)
						break;
					if ((sts = VDSetData(oLst, &vp->vd))!=0)
						goto	RET;
				}
			}
			else {
				if ((sts = VDSetData(oLst, &vp->vd))!=0)
					goto	RET;
			}
		}
		if(VDClose( oLst))
			goto	RET;
		vhd = vhd->next;
	}
	return 0;
RET:
	return -1;
}
/***********************************************************************
 *	Smoothing Main
 */
/* */	int
/* */	SmoothVector(
/* */		int	lstHdl,
/* */		int	tmpLst,
/* */		int	xinMesh,	/* Input Mesh Size*/
/* */		int 	yinMesh,
/* */		int	outMesh,	/* Output Mesh size */
/* */	struct SMOOTHPRM *prm,
/* */		int	fp)		/* Fixed Point sft-val */
/*
 *	reuturns : 0, -1
 *	Remarks : ̃W[̓͂́A֊sǒʂ̃xN^
 *		@_ƂB
 *		@o͂́Ao̓bVɍ킹邪A_͍ŁA
 *		@x[XCAxAO͒Ȃ
 ***********************************************************************/
{
	int	sts;

	if ( (sts = BindPoint( lstHdl, tmpLst))<0)
		goto	RET;

	if ( (sts = DetectNoSmooth( tmpLst))<0)
		goto	RET;

	if ( (sts = ZoomPoint( tmpLst, xinMesh, yinMesh, outMesh, fp))<0)
		goto	RET;

	if ( (sts = preproc1( tmpLst, lstHdl))<0)
		goto	RET;
	/* */
	if ( prm->UseConic) {
		if ( sts = divVec( lstHdl, tmpLst, 2))
			goto	RET;
		if ( (sts = Smooth1( tmpLst, lstHdl, 1, 2, 1))<0)
			goto	RET;
		
		if ( (sts = Smooth2(  lstHdl, tmpLst))<0)
			goto	RET;
		
		if ( sts = FitConic(tmpLst,lstHdl, prm->SmoothLevel, fp))
			goto	RET;
	}
	else {
		if ( (sts = Smooth1( lstHdl, tmpLst, 1, 2, 1))<0)
			goto	RET;
		if ( (sts = Smooth2( tmpLst, lstHdl))<0)
			goto	RET;
	}
	if ( (sts = DelZeroVec( lstHdl, tmpLst))<0)
		goto	RET;

	if ( (sts = straightCurve( tmpLst, lstHdl))<0)
		goto	RET;

	if ( (sts = DelZeroVec( lstHdl, tmpLst))<0)
		goto	RET;
	sts = BindLinears( tmpLst, lstHdl);


RET:
	return  sts;
}
/***********************************************************************
 *	Bind Same Direction Unit Vector
 */
/* */	static int
/* */	BindVector(
/* */		int inLst, 	/* Absolute Coordinate */
/* */		int outLst)	/* Relative one */
/*
 *	reuturns : 0, -1
 ***********************************************************************/
{
struct VHEAD	*vhd;
struct VDATA	*vp;
struct vecdata	rel, nxtrel;
	int	np;
	int	sts;

	if ( (sts = VDGetHead( inLst, &vhd))!=0)
		goto	RET;
	VDNew(outLst);

	nxtrel.atr = 1;
	while ( vhd->next!=NIL) {
		/* No point data is not Allowed */
		/* Set Origin */
		vp = vhd->headp;
		if ((sts = VDSetData(outLst, &vp->vd))!=0)
			goto	RET;
		rel.x = rel.y = 0;
		for ( np = 0; np < vhd->nPoints; np++,vp = vp->next) {
			nxtrel.x = vp->next->vd.x - vp->vd.x;
			nxtrel.y = vp->next->vd.y - vp->vd.y;
			if ( rel.x==0 && rel.y ==0)
				rel = nxtrel;
			else  {
				if ( rel.y==0 && nxtrel.y==0)
					rel.x += nxtrel.x;
				else if ( rel.x == 0 && nxtrel.x==0)
					rel.y += nxtrel.y;
				else {
					if ((sts=VDSetData(outLst, &rel))!=0)
						goto	RET;
					rel = nxtrel;
				}
			}
		}
		if ( rel.x!=0 || rel.y!=0) {
			if ((sts=VDSetData(outLst, &rel))!=0)
				goto	RET;
		}
		vhd = vhd->next;
		if ((sts = VDClose(outLst))!=0)
			goto	RET;
	}
RET:
	return( sts);
	
}
/***********************************************************************
 *	Bind Same Direction Unit Vector(Absolute Coodinate Version)
 *		Only for short vector ( dont care SPLINE )
 */
/* */	static int
/* */	BindPoint(
/* */		int inLst, 	/* Absolute Coordinate */
/* */		int outLst)	/* .. */
/*
 *	reuturns : 0, -1
 ***********************************************************************/
{
struct VHEAD	*vhd;
struct VDATA	*vp;
struct vecdata	lastvd;
	int	np;
	int	sts;

	if ( (sts = VDGetHead( inLst, &vhd))!=0)
		goto	RET;
	VDNew(outLst);

	while ( vhd->next!=NIL) {
		/* No point data is not Allowed */
		/* Set Origin */
		vp = vhd->headp;
		if ((sts = VDSetData(outLst, &vp->vd))!=0)
			goto	RET;
		lastvd = vp->vd;
		for ( np = 0; np < vhd->nPoints; np++,vp = vp->next) {
			if (vp->next->vd.x != lastvd.x && vp->next->vd.y != lastvd.y) {
				if ((sts=VDSetData(outLst, &vp->vd))!=0)
					goto	RET;
				lastvd = vp->vd;
			}
		}
		vhd = vhd->next;
		if ((sts = VDClose(outLst))!=0)
			goto	RET;
	}
RET:
	return( sts);
	
}
/***********************************************************************
 *	Detect Corner and edge
 */
/* */	static int
/* */	DetectNoSmooth(
/* */		int lsthdl)	/* Absolute Coordinate */
/*
 *	returns : 0, -1
 ***********************************************************************/
{
struct VHEAD	*vhd;
	int	sts;
struct VDATA	*vp;
	int	np;


	if ( (sts = VDGetHead( lsthdl, &vhd))!=0)
		goto	RET;
	while ( vhd->next != NIL) {
		vp = vhd->headp;
		for ( np = 0; np < vhd->nPoints; np++, vp = vp->next) {
			if (  isturn( vp) )
				turnsort(vp);
			else if (islong (vp))
				longline( vp);
			else	/* based on general rule */
				generalsmooth(vp);
		}
		vhd = vhd->next;
	}
RET:
	return sts;
}
/***********************************************************************
 *	Judge smooth or not at Turning Part
 */
/* */	static void
/* */	turnsort(
/* */		struct VDATA *vp)
/*
 *	returns : none
 ***********************************************************************/
{
struct vecdata	cur, prev1, prev2, next1, next2;

	cur.x = vp->vd.x-vp->prev->vd.x;
	cur.y = vp->vd.y-vp->prev->vd.y;
	prev1.x = vp->prev->vd.x-vp->prev->prev->vd.x;
	prev1.y = vp->prev->vd.y-vp->prev->prev->vd.y;
	prev2.x = vp->prev->prev->vd.x-vp->prev->prev->prev->vd.x;
	prev2.y = vp->prev->prev->vd.y-vp->prev->prev->prev->vd.y;
	next1.x = vp->next->vd.x - vp->vd.x;
	next1.y = vp->next->vd.y - vp->vd.y;
	next2.x = vp->next->next->vd.x - vp->next->vd.x;
	next2.y = vp->next->next->vd.y - vp->next->vd.y;

	if ( cur.x) {
		if ( abs(next1.y) > 1)
			vp->vd.atr |= NOSMOOTH ;
		else if ( sign( cur.x) == sign( next2.x))
			vp->vd.atr |= SMOOTH | BACKWARD;
		else
			vp->vd.atr |= NOSMOOTH;
		if ( abs(prev1.y) > 1)
			vp->prev->vd.atr |= NOSMOOTH ;
		else if (sign(cur.x)==sign(prev2.x))
			vp->prev->vd.atr |= SMOOTH | FOREWARD;
		else
			vp->prev->vd.atr |= NOSMOOTH ;
	}
	else {
		if ( abs(next1.x) > 1)
			vp->vd.atr |= NOSMOOTH ;
		else if ( sign( cur.y) == sign( next2.y))
			vp->vd.atr |= SMOOTH | BACKWARD;
		else
			vp->vd.atr |= NOSMOOTH;
		if ( abs(prev1.x) > 1)
			vp->prev->vd.atr |= NOSMOOTH ;
		else if (sign(cur.y)==sign(prev2.y))
			vp->prev->vd.atr |= SMOOTH | FOREWARD;
		else
			vp->prev->vd.atr |= NOSMOOTH;
	}
	return;
}
/***********************************************************************
 *	Judge Smooth or not with general rule
 */
/* */	static void
/* */	generalsmooth( struct VDATA *vp)
/*
 *	returns : none
 ***********************************************************************/
{
struct vecdata	prev2, prev1, cur, next1, next2, next3;

	cur.x = vp->vd.x- vp->prev->vd.x;
	cur.y = vp->vd.y- vp->prev->vd.y;
	prev1.x = vp->prev->vd.x - vp->prev->prev->vd.x;
	prev1.y = vp->prev->vd.y - vp->prev->prev->vd.y;
	prev2.x = vp->prev->prev->vd.x - vp->prev->prev->prev->vd.x;
	prev2.y = vp->prev->prev->vd.y - vp->prev->prev->prev->vd.y;
	next1.x = vp->next->vd.x - vp->vd.x;
	next1.y = vp->next->vd.y - vp->vd.y;
	next2.x = vp->next->next->vd.x - vp->next->vd.x;
	next2.y = vp->next->next->vd.y - vp->next->vd.y;
	next3.x = vp->next->next->next->vd.x - vp->next->next->vd.x;
	next3.y = vp->next->next->next->vd.y - vp->next->next->vd.y;

	if ( cur.y) {
		if ( abs(next1.x)>1 && abs(cur.y)>1) {
			if ( sign(cur.y) == sign(next1.x)
			   && abs(next2.y)==1
			   && abs(prev1.x)==1
			   && sign(cur.y)==sign(prev2.y)
			   && sign(next1.x)==sign( next3.x))
				;
			else
				vp->vd.atr |= NOSMOOTH;
		}
	}
	else {
		if ( abs(next1.y)>1 && abs(cur.x)>1) {
			if ( sign(cur.x) != sign(next1.y)
			   && abs(next2.x)==1
			   && abs(prev1.y)==1
			   && sign(cur.x)==sign(prev2.x)
			   && sign(next1.y)==sign( next3.y))
				;
			else
				vp->vd.atr |= NOSMOOTH;
		}
	}
	return;
}
/***********************************************************************
 *	Judge turning
 */
/* */	static int
/* */	isturn( struct VDATA	*vp)		/* Absolute */
/*
 *	retuns
 ***********************************************************************/
{
	int	turnSort;
struct vecdata	prev, cur, next;

	prev.x = vp->prev->vd.x - vp->prev->prev->vd.x;
	prev.y = vp->prev->vd.y - vp->prev->prev->vd.y;
	cur.x = vp->vd.x - vp->prev->vd.x;
	cur.y = vp->vd.y - vp->prev->vd.y;
	next.x = vp->next->vd.x - vp->vd.x;
	next.y = vp->next->vd.y - vp->vd.y;

	if ( prev.x !=0) {
		if ( sign(prev.x )!=sign(next.x )) {
			if (sign(next.x ) ==sign(cur.y))
				turnSort = TURN_TOTSU;
			else
				turnSort = TURN_OU;
		}
		else	turnSort = 0;
	}
	else {
		if ( sign(prev.y )!=sign(next.y )) {
			if (sign(next.y ) ==sign(cur.x))
				turnSort = TURN_OU;
			else
				turnSort = TURN_TOTSU;
		}
		else	turnSort = 0;
	}
	return	turnSort;
}

/***********************************************************************
 *	judge Long Line or Not
 */
/* */	static int
/* */	islong( struct VDATA *vp)
/*
 *	returns : 0, 1
 ***********************************************************************/
{
struct vecdata	cur, prev1, prev2, next1, next2;
	int	sts;

	cur.x = vp->vd.x - vp->prev->vd.x;
	cur.y = vp->vd.y - vp->prev->vd.y;
	if ( abs(cur.x)<= LONGMIN && abs(cur.y) <= LONGMIN)
		return( 0);
	prev2.x = vp->prev->prev->vd.x - vp->prev->prev->prev->vd.x;
	prev2.y = vp->prev->prev->vd.y - vp->prev->prev->prev->vd.y;
	prev1.x = vp->prev->vd.x - vp->prev->prev->vd.x;
	prev1.y = vp->prev->vd.y - vp->prev->prev->vd.y;
	next1.x = vp->next->vd.x - vp->vd.x;
	next1.y = vp->next->vd.y - vp->vd.y;
	next2.x = vp->next->next->vd.x - vp->next->vd.x;
	next2.y = vp->next->next->vd.y - vp->next->vd.y;
	if ( cur.x) {
		if ( (sign(cur.x) != sign(next2.x)
			|| abs(next1.y)>1
			|| ( abs(next1.y)==1 && abs(cur.x)/2 > abs(next2.x)))
		 && (sign(cur.x) != sign(prev2.x)
			|| abs(prev1.y)>1
			|| ( abs(prev1.y)==1 && abs(cur.x)/2 > abs(prev2.x))))
			sts = 1;
		/* 94.11.09 */
                else if ( abs(cur.x) > 2 && (abs(next1.y)>2 || abs(prev1.y)>2))
			sts = 1;
		/* */
		else	sts = 0;
	}
	else {
		if ( (sign(cur.y) != sign(next2.y)
			|| abs(next1.x)>1
			|| ( abs(next1.x)==1 && abs(cur.y)/2 > abs(next2.y)))
		 && (sign(cur.y) != sign(prev2.y)
			|| abs(prev1.x)>1
			|| ( abs(prev1.x)==1 && abs(cur.y)/2 > abs(prev2.y))))
			sts = 1;
		/* 94.11.09 */
                else if ( abs(cur.y) > 2 && (abs(next1.x)>2 || abs(prev1.x)>2))
			sts = 1;
		/* */
		else	sts = 0;
	}
	return sts;
}
/***********************************************************************
 *	judge Long Line or Not
 */
/* */	static void
/* */	longline( struct VDATA *vp)
/*
 *	returns : 0, 1
 ***********************************************************************/
{
struct vecdata	cur, prev1, prev2, next1, next2;

	prev2.x = vp->prev->prev->vd.x - vp->prev->prev->prev->vd.x;
	prev2.y = vp->prev->prev->vd.y - vp->prev->prev->prev->vd.y;
	prev1.x = vp->prev->vd.x - vp->prev->prev->vd.x;
	prev1.y = vp->prev->vd.y - vp->prev->prev->vd.y;
	cur.x = vp->vd.x - vp->prev->vd.x;
	cur.y = vp->vd.y - vp->prev->vd.y;
	next1.x = vp->next->vd.x - vp->vd.x;
	next1.y = vp->next->vd.y - vp->vd.y;
	next2.x = vp->next->next->vd.x - vp->next->vd.x;
	next2.y = vp->next->next->vd.y - vp->next->vd.y;

	if ( cur.x) {
		/* O */
		if ( abs(next1.y)!=1 || sign(cur.x)!=sign(next2.x))
			vp->vd.atr |= NOSMOOTH;
		else if ( abs( next2.x) ==1 && sign(cur.x)==sign(next1.y))
			vp->vd.atr |= NOSMOOTH;
		else
			vp->vd.atr |= NOSMOOTH | BACKWARD;
		/*  */
		if ( abs(prev1.y)!=1 || sign(cur.x)!=sign(prev2.x))
			vp->prev->vd.atr |= NOSMOOTH;
		else if ( abs( prev2.x) ==1&& sign(cur.x)!=sign(prev1.y))
			vp->prev->vd.atr |= NOSMOOTH;
		else
			vp->prev->vd.atr |= NOSMOOTH | FOREWARD;
	}
	else {
		/* O */
		if ( abs(next1.x)!=1 || sign(cur.y)!=sign(next2.y))
			vp->vd.atr |= NOSMOOTH;
		else if ( abs( next2.y) ==1 && sign(cur.y)!=sign(next1.x))
			vp->vd.atr |= NOSMOOTH;
		else
			vp->vd.atr |= NOSMOOTH | BACKWARD;
		/*  */
		if ( abs(prev1.x)!=1 || sign(cur.y)!=sign(prev2.y))
			vp->prev->vd.atr |= NOSMOOTH;
		else if ( abs( prev2.y) ==1&& sign(cur.y)==sign(prev1.x))
			vp->prev->vd.atr |= NOSMOOTH;
		else
			vp->prev->vd.atr |= NOSMOOTH | FOREWARD;
	}
}
/***********************************************************************
 *	Zoom for fixed point
 */
/* */	static int
/* */	ZoomPoint(
/* */		int	lstHdl,		/* List Handle to proccess */
/* */		int	xinMesh,	/* INPut Dot Mesh */
/* */		int	yinMesh,
/* */		int	outMesh,	/* output mesh (256) */
/* */		int	uFp)		/* Under Fixed Point Value */
/*
 *	returns : none
 *	remarks : ʂ̍WńA(128,128)[=outMesh/2]_ɈړA
 *		@UFp|lł
 ***********************************************************************/
{
struct VHEAD	*vhd;
	int	sts;
struct VDATA	*vp;
	int	np;
	int	center;

	center = outMesh/2*uFp;

	if ( (sts = VDGetHead( lstHdl, &vhd))!=0)
		goto	RET;
	while ( vhd->next != NIL) {
		vp = vhd->headp;
		for ( np = 0; np < vhd->nPoints; np++, vp = vp->next) {
			vp->vd.x =(short)((long)vp->vd.x*outMesh*uFp/xinMesh)-center;
			vp->vd.y =(short)((long)vp->vd.y*outMesh*uFp/yinMesh)-center;
		}
		vhd = vhd->next;
	}
RET:
	return	sts;
}
/***********************************************************************
 *	Pre-Proc1 of smoothing( divide long vector )
 */
/* */	static int
/* */	preproc1( int inLst, int outLst)
/*
 *	returns : 0. -1
 ***********************************************************************/
{
struct VHEAD	*vhd;
	int	sts;
struct VDATA	*vp;
	int	np;
struct vecdata	vd;

	if ( (sts = VDGetHead( inLst, &vhd))!=0)
		goto	RET;
	VDNew( outLst);
	while ( vhd->next != NIL) {
		vp = vhd->headp;
		for ( np = 0; np < vhd->nPoints; ) {
			if ( vp->vd.atr & FOREWARD) {
				if ( vp->next->vd.atr& BACKWARD) {
					if ((sts = diveachside( vp, outLst))<0)
						goto	RET;
					np++;
					vp = vp->next;
				}
				else {
					if ((sts=divoneside(vp, outLst))<0)
						goto	RET;
				}
			}
			else if ((vp->vd.atr & BACKWARD)
				&& (vp->prev->vd.atr & FOREWARD)==0){

				if ( (sts = divoneside( vp, outLst))<0)
					goto	RET;

			}
			else {	/* only copy */
				vd = vp->vd;
				if ( vp->vd.atr & NOSMOOTH)
					vd.atr = SMOOTHANCHOR;
				if ((sts=VDSetData( outLst, &vd))<0)
					goto	RET;

			}
			np++;
			vp = vp->next;
		}

		if ( (sts = VDClose( outLst))<0)
			break;

		vhd = vhd->next;
	}
RET:
	return sts;
}
/***********************************************************************
 *	Divide Vector from each side( for PreProc)
 */
/* */	static int
/* */	diveachside( struct VDATA *vp, int outLst)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
struct vecdata	prev, cur, next1, next2, next3;
struct vecdata	div1, div2;
	int	sts;

	prev.x = vp->prev->vd.x - vp->prev->prev->vd.x;
	prev.y = vp->prev->vd.y - vp->prev->prev->vd.y;
	cur.x = vp->vd.x - vp->prev->vd.x;
	cur.y = vp->vd.y - vp->prev->vd.y;
	next1.x = vp->next->vd.x - vp->vd.x;
	next1.y = vp->next->vd.y - vp->vd.y;
	next2.x = vp->next->next->vd.x - vp->next->vd.x;
	next2.y = vp->next->next->vd.y - vp->next->vd.y;
	next3.x = vp->next->next->next->vd.x - vp->next->next->vd.x;
	next3.y = vp->next->next->next->vd.y - vp->next->next->vd.y;
	sts = 0;
	if ( next1.x) {
		if ( (sts = VDSetData( outLst, &vp->vd))<0)
			goto	RET;
		div1.y = vp->vd.y;
		div2.y = vp->vd.y;
		div1.atr = SMOOTHANCHOR;
		div2.atr = SMOOTHANCHOR;
		if ( abs(prev.x) + abs( next3.x) <= abs(next1.x)) {
			div1.x = vp->vd.x + prev.x;
			if ( (sts = VDSetData( outLst, &div1))<0)
				goto	RET;
			div2.x = vp->next->vd.x - next3.x;
			if ( (sts = VDSetData( outLst, &div2))<0)
				goto	RET;
			if ( (sts = VDSetData( outLst, &vp->next->vd))<0)
				goto	RET;
		}
		else {
			div1.x = (short)((long)next1.x*abs(prev.x)/abs(prev.x + next3.x));
			if ( div1.x != 0) {
				div1.x += vp->vd.x;
				if ( (sts = VDSetData( outLst, &div1))<0)
					goto	RET;
				if ( (sts = VDSetData( outLst, &vp->next->vd))<0)
					goto	RET;
			}
			else {
				div1.x = vp->next->vd.x;
				div1.y = vp->next->vd.y;
				if ( (sts = VDSetData( outLst, &div1))<0)
					goto	RET;
			}
		}
	}
	else {
		div1.x = vp->vd.x;
		div2.x = vp->vd.x;
		div1.atr = SMOOTHANCHOR;
		div2.atr = SMOOTHANCHOR;
		if ( (sts = VDSetData( outLst, &vp->vd))<0)
			goto	RET;
		if ( abs(prev.y) + abs( next3.y) <= abs(next1.y)) {
//			div1.y = vp->vd.y + prev.y;
			div1.y = vp->vd.y + prev.y/2;
			if ( (sts = VDSetData( outLst, &div1))<0)
				goto	RET;
//			div2.y = vp->next->vd.y - next3.y;
			div2.y = vp->next->vd.y - next3.y/2;
			if ( (sts = VDSetData( outLst, &div2))<0)
				goto	RET;
			if ( (sts = VDSetData( outLst, &vp->next->vd))<0)
				goto	RET;
		}
		else {
			div1.y = (short)((long)next1.y*abs(prev.y)/abs(prev.y + next3.y));
			if ( div1.y!=0) {
				div1.y += vp->vd.y;
				if ( (sts = VDSetData( outLst, &div1))<0)
					goto	RET;
				if ( (sts = VDSetData( outLst, &vp->next->vd))<0)
					goto	RET;
			}
			else {
				div1.x = vp->next->vd.x;
				div1.y = vp->next->vd.y;
				if ( (sts = VDSetData( outLst, &div1))<0)
					goto	RET;
			}
		}
	}
RET:
	return( sts);
}
/***********************************************************************
 *
 */
/* */	static int
/* */	divoneside(
/* */	struct VDATA	*vp,
/* */		int	outLst)
/*
 *
 ***********************************************************************/
{
struct vecdata	prev, cur, next1, next2;
struct vecdata	div1;
	int	sts;

	sts = 0;
	div1.atr = SMOOTHANCHOR;
	if ( vp->vd.atr & FOREWARD) {
		if ( (sts = VDSetData( outLst, &vp->vd))<0)
			goto	RET;
		prev.x = vp->prev->vd.x - vp->prev->prev->vd.x;
		prev.y = vp->prev->vd.y - vp->prev->prev->vd.y;
		cur.x = vp->vd.x - vp->prev->vd.x;
		cur.y = vp->vd.y - vp->prev->vd.y;
		next1.x = vp->next->vd.x - vp->vd.x;
		next1.y = vp->next->vd.y - vp->vd.y;

		if ( vp->vd.x == vp->prev->vd.x) {
			if ( abs(prev.x) < abs(next1.x)) {
				div1.y = vp->vd.y;
//				div1.x = vp->vd.x + prev.x;
				div1.x = vp->vd.x + prev.x/2;
				if ( (sts = VDSetData( outLst, &div1))<0)
					goto	RET;
			}
		}
		else {
			if ( abs(prev.y) < abs(next1.y)) {
				div1.x = vp->vd.x;
//				div1.y = vp->vd.y + prev.y;
				div1.y = vp->vd.y + prev.y/2;
				if ( (sts = VDSetData( outLst, &div1))<0)
					goto	RET;
			}
		}
	}
	else {
		cur.x = vp->vd.x - vp->prev->vd.x;
		cur.y = vp->vd.y - vp->prev->vd.y;
		next2.x = vp->next->next->vd.x - vp->next->vd.x;
		next2.y = vp->next->next->vd.y - vp->next->vd.y;
		if ( vp->vd.x == vp->next->vd.x) {
			if ( abs(cur.x) > abs(next2.x)) {
//				div1.x = vp->vd.x - next2.x;
				div1.x = vp->vd.x - next2.x/2;
				div1.y = vp->vd.y;
				if ( (sts = VDSetData( outLst, &div1))<0)
					goto	RET;
			}
		}
		else {
			if ( abs(cur.y) > abs(next2.y)) {
				div1.x = vp->vd.x;
//				div1.y = vp->vd.y - next2.y;
				div1.y = vp->vd.y - next2.y/2;
				if ( (sts = VDSetData( outLst, &div1))<0)
					goto	RET;
			}
		}
		if ( (sts = VDSetData( outLst, &vp->vd))<0)
			goto	RET;
	}
RET:
	return( sts);
}
/***********************************************************************
 *	Smoothing 1
 */
/* */	static int
/* */	Smooth1( int	inLst,
/* */		int	outLst,
/* */		int	weight1,		/* Waight of Smoothing Form.*/
/* */		int	weight2,
/* */		int	weight3	)
/*
 *	returns : 0,  -1
 ***********************************************************************/
{
struct VHEAD	*vhd;
	int	sts;
struct VDATA	*svp, *evp;
	int	sp, ep;

	if ( (sts = VDGetHead( inLst, &vhd))!=0)
		goto	RET;
	VDNew( outLst);
	while ( vhd->next != NIL) {
	    svp = vhd->headp;
	    if ((sp=searchanchor(0,svp,&svp,vhd->nPoints))<vhd->nPoints){
			
		while(sp <vhd->nPoints) {
			ep = searchanchor(sp+1, svp->next,&evp, vhd->nPoints);
			if ((sts=smooth1sub( svp, ep-sp,outLst,weight1, weight2, weight3))<0)
				goto	RET;
			if ( ep >= vhd->nPoints)
				break;
			sp = ep;
			svp = evp;
		}
	    }
	    vhd = vhd->next;
	    if ( (sts = VDClose( outLst)) < 0)
		break;
	}
RET:
	return	sts;
}
/***********************************************************************
 *	Smoothing 2 ( mabiki)
 */
/* */	static int
/* */	Smooth2( int inLst, int outLst )
/*
 *	returns : 0,  -1
 ***********************************************************************/
{
struct VHEAD	*vhd;
	int	sts;
struct VDATA	*svp, *evp;
	int	sp, ep;

	if ( (sts = VDGetHead( inLst, &vhd))!=0)
		goto	RET;
	VDNew( outLst);
	while ( vhd->next != NIL) {
	    svp = vhd->headp;
	    if ((sp=searchanchor(0,svp,&svp,vhd->nPoints))<vhd->nPoints){
			
		while(sp <vhd->nPoints) {
			ep = searchanchor(sp+1, svp->next,&evp, vhd->nPoints);
			if ((sts=smooth2sub( svp, ep-sp,outLst))<0)
				goto	RET;
			if ( ep >= vhd->nPoints)
				break;
			sp = ep;
			svp = evp;
		}
	    }
	    vhd = vhd->next;
	    if ( (sts = VDClose( outLst)) < 0)
		break;
	}
RET:
	return	sts;
}
/***********************************************************************
 *	Search Smoothing Anchor Point
 */
/* */	int
/* */	searchanchor(
/* */		int	sn,
/* */	struct VDATA	*sp,
/* */	struct VDATA	**ep,
/* */		int	lim)
/*
 *
 ***********************************************************************/
{
	while ( lim-- > 0) {
		if (sp->vd.atr & SMOOTHANCHOR) {
			*ep = sp;
			return	sn;
		}
		sp = sp->next;
		sn++;
	}
	return( sn);
}
/***********************************************************************
 *	Smooth1 body
 */
/* */	static int
/* */	smooth1sub(
/* */	struct VDATA	*vp,
/* */		int	np,
/* */		int	outLst,
/* */		int	w1,		/* Waight of Smoothing Form.*/
/* */		int	w2,
/* */		int	w3)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
	int	pcnt,
		sts;
struct vecdata	vd;
	int	base;

	if ( (sts = VDSetData( outLst, &vp->vd))<0)
		goto	RET;
	np--;
	vp = vp->next;
	base = w1 + w2 + w3;
	for ( pcnt = 0; pcnt < np; pcnt++, vp= vp->next) {
		vd.x = (vp->prev->vd.x*w1 + vp->vd.x*w2 + vp->next->vd.x*w3)/base;
		vd.y = (vp->prev->vd.y*w1 + vp->vd.y*w2 + vp->next->vd.y*w3)/base;
		vd.atr = vp->vd.atr;
		if ( (sts = VDSetData( outLst, &vd))<0)
			break;
	}
RET:
	return( sts);
}
/***********************************************************************
 *	Smooth2 body ( mabiki body)
 */
/* */	static int
/* */	smooth2sub(
/* */	struct VDATA	*vp,
/* */		int	np,
/* */		int	outLst)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
	int	pcnt,
		sts;

	if ( (sts = VDSetData( outLst, &vp->vd))<0)
		goto	RET;
	np--;
	vp = vp->next;
	for ( pcnt = 0; pcnt < np; pcnt++, vp= vp->next) {
		if ( np < 3 || pcnt % 2 == 0) {
			if ( (sts = VDSetData( outLst, &vp->vd))<0)
				break;
		}
	}
RET:
	return( sts);
}
/***********************************************************************
 *	Remove Fixed Point
 */
/* */	int
/* */	RemoveFp(
/* */		int	lstHdl,		/* List Handle to proccess */
/* */		int	outMesh,	/* output mesh */
/* */		int	uFp)		/* Under Fixed Point Value */
/*
 *	returns : none
 *	remarks : X[YBȌʂ̍WńAUFpŊČ_
 *		  (128,128) [=outMesh/2]Ɉړlł
 ***********************************************************************/
{
struct VHEAD	*vhd;
	int	sts;
struct VDATA	*vp;
	int	center;
	int	np;

	center = outMesh/2;

	if ( (sts = VDGetHead( lstHdl, &vhd))!=0)
		goto	RET;
	while ( vhd->next != NIL) {
		vp = vhd->headp;
		for ( np = 0; np < vhd->nPoints; np++, vp = vp->next) {
			vp->vd.x = vp->vd.x / uFp+center;
			if ( vp->vd.x < 0)	vp->vd.x = 0;
			else if  ( vp->vd.x >= outMesh)	vp->vd.x = outMesh-1;

			vp->vd.y = vp->vd.y / uFp+center;
			if ( vp->vd.y < 0)	vp->vd.y = 0;
			else if  ( vp->vd.y >= outMesh)	vp->vd.y = outMesh-1;
		}
		vhd = vhd->next;
	}
RET:
	return sts;
}

/***********************************************************************
 *	Bind same direction vector
 */
/* */	static int
/* */	BindLinears( int inLst, int outLst)
/*
 ***********************************************************************/
{
struct VHEAD	*vhd;
	int	sts;
struct VDATA	*vp;
	int	np;
struct vecdata	rel1, rel2;

	VDNew( outLst);
	if ( (sts = VDGetHead( inLst, &vhd))!=0)
		goto	RET;
	while ( vhd->next != NIL) {
		vp = vhd->headp;
		/* Origin */
		if ( (sts = VDSetData( outLst, &vp->vd))<0)
			goto	RET;
		vp = vp->next;
		for ( np = 1; np < vhd->nPoints; np++, vp = vp->next) {
			if ( np+1 >= vhd->nPoints) {
				if ((sts=VDSetData( outLst, &vp->vd))<0)
					goto	RET;
				break;
			}
			else if ( vp->vd.atr&SPLINE_ATR) {

				if ((sts=VDSetData( outLst, &vp->vd))<0)
					goto	RET;
				/* End Point */
				vp = vp->next;
				np++;
				if ( np >= vhd->nPoints)
					break;
				if ( (sts = VDSetData( outLst, &vp->vd))<0)
					goto	RET;
			}
			else {
			    rel1.x = vp->next->vd.x - vp->vd.x;
			    rel1.y = vp->next->vd.y - vp->vd.y;
			    rel2.x = vp->vd.x - vp->prev->vd.x;
			    rel2.y = vp->vd.y - vp->prev->vd.y;
			    if ( (vp->next->vd.atr & SPLINE_ATR )
				|| (long)rel1.x*rel2.y != (long)rel1.y*rel2.x) {
				if ( (sts = VDSetData( outLst, &vp->vd))<0)
					goto	RET;
			    }
			}
		}
		if ( (sts = VDClose( outLst))<0)
			goto	RET;
		vhd = vhd->next;
	}
RET:
	return( sts);
}
/***********************************************************************
 *	Deleate Zero Vector ( about Non Curve Part)
 */
/* */	static int
/* */	DelZeroVec( int inLst, int outLst)
/*
 ***********************************************************************/
{
struct VHEAD	*vhd;
	int	sts;
struct VDATA	*vp;
	int	np;

	VDNew( outLst);
	if ( (sts = VDGetHead( inLst, &vhd))!=0)
		goto	RET;
	while ( vhd->next != NIL) {
		vp = vhd->headp;
		/* Origin */
		if ( (sts = VDSetData( outLst, &vp->vd))<0)
			goto	RET;
		vp = vp->next;
		for ( np = 1; np < vhd->nPoints; np++, vp = vp->next) {
			if ( vp->vd.atr&SPLINE_ATR) {
				/* Control Point */
				if ( (sts = VDSetData( outLst, &vp->vd))<0)
					goto	RET;
				/* End Point */
				vp = vp->next;
				np++;
				if ( np >= vhd->nPoints)
					break;
				if ( (sts = VDSetData( outLst, &vp->vd))<0)
					goto	RET;
			}
			else {
				if ( vp->vd.x != vp->prev->vd.x
					   || vp->vd.y != vp->prev->vd.y) {
					if ((sts=VDSetData( outLst, &vp->vd))<0)
						goto	RET;
				}
			}
		}
		if ( (sts = VDClose( outLst))<0)
			goto	RET;
		vhd = vhd->next;
	}
RET:
	return( sts);
}
/*		X			  |Y
 *	O------------		     	+-|------+
 *	|	|			| |	 |
 *	|	|	---> 		| |	 |
 *	|	|		     -----+-------------X
 *	|-------+			O-|------+
 *	|Y				  |
 */
int
toTTFFrame( int lstH, struct BBX *bbx)
{
struct VHEAD	*vhd;
struct VDATA	*vp;
	int	np;
	int	sts;
	short	mesh;

	if ( (sts = VDGetHead( lstH, &vhd))!=0)
		goto	RET;
	if ( (sts = VDGetNCont( lstH))<=0)
		goto	RET;
	mesh = bbx->xMax - bbx->xMin+1;
	if ( mesh > bbx->yMax - bbx->yMin)
		mesh = bbx->yMax - bbx->yMin+1;
	while ( vhd->next != NIL) {
		vp = vhd->headp;
		np = vhd->nPoints;
		while ( np-->0) {
			vp->vd.x += (short)bbx->xMin;
			vp->vd.y = (mesh - 1) - vp->vd.y + bbx->yMin;
			/* Limit in BBX */
			if ( vp->vd.x > bbx->xMax)
				vp->vd.x = (short)bbx->xMax;
			else if (vp->vd.x < bbx->xMin)
				vp->vd.x = (short)bbx->xMin;
			if ( vp->vd.y > bbx->yMax)
				vp->vd.y = (short)bbx->yMax;
			else if (vp->vd.y < bbx->yMin)
				vp->vd.y = (short)bbx->yMin;
			vp = vp->next;
		}
		vhd = vhd->next;
	}
	sts = 0;
RET:
	return sts;
}
static int
lightSub( int inLst, int outLst)
{
struct VHEAD	*vhd;
	int	sts;
struct VDATA	*svp, *evp;
	int	sp, ep;
	if ( (sts = VDGetHead( inLst, &vhd))!=0)
		goto	RET;
	VDNew( outLst);
	while ( vhd->next != NIL) {
	    svp = vhd->headp;
	    if ((sp=searchanchor(0,svp,&svp,vhd->nPoints))<vhd->nPoints){
			
		while(sp <vhd->nPoints) {
			ep = searchanchor(sp+1, svp->next,&evp, vhd->nPoints);
			if ((sts=smooth1sub( svp, ep-sp,outLst,1, 2, 1))<0)
				goto	RET;
			if ( ep >= vhd->nPoints)
				break;
			sp = ep;
			svp = evp;
		}
	    }
	    vhd = vhd->next;
	    if ( (sts = VDClose( outLst)) < 0)
		break;
	}
RET:
	return	sts;
}
static int
divVec( int ilst, int olst, int divN)
{
struct VHEAD	*vhd;
struct VDATA	*vp;
struct vecdata	rel, vd;
	int	np;
	int	n;

	if ( VDGetHead( ilst, &vhd)!=0)
		goto	RET;
	VDNew( olst);
	while ( vhd->next != NIL) {
		vp = vhd->headp;
		np = vhd->nPoints;
		while ( np-->0) {
			if (VDSetData(olst, &vp->vd))
				goto	RET;
			rel.x = vp->next->vd.x - vp->vd.x;
			rel.y = vp->next->vd.y - vp->vd.y;
			vd.atr = 0;
			for ( n=1; n<divN; n++) {
				vd.x = vp->vd.x+rel.x*n/divN;
				vd.y = vp->vd.y+rel.y*n/divN;
				if (VDSetData(olst, &vd))
					goto	RET;
			}
			vp = vp->next;
		}
		vhd = vhd->next;
		VDClose( olst);
	}
	return 0;
RET:
	return -1;
}
int
SmoothLight( int ioLst, int tmpLst, int width, int height, int oWidth, int ufpVal)
{
	int	sts;

	if ( (sts = BindPoint( ioLst, tmpLst))<0)
		goto	RET;
	if ( (sts = DetectNoSmooth( tmpLst))<0)
		goto	RET;
	if ( (sts = ZoomPoint( tmpLst, width, height, oWidth, ufpVal))<0)
		goto	RET;
	if ( (sts = preproc1( tmpLst, ioLst))<0)
		goto	RET;


	if ( sts = divVec( ioLst, tmpLst, 2))
		goto	RET;
	if ( lightSub( tmpLst, ioLst))
		goto	RET;
	if ( lightSub( ioLst, tmpLst))
		goto	RET;

	if ( RemoveFp( tmpLst, oWidth, ufpVal))
		goto	RET;
	if ( (sts = DelZeroVec( tmpLst, ioLst))<0)
		goto	RET;
	return 0;
RET:
	return -1;
}
int
ConvMesh( int lstH, int inMesh, int outMesh)
{
struct VHEAD	*vhd;
struct VDATA	*vp;
	int	np;
	int	sts;
	if ( inMesh==outMesh)
		return 0;
	if ( (sts = VDGetHead( lstH, &vhd))!=0)
		goto	RET;
	if ( (sts = VDGetNCont( lstH))<=0)
		goto	RET;
	while ( vhd->next != NIL) {
		vp = vhd->headp;
		np = vhd->nPoints;
		while ( np-->0) {
			vp->vd.x = (int)((long)vp->vd.x*outMesh/inMesh);
			vp->vd.y = (int)((long)vp->vd.y*outMesh/inMesh);
			vp = vp->next;
		}
		vhd = vhd->next;
	}
	sts = 0;
RET:
	return sts;
}
/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by eudcedit.rc
//
#define IDR_MAINFRAME                   2
#define IDR_EUDCTYPE                    3
#define ID_PALETTEPEN                   103
#define ID_PALETTESLOPE                 104
#define ID_PALETTERECT                  105
#define IDD_REFERENCE                   105
#define ID_PALETTERECTFILL              106
#define IDC_BUTTOMFONT                  106
#define ID_PALETTECIRCLE                107
#define IDD_CUSTOMCODE                  107
#define ID_PALETTECIRCLEFILL            108
#define ID_PALETTERECTBAND              109
#define IDC_EDITCODE                    109
#define IDC_PENCIL                      109
#define IDC_EDITCHAR                    110
#define IDC_EDITFONT                    111
#define IDW_STATICSTYLE                 111
#define IDW_STATIC                      112
#define IDC_STATIC1                     113
#define IDC_BRUSH                       113
#define IDC_STATICC                     113
#define IDC_COMPUS                      114
#define IDC_STATIC3                     115
#define IDC_STATICF                     115
#define ID_REFERCODE                    116
#define IDB_CLOSE_REF                   118
#define IDD_INPUTFILE                   120
#define IDD_ASSOCIATION                 121
#define IDC_CUSTOMEDIT                  122
#define IDC_CODECUST                    123
#define IDC_CUSTOMCHR                   125
#define IDD_IMEREGISTDLG                125
#define IDD_IMPORT                      126
#define IDI_ROTATE90                    127
#define IDI_ROTATE180                   128
#define IDI_ROTATE270                   129
#define IDI_FLIPHOR                     130
#define IDI_FLIPVER                     131
#define IDD_ROTATECHAR                  132
#define IDC_STATICFONT                  133
#define IDC_FONT_NAME                   133
#define IDD_GAGE                        136
#define IDC_SETFONTNAME                 137
#define IDI_TRUETYPE                    137
#define IDB_CLOSEBMP                    138
#define IDC_STATIC5                     139
#define IDB_CLOSEBMPP                   139
#define IDC_EDITFILENAME                140
#define IDW_STATICFILE                  142
#define IDC_STATIC7                     142
#define IDI_WIFEFONT                    142
#define IDC_FILE_NAME                   142
#define IDW_STATICNAME                  143
#define IDC_SETFILENAME                 143
#define IDC_REGISTLIST                  144
#define IDD_LINKBATCH                   145
#define IDC_MODIFY                      146
#define IDD_BROWSE_TTF                  147
#define IDC_CHINARANGE                  157
#define IDC_ERASER                      161
#define IDW_STATICCODE                  162
#define IDC_IMEREGISTEDIT               162
#define IDI_UPRIGHT                     162
#define IDW_STATICCODENUM               163
#define IDC_REMOVE                      167
#define IDC_BMP_IMPUT                   169
#define IDC_FILE_BROWSE                 170
#define IDC_FLIPHOR                     173
#define IDC_FLIPVER                     174
#define IDC_ROTATE90                    175
#define IDC_ROTATE180                   176
#define IDC_ROTATE270                   177
#define IDC_ASSOCIATE_BROWSE            188
#define IDC_GAGE                        196
#define IDC_IMPORT_STATIC               197
#define IDC_SCRIPTCOMBO                 200
#define IDC_STATICSCRIPT                201
#define IDC_STATICRANGE                 202
#define IDC_IMETABLE                    209
#define IDC_BROWSETABLE                 210
#define IDC_CUSTOMLISTFRAME             213
#define IDC_CUSTOMINFOFRAME             214
#define IDC_CUSTOMFRAME                 215
#define IDC_LISTFRAME1                  216
#define IDC_LISTFRAME2                  217
#define IDC_INFOFRAME                   218
#define IDC_CUSTOMFRAME2                219
#define IDC_CUSTOMFRAME3                220
#define IDC_TTFLIST                     221
#define IDC_RADIO_SYSTEM                222
#define IDC_RADIO_DBCS                  223
#define IDC_LIST_SYSTEM                 224
#define IDC_CODE_NAME                   225
#define IDC_ICON_HOR                    226
#define IDC_ICON_VER                    227
#define IDC_ICON_R90                    228
#define IDC_ICON_R180                   229
#define IDC_ICON_R270                   230
#define IDC_STATICS                     231
#define IDC_UPRIGHT                     231
#define IDD_RADICAL                     232
#define IDC_ROTATE_GROUP                234
#define IDC_STANDARD_GROUP              235
#define IDC_DBCS_GROUP                  236
#define IDC_COLUMNHEADING               237
#define IDC_SELECTCHARSET               238
#define IDC_STATICBMP                   240
#define IDC_STATICIMETBL                241
#define ID_STATUS_CHARSET               300
#define ID_STATUS_CODE                  301
#define ID_STATUS_FONT                  302
#define ID_STATUS_FILE                  303
#define IDC_COLUMNHEADINGR              304
#define IDH_EUDC_ASSOCIATE              1010
#define IDH_EUDC_ASSO_STANDARD          1011
#define IDH_EUDC_ASSO_LIST              1012
#define IDH_EUDC_MODIFY                 1013
#define IDH_EUDC_REMOVE                 1014
#define IDH_EUDC_ASSO_TYPEFACE          1015
#define IDH_EUDC_MODFILE                1020
#define IDH_EUDC_SELLIST                1030
#define IDH_EUDC_SELCODE                1031
#define IDH_EUDC_SELFONT                1032
#define IDH_EUDC_SELFILE                1033
#define IDH_EUDC_SELCHAR                1034
#define IDH_EUDC_SELRANGE               1035
#define IDH_EUDC_REFLIST                1040
#define IDH_EUDC_REFCODE                1041
#define IDH_EUDC_REFFONT                1042
#define IDH_EUDC_REFCHAR                1043
#define IDH_EUDC_IMPOBMP                1050
#define IDH_EUDC_FLIPH                  1060
#define IDH_EUDC_FLIPV                  1061
#define IDH_EUDC_ROTA90                 1062
#define IDH_EUDC_ROTA180                1063
#define IDH_EUDC_ROTA270                1064
#define IDH_EUDC_EXAMPLE                1065
#define IDH_EUDC_OK                     1070
#define IDH_EUDC_CANCEL                 1071
#define IDH_EUDC_BROWSE                 1072
#define IDH_EUDC_FONT                   1073
#define IDH_EUDC_BROWSE_TTF             1080
#define IDH_EUDC_LINK_IMELIST           1090
#define IDH_EUDC_BLINK_EDITTBL          1100
#define IDH_EUDC_OUTCAUTION             1200
#define IDH_EUDC_REGLIST                1530
#define IDH_EUDC_REGCODE                1531
#define IDH_EUDC_REGFONT                1532
#define IDH_EUDC_REGFILE                1533
#define IDH_EUDC_REGCHAR                1534
#define IDH_EUDC_REGRANGE               1535
#define IDH_EUDC_CALLLIST               1540
#define IDH_EUDC_CALLCODE               1541
#define IDH_EUDC_CALLFONT               1542
#define IDH_EUDC_CALLCHAR               1543
#define IDW_STYLES                      32771
#define ID_TOOLBAR                      32772
#define ID_REFFERFILE_NEW               32775
#define ID_READ_CHAR                    32776
#define ID_GAIJI_COPY                   32777
#define ID_GAIJI_CUT                    32778
#define ID_GAIJI_PASTE                  32779
#define ID_SAVE_CHARAS                  32780
#define ID_SAVECHAR                     32781
#define ID_GAIJI_UNDO                   32782
#define ID_FIT_CURVE                    32783
#define ID_SELECTFAMILY                 32784
#define ID_PALETTEBRUSH                 32785
#define ID_REFFER_CLOSE                 32788
#define ID_SHOW_GRID                    32789
#define ID_DELETE_EDIT                  32790
#define ID_LINKIME                      32791
#define ID_PALETTEFREEFORM              32794
#define ID_NEXTCODE                     32795
#define ID_PREVCODE                     32796
#define ID_CALL_CHAR                    32797
#define ID_IMPORT_FILE                  32798
#define ID_ROTATE                       32799
#define ID_LINKBATCHMODE                32802
#define ID_PALETTEERASER                32803
#define IDS_APPSELECTION                61216
#define IDS_SELECTCODE_DLGTITLE         61216
#define IDS_APPENTRY                    61217
#define IDS_REGISTAS_DLGTITLE           61217
#define IDS_NOTSELCHARACTER_MSG         61220
#define IDS_REFERENCE_DLGTITLE          61222
#define IDS_ILLEGALCODE_MSG             61223
#define IDS_ILLEGALCODE_TITLE           61224
#define IDS_LINK_DLGTITLE               61226
#define IDS_ILLEGALFILE_MSG             61229
#define IDS_MODIFY_DLGTITLE             61230
#define IDS_NOTEUDCFILE_MSG             61231
#define IDS_NOUSEEUDCFILE_MSG           61232
#define IDS_NOTCREATEEUDC_MSG           61233
#define IDS_SAVEORNOT                   61234
#define IDS_ASSOCIATE_DLGTITLE          61235
#define IDS_NOTSELTYPEFACE_MSG          61236
#define IDS_NOTSELECT_STR               61238
#define IDS_EDIT_STR                    61239
#define IDS_REFERENCE_STR               61240
#define IDS_FONT_STR                    61241
#define IDS_FILE_STR                    61242
#define IDS_MAINFRAMETITLE              61243
#define IDS_INVALIDREAD_MSG             61245
#define IDS_CODE_STR                    61246
#define IDS_MODIFYREAD_MSG              61248
#define IDS_CALL_DLGTITLE               61249
#define IDS_SYSTEMEUDCFONT_STR          61250
#define IDS_WANSUNG_STR                 61251
#define IDS_JOHAB_STR                   61252
#define IDS_BATCHIME_FILTER             61255
#define IDS_FILEHEADER_MSGTITLE         61256
#define IDS_FILEHEADER_MSG              61257
#define IDS_FILESIZE_MSGTITLE           61258
#define IDS_FILESIZE_MSG                61259
#define IDS_INMETHOD_MSGTITLE           61260
#define IDS_INMETHOD_MSG                61261
#define IDS_BANKID_MSGTITLE             61262
#define IDS_BANKID_MSG                  61263
#define IDS_CODEPAGE_MSGTITLE           61264
#define IDS_CODEPAGE_MSG                61265
#define IDS_SIGN_MSGTITLE               61266
#define IDS_SIGN_MSG                    61267
#define IDS_BATCHLNK_DLGTITLE           61268
#define IDS_NOTOPEN_MSG                 61269
#define IDS_BROWSETTF_DLGTITLE          61270
#define IDS_NOTSELECTTTF_MSG            61271
#define IDS_IMPORT_DLGTITLE             61272
#define IDS_NOTUSERFONT_MSG             61273
#define IDS_BROWSEUSER_DLGTITLE         61274
#define IDS_ROTATE_DLGTITLE             61275
#define IDS_BROWSETABLE_DLGTITLE        61276
#define IDS_DEFAULTFILENAME             61277
#define IDS_IMPORT_JAPAN_FILTER         61278
#define IDS_NOTENOUGHMEMORY_ERROR       61279
#define IDS_IMPORT_CHINA_FILTER         61280
#define IDS_INTERNAL_TITLE              61281
#define IDS_INTERNAL_MSG                61282
#define IDS_NOTOPEN_TITLE               61283
#define IDS_UNMATCHED_TITLE             61284
#define IDS_UNMATCHED_MSG               61285
#define IDS_CHINESE_CHAR                61286
#define IDS_QUERY_NOTFINISH             61287
#define IDS_QUERY_REGISTER              61288
#define IDS_NOIME_TITLE                 61289
#define IDS_NOIME_MSG                   61290
#define IDS_NOMEM_TITLE                 61291
#define IDS_NOMEM_MSG                   61292
#define IDS_EUDCTTF_FILTER              61293
#define IDS_SELECTFONT_ERROR            61294
#define IDS_CHARSET_STR                 61295
#define IDS_UNICODE                     61297
#define IDS_SHIFTJIS                    61298
#define IDS_GB2312                      61299
#define IDS_HANGUL                      61300
#define IDS_CHINESEBIG5                 61301
#define IDS_INVALID_CODE_MSG            61302
#define IDS_IMPORTFONT_MSG              61303
#define IDS_OVERWRITEFAIL               61304
#define IDS_ACCESSDENIED                61305
#define IDS_NOTTE                       61306

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        165
#define _APS_NEXT_COMMAND_VALUE         32811
#define _APS_NEXT_CONTROL_VALUE         242
#define _APS_NEXT_SYMED_VALUE           151
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\sources.inc ===
!IF 0

Copyright (c) 1991-2000 Microsoft Corporation.

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF


#
# Fusionized
# 
SXS_ASSEMBLY_NAME=Microsoft.Windows.eudcedit
SXS_ASSEMBLY_VERSION=1.0 
SXS_APPLICATION_MANIFEST=eudcedit.Manifest

TARGETNAME=eudcedit
TARGETPATH=obj
TARGETTYPE=PROGRAM


PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafx.obj

INCLUDES=..

C_DEFINES=-DWINVER=0x0500 -DBUILD_ON_WINNT -DNEWREG

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\ASSOCDLG.CPP \
        ..\BLINKDLG.CPP \
        ..\BMPOPE.CPP   \
        ..\CODE.CPP     \
        ..\CREATE.CPP   \
        ..\DATAIF.CPP   \
        ..\EDITWND.CPP  \
        ..\ETEN.CPP     \
        ..\EUDCDLG.CPP  \
        ..\EUDCEDIT.CPP \
        ..\EUDCLIST.CPP \
        ..\EUDCRANG.CPP \
        ..\FITCONIC.CPP \
        ..\GAGEDLG.CPP  \
        ..\GUIDEBAR.CPP \
        ..\IMEBLINK.C   \
        ..\IMELIST.C    \
        ..\IMPORT.CPP   \
        ..\IMPRTDLG.CPP \
        ..\MAINFRM.CPP  \
        ..\MAKEPOLY.CPP \
        ..\REFRDLG.CPP  \
        ..\REFRLIST.CPP \
        ..\REFRWND.CPP  \
        ..\REGISTRY.CPP \
        ..\ROTATDLG.CPP \
        ..\SMOOTH.CPP   \
        ..\TTFFILE.CPP  \
        ..\UTIL.CPP     \
        ..\VDATA.CPP    \
        ..\W31JBMP.CPP  \
        ..\W31JEUDC.CPP \
        ..\EUDCEDIT.RC

UMTYPE=windows
UMENTRY=winmain

UMLIBS=$(SDK_LIB_PATH)\comdlg32.lib  \
       $(SDK_LIB_PATH)\shell32.lib   \
       $(SDK_LIB_PATH)\gdi32.lib     \
       $(SDK_LIB_PATH)\htmlhelp.lib  \
       $(SDK_LIB_PATH)\imm32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\stdafx.cpp ===
/**************************************************/
/*					                              */
/*		For MFC			                          */
/*					                              */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\stdafx.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//
#include <afxwin.h>         // MFC core and standard components
#include <afxcmn.h>         // for tooltips
#include <afxext.h>         // MFC extensions (including VB)
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxpriv.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\rotatdlg.cpp ===
/**************************************************/
/*					                              */
/*					                              */
/*	Rotate Bitmap in Edit Window	              */
/*		(Dialog)		                          */
/*					                              */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include 	"stdafx.h"
#include 	"eudcedit.h"
#include 	"rotatdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/****************************************/
/*					*/
/*	Default Constructor		*/
/*					*/
/****************************************/
CRotateDlg::CRotateDlg( CWnd* pParent)
	: CDialog(CRotateDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CRotateDlg)
	//}}AFX_DATA_INIT
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_INITDIALOG"		*/
/*					*/
/****************************************/
BOOL
CRotateDlg::OnInitDialog()
{
	CString	DlgTitle;

	CDialog::OnInitDialog();

//	Implement "?" in this dialogbox.
	LONG WindowStyle = GetWindowLong( this->GetSafeHwnd(), GWL_EXSTYLE);
	WindowStyle |= WS_EX_CONTEXTHELP;
	SetWindowLong( this->GetSafeHwnd(), GWL_EXSTYLE, WindowStyle);

//	Set Dialog title name.
	DlgTitle.LoadString(IDS_ROTATE_DLGTITLE);
	this->SetWindowText( DlgTitle);

	RadioItem = FLIP_HOR;
	this->SendDlgItemMessage( IDC_FLIPHOR, BM_SETCHECK,(WPARAM)1,(LPARAM)0);
	return TRUE;
}

/****************************************/
/*					*/
/*	COMMAND	"IDOK"			*/
/*					*/
/****************************************/
void
CRotateDlg::OnOK()
{
	if( RadioItem == NOTSEL){
		MessageBeep((UINT)-1);
		return;
	}
	CDialog::OnOK();
}

/****************************************/
/*					*/
/*	COMMAND	"FLIP HORIZONTAL"	*/
/*					*/
/****************************************/
void
CRotateDlg::OnFliphor()
{
	RadioItem = FLIP_HOR;
}

/****************************************/
/*					*/
/*	COMMAND	"FLIP VERTICAL"		*/
/*					*/
/****************************************/
void
CRotateDlg::OnFlipver()
{
	RadioItem = FLIP_VER;
}

/****************************************/
/*					*/
/*	COMMAND	"ROTATE 90"		*/
/*					*/
/****************************************/
void CRotateDlg::OnRotate90()
{
	RadioItem = ROTATE_9;
}

/****************************************/
/*					*/
/*	COMMAND	"ROTATE 180"		*/
/*					*/
/****************************************/
void
CRotateDlg::OnRotate180()
{
	RadioItem = ROTATE_18;
}

/****************************************/
/*					*/
/*	COMMAND	"ROTATE 270"		*/
/*					*/
/****************************************/
void CRotateDlg::OnRotate270()
{
	RadioItem = ROTATE_27;
}

static DWORD aIds[] =
{
//	IDC_ROTATE_GROUP, IDH_EUDC_OUTCAUTION,
	IDC_FLIPHOR, IDH_EUDC_FLIPH,
	IDC_ICON_HOR, IDH_EUDC_FLIPH,
	IDC_FLIPVER, IDH_EUDC_FLIPV,
	IDC_ICON_VER, IDH_EUDC_FLIPV,
	IDC_ROTATE90, IDH_EUDC_ROTA90,
	IDC_ICON_R90, IDH_EUDC_ROTA90,
	IDC_ROTATE180, IDH_EUDC_ROTA180,
	IDC_ICON_R180, IDH_EUDC_ROTA180,
	IDC_ROTATE270, IDH_EUDC_ROTA270,
	IDC_ICON_R270, IDH_EUDC_ROTA270,
	IDC_UPRIGHT, IDH_EUDC_EXAMPLE,
//	IDOK, IDH_EUDC_OK,
//	IDCANCEL, IDH_EUDC_CANCEL,
	0,0
};

/****************************************/
/*					*/
/*	Window procedure		*/
/*					*/
/****************************************/
LRESULT
CRotateDlg::WindowProc(
UINT 	message,
WPARAM 	wParam,
LPARAM 	lParam)
{
	if( message == WM_HELP){
		::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
			HelpPath, HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);
		return(0);
	}
	if( message == WM_CONTEXTMENU){
		::WinHelp((HWND)wParam, HelpPath,
			HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)aIds);
		return(0);
	}		
	return CDialog::WindowProc(message, wParam, lParam);
}

BEGIN_MESSAGE_MAP(CRotateDlg, CDialog)
	//{{AFX_MSG_MAP(CRotateDlg)
	ON_BN_CLICKED(IDC_FLIPHOR, OnFliphor)
	ON_BN_CLICKED(IDC_FLIPVER, OnFlipver)
	ON_BN_CLICKED(IDC_ROTATE180, OnRotate180)
	ON_BN_CLICKED(IDC_ROTATE270, OnRotate270)
	ON_BN_CLICKED(IDC_ROTATE90, OnRotate90)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\util.h ===
/**************************************************/
/*					                              */
/*					                              */
/*	EudcEditor Utillity funcs	                  */
/*					                              */
/*					                              */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

int  OutputMessageBox( HWND hWnd, UINT TitleID, UINT MessgID, BOOL OkFlag);
#ifdef BUILD_ON_WINNT
int  OutputMessageBoxEx( HWND hWnd, UINT TitleID, UINT MessgID, BOOL OkFlag, ...);
#endif // BUILD_ON_WINNT
void GetStringRes( LPTSTR lpStr, UINT sID);
void ConvStringRes( LPTSTR lpStr, CString String);

#ifdef UNICODE
#define Mytcsrchr wcsrchr
#define Mytcschr wcschr
#define Mytcstok wcstok
#define Mytcstol wcstol
#define Mytcsstr wcsstr
#define Myttoi _wtoi
#else
char * Mystrrchr(char *pszString, char ch);
char * Mystrchr(char *pszString, char ch);
#define Mytcsrchr Mystrrchr
#define Mytcschr Mystrchr
#define Mytcstok strtok
#define Mytcstol strtol
#define Mytcsstr strstr
#define Myttoi atoi
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\ttfstruc.h ===
/*
 *	TrueType File Format Structure Definitions
 *
 * Copyright (c) 1997-1999 Microsoft Corporation.
 */
/*  Whole :
	+-----------------------+
	| Header		|
	+-----------------------+
	| Tables		|
	|			|
		    |
	|			|
	+-----------------------+
    Header :
	----------------------------------------------------------
	  Fixed		sfnt version	0x00010000
	  ushort	numTables	Number of tables
	  ushort	searchRange	(n^2 <= numtables)*16
	  ushort	entrySelector	Log2(n^2<=numTables)
	  ushort	rangeShift	NumTables*16-searchRange
	     Table Directory Entries
	----------------------------------------------------------
    Table Directory:
	----------------------------------------------------------
	  ulong		tag		4-byte idetifier
	  ulong		checkSum	CheckSum for this table
	  ulong		offset		offset from beginning of
					TrueType font file
	  ulong		length		Length of this table
	----------------------------------------------------------

    Tables:
	----------------------------------------------------------
	  cmap		character to glyph mapping
	  glyf		glyph data
	  head		font header
	  hhea		horizontal header
	  hmtx		hosizontal metrics
	  loca		index to location
	  maxp		maximum profile
	  name		naming table
	  post		PostScript information
	  OS/2		OS/2 and Windows specific metrics
		--------------------------
	  cvt		Control Value Table
	  fpgm		font program
	  hdmx		hosizontal device metrics
	  kern		kerning
	  LTSH		Linear threshold table
	  prep		CVT Program
	  WIN 		(reserved)
	  VDMX		Vertical Device Metrics table
	  FOCA		Reserved for IBM Font Object Content Architecture data
	  PCLT		PCL 5 table
	  mort		glyph metamorphosis table
		--------------------------
	  vhea		Vertical Header table
	  vmtx		Vertical metrics table
	----------------------------------------------------------
*/
#define		TAGSIZ	4
struct TTFHeader {
	char	sfnt_version[4];
	short	numTables;
	short	searchRange;
	short	entrySelector;
	short	rangeShift;
	};
struct TableEntry {
	char	tagName[TAGSIZ];
	unsigned long	checkSum;
	long	ofs;
	long	siz;
	};


/***
 *	cmap
 ***/
struct CmapHead {
	short	version;
	short	nTbls;
	};

struct CmapEncodingTbl {
	short	PlatformID;
	short	PlatformSpecEncID;
	long	ofs;
	};

struct CmapSubtable {
	short	format;
	short	length;
	short	version;
	short	segCnt2;
	short	searchRange;
	short	rangeShift;
	short	endCnt[2];
	short	reservedPad;
	short	startCnt[2];
	short	idDelta[2];
	short	idRangeOfs[2];
	};
/***
 *	maxp
 ***/
struct MaxpTbl {
	char	version[4];
	short	numGlyph;
	short	maxPoints;
	short	maxContours;
	short	maxCompositePoints;
	short	maxCompositeContours;
	short	maxZones;
	short	maxTwilightPoints;
	short	maxStorage;
	short	maxFunctionDefs;
	short	maxInstructiondefs;
	short	maxStackElements;
	short	maxSizeOfInstructions;
	short	maxComponentElements;
	short	maxComponentDepth;
	};
/***
 *	name
 ***/
struct NamingTable {
	short	FormSel;
	short	NRecs;
	short	OfsToStr;
	/* Following NameRecords */
	};
struct NameRecord {
	short	PlatformID;
	short	PlatformSpecEncID;
	short	LanguageID;
	short	NameID;
	short	StringLength;
	short	StringOfs;
	};
/***
 *	head
 ***/
struct HeadTable {
	char	version[4];		/* 0x00010000 */
	char	revision[4];
	unsigned long	chkSum;
	unsigned long	magicNumber;	/* 0x5F0F3CF5 */
	short	flags;
	short	unitsPerEm;
	char	createdDate[8];
	char	updatedDate[8];
	short	xMin;
	short	yMin;
	short	xMax;
	short	yMax;
	short	macStyle;
	short	lowestRecPPEM;
	short	fontDirectionHint;
	short	indexToLocFormat;
	short	glyphDataFormat;	/* 0*/
	};
/***
 *	hhea
 ***/
struct HheaTable	{
	char	version[4];
	short	Ascender;
	short	Descender;
	short	LineGap;
	short	advanceWidthMax;
	short	minLeftSideBearing;
	short	minRightSideBearing;
	short	xMaxExtent;
	short	caretSlopeRise;
	short	caretSlopeRun;
	short	reserved[5];
	short	metricDataFormat;
	short	numberOfHMetrics;
	};
/***
 *	hmtx
 ***/
 struct HMetrics {
	short	advanceWidth;
	short	leftSideBearing;
	};
/***
 *	vhea
 ***/
struct VheaTable	{
	char	version[4];
	short	Ascender;
	short	Descender;
	short	LineGap;
	short	advanceHeightMax;
	short	minTopSideBearing;
	short	minBottomSideBearing;
	short	yMaxExtent;
	short	caretSlopeRise;
	short	caretSlopeRun;
	short	caretOffset;
	short	reserved[4];
	short	metricDataFormat;
	short	numOfLongVerMetrics;
	};
/***
 *	vmtx
 ***/
 struct VMetrics {
	short	advanceHeight;
	short	topSideBearing;
	};
/***
 *	post
 ***/
struct postTable {
	char	FormatType[4];	/* 00030000 */
	long	italicAngle;
	short	underlinePosition;
	short	underlineThickness;
	unsigned long	isFixedPitch;
	unsigned long	minMemType42;
	unsigned long	maxMemType42;
	unsigned long	minMemType1;
	unsigned long	maxMemType1;
	};
/***
 *	OS/2
 ***/
/*
typedef struct {
	char	bFamily;
	char	bSerifStyle;
	char	bWeight;
	char	bProportion;
	char	bContrast;
	char	bStrokeVariation;
	char	bArmStyle;
	char	bLetterform;
	char	bMidline;
	char	bXHeight;
	} PANOSE;
*/
struct OS2Table {
	unsigned short	version;
	short	xAvgCharWidth;
	unsigned short	usWeightClass;
	unsigned short	usWidthClass;
	short	fsType;
	short	ySubscriptXSize;
	short	ySubscriptYSize;
	short	ySubscriptXOffset;
	short	ySubscriptYOffset;
	short	ySuperscriptXSize;
	short	ySuperscriptYSize;
	short	ySuperscriptXOffset;
	short	ySuperscriptYOffset;
	short	yStrikeoutSize;
	short	yStrikeoutPosition;
	short	sFamilyClass;
	PANOSE	panose;
	unsigned long	ulCharRange[4];
	char	achVendID[4];
	unsigned short	fsSelection;
	unsigned short	usFirstCharIndex;
	unsigned short	usLastCharIndex;
	short	sTypoAscender;
	short	sTypoDescender;
	short	sTypoLineGap;
	unsigned short	usWinAscent;
	unsigned short	usWinDescent;
	};
/***
 *	glyf
 ***/
struct glyfHead {
	short	numberOfContour;
	short	xMin, yMin;
	short	xMax, yMax;
	};
/** glyf data flag definition **/
	
#define	GLYF_ON_CURVE	0x01
#define	GLYF_X_SHORT	0x02	/* x is short */
#define	GLYF_Y_SHORT	0x04	/* y is short */
#define	GLYF_X_SHORT_N	0x02	/* x is short & negative */
#define	GLYF_Y_SHORT_N	0x04	/* y is short & negative */
#define	GLYF_X_SHORT_P	0x12	/* x is short & positive */
#define	GLYF_Y_SHORT_P	0x24	/* y is short & positive */
#define	GLYF_REPEAT	0x08
#define	GLYF_X_SAME	0x10
#define	GLYF_Y_SAME	0x20

/***
 *	Bounding Box ( Not for file structure )
 ***/
struct BBX	{
	int	xMin, yMin;
	int	xMax, yMax;
	};

/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\vdata.cpp ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//

#include	"stdafx.h"


#define		LISTDATAMAX	4

#define		NIL	(void *)0

struct vecdata	{
	short	x, y, atr;
	};

struct VDATA	{
	struct VDATA	*next, *prev;
	struct vecdata	vd;
	};

struct VHEAD	{
	struct VHEAD	*next, *prev;
	struct VDATA	*headp;
	int		nPoints;
	};
struct VCNTL	{
	struct VHEAD	*rootHead;
	struct VHEAD	*currentHead;
	int		nCont;
	struct VDATA	*cvp;
	int	mendp;
	void	*memroot;
	void	*cmem;
	};


int  VDInit(void);
void  VDTerm(void);
void  VDNew(int  lsthdl);
int  VDClose(int  lsthdl);
int  VDSetData(int  lsthdl,struct  vecdata *pnt);
int  VDGetData(int  lsthdl,int  contN,int  pn,struct  vecdata *pnt);
int  VDGetHead(int  lsthdl,struct  VHEAD * *vhd);
static void  *getmem(int  lsthdl,int  siz);
int  VDGetNCont(int  lstHdl);
int  VDReverseList(int  lstHdl);
int  VDCopy(int  srcH,int  dstH);

struct VCNTL	VCntlTbl[LISTDATAMAX];
#define		ALLOCMEMUNIT	2048

static int	init=0;
/***********************************************************************
 *	initialize data
 */
/* */	int
/* */	VDInit()
/*
 *	returns : 0, -1( out of memory)
 ***********************************************************************/
{
	int	lsthdl;
	void	*mem;

	if ( init)
		return( 0);
	for( lsthdl = 0; lsthdl < LISTDATAMAX; lsthdl++) {
		/* Allocate First memory */
		mem = (void *)malloc( ALLOCMEMUNIT);
		if ( mem==NIL)	
			return( -1);
		*((void **)mem) = NIL;
		VCntlTbl[lsthdl].memroot = mem;
		VDNew(lsthdl);
	}

	init = 1;
	return( 0);
}
/***********************************************************************
 *	Terminate
 */
/* */	void
/* */	VDTerm()
/*
 *	returns : none
 ***********************************************************************/
{
	void	*mem, *nextmem;
	int	lsthdl;
	if ( init) {
		for( lsthdl = 0; lsthdl < LISTDATAMAX; lsthdl++) {
			mem = VCntlTbl[lsthdl].memroot;
			do {
				nextmem = *((void * *)mem);
				free( mem);
				mem = nextmem;
			} while ( mem!=NIL);
		}
		init = 0;
	}
	return;
}
/***********************************************************************
 *	New Data
 */
/* */	void
/* */	VDNew(int lsthdl)
/*
 *	returns : none
 ***********************************************************************/
{
struct VCNTL	*vc;

	vc = VCntlTbl+lsthdl;
	vc->cmem = vc->memroot;
	vc->mendp  =  sizeof( void *);
	vc->currentHead = vc->rootHead = (struct VHEAD *)((char *)(vc->cmem)+vc->mendp);
	vc->mendp += sizeof( struct VHEAD);

	vc->currentHead->prev = (struct VHEAD *)NIL;
	vc->currentHead->next = (struct VHEAD *)NIL;
	vc->currentHead->headp = (struct VDATA *)NIL;
	vc->currentHead->nPoints = 0;
	vc->cvp = (struct VDATA *)NIL;
	vc->nCont = 0;

}
/***********************************************************************
 *	Close Contour
 */
/* */	int
/* */	VDClose(int lsthdl)
/*
 *	returns : none
 ***********************************************************************/
{
struct VHEAD	*vh;
struct VCNTL	*vc;

	vc = VCntlTbl+lsthdl;

	vc->cvp->next = vc->currentHead->headp;
	vc->currentHead->headp->prev = vc->cvp;
	vh = (struct VHEAD *)getmem( lsthdl, sizeof(struct VHEAD));
	if ( vh == NIL)	return( -1);
	vc->currentHead->next = vh;
	vh->prev = vc->currentHead;
	vh->next = (struct VHEAD *)NIL;
	vh->headp = (struct VDATA *)NIL;
	vh->nPoints = 0;
	vc->currentHead = vh;
	vc->cvp = (struct VDATA *)NIL;
	vc->nCont++;

	return (0);
}
/***********************************************************************
 *	Set Data
 */
/* */	int
/* */	VDSetData ( 
/* */		int lsthdl,
/* */	struct vecdata	*pnt)
/*
 *	return : 0, -1 ( no memory)
 ***********************************************************************/
{
	void	*mem;
struct VCNTL	*vc;

	vc = VCntlTbl+lsthdl;

	mem = getmem( lsthdl,sizeof(  struct VDATA));
	if ( mem == NIL) {
		return -1;
	}
	if ( vc->cvp== NIL) {	/* Contour First Point*/
		vc->cvp = vc->currentHead->headp = (struct VDATA *)mem;
		vc->cvp->vd = *pnt;
		vc->cvp->next = vc->cvp->prev= (struct VDATA *)NIL;
	}
	else {
		vc->cvp->next = (struct VDATA *)mem;
		vc->cvp->next->prev = vc->cvp;
		vc->cvp = vc->cvp->next;
		vc->cvp->vd = *pnt;
		vc->cvp->next =(struct VDATA *) NIL;
	}
	vc->currentHead->nPoints++;
	return  0;
}
/***********************************************************************
 *	Get Data
 */
/* */	int
/* */	VDGetData( 
/* */	int	lsthdl, 
/* */	int	contN, 
/* */	int	pn, 
/* */	struct  vecdata *pnt)
/*
 *	returns : 0, -1 ( Illeagal Coontour Number)
 ***********************************************************************/
{
struct VHEAD	*vhd;
struct VDATA	*cvd;


	if ( lsthdl <0 ||lsthdl >= LISTDATAMAX) 
		return -1;
	if ((vhd = VCntlTbl[lsthdl].rootHead)==NIL)
		return -1;
	while ( contN-->0)
		vhd = vhd->next;
	cvd = vhd->headp;
	while ( pn-->0)
		cvd = cvd->next;

	*pnt = cvd->vd;

	return	0;
}
/***********************************************************************
 *	Get Data Head
 */
/* */	int
/* */	VDGetHead( 
/* */	int	lsthdl, 
/* */	struct VHEAD	**vhd)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
	if ( lsthdl >= 0 && lsthdl < LISTDATAMAX) {
		*vhd = VCntlTbl[lsthdl].rootHead;
		return( 0);
	}
	else
		return( -1);
}
/***********************************************************************
 *	Get Memory
 */
/* */	static void *
/* */	getmem(	int lsthdl, int	siz)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
	void	*mem;
struct VCNTL	*vc;

	vc = VCntlTbl+lsthdl;

	if ( vc->mendp + siz >= ALLOCMEMUNIT) {
		mem = *((void **)vc->cmem);
		if ( mem == NIL ) {
			mem = (void *)malloc(ALLOCMEMUNIT);
			if ( mem == NIL)
				return( NIL);
			*((void * *)mem) = NIL;
			*((void * *)vc->cmem) = mem; /* */
			vc->cmem = mem;
		}
		else
			vc->cmem  = mem;
		vc->mendp = sizeof(void *); 
	}
	mem = (void *)((char *)(vc->cmem) + vc->mendp);
	vc->mendp += siz;
	return(mem );
}
/***********************************************************************
 *	Get Number of COntours
 */
/* */	int
/* */	VDGetNCont( int lstHdl)
/*
 *	returns : Number of Contour
 ***********************************************************************/
{
	if ( lstHdl >= 0 && lstHdl < LISTDATAMAX)
		return VCntlTbl[lstHdl].nCont;
	else
		return( -1);
}
/***********************************************************************
 *	Reverse List
 */
/* */	int
/* */	VDReverseList(  int lstHdl)
/*
 *	returns : 0, -1 ( handle No )
 ***********************************************************************/
{
	int	cont;
	int	np;
struct VHEAD	*vh;
struct VDATA	*vp, *nvp;

	if ( lstHdl < 0 || lstHdl >= LISTDATAMAX)
		return -1;
	vh = VCntlTbl[lstHdl].rootHead;
	for ( cont = 0; cont < VCntlTbl[lstHdl].nCont; cont++ ) {
		vp = vh ->headp;
		np = vh->nPoints;
		while ( np-->0) {
			nvp = vp->next;
			vp->next = vp->prev;
			vp->prev = nvp;
			vp = nvp;
		}
		vh = vh->next;
	}
	return 0;
}
/***********************************************************************
 *	Copy Data
 */
/* */	int
/* */	VDCopy( int srcH, int dstH)
/*
 *	returns : 0, -1(Invalid Handle)
 ***********************************************************************/
{
	int	cont;
	int	np;
struct VHEAD	*vh;
struct VDATA	*vp;

	if ( srcH < 0 || srcH >= LISTDATAMAX
	  || dstH < 0 || dstH >= LISTDATAMAX)
		return -1;

	VDNew( dstH);

	vh = VCntlTbl[srcH].rootHead;
	for ( cont = 0; cont < VCntlTbl[srcH].nCont; cont++ ) {
		vp = vh ->headp;
		np = vh->nPoints;
		while ( np-->0) {
			if ( VDSetData( dstH, &vp->vd))
				return -1;
			vp = vp->next;
		}
		vh = vh->next;
		VDClose( dstH);
	}
	return 0;
}
/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\util.cpp ===
/**************************************************/
/*					                              */
/*					                              */
/*	EudcEditor Utillity funcs	                  */
/*					                              */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include	"stdafx.h"
#include	"eudcedit.h"
#include	"util.h"

/****************************************/
/*					*/
/*	Output Message function		*/
/*					*/
/****************************************/
int 
OutputMessageBox(
HWND	hWnd,
UINT 	TitleID,
UINT	MessgID,
BOOL	OkFlag)
{
	CString	TitleStr, MessgStr;
	int	mResult;

	TitleStr.LoadString( TitleID);
	MessgStr.LoadString( MessgID);
	if( OkFlag){
		mResult = ::MessageBox( hWnd, MessgStr, TitleStr,
			MB_OK | MB_ICONEXCLAMATION);
	}else{
		mResult = ::MessageBox( hWnd, MessgStr, TitleStr,
			MB_YESNOCANCEL | MB_ICONQUESTION);
	}
	return mResult;
}

#ifdef BUILD_ON_WINNT
int 
OutputMessageBoxEx(
HWND	hWnd,
UINT 	TitleID,
UINT	MessgID,
BOOL	OkFlag,
        ...)
{
	CString	TitleStr, MessgStr;
	int	mResult;
    va_list argList;
    LPTSTR  MessageBody;

    va_start(argList, OkFlag);
	TitleStr.LoadString( TitleID);
	MessgStr.LoadString( MessgID);

    ::FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING,
                     MessgStr,0,0,(LPTSTR)&MessageBody,0,&argList);

    if( MessageBody ) {
    	if( OkFlag){
    		mResult = ::MessageBox( hWnd, MessageBody, TitleStr,
    			MB_OK | MB_ICONEXCLAMATION);
    	}else{
    		mResult = ::MessageBox( hWnd, MessageBody, TitleStr,
    			MB_YESNOCANCEL | MB_ICONQUESTION);
    	}
        ::LocalFree(MessageBody);
    }
	return mResult;
}
#endif // BUILD_ON_WINNT

/****************************************/
/*					*/
/*   	Get String from resource	*/
/*					*/
/****************************************/
void 
GetStringRes( 
LPTSTR 	lpStr, 
UINT 	sID)
{
	CString	cStr;
	int	StrLength;
	TCHAR 	*Swap;

	cStr.LoadString( sID);
	StrLength = cStr.GetLength();
	Swap = cStr.GetBuffer(StrLength + 1);
	lstrcpy( lpStr, Swap);
	cStr.ReleaseBuffer();

	return;
}

/****************************************/
/*					*/
/*   	Convert String from resource	*/
/*					*/
/****************************************/
void 
ConvStringRes( 
LPTSTR 	lpStr, 
CString	String)
{
	TCHAR 	*Swap;

	int StrLength = String.GetLength();
	Swap = String.GetBuffer(StrLength + 1);
	lstrcpy( lpStr, Swap);
	String.ReleaseBuffer();

	return;
}

#ifndef UNICODE
char * Mystrrchr(char *pszString, char ch)
{
	CHAR *p1, *p2;
	p1 = NULL;
	for (p2 = pszString; *p2; p2=CharNext(p2))
	{
		if (*p2 == ch)
		{
			p1 = p2;
		}
	}
	return (p1);
}

char * Mystrchr(char *pszString, char ch)
{
	CHAR *p;
	
	for (p = pszString; *p; p=CharNext(p))
	{
		if (*p == ch)
		{
			return (p);
		}
	}
	return (NULL);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\ttffile.cpp ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
#include	"stdafx.h"
#include	"eudcedit.h"
#include    "util.h"

#pragma		pack(2)


#include	"vdata.h"
#include	"ttfstruc.h"
#include	"extfunc.h"
/*
 *	TrueType File I/F
 */
#define		GLYPHBUFSIZ	0xFFFFL
#define		RWBUFSIZ	16384

#define		EUDCCODEBASE	((unsigned short)0xE000) /* 0xe000  uni-code */
#define		NUMTABLES	15

#define		NAMEBUFSIZ	1024
#define		NUMOFNAMEREC	8


static void  initDirEntry(struct  TableEntry *e,int  num);
static int  setDirEntry(struct  TableEntry *e,char  *tag);
void  smtoi(short  *sval);
void  lmtoi(long  *lval);
void  sitom(short  *sval);
void  litom(long  *lval);
static int  align32(int  siz);
static unsigned long  calchksum(char  *buf,int  siz);
static int  copyblk(HDC  hDC,char  *tag,int  ofHdl,long  siz,char  *buf,int  bufsiz,unsigned long  *cs);
static int  mergeblock(HDC  hDC,struct  TableEntry *entry,int  ofHdl);
static int  tableChkSum(int  fH,struct  TableEntry *te);
static int  codeToGID(unsigned short  code);
int  TTFReadHdr(HANDLE  fHdl,struct  TTFHeader *hdr);
int  TTFWriteHdr(HANDLE  fHdl,struct  TTFHeader *hdr);
int  TTFReadDirEntry(HANDLE  fHdl,struct  TableEntry *entry,int  eCnt);
int  TTFWriteDirEntry(HANDLE  fHdl,struct  TableEntry *entry,int  eCnt);
static struct  TableEntry *searchEntry(struct  TableEntry *entry,int  eCnt,char  *tag);
int  TTFGetTableEntry(HANDLE  fH,struct  TableEntry *entry,char  *tag);
int  TTFReadTable(HANDLE  fH,struct  TableEntry *entry,void  *buf,int  bufsiz);
int  TTFReadFixedTable(HANDLE  fH,char  *buf,int  bufsiz,char  *tag);
int  TTFReadVarTable(HANDLE  fH,char  * *buf,unsigned int  *bufsiz,char  *tag);
int  TTFWriteTable(HANDLE  fH,struct  TableEntry *entry,void  *buf,int  bufsiz);
int  TTFAppendTable(HANDLE  fH,struct  TableEntry *entry,void  *buf,int  siz);
static int  TTFMergeTable(HDC  hDC,HANDLE  nfh,char  *tag,struct  TableEntry *nte);
#ifdef BUILD_ON_WINNT
static int __cdecl compentry(const void  *e1,const void  *e2);
#else
static int  compentry(const void  *e1,const void  *e2);
#endif // BUILD_ON_WINNT
static void  SortEntry(struct  TableEntry *ebuf,int  num);
static int  fileChkSum(HANDLE  fh,struct  TableEntry *entry,int  numEntry,struct  TTFHeader *hdr,struct  HeadTable *head);
static void  makeTTFHeader(struct  TTFHeader *hdr,int  nTbl);
static int  makeGlyphData(int  lstH,struct  BBX *bbx,char  *glyphData,int  bufsiz,int  *gdatsiz);
static void  initsetgbuf(char  *b,int  lim);
static int  setgbuf(char  *dat,int  siz,char  * *np);
static int  termbuf(void);
static int  strwlen(char  *s);
static void  strwcat(char  *s1,char  *s2);
static void  setnamebuf(char  *buf,int  *siz, short EncodingID);
static void  modifyOS2(char  *buf);
static void  modifyhead(struct  HeadTable *head);
static void  setVhea(struct  VheaTable *vhea,struct  HheaTable *hhea,struct  BBX *bbx);
static int  updateMaxp(struct  MaxpTbl *maxp,int  lstHdl);
static int  TTFGetOrgTableEntry(HDC  hDC,struct  TableEntry *entry,char  *tag);
int  TTFReadOrgFixedTable(HDC  hDC,char  *buf,int  bufsiz,char  *tag);
int  TTFReadOrgVarTable(HDC  hDC,char  * *buf,unsigned int  *bufsiz,char  *tag);
static void  setCountryData(short EncodingID);
static int  WIFEOS2(HDC  hDC,char  * *os2buf,int  *os2TblSiz,struct  BBX *bbx);
static void  WIFEhhea(struct  HheaTable *hhea,struct  BBX *bbx);
static void  WIFEhead(struct  HeadTable *head,struct  BBX *bbx);
static void  WIFEpost(struct  postTable *post);
int  TTFCreate(HDC  hDC,TCHAR  *newf,struct  BBX *bbx,int  lstHdl,int  fontType);
int  TTFGetBBX(HDC  hDC,struct  BBX *bbx,short  *uPEm);
int  TTFTmpPath(TCHAR  *path,TCHAR  *tmpPath);
static int  copyTable(HANDLE iFh,HANDLE oFh,struct  TableEntry *te,int  nEntry,char  *tag);
static int  copyfblock(HANDLE  iFh,HANDLE oFh,unsigned long  siz,unsigned long  *cs);
static int  mergeGlyph(HANDLE  iFh,HANDLE oFh,struct  TableEntry *tep,char  *locabuf,int  glyphID,char  *glyphData,int  glyphSiz);
static void  frebuf(void);
int  TTFOpen(TCHAR  *path);
int  TTFClose(void);
int  TTFGetEUDCBBX(TCHAR  *path,struct  BBX *bbx,short  *upem);
static void  makeMetrics(int  lsthdl,struct  HMetrics *hM,struct  VMetrics *vM,struct  BBX *bbx);
int  TTFAppend(unsigned short  code,struct  BBX *bbx,int  lsthdl);
int  TTFImpCopy(TCHAR  *sPath,TCHAR  *dPath);
int  TTFImpGlyphCopy(HANDLE sFh,int  glyphID);
int  TTFImpGlyphWrite(int  glyphID, char *buf, int siz);
int  TTFLastError();
/**
 * static variables
 **/
static struct TableEntry *et;
static int	entryNum;
static int	entryCnt;

static int	numOfGlyph=0;
static int	lastErr = 0;
/**
 * static table data
 **/
static char	cvtdata[] = {0, 0};
static char	fpgmdata[]={ (char)0xb0, (char)0x00, (char)0x2c, (char)0x2d};
static char	prepdata[]={(char)0xb8, 0x1, (char)0xff, (char)0x85,
				(char)0xb0, (char)0x01, (char)0x8d};
static char	maxpdata[]={	/* JPN */
			0x00, 0x01, 0x00, 0x00,
			(char)0x07, (char)0x5a,	/* 1882  numGlyph of JPN */
			0, 4, 0, 1 ,  		/* maxP, maxC(nullGlyf value)*/
			0, 0,  0, 0,		/* maxCom*2*/
			0, 1,  0, 0,		   /* maxZones, maxTw*/
			0, 0,  0, 1,		   /* maxStorage, maxFunc*/
			0, 0,  0, 1,		   /* maxI, maxStack */
			0, 1,  0, 1,  0, 1
			};
static char	cmapdata[] = {
			0, 0,  0, 1,
			0, 3,  0, 1,
			0, 0,  0, 12,
			0, 4,  0, 32,  0, 0,  0, 4,  0, 4,  0, 1, 0, 0,
			(char)0xe7, (char)0x57, (char) 0xff,(char) 0xff, 	/* last code */
			0, 0,
			(char)0xe0, (char)0x00,  (char)0xff,(char) 0xff,
			0x20, 0x02,  0x00, 0x01,
			0, 0,  0, 0
			};

static char	namerecstr[NUMOFNAMEREC][16] ={
			{ 0, '0', 0, '0', 0, 0},
			{ 0,'E', 0,'U', 0, 'D',0,'C', 0,0},
			{ 0,'R', 0, 'e', 0,'g', 0,'u', 0,'l', 0,'a', 0,'r',0,0},
			{ 0, '0', 0,'0', 0, 0},
			{ 0,'E', 0,'U', 0, 'D',0,'C', 0,0},
			{ 0, '0', 0,'0', 0, 0},
			{ 0, '0',  0,'0',0, 0},
			{ 0, '0',  0,'0',0, 0}
		};


static void
initDirEntry( struct TableEntry *e, int num)
{
	et = e;
	entryNum = num;
	entryCnt = 0;
}
static int
setDirEntry(struct TableEntry *e, char *tag)
{
	if ( entryCnt >= entryNum)
		return -1;
	memcpy( e->tagName, tag, TAGSIZ);
	*(et+entryCnt) = *e;
	entryCnt++;

	return 0;
}
void
smtoi( short *sval)
{
	short	retval;
	unsigned char	*cp;
	
	cp = (unsigned char *)sval;
	retval = *cp++;
	retval <<=8;
	retval += *cp;
	*sval = retval;
}
void
lmtoi( long *lval)
{
	long	retval;
	unsigned char	*cp;
	int	i;

	cp = (unsigned char *)lval;
	retval = (long)*cp++;
	for(i=0; i<3; i++) {
		retval <<=8;
		retval |= (long)*cp++;
	}
	*lval = retval;
}
void
sitom( short	*sval)
{
	unsigned char *cp;
	short	setval;

	setval = *sval;
	cp = (unsigned char *)sval;
	*cp++ = (unsigned char)((setval>>8)&0xff);
	*cp++ = (unsigned char)(setval&0xff);
}
void
litom( long	*lval)
{
	long	setval;
	int	i;
	unsigned char	*cp;

	setval = *lval;
	cp = (unsigned char *)lval;
	cp += 3;
	for ( i = 0; i<4; i++) {
		*cp--=(char )(setval&0xff);
		setval >>=8;
	}
}
static int
align32( int siz)
{
	siz = (siz + 3)/4 * 4;
	return siz;
}
static unsigned long
calchksum( char *buf, int siz)
{
	unsigned long	*csp;
	unsigned long	chksum;
	unsigned long	lval;
	unsigned char	pad[4];
	int	i;
	int	padsiz;
	unsigned char	*cp;
	int	csc;

	csp = (unsigned long *)buf;
	csc = siz/4;
	chksum = 0;
	while ( csc-->0) {
		lval = *csp++;
		lmtoi( (long *)&lval);
		chksum += lval;
	}	
	padsiz = (siz+3)/4*4 - siz;

	if ( padsiz) {
		cp = (unsigned char *)csp;
		i = 0;
		while (padsiz++<4)
			pad[i++]=*cp++;
		csp = (unsigned long *)pad;
		lval = *csp;
		lmtoi( (long *)&lval);
		chksum += lval;
	}
	return	chksum;
}
static int
copyblk(HDC hDC, char *tag, HANDLE ofHdl, long siz, char *buf, int bufsiz, unsigned long *cs)
{
	int	rwsiz;
	int	filsiz;
	int	aligne;
	unsigned long	chksum;
	long	ofs;
	DWORD	dwTable, nByte;

	dwTable = *(DWORD *)tag;
	filsiz = (int)(siz % 4);
	if ( filsiz)	filsiz = 4-filsiz;
	ofs = 0L;
	aligne =0;
	chksum = 0;
	while ( siz > 0) {
		if ( siz > bufsiz)
			rwsiz = bufsiz;
		else	{
			rwsiz = (int)siz;
			if ( filsiz)
				aligne =1;
		}
		if ( GetFontData(hDC, dwTable, (DWORD)ofs, buf,(DWORD)rwsiz )
			!= (DWORD)rwsiz)
			goto	ERET;

		if ( aligne ) {
			memset( buf+siz, 0, filsiz);
			rwsiz += filsiz;
		}
		chksum += calchksum( buf, rwsiz);

		BOOL res =  WriteFile( ofHdl, buf, (unsigned int)rwsiz, &nByte, NULL);
		if (!res || nByte !=(unsigned int)rwsiz)
			goto	ERET;
		siz -= rwsiz;
		ofs += rwsiz;
	}
	*cs = chksum;
	return 0;
ERET:
	return -1;
}
static int
mergeblock( HDC hDC, struct TableEntry *entry, HANDLE ofHdl)
{
	long	ofs;
	char	*mem;
	unsigned long	cs;	/* CheckSum value */

	mem = (char *)malloc((size_t) RWBUFSIZ);
	if ( mem==(char *)0)
		return -1;
	/* Obtain start offset of Output table */
	ofs = SetFilePointer( ofHdl, 0L, NULL, FILE_CURRENT);

	if (copyblk( hDC, entry->tagName, ofHdl, entry->siz, mem, RWBUFSIZ, &cs))
		goto	ERET;
	entry->ofs = ofs;
	entry->checkSum = cs;
	free( mem);
	return	0;
ERET:
	free( mem);
	return -1;
}
static int
tableChkSum( HANDLE fH, struct TableEntry *te)
{
	char	*rwbuf;
	unsigned long	cs;
	long	lsiz;
	int	rwsiz;

	if ( te->siz==0)
		return 0;
	if ((rwbuf = (char *)malloc( (size_t)RWBUFSIZ))==(char *)0)
		return -1;
	if ( (long) SetFilePointer( fH, te->ofs, NULL, FILE_BEGIN)!=te->ofs)
		goto	ERET;
	cs = 0;
	lsiz = te->siz;
	while ( lsiz > 0) {
		if (lsiz > RWBUFSIZ)
			rwsiz = RWBUFSIZ;
		else	rwsiz = (int)lsiz;
		lsiz -= rwsiz;
		cs += calchksum( rwbuf, rwsiz);
	}
	te->checkSum = cs;
	free( rwbuf);
	return 0;
ERET:
	free( rwbuf);
	return -1;
}
static int
codeToGID( unsigned short code)
{
	return	(int)( code - (unsigned short)EUDCCODEBASE +2);
}
int
TTFReadHdr ( HANDLE fHdl, struct TTFHeader *hdr)
{
	DWORD nBytesRead;
	SetFilePointer( fHdl, 0L, NULL, FILE_BEGIN);
	BOOL res=ReadFile( fHdl, hdr, sizeof(struct TTFHeader),&nBytesRead, NULL);
	if (!res || nBytesRead !=sizeof(struct TTFHeader)) {
		return -1;
	}
	smtoi( &hdr->numTables);
	smtoi( &hdr->searchRange);
	smtoi( &hdr->entrySelector);
	smtoi( &hdr->rangeShift);
	return	0;
}
int
TTFWriteHdr ( HANDLE fHdl, struct TTFHeader *hdr)
{
	struct TTFHeader whdr;

	whdr = *hdr;
	sitom( &whdr.numTables);
	sitom( &whdr.searchRange);
	sitom( &whdr.entrySelector);
	sitom( &whdr.rangeShift);

	if (SetFilePointer( fHdl, 0L, NULL,  FILE_BEGIN)!=0L)
		return -1;

	DWORD nByte;
	BOOL res = WriteFile( fHdl, (BYTE *) &whdr, sizeof(struct TTFHeader), &nByte, NULL);
	if (!res || nByte !=sizeof(struct TTFHeader))
		return -1;

	return	0;
}
int
TTFReadDirEntry( HANDLE fHdl, struct TableEntry *entry, int eCnt)
{
	long	ofs;
	DWORD nByte;
	BOOL res;


	ofs = sizeof (struct TTFHeader);
	if ( (long) SetFilePointer( fHdl, ofs, NULL, FILE_BEGIN)!=ofs)
		return -1;
	res = ReadFile( fHdl, entry, (unsigned int)(sizeof(struct TableEntry)*eCnt), &nByte, NULL);
	if (!res || nByte !=(unsigned int)sizeof(struct TableEntry)*eCnt)
		return -1;
	while ( eCnt-->0) {
		lmtoi((long *)&entry->checkSum);
		lmtoi(&entry->ofs);
		lmtoi(&entry->siz);
		entry++;
	}
	return	0;
}
int
TTFWriteDirEntry( HANDLE fHdl, struct TableEntry *entry, int eCnt)
{
	long	ofs;
struct TableEntry wentry;
	DWORD nByte;
	BOOL res;

	ofs = sizeof (struct TTFHeader);
	if ( (long) SetFilePointer( fHdl, ofs, NULL, FILE_BEGIN)!=ofs)
		return -1;

	/* Write Entries */
	while ( eCnt-->0) {
		wentry = *entry++;
		litom((long *)&wentry.checkSum);
		litom(&wentry.ofs);
		litom(&wentry.siz);
		res = WriteFile( fHdl,(char *) &wentry, sizeof wentry, &nByte, NULL);
		if (!res || nByte !=sizeof wentry) {
			return -1;
		}
	}
	return	0;
}
static struct TableEntry *
searchEntry(struct TableEntry *entry, int eCnt, char *tag)
{
	while ( eCnt-->0) {
		if (memcmp( entry->tagName, tag, TAGSIZ)==0)
			return entry;
		entry++;
	}
	return (struct TableEntry *)0;
}
int
TTFGetTableEntry( HANDLE fH, struct TableEntry *entry, char *tag)
{
struct TTFHeader	hdr;
struct TableEntry	*te, *rte;
	int	msiz;

	te = 0;
	/* Read TTF Header to get numTables */
	if (TTFReadHdr( fH, &hdr))
		goto	ERET;
	msiz = sizeof(struct TableEntry)*hdr.numTables;
	if ( (te = (struct TableEntry *)malloc((size_t)msiz))==(struct TableEntry *)0)
		goto	ERET;

	/* Read entry whole */
	if ( TTFReadDirEntry( fH, te, hdr.numTables))
		goto	ERET;

	/* Search for entry with tag */
	if ((rte = searchEntry(te, (int)hdr.numTables, tag))==0)
		goto	ERET;
	*entry = *rte;
	free(te);
	return 0;
ERET:
	if (te)	free(te);
	return -1;
}
/***********************************************************************
 *	Read Table at once with entry data
 */
/* */	int
/* */	TTFReadTable(
/* */		HANDLE fH,
/* */	struct TableEntry *entry,
/* */		void	*buf,
/* */		int	bufsiz)
/*
 *	returns :  read size
 ***********************************************************************/
{
	unsigned int	rdsiz;
	DWORD nByte;
	BOOL res;

	if ((long) SetFilePointer( fH, entry->ofs, NULL, FILE_BEGIN)!=entry->ofs)
		goto	ERET;
	rdsiz = bufsiz >= (int)entry->siz ? (unsigned int)entry->siz
						: (unsigned int)bufsiz;
	res = ReadFile( fH, buf, rdsiz, &nByte, NULL);
	if (!res || nByte!=rdsiz)
		goto	ERET;
	if ( rdsiz < (unsigned int)bufsiz)
		memset((unsigned char *)buf + rdsiz, 0, bufsiz - rdsiz);
	return (int)rdsiz;
ERET:
	return -1;
}
/***********************************************************************
 *	Read Fixed Size Table at onece with tag
 */
/* */	int
/* */	TTFReadFixedTable(
/* */		HANDLE	fH,
/* */		char	*buf,
/* */		int	bufsiz,
/* */		char	*tag)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
struct TableEntry	te;

	if (TTFGetTableEntry( fH, &te, tag))
		goto	ERET;
	if ( TTFReadTable( fH, &te, buf, bufsiz )!=bufsiz)
		goto	ERET;
	return 0;
ERET:
	return -1;
}

/***********************************************************************
 *	Read Variable Size Table at onece with tag
 */
/* */	int
/* */	TTFReadVarTable(
/* */		HANDLE	fH,
/* */		char	**buf,		/* Buffer pointer (be set) */
/* */		unsigned int	*bufsiz,	/* Buffer Size ( be set) */
/* */		char	*tag)		/* Tag name */
/*
 *	returns : 0, -1
 *	remarks : allocated memory must be free by caller
 ***********************************************************************/
{
struct TableEntry	te;
	char	*mem;

	if (TTFGetTableEntry( fH, &te, tag))
		goto	ERET;
	if ((mem = (char *)malloc( (size_t)te.siz))==(char *)0)
		goto	ERET;
	if ( TTFReadTable( fH, &te, mem, (int)te.siz )!=(int)te.siz)
		goto	ERET;
	*buf = mem;
	*bufsiz = (unsigned int)te.siz;

	return 0;
ERET:
	return -1;
}

/***********************************************************************
 *	Write Table
 */
/* */	int
/* */	TTFWriteTable(
/* */		HANDLE	fH,
/* */	struct TableEntry *entry,
/* */		void	*buf,
/* */		int	bufsiz)
/*
 *	returns :  written size
 *	remarks : update checksum
 ***********************************************************************/
{
	int	wsiz;
	DWORD nByte;
	BOOL res;

	if ((long) SetFilePointer( fH, entry->ofs, NULL, FILE_BEGIN)!=entry->ofs)
		goto	ERET;
	wsiz = bufsiz >= (int)entry->siz ? (int)entry->siz : bufsiz;
	res = WriteFile( fH, (char *)buf, (unsigned int)wsiz, &nByte, NULL);
	if (!res || nByte !=(unsigned int)wsiz)
		goto	ERET;
	entry->checkSum = calchksum( (char *)buf, bufsiz);
	return wsiz;
ERET:
	return -1;
}
/***********************************************************************
 *	Write Table
 */
/* */	int
/* */	TTFAppendTable(
/* */		HANDLE	fH,
/* */	struct TableEntry *entry, 	/* value be set */
/* */		void	*buf,
/* */		int	siz)
/*
 *	returns : 0, -1
 *	remarks : enttry->siz  not aligned 32bit
 ***********************************************************************/
{
	long	ofs;
	BYTE	pad[4];
	int	padsiz;
	DWORD nByte;
	BOOL res;

	if ( (ofs=(long) SetFilePointer( fH, 0L, NULL, FILE_CURRENT))<0L)
		goto	ERET;

	res = WriteFile( fH, buf, (unsigned int)siz, &nByte, NULL);
	if (!res || nByte !=(unsigned int)siz)
		goto	ERET;
	
	/* 32 bit Word aligne */
	if ( siz % 4) {
		padsiz = 4 - siz%4;
		memset(pad,0,4);
		res = WriteFile(fH,pad, (unsigned int)padsiz, &nByte, NULL);
		if (!res || nByte !=(unsigned int)padsiz)
			goto	ERET;
	}
	entry->ofs = ofs;
	entry->siz = siz;
	entry->checkSum = calchksum((char *) buf, siz);
	return 0;
ERET:
	return -1;
}
/***********************************************************************
 *	Merge Table
 */
/* */	static int
/* */	TTFMergeTable(
/* */		HDC	hDC,
/* */		HANDLE	nfh,
/* */		char	tag[4],
/* */	struct TableEntry	*nte)
/*
 *	returns : 0
 ***********************************************************************/
{
	if (TTFGetOrgTableEntry( hDC, nte, tag))
		return -1;
	if (mergeblock( hDC, nte, nfh))
		return -1;
	return 0;
}
int
#ifdef BUILD_ON_WINNT
__cdecl
#endif // BUILD_ON_WINNT
compentry( const void *e1, const void *e2)
{
struct TableEntry *te1, *te2;

	te1 = (struct TableEntry *)e1;
	te2 = (struct TableEntry *)e2;
	return memcmp(te1->tagName, te2->tagName,4);
}
static void
SortEntry(struct TableEntry *ebuf, int num)
{
	if ( num <=0)	return;
	qsort( ebuf, num, sizeof(struct TableEntry), compentry);
}
static int
fileChkSum(
	HANDLE fh,
	struct TableEntry *entry,
	int numEntry,
	struct TTFHeader *hdr,
	struct HeadTable *head)
{
	unsigned long	lval, cs;
	unsigned long	*lp;
	struct TableEntry *e;
	int	n;
	struct TableEntry	*headp;
	DWORD nByte;
	BOOL res;

	e = entry;
	n = numEntry;
	cs = 0;
	head->chkSum = 0;
	headp = 0;
	while ( n-->0) {
		lp = (unsigned long *)e->tagName;
		if (memcmp( e->tagName,"head", 4)==0)
			headp = e;
		lval = *lp;
		lmtoi( (long *)&lval);
		cs += lval;
		cs += e->checkSum;
		cs += e->checkSum;
		cs += e->ofs;
		cs += e->siz;
		e++;
	}
	if (headp==0)
		return -1;

	cs += calchksum( (char *)hdr, sizeof(struct TTFHeader) );

	if ((long) SetFilePointer( fh, headp->ofs, NULL, FILE_BEGIN)!=headp->ofs)
		goto	ERET;
	head->chkSum = (unsigned long)0xb1b0afbaL - cs;
	litom( (long *)&head->chkSum);
	res = WriteFile(fh,(char *)head,sizeof(struct HeadTable), &nByte, NULL);
	if (!res || nByte !=sizeof(struct HeadTable))
		goto	ERET;
	return 0;
ERET:
	return -1;
}
static void
makeTTFHeader( struct TTFHeader *hdr, int nTbl)
{
	int	po;
	int	n;
	int	ponum;

	po = 0;
	n = nTbl;
	ponum = 1;
	while ( n>=2) {
		n /= 2;
		po++;
		ponum*=2;
	}
	hdr->sfnt_version[0]= hdr->sfnt_version[2]= hdr->sfnt_version[3]= 0;
	hdr->sfnt_version[1]= 0x01;
	hdr->numTables = (short)nTbl;
	hdr->searchRange = (short)ponum*16;
	hdr->entrySelector = (short)po;
	hdr->rangeShift = (short)( nTbl*16)-hdr->searchRange;

	return ;
}
/***********************************************************************
 *	make GlyphData from lst
 */
/* */	static int
/* */	makeGlyphData(
/* */		int lstH,
/* */		struct BBX *bbx,	/* Set value to header */
/* */		char	*glyphData,
/* */		int	bufsiz,
/* */		int	*gdatsiz)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
	char	*flgp, *sflgp;
	char	flag;
	char	*dummyp;
struct VHEAD	*vhd,
		*svhd;
struct glyfHead	ghdr;
	int	nCnt;
struct VDATA	*vp;
	int	nPnt;
	int	pntSum;
	int	cnt;
	short	sval;
	short	px, py;
	short	relx, rely;
	char	cval;

	initsetgbuf ( glyphData, bufsiz);
	if( ( nCnt = VDGetNCont( lstH))<0)
		goto	ERET;

	else  if (nCnt == 0) {	/* Space Character */
			*gdatsiz = 0;
			return	0;
	
	}

	ghdr.numberOfContour = (short)nCnt;
	sitom( &ghdr.numberOfContour );
	ghdr.xMin = (short)bbx->xMin;
	sitom( &ghdr.xMin);
	ghdr.yMin = (short)bbx->yMin;
	sitom( &ghdr.yMin);
	ghdr.xMax = (short)bbx->xMax;
	sitom( &ghdr.xMax);
	ghdr.yMax = (short)bbx->yMax;
	sitom( &ghdr.yMax);
	if (setgbuf( (char *)&ghdr, sizeof ghdr, &flgp))
		goto	ERET2;
	if (VDGetHead( lstH, &vhd))
		goto	ERET;
	pntSum = 0;
	svhd = vhd;
	/* Set each Contour Last point number */
	for ( cnt = 0; cnt < nCnt; cnt++) {
		pntSum +=  vhd->nPoints;
		sval = pntSum-1;
		sitom( &sval);
		if ( setgbuf((char *)&sval, sizeof( short), &flgp))
			goto	ERET2;
		vhd = vhd->next;
	}
	/* Toatal number of instructions */
	sval = 0;
	if ( setgbuf((char *)&sval, sizeof( short), &flgp))
		goto	ERET2;

	/* Set flags */
	vhd = svhd;
	px = py = 0;
	for ( cnt = 0; cnt < nCnt; cnt++) {
		vp = vhd->headp;
		nPnt = vhd->nPoints;
		while ( nPnt-->0) {
			flag = (vp->vd.atr&1)==0 ? (char)GLYF_ON_CURVE :(char)0;
			relx = vp->vd.x - px;
			rely = vp->vd.y - py;
			if ( relx == 0)
				flag |= GLYF_X_SAME;
			else if ( relx > 0 && relx < 256)
				flag |= GLYF_X_SHORT_P;
			else if ( relx < 0 && relx > -256)
				flag |= GLYF_X_SHORT_N;
			if ( rely == 0)
				flag |= GLYF_Y_SAME;
			else if ( rely > 0 && rely < 256)
				flag |= GLYF_Y_SHORT_P;
			else if ( rely < 0 && rely > -256)
				flag |= GLYF_Y_SHORT_N;

			if (setgbuf((char *) &flag, 1, &dummyp))
				goto	ERET2;
			px = vp->vd.x;
			py = vp->vd.y;
			vp = vp->next;
		}
		vhd = vhd->next;
	}
	/* set X */
	vhd = svhd;
	sflgp = flgp;
	px = 0;
	for ( cnt = 0; cnt < nCnt; cnt++) {
		vp = vhd->headp;
		nPnt = vhd->nPoints;
		while ( nPnt-->0) {
			relx = vp->vd.x - px;
			if ( *flgp & GLYF_X_SHORT) {
				if ( (*flgp & GLYF_X_SAME)==0)
					relx = -relx;
				cval = (char)relx;
				if ( setgbuf( &cval, 1, &dummyp))
					goto	ERET2;
			}
			else if ( *flgp & GLYF_X_SAME)
				;
			else {
				sitom( &relx);
				if ( setgbuf( (char *)&relx, 2, &dummyp))
					goto	ERET2;
			}
			flgp++;
			px = vp->vd.x;
			vp = vp->next;
		}
		vhd = vhd->next;
	}
	/* set Y */
	vhd = svhd;
	flgp = sflgp;
	py = 0;
	for ( cnt = 0; cnt < nCnt; cnt++) {
		vp = vhd->headp;
		nPnt = vhd->nPoints;
		while ( nPnt-->0) {
			rely = vp->vd.y - py;
			if ( *flgp & GLYF_Y_SHORT) {
				if ( (*flgp & GLYF_Y_SAME)==0)
					rely = -rely;
				cval = (char)rely;
				if ( setgbuf( &cval, 1, &dummyp))
					goto	ERET2;
			}
			else if ( *flgp & GLYF_Y_SAME)
				;
			else {
				sitom( &rely);
				if ( setgbuf((char *)&rely, 2, &dummyp))
					goto	ERET2;
			}
			flgp++;
			py = vp->vd.y;
			vp = vp->next;
		}
		vhd = vhd->next;
	}

	*gdatsiz = termbuf();
	return 0;
ERET:
	return -1;
ERET2:
	return -2;
}
static char	*sbuf;
static int	limcnt;
static char	*setp;
static int	bcnt;
static void
initsetgbuf( char *b, int lim)
{
	setp = sbuf = b;
	limcnt = lim;
	bcnt = lim;	/* decremental counter */
	return;
}
static int
setgbuf( char *dat, int siz, char **np)
{
	if ( siz > bcnt)	return -1;
	memcpy( setp, dat, siz);
	setp += siz;
	bcnt -= siz;
	*np = setp;
	return 0;
}
static int
termbuf( )
{
	int	siz;

	siz = limcnt - bcnt;
	siz = siz % 4;
	if ( siz) {
		while ( siz++<4) {
			*setp++=0;
			bcnt--;
		}
	}
	return limcnt - bcnt;
}
static int
strwlen( char *s)
{
	int	len;

	len = 0;
	while (*s ||  *(s+1)) {
		s+=2;
		len++;
	}
	return len*2;
}
static void
strwcat( char *s1, char *s2)
{
	while (*s1 || *(s1+1))
		s1+=2;

	while ( *s2 || *(s2+1)) {
		*s1++ = *s2++;
		*s1++ = *s2++;
	}
	*s1++ = 0;
	*s1++ = 0;
	
	return;
}
static void
setnamebuf( char *buf, int *siz, short EncodingID)
{
	int	strsiz;
	short	strofs;
	char	*strp;
struct NamingTable	*nt;
struct NameRecord	*nr;
	int	rec;
	int	slen;

	strofs = sizeof(struct NamingTable)
		+ sizeof(struct NameRecord)*NUMOFNAMEREC;
	strsiz = 0;
	strp = buf +strofs;
	*strp=(char)0;
	*(strp+1)=(char)0;
	nt = (struct NamingTable *)buf;
	nt->OfsToStr = strofs;
	sitom( &nt->OfsToStr);
	nr = (struct NameRecord *)(buf + sizeof(struct NamingTable));
	/* Set name record */
	strofs = 0;
	for ( rec = 0; rec<NUMOFNAMEREC; rec++, nr++) {
		nr ->PlatformID = 3;
		sitom(&nr ->PlatformID);

		nr ->PlatformSpecEncID = EncodingID;
		sitom(&nr ->PlatformSpecEncID);

		nr ->LanguageID = (short)CountryInfo.LangID;
		sitom(&nr ->LanguageID);

		nr ->NameID = (short)rec;
		sitom(&nr ->NameID);

		strwcat( strp,namerecstr[rec]);
		slen = strwlen(namerecstr[rec]);

		nr -> StringLength = (short)slen;
		sitom(&nr -> StringLength );
		strsiz += slen;

		nr -> StringOfs = strofs;
		sitom(&nr -> StringOfs);
		strofs += (short)slen;
	}
	nt->FormSel = 0;
	nt->NRecs = NUMOFNAMEREC;
	sitom( &nt->NRecs);
	*siz = strsiz+ sizeof(struct NamingTable)
			+ sizeof(struct NameRecord)*NUMOFNAMEREC;
}
static void
modifyOS2( char *buf)
{
	/* Allow all license */
	*(buf+9) = (char)0x00;
	/* Set aulUnicodeRange  Privete Use Area bit*/
	*(buf+0x31) |= 0x31;
}
static void
modifyhead( struct HeadTable *head)
{
	head->chkSum=0L;
	memset( head->createdDate, 0, 8);
	memset( head->updatedDate, 0, 8);
	head->indexToLocFormat = 1;
	head->glyphDataFormat = 0;
	sitom( &head->indexToLocFormat );
	sitom( &head->glyphDataFormat);
}
/*
 *	Set Vertical Header with Horizontal Header and Bounding Box
 */
static void
setVhea( struct VheaTable *vhea, struct HheaTable *hhea, struct BBX *bbx)
{

	memcpy( vhea, hhea, sizeof(struct HheaTable));
	vhea->minTopSideBearing = 0;
	vhea->minBottomSideBearing = 0;
	vhea->caretSlopeRise = 0;
	vhea->caretSlopeRun = 1;
	sitom( &vhea->caretSlopeRun );
	vhea->numOfLongVerMetrics = (short)numOfGlyph;
	sitom( &vhea->numOfLongVerMetrics );
}
static int
updateMaxp( struct MaxpTbl *maxp, int lstHdl)
{
struct VHEAD	*vhd;
	short	sval;
	int	nCnt;
	int	ttlPnt;
	int	updflg;

	updflg = 0;	
	if ( (nCnt = VDGetNCont( lstHdl))<0)
		goto	ERET;
	else if ( nCnt ==0)
		goto	RET;

	sval = maxp->maxContours;
	smtoi( &sval);
	if ( sval < nCnt) {
		sval = (short)nCnt;
		sitom(&sval);
		maxp->maxContours = sval;
		updflg = 1;	
	}
	if (VDGetHead( lstHdl, &vhd))
		goto	ERET;
	ttlPnt = 0;
	while ( nCnt-->0) {
		ttlPnt += vhd->nPoints;
		vhd = vhd->next;
	}
	sval = maxp->maxPoints;
	smtoi( &sval);
	if ( sval < ttlPnt) {
		sval = (short)ttlPnt;
		sitom(&sval);
		maxp->maxPoints = sval;
		updflg = 1;	
	}
RET:
	return updflg;
ERET:
	return -1;
}
/***********************************************************************
 *	Obtain Original TTF Table Size
 */
/* */	static int
/* */	TTFGetOrgTableEntry(
/* */		HDC	hDC,
/* */		struct TableEntry	*entry,
/* */		char	*tag)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
	DWORD dwTable;	/* Metric Table to request */
	DWORD 	siz;

	dwTable = *(DWORD *)tag;
	siz = GetFontData(hDC, dwTable, (DWORD)0, (char *)0, (DWORD)0);
	if ( siz == GDI_ERROR)	return -1;
	else {
		memcpy( entry->tagName, tag, TAGSIZ);
		entry->siz = (long)siz;
		return 0;
	}
}
/***********************************************************************
 *	Read Original TTF Table
 */
/* */	int
/* */	TTFReadOrgFixedTable (
/* */		HDC	hDC,		/* Handle to DC */
/* */		char	*buf,		/* Read Buffer */
/* */		int	bufsiz,		/* Buffer Siz */
/* */		char	*tag)		/* TagName */
/*
 *	returns : 0, -1
 ***********************************************************************/
{
	DWORD dwTable;	/* Metric Table to request */
	DWORD	siz;

	dwTable = *(DWORD *)tag;
	siz = GetFontData(hDC, dwTable, (DWORD)0, buf,(DWORD)bufsiz );
	if ( (int)siz != bufsiz)
		return -1;
	else	return 0;
}
/***********************************************************************
 *	Read Variable Size Table at onece with tag
 */
/* */	int
/* */	TTFReadOrgVarTable(
/* */		HDC	hDC,
/* */		char	**buf,		/* Buffer pointer (be set) */
/* */		unsigned int	*bufsiz,	/* Buffer Size ( be set) */
/* */		char	*tag)		/* Tag name */
/*
 *	returns : 0, -1
 *	remarks : allocated memory must be free by caller
 ***********************************************************************/
{
struct TableEntry	te;
	char	*mem;

	if (TTFGetOrgTableEntry( hDC, &te, tag))
		goto	ERET;
	if ((mem = (char *)malloc( (size_t)te.siz))==(char *)0)
		goto	ERET;
	if ( TTFReadOrgFixedTable ( hDC, mem,(int)te.siz , tag))
		goto	ERET;
	*buf = mem;
	*bufsiz = (unsigned int)te.siz;

	return 0;
ERET:
	return -1;
}
static void
setCountryData(short EncodingID)
{
	unsigned short lastCode;

	makeUniCodeTbl();

	lastCode = getMaxUniCode();

	numOfGlyph = lastCode - EUDCCODEBASE +1 + 2; /* +null, +missing */

	cmapdata[6] = (char)((EncodingID>>8)&(unsigned short)0xff);
	cmapdata[7] = (char)(EncodingID&(unsigned short)0xff);
	cmapdata[26] = (char)((lastCode>>8)&(unsigned short)0xff);
	cmapdata[27] = (char)(lastCode&(unsigned short)0xff);

	maxpdata[4] = (char)((numOfGlyph>>8)&(unsigned short)0xff);
	maxpdata[5] = (char)(numOfGlyph&(unsigned short)0xff);
}
static int
WIFEOS2( HDC hDC, char **os2buf, int *os2TblSiz, struct BBX *bbx)
{
	struct OS2Table *os2tbl;
	int	siz;
	TEXTMETRIC	tm;
static PANOSE	msminPanose= { (char)2, (char)2, (char)6, (char)9, (char)4,
			(char)2, (char)5, (char)8, (char)3, (char)4};

	if ( GetTextMetrics( hDC, &tm)==0)
		goto	ERET;
	siz = sizeof( struct OS2Table);
	if ((os2tbl = (struct OS2Table *)malloc(sizeof(struct OS2Table)))==0)
		goto	ERET;
	memset( os2tbl, 0, sizeof(struct OS2Table));

	os2tbl->version = 1;
	sitom( (short *)&os2tbl->version);
	os2tbl->xAvgCharWidth = bbx->xMax+1;
	sitom( &os2tbl->xAvgCharWidth );
	os2tbl->usWeightClass = tm.tmWeight? (unsigned short)tm.tmWeight : 500;
	sitom( (short *)&os2tbl->usWeightClass );
	os2tbl->usWidthClass = 5; /* Medium */
	sitom( (short *)&os2tbl->usWidthClass );
	os2tbl->fsType = 0x0000; /* Allow all liscence */
	sitom( &os2tbl->fsType );

	os2tbl->ySubscriptXSize = (bbx->xMax+1)/2;	/* 1/4kaku */
	sitom( &os2tbl->ySubscriptXSize );
	os2tbl->ySubscriptYSize = (bbx->yMax+1)/2;	/* 1/4kaku */
	sitom( &os2tbl->ySubscriptYSize );
	os2tbl->ySubscriptXOffset = 0;			/* 1/4kaku */
	sitom( &os2tbl->ySubscriptXOffset );
	os2tbl->ySubscriptYOffset = 0;			/* 1/4kaku */
	sitom( &os2tbl->ySubscriptYOffset );

	os2tbl->ySuperscriptXSize = (bbx->xMax+1)/2;	/* 1/4kaku */
	sitom( &os2tbl->ySuperscriptXSize );
	os2tbl->ySuperscriptYSize = (bbx->yMax+1)/2;	/* 1/4kaku */
	sitom( &os2tbl->ySuperscriptYSize );
	os2tbl->ySuperscriptXOffset = (bbx->xMax+1)/2;	/* 1/4kaku */
	sitom( &os2tbl->ySuperscriptXOffset );
	os2tbl->ySuperscriptYOffset = (bbx->yMax+1)/2;	/* 1/4kaku */
	sitom( &os2tbl->ySuperscriptYOffset );

	os2tbl->yStrikeoutSize = bbx->yMax/20;		/* 5% */
	sitom( &os2tbl->yStrikeoutSize );
	os2tbl->yStrikeoutPosition = bbx->yMax/4;	/* 25% */
	sitom( &os2tbl->yStrikeoutPosition );

	os2tbl->sFamilyClass = 0;	/* no classification */
	sitom( &os2tbl->sFamilyClass );
	os2tbl->panose = msminPanose;

	os2tbl->fsSelection = 0x40;
	sitom( (short *)&os2tbl->fsSelection );

	os2tbl->usFirstCharIndex = 0x20;
	sitom( (short *)&os2tbl->usFirstCharIndex );
	os2tbl->usLastCharIndex = 0xffe5;
	sitom( (short *)&os2tbl->usLastCharIndex );
	os2tbl->sTypoAscender = bbx->yMax+1;
	sitom( &os2tbl->sTypoAscender );
	os2tbl->sTypoDescender = -(bbx->yMax/8);
	sitom( &os2tbl->sTypoDescender );
	os2tbl->sTypoLineGap = 0;
	sitom( &os2tbl->sTypoLineGap );

	os2tbl->usWinAscent = bbx->yMax+1;
	sitom( (short *)&os2tbl->usWinAscent );
	os2tbl->usWinDescent = bbx->yMax/8;
	sitom( (short *)&os2tbl->usWinDescent );
	*os2TblSiz = sizeof( struct OS2Table);
	*os2buf = (char *)os2tbl;
	return 0;
ERET:
	return -1;
}
static void
WIFEhhea( struct HheaTable *hhea, struct BBX *bbx)
{
	memset( hhea, 0, sizeof(struct HheaTable));

	hhea->version[1] = (char)1;
	hhea->Ascender = bbx->yMax+1;
	sitom( &hhea->Ascender);
	hhea->Descender = -(bbx->yMax/8);
	sitom( &hhea->Descender);
	hhea->LineGap =  0;
	sitom( &hhea->LineGap);

	hhea->advanceWidthMax =  bbx->xMax+1;
	sitom( &hhea->advanceWidthMax);
	hhea->minLeftSideBearing =  0;
	sitom( &hhea->minLeftSideBearing);
	hhea->minRightSideBearing = 0;
	sitom( &hhea->minRightSideBearing);

	hhea->xMaxExtent =  bbx->xMax+1;
	sitom( &hhea->xMaxExtent);
	hhea->caretSlopeRise = 1;
	sitom( &hhea->caretSlopeRise);
	hhea->caretSlopeRun = 0;
	sitom( &hhea->caretSlopeRun);

	hhea->numberOfHMetrics = (short)numOfGlyph;
	sitom( &hhea->numberOfHMetrics);

}
static void
WIFEhead( struct HeadTable *head, struct BBX *bbx)
{
	memset( head, 0, sizeof( struct HeadTable));

	head->version[1] = 0x1;
	head->magicNumber=0x5f0F3CF5L;
	litom((long *)&head->magicNumber);
	head->flags = 0;
	sitom( &head->flags);
	head->unitsPerEm = bbx->xMax - bbx->xMin+1;
	head->unitsPerEm = ((bbx->xMax - bbx->xMin+1)*9+4)/8;
	sitom( &head->unitsPerEm);

	head->xMin = (short)bbx->xMin;
	sitom( &head->xMin);
	head->xMax = (short)bbx->xMax;
	sitom( &head->xMax);
//	head->yMin = (short)bbx->yMin;
	head->yMin = -(bbx->yMax/8);
	sitom( &head->yMin);
	head->yMax = (short)bbx->yMax;
	sitom( &head->yMax);

	head->lowestRecPPEM = 25;
	sitom( &head->lowestRecPPEM);
	head->fontDirectionHint = 1;
	sitom( &head->fontDirectionHint);
	head->indexToLocFormat = 1;
	sitom( &head->indexToLocFormat);

}
static void
WIFEpost( struct postTable *post)
{
	memset( post, 0, sizeof( struct postTable));
	post->FormatType[1]=0x3;
	post->underlineThickness = 12;
	sitom( &post->underlineThickness);
	post->isFixedPitch = 1;
	litom( (long *)&post->isFixedPitch);
}
static short
getEncID( HDC hDC, int fontType)
{
	if ( CountryInfo.LangID==EUDC_KRW)
		return (short)1;
	else	return (short)1;
}
/***********************************************************************
 *	Create TTF
 */
/* */	int
/* */	TTFCreate(
/* */		HDC hDC, 		/* Handle to DC */
/* */		TCHAR *newf,		/* Create TTF Path */
/* */		struct BBX	*bbx,	/* the same as original 'head'*/
/* */					/* but minX should be 0 */
/* */		int	lstHdl,		/* missing glyf list */
/* */					/* bbx, hM, LstHdl is for Missing Glyf*/
/* */		int	fontType)	/* 0:TrueType, 1:WIFE */
/*
 *	returns : 0, -1
 ***********************************************************************/
{
	HANDLE	nfh;	
struct TTFHeader	hdr;
struct TableEntry	*te,		/* Directory Entry */
			nte;
	char		*nameBuf;
	int		nameBufSiz;
struct HheaTable	hhea;
struct VheaTable	vhea;
struct HeadTable	head;
struct HMetrics		*hmet;
struct VMetrics		*vmet;
	long		*loca;
	long		ofs;
	char	*glyphData;
	int	gdatsiz;
	int	i;
	char	*os2buf;
	int	os2siz;
struct BBX	cbbx;		/* bounding box for each glyph*/
struct HMetrics		hM;	/* horizontal metrics for each glyph */
struct VMetrics		vM;	/* Vertical one */
struct postTable	postTbl; /* post table */
	short	EncodingID;
	DWORD nByte;
	BOOL res;

//	nfh = -1;
	te =  0;
	nameBuf = 0;
	hmet = 0;
	loca = 0;
	glyphData = 0;
	os2buf = 0;

	/* Determin PlatformSpcificEncodingID */
	if ((EncodingID = getEncID( hDC, fontType))<(short)0)
		goto	ERET;
	/* Set cmapdata,maxpdata,numOfGlyph,lastCode */
	setCountryData(EncodingID);

	/* Open files */
	nfh = CreateFile(newf,
					GENERIC_WRITE,
					FILE_SHARE_READ | FILE_SHARE_DELETE,
					NULL,
					CREATE_ALWAYS,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( nfh  == INVALID_HANDLE_VALUE)
		goto	ERET;
	
	/* Write header */
	makeTTFHeader( &hdr, NUMTABLES);
	if ( TTFWriteHdr( nfh, &hdr))
		goto	ERET;

	/* Allocate dir entry area */
	if ( (te =(struct TableEntry *)malloc((size_t)sizeof(struct TableEntry)*NUMTABLES))==0)
		goto	ERET;

	/*
	 * DirEntry Dummy Write
	 */
	memset( te, 0, sizeof(struct TableEntry)*NUMTABLES);
	res = WriteFile( nfh, te, sizeof(struct TableEntry)*NUMTABLES, &nByte, NULL);
	if (!res || nByte != sizeof(struct TableEntry)*NUMTABLES)
		goto	ERET;

	initDirEntry(te, NUMTABLES );

	/*
	 * 'cvt ' Write
	 */
	if (TTFAppendTable( nfh, &nte, cvtdata, sizeof cvtdata))
		goto	ERET;
	if ( setDirEntry( &nte, "cvt "))
		goto	ERET;
	/*
	 * 'fpgm' Write
	 */
	if (TTFAppendTable( nfh, &nte, fpgmdata, sizeof fpgmdata))
		goto	ERET;
	if ( setDirEntry( &nte, "fpgm"))
		goto	ERET;
	/*
	 * 'prep' write
	 */
	if (TTFAppendTable( nfh, &nte, prepdata, sizeof prepdata))
		goto	ERET;
	if ( setDirEntry( &nte, "prep"))
		goto	ERET;
	/*
	 * 'name' write
	 */
	if ( (nameBuf = (char *)malloc((size_t)NAMEBUFSIZ))==0)
		goto	ERET;
	setnamebuf(nameBuf, &nameBufSiz, EncodingID);
	if (TTFAppendTable( nfh, &nte, nameBuf, nameBufSiz))
		goto	ERET;
	free( nameBuf);
	nameBuf = 0;
	if ( setDirEntry( &nte, "name"))
		goto	ERET;

	/*
	 * 'cmap' Write
	 */
	if (TTFAppendTable( nfh, &nte, cmapdata, sizeof cmapdata))
		goto	ERET;
	if ( setDirEntry( &nte, "cmap"))
		goto	ERET;
	/*
	 * 'OS/2' Copy -> modify
	 */
	if ( fontType==0) {
		if ( TTFReadOrgVarTable( hDC, &os2buf, (unsigned int *)&os2siz,
						"OS/2"))
			goto	ERET;
		modifyOS2( os2buf);
	}
	else {
		if (WIFEOS2( hDC, &os2buf, &os2siz, bbx))
			goto	ERET;
	}
	if (TTFAppendTable( nfh, &nte, os2buf,  os2siz))
		goto	ERET;
	if ( setDirEntry( &nte, "OS/2"))
		goto	ERET;
	free( os2buf);
	/*
	 * 'post' Copy
	 */
	if ( fontType==0) {
		if ( TTFMergeTable( hDC, nfh, "post", &nte))
			goto	ERET;
	}
	else {
		WIFEpost( &postTbl);
		if (TTFAppendTable( nfh,&nte, (char *)&postTbl,sizeof(struct postTable)))
			goto	ERET;
	}
	if ( setDirEntry( &nte, "post"))
		goto	ERET;
	/*
	 * 'hhea' Read,modify and write
	 */
	if ( fontType==0) {
		if (TTFReadOrgFixedTable( hDC, (char *)&hhea, sizeof hhea,"hhea"))
			goto	ERET;

		hhea.metricDataFormat = 0;
		hhea.numberOfHMetrics = (short)numOfGlyph;
		sitom( &hhea.numberOfHMetrics );
	}
	else {
		WIFEhhea( &hhea, bbx);
	}
	if (TTFAppendTable( nfh, &nte, &hhea, sizeof hhea))
		goto	ERET;
	if ( setDirEntry( &nte, "hhea"))
		goto	ERET;

	/*
	 * 'vhea'
	 */
	setVhea( &vhea, &hhea, bbx);
	if (TTFAppendTable( nfh, &nte, &vhea, sizeof vhea))
		goto	ERET;
	if ( setDirEntry( &nte, "vhea"))
		goto	ERET;
	/* Make metrics for missing Glyph */	
	cbbx = *bbx;
	makeMetrics( lstHdl, &hM, &vM, &cbbx);

	/*
	 * 'vmtx'
	 */
	if ((vmet=(struct VMetrics *)malloc( (size_t)sizeof(struct VMetrics)*numOfGlyph))==0)
		goto	ERET;
	memset(vmet, 0, sizeof(struct VMetrics)*numOfGlyph);

	/* for missing Glyph */

	*vmet = vM;
	sitom(&vmet->advanceHeight );
	sitom(&vmet->topSideBearing );

	/* for null Glyph */
	(vmet+1)->advanceHeight = 0;
	(vmet+1)->topSideBearing = 0;

	if (TTFAppendTable( nfh,&nte,vmet,sizeof(struct VMetrics)*numOfGlyph))
		goto	ERET;
	if ( setDirEntry( &nte, "vmtx"))
		goto	ERET;
	free( vmet);
	vmet = 0;

	/*
	 * head Read,modify and write
	 */
	if ( fontType==0) {
		if (TTFReadOrgFixedTable( hDC,(char *)&head, sizeof head,"head"))
			goto	ERET;
		modifyhead( &head);
	}
	else {
		WIFEhead( &head, bbx);
	}
	if (TTFAppendTable( nfh, &nte, &head, sizeof head))
		goto	ERET;
	if ( setDirEntry( &nte, "head"))
		goto	ERET;

	/*
	 * make hmtx
	 */
	if ((hmet=(struct HMetrics *)malloc( (size_t)sizeof(struct HMetrics)*numOfGlyph))==0)
		goto	ERET;
	memset(hmet, 0, sizeof(struct HMetrics)*numOfGlyph);
	/* for missing Glyph */
	*hmet = hM;
	sitom(&hmet->advanceWidth );
	sitom(&hmet->leftSideBearing);

	/* for null Glyph */
	(hmet+1)->advanceWidth = 0;
	(hmet+1)->leftSideBearing = 0;

	if (TTFAppendTable( nfh,&nte,hmet,sizeof(struct HMetrics)*numOfGlyph))
		goto	ERET;
	if ( setDirEntry( &nte, "hmtx"))
		goto	ERET;
	free( hmet);
	hmet = 0;

	if ((glyphData = (char *)malloc((size_t)GLYPHBUFSIZ))==0)
		goto	ERET;
	if (makeGlyphData( lstHdl, &cbbx, glyphData, GLYPHBUFSIZ, &gdatsiz ))
		goto	ERET;
	/*
	 * 'loca' make
	 */
	if ((loca = (long *)malloc( (size_t)sizeof(unsigned long)*(numOfGlyph+1)))==(long *)0)
		goto	ERET;
	*loca = 0;
	ofs = gdatsiz;
	litom(&ofs);
	for ( i = 1; i< numOfGlyph+1; i++)
		*(loca + i)=ofs;

	if (TTFAppendTable( nfh,&nte,loca,sizeof( long)*(numOfGlyph+1)))
		goto	ERET;
	if ( setDirEntry( &nte, "loca"))
		goto	ERET;
	free( loca);
	loca = 0;

	/*
	 * 'maxp' write
	 */
	if (TTFAppendTable( nfh,&nte,maxpdata,sizeof(maxpdata)))
		goto	ERET;
	if ( setDirEntry( &nte, "maxp"))
		goto	ERET;

	/*
	 * 'glyf' Write (missing glyph )
	 */
	if (TTFAppendTable( nfh, &nte, glyphData, gdatsiz))
		goto	ERET;
	if ( setDirEntry( &nte, "glyf"))
		goto	ERET;
	free( glyphData);
	glyphData = 0;
	/* Sort dir entry table */
	SortEntry( te, NUMTABLES);

	/* Write dir entry */
	if (TTFWriteDirEntry( nfh, te, NUMTABLES))
		goto	ERET;

	/* Set Check sum of file whole to head */
	if (fileChkSum( nfh, te, NUMTABLES, &hdr, &head))
		goto	ERET;
	CloseHandle( nfh);
	if ( te)	free( te);
	return 0;
ERET:
	if ( nfh != INVALID_HANDLE_VALUE)	CloseHandle( nfh);
	if ( te)	free( te);
	if ( nameBuf)	free( nameBuf);
	if ( hmet)	free( hmet);
	if ( loca)	free( loca);
	if ( os2buf)	free( os2buf);
	if ( glyphData)	free( glyphData);
	return -1;
}
/***********************************************************************
 *	Obtain BoundingBox ( from 'head' xMin, xMax, yMin, yMax)
 */
/* */	int
/* */	TTFGetBBX(
/* */		HDC	hDC,
/* */		struct BBX	*bbx,
/* */		short		*uPEm)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
struct	HeadTable	head;
	DWORD	dwTable;	/* tagName to request */
	DWORD	siz, s;

	memcpy( &dwTable, "head", TAGSIZ);
	siz = (DWORD)sizeof( struct HeadTable);

	
	if ((s=GetFontData(hDC, dwTable, (DWORD)0, &head,(DWORD)siz))!=siz){
		DWORD err = GetLastError();
		return -1;
	}
	smtoi( &head.xMin);
	smtoi( &head.xMax);
	smtoi( &head.yMin);
	smtoi( &head.yMax);
	smtoi( &head.unitsPerEm);
	bbx->xMin = head.xMin;
	bbx->xMax = head.xMax;
	bbx->yMin = head.yMin;
	bbx->yMax = head.yMax;
	*uPEm = head.unitsPerEm;
	if ( bbx->xMin < 0 )
		bbx->xMin = 0;
	return 0;
}
int
TTFTmpPath( TCHAR *path, TCHAR *tmpPath)
{
	TCHAR	*p1;
	TCHAR	dirPath[MAX_PATH];


	lstrcpy( dirPath, path);
	p1 = Mytcsrchr( dirPath, '\\');
	if ( p1==(TCHAR *)0) {
		p1 = Mytcsrchr( dirPath, ':');
		if (p1==(TCHAR *)0)
			*dirPath=(TCHAR)0;
		else
			*(p1+1)=0;
	}
	else
		*p1=0;
	if (GetTempFileName( dirPath, TEXT("TTE"), 0, tmpPath)==0)
		return -1;
	else
		return 0;

}
static int
copyTable( HANDLE iFh,HANDLE oFh, struct TableEntry *te, int nEntry, char *tag)
{
struct TableEntry *tep;
	char	*buf = NULL;

	if ((tep = searchEntry(te, nEntry, tag))==(struct TableEntry *)0)
		goto	ERET;
	if ((buf = (char *)malloc((size_t)tep->siz))==(char *)0)
		goto	ERET;
	if ( (TTFReadTable( iFh,tep, buf, (int)tep->siz)!=(int)tep->siz) )
		goto	ERET;
	if ( (TTFWriteTable( oFh,tep, buf, (int)tep->siz)!=(int)tep->siz) )
		goto	ERET;
	free(buf);
	return 0;
ERET:
	if (buf)	free(buf);
	return -1;
	
}
static int
copyfblock( HANDLE iFh, HANDLE oFh, unsigned long siz, unsigned long *cs)
{
	int	rwsiz;
	int	filsiz;
	int	aligne;
	unsigned long	chksum;
	char	*buf;

	if ((buf = (char *)malloc((size_t) RWBUFSIZ))==(char *)0)
		goto	ERET;

	filsiz = (int)(siz % 4);
	if ( filsiz)	filsiz = 4-filsiz;
	aligne =0;
	chksum = 0;
	while ( siz > 0) {
		if ( siz > RWBUFSIZ)
			rwsiz = RWBUFSIZ;
		else	{
			rwsiz = (int)siz;
			if ( filsiz)
				aligne =1;
		}
		DWORD nByte;
		BOOL res = ReadFile(iFh, buf,(unsigned int)rwsiz, &nByte, NULL );
		if (!res || nByte != (unsigned int)rwsiz)
			goto	ERET;

		if ( aligne ) {
			memset( buf+siz, 0, filsiz);
			rwsiz += filsiz;
		}
		chksum += calchksum( buf, rwsiz);

		res = WriteFile ( oFh, buf, (unsigned int)rwsiz, &nByte, NULL);
		if (!res || nByte !=(unsigned int)rwsiz)
			goto	ERET;
		siz -= rwsiz;
	}
	*cs = chksum;
	free(buf);
	return 0;
ERET:
	if(buf)	free(buf);
	return -1;
}
static int
mergeGlyph(
	HANDLE	iFh,
	HANDLE	oFh,
	struct TableEntry *tep,
	char	*locabuf,
	int	glyphID,
	char	*glyphData,
	int	glyphSiz)
{
	long	*locp;
	long	nloc, cloc;
	long	iofs;
	long	tail;
	long	siz;
	int	gid;
	long	delta;
	unsigned long	cs;
	int	filsiz;
	long	lval;

	locp = (long *)locabuf;

	cs = 0;
	/* copy leading */
	cloc = *locp;
	lmtoi( &cloc);
	iofs = (unsigned long)tep->ofs+cloc;
	if ((long) SetFilePointer( iFh, iofs, NULL, FILE_BEGIN) != iofs)
		goto	ERET;
	if ((long) SetFilePointer( oFh, iofs, NULL, FILE_BEGIN) != iofs)
		goto	ERET;
	cloc = *(locp + glyphID);
	lmtoi( &cloc);
	nloc = *(locp + glyphID+1);
	lmtoi( &nloc);
	siz = nloc - cloc;

	if (copyfblock( iFh, oFh, cloc, &cs))
		goto	ERET;
	/* write glyphData */
	if ( glyphSiz>0L) {
		filsiz = glyphSiz % 4;
		if ( filsiz) {
			filsiz = 4 - filsiz;
			memset( glyphData+glyphSiz, 0, filsiz);
			glyphSiz += filsiz;
		}
		DWORD nByte;
		BOOL res = WriteFile( oFh, glyphData, (unsigned int)glyphSiz, &nByte, NULL);
		if (!res || nByte !=(unsigned int)glyphSiz)
			goto	ERET;
		cs += calchksum( glyphData, glyphSiz);
	}
	iofs = nloc + tep->ofs;
	/* copy trailer */
	if ((long) SetFilePointer( iFh, iofs, NULL, FILE_BEGIN) != iofs)
		goto	ERET;
	tail = *(locp+numOfGlyph);
	lmtoi(&tail);
	siz = tail - nloc;
	if (copyfblock( iFh, oFh, siz, &cs))
		goto	ERET;
	/* update loca */
	delta = glyphSiz - (nloc - cloc);
	for ( gid = glyphID+1; gid<=numOfGlyph; gid++) {
		lval = *(locp+gid);
		lmtoi(&lval);
		lval += delta;
		litom(&lval);
		*(locp+gid)=lval;
	}
	tep->siz = tail+delta;
	return 0;
ERET:
	return -1;
}
/***********************************************************************
 *	Add EUDC Font
 */
/* */	int
/* */	TTFAddEUDCChar(
/* */		TCHAR	*path,	/* EUDC FontFile path */
/* */		unsigned short	code, /* Charcode */
/* */	struct BBX	*bbx,	/* Bounding Box */
/* */		int	lstH) /* List Handle for glyph */
/*
 *	returns :0, -1
 ***********************************************************************/
{
struct TTFHeader	hdr;
struct HeadTable	head;
struct MaxpTbl		maxp;
	HANDLE	fH;
	HANDLE	tmpFh = INVALID_HANDLE_VALUE;
struct TableEntry	*te;
struct TableEntry	*tep;
struct TableEntry	*maxpTep;
struct TableEntry	*locaTep;
	int		glyphID;
struct HMetrics		hmet;
struct VMetrics		vmet;
	int		nEntry;
	char		*updbuf;
	char		*glyphData;
	int		bufsiz;
	int		gdatsiz;
	short		sval;
struct BBX	cbbx;
	TCHAR	tmpPath[MAX_PATH];
	TCHAR	savPath[MAX_PATH];
	int	sts;
  HINSTANCE hInst = AfxGetInstanceHandle();
  TCHAR szMessage[256];

	lastErr = 0;
	te = ( struct TableEntry *)0;
	updbuf = (char *)0;
	glyphData = (char *)0;

	fH = CreateFile(path,
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fH == INVALID_HANDLE_VALUE)
		goto	ERET;

	TTFTmpPath( path, tmpPath);
	if ( tmpPath[0] == NULL )
		goto ERET;
	
	tmpFh = CreateFile(tmpPath,
					GENERIC_WRITE,
					FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
					NULL,
					CREATE_ALWAYS,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( tmpFh == INVALID_HANDLE_VALUE)
		goto	ERET;

	if ( TTFReadHdr( fH, &hdr))
		goto	ERET;
	if ( TTFWriteHdr( tmpFh, &hdr))
		goto	ERET;
	nEntry = hdr.numTables;
	glyphID = codeToGID( code);

	/* Read Table entries */
	if ( (te = (struct TableEntry *)malloc((size_t)sizeof(struct TableEntry)*NUMTABLES))==0)
		goto	ERET;

	if (TTFReadDirEntry( fH, te, nEntry))
		goto	ERET;
	if (TTFWriteDirEntry( tmpFh, te, nEntry))
		goto	ERET;
	if (copyTable( fH, tmpFh, te, nEntry, "cvt "))
		goto	ERET;
	if (copyTable( fH, tmpFh, te, nEntry, "fpgm"))
		goto	ERET;
	if (copyTable( fH, tmpFh, te, nEntry, "prep"))
		goto	ERET;
	if (copyTable( fH, tmpFh, te, nEntry, "name"))
		goto	ERET;
	if (copyTable( fH, tmpFh, te, nEntry, "cmap"))
		goto	ERET;
	if (copyTable( fH, tmpFh, te, nEntry, "OS/2"))
		goto	ERET;
	if (copyTable( fH, tmpFh, te, nEntry, "post"))
		goto	ERET;
	if (copyTable( fH, tmpFh, te, nEntry, "hhea"))
		goto	ERET;
	if (copyTable( fH, tmpFh, te, nEntry, "vhea"))
		goto	ERET;

	/* Read maxp Table */
	if ((maxpTep = searchEntry(te, nEntry, "maxp"))==0)
		goto	ERET;
	if ( TTFReadTable( fH, maxpTep, &maxp, sizeof maxp)!=(sizeof maxp) )
		goto	ERET;
	
	sval = maxp.numGlyph;	
	smtoi( &sval);
	numOfGlyph = sval;

	// Glyph is out of TTE file range, Win9x upgrade
	if (glyphID >= numOfGlyph) 
	    goto ERET;

	bufsiz = sizeof(struct HMetrics)*(numOfGlyph);
	bufsiz = align32( bufsiz);
	if ( (updbuf = (char *)malloc( (size_t)bufsiz))==0)
		goto	ERET;

	/* make metrics for the glyph */
	cbbx = *bbx;
	makeMetrics( lstH, &hmet, &vmet, &cbbx);

	/* make glyph data */
	if ((glyphData = (char *)malloc((size_t)GLYPHBUFSIZ))==0)
		goto	ERET;
	if (sts=makeGlyphData(lstH, &cbbx, glyphData, GLYPHBUFSIZ, &gdatsiz)) {
		lastErr = sts;
		goto	ERET;
	}
	/* set hmetrics */
	sitom( &hmet.advanceWidth);
	sitom( &hmet.leftSideBearing);
	if ((tep = searchEntry(te, nEntry, "hmtx"))==0)
		goto	ERET;
	if ( TTFReadTable( fH, tep, updbuf, bufsiz)<=0)
		goto	ERET;
	*((struct HMetrics *)updbuf + glyphID) = hmet;
	if ( TTFWriteTable( tmpFh, tep, updbuf, bufsiz)<=0)
		goto	ERET;
	free( updbuf);
	updbuf = 0;

	/* Update 'vmtx' */
	bufsiz = sizeof(struct VMetrics)*(numOfGlyph);
	bufsiz = align32( bufsiz);
	if ( (updbuf = (char *)malloc( (size_t)bufsiz))==0)
		goto	ERET;

	/* set vmetrics */
	sitom( &vmet.advanceHeight);
	sitom( &vmet.topSideBearing);
	if ((tep = searchEntry(te, nEntry, "vmtx"))==0)
		goto	ERET;
	if ( TTFReadTable( fH, tep, updbuf, bufsiz)<=0)
		goto	ERET;
	*((struct VMetrics *)updbuf + glyphID) = vmet;
	if ( TTFWriteTable( tmpFh, tep, updbuf, bufsiz)<=0)
		goto	ERET;
	free( updbuf);
	updbuf = 0;

	/* Read loca */
	bufsiz = sizeof(long )*(numOfGlyph+1);
	bufsiz = align32( bufsiz);
	if ( (updbuf = (char *)malloc((size_t)bufsiz)) ==(char *)0)
		goto	ERET;
	if ((locaTep = searchEntry(te, nEntry, "loca"))==0)
		goto	ERET;
	if ( TTFReadTable( fH, locaTep, updbuf, bufsiz)<=0)
		goto	ERET;

	/* move glyf data */
	if ((tep = searchEntry(te, nEntry, "glyf"))==0)
		goto	ERET;
	if (mergeGlyph( fH, tmpFh, tep, updbuf, glyphID, glyphData, gdatsiz ))
		goto	ERET;
	/* read and cal checkSum of 'glyf' */
	if (tableChkSum( tmpFh, tep))
		goto	ERET;

	free( glyphData);
	glyphData =(char *)0;
	/* write loca */
	if ( TTFWriteTable( tmpFh, locaTep, updbuf, bufsiz)<=0)
		goto	ERET;

	/* update maxp */
	if ( updateMaxp( &maxp,  lstH) < 0)
		goto	ERET;
	if (TTFWriteTable(tmpFh, maxpTep, &maxp, sizeof maxp)!=(sizeof maxp))
		goto	ERET;

	/* update directory entry */
	if (TTFWriteDirEntry( tmpFh, te, nEntry))
		goto	ERET;

	/* Set Check sum of file whole to head */
	if ((tep = searchEntry(te, nEntry, "head"))==0)
		goto	ERET;
	if ( TTFReadTable( fH, tep, &head, sizeof head)<=0)
		goto	ERET;
	tep->checkSum = 0L;
	if ( TTFWriteTable( tmpFh, tep, &head, sizeof head)<=0)
		goto	ERET;
	if (fileChkSum(tmpFh , te, nEntry, &hdr, &head))
		goto	ERET;
	if ( TTFWriteTable( tmpFh, tep, &head, sizeof head)<=0)
		goto	ERET;

	CloseHandle( fH);
	CloseHandle( tmpFh);

//	fH = tmpFh = -1;

  TTFTmpPath( path, savPath); 
  if( DeleteFile( savPath)==0) {
    TCHAR szTitle[256];
    LoadString(hInst, IDS_MAINFRAMETITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
    LoadString(hInst, IDS_NOMEM_MSG, szMessage, sizeof(szMessage) / sizeof(TCHAR));
    MessageBox( AfxGetMainWnd()->GetSafeHwnd(), szMessage, szTitle, MB_OK);
		goto	ERET2;
  }
	if( MoveFile( path, savPath)==0) {
    TCHAR szTitle[256];
    LoadString(hInst, IDS_MAINFRAMETITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
    LoadString(hInst, IDS_NOMEM_MSG, szMessage, sizeof(szMessage) / sizeof(TCHAR));
    MessageBox( AfxGetMainWnd()->GetSafeHwnd(), szMessage, szTitle, MB_OK);
    goto	ERET2;
	}
  if( MoveFile( tmpPath, path)==0) {
    TCHAR szTitle[256];
    LoadString(hInst, IDS_MAINFRAMETITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
    LoadString(hInst, IDS_NOMEM_MSG, szMessage, sizeof(szMessage) / sizeof(TCHAR));
    MessageBox( AfxGetMainWnd()->GetSafeHwnd(), szMessage, szTitle, MB_OK);
		goto	ERET2;
  }
  if ( DeleteFile( savPath) ==0) {
    DeleteFile(path);
    MoveFile(savPath, path);
	  if ( te)	free(te);
    if ( updbuf)	free(updbuf);
	  if ( glyphData)	free(glyphData);
    return -3; //tte file is being used by another process
  }

  free( te);
	free( updbuf);
	return 0;

ERET:
	if ( fH != INVALID_HANDLE_VALUE)	CloseHandle(fH);
	if ( tmpFh != INVALID_HANDLE_VALUE)	CloseHandle(tmpFh);
	if ( te)	free(te);
	if ( updbuf)	free(updbuf);
	if ( glyphData)	free(glyphData);
	return -1;

ERET2:
	if ( fH != INVALID_HANDLE_VALUE)	CloseHandle(fH);
	if ( tmpFh != INVALID_HANDLE_VALUE)	CloseHandle(tmpFh);
	if ( te)	free(te);
	if ( updbuf)	free(updbuf);
	if ( glyphData)	free(glyphData);
	if ( tmpPath) DeleteFile( tmpPath);
	return -1;
}


/***********************************************************************
 *	For Import
 */
static HANDLE eudcFh;
static char *locaBuf = 0;
static char *maxpBuf = 0;
static char	*hmtxBuf = 0;
static char	*vmtxBuf = 0;
static char	*glyphBuf = 0;

static void
frebuf()
{
	if ( locaBuf) {
		free( locaBuf);
		locaBuf = 0;
	}
	if ( maxpBuf) {
		free( maxpBuf);
		maxpBuf = 0;
	}
	if ( vmtxBuf) {
		free( vmtxBuf);
		vmtxBuf = 0;
	}
	if ( hmtxBuf) {
		free( hmtxBuf);
		hmtxBuf = 0;
	}
	if ( glyphBuf) {
		free( glyphBuf);
		glyphBuf = 0;
	}
	if ( et) {
		free( et);
		glyphBuf = 0;
	}
	return;
}
int
TTFOpen( TCHAR *path)
{
struct TTFHeader	hdr;
unsigned int	bufsiz;
unsigned short	sval;

	et = 0;
	eudcFh = CreateFile(path,
					GENERIC_READ | GENERIC_WRITE,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( eudcFh == INVALID_HANDLE_VALUE)
		goto	ERET;

	if (TTFReadHdr(eudcFh,&hdr))
		goto	ERET;

	if ((et = (struct TableEntry *)malloc( sizeof (struct TableEntry)*hdr.numTables))
			==0)
		goto	ERET;
	entryNum = hdr.numTables;
	if (TTFReadDirEntry(eudcFh, et, hdr.numTables))
		goto	ERET;

	if (TTFReadVarTable( eudcFh, &maxpBuf, &bufsiz, "maxp"))
		goto	ERET;
	sval = ((struct MaxpTbl *)maxpBuf) ->numGlyph;
	smtoi( (short *)&sval);
	numOfGlyph = sval;

	if (TTFReadVarTable( eudcFh, &locaBuf, &bufsiz, "loca"))
		goto	ERET;
	if (TTFReadVarTable( eudcFh, &hmtxBuf, &bufsiz, "hmtx"))
		goto	ERET;
	if (TTFReadVarTable( eudcFh, &vmtxBuf, &bufsiz, "vmtx"))
		goto	ERET;
	if ((glyphBuf = (char *)malloc( GLYPHBUFSIZ))==0)
		goto	ERET;
	return 0;
ERET:
	if ( eudcFh != INVALID_HANDLE_VALUE) {
		CloseHandle( eudcFh);
		eudcFh = INVALID_HANDLE_VALUE;
	}
	frebuf();
	return -1;
}
int
TTFClose()
{
struct TableEntry	*tep;
struct HeadTable	head;
struct TTFHeader	hdr;
	long		ofs;
	if ( eudcFh == INVALID_HANDLE_VALUE)
		return -1;
	if (TTFReadHdr( eudcFh, &hdr))
		goto	ERET;
	/* obtain glyph table size */
	ofs = SetFilePointer( eudcFh, 0L, NULL, FILE_END);

	/* Update Glyph checkSum */
	if ((tep = searchEntry(et, entryNum, "glyf"))==0)
		goto	ERET;
	tep->siz = ofs - tep->ofs;

	/* read and cal checkSum of 'glyf' */
	if (tableChkSum( eudcFh, tep))
		goto	ERET;

	if ((tep = searchEntry(et, entryNum, "maxp"))==0)
		goto	ERET;

	if (TTFWriteTable( eudcFh, tep, maxpBuf, (int)tep->siz)!=(int)tep->siz)
		goto	ERET;

	if ((tep = searchEntry(et, entryNum, "loca"))==0)
		goto	ERET;

	if (TTFWriteTable( eudcFh, tep, locaBuf, (int)tep->siz)!=(int)tep->siz)
		goto	ERET;
	
	if ((tep = searchEntry(et, entryNum, "hmtx"))==0)
		goto	ERET;
	if (TTFWriteTable( eudcFh, tep, hmtxBuf, (int)tep->siz)!=(int)tep->siz)
		goto	ERET;
	if ((tep = searchEntry(et, entryNum, "vmtx"))==0)
		goto	ERET;
	if (TTFWriteTable( eudcFh, tep, vmtxBuf, (int)tep->siz)!=(int)tep->siz)
		goto	ERET;
	if ((tep = searchEntry(et, entryNum, "head"))==0)
		goto	ERET;

	if ( TTFReadTable(eudcFh, tep, &head, sizeof(head))!=sizeof(head))
		goto	ERET;

	if ( fileChkSum(eudcFh, et, entryNum, &hdr, &head))
		goto	ERET;

	if ( TTFWriteDirEntry( eudcFh, et, entryNum))
		goto	ERET;
	CloseHandle( eudcFh);
	frebuf();
	return 0;
ERET:
	CloseHandle( eudcFh);
	frebuf();
	return -1;
}
int
TTFGetEUDCBBX(TCHAR *path, struct BBX *bbx, short *upem)
{
struct	HeadTable	head;
	HANDLE	fH;

	fH = CreateFile(path,
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fH == INVALID_HANDLE_VALUE)
		goto	ERET;

	if ( TTFReadFixedTable(fH, (char *)&head,sizeof head,"head"))
		goto	ERET;
	smtoi( &head.xMin);
	smtoi( &head.xMax);
	smtoi( &head.yMin);
	smtoi( &head.yMax);
	smtoi( &head.unitsPerEm);
	bbx->xMin = head.xMin;
	bbx->xMax = head.xMax;
	bbx->yMin = head.yMin;
	bbx->yMax = head.yMax;
	*upem = head.unitsPerEm;
	if ( bbx->xMin < 0 )
		bbx->xMin = 0;
	CloseHandle( fH);
	return 0;
ERET:
	if (fH!=INVALID_HANDLE_VALUE)
		CloseHandle( fH);
	return -1;
}
static void
makeMetrics(int lsthdl, struct HMetrics *hM, struct VMetrics *vM, struct BBX *bbx)
{
struct VHEAD	*vhd;
struct VDATA	*vp;
	int	np;
	int	sts;
	int	xmin, ymin, xmax, ymax;


	if ( (sts = VDGetHead( lsthdl, &vhd))!=0)
		goto	RET;
	if ( (sts = VDGetNCont( lsthdl))<=0)
		goto	SPACE_CHAR;
	xmin = xmax = vhd->headp->vd.x;
	ymin = ymax = vhd->headp->vd.y;
	while ( vhd->next != NIL) {
		vp = vhd->headp;
		np = vhd->nPoints;
		while ( np-->0) {
			if (vp->vd.x > xmax)
				xmax = vp->vd.x;
			else if(vp->vd.x < xmin)
				xmin = vp->vd.x;
			if (vp->vd.y > ymax)
				ymax = vp->vd.y;
			else if(vp->vd.y < ymin)
				ymin = vp->vd.y;
			vp = vp->next;
		}
		vhd = vhd->next;
	}
//	if ( xmin < 0)
//		xmin = 0;
	hM->leftSideBearing = (short)xmin;
  hM->advanceWidth = bbx->xMax - bbx->xMin;
  {
    int hmw = hM->advanceWidth + 1;
    int ii = 0;
    while (hmw >> 1)
      {
        hmw >>= 1;
        ii++;
      }
    hmw = 1;
    while (ii--) hmw *= 2;
    int gap1 = hM->advanceWidth - hmw;
    int gap2 = hmw*2 - hM->advanceWidth;
    hmw = gap1 > gap2 ? hmw * 2 : hmw;
    hM->advanceWidth = (short)hmw;
  } 
	vM->topSideBearing = bbx->yMax - ymax;
	if (vM->topSideBearing < 0)
		vM->topSideBearing = 0;
	vM->advanceHeight = bbx->yMax - bbx->yMin;
	bbx->xMin = xmin;
	bbx->yMin = ymin;
	bbx->xMax = xmax;
	bbx->yMax = ymax;
	return;
RET:

SPACE_CHAR:
	hM->leftSideBearing = (short)bbx->xMax;
	hM->advanceWidth = bbx->xMax - bbx->xMin;
	vM->topSideBearing = bbx->yMax - bbx->yMin;
	vM->advanceHeight = bbx->yMax - bbx->yMin;
	bbx->xMin = bbx->xMax;
	bbx->yMax = bbx->yMin;
	return;
}

int
TTFAppend( unsigned short code,  struct BBX *bbx, int lsthdl)
{
	int	glyphID;
struct HMetrics	hmet;
struct VMetrics	vmet;
	int	updflg;
	int	gdatsiz;
struct BBX	cbbx;
	int	sts;

	glyphID = codeToGID( code);
	lastErr = 0;
	/* make metrics */
	cbbx = *bbx;
	makeMetrics( lsthdl, &hmet, &vmet, &cbbx);

	/* make glyph data */
	if (sts =makeGlyphData(lsthdl, &cbbx, glyphBuf, GLYPHBUFSIZ, &gdatsiz)) {
		lastErr = sts;
		goto	ERET;
	}
	/* set hmetrics */
	sitom( &hmet.advanceWidth);
	sitom( &hmet.leftSideBearing);
	*((struct HMetrics *)hmtxBuf + glyphID) = hmet;

	/* Update 'vmtx' */
	sitom( &vmet.advanceHeight);
	sitom( &vmet.topSideBearing);
	*((struct VMetrics *)vmtxBuf + glyphID) = vmet;

	/* write glyf data */
	if (TTFImpGlyphWrite( glyphID, glyphBuf, gdatsiz))
		goto	ERET;
	/* update maxp */
	if ((updflg = updateMaxp( (struct MaxpTbl *)maxpBuf,  lsthdl)) < 0)
		goto	ERET;
	return 0;
ERET:
	return -1;
}
/*
 * Copy
 */
int
TTFImpCopy( TCHAR *sPath, TCHAR *dPath)
{
	HANDLE	sFh, dFh;
struct TTFHeader	hdr;
struct TableEntry	*te;
	int		tblSiz;
	int		ntbl;
	int		tcnt;
	char	*buf;
	int	bufsiz;

	sFh = dFh = 0;
	te = 0;
	buf  = 0;

  /* Open src */
	sFh = CreateFile(sPath,
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);
	if (sFh == INVALID_HANDLE_VALUE)
		goto	ERET;
	/* create open destination*/
	dFh = CreateFile(dPath,
					GENERIC_WRITE,
					FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
					NULL,
					CREATE_ALWAYS,
					FILE_ATTRIBUTE_NORMAL,
					NULL);
	if (dFh == INVALID_HANDLE_VALUE)
		goto	ERET;
	
	/* read header */
	if ( TTFReadHdr( sFh, &hdr))
		goto	ERET;
	ntbl = (int)hdr.numTables;
	/* write header */
	if ( TTFWriteHdr( dFh, &hdr))
		goto	ERET;
	
	/* read directory entry */
	tblSiz = sizeof( struct TableEntry)*ntbl;
	if ((te = (struct TableEntry *)malloc(tblSiz))==(struct TableEntry *)0)
		goto	ERET;

	if ( TTFReadDirEntry(sFh, te, ntbl))
		goto	ERET;

	/* write directory entry */
	if ( TTFWriteDirEntry(dFh, te, ntbl))
		goto	ERET;

	/* copy each table (except glyph)*/
	for ( tcnt = 0; tcnt < ntbl; tcnt++) {
		if ( memcmp((te+tcnt)->tagName,"glyf", 4)) {
			bufsiz = (int)(te+tcnt)->siz;
			buf = (char *)malloc((int)(te+tcnt)->siz);
			if (TTFReadTable( sFh, te+tcnt, buf, bufsiz)!=bufsiz)
				goto	ERET;
			if (TTFWriteTable( dFh, te+tcnt, buf, bufsiz)!=bufsiz)
				goto	ERET;
			free( buf);
			buf = 0;
		}
	}
	/* close */
	CloseHandle( sFh);
	CloseHandle( dFh);
	free( te);
	return 0;
ERET:
  if (sFh != INVALID_HANDLE_VALUE) CloseHandle(sFh);
  if (dFh != INVALID_HANDLE_VALUE) CloseHandle(dFh);
	if (te)
		free( te);
	if ( buf)	free( buf);
	return -1;
}
int
TTFImpGlyphCopy(
	HANDLE	sFh,
	int	glyphID)
{
struct TableEntry *tep;
	long	*locap;
	long	cloc, nloc;
	long	siz;
	long	ofs;
	long	wofs;
	char	*buf;
	DWORD	nByte;

	buf = 0;
	if ((tep = searchEntry( et, entryNum, "glyf"))==0)
		goto	ERET;
	locap = (long *)locaBuf;
	cloc = *(locap+glyphID);
	lmtoi( &cloc);
	nloc = *(locap+glyphID+1);
	lmtoi( &nloc);
	siz = nloc - cloc;
	ofs = tep->ofs + cloc;

	if ( (long) SetFilePointer( sFh, ofs, NULL, FILE_BEGIN) != ofs)
		goto	ERET;

	wofs = SetFilePointer( eudcFh, 0L, NULL, FILE_END);
	wofs -= tep->ofs;
	litom( &wofs);
	*(locap+glyphID) = wofs;
	if ( siz) {
		if ( (buf = (char *)malloc((int)siz))==(char *)0)
			goto	ERET;

		BOOL res = ReadFile( sFh, buf, (unsigned int)siz, &nByte, NULL);
		if (!res ||	nByte !=(unsigned int)siz)
			goto	ERET;

		res = WriteFile( eudcFh, buf,(unsigned int)siz, &nByte, NULL);
		if (!res ||	nByte !=(unsigned int)siz)
			goto	ERET;
	}
	free( buf);
	return 0;
ERET:
	if ( buf)	free( buf);

	return -1;
}
int
TTFImpGlyphWrite(
	int	glyphID, char *glyph, int siz)
{
struct TableEntry *tep;
	long	ofs;
	long	wofs;
	long	*locap;
	DWORD	nByte;

	if ( glyphID >= numOfGlyph)
		return -1;
	if ((tep = searchEntry( et, entryNum, "glyf"))==0)
		goto	ERET;
	
	wofs =  SetFilePointer( eudcFh, 0L, NULL, FILE_END);
	ofs = wofs - tep->ofs;
	litom( &ofs);
	locap = (long *)locaBuf;
	*(locap+glyphID) = ofs;
	if ( siz) {
		BOOL res = WriteFile(eudcFh, glyph, (unsigned int)siz, &nByte, NULL);
		if (!res || nByte !=(unsigned int)siz)
			goto	ERET;
	}
	return 0;
ERET:
	return -1;
}

int
TTFImpTerm(HANDLE orgFh, int glyphID)
{
struct TableEntry *tep;
	
	long	ofs;
	long	wofs;
	long	*locap;
	int		gid;
	
	//
	// copy the rest of the glyph data over.
	//
	for ( gid = glyphID; gid < numOfGlyph; gid++)
	{
		if (TTFImpGlyphCopy(orgFh, gid))
			return -1;
	}

	if ((tep = searchEntry( et, entryNum, "glyf"))==0)
		return -1;
	locap = (long *)locaBuf;
	wofs =  SetFilePointer( eudcFh, 0L,NULL, FILE_END);
	ofs = wofs - tep->ofs;
	litom( &ofs);
	*(locap + numOfGlyph) = ofs;
	tep->siz = wofs - tep->ofs;

	return 0;

}
int
TTFLastError()
{
	return lastErr;
}
/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\vdata.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//

#define		LISTDATAMAX	4
#define		NIL		((void *)0)
struct vecdata	{
	short	x, y, atr, dummy;
	};

struct VDATA	{
	struct VDATA	*next, *prev;
	struct vecdata	vd;
	};

struct VHEAD	{
	struct VHEAD	*next, *prev;
	struct VDATA	*headp;
	int		nPoints;
	};
struct VCNTL	{
	struct VHEAD	*rootHead;
	struct VHEAD	*currentHead;
	int		nCont;
	struct VDATA	*cvp;
	int	mendp;
	void	*memroot;
	void	*cmem;
	};


int  VDInit(void);
void  VDTerm(void);
void  VDNew(int  lsthdl);
int  VDClose(int  lsthdl);
int  VDSetData(int  lsthdl,struct  vecdata *pnt);
int  VDGetHead(int  lsthdl,struct  VHEAD * *vhd);
int  VDGetNCont(int  lsthdl);
int  VDReverseList(int  lsthdl);
int  VDCopy(int  srcH, int dstH);

/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\w31jeudc.cpp ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
#include	"stdafx.h"
#pragma		pack(2)

#include	"vdata.h"
#include	"ttfstruc.h"
#include	"extfunc.h"
/*
 *	Win3.1J EUDC fontfile i/o
 */
#define		EUDCCODEBASE	((unsigned short)0xe000)
/*
 File Structure */

struct W31_Header {
	char	identify[72];
	short	segCnt;		/* ??? */
unsigned short	sCode,
		eCode;
	short	cCnt;
	long	ofsCmap;
	short	sizCmap;
	long	ofsFil;
	short	sizFil;
	long	ofsStbl;	/* search tbl*/
	short	sizStbl;
	long	ofsBdatSub;
	};

struct BDatSubTbl {
	long	tail;
	long	filler1;
	long	head;
	short	filler2;
	/* Following Pointer tbl. */
	};
struct BMPHeader {
	long	bitmapSiz;
	short	xsiz, ysiz;
	};


static int  ReadBdatSub(HANDLE hdl,long  ofs,struct  BDatSubTbl *tbl);
static int  WriteBdatSub(HANDLE  hdl,long  ofs,struct  BDatSubTbl *tbl);
static int  ReadBDatEntry(HANDLE  hdl,long  *ofs,long  rec);
static int  WriteBDatEntry(HANDLE  hdl,long  ofs,long  rec);
static int  ReadBMPHdr(HANDLE  hdl,long  ofs,struct  BMPHeader *hdr);
static int  WriteBMPHdr(HANDLE  hdl,long  ofs,struct  BMPHeader *hdr);


static int	init = 0;
static long	bdathead;
static long	bdatptr;
static int	maxRec;
static TCHAR fpath[128];

/***************************************************************
 *	Initialize
 */
/* */	int
/* */	OpenW31JEUDC( TCHAR *path)
/*
 *	returns : 0, -1
 ***************************************************************/
{
	HANDLE fHdl;
struct W31_Header hdr;
	DWORD nByte;
	BOOL res;

	makeUniCodeTbl();
	lstrcpy( fpath, path);
	/* open EUDC Font File */
	fHdl = CreateFile(path,
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fHdl == INVALID_HANDLE_VALUE)
		return -1;

	/* Read Header */
	res = ReadFile( fHdl, &hdr, sizeof(struct W31_Header), &nByte, NULL);
	if (!res || nByte !=sizeof(struct W31_Header))
  {
    CloseHandle(fHdl);
		return -1;
  }
	bdathead = hdr.ofsBdatSub;
	bdatptr = hdr.ofsBdatSub + sizeof(struct BDatSubTbl);
	maxRec = hdr.cCnt-1;

	/* close Font File */
	CloseHandle( fHdl);
	init = 1;
	return	0;
}
/***************************************************************
 *	Terminate Close
 */
/* */	void
/* */	CloseW31JEUDC()
/*
 *	returns : none
 ***************************************************************/
{
	init = 0;
	return;
}
static int
codeToRec( unsigned short code, BOOL bUnicode)
{
	return (int)((bUnicode ? code : sjisToUniEUDC(code)) - EUDCCODEBASE);
}
/***************************************************************
 *	Read Bitmap
 */
/* */	int
/* */	GetW31JEUDCFont(
/* */		unsigned short	code,	/*  native-code */
/* */		LPBYTE buf,	/* buffer to set bitmap */
/* */		int	bufsiz,	/* Buffer Size */
/* */		int	*xsiz,	/* Bitmap X,Ysiz */
/* */		int	*ysiz,
/* */       BOOL bUnicode)
/*
 *	returns : >=0, -1
 ***************************************************************/
{
	HANDLE	fHdl;
	long	ofs;
struct BMPHeader	fhdr;
	int	bmpsiz;
	int	rdsiz;
	int	rec;
	DWORD nByte;
	BOOL res;

	rec = codeToRec( code, bUnicode);
	if (init==0)
		return -1;
	else if ( maxRec < rec || rec < 0)
		return -1;

	/* Open Font File */
	fHdl = CreateFile(fpath,
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fHdl == INVALID_HANDLE_VALUE)
		return	-1;
	/* read bitmap ptr on subTable */
	ofs = bdatptr + sizeof(long)*rec;
	if ( (long) SetFilePointer( fHdl, ofs, NULL, FILE_BEGIN)!=ofs)
		goto	ECLOSE_RET;
	res = ReadFile( fHdl, &ofs, sizeof(long), &nByte, NULL);
	if (!res || nByte !=sizeof(long))
		goto	ECLOSE_RET;
	if ( ofs==0L)	
		goto	ECLOSE_RET;
	ofs += bdathead;

	/* read Bitmap Header
		bitmap is Word aligned */
	if ( (long) SetFilePointer( fHdl, ofs, NULL, FILE_BEGIN)!=ofs)
		goto	ECLOSE_RET;
	res = ReadFile( fHdl, &fhdr, sizeof(struct BMPHeader), &nByte, NULL);
	if (!res || nByte != sizeof( struct BMPHeader))
		goto	ECLOSE_RET;

	bmpsiz = ((int)fhdr.xsiz+15)/16 *2 * (int)fhdr.ysiz;
	/* Read Bitmap Body */
	rdsiz = bmpsiz > bufsiz ? bufsiz : bmpsiz;

	res = ReadFile( fHdl, buf, (unsigned short)rdsiz, &nByte, NULL);
	if (!res || nByte !=(unsigned short)rdsiz)
		goto	ECLOSE_RET;
	rdsiz = bmpsiz > bufsiz ? bmpsiz - bufsiz : 0;
	*xsiz = fhdr.xsiz;
	*ysiz = fhdr.ysiz;

	CloseHandle (fHdl);
	return rdsiz;
ECLOSE_RET:
	CloseHandle (fHdl);
	return -1;
}
/***************************************************************
 *	Write Bitmap
 */
/* */	int
/* */	PutW31JEUDCFont(
/* */		unsigned short code,	/* native code */
/* */		LPBYTE buf,	/* buffer to set bitmap */
/* */		int	xsiz,	/* Bitmap X,Ysiz */
/* */		int	ysiz,
/* */       BOOL bUnicode)
/*
 *	returns : 0, -1
 ***************************************************************/
{
	HANDLE fHdl;
	long	ofs;
struct BMPHeader	fhdr;
	int	bmpsiz;
	int	wbmpsiz;
struct BDatSubTbl subTbl;
	int	rec;
	DWORD nByte;
	BOOL res;

	rec = codeToRec( code, bUnicode);

	if (init==0)
		return -1;
	else if ( maxRec < rec || rec < 0)
		return -1;
	/* Open Font File */
	fHdl = CreateFile(fpath,
					GENERIC_READ | GENERIC_WRITE,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fHdl == INVALID_HANDLE_VALUE)
		return	-1;

	/* read bitmap ptr on subTable */
	if (ReadBDatEntry( fHdl, &ofs, rec))
		goto	ECLOSE_RET;

	wbmpsiz = (xsiz+15)/16 *2 * ysiz;
	if ( ofs != 0L) {
		/* read Bitmap Header
			bitmap is Word aligned */
		if ( ReadBMPHdr( fHdl, ofs, &fhdr))
			goto	ECLOSE_RET;

		bmpsiz = ((int)fhdr.xsiz+15)/16 *2 * (int)fhdr.ysiz;
		if ( bmpsiz<wbmpsiz)
			ofs = 0L;
	}
	if ( ReadBdatSub( fHdl, bdathead, &subTbl))
		goto	ECLOSE_RET;
	if ( ofs == 0L) {
		ofs = subTbl.tail;
		subTbl.tail += wbmpsiz+sizeof(fhdr);
	}
	/* Write Bitmap Header */
	fhdr.xsiz = (short)xsiz;
	fhdr.ysiz = (short)ysiz;
	fhdr.bitmapSiz = wbmpsiz+sizeof(fhdr);
	if ( WriteBMPHdr( fHdl, ofs, &fhdr))
		goto	ECLOSE_RET;

	/* Write Bitmap Body */
	res = WriteFile( fHdl, buf, (unsigned short)wbmpsiz, &nByte, NULL);
	if (!res || nByte !=(unsigned short)wbmpsiz)
		goto	ECLOSE_RET;

	/* write bitmap ptr on subTable */
	if (WriteBDatEntry( fHdl, ofs, rec))
		goto	ECLOSE_RET;

	/* write subTable */
	if ( WriteBdatSub( fHdl, bdathead, &subTbl))
		goto	ECLOSE_RET;
	CloseHandle (fHdl);

	return 0;
ECLOSE_RET:
	CloseHandle (fHdl);
	return -1;
}
static int
ReadBdatSub( HANDLE hdl, long ofs, struct BDatSubTbl *tbl)
{
	DWORD nByte;
	BOOL res;
	if ( (long) SetFilePointer( hdl, ofs, NULL, FILE_BEGIN)!= ofs)
		goto	ERET;

	res = ReadFile( hdl, tbl, sizeof (struct BDatSubTbl), &nByte, NULL);
	if (!res || nByte !=sizeof (struct BDatSubTbl))
		goto	ERET;
	return 0;
ERET:
	return -1;
}
static int
WriteBdatSub( HANDLE hdl, long ofs, struct BDatSubTbl *tbl)
{
	DWORD nByte;
	BOOL res;
	if ( (long) SetFilePointer( hdl, ofs, NULL, FILE_BEGIN)!= ofs)
		goto	ERET;

	res = WriteFile( hdl, (char *)tbl, sizeof (struct BDatSubTbl), &nByte, NULL);
	if (!res || nByte !=sizeof (struct BDatSubTbl))
		goto	ERET;
	return 0;
ERET:
	return -1;
}
static int
ReadBDatEntry( HANDLE hdl, long *ofs, long rec)
{
	DWORD nByte;
	BOOL res;
	long	ofsofs;

	ofsofs = bdatptr+(long)sizeof(long)*rec;
	if ( (long) SetFilePointer( hdl, ofsofs, NULL, FILE_BEGIN)!=ofsofs)
		goto	ERET;
	res = ReadFile( hdl, ofs, sizeof (long), &nByte, NULL);
	if (!res || nByte != sizeof (long))
		goto	ERET;
	return 0;
ERET:
	return -1;
}
static int
WriteBDatEntry( HANDLE hdl, long ofs, long rec)
{
	long	ofsofs;
	DWORD nByte;
	BOOL res;

	ofsofs = bdatptr+(long)sizeof(long)*rec;
	if ( (long) SetFilePointer( hdl, ofsofs, NULL, FILE_BEGIN)!=ofsofs)
		goto	ERET;
	res = WriteFile( hdl, (char *)&ofs, sizeof(long), &nByte, NULL);
	if (!res || nByte != sizeof(long))
		goto	ERET;
	return 0;
ERET:
	return -1;
}
static int
ReadBMPHdr( HANDLE hdl, long ofs, struct BMPHeader *hdr)
{
	DWORD nByte;
	BOOL res;

	ofs += bdathead;
	if ( (long) SetFilePointer( hdl, ofs, NULL, FILE_BEGIN)!=ofs)
		goto	ERET;
	res = ReadFile( hdl, hdr, sizeof( struct BMPHeader), &nByte, NULL);
	if (!res || nByte !=sizeof( struct BMPHeader))
		goto	ERET;
	return 0;
ERET:
	return -1;
}
static int
WriteBMPHdr( HANDLE hdl, long ofs, struct BMPHeader *hdr)
{
	DWORD nByte;
	BOOL res;
	ofs += bdathead;
	if ( (long) SetFilePointer( hdl, ofs, NULL, FILE_BEGIN)!=ofs)
		goto	ERET;
	res = WriteFile( hdl, (char *)hdr, sizeof( struct BMPHeader), &nByte, NULL);
	if (!res || nByte !=sizeof( struct BMPHeader))
		goto	ERET;
	return 0;
ERET:
	return -1;
}

/***************************************************************
 *	is Win95 EUDC bitmap
 */
/* */	int
/* */   IsWin95EUDCBmp(LPTSTR szBmpPath)
/*
 *	returns : 0 (other), 1 (EUDC bitmap), -1(error)
 ***************************************************************/
{
	HANDLE fhdl;
struct W31_Header hdr;
	DWORD nByte;
	BOOL res;

	fhdl = CreateFile(szBmpPath,
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fhdl == INVALID_HANDLE_VALUE)
    {
		return -1;
    }
	res = ReadFile( fhdl, (LPBYTE)&hdr, sizeof(hdr), &nByte, NULL);
	CloseHandle( fhdl);
	if (!res || nByte !=sizeof(hdr)){
		return 0;
	}	

	/* compare idendify leading 16 byte, sCode, eCode and cCnt*/
	if (memcmp( hdr.identify, "Windows95 EUDC", 14))
    {
		return 0;
    }
	if(hdr.sCode != 0x00e0){
		return 0;
	}
	return 1;
}
/* EOF */

////////////////////////////////////////////////////////////////////
//
// To work-around font linking in "Select Code" and "Save Char As".
// so that a typeface specific font does not show any glyph it does
// not have (from EUDC.TTE)
//
//     path   = *.euf
//     pGlyph = an array of 800 byte for 6400 EUDC chars
//
////////////////////////////////////////////////////////////////////
BOOL
GetGlyph(TCHAR *Path, BYTE* pGlyph)
{
	HANDLE fHdl;
    struct W31_Header hdr;
	DWORD  nByte;
    long   Offset;
    WORD   wc;
    long   lptr;
    TCHAR *pChar;
    TCHAR  PathEUF[MAX_PATH];
	BOOL   bRet = FALSE;

    lstrcpy(PathEUF, Path);
    pChar = PathEUF + lstrlen(PathEUF) - 3;
    *pChar = 0;
    lstrcat(PathEUF, TEXT("EUF"));

	fHdl = CreateFile(PathEUF,
                      GENERIC_READ,
                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);
    if(fHdl == INVALID_HANDLE_VALUE) return FALSE;

    bRet = ReadFile( fHdl, &hdr, sizeof(struct W31_Header), &nByte, NULL);
    if(!bRet && nByte !=sizeof(struct W31_Header)) goto Done;

    lptr = hdr.ofsBdatSub + sizeof(struct BDatSubTbl);
    if((long)SetFilePointer(fHdl, lptr, NULL, FILE_BEGIN) != lptr) goto Done;

    memset(pGlyph, 0, 800);

    for(wc = 0; wc < hdr.cCnt; wc++)
    {
        bRet = ReadFile( fHdl, &Offset, sizeof(long), &nByte, NULL);
        if(!bRet) goto Done;
        if(Offset == 0L || nByte !=sizeof(long)) continue;

        pGlyph[wc>>3] |= (0x80>>(wc%8));
    }

Done:
    CloseHandle(fHdl);
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\w31jbmp.cpp ===
/*
 *	Win3.1J EUDC fontfile i/o ( MS-Code base)
 *
 * Copyright (c) 1997-1999 Microsoft Corporation.
 */


#include	"stdafx.h"
#pragma		pack(2)

#include	"extfunc.h"
/*
 File Structure */

struct W31_Header {
	char	identify[72];
	short	segCnt;		/* ??? */
unsigned short	sCode,
		eCode;
	short	cCnt;
	long	ofsCmap;
	short	sizCmap;
	long	ofsFil;
	short	sizFil;
	long	ofsStbl;	/* search tbl*/
	short	sizStbl;
	long	ofsBdatSub;
	};

struct BDatSubTbl {
	long	tail;
	long	ptrOfs;
	long	head;
	short	filler2;
	/* Following Pointer tbl. */
	};
struct BMPHeader {
	long	bitmapSiz;
	short	xsiz, ysiz;
	};

#define		EUDCCODEBASE	((unsigned short)0xe000)


int  OpenW31JBMP(TCHAR  *path,int  omd);
int  CloseW31JBMP(void);
int  isW31JEUDCBMP(TCHAR  *path);
int  GetW31JBMPnRecs(int *nRec, int *nGlyph, int *xsiz, int *ysiz);
int  GetW31JBMPMeshSize( int *xsiz, int *ysiz);
static int  readcmap(void);
static int  rectocode(int  rec,unsigned short  *code);
static int  searchCode(unsigned short  code);
int  GetW31JBMP(unsigned short  code,LPBYTE buf,int  bufsiz,int  *xsiz,int  *ysiz);
int  GetW31JBMPRec(int  rec,LPBYTE buf,int  bufsiz,int  *xsiz,int  *ysiz,unsigned short  *code);
int  PutW31JBMPRec(int  rec,LPBYTE buf,int  xsiz,int  ysiz);
static int  ReadBMPHdr(HANDLE hdl,long  ofs,struct  BMPHeader *bhdr);
static int  WriteBMPHdr(HANDLE hdl,long  ofs,struct  BMPHeader *bhdr);

static int	init = 0;
static HANDLE	fHdl;
struct W31_Header hdr;
struct BDatSubTbl bdTbl;
static int	rwmode = 0;
static long	*ofstbl=0;
static unsigned short	*cmap=0;
static int	*recordTbl=0;
/***************************************************************
 *	Initialize
 */
/* */	int
/* */	OpenW31JBMP( TCHAR *path, int omd)
/*
 *	returns : 0, -1
 ***************************************************************/
{
	int	msiz;
	DWORD nByte;
	BOOL res;

	/* open EUDC Font File */
	rwmode = omd ? 1 : 0;
	fHdl = CreateFile(path,
					omd==0 ? GENERIC_READ : GENERIC_READ | GENERIC_WRITE,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fHdl == INVALID_HANDLE_VALUE)
		return -1;

	/* Read Header */
	res = ReadFile( fHdl, (LPBYTE)&hdr, sizeof(struct W31_Header), &nByte, NULL);
	if (!res || nByte !=sizeof(struct W31_Header))
		goto	ERET;

    //
    // WinSE #13986, 
    // In Win9x, character number could be well over 1880,
    // EUDC EUF file will be trashed if we limit character number to 1880
    //    
    /*
	if( hdr.cCnt > 1880)
		hdr.cCnt = 1880;
    */

	/* allocate ofs. tbl. */
	msiz = hdr.cCnt*sizeof(long);
	if ((ofstbl = (long *)malloc( msiz))==(long *)0)
		goto	ERET;

	/* Read Ofs. tbl.*/
	if ( (long) SetFilePointer( fHdl, hdr.ofsBdatSub, NULL, FILE_BEGIN)!=hdr.ofsBdatSub)
		goto	ERET;
	res = ReadFile( fHdl, (LPBYTE)&bdTbl, sizeof(bdTbl), &nByte, NULL);
	if (!res || nByte !=sizeof(bdTbl))
		goto	ERET;

	res = ReadFile( fHdl, (LPBYTE)ofstbl, (unsigned int)msiz, &nByte, NULL);
	if (!res || nByte !=(unsigned int)msiz)
		goto	ERET;

	init = 1;
/*	
  if (fHdl != INVALID_HANDLE_VALUE)
  {
    CloseHandle(fHdl);
    fHdl = INVALID_HANDLE_VALUE;
  }
*/
	return	0;
ERET:
	if (fHdl != INVALID_HANDLE_VALUE)
  {
		CloseHandle (fHdl);
    fHdl = INVALID_HANDLE_VALUE;
  }

	if (ofstbl)
  {
		free( ofstbl);
    ofstbl = 0;
  }
	return -1;
}
/***************************************************************
 *	Terminate Close
 */
/* */	int
/* */	CloseW31JBMP()
/*
 *	returns : none
 ***************************************************************/
{
	unsigned int	siz;
	DWORD nByte;
	BOOL res;

	if ( rwmode>=1) {
		/* update ofstbl*/
		if ((long) SetFilePointer( fHdl, hdr.ofsBdatSub, NULL, FILE_BEGIN)!=hdr.ofsBdatSub)
			goto	ERET;
		res = WriteFile( fHdl, (LPBYTE)&bdTbl, sizeof( bdTbl), &nByte, NULL);
		if (!res || nByte !=sizeof(bdTbl))
			goto	ERET;
		siz = (unsigned int)hdr.cCnt*sizeof(long);
		res = WriteFile( fHdl, (LPBYTE)ofstbl, siz, &nByte, NULL);
		if (!res || nByte !=siz)
			goto	ERET;
	}
	if ( fHdl !=INVALID_HANDLE_VALUE) {
		CloseHandle( fHdl);
		fHdl = INVALID_HANDLE_VALUE;
	}
	if ( ofstbl) {
		free(ofstbl);
		ofstbl = 0;
	}
	if ( cmap) {
		free(cmap);
		cmap = 0;
	}
	if ( recordTbl) {
		free(recordTbl);
		recordTbl = 0;
	}

	init = 0;
	return 0;
ERET:
	return -1;
}
/***************************************************************
 *	is Win3.1J EUDC bitmap
 */
/* */	int
/* */	isW31JEUDCBMP( TCHAR *path)
/*
 *	returns : 0 (other), 1 (EUDC bitmap), -1(error)
 ***************************************************************/
{
	HANDLE fhdl;
struct W31_Header hdr;
	DWORD nByte;
	BOOL res;

	fhdl = CreateFile(path,
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fhdl == INVALID_HANDLE_VALUE)
		return -1;
	res = ReadFile( fhdl, (LPBYTE)&hdr, sizeof(hdr), &nByte, NULL);
	if (!res || nByte !=sizeof(hdr))
		goto	NO_WIN31J;
	CloseHandle( fhdl);
  fhdl = INVALID_HANDLE_VALUE;

	/* compare idendify leading 16 byte, sCode, eCode and cCnt*/
	if (memcmp( hdr.identify, "WINEUDC2Standard", 16))
		goto	NO_WIN31J;
#if 0
	if ( hdr.sCode != 0x40f0 || hdr.eCode != 0xfcf9 || hdr.cCnt != 1880)
#endif
	if( hdr.sCode != 0x40f0)
		goto	NO_WIN31J;
	return 1;

NO_WIN31J:
  if (fhdl != INVALID_HANDLE_VALUE)
  {
    CloseHandle(fhdl);
    fhdl = INVALID_HANDLE_VALUE;
  }
	return 0;
}
/***************************************************************
 *	Get number of records
 */
/* */	int
/* */	GetW31JBMPnRecs( int *nRec, int *nGlyph, int *xsiz, int *ysiz)
/*
 *	returns : 0, -1
 ***************************************************************/
{
struct BMPHeader	fhdr;
	long	ofs;
	BOOL	bFirst;
	int	rec;
	int	gc;
	DWORD nByte;
	BOOL res;

	bFirst = FALSE;
	if ( init==0 || fHdl == INVALID_HANDLE_VALUE)
		return -1;
	else {
		gc = 0;
		for ( rec = 0; rec < (int)hdr.cCnt; rec++) {
			if( *(ofstbl+rec)){
				if( !bFirst){
					ofs = *(ofstbl+rec);
					ofs += hdr.ofsBdatSub;
					if ( (DWORD) SetFilePointer( fHdl,ofs, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
          {
            DWORD dwErr = GetLastError();
						goto	ERET;
          }

					res = ReadFile( fHdl, (LPBYTE)&fhdr,
					     sizeof(struct BMPHeader), &nByte, NULL);
					if (!res || nByte != sizeof( struct BMPHeader))
						goto	ERET;

					bFirst = TRUE;
				}
				gc++;
			}
		}
		*nRec = (int)hdr.cCnt;
		*nGlyph = gc;
		*xsiz = fhdr.xsiz;
		*ysiz = fhdr.ysiz;
		return 0;
	}
ERET:
	return( -1);
}
static int
readcmap()
{
	unsigned int	msiz;
	DWORD nByte;
	BOOL res;
	msiz = (unsigned int)hdr.cCnt*sizeof(unsigned short);
	if ((cmap = (unsigned short*)malloc(msiz))==(unsigned short *)0)
		goto	ERET;
	if ((long) SetFilePointer( fHdl, hdr.ofsCmap, NULL, FILE_BEGIN)!=hdr.ofsCmap)
		goto	ERET;
	res = ReadFile( fHdl, (LPBYTE)cmap, msiz, &nByte, NULL);
	if (!res || nByte !=msiz)
		goto	ERET;
	return 0;
ERET:
	return -1;
}
static int
rectocode( int rec, unsigned short *code)
{
	if ( cmap==0) {
		if (readcmap())
			return -1;
	}
	*code = *(cmap+rec);
	return 0;
}
static int
searchCode( unsigned short code)
{
	int	high, low, mid;

	if ( cmap==(unsigned short *)0) {
		if (readcmap())
			goto	ERET;
	}
	high = hdr.cCnt-1;
	low = 0;
	while ( high >= low) {
		mid = (high+low)/2;
		if ( *(cmap+mid)==code)
			return mid;
		else if ( *(cmap+mid)>code)
			high = mid-1;
		else
			low = mid+1;
	}
ERET:
	return -1;
}
/***************************************************************
 *	Read Bitmap by code number
 */
/* */	int
/* */	GetW31JBMP(
/* */		unsigned short	code,	/* code Number */
/* */		LPBYTE buf,	/* buffer to set bitmap */
/* */		int	bufsiz,	/* Buffer Size */
/* */		int	*xsiz,	/* Bitmap X,Ysiz */
/* */		int	*ysiz)
/*
 *	returns : >=0, -1
 ***************************************************************/
{
	int	rec;
	int	sts;
	unsigned short	rcode;
	/* search code */
	if ( (rec = searchCode( code)) <0)
		return -1;
	else {
		sts = GetW31JBMPRec( rec, buf, bufsiz, xsiz, ysiz, &rcode);
		return sts;
	}
}
/****************************************/
/*					*/
/*	Get W31JEUDC's Bmp Mesh Size	*/
/*					*/
/****************************************/
int
GetW31JBMPMeshSize(
int	*xsiz,
int	*ysiz)
{
	long	ofs;
struct BMPHeader	fhdr;
	int	bmpsiz;
	DWORD nByte;
	BOOL res;

	if (init==0)
		return -1;

	ofs = *(ofstbl);
	if ( ofs==0L)	
		return 0;
	ofs += hdr.ofsBdatSub;

	if ( (long) SetFilePointer(fHdl, ofs, NULL, FILE_BEGIN)!=ofs)
		goto	ERET;
	res = ReadFile( fHdl, (LPBYTE)&fhdr, sizeof(struct BMPHeader), &nByte, NULL);
	if (!res || nByte != sizeof( struct BMPHeader))
		goto	ERET;

	*xsiz = fhdr.xsiz;
	*ysiz = fhdr.ysiz;
	bmpsiz = ((int)fhdr.xsiz+15)/16 *2 * (int)fhdr.ysiz;

	return bmpsiz;
ERET:
	return (-1);
}
/***************************************************************
 *	Read Bitmap by record number
 */
/* */	int
/* */	GetW31JBMPRec(
/* */		int	rec,	/* Record Number */
/* */		LPBYTE buf,	/* buffer to set bitmap */
/* */		int	bufsiz,	/* Buffer Size */
/* */		int	*xsiz,	/* Bitmap X,Ysiz */
/* */		int	*ysiz,
/* */		unsigned short	*code)
/*
 *	returns : bitmapsiz >=0, -1
 ***************************************************************/
{
	long	ofs;
struct BMPHeader	fhdr;
	int	bmpsiz;
	int	rdsiz;
	DWORD nByte;
	BOOL res;

	if (init==0)
		return -1;

	ofs = *(ofstbl+rec);
	if ( ofs==0L)	
		return 0;
	ofs += hdr.ofsBdatSub;

	/* read Bitmap Header
		bitmap is Word aligned */
	if ( (long) SetFilePointer( fHdl, ofs, NULL, FILE_BEGIN)!=ofs)
		goto	ERET;
	res = ReadFile( fHdl, (LPBYTE)&fhdr, sizeof(struct BMPHeader), &nByte, NULL);
	if (!res || nByte != sizeof( struct BMPHeader))
		goto	ERET;

	bmpsiz = ((int)fhdr.xsiz+15)/16 *2 * (int)fhdr.ysiz;
	/* Read Bitmap Body */
	rdsiz = bmpsiz > bufsiz ? bufsiz : bmpsiz;
	if ( rdsiz > 0) {
		res = ReadFile( fHdl, buf, (unsigned int)rdsiz, &nByte, NULL);
		if (!res || nByte !=(unsigned int)rdsiz)
			goto	ERET;
	}
	*xsiz = fhdr.xsiz;
	*ysiz = fhdr.ysiz;
	if ( rectocode( rec, code))
		goto	ERET;
	return bmpsiz;
ERET:
	return -1;
}
/***************************************************************
 *	Write Bitmap by record number
 */
/* */	int
/* */	PutW31JBMPRec(
/* */		int	rec,	/* Record Number */
/* */		 LPBYTE buf,	/* buffer to set bitmap */
/* */		int	xsiz,	/* Bitmap X,Ysiz */
/* */		int	ysiz)
/*
 *	returns : 0, -1
 ***************************************************************/
{
	long	ofs;
struct BMPHeader	fhdr;
	int	bmpsiz;
	unsigned int	wbmpsiz;
	DWORD nByte;
	BOOL res;

	if (init==0)
		return -1;
	else if ( rwmode==0)
		return -1;
	rwmode = 2;
	wbmpsiz = (unsigned int) ((xsiz+15)/16 *2 * ysiz);
	ofs = *(ofstbl+rec);
	if ( ofs != 0L) {
		/* read Bitmap Header
			bitmap is Word aligned */
		if ( ReadBMPHdr( fHdl, ofs, &fhdr))
			goto	ERET;

		bmpsiz = ((int)fhdr.xsiz+15)/16 *2 * (int)fhdr.ysiz;
		if ( bmpsiz<(int)wbmpsiz)
			ofs = 0L;
	}
	if ( ofs == 0L)
		ofs = bdTbl.tail;

	/* Write Bitmap Header */
	fhdr.xsiz = (short)xsiz;
	fhdr.ysiz = (short)ysiz;
	fhdr.bitmapSiz = wbmpsiz+sizeof(fhdr);

	if ( WriteBMPHdr( fHdl, ofs, &fhdr))
		goto	ERET;

	/* Write Bitmap Body */
	res = WriteFile( fHdl, buf, wbmpsiz, &nByte, NULL);
	if (!res || nByte !=wbmpsiz)
		goto	ERET;

	/* write bitmap ptr on subTable */
	*(ofstbl+rec) = ofs;

	bdTbl.tail = ofs + wbmpsiz+sizeof(fhdr);

	return 0;
ERET:
	return -1;
}
static int
ReadBMPHdr( HANDLE hdl, long ofs, struct BMPHeader *bhdr)
{
	DWORD nByte;
	BOOL res;

	ofs += hdr.ofsBdatSub;
	if ( (long) SetFilePointer( hdl, ofs, NULL, FILE_BEGIN)!=ofs)
		goto	ERET;
	res = ReadFile( hdl, (LPBYTE) bhdr, sizeof( struct BMPHeader), &nByte, NULL);
	if (!res || nByte !=sizeof( struct BMPHeader))
		goto	ERET;
	return 0;
ERET:
	return -1;
}
static int
WriteBMPHdr( HANDLE hdl, long ofs, struct BMPHeader *bhdr)
{
	DWORD nByte;
	BOOL res;
	ofs += hdr.ofsBdatSub;
	if ( (long) SetFilePointer( hdl, ofs, NULL, FILE_BEGIN)!=ofs)
		goto	ERET;
	res = WriteFile(hdl, (LPBYTE )bhdr, sizeof( struct BMPHeader), &nByte, NULL);
	if (!res || nByte !=sizeof( struct BMPHeader))
		goto	ERET;
	return 0;
ERET:
	return -1;
}

int
W31JrecTbl( int **recTbl, BOOL bIsWin95EUDC)
{
	int	rec;
	int	*tp;
	unsigned short code;
	if ( cmap==0) {
		if (readcmap())
			return -1;
	}
	if ( (tp = (int *)malloc( sizeof(int)*hdr.cCnt))==(int *)0)
		return -1;
	for ( rec = 0; rec < hdr.cCnt; rec++) {
		if ( *(ofstbl + rec)!=0L) {

			code = *(cmap+rec);
			if (!bIsWin95EUDC)
				code = sjisToUniEUDC( code);
			tp[(int)(code - EUDCCODEBASE)] = rec;
		}
		else	
			tp[rec] = -1;
	}
	*recTbl = recordTbl = tp;

	return 0;
}
/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\eudcedit\w31jeudc.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
#ifdef BUILD_ON_WINNT
/*
 * To avoid multipule definition, this is already defined in w31jeudc.cpp
 */
#else
/*
 File Structure */

struct W31_Header {
	char	identify[72];
	short	segCnt;		/* ??? */
unsigned short	sCode,
		eCode;
	short	cCnt;
	long	ofsCmap;
	short	sizCmap;
	long	ofsFil;
	short	sizFil;
	long	ofsStbl;	/* search tbl*/
	short	sizStbl;
	long	ofsBdatSub;
	};

struct BDatSubTbl {
	long	tail;
	long	ptrOfs;
	long	head;
	short	filler2;
	/* Following Pointer tbl. */
	};
struct BMPHeader {
	long	bitmapSiz;
	short	xsiz, ysiz;
	};
#endif // BUILD_ON_WINNT

extern int OpenW31JEUDC( TCHAR *path);
extern void CloseW31JEUDC();
extern int  GetW31JEUDCFont(int  rec, LPBYTE buf,int  bufsiz,int  *xsiz,int  *ysiz);
extern int  PutW31JEUDCFont(int  rec, LPBYTE buf,int  xsiz,int  ysiz);
/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\cnctstd\cnctdrv.hh ===
/*	File: D:\WACKER\cnctstd\cnctdrv.hh (Created: 19-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:00p $
 */

typedef struct stCnctDrvPrivate *HHDRIVER;

/* --- Macros --- */

#define STATE_START 		100

#define STATE_DISCONNECT	200

/* --- Data structures --- */

struct stCnctDrvPrivate
	{
	HCNCT	 hCnct; 		// public connection handle passed to create func
	HSESSION hSession;		// public session handle passed to create func

	HANDLE	 hDiscnctEvent, // event semaphore for disconnects
			 hMatchEvent,	// signals a string match has occured
			 hThread;		// connection thread

	CRITICAL_SECTION cs;	// critical section semaphore

	int 	 iStatus,		// connection status
			 iState;		// current connection state

	unsigned uFlags;		// connection flags passed in

	DWORD	 dwTime;		// used for MultipleWaitForObjects()
	};

/* --- Function Prototypes --- */

HDRIVER WINAPI cnctdrvCreate(const HCNCT hCnct, const HSESSION hSession);
int WINAPI cnctdrvDestroy(const HHDRIVER hhDriver);
void cnctdrvLock(const HHDRIVER hhDriver);
void cnctdrvUnlock(const HHDRIVER hhDriver);
int WINAPI cnctdrvQueryStatus(const HHDRIVER hhDriver);
int WINAPI cnctdrvConnect(const HHDRIVER hhDriver, const unsigned int uFlags);
int WINAPI cnctdrvDisconnect(const HHDRIVER hhDriver, const unsigned int uFlags);
DWORD WINAPI ConnectLoop(const HHDRIVER hhDriver);
int WINAPI cnctdrvComEvent(const HHDRIVER hhDriver);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\cnctstd\cncts.c ===
/*	File: D:\WACKER\cnctstd\cncts.c (Created: 19-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:00p $
 */

#include <windows.h>

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\assert.h>
#include <tdll\cnct.h>
#include <tdll\com.h>
#include "cnctdrv.hh"

static BOOL ProcessEvent(const HHDRIVER hhDriver);
static void SetStatus(const HHDRIVER hhDriver, const int iStatus);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctdrvCnctLoop
 *
 * DESCRIPTION:
 *	This is the connection loop which runs as its own thread.  It waits
 *	for events such as a match or a request to disconnect and executes
 *	the request according to the current execution state.
 *
 * ARGUMENTS:
 *	hhDriver	- private connection driver handle
 *
 * RETURNS:
 *	0 or error code
 *
 */
DWORD WINAPI ConnectLoop(const HHDRIVER hhDriver)
	{
	DWORD dwEvent;
	HANDLE ahEvents[2];

	cnctdrvLock(hhDriver);

	/* --- Create event objects for matching and disconnect --- */

	ahEvents[0] = hhDriver->hDiscnctEvent = CreateEvent(0, FALSE, FALSE, 0);

	if (hhDriver->hDiscnctEvent == 0)
		{
		assert(FALSE);
		cnctdrvUnlock(hhDriver);
		return (DWORD)CNCT_ERROR;
		}

	ahEvents[1] = hhDriver->hMatchEvent = CreateEvent(0, FALSE, TRUE, 0);

	if (hhDriver->hMatchEvent == 0)
		{
		assert(FALSE);
		CloseHandle(hhDriver->hDiscnctEvent);
		cnctdrvUnlock(hhDriver);
		return (DWORD)CNCT_ERROR;
		}

	/* --- Main Connection Loop --- */

	hhDriver->dwTime = INFINITE;
	hhDriver->iState = STATE_START;

	for (;;)
		{
		cnctdrvUnlock(hhDriver);

		dwEvent = WaitForMultipleObjects(2, ahEvents, FALSE, hhDriver->dwTime);

		cnctdrvLock(hhDriver);

		switch (dwEvent)
			{
		case WAIT_OBJECT_0+0:
			hhDriver->iState = STATE_DISCONNECT;
			/* --------------------------------------- */
			/* --- Fall through to WAIT_OBJECT_0+1 --- */
			/* --------------------------------------- */

		case WAIT_OBJECT_0+1:
			if (ProcessEvent(hhDriver) == FALSE)
				goto EXIT_THREAD;

			break;

		case WAIT_TIMEOUT:
			// do a quick and dirty disconnect maybe
			assert(FALSE);
			goto EXIT_THREAD;

		case WAIT_ABANDONED_0 + 0:
		case WAIT_ABANDONED_0 + 1:
			// do a quick and dirty disconnect
			assert(FALSE);
			goto EXIT_THREAD;

		case WAIT_FAILED:
			// do a quick and dirty disconnect
			assert(FALSE);
			goto EXIT_THREAD;

		default:
			assert(FALSE);
			goto EXIT_THREAD;
			}
		}

	EXIT_THREAD:

	CloseHandle(hhDriver->hDiscnctEvent);
	hhDriver->hDiscnctEvent = 0;

	CloseHandle(hhDriver->hMatchEvent);
	hhDriver->hMatchEvent = 0;

	cnctdrvUnlock(hhDriver);
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	ProcessMatchEvent
 *
 * DESCRIPTION:
 *	Handles the match process.
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle
 *
 * RETURNS:
 *	BOOL
 *
 */
static BOOL ProcessEvent(const HHDRIVER hhDriver)
	{
	switch (hhDriver->iState)
		{
	case STATE_START:
		if (ComActivatePort(sessQueryComHdl(hhDriver->hSession)) != COM_OK)
			{
			assert(FALSE);
			return FALSE;
			}

		// For now we're doing direct connects only
		//
		SetStatus(hhDriver, CNCT_STATUS_TRUE);
		break;

	case STATE_DISCONNECT:
		if (hhDriver->iStatus == CNCT_STATUS_FALSE)
			break;

		SetStatus(hhDriver, CNCT_STATUS_FALSE);
		ComDeactivatePort(sessQueryComHdl(hhDriver->hSession));
		break;

	default:
		assert(FALSE);
		return FALSE;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	SetStatus
 *
 * DESCRIPTION:
 *	There's actually more to setting the connection status than just
 *	setting the status variable as the code below indicates.  Dumb
 *	question:  Why aren't there any locks in this code.  Dumb Answer:
 *	This function is only called from the ConnectLoop thread context
 *	which has already locked things down.
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle
 *	iStatus 	- new status
 *
 * RETURNS:
 *	void
 *
 */
static void SetStatus(const HHDRIVER hhDriver, const int iStatus)
	{
	/* --- Don't do things twice --- */

	if (iStatus == hhDriver->iStatus)
		return;

	/* --- Set the status, an exciting new adventure game --- */

	switch (iStatus)
		{
	case CNCT_STATUS_TRUE:
		hhDriver->iStatus = CNCT_STATUS_TRUE;
		NotifyClient(hhDriver->hSession, EVENT_CONNECTION_OPENED, 0);
		break;

	case CNCT_STATUS_CONNECTING:
		hhDriver->iStatus = CNCT_STATUS_CONNECTING;
		break;

	case CNCT_STATUS_DISCONNECTING:
		hhDriver->iStatus = CNCT_STATUS_DISCONNECTING;
		break;

	case CNCT_STATUS_FALSE:
		hhDriver->iStatus = CNCT_STATUS_FALSE;
		NotifyClient(hhDriver->hSession, EVENT_CONNECTION_CLOSED, 0);
		break;

	default:
		assert(FALSE);
		break;
		}

	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\cncttapi\cnctdrv.hh ===
/*	File: D:\WACKER\cncttapi\cnctdrv.hh (Created: 08-Feb-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:01p $
 */

THIS FILE NO LONGER USED!!!
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\cncttapi\cncttapi.h ===
/*	File: D:\WACKER\cncttapi\cncttapi.h (Created: 23-Feb-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 2/05/99 3:19p $
 */

/* --- Function Prototypes --- */

INT_PTR CALLBACK NewPhoneDlg(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\cnctstd\cnctdrvs.c ===
/*	File: D:\WACKER\cnctstd\cnctdrvs.c (Created: 19-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:00p $
 */

#include <windows.h>

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\mc.h>
#include <tdll\assert.h>
#include <tdll\cnct.h>

#include "cnctdrv.hh"

BOOL WINAPI cnctdrvEntry(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);
BOOL WINAPI _CRT_INIT(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctdrvEntry
 *
 * DESCRIPTION:
 *	Currently, just initializes the C-Runtime library but may be used
 *	for other things later.
 *
 * ARGUMENTS:
 *	hInstDll	- Instance of this DLL
 *	fdwReason	- Why this entry point is called
 *	lpReserved	- reserved
 *
 * RETURNS:
 *	BOOL
 *
 */
BOOL WINAPI cnctdrvEntry(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved)
	{
	return _CRT_INIT(hInstDll, fdwReason, lpReserved);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctdrvCreate
 *
 * DESCRIPTION:
 *	Initializes the connection driver and returns a handle to the driver
 *	if successful.
 *
 * ARGUMENTS:
 *	hCnct	- public connection handle
 *
 * RETURNS:
 *	Handle to driver if successful, else 0.
 *
 */
HDRIVER WINAPI cnctdrvCreate(const HCNCT hCnct, const HSESSION hSession)
	{
	HHDRIVER hhDriver;

	if (hCnct == 0)
		{
		assert(FALSE);
		return 0;
		}

	hhDriver = malloc(sizeof(*hhDriver));

	if (hhDriver == 0)
		{
		assert(FALSE);
		return 0;
		}

	memset(hhDriver, 0, sizeof(*hhDriver));
	hhDriver->hCnct = hCnct;
	hhDriver->hSession = hSession;
	hhDriver->iStatus = CNCT_STATUS_FALSE;

	InitializeCriticalSection(&hhDriver->cs);

	return (HDRIVER)hhDriver;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctdrvDestroy
 *
 * DESCRIPTION:
 *	Destroys a connection driver handle.
 *
 * ARGUMENTS:
 *	hhDriver - private driver handle.
 *
 * RETURNS:
 *	0 or error code
 *
 */
int WINAPI cnctdrvDestroy(const HHDRIVER hhDriver)
	{
	if (hhDriver == 0)
		{
		assert(FALSE);
		return CNCT_BAD_HANDLE;
		}

	// Disconnect if we're connected or in the process.
	// Note: cnctdrvDisconnect should terminate the thread.

	cnctdrvDisconnect(hhDriver, 0);

	/* --- Wait for connection loop thread to terminate --- */

	if (hhDriver->hThread)
		WaitForSingleObject(hhDriver->hThread, 10000);

	/* --- Free any allocated resources --- */

	if (hhDriver->hThread)
		CloseHandle(hhDriver->hThread);

	DeleteCriticalSection(&hhDriver->cs);
	free(hhDriver);
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctdrvLock
 *
 * DESCRIPTION:
 *	Locks the connection driver's critical section semaphore.
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle
 *
 * RETURNS:
 *	void
 *
 */
void cnctdrvLock(const HHDRIVER hhDriver)
	{
	EnterCriticalSection(&hhDriver->cs);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctdrvUnlock
 *
 * DESCRIPTION:
 *	Unlocks the connection driver's critical section semaphore.
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle
 *
 * RETURNS:
 *	void
 *
 */
void cnctdrvUnlock(const HHDRIVER hhDriver)
	{
	LeaveCriticalSection(&hhDriver->cs);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctdrvQueryStatus
 *
 * DESCRIPTION:
 *	Returns the current connection status as defined in <tdll\cnct.h>
 *
 * ARGUMENTS:
 *	hhDriver - private driver handle
 *
 * RETURNS:
 *	connection status or error code
 *
 */
int WINAPI cnctdrvQueryStatus(const HHDRIVER hhDriver)
	{
	int iStatus;

	if (hhDriver == 0)
		{
		assert(FALSE);
		return CNCT_BAD_HANDLE;
		}

	cnctdrvLock(hhDriver);
	iStatus = hhDriver->iStatus;   //* hard-code for now.
	cnctdrvUnlock(hhDriver);

	return iStatus;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctdrvConnect
 *
 * DESCRIPTION:
 *	Attempts to dial the modem.
 *
 * ARGUMENTS:
 *	hhDriver - private driver handle
 *	uFlags	 - connection flags
 *
 * RETURNS:
 *	0 or error
 *
 */
int WINAPI cnctdrvConnect(const HHDRIVER hhDriver, const unsigned int uFlags)
	{
	DWORD dwThreadId;

	if (hhDriver == 0)
		{
		assert(FALSE);
		return CNCT_BAD_HANDLE;
		}

	/* --- Check to see we're not already connected --- */

	if (cnctdrvQueryStatus(hhDriver) != CNCT_STATUS_FALSE)
		{
		assert(FALSE);
		return CNCT_ERROR;
		}

	cnctdrvLock(hhDriver);

	/* --- If we created a thread before, then close handle --- */

	if (hhDriver->hThread)
		CloseHandle(hhDriver->hThread);

	/* --- Create the connection loop ---*/

	hhDriver->hThread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)
		ConnectLoop, hhDriver, 0, &dwThreadId);

	if (hhDriver->hThread == 0)
		{
		assert(FALSE);
		cnctdrvUnlock(hhDriver);
		return CNCT_ERROR;
		}

	cnctdrvUnlock(hhDriver);
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctdrvDisconnect
 *
 * DESCRIPTION:
 *	Signals a disconnect
 *
 * ARGUMENTS:
 *	hhDriver - private driver handle
 *	uFlags	 - disconnect flags
 *
 * RETURNS:
 *	0 or error
 *
 */
int WINAPI cnctdrvDisconnect(const HHDRIVER hhDriver, const unsigned int uFlags)
	{
	if (hhDriver == 0)
		{
		assert(FALSE);
		return CNCT_BAD_HANDLE;
		}

	cnctdrvLock(hhDriver);

	if (hhDriver->hDiscnctEvent)
		SetEvent(hhDriver->hDiscnctEvent);

	cnctdrvUnlock(hhDriver);

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctdrvComEvent
 *
 * DESCRIPTION:
 *	Com routines call the this to notify connection routines that some
 *	significant event has happened (ie. carrier lost).	The connetion
 *	driver decides what it is interested in knowing however by
 *	querying the com drivers for the specific data.
 *
 * ARGUMENTS:
 *	hhDriver	- private connection driver handle
 *
 * RETURNS:
 *	0
 *
 */
int WINAPI cnctdrvComEvent(const HHDRIVER hhDriver)
	{
	if (hhDriver == 0)
		{
		assert(FALSE);
		return CNCT_BAD_HANDLE;
		}

	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\cncttapi\cncttapi.c ===
/*  File: D:\WACKER\cncttapi\cncttapi.c (Created: 08-Feb-1994)
 *
 *  Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *  All rights reserved
 *
 *      $Revision: 32 $
 *      $Date: 6/22/01 4:41p $
 */

#define TAPI_CURRENT_VERSION 0x00010004     // cab:11/14/96 - required!

#include <tapi.h>
#include <unimodem.h>
#pragma hdrstop

//#define DEBUGSTR

#include <time.h>

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\statusbr.h>
#include <tdll\tdll.h>
#include <tdll\misc.h>
#include <tdll\mc.h>
#include <tdll\assert.h>
#include <tdll\errorbox.h>
#include <tdll\cnct.h>
#include <tdll\globals.h>
#include <tdll\sf.h>
#include <tdll\sess_ids.h>
#include <tdll\com.h>
#include <tdll\comdev.h>
#include <tdll\com.hh>
#include <tdll\htchar.h>
#include <tdll\cloop.h>
#include <tdll\open_msc.h>
#include <emu\emu.h>
#include <term\res.h>
#include "cncttapi.h"
#include "cncttapi.hh"
#include <tdll\XFER_MSC.HH>     // XD_TYPE
#include <tdll\XFER_MSC.H>      // xfrGetDisplayWindow(), xfrDoTransfer()
#include "tdll\XFDSPDLG.H"      // XFR_SHUTDOWN

static int DoNewModemWizard(HWND hWnd, int iTimeout);
static int tapiReinit(const HHDRIVER hhDriver);
static int tapiReinitMessage(const HHDRIVER hhDriver);
static int DoDelayedCall(const HHDRIVER hhDriver);

const TCHAR *g_achApp = TEXT("HyperTerminal");

static HHDRIVER gbl_hhDriver;	// see LINEDEVSTATE for explaination.

#if 0
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  cnctdrvEntry
 *
 * DESCRIPTION:
 *  Currently, just initializes the C-Runtime library but may be used
 *  for other things later.
 *
 * ARGUMENTS:
 *  hInstDll    - Instance of this DLL
 *  fdwReason   - Why this entry point is called
 *  lpReserved  - reserved
 *
 * RETURNS:
 *  BOOL
 *
 */
BOOL WINAPI cnctdrvEntry(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved)
	{
	hInstance = hInstDll;
	return _CRT_INIT(hInstDll, fdwReason, lpReserved);
	}
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  cnctdrvCreate
 *
 * DESCRIPTION:
 *  Initializes the connection driver and returns a handle to the driver
 *  if successful.
 *
 * ARGUMENTS:
 *  hCnct   - public connection handle
 *
 * RETURNS:
 *  Handle to driver if successful, else 0.
 *
 */
HDRIVER WINAPI cnctdrvCreate(const HCNCT hCnct, const HSESSION hSession)
	{
	HHDRIVER hhDriver;

	if (hCnct == 0)
		{
		assert(FALSE);
		return 0;
		}

	hhDriver = malloc(sizeof(*hhDriver));

	if (hhDriver == 0)
		{
		assert(FALSE);
		return 0;
		}

	gbl_hhDriver = hhDriver;
	memset(hhDriver, 0, sizeof(*hhDriver));

	InitializeCriticalSection(&hhDriver->cs);

	hhDriver->hCnct = hCnct;
	hhDriver->hSession = hSession;
	hhDriver->iStatus  = CNCT_STATUS_FALSE;
	hhDriver->dwLine   = (DWORD)-1;

	cnctdrvInit(hhDriver);
	return (HDRIVER)hhDriver;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  cnctdrvDestroy
 *
 * DESCRIPTION:
 *  Destroys a connection driver handle.
 *
 * ARGUMENTS:
 *  hhDriver - private driver handle.
 *
 * RETURNS:
 *  0 or error code
 *
 */
int WINAPI cnctdrvDestroy(const HHDRIVER hhDriver)
	{
	if (hhDriver == 0)
		{
		assert(FALSE);
		return CNCT_BAD_HANDLE;
		}

	// Disconnect if we're connected or in the process.
	// Note: cnctdrvDisconnect should terminate the thread.

	cnctdrvDisconnect(hhDriver, DISCNCT_NOBEEP);

	if (hhDriver->hLine)
		{
		lineClose(hhDriver->hLine);
		hhDriver->hLine = 0;
		}

	if (hhDriver->hLineApp)
		{
		lineShutdown(hhDriver->hLineApp);
		hhDriver->hLineApp = 0;
		}

	if (IsWindow(hhDriver->hwndCnctDlg))
		EndModelessDialog(hhDriver->hwndCnctDlg);

	if (IsWindow(hhDriver->hwndStupid))
		DestroyWindow(hhDriver->hwndStupid);

	/* --- Cleanup --- */

	DeleteCriticalSection(&hhDriver->cs);
	free(hhDriver);
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  cnctdrvLock
 *
 * DESCRIPTION:
 *  Locks the connection driver's critical section semaphore.
 *
 * ARGUMENTS:
 *  hhDriver    - private driver handle
 *
 * RETURNS:
 *  void
 *
 */
void cnctdrvLock(const HHDRIVER hhDriver)
	{
	EnterCriticalSection(&hhDriver->cs);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  cnctdrvUnlock
 *
 * DESCRIPTION:
 *  Unlocks the connection driver's critical section semaphore.
 *
 * ARGUMENTS:
 *  hhDriver    - private driver handle
 *
 * RETURNS:
 *  void
 *
 */
void cnctdrvUnlock(const HHDRIVER hhDriver)
	{
	LeaveCriticalSection(&hhDriver->cs);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctdrvInit
 *
 * DESCRIPTION:
 *	Initializes the connection handle.	Can be called to reinitialize
 *	the handle.  Does an implicit disconnect.
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle
 *
 * RETURNS:
 *	0
 *
 */
int WINAPI cnctdrvInit(const HHDRIVER hhDriver)
	{
	long  lRet;
	int   id = 0;
	TCHAR ach[256];
    TCHAR achMessage[256];
    int   iReturn = 0;

	// Make sure we're disconnected.
	//
	cnctdrvDisconnect(hhDriver, DISCNCT_NOBEEP);

   	// ----------------------------------------------------------------
	// Need to shut down hLineApp and reinitialize everytime we read
	// new data file so that TAPI starts out in a clean and initialized
	// state.  Otherwise, we might inherit values from the previous
	// session.
	// ----------------------------------------------------------------
	if (hhDriver->hLineApp)
		{
		if (lineShutdown(hhDriver->hLineApp) != 0)
			{
			assert(FALSE);
			hhDriver->hLineApp = 0;
			return -2;
			}
		}

	hhDriver->hLineApp = 0;

	// Try to get a new LineApp handle now.
	//
	if ((lRet = lineInitialize(&hhDriver->hLineApp, glblQueryDllHinst(),
			lineCallbackFunc, g_achApp, &hhDriver->dwLineCnt)) != 0)
		{
        iReturn = -3;
		switch (lRet)
			{
		case LINEERR_INIFILECORRUPT:
			id = IDS_ER_TAPI_INIFILE;
			break;

		case LINEERR_NODRIVER:
			id = IDS_ER_TAPI_NODRIVER;
			break;

		case LINEERR_NOMULTIPLEINSTANCE:
			id = IDS_ER_TAPI_NOMULTI;
			break;

#if 0   // rev:08/05/99 We are now printing the lineInitialize() error.
        // rev:08/26/98 We need to make sure there was no error reported.
        //
        case LINEERR_INVALAPPNAME:
        case LINEERR_OPERATIONFAILED:
        case LINEERR_RESOURCEUNAVAIL:
        case LINEERR_INVALPOINTER:
        case LINEERR_REINIT:
        case LINEERR_NODEVICE:
        case LINEERR_NOMEM:
            id = IDS_ER_CNCT_TAPIFAILED;
            break;
#endif

        case LINEERR_OPERATIONUNAVAIL:
            //rev: 08-05-99 If TAPI has not been installed, then return a
            //              unique error code (since it will be handled
            //              differently than other TAPI errors).
            //
            iReturn = -4;

            // Run the new Modem wizard if we have not prompted before.
            //
            DoNewModemWizard(sessQueryHwnd(hhDriver->hSession),
                             sessQueryTimeout(hhDriver->hSession));
            break;

        default:
			id = IDS_ER_TAPI_UNKNOWN;
			break;
			}

		if ( id )
			{
			LoadString(glblQueryDllHinst(), id, ach, sizeof(ach) / sizeof(TCHAR));
            if (id == IDS_ER_TAPI_UNKNOWN)
                {
                wsprintf(achMessage, ach, lRet);
                }
            else
                {
                lstrcpy(achMessage, ach);
                }

			TimedMessageBox(sessQueryHwnd(hhDriver->hSession), achMessage, 0,
				MB_OK | MB_ICONSTOP, sessQueryTimeout(hhDriver->hSession));
			}
        return iReturn;
		}

	hhDriver->iStatus			= CNCT_STATUS_FALSE;
	hhDriver->dwLine			= (DWORD)-1;
	hhDriver->dwCountryID		= (DWORD)-1;
	hhDriver->dwPermanentLineId = (DWORD)-1;
	hhDriver->achDest[0]		= TEXT('\0');
	hhDriver->achAreaCode[0]	= TEXT('\0');
	hhDriver->achLineName[0]	= TEXT('\0');
	hhDriver->fUseCCAC			= TRUE;

	/* --- This guy will set defaults --- */

	EnumerateTapiLocations(hhDriver, 0, 0);
	
#if defined(INCL_WINSOCK)
	hhDriver->iPort = 23;
	hhDriver->achDestAddr[0] = TEXT('\0');
#endif

#ifdef INCL_CALL_ANSWERING	
    hhDriver->fAnswering = FALSE;
    hhDriver->fRestoreSettings = FALSE;
    hhDriver->nSendCRLF = 0;
    hhDriver->nLocalEcho = 0;
    hhDriver->nAddLF = 0;
    hhDriver->nEchoplex = 0;
    hhDriver->pvUnregister = 0;
#endif

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctdrvLoad
 *
 * DESCRIPTION:
 *  Reads the session file to get stuff connection driver needs.
 *
 * ARGUMENTS:
 *  hhDriver    - private driver handle
 *
 * RETURNS:
 *  0=OK, else error
 *
 */
int WINAPI cnctdrvLoad(const HHDRIVER hhDriver)
	{
    LPVARSTRING pvs;
	unsigned long ul;
	const SF_HANDLE sfhdl = sessQuerySysFileHdl(hhDriver->hSession);

	hhDriver->dwCountryID = (DWORD)-1;
	ul = sizeof(hhDriver->dwCountryID);
	sfGetSessionItem(sfhdl, SFID_CNCT_CC, &ul, &hhDriver->dwCountryID);

	hhDriver->achAreaCode[0] = TEXT('\0');
	ul = sizeof(hhDriver->achAreaCode);
	sfGetSessionItem(sfhdl, SFID_CNCT_AREA, &ul, hhDriver->achAreaCode);

	hhDriver->achDest[0] = TEXT('\0');
	ul = sizeof(hhDriver->achDest);
	sfGetSessionItem(sfhdl, SFID_CNCT_DEST, &ul, hhDriver->achDest);

	hhDriver->dwPermanentLineId = 0;
	ul = sizeof(hhDriver->dwPermanentLineId);
	sfGetSessionItem(sfhdl, SFID_CNCT_LINE, &ul, &hhDriver->dwPermanentLineId);

	hhDriver->fUseCCAC = 1;
	ul = sizeof(hhDriver->fUseCCAC);
	sfGetSessionItem(sfhdl, SFID_CNCT_USECCAC, &ul, &hhDriver->fUseCCAC);

    hhDriver->fRedialOnBusy = 1;
    ul = sizeof(hhDriver->fRedialOnBusy);
    sfGetSessionItem(sfhdl, SFID_CNCT_REDIAL, &ul, &hhDriver->fRedialOnBusy);

#if defined (INCL_WINSOCK)
	hhDriver->iPort = 23;
    ul = sizeof(hhDriver->iPort);
    sfGetSessionItem(sfhdl, SFID_CNCT_IPPORT, &ul, &hhDriver->iPort);

	hhDriver->achDestAddr[0] = TEXT('\0');
	ul = sizeof(hhDriver->achDestAddr);
	sfGetSessionItem(sfhdl, SFID_CNCT_IPDEST, &ul, hhDriver->achDestAddr);
#endif


	if ( IsNT() )
		{
		hhDriver->achComDeviceName[0] = TEXT('\0');
		ul = sizeof(hhDriver->achComDeviceName);
		sfGetSessionItem(sfhdl, SFID_CNCT_COMDEVICE, &ul, hhDriver->achComDeviceName);
		}

   	// ----------------------------------------------------------------
	// Need to shut down hLineApp and reinitialize everytime we read
	// new data file so that TAPI starts out in a clean and initialized
	// state.  Otherwise, we might inherit values from the previous
	// session.
	// ----------------------------------------------------------------

	if (hhDriver->hLineApp)
		{
		if (lineShutdown(hhDriver->hLineApp) != 0)
			{
			assert(FALSE);
			hhDriver->hLineApp = 0;
			return -2;
			}

		hhDriver->hLineApp = 0;

		if (lineInitialize(&hhDriver->hLineApp, glblQueryDllHinst(),
				lineCallbackFunc, g_achApp, &hhDriver->dwLineCnt))
			{
			assert(FALSE);
			return -3;
			}
		}

	// EnumerateLines() will set the hhDriver->fMatchedPermanentLineID
	// guy if it finds a match for our saved dwPermanentLineId guy
	//
	if ( IsNT() )
		{
		EnumerateLinesNT(hhDriver, 0);
		}
	else
		{
		EnumerateLines(hhDriver, 0);
		}
	
	/* --- If we saved a tapi configuration, restore it. --- */

	if (sfGetSessionItem(sfhdl, SFID_CNCT_TAPICONFIG, &ul, 0) != 0)
		return 0; // Ok, might not be there.

	if ((pvs = malloc(ul)) == 0)
		{
		assert(FALSE);
		return -4;
		}

	if (sfGetSessionItem(sfhdl, SFID_CNCT_TAPICONFIG, &ul, pvs) == 0)
		{
		if (hhDriver->fMatchedPermanentLineID)
			{
			LPVOID pv = (BYTE *)pvs + pvs->dwStringOffset;

			if (lineSetDevConfig(hhDriver->dwLine, pv,
			        pvs->dwStringSize, DEVCLASS) != 0)
				{
                // This error prevented a user from even opening a session
                // file if the file contained TAPI info and the user had
                // never installed a modem. We modified the error that appears
                // when you actually try to USE a non-existant modem so that
                // we could suppress the display of this error  jkh 8/3/98
#if 0
                TCHAR ach[FNAME_LEN];

                LoadString(glblQueryDllHinst(), IDS_OPEN_FAILED, ach,
				    sizeof(ach) / sizeof(TCHAR));

				TimedMessageBox(sessQueryHwnd(hhDriver->hSession), ach, 0,
					MB_OK | MB_ICONINFORMATION,
					sessQueryTimeout(hhDriver->hSession));

                                free(pvs);
                                pvs = NULL;
                                return -5;
#endif
                                }
			}
		}

        free(pvs);
        pvs = NULL;
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  cnctdrvSave
 *
 * DESCRIPTION:
 *  Saves connection settings to the session file
 *
 * ARGUMENTS:
 *  hhDriver    - private driver handle
 *
 * RETURNS:
 *  0=OK, else error
 *
 */
int WINAPI cnctdrvSave(const HHDRIVER hhDriver)
	{
	DWORD dwSize;
	unsigned long ul;
	LPVARSTRING pvs = NULL;
	const SF_HANDLE sfhdl = sessQuerySysFileHdl(hhDriver->hSession);

	sfPutSessionItem(sfhdl, SFID_CNCT_CC, sizeof(hhDriver->dwCountryID),
		&hhDriver->dwCountryID);

	sfPutSessionItem(sfhdl, SFID_CNCT_AREA,
		(lstrlen(hhDriver->achAreaCode) + 1) * sizeof(TCHAR),
			hhDriver->achAreaCode);

	sfPutSessionItem(sfhdl, SFID_CNCT_DEST,
		(lstrlen(hhDriver->achDest) + 1) * sizeof(TCHAR), hhDriver->achDest);

	sfPutSessionItem(sfhdl, SFID_CNCT_LINE, sizeof(hhDriver->dwPermanentLineId),
		&hhDriver->dwPermanentLineId);

	sfPutSessionItem(sfhdl, SFID_CNCT_USECCAC, sizeof(hhDriver->fUseCCAC),
		&hhDriver->fUseCCAC);

	sfPutSessionItem(sfhdl, SFID_CNCT_REDIAL, sizeof(hhDriver->fRedialOnBusy),
		&hhDriver->fRedialOnBusy);

#if defined (INCL_WINSOCK)
	sfPutSessionItem(sfhdl, SFID_CNCT_IPPORT, sizeof(hhDriver->iPort),
		&hhDriver->iPort);

	sfPutSessionItem(sfhdl, SFID_CNCT_IPDEST,
		(lstrlen(hhDriver->achDestAddr) + 1) * sizeof(TCHAR),
			hhDriver->achDestAddr);
#endif

	/* --- Usual 100 lines of code to use TAPI --- */

	if (hhDriver->hLineApp && hhDriver->dwLine != (DWORD)-1 &&
			!IN_RANGE(hhDriver->dwPermanentLineId, DIRECT_COM1, DIRECT_COM4) &&
            hhDriver->dwPermanentLineId != DIRECT_COM_DEVICE &&
            hhDriver->dwPermanentLineId != DIRECT_COMWINSOCK)
		{
		if ((pvs = malloc(sizeof(VARSTRING))) == 0)
			{
			assert(FALSE);
			return 0;
			}
		
		memset( pvs, 0, sizeof(VARSTRING) );
		pvs->dwTotalSize = sizeof(VARSTRING);

		if (lineGetDevConfig(hhDriver->dwLine, pvs, DEVCLASS) != 0)
			{
			assert(FALSE);
            free(pvs);
            pvs = NULL;
			return 0;
			}

		if (pvs->dwNeededSize > pvs->dwTotalSize)
			{
			dwSize = pvs->dwNeededSize;
			free(pvs);
                        pvs = NULL;

			if ((pvs = malloc(dwSize)) == 0)
				{
				assert(FALSE);
				return 0;
				}

			memset( pvs, 0, dwSize );
			pvs->dwTotalSize = dwSize;

			if (lineGetDevConfig(hhDriver->dwLine, pvs, DEVCLASS) != 0)
				{
				assert(FALSE);
                free(pvs);
                pvs = NULL;
				return 0;
				}
			}

		/* --- Store the whole structure --- */

		ul = pvs->dwTotalSize;
		sfPutSessionItem(sfhdl, SFID_CNCT_TAPICONFIG, ul, pvs);
                free(pvs);
                pvs = NULL;
		}

	if ( IsNT() )
		{
		if (hhDriver->dwPermanentLineId == DIRECT_COM_DEVICE)
			{
			ul = sizeof(hhDriver->achComDeviceName);

			sfPutSessionItem(sfhdl, SFID_CNCT_COMDEVICE, ul,
				hhDriver->achComDeviceName);
			}
		}


	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  cnctdrvQueryStatus
 *
 * DESCRIPTION:
 *  Returns the current connection status as defined in <tdll\cnct.h>
 *
 * ARGUMENTS:
 *  hhDriver - private driver handle
 *
 * RETURNS:
 *  connection status or error code
 *
 */
int WINAPI cnctdrvQueryStatus(const HHDRIVER hhDriver)
	{
	int iStatus;

	if (hhDriver == 0)
		{
		assert(FALSE);
		return CNCT_BAD_HANDLE;
		}

	cnctdrvLock(hhDriver);
	iStatus = hhDriver->iStatus;   //* hard-code for now.
	cnctdrvUnlock(hhDriver);

	return iStatus;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  SetStatus
 *
 * DESCRIPTION:
 *  There's actually more to setting the connection status than just
 *  setting the status variable as the code below indicates.  Dumb
 *  question:  Why aren't there any locks in this code.  Dumb Answer:
 *  This function is only called from the ConnectLoop thread context
 *  which has already locked things down.
 *
 * ARGUMENTS:
 *  hhDriver    - private driver handle
 *  iStatus     - new status
 *
 * RETURNS:
 *  void
 *
 */
void SetStatus(const HHDRIVER hhDriver, const int iStatus)
	{
	HCLOOP	hCLoop;
	/* --- Don't do things twice --- */

	const HWND hwndToolbar = sessQueryHwndToolbar(hhDriver->hSession);

	cnctdrvLock(hhDriver);

	if (iStatus == hhDriver->iStatus)
		{
		if (iStatus == CNCT_STATUS_TRUE || iStatus == CNCT_STATUS_FALSE)
			{
			hCLoop = sessQueryCLoopHdl(hhDriver->hSession);
			if (hCLoop)
				CLoopSndControl(hCLoop, CLOOP_RESUME, CLOOP_SB_CNCTDRV);
            }

		cnctdrvUnlock(hhDriver);
		return;
		}

	/* --- Set the status, an exciting new adventure game --- */

	switch (iStatus)
		{
	case CNCT_STATUS_TRUE:
            hCLoop = sessQueryCLoopHdl(hhDriver->hSession);
          #ifdef INCL_CALL_ANSWERING
            // If we are going from answering to connected, that means
            // we have answered a call. So tweak the ASCII settings so
            // that they make chatting possible. - cab:11/20/96
            //
            if (hhDriver->fAnswering)
                {
                // Store old ASCII settings, and set the new ones.
                //
                hhDriver->nSendCRLF = CLoopGetSendCRLF(hCLoop);
                hhDriver->nLocalEcho = CLoopGetLocalEcho(hCLoop);
                hhDriver->nAddLF = CLoopGetAddLF(hCLoop);
                hhDriver->nEchoplex = CLoopGetEchoplex(hCLoop);

                CLoopSetSendCRLF(hCLoop, TRUE);
                CLoopSetLocalEcho(hCLoop, TRUE);
                CLoopSetAddLF(hCLoop, TRUE);
                CLoopSetEchoplex(hCLoop, TRUE);

                hhDriver->fRestoreSettings = TRUE;
                }
          #endif
            hhDriver->iStatus = CNCT_STATUS_TRUE;
            assert(hCLoop);
            if (hCLoop)
                {
                CLoopRcvControl(hCLoop, CLOOP_RESUME, CLOOP_RB_CNCTDRV);
                CLoopSndControl(hCLoop, CLOOP_RESUME, CLOOP_SB_CNCTDRV);
                }

            NotifyClient(hhDriver->hSession, EVENT_CONNECTION_OPENED, 0);
            sessBeeper(hhDriver->hSession);
			ToolbarEnableButton(hwndToolbar, IDM_ACTIONS_DIAL, FALSE);
			ToolbarEnableButton(hwndToolbar, IDM_ACTIONS_HANGUP, TRUE);
            break;

	case CNCT_STATUS_CONNECTING:
            hhDriver->iStatus = CNCT_STATUS_CONNECTING;
            DialingMessage(hhDriver, IDS_DIAL_OFFERING); // temp
            NotifyClient(hhDriver->hSession, EVENT_CONNECTION_INPROGRESS, 0);
            EnableDialNow(hhDriver->hwndCnctDlg, FALSE);
			ToolbarEnableButton(hwndToolbar, IDM_ACTIONS_DIAL, FALSE);
			ToolbarEnableButton(hwndToolbar, IDM_ACTIONS_HANGUP, TRUE);
            break;

	case CNCT_STATUS_DISCONNECTING:
            hhDriver->iStatus = CNCT_STATUS_DISCONNECTING;
			ToolbarEnableButton(hwndToolbar, IDM_ACTIONS_DIAL, FALSE);
			ToolbarEnableButton(hwndToolbar, IDM_ACTIONS_HANGUP, FALSE);
            break;

	case CNCT_STATUS_FALSE:
		hCLoop = sessQueryCLoopHdl(hhDriver->hSession);
          #ifdef INCL_CALL_ANSWERING
            // Since this is called when we disconnect we need to restore
            // any ASCII Settings here. - cab:11/20/96
            //
            if ( hhDriver->fRestoreSettings && hCLoop ) //mpt: so that we don't reference a null pointer
                {
                CLoopSetSendCRLF(hCLoop, hhDriver->nSendCRLF);
                CLoopSetLocalEcho(hCLoop, hhDriver->nLocalEcho);
                CLoopSetAddLF(hCLoop, hhDriver->nAddLF);
                CLoopSetEchoplex(hCLoop, hhDriver->nEchoplex);
                hhDriver->fRestoreSettings = FALSE;
                }
            hhDriver->fAnswering = FALSE;
          #endif
            hhDriver->iStatus = CNCT_STATUS_FALSE;
            if (hCLoop)
                {
                CLoopRcvControl(hCLoop, CLOOP_RESUME, CLOOP_RB_CNCTDRV);
                CLoopSndControl(hCLoop, CLOOP_RESUME, CLOOP_SB_CNCTDRV);
                }
            NotifyClient(hhDriver->hSession, EVENT_CONNECTION_CLOSED, 0);
            EnableDialNow(hhDriver->hwndCnctDlg, TRUE);
			ToolbarEnableButton(hwndToolbar, IDM_ACTIONS_DIAL, TRUE);
			ToolbarEnableButton(hwndToolbar, IDM_ACTIONS_HANGUP, FALSE);
            break;

        case CNCT_STATUS_ANSWERING:
          #ifdef INCL_CALL_ANSWERING
            hhDriver->fAnswering = TRUE;
            hhDriver->iStatus = CNCT_STATUS_ANSWERING;
            NotifyClient(hhDriver->hSession, EVENT_CONNECTION_INPROGRESS, 0);
			ToolbarEnableButton(hwndToolbar, IDM_ACTIONS_DIAL, FALSE);
			ToolbarEnableButton(hwndToolbar, IDM_ACTIONS_HANGUP, TRUE);
          #endif
            break;

	default:
		assert(FALSE);
		break;
		}

	cnctdrvUnlock(hhDriver);

	/* --- Notify status bar so it can update it's display --- */

	PostMessage(sessQueryHwndStatusbar(hhDriver->hSession), SBR_NTFY_REFRESH,
		(WPARAM)SBR_CNCT_PART_NO, 0);

	return;
	}

#ifdef INCL_CALL_ANSWERING
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  WaitForCRcallback
 *
 * DESCRIPTION:
 *  This function gets registered as a callback with the cloop.  Every
 *  character that the cloop gets, is passed back to this function.  When
 *  this function finds a CR, it indicates that a connection has been
 *  established.  Note that this applies only to an answer mode connection,
 *  in the direct connect driver.
 *
 * ARGUMENTS:
 *  ECHAR   ech  -   The character returned from cloop.
 *  void    *p   -   A void pointer passed back from cloop.  This is
 *                   the enternal connection driver handle.
 *
 * RETURNS:
 *  CLOOP_DISCARD unless the character is a CR where is returns CLOOP_KEEP.
 *
 * AUTHOR: C. Baumgartner, 11/20/96 (ported from HAWin32)
 */
int WaitForCRcallback(ECHAR ech, void *p)
    {
    int   iRet = CLOOP_DISCARD; // Discard all characters except the CR.
    TCHAR chC = (TCHAR) ech;
    const HHDRIVER hhDriver = (HHDRIVER)p;

    if (chC == TEXT('\r'))
        {
        CLoopUnregisterRmtInputChain(hhDriver->pvUnregister);
        hhDriver->pvUnregister = 0;

        // Okay, we are connected now.
        //
        SetStatus(hhDriver, CNCT_STATUS_TRUE);

        iRet = CLOOP_KEEP;
        }

    return iRet;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  WaitForCRinit
 *
 * DESCRIPTION:
 *  This function is called to register a new string match function
 *  with the cloop.  It unregisters a previously registered function
 *  if necessary. It basically will cause us to wait for a carriage
 *  return.
 *
 * ARGUMENTS:
 *  HHDRIVER    hhDriver    -   The internal connection handle.
 *
 * RETURNS:
 *  0 if successful, otherwise -1.
 *
 * AUTHOR: C. Baumgartner, 11/20/96 (ported from HAWin32)
 */
static int WaitForCRinit(const HHDRIVER hhDriver)
    {
    const HCLOOP hCLoop = sessQueryCLoopHdl(hhDriver->hSession);

    if (!hCLoop)
        {
        return -1;
        }

    // If we are already registered, unregister.
    //
    if (hhDriver->pvUnregister != 0)
        {
        CLoopUnregisterRmtInputChain(hhDriver->pvUnregister);
        hhDriver->pvUnregister = 0;
        }

    // We need to un-block CLoop so we can look at the
    // characters as they come in.
    //
	CLoopRcvControl(hCLoop, CLOOP_RESUME, CLOOP_RB_CNCTDRV);

    // Register the match function with the cloop.
    //
    hhDriver->pvUnregister = CLoopRegisterRmtInputChain(hCLoop,
        WaitForCRcallback, hhDriver);

    if (hhDriver->pvUnregister == 0)
        {
        return -1;
        }

    return 0;
    }
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  cnctdrvComEvent
 *
 * DESCRIPTION:
 *  Com routines call the this to notify connection routines that some
 *  significant event has happened (ie. carrier lost).  The connetion
 *  driver decides what it is interested in knowing however by
 *  querying the com drivers for the specific data.
 *
 * ARGUMENTS:
 *  hhDriver - private connection driver handle
 *  event    - the com event we are being notified of
 *
 * RETURNS:
 *  0
 *
 */
int WINAPI cnctdrvComEvent(const HHDRIVER hhDriver, const enum COM_EVENTS event)
	{
	int		iRet;
	TCHAR 	ach[80];
#if defined(INCL_WINSOCK)
	char	achMsg[512];
#endif
	HCOM	hCom;

	if (hhDriver == 0)
		{
		assert(FALSE);
		return CNCT_BAD_HANDLE;
		}

    if (event == CONNECT)
        {
#if defined (INCL_WINSOCK)
	    // If we are connected via Winsock, there will be some ComEvents
	    // that we have to handle
	    if (hhDriver->dwPermanentLineId == DIRECT_COMWINSOCK)
		    {
		    hCom = sessQueryComHdl(hhDriver->hSession);
		    iRet = ComDriverSpecial(hCom, "Query ISCONNECTED", ach, sizeof(ach) / sizeof(TCHAR));

		    if (iRet == COM_OK)
			    {
			    // Do we want to initiate a disconnect?  Only if we're
			    // connected.
			    if (ach[0] == '0')
				    {

				    if (hhDriver->iStatus == CNCT_STATUS_TRUE)
					    {
                        // If we are already connected, then beep when
                        // we disconnect. - cab:12/06/96
                        //
						//mpt:10-28-97 added exit upon disconnect feature
						cnctdrvDisconnect(hhDriver,
							sessQueryExit(hhDriver->hSession) ? DISCNCT_EXIT : 0 );
					    }
				    else if (hhDriver->iStatus == CNCT_STATUS_CONNECTING)
					    {
					    cnctdrvDisconnect(hhDriver, DISCNCT_NOBEEP);

					    LoadString(glblQueryDllHinst(), IDS_ER_TCPIP_BADADDR,
						    ach, sizeof(ach) / sizeof(TCHAR));
					    wsprintf(achMsg, ach, hhDriver->achDestAddr,
                            hhDriver->iPort);
					    TimedMessageBox(sessQueryHwnd(hhDriver->hSession),
                            achMsg, 0, MB_OK | MB_ICONINFORMATION,
						    sessQueryTimeout(hhDriver->hSession));
					    }
				    }
			    else if (ach[0] == '1')
				    {
				    SetStatus(hhDriver, CNCT_STATUS_TRUE);
				    }
			    }

		    }
#endif
        if (IN_RANGE(hhDriver->dwPermanentLineId, DIRECT_COM1,
                DIRECT_COM4))
            {
            if (hhDriver->iStatus == CNCT_STATUS_TRUE)
                {
				// Checking the status of DCD before disconnecting
				// is a good idea, prevents us hanging up whenever we
				// get any event while connected
				// - mpt:08-26-97
			    hCom = sessQueryComHdl(hhDriver->hSession);
			    iRet = ComDriverSpecial(hCom, "Query DCD_STATUS", ach, sizeof(ach) / sizeof(TCHAR));
			
				if (iRet == COM_OK)
				    {
				    if (ach[0] == '0')
						{
						// If we are direct cabled, and we're connected, then
						// the other end just disconnected, so disconnect now.
						// - cab:11/20/96
						//
						// Note: We must disconnect by posting a message to
						// thread one. This is because if we get here, we were
						// called from the context of the com thread, which
						// will not exit properly if cnctdrvDisconnect is called.
						// - cab:11/21/96
						//
						NotifyClient(hhDriver->hSession, EVENT_LOST_CONNECTION, 0);
						}
					}
                }
#ifdef INCL_CALL_ANSWERING
            else if (hhDriver->iStatus == CNCT_STATUS_ANSWERING)
                {
                // If we are a direct cabled connection, and we are waiting
                // for a call, connect when we see a carriage return.
                //
                WaitForCRinit(hhDriver);
                }
#endif
            }
        }
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  DoAnswerCall
 *
 * DESCRIPTION:
 *  Sets up TAPI to answer the next data modem call.
 *
 * ARGUMENTS:
 *  hhDriver - private driver handle
 *
 * RETURNS:
 *  0 or error
 *
 * AUTHOR:  C. Baumgartner, 11/25/96 (ported from HAWin32)
 */
int DoAnswerCall(const HHDRIVER hhDriver)
    {
	TCHAR ach[256];

    // Believe it or not, this is all one has to do to setup and
    // answer a call.  Quite a contrast to placing a call.
    //
    if (TRAP(lineOpen(hhDriver->hLineApp, hhDriver->dwLine, &hhDriver->hLine,
        hhDriver->dwAPIVersion, 0, (DWORD_PTR)hhDriver, LINECALLPRIVILEGE_OWNER,
        LINEMEDIAMODE_DATAMODEM, 0)) != 0)
        {
        assert(0);
	    LoadString(glblQueryDllHinst(), IDS_ER_CNCT_TAPIFAILED, ach, sizeof(ach) / sizeof(TCHAR));
	    TimedMessageBox(0, ach, 0, MB_OK | MB_ICONINFORMATION | MB_TASKMODAL,
            sessQueryTimeout(hhDriver->hSession));
        return -1;
        }

    // The the line app priority for compliance with TAPI specifications.
    // mrw:9/18/96
    //
	LoadString(glblQueryDllHinst(), IDS_GNRL_APPNAME, ach, sizeof(ach) / sizeof(TCHAR));
    TRAP(lineSetAppPriority(ach, LINEMEDIAMODE_DATAMODEM, 0, 0, 0, 1));

    // Set line notifications we want to receive
    //
    TRAP(lineSetStatusMessages(hhDriver->hLine, LINEDEVSTATE_RINGING, 0));

    SetStatus(hhDriver, CNCT_STATUS_ANSWERING);
    return 0;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  DoMakeCall
 *
 * DESCRIPTION:
 *  Performs the neccessary TAPI rituals to place an outbound call.
 *
 * ARGUMENTS:
 *  hhDriver - private driver handle
 *  uFlags   - connection flags
 *
 * RETURNS:
 *  0 or error
 *
 * AUTHOR:  C. Baumgartner, 11/25/96 (ported from cnctdrvConnect)
 */
int DoMakeCall(const HHDRIVER hhDriver, const unsigned int uFlags)
    {
    unsigned int  uidErr = 0;
    int           iRet = 0;
    LINEDEVSTATUS stLnDevStat;
    TCHAR         ach[256];
    BOOL          msgFlag = FALSE;
    
    //
    // Set the line settings.
    //
    if (cncttapiSetLineConfig(hhDriver->dwLine, sessQueryComHdl(hhDriver->hSession)) != 0)
        {
        assert(0);
        uidErr = IDS_ER_CNCT_TAPIFAILED;
        iRet = -1;
        msgFlag = TRUE;
        goto ERROR_EXIT;
        }

	/* --- Open the line, pass driver handle for data reference --- */

	if (TRAP(lineOpen(hhDriver->hLineApp, hhDriver->dwLine,
	        &hhDriver->hLine, hhDriver->dwAPIVersion, 0, (DWORD_PTR)hhDriver,
				LINECALLPRIVILEGE_NONE, 0, 0)) != 0)
            {
            assert(0);
            uidErr = IDS_ER_CNCT_TAPIFAILED;
            iRet = -1;
            msgFlag = TRUE;
            goto ERROR_EXIT;
            }

	/* --- Set line notifications we want to receive, mrw,2/28/95 --- */

	TRAP(lineSetStatusMessages(hhDriver->hLine,
		LINEDEVSTATE_INSERVICE | LINEDEVSTATE_OUTOFSERVICE, 0));

	/* --- Check if our device is in service, mrw,2/28/95 --- */

	stLnDevStat.dwTotalSize = sizeof(stLnDevStat);
	TRAP(lineGetLineDevStatus(hhDriver->hLine, &stLnDevStat));

	if ((stLnDevStat.dwDevStatusFlags & LINEDEVSTATUSFLAGS_INSERVICE) == 0)
            {
            if (DialogBoxParam(glblQueryDllHinst(),
			MAKEINTRESOURCE(IDD_CNCT_PCMCIA),
                        sessQueryHwnd(hhDriver->hSession), PCMCIADlg,
                        (LPARAM)hhDriver) == FALSE)
                {
                iRet = -2;
                goto ERROR_EXIT;
                }
            }

	/* --- Launch the dialing dialog, or go right into passthrough mode. --- */

	if ((uFlags & CNCT_PORTONLY) == 0)
            {
            if (!IsWindow(hhDriver->hwndCnctDlg))
                {
                hhDriver->hwndCnctDlg = DoModelessDialog(glblQueryDllHinst(),
				MAKEINTRESOURCE(IDD_DIALING), sessQueryHwnd(hhDriver->hSession),
                                DialingDlg, (LPARAM)hhDriver);
                }
            }

	/* --- Make the call (oooh, how exciting!) --- */

	memset(&hhDriver->stCallPar, 0, sizeof(hhDriver->stCallPar));
	hhDriver->stCallPar.dwTotalSize = sizeof(hhDriver->stCallPar);
	hhDriver->stCallPar.dwMediaMode = LINEMEDIAMODE_DATAMODEM;
	hhDriver->stCallPar.dwCallParamFlags = LINECALLPARAMFLAGS_IDLE;

	if (uFlags & CNCT_PORTONLY)
		hhDriver->stCallPar.dwBearerMode = LINEBEARERMODE_PASSTHROUGH;

	if ((hhDriver->lMakeCallId = lineMakeCall(hhDriver->hLine,
			&hhDriver->hCall, hhDriver->achDialableDest,
                        hhDriver->dwCountryCode, &hhDriver->stCallPar)) < 0)
            {
            #if defined(_DEBUG)
            char ach[50];
            wsprintf(ach, "lineMakeCall returned %x", hhDriver->lMakeCallId);
            MessageBox (0, ach, "debug", MB_OK);
            #endif

            switch (hhDriver->lMakeCallId)
                {
                case LINEERR_RESOURCEUNAVAIL:
                case LINEERR_CALLUNAVAIL:
                    uidErr = IDS_ER_CNCT_CALLUNAVAIL;
                    iRet   = -3;
                    msgFlag = TRUE;
                    goto ERROR_EXIT;

                case LINEERR_DIALDIALTONE:
                case LINEERR_DIALPROMPT:
                    if (DoDelayedCall(hhDriver) != 0)
                        {
                        iRet = -4;
                        msgFlag = TRUE;
                        goto ERROR_EXIT;
                        }

                    break;

                default:
                    iRet = -5;
                    msgFlag = TRUE;
                    goto ERROR_EXIT;
                    }
                }

	SetStatus(hhDriver, CNCT_STATUS_CONNECTING);
	return 0;

	/* --- Error exit --- */

ERROR_EXIT:

        // Change this so that the dialog is destroyed before the
        // error message is displayed. Otherwise, the timer that
        // handled redials continued to pump a redial message once
        // every second, causing HT to go into a very nasty loop. mpt 02SEP98

        if (IsWindow(hhDriver->hwndCnctDlg))
            {
            EndModelessDialog(hhDriver->hwndCnctDlg);
            hhDriver->hwndCnctDlg = 0;
            }

        if ( msgFlag )
            {
            LoadString(glblQueryDllHinst(), uidErr, ach, sizeof(ach) / sizeof(TCHAR));

            TimedMessageBox(0, ach, 0, MB_OK | MB_ICONINFORMATION | MB_TASKMODAL,
            sessQueryTimeout(hhDriver->hSession));
            }

	return iRet;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  cnctdrvConnect
 *
 * DESCRIPTION:
 *  Attempts to dial the modem.
 *
 * ARGUMENTS:
 *  hhDriver - private driver handle
 *  uFlags   - connection flags
 *
 * RETURNS:
 *  0 or error
 *
 */
int WINAPI cnctdrvConnect(const HHDRIVER hhDriver, const unsigned int uFlags)
	{
	TCHAR 	ach[FNAME_LEN];
#if defined(INCL_WINSOCK)
	//
	// MAX_IP_ADDR_LEN+11+1 = buffer size of hhDriver->achDestAddr +
	// settings string "SET IPADDR=" + 1 for the terminating NULL
	// character.  REV 09/20/2000
	//
	TCHAR	szInstruct[MAX_IP_ADDR_LEN+11+1]; // Used only for WinSock
	TCHAR   szResult[MAX_IP_ADDR_LEN+11+1];   // Used only for WinSock
	int     iNumChars;
#endif
	TCHAR	achNewCnct[FNAME_LEN];
	TCHAR	achCom[20];
	BOOL	fGetNewName = FALSE;
	HICON	hIcon;
	HCOM	hCom;
#ifdef INCL_WINSOCK
    //UNDO:jmh 3/24/97 HEMU    hEmu;
#endif
	int 	hIconId;
	int 	fFlag;
	unsigned int uidErr = IDS_ER_CNCT_TAPIFAILED;

	if (hhDriver == 0)
		{
		assert(FALSE);
		return CNCT_BAD_HANDLE;
		}

	/* --- Makes for easier referencing --- */

	hCom = sessQueryComHdl(hhDriver->hSession);

	/* --- Check to see we're not already connected --- */

	if (cnctdrvQueryStatus(hhDriver) != CNCT_STATUS_FALSE)
		return CNCT_ERROR;

	// JMH 05-29-96 This is needed to prevent CLoop from processing
	// activity on the terminal window while TAPI is connecting.
	//
	CLoopRcvControl(sessQueryCLoopHdl(hhDriver->hSession),
				    CLOOP_SUSPEND,
					CLOOP_RB_CNCTDRV);
	CLoopSndControl(sessQueryCLoopHdl(hhDriver->hSession),
					CLOOP_SUSPEND,
					CLOOP_SB_CNCTDRV);

	/* --- Just on the off chance we still have an open line --- */

	if (hhDriver->hLineApp && hhDriver->hLine)
		{
		lineClose(hhDriver->hLine);
		hhDriver->hLine = 0;
		}

	if (hhDriver->hLineApp && hhDriver->dwLineCnt == 0 &&
            (uFlags & CNCT_PORTONLY) == 0)
		{
    	DoNewModemWizard(sessQueryHwnd(hhDriver->hSession),
                         sessQueryTimeout(hhDriver->hSession));
		}

	/* --- Ask for new session name only if needed  --- */

	sessQueryName(hhDriver->hSession, ach, sizeof(ach));

	achNewCnct[0] = TEXT('\0');
	LoadString(glblQueryDllHinst(),	IDS_GNRL_NEW_CNCT, achNewCnct,
		sizeof(achNewCnct) / sizeof(TCHAR));

	if (ach[0] == TEXT('\0') || lstrcmp(achNewCnct, ach) == 0)
		{
		// This can only happen if the user double-clicks on the term.exe or
		// there is no session name given on the command line.
		// In this case give the "New Connection" name to the session.
		//
		sessSetName(hhDriver->hSession, achNewCnct);

		if (!(uFlags & CNCT_PORTONLY))
            fGetNewName = TRUE;
		}
	else if (uFlags & CNCT_NEW)
		{
		// This can only happen if the user selects 'File | New Connection'
		// from the menus.
		//
		sessSetName(hhDriver->hSession, achNewCnct);
		sessSetIsNewSession(hhDriver->hSession, TRUE);
		}
#if defined (INCL_WINSOCK)
	else if (uFlags & CNCT_WINSOCK)
		{
		//
		// Make sure we don't overwrite the buffer. If the string
		// is too long, then truncate to the hhDriver->achDestAddr
		// size of MAX_AP_ADDR_LEN.  REV 09/20/2000 
		//
		StrCharCopyN(hhDriver->achDestAddr, ach, MAX_IP_ADDR_LEN);
		hhDriver->achDestAddr[MAX_IP_ADDR_LEN - 1] = TEXT('\0');
		hhDriver->dwPermanentLineId = DIRECT_COMWINSOCK;
		}
#endif

	if (fGetNewName || (uFlags & CNCT_NEW))
		{
		if (DialogBoxParam(glblQueryDllHinst(), MAKEINTRESOURCE(IDD_NEWCONNECTION),
			sessQueryHwnd(hhDriver->hSession), NewConnectionDlg,
				(LPARAM)hhDriver->hSession) == FALSE)
			{
			if (uFlags & CNCT_NEW)
				{
				sessQueryOldName(hhDriver->hSession, ach, sizeof(ach));
				sessSetName(hhDriver->hSession, ach);
				sessSetIsNewSession(hhDriver->hSession, FALSE);
				}
			goto ERROR_EXIT;
			}
		else
			{
			if (uFlags & CNCT_NEW)
				{
				sessQueryName(hhDriver->hSession, ach, sizeof(ach));
				hIcon = sessQueryIcon(hhDriver->hSession);
				hIconId = sessQueryIconID(hhDriver->hSession);

				ReinitializeSessionHandle(hhDriver->hSession, FALSE);
				CLoopSndControl(sessQueryCLoopHdl(hhDriver->hSession),
                                CLOOP_SUSPEND,
                                CLOOP_SB_CNCTDRV);

				sessSetName(hhDriver->hSession, ach);
				sessSetIconID(hhDriver->hSession, hIconId);
				}
			}
		}

	/* --- Load the Standard Com  drivers --- */

	ComLoadStdcomDriver(hCom);

	// There are a bunch of conditions that can trigger the
	// phone dialog.
	//
	fFlag = FALSE;

	// If no phone number, bring up new phone dialog here
	// Unless we have a direct to com port selected
    //
    // Don't display the dialog if we are answering, because
    // we don't need a phone number. - cab:11/19/96
    //
	
	if (!IN_RANGE(hhDriver->dwPermanentLineId, DIRECT_COM1, DIRECT_COM4) &&
            hhDriver->dwPermanentLineId != DIRECT_COM_DEVICE &&
			!(uFlags & (CNCT_PORTONLY | CNCT_ANSWER)))
		{
#ifdef INCL_WINSOCK
        // If the driver is WinSock, then check for a
        // destination IP address. - cab:11/19/96
        //
        if (hhDriver->dwPermanentLineId == DIRECT_COMWINSOCK &&
                hhDriver->achDestAddr[0] == TEXT('\0'))
            {
            fFlag = TRUE;
            }
#endif
        // If the driver isn't WinSock, then we must be using
        // TAPI, so check for a destination phone number. - cab:11/19/96
        //
        if (hhDriver->dwPermanentLineId != DIRECT_COMWINSOCK &&
                (hhDriver->achDest[0] == TEXT('\0') || 
				 hhDriver->achDialableDest[0] == TEXT('\0') ||
				 hhDriver->achCanonicalDest[0] == TEXT('\0')))
            {
            fFlag = TRUE;
            }
		}

	// New connections trigger this dialog
	//
	if (uFlags & CNCT_NEW)
		fFlag = TRUE;

	// If the modem/port we saved no longer exists
	//
	//if (!hhDriver->fMatchedPermanentLineID)
	//	fFlag = TRUE;

	// Note:  Passing the property sheet page here because property
	//        sheets use same code and don't have access directly
	//        to the private driver handle.  Upper wacker will have
	//        to address the problem differently - mrw.

	if (fFlag)
		{
		PROPSHEETPAGE psp;

		// Before you go and critize this goto target come talk to
		// me.	There are enough things going on here that a goto
		// is warranted in my humble opinion. - mrw

NEWPHONEDLG:

		psp.lParam = (LPARAM)hhDriver->hSession;

		if (DialogBoxParam(glblQueryDllHinst(),
			MAKEINTRESOURCE(IDD_CNCT_NEWPHONE),
				sessQueryHwnd(hhDriver->hSession), NewPhoneDlg,
					(LPARAM)&psp) == FALSE)
			{
			goto ERROR_EXIT;
			}

		else if (IN_RANGE(hhDriver->dwPermanentLineId, DIRECT_COM1,
				DIRECT_COM4))
			{
			/* --- Bring up the port configure dialog --- */

			wsprintf(ach, "COM%d",
				hhDriver->dwPermanentLineId - DIRECT_COM1 + 1);

			ComSetPortName(hCom, ach);

			if (ComDeviceDialog(hCom, sessQueryHwnd(hhDriver->hSession))
					!= COM_OK)
				{
				// User canceled
				//  --jcm 3-2-95
				//return -1;
				}
			}

		else if ( IsNT() )
			{
			if (hhDriver->dwPermanentLineId == DIRECT_COM_DEVICE)
				{
				ComSetPortName(hCom, hhDriver->achComDeviceName);
				ComDeviceDialog(hCom, sessQueryHwnd(hhDriver->hSession));
				}
			}

#if defined(INCL_WINSOCK) // mrw:3/5/96
        else if (hhDriver->dwPermanentLineId == DIRECT_COMWINSOCK)
            {
            if (hhDriver->achDestAddr[0] == TEXT('\0'))
                {
				LoadString(glblQueryDllHinst(), IDS_ER_TCPIP_MISSING_ADDR,
					ach, sizeof(ach) / sizeof(TCHAR));

        		TimedMessageBox(sessQueryHwnd(hhDriver->hSession), ach, 0,
		        	MB_OK | MB_ICONINFORMATION,
                        sessQueryTimeout(hhDriver->hSession));

                goto NEWPHONEDLG;
                }
            }
#endif

        else
            {
            // mrw: Check that we have valid data.
            //
            if (hhDriver->achDest[0] == TEXT('\0'))
                {
		        LoadString(glblQueryDllHinst(), IDS_ER_CNCT_BADADDRESS, ach,
    			    sizeof(ach) / sizeof(TCHAR));

        		TimedMessageBox(sessQueryHwnd(hhDriver->hSession), ach, 0,
		        	MB_OK | MB_ICONINFORMATION,
                        sessQueryTimeout(hhDriver->hSession));

                // goto ERROR_EXIT; // mrw:3/5/96
                goto NEWPHONEDLG;   // mrw:3/5/96
                }
            }
		}

	/* --- Enumerate lines, picks default (set in hhDriver->dwLine) --- */

	if ( IsNT() )
		{
		if (EnumerateLinesNT(hhDriver, 0) != 0)
			{
			assert(FALSE);
			goto MSG_EXIT;
			}
		}
	else
		{
		if (EnumerateLines(hhDriver, 0) != 0)
			{
			assert(FALSE);
			goto MSG_EXIT;
			}
		}


	/* --- If we don't match any TAPI lines, go back to new phone --- */

	if ( hhDriver->dwLine == (DWORD)-1 )
		{
		DoNewModemWizard(sessQueryHwnd(hhDriver->hSession),
                         sessQueryTimeout(hhDriver->hSession));
		goto NEWPHONEDLG;
		}

	/* --- Redraw window now so dialogs don't overlap ---- */

	UpdateWindow(sessQueryHwnd(hhDriver->hSession));

 	/* --- Check if we're doing a direct connect or using passthrough mode --- */

	if ( IsNT() )
		{
		if (hhDriver->dwPermanentLineId == DIRECT_COM_DEVICE)
			{
            int iActivatePortReturn = IDS_ER_CNCT_PORTFAILED;
			if (TRAP(ComSetPortName(hCom, hhDriver->achComDeviceName)) != COM_OK ||
				(iActivatePortReturn = TRAP(ComActivatePort(hCom, 0))) != COM_OK)
				{
                if (iActivatePortReturn == COM_PORT_IN_USE)
                    {
				    LoadString(glblQueryDllHinst(), IDS_ER_CNCT_CALLUNAVAIL,
					    ach, sizeof(ach) / sizeof(TCHAR));
                    }
                else
                    {
				    LoadString(glblQueryDllHinst(), IDS_ER_CNCT_PORTFAILED,
					    achNewCnct, sizeof(achNewCnct) / sizeof(TCHAR));

				    wsprintf(ach, achNewCnct, hhDriver->achComDeviceName);
                    }

				TimedMessageBox(sessQueryHwnd(hhDriver->hSession), ach, 0,
					MB_OK | MB_ICONINFORMATION,
						sessQueryTimeout(hhDriver->hSession));

				return -1;
				}

			else
				{
				SetStatus(hhDriver, CNCT_STATUS_TRUE);
				}

			return 0;
			}
		}

	if (IN_RANGE(hhDriver->dwPermanentLineId, DIRECT_COM1, DIRECT_COM4))
		{
        int iActivatePortReturn = IDS_ER_CNCT_PORTFAILED;
		wsprintf(achCom, "COM%d", hhDriver->dwPermanentLineId -
			DIRECT_COM1 + 1);

        if (TRAP(ComSetPortName(hCom, achCom)) != COM_OK ||
			(iActivatePortReturn = TRAP(ComActivatePort(hCom, 0))) != COM_OK)
			{
            if (iActivatePortReturn == COM_PORT_IN_USE)
                {
				LoadString(glblQueryDllHinst(), IDS_ER_CNCT_CALLUNAVAIL,
					ach, sizeof(ach) / sizeof(TCHAR));
                }
            else
                {
				LoadString(glblQueryDllHinst(), IDS_ER_CNCT_PORTFAILED,
					achNewCnct, sizeof(achNewCnct) / sizeof(TCHAR));

			    wsprintf(ach, achNewCnct, achCom);
                }

			TimedMessageBox(sessQueryHwnd(hhDriver->hSession), ach, 0,
				MB_OK | MB_ICONINFORMATION,
					sessQueryTimeout(hhDriver->hSession));

			return -1;
			}

		else
			{
            if (uFlags & CNCT_ANSWER)
                {
                SetStatus(hhDriver, CNCT_STATUS_ANSWERING);
                }
            else
                {
			    SetStatus(hhDriver, CNCT_STATUS_TRUE);
                }
			}

		return 0;
		}

#if defined(INCL_WINSOCK)
	if (hhDriver->dwPermanentLineId == DIRECT_COMWINSOCK)
		{
		int iPort;

		/* --- Load the Winsock Com  drivers --- */
		ComLoadWinsockDriver(hCom);

        // Baud rate, etc. are meaningless for TCP/IP connections
        //
        ComSetAutoDetect(hCom, FALSE);
		iPort = sessQueryTelnetPort(hhDriver->hSession);
		if (iPort != 0)
			hhDriver->iPort = iPort;
        PostMessage(sessQueryHwndStatusbar(hhDriver->hSession),
            SBR_NTFY_REFRESH, (WPARAM)SBR_COM_PART_NO, 0);

#if 0   //DEADWOOD:jmh 3/24/97 Yes, we really want auto-detection, even in telnet!
        // Auto-detection of emulator type is redundant, since we tell
        // the telnet host what type we want. Seems like ANSI is the
        // most likely choice.
        hEmu = sessQueryEmuHdl(hhDriver->hSession);
        if (emuQueryEmulatorId(hEmu) == EMU_AUTO)
            {
            emuLoad(hEmu, EMU_VT100);
#ifdef INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID
            // Make sure the telnet terminal id is correct. - cab:11/18/96
            //
            emuLoadDefaultTelnetId(hEmu);
#endif
            PostMessage(sessQueryHwndStatusbar(hhDriver->hSession),
                SBR_NTFY_REFRESH, (WPARAM)SBR_EMU_PART_NO, 0);
            }
#endif  // 0

#ifdef INCL_CALL_ANSWERING
        if (uFlags & CNCT_ANSWER)
            {
            wsprintf(szInstruct, "SET ANSWER=1");
            }
        else
            {
            wsprintf(szInstruct, "SET ANSWER=0");
            }
        ComDriverSpecial(hCom, szInstruct, szResult, sizeof(szResult) / sizeof(TCHAR));
#endif
		/* --- Do ComDriverSpecial calls to send the IP address &  port number
			   to the comm driver */

		//
		// Make sure we don't overwrite the buffer. If the string
		// is too long, then truncate to the hhDriver->achDestAddr
		// size of MAX_AP_ADDR_LEN.  REV 09/20/2000 
		//
		StrCharCopy(szInstruct, TEXT("SET IPADDR="));
		iNumChars = StrCharGetStrLength(szInstruct);
		StrCharCopyN(&szInstruct[iNumChars], hhDriver->achDestAddr,
			         sizeof(szInstruct)/sizeof(TCHAR) - iNumChars);

		//
		// Make sure the string is null terminated.
		//
		szInstruct[sizeof(szInstruct)/sizeof(TCHAR) - 1]=TEXT('\0');
		ComDriverSpecial(hCom, szInstruct, szResult,
					  sizeof(szResult) / sizeof(TCHAR));

		wsprintf(szInstruct, "SET PORTNUM=%ld", hhDriver->iPort);
		ComDriverSpecial(hCom, szInstruct,
					  szResult, sizeof(szResult) / sizeof(TCHAR));

#ifdef INCL_CALL_ANSWERING
        if (uFlags & CNCT_ANSWER)
            {
            SetStatus(hhDriver, CNCT_STATUS_ANSWERING);
            }
        else
            {
		    SetStatus(hhDriver, CNCT_STATUS_CONNECTING);
            }
#else
		SetStatus(hhDriver, CNCT_STATUS_CONNECTING);
#endif

		/* --- Activate the port  ---*/
		if (ComActivatePort(hCom, 0) != COM_OK)
			{
			LoadString(glblQueryDllHinst(), IDS_ER_TCPIP_FAILURE,
			achNewCnct, sizeof(achNewCnct) / sizeof(TCHAR));

			TimedMessageBox(sessQueryHwnd(hhDriver->hSession), ach, 0,
				MB_OK | MB_ICONINFORMATION,
				sessQueryTimeout(hhDriver->hSession));

			return -1;
			}

		else
			{
			return COM_OK;
			}
		}
#endif

	/* --- Display confimation dialog if requested --- */

	if ((uFlags & (CNCT_PORTONLY | CNCT_DIALNOW | CNCT_ANSWER)) == 0)
		{
		if (DialogBoxParam(glblQueryDllHinst(),
			MAKEINTRESOURCE(IDD_CNCT_CONFIRM),
				sessQueryHwnd(hhDriver->hSession), ConfirmDlg,
					(LPARAM)hhDriver) == FALSE)
			{
			goto ERROR_EXIT;
			}
		}

    // Either make the call or wait for a call.
    //
    if (uFlags & CNCT_ANSWER)
        {
        if (DoAnswerCall(hhDriver) != 0)
            {
            goto ERROR_EXIT;
            }
        }
    else
        {
        if (DoMakeCall(hhDriver, uFlags) != 0)
            {
            goto ERROR_EXIT;
            }
        }

    return 0;

	/* --- Message exit --- */

MSG_EXIT:
	LoadString(glblQueryDllHinst(), uidErr, ach, sizeof(ach) / sizeof(TCHAR));

	TimedMessageBox(0, ach, 0, MB_OK | MB_ICONINFORMATION | MB_TASKMODAL,
        sessQueryTimeout(hhDriver->hSession));

	/* --- Error exit --- */

ERROR_EXIT:
	if (hhDriver->hLineApp && hhDriver->hLine)
		{
		lineClose(hhDriver->hLine);
		hhDriver->hLine = 0;
		}

	SetStatus(hhDriver, CNCT_STATUS_FALSE);
    return CNCT_ERROR;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	DoDelayedCall
 *
 * DESCRIPTION:
 *	Check the section under Delayed Dialing in the programmers guide to
 *	TAPI.  Basicly, if the service provider does not provide dialtone
 *	support, then we have to break of the dialable string format into
 *	pieces and prompt the user.
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle.
 *
 * RETURNS:
 *	0=OK, else error.
 *
 * AUTHOR: Mike Ward, 20-Apr-1995
 */
static int DoDelayedCall(const HHDRIVER hhDriver)
	{
	TCHAR ach[256];
	TCHAR ach2[256];
	TCHAR *pach;
	long  lDialRet;

	#define DIAL_DELIMITERS "Ww@$?"

	hhDriver->lMakeCallId = -1;
	lstrcpy(ach, hhDriver->achDialableDest);

	if ((pach = strtok(ach, DIAL_DELIMITERS)) == 0)
		return -1;

	while (pach)
		{
		lstrcpy(ach2, pach);

		// If this is the last segment of the string, don't append the
		// semicolon.
		//
		if ((pach = strtok(NULL, DIAL_DELIMITERS)) != 0)
			lstrcat(ach2, ";");

		if (hhDriver->lMakeCallId < 0)
			{
			// By appending a semicolon to the dialable string, we're
			// telling lineMakeCall that more is on the way.
			//
			if ((hhDriver->lMakeCallId = lineMakeCall(hhDriver->hLine,
				&hhDriver->hCall, ach2, hhDriver->dwCountryCode,
					&hhDriver->stCallPar)) < 0)
				{
				#if defined(_DEBUG)
				char ach[50];
				wsprintf(ach, "DoDelayedCall returned %x", hhDriver->lMakeCallId);
				MessageBox(GetFocus(), ach, "debug", MB_OK);
				#endif

				return -3;
				}
			}

		else
			{
			// Once we have a call handle we have to use lineDial to complete
			// the call.
			//
			if ((lDialRet = lineDial(hhDriver->hCall, ach2,
				hhDriver->dwCountryCode)) < 0)
				{
				#if defined(_DEBUG)
				char ach[50];
				wsprintf(ach, "lineDial returned %x", lDialRet);
				MessageBox(GetFocus(), ach, "debug", MB_OK);
				#endif

				return -4;
				}
			}

		// The user has to tell us when the we can continue dialing
		//
		if (pach != 0)
			{
			LoadString(glblQueryDllHinst(), IDS_CNCT_DELAYEDDIAL, ach2,
			sizeof(ach2) / sizeof(TCHAR));

			if (TimedMessageBox(hhDriver->hwndCnctDlg, ach2, 0,
				MB_OKCANCEL | MB_ICONINFORMATION | MB_TASKMODAL,
				sessQueryTimeout(hhDriver->hSession)) != IDOK)
				{
				return -4;
				}
			}
		}

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  cnctdrvDisconnect
 *
 * DESCRIPTION:
 *  Signals a disconnect
 *
 * ARGUMENTS:
 *  hhDriver - private driver handle
 *  uFlags   - disconnect flags
 *
 * RETURNS:
 *  0 or error
 *
 */
int WINAPI cnctdrvDisconnect(const HHDRIVER hhDriver, const unsigned int uFlags)
	{
	LONG      lLineDropId;
    #if defined(INCL_REDIAL_ON_BUSY)
    HKEY      hKey;
    DWORD     dwSize;
    BYTE      ab[20];
    #endif
    HXFER     hXfer;
    XD_TYPE*  pX;
    int       nReturnVal = 0;
    TCHAR     ach[256];

	if (hhDriver == 0)
		{
		assert(FALSE);
		return CNCT_BAD_HANDLE;
		}

    //
    // Cancel any active file transfers that are currently executing.
    // REV: 02/01/2001
    //
	hXfer = sessQueryXferHdl(hhDriver->hSession);

    if (hXfer != NULL)
        {
        pX = (XD_TYPE*)hXfer;

        if (pX != NULL &&
            pX->hwndXfrDisplay != NULL &&
            IsWindow(pX->hwndXfrDisplay) &&
            pX->nDirection != XFER_NONE)
            {
            int nCancelTransfer = IDYES;

            if (uFlags & CNCT_XFERABORTCONFIRM)
                {
                //
                // Prompt to cancel the file transfer. REV: 02/16/2001
                //
                LoadString(glblQueryDllHinst(), IDS_ER_CNCT_ACTIVETRANSFER, ach, sizeof(ach) / sizeof(TCHAR));

                nCancelTransfer = TimedMessageBox(pX->hwndXfrDisplay, ach, NULL,
                                                  MB_YESNO | MB_ICONEXCLAMATION | MB_TASKMODAL,
			                                      sessQueryTimeout(hhDriver->hSession));

                }

            if (nCancelTransfer == IDYES || nCancelTransfer == -1)
                {
                unsigned int uNewFlags = uFlags;

                if (uFlags & CNCT_XFERABORTCONFIRM)
                    {
                    //
                    // NOTE:  We should only have to tell the XFER to abort here.
                    //        It should not be dependent on a message to a dialog.
                    //
                    PostMessage(pX->hwndXfrDisplay, WM_COMMAND, XFR_SHUTDOWN, 0L);
                    }

                //
                // We can't exit until the file transfer exits, so post a
                // message to try to disconnect again.  Make sure to turn
                // of the CNCT_XFERABORTCONFIRM flag as we don't want to
                // prompt the kill the transfer again.
                //
                uNewFlags &= ~CNCT_XFERABORTCONFIRM;

                //
                // We must post a message to disconnect because we are
                // waiting for the file transfer to cancel.  We have to
                // post a message otherwise we will get into a deadlock
                // situation.  This is not the best way to accomplish
                // this as we may be posting a lot of messages to the
                // session window and there is a potential for the
                // file transfer to not respond quickly causing the
                // disconnect to loop.  Eventually, the file transfer
                // will cancel, or will timeout and cancel, so we will
                // not get into an endless loop. REV: 06/22/2001
                //
                PostDisconnect(hhDriver, uNewFlags);
                }

            //
            // Return an status that the current file transfer must be
            // canceled (or is in the process of being canceled).  We
            // cannot disconnect until the transfer is complete.
            //
            return XFR_SHUTDOWN;
            }
        }

#ifdef INCL_CALL_ANSWERING
    // Unregister our cloop callback.
    //
    if (hhDriver->pvUnregister)
        {
        CLoopUnregisterRmtInputChain(hhDriver->pvUnregister);
        hhDriver->pvUnregister = 0;
        }
#endif

	ComDeactivatePort(sessQueryComHdl(hhDriver->hSession));

	if (hhDriver->hCall)
		{
		SetStatus(hhDriver, CNCT_STATUS_DISCONNECTING);

		if ((lLineDropId = lineDrop(hhDriver->hCall, 0, 0)) < 0)
			assert(FALSE);

		hhDriver->hCall = 0;

		// If the drop is completing asychronously, save the flags and
		// wait for the call status to go idle.
		//
		if (lLineDropId > 0)
			{
			hhDriver->uDiscnctFlags = uFlags;
			return 0;
			}
		}

	SetStatus(hhDriver, CNCT_STATUS_FALSE);

	if ((uFlags & DISCNCT_NOBEEP) == 0)
		sessBeeper(hhDriver->hSession);

	//mpt:10-28-97 added exit upon disconnect feature
	if ((uFlags & DISCNCT_EXIT))
		PostMessage(sessQueryHwnd(hhDriver->hSession), WM_CLOSE, 0, 0);

	if (hhDriver->hLine)
		{
		lineClose(hhDriver->hLine);
		hhDriver->hLine = 0;
		}

	if (uFlags & CNCT_DIALNOW)
		{
        #if defined(INCL_REDIAL_ON_BUSY)
        if (hhDriver->fRedialOnBusy && hhDriver->iRedialCnt > 0)
            {
			hhDriver->uDiscnctFlags = uFlags;
            hhDriver->iRedialSecsRemaining = 2;

            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                "SOFTWARE\\Microsoft\\HyperTerminal\\TimeToRedial", 0, KEY_READ,
                    &hKey) == ERROR_SUCCESS)
                {
                dwSize = sizeof(ab);

                if (RegQueryValueEx(hKey, "", 0, 0, ab, &dwSize) == ERROR_SUCCESS)
                    hhDriver->iRedialSecsRemaining = atoi(ab);

                RegCloseKey(hKey);
                }

            SetTimer(hhDriver->hwndCnctDlg, 1, 1000, 0);
            }

        else
            {
		    PostMessage(sessQueryHwnd(hhDriver->hSession), WM_CNCT_DIALNOW,
			    uFlags, 0);
            }

        #else
		PostMessage(sessQueryHwnd(hhDriver->hSession), WM_CNCT_DIALNOW,
			uFlags, 0);
        #endif
		}

    else
        {
        // If we're not auto redialing, reset the dial count. - mrw:10/10/95
        //
        hhDriver->iRedialCnt = 0;
        }

	return nReturnVal;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  lineCallbackFunc
 *
 * DESCRIPTION:
 *  Function TAPI calls to handle asynchronous events
 *
 * ARGUMENTS:
 *  see TAPI.H
 *
 * RETURNS:
 *  void
 *
 */
void CALLBACK lineCallbackFunc(DWORD hDevice, DWORD dwMsg, DWORD_PTR dwCallback,
							   DWORD_PTR dwParm1, DWORD_PTR dwParm2, DWORD_PTR dwParm3)
	{
	const HHDRIVER hhDriver = (HHDRIVER)dwCallback;
	int id;
    unsigned int uFlags;

	#if 0
	{
	char ach[256];
	wsprintf(ach,"%x %x", dwMsg, dwParm1);
	MessageBox(GetFocus(), ach, "debug", MB_OK);
	}
	#endif

	switch (dwMsg)
		{
	case LINE_REPLY:
		if ((LONG)dwParm1 == hhDriver->lMakeCallId)
			{
			hhDriver->lMakeCallId = 0;

			if ((LONG)dwParm2 != 0) // zero indicates success
				{
				switch (dwParm2)
					{
				case LINEERR_CALLUNAVAIL:
					id = IDS_DIAL_NODIALTONE;
					break;

				default:
					id = IDS_DIAL_DISCONNECTED;
					break;
					}

				cnctdrvDisconnect(hhDriver, 0);
				DialingMessage(hhDriver, id);
				}
			}
		break;

	case LINE_LINEDEVSTATE:
		DbgOutStr("LINEDEVSTATE_DISCONNECTED 0x%x\r\n", dwParm1, 0, 0, 0, 0);

		switch (dwParm1)
			{
        case PHONESTATE_CAPSCHANGE:
            //
            // If we are currently disconnected, then reset.
            //
            if (hhDriver != NULL && hhDriver->iStatus != CNCT_STATUS_FALSE)
                break;

		case LINEDEVSTATE_REINIT:
        case PHONESTATE_REINIT:
			if (hhDriver == 0)
				{
				// Until we open a line, we don't have a driver handle
				// since we can't pass one during lineInitialize().
				// This turns out to be a good time to reinit if we get
				// notified to do so however, so it has use.
				//
				if (tapiReinit(gbl_hhDriver) != 0)
					tapiReinitMessage(gbl_hhDriver);
				}

			else
				{
				tapiReinitMessage(hhDriver);
				}
			break;

		case LINEDEVSTATE_INSERVICE:
			// If we are showing our PCMCIA dialog prompting the user
			// to insert the card, we post a message to dismiss the
			// dialog once they insert it. - mrw,2/28/95
			//
			if (IsWindow(hhDriver->hwndPCMCIA))
				{
				PostMessage(hhDriver->hwndPCMCIA, WM_COMMAND,
					MAKEWPARAM(IDOK, 0), (LPARAM)hhDriver->hwndPCMCIA);
				}
			break;

		case LINEDEVSTATE_OUTOFSERVICE:
			// Means they yanked the PCMCIA card - mrw,2/28/95
			//
			cnctdrvDisconnect(hhDriver, 0);
			break;

        case LINEDEVSTATE_RINGING:
            // When the current ring count (as told by dwParam3) equals
            // or exceeds the rings to answer on then we'll do the answer
            // using the hhdriver->hCall handle we cached during the
            // LINECALLSTATE_BURNTOFFERING notification. - rjk. 07-31-96
            //
            if ((hhDriver->lMakeCallId = lineAnswer(hhDriver->hCall,0,0)) >= 0)
                {
                SetStatus(hhDriver, CNCT_STATUS_CONNECTING);
                }
            break;

        case LINEDEVSTATE_CLOSE:
        case PHONESTATE_DISCONNECTED:
            //
            // Another application has disconnected this device. REV: 04/27/2001
            //
            uFlags = CNCT_DIALNOW | CNCT_NOCONFIRM;
            id = IDS_DIAL_DISCONNECTED;
			PostDisconnect(hhDriver, uFlags);
			DialingMessage(hhDriver, id);
            break;

		default:
			break;
			}
		break; // case LINE_LINEDEVSTATE

	case LINE_CREATE:	// Sent when new modem is added
		assert(0);		// So I know it happened

		// A remote possibilility exists that if two modems were created
		// back to back, that the LINE_CREATE's would come out of order.
		// T. Nixon suggests that we bump the line count by the dwParm1
		// parameter plus one only when it is greater than or equal to
		// the current line count. - mrw
		//
		if (dwParm1 >= gbl_hhDriver->dwLineCnt)
			gbl_hhDriver->dwLineCnt = (DWORD)(dwParm1 + 1);

		break;

	case LINE_CALLSTATE:
		DbgOutStr("LINECALLSTATE 0x%x\r\n", dwParm1, 0, 0, 0, 0);
		switch ((LONG)dwParm1)
			{
		case LINECALLSTATE_OFFERING:
			DialingMessage(hhDriver, IDS_DIAL_OFFERING);
            // Windows sends us this message only one time while receiving
            // a call and that is on the very first ring.  See the code
            // that responds to the LINEDEVSTATE_RINGING to see how the call
            // gets answered. - rjk. 07-31-96
            //
            hhDriver->hCall = (HCALL)hDevice;
			break;

		case LINECALLSTATE_DIALTONE:
			DialingMessage(hhDriver, IDS_DIAL_DIALTONE);
			break;

		case LINECALLSTATE_DIALING:
			DialingMessage(hhDriver, IDS_DIAL_DIALING);
			break;

		case LINECALLSTATE_RINGBACK:
			DialingMessage(hhDriver, IDS_DIAL_RINGBACK);
			break;

		case LINECALLSTATE_BUSY:
			DialingMessage(hhDriver, IDS_DIAL_BUSY);
			EnableDialNow(hhDriver->hwndCnctDlg, TRUE);
            uFlags = DISCNCT_NOBEEP;

            #if defined(INCL_REDIAL_ON_BUSY)
            if (hhDriver->fRedialOnBusy && hhDriver->iRedialCnt++ < REDIAL_MAX)
                uFlags = CNCT_DIALNOW | CNCT_NOCONFIRM | DISCNCT_NOBEEP;
            #endif

			PostDisconnect(hhDriver, uFlags);
			break;

		case LINECALLSTATE_CONNECTED:
			DialingMessage(hhDriver, IDS_DIAL_CONNECTED);

			if (Handoff(hhDriver) != 0)
				{
				PostDisconnect(hhDriver, 0);
				}
			else
				{
                if (IsWindow(hhDriver->hwndCnctDlg))
                    {
                    // Closes the dialing dialog
				    PostMessage(hhDriver->hwndCnctDlg, WM_USER+0x100, 0, 0);
                    }
				SetStatus(hhDriver, CNCT_STATUS_TRUE);
				}

			break;

		case LINECALLSTATE_DISCONNECTED:
			DbgOutStr("LINECALLSTATE_DISCONNECTED 0x%x\r\n", dwParm2, 0, 0, 0, 0);
			uFlags = 0;

			if (dwParm2 & LINEDISCONNECTMODE_BUSY)
                {
				id = IDS_DIAL_BUSY;

                #if defined(INCL_REDIAL_ON_BUSY)
                if (hhDriver->fRedialOnBusy &&
                    hhDriver->iRedialCnt++ < REDIAL_MAX)
                    {
                    // Wait to let slower phone systems catchup - mrw 2/29/96
                    //
                    uFlags |= CNCT_DIALNOW|CNCT_NOCONFIRM|DISCNCT_NOBEEP;
                    }
                #endif
                }

			else if (dwParm2 & LINEDISCONNECTMODE_NOANSWER)
				id = IDS_DIAL_NOANSWER;

			else if (dwParm2 & LINEDISCONNECTMODE_NODIALTONE)
				id = IDS_DIAL_NODIALTONE;

			else
				{
				id = IDS_DIAL_DISCONNECTED;
				//mpt:10-28-97 added exit upon disconnect feature
				uFlags |= ( sessQueryExit(hhDriver->hSession) ? DISCNCT_EXIT : 0 );
				}

			PostDisconnect(hhDriver, uFlags);
			DialingMessage(hhDriver, id);
			break;

		case LINECALLSTATE_IDLE:
			cnctdrvDisconnect(hhDriver, hhDriver->uDiscnctFlags);
			break;

		default:
			break;
			}

	default:
		break;
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	Handoff
 *
 * DESCRIPTION:
 *	Hands TAPI's com handle to the Wacker's com routines.
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle
 *
 * RETURNS:
 *	0=OK
 *
 */
int Handoff(const HHDRIVER hhDriver)
	{
	LPVARSTRING pVarstr;
	HANDLE hdl;
	DWORD dwSize;
	int i;

	pVarstr = malloc(sizeof(VARSTRING));

	if (pVarstr == 0)
		{
		assert(FALSE);
		return 1;
		}

    memset( pVarstr, 0, sizeof(VARSTRING) );
	pVarstr->dwTotalSize = sizeof(VARSTRING);

	if (lineGetID(hhDriver->hLine, hhDriver->dwLine, hhDriver->hCall,
                        LINECALLSELECT_CALL, pVarstr, DEVCLASS) != 0)
		{
		assert(FALSE);
        free(pVarstr);
        pVarstr = NULL;
		return 2;
		}

	if (pVarstr->dwNeededSize > pVarstr->dwTotalSize)
		{
		dwSize = pVarstr->dwNeededSize;
		free(pVarstr);
        pVarstr = NULL;
        pVarstr = malloc(dwSize);

		if (pVarstr == 0)
			{
			assert(FALSE);
			return 3;
			}

        memset( pVarstr, 0, dwSize );
		pVarstr->dwTotalSize = dwSize;

		if (TRAP(lineGetID(hhDriver->hLine, hhDriver->dwLine, hhDriver->hCall,
                                LINECALLSELECT_CALL, pVarstr, DEVCLASS)) != 0)
			{
			assert(FALSE);
			free(pVarstr);
            pVarstr = NULL;
            return 4;
			}
		}

	if (pVarstr->dwStringSize == 0)
		{
		assert(FALSE);
		free(pVarstr);
        pVarstr = NULL;
        return 5;
		}

	hdl = *(HANDLE *)((BYTE *)pVarstr + pVarstr->dwStringOffset);

	// Set comm buffers to 32K
	//
	if (SetupComm(hdl, 32768, 32768) == FALSE)
		assert(0);

	if ((i = ComActivatePort(sessQueryComHdl(hhDriver->hSession),
			(DWORD_PTR)hdl)) != COM_OK)
		{
        #if !defined(NDEBUG)
		char ach[256];
		wsprintf(ach, "hdl=%x, i=%d", hdl, i);
		MessageBox(0, ach, "debug", MB_OK);
        #endif

		assert(FALSE);
		free(pVarstr);
        pVarstr = NULL;
        return 6;
		}

    if(pVarstr)
        {
        free(pVarstr);
        pVarstr = NULL;
        }

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	PostDisconnect
 *
 * DESCRIPTION:
 *	Work around to TAPI bug that does not allow us to call lineShutDown()
 *	from with the TAPI callback
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle
 *
 * RETURNS:
 *	void
 *
 */
void PostDisconnect(const HHDRIVER hhDriver, const unsigned int uFlags)
	{
	PostMessage(sessQueryHwnd(hhDriver->hSession), WM_DISCONNECT,
		uFlags, 0);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	tapiReinitMessage
 *
 * DESCRIPTION:
 *	Displays a messagebox showing just how stupid TAPI can be at times.
 *
 * ARGUMENTS:
 *	hhDriver    - private driver handle
 *
 * RETURNS:
 *  0=OK, <0=error
 *
 */
static int tapiReinitMessage(const HHDRIVER hhDriver)
    {
	HWND hwnd;
	TCHAR ach[512], achTitle[256];

	if (hhDriver == 0)
        {
        assert(FALSE);
        return -1;
		}

	LoadString(glblQueryDllHinst(), IDS_ER_TAPI_REINIT, ach, sizeof(ach) / sizeof(TCHAR));

	LoadString(glblQueryDllHinst(), IDS_ER_TAPI_REINIT2, achTitle,
		sizeof(achTitle) / sizeof(TCHAR));

	lstrcat(ach, achTitle);

	if ((hwnd = GetFocus()) == 0)
		hwnd = sessQueryHwnd(hhDriver->hSession);

	TimedMessageBox(hwnd, ach, 0,
		MB_OK | MB_ICONINFORMATION | MB_TASKMODAL,
			sessQueryTimeout(hhDriver->hSession));

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	tapiReinit
 *
 * DESCRIPTION:
 *	Attempts to reinit tapi.
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle
 *
 * RETURNS:
 *	0=OK,else error
 *
 */
static int tapiReinit(const HHDRIVER hhDriver)
	{
	int i;
	LPVARSTRING pvs = 0;
    DWORD dwSize;
	const SF_HANDLE sfhdl = sessQuerySysFileHdl(hhDriver->hSession);

    if (hhDriver == 0)
        {
        assert(FALSE);
        return -1;
        }

    if (hhDriver->hLineApp)
        {
        /* --- Get current config so we can restore it --- */

        if (hhDriver->dwLine != (DWORD)-1)
            {
            if ((pvs = malloc(sizeof(VARSTRING))) == 0)
                {
                assert(FALSE);
                goto SHUTDOWN;
                }

			memset( pvs, 0, sizeof(VARSTRING) );
            pvs->dwTotalSize = sizeof(VARSTRING);

            if (lineGetDevConfig(hhDriver->dwLine, pvs, DEVCLASS) != 0)
                {
                assert(FALSE);
                free(pvs);
                pvs = NULL;
                hhDriver->dwLine = (DWORD)-1;
                goto SHUTDOWN;
                }

            if (pvs->dwNeededSize > pvs->dwTotalSize)
                {
                dwSize = pvs->dwNeededSize;
                free(pvs);
                pvs = NULL;

                if ((pvs = malloc(dwSize)) == 0)
                    {
                    assert(FALSE);
                    hhDriver->dwLine = (DWORD)-1;
                    goto SHUTDOWN;
                    }

				memset( pvs, 0, dwSize );
                pvs->dwTotalSize = dwSize;

                if (lineGetDevConfig(hhDriver->dwLine, pvs, DEVCLASS) != 0)
                    {
                    assert(FALSE);
                    free(pvs);
                    pvs = NULL;
                    hhDriver->dwLine = (DWORD)-1;
                    goto SHUTDOWN;
                    }
                }
            }

        SHUTDOWN:

        if (lineShutdown(hhDriver->hLineApp) != 0)
            {
            assert(FALSE);
            return -6;
            }

        hhDriver->hLineApp = 0;

        // Wait for 10 seconds, if nothing happens, return an error
        //
        for (i=0 ;; ++i)
            {
            if (lineInitialize(&hhDriver->hLineApp, glblQueryDllHinst(),
                            lineCallbackFunc, g_achApp, &hhDriver->dwLineCnt) != 0)
                {
                if (i > 10)
                    {
                    assert(0);
                    return -7;
                    }

                Sleep(1000);    // sleep 1 second
                continue;
                }

            break;
            }
        }

    /* --- Ok, we've reintialized, put settings back now --- */

    if (pvs)
        {
    	LPVOID pv = (BYTE *)pvs + pvs->dwStringOffset;

        if (lineSetDevConfig(hhDriver->dwLine, pv, pvs->dwStringSize,
                             DEVCLASS) != 0)
            {
            assert(FALSE);
            free(pvs);
            pvs = NULL;
            return -8;
            }

        free(pvs);
        pvs = NULL;
        }

    return 0;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  cnctdrvSetDestination
 *
 * DESCRIPTION:
 *	Sets the destination (in this case phone number).
 *
 * ARGUMENTS:
 *	hhDriver    - private driver handle
 *	ach			- string to set
 *	cb			- number of chars in ach
 *
 * RETURNS:
 *  0=OK, <0=error
 *
 */
int WINAPI cnctdrvSetDestination(const HHDRIVER hhDriver, TCHAR * const ach,
								 const size_t cb)
	{
	int len;

	if (hhDriver == 0 || ach == 0 || cb == 0)
		{
		assert(FALSE);
		return -1;
		}

	len = (int) min(cb, sizeof(hhDriver->achDest));
	strncpy(hhDriver->achDest, ach, len);
	hhDriver->achDest[len-1];

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	DoNewModemWizard
 *
 * DESCRIPTION:
 *	Calls up the new modem wizard
 *
 * ARGUMENTS:
 *	hhDriver    - private driver handle
 *  iTimeout    - The timeout length
 *
 * RETURNS:
 *	0=OK,else error
 *
 */
static int DoNewModemWizard(HWND hWnd, int iTimeout)
	{
	PROCESS_INFORMATION stPI;
	STARTUPINFO 		stSI;
    TCHAR               ach[256];
    int                 returnVal = 0;

	// Initialize the STARTUPINFO structure for CreateProcess
	//
	memset(&stSI, 0, sizeof(stSI));
	stSI.cb = sizeof(stSI);
	stSI.dwFlags = STARTF_USESHOWWINDOW;
	stSI.wShowWindow = SW_SHOW;

    // See if we should run the New modem wizard.
    //
    if(mscAskWizardQuestionAgain())
        {
		LoadString(glblQueryDllHinst(), IDS_ER_CNCT_BADLINE, ach, sizeof(ach) / sizeof(TCHAR));

		if (TimedMessageBox(hWnd, ach, 0, MB_YESNO | MB_ICONEXCLAMATION, iTimeout) == IDYES)
			{
            TCHAR  systemDir[MAX_PATH];
            TCHAR  executeString[MAX_PATH * 3];
            TCHAR *pParams = TEXT("\\control.exe\" modem.cpl,,Add");
            UINT   numChars = 0;

            TCHAR_Fill(systemDir, TEXT('\0'), MAX_PATH);
            TCHAR_Fill(executeString, TEXT('\0'), MAX_PATH * 3);
            numChars = GetSystemDirectory(systemDir, MAX_PATH);
            
            if (numChars == 0 || StrCharGetStrLength(systemDir) == 0)
                {
                returnVal = -3;
                }
            else
                {
                if (StrCharGetStrLength(systemDir) + StrCharGetStrLength(pParams) + sizeof(TEXT("\"")) / sizeof(TCHAR) >
                    sizeof(executeString) / sizeof(TCHAR))
                    {
                    returnVal = -2;
                    }
                else
                    {
                    StrCharCopy(executeString, TEXT("\""));
                    StrCharCat(executeString, systemDir);
                    StrCharCat(executeString, pParams);

                    //
	                // Launch the new modem wizard with the command below.
	                //

	                //if (CreateProcess(0, "rundll sysdm.cpl,InstallDevice_Rundll modem,,",
	                //		  0, 0, 0, 0, 0, 0, &stSI, &stPI) == FALSE)
	                //if (CreateProcess(0, "control.exe modem.cpl,,Add",
                    //    0, 0, 0, 0, 0, 0, &stSI, &stPI) == FALSE)
                    if (CreateProcess(NULL, executeString,
 			            NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS,
                        NULL, systemDir, &stSI, &stPI) == FALSE)
		                {
		                #if defined(_DEBUG)
			                {
			                char ach[100];
			                DWORD dw = GetLastError();

			                wsprintf(ach,"CreateProcess (%s, %d) : %x",__FILE__,__LINE__,dw);
			                MessageBox(GetFocus(), ach, "Debug", MB_OK);
			                }
		                #endif

		                returnVal = -1;
		                }
		            else
			            {
			            mscUpdateRegistryValue();
			            }
                    }
			    }
            }
        }
	return returnVal;
	}

int cncttapiGetLineConfig( const DWORD dwLineId, VOID ** ppvs )
    {
    DWORD dwSize;
    LPVARSTRING pvs = (LPVARSTRING)*ppvs;

    if (pvs != NULL)
        {
        assert(FALSE);
        free(pvs);
        pvs = NULL;
        }

    if ((pvs = malloc(sizeof(VARSTRING))) == 0)
    	{
    	assert(FALSE);
    	return -3;
    	}

	memset(pvs, 0, sizeof(VARSTRING));
    pvs->dwTotalSize = sizeof(VARSTRING);
	pvs->dwNeededSize = 0;

    if (lineGetDevConfig(dwLineId, pvs, DEVCLASS) != 0)
    	{
    	assert(FALSE);
    	free(pvs);
  		pvs = NULL;
    	return -4;
    	}

    if (pvs->dwNeededSize > pvs->dwTotalSize)
    	{
    	dwSize = pvs->dwNeededSize;
    	free(pvs);
  		pvs = NULL;

    	if ((pvs = malloc(dwSize)) == 0)
    		{
    		assert(FALSE);
    		return -5;
    		}

		memset(pvs, 0, dwSize);
    	pvs->dwTotalSize = dwSize;

    	if (lineGetDevConfig(dwLineId, pvs, DEVCLASS) != 0)
    		{
    		assert(FALSE);
    		free(pvs);
  			pvs = NULL;
    		return -6;
    		}
    	}

    *ppvs = (VOID *)pvs;
    return 0;
    }

int cncttapiSetLineConfig(const DWORD dwLineId, const HCOM hCom)
    {
    int         retValue = 0;
    LPVARSTRING pvs = NULL;
    PUMDEVCFG   pDevCfg = NULL;
    #if defined(TODO)
    int         iBaudRate;
    #endif // TODO
    int         iDataBits;
    int         iParity;
    int         iStopBits;
    LONG        lLineReturn;

    retValue = cncttapiGetLineConfig( dwLineId, (VOID **) &pvs);

    if (retValue != 0)
        {
        retValue = retValue;
        }

    if (retValue == 0 && pvs == NULL)
        {
        retValue = -7;
        }

    // The structure of the DevConfig block is as follows
    //
    //	VARSTRING
    //	UMDEVCFGHDR
    //	COMMCONFIG
    //	MODEMSETTINGS
    //
    // The UMDEVCFG structure used below is defined in the
    // UNIMODEM.H provided in the platform SDK (in the nih
    // directory for HTPE). REV: 12/01/2000 
    //
    if (retValue == 0)
        {
        pDevCfg = (UMDEVCFG *)((BYTE *)pvs + pvs->dwStringOffset);
        if (pDevCfg == NULL)
            {
            retValue = -8;
            }
        }

    if (retValue == 0 && ComValidHandle(hCom) == FALSE)
        {
        retValue = -9;
        }

    //
    // commconfig struct has a DCB structure we dereference for the
    // com settings.
    //

    //
    // The baud rate should be stored with the COM settings for
    // TAPI devices, but we may want to use the current TAPI device
    // baud rate instead.  We should find a better solution for this.
    // TODO:REV 05/01/2001
    //
    #if defined(TODO)
    if (retValue == 0 && ComGetBaud(hCom, &iBaudRate) != COM_OK)
        {
        retValue = -10;
        }
    #endif // TODO

    if (retValue == 0 && ComGetDataBits(hCom, &iDataBits) != COM_OK)
        {
        retValue = -11;
        }

    if (retValue == 0 && ComGetParity(hCom, &iParity) != COM_OK)
        {
        retValue = -12;
        }

    if (retValue == 0 && ComGetStopBits(hCom, &iStopBits) != COM_OK)
        {
        retValue = -13;
        }

    if (retValue != 0)
        {
        free(pvs);
        pvs = NULL;
        return retValue;
        }

    #if defined(TODO)
    pDevCfg->commconfig.dcb.BaudRate = iBaudRate;
    #endif // TODO
        pDevCfg->commconfig.dcb.ByteSize = (BYTE)iDataBits;
        pDevCfg->commconfig.dcb.Parity =   (BYTE)iParity;
        pDevCfg->commconfig.dcb.StopBits = (BYTE)iStopBits;

    if (iDataBits != 8 && iParity != NOPARITY && iStopBits != ONESTOPBIT)
        {
        ComSetAutoDetect(hCom, FALSE);
        }

    //
    // Actually set the TAPI device's COM settings.
    //
    lLineReturn = lineSetDevConfig(dwLineId, pDevCfg, pvs->dwStringSize, DEVCLASS);

    free(pvs);
    pvs = NULL;

    if (lLineReturn < 0)
        {
		return lLineReturn;
        }

    retValue = cncttapiGetLineConfig( dwLineId, (VOID **) &pvs);

    if (retValue != 0)
        {
        retValue = retValue - 100;
        }

    //
    // Make sure the port settings get updated.
    //
    retValue = ComConfigurePort(hCom);

    //
    // Make sure the status bar contains the correct settings.
    //
    PostMessage(sessQueryHwndStatusbar(hCom->hSession),
                SBR_NTFY_REFRESH, (WPARAM)SBR_COM_PART_NO, 0);

    if (pvs == NULL)
        {
        return -14;
        }

    // The structure of the DevConfig block is as follows
    //
    //	VARSTRING
    //	UMDEVCFGHDR
    //	COMMCONFIG
    //	MODEMSETTINGS
    //
    // The UMDEVCFG structure used below is defined in the
    // UNIMODEM.H provided in the platform SDK (in the nih
    // directory for HTPE). REV: 12/01/2000 
    //
    if (retValue == 0)
        {
        pDevCfg = (UMDEVCFG *)((BYTE *)pvs + pvs->dwStringOffset);

        if (pDevCfg == NULL)
            {
            retValue = -15;
            }
        }

    if (retValue == 0 && (
        #if defined(TODO)
        pDevCfg->commconfig.dcb.BaudRate != iBaudRate ||
        #endif // TODO
	    pDevCfg->commconfig.dcb.ByteSize != iDataBits ||
	    pDevCfg->commconfig.dcb.Parity != iParity ||
	    pDevCfg->commconfig.dcb.StopBits != iStopBits))
        {

        //
        // If this is NT and we are currently connected with
        // a modem, we must disconnect and attempt to redial
        // so that the COM settings are set properly for the
        // modem since this can not be done once a connection
        // has been made. REV: 06/05/2001
        //
        if (IsNT())
            {
            HCNCT hCnct = sessQueryCnctHdl(hCom->hSession);
            if (hCnct)
                {
                int iStatus = cnctQueryStatus(hCnct);

                if (iStatus != CNCT_STATUS_FALSE &&
                    iStatus != CNCT_BAD_HANDLE &&
                    cnctIsModemConnection(hCnct) == 1)
                    {
                    HWND hWnd = sessQueryHwnd(hCom->hSession);
                    int nDisconnect = IDYES;

                    //
                    // Don't prompt if this is NT_EDITION, just do the
                    // disconnection quietly and attempt to reconnect.
                    //
                    #if !defined(NT_EDITION)
                    TCHAR ach[256];

                    TCHAR_Fill(ach, TEXT('\0'), sizeof(ach) / sizeof(TCHAR));

                    //
                    // Prompt to disconnect current connection due to TAPI
                    // device needing to be reset. REV: 05/31/2001
                    //
                    LoadString(glblQueryDllHinst(), IDS_ER_TAPI_NEEDS_RESET, ach, sizeof(ach) / sizeof(TCHAR));

                    nDisconnect =
                        TimedMessageBox(hWnd, ach, NULL,
                                        MB_YESNO | MB_ICONEXCLAMATION | MB_TASKMODAL,
                                        sessQueryTimeout(hCom->hSession));
                    #endif //NT_EDITION

                    if (nDisconnect == IDYES || nDisconnect == -1)
                        {
                        retValue = -16;
                        }
                    }
                } // hCnct
            } // IsNT()
        }

    free(pvs);
    pvs = NULL;

    return retValue;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\cncttapi\dialdlg.c ===
/*	File: D:\WACKER\cncttapi\dialdlg.c (Created: 23-Mar-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 2/05/99 3:19p $
 */

#define TAPI_CURRENT_VERSION 0x00010004     // cab:11/14/96 - required!

#include <tapi.h>
#pragma hdrstop

#include <time.h>

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\tdll.h>
#include <tdll\misc.h>
#include <tdll\assert.h>
#include <tdll\cnct.h>
#include <tdll\globals.h>
#include <term\res.h>

#include "cncttapi.hh"
#include "cncttapi.h"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	DialingDlg
 *
 * DESCRIPTION:
 *	Dialing dialog.
 *
 * ARGUMENTS:
 *	Standard dialog arguments
 *
 * RETURNS:
 *	BOOL
 *
 */
INT_PTR CALLBACK DialingDlg(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar)
	{
	#define TB_SESSION	  103
	#define TB_TELEPHONE  104
	#define TB_MODEM	  105
	#define TB_DIALICON   101
	#define TB_STATUS	  110

	HHDRIVER hhDriver;
	TCHAR ach[256];
    TCHAR achFmt[100];

	switch (uMsg)
		{
	case WM_INITDIALOG:
		SetWindowLongPtr(hwnd, DWLP_USER, lPar);
		hhDriver = (HHDRIVER)lPar;
		mscCenterWindowOnWindow(hwnd, sessQueryHwnd(hhDriver->hSession));

		SendDlgItemMessage(hwnd, TB_DIALICON, STM_SETICON,
				(WPARAM)sessQueryIcon(hhDriver->hSession), 0);

		sessQueryName(hhDriver->hSession, ach, sizeof(ach));
		SetDlgItemText(hwnd, TB_SESSION, ach);

		SetDlgItemText(hwnd, TB_TELEPHONE, hhDriver->achDisplayableDest);
		SetDlgItemText(hwnd, TB_MODEM, hhDriver->achLineName);
		break;

	case WM_SHOWWINDOW:
		if (wPar == TRUE)
			EnableDialNow(hwnd, FALSE);
		break;

	case WM_USER+0x100: // Got connection.  Close the dialog.
		EndModelessDialog(hwnd);
		break;

	case WM_USER+0x101: // Dialing message.  Display requested string in status.
		hhDriver = (HHDRIVER)GetWindowLongPtr(hwnd, DWLP_USER);

		if (LoadString(glblQueryDllHinst(), (UINT)wPar, ach,
				sizeof(ach) / sizeof(TCHAR)) == 0)
			{
			assert(FALSE);
            break;
			}

        DbgOutStr("%s\r\n", ach, 0, 0, 0, 0);
		SetDlgItemText(hhDriver->hwndCnctDlg, TB_STATUS, ach);

		break;

	case WM_COMMAND:
		switch (wPar)
			{
		case IDOK: // Dial Now
			hhDriver = (HHDRIVER)GetWindowLongPtr(hwnd, DWLP_USER);
            hhDriver->iRedialCnt = 0;
            KillTimer(hwnd, 1);

			cnctdrvDisconnect(hhDriver,
				CNCT_DIALNOW | CNCT_NOCONFIRM | DISCNCT_NOBEEP);

			break;

		case IDCANCEL:
			hhDriver = (HHDRIVER)GetWindowLongPtr(hwnd, DWLP_USER);
			cnctdrvDisconnect(hhDriver, DISCNCT_NOBEEP);
			EndModelessDialog(hwnd);
			hhDriver->hwndCnctDlg = 0;	// important, so we create another
            KillTimer(hwnd, 1);
			break;

		default:
			return FALSE;
			}
		break;

    case WM_TIMER:
		hhDriver = (HHDRIVER)GetWindowLongPtr(hwnd, DWLP_USER);

        if (--hhDriver->iRedialSecsRemaining > 0)
            {
    		LoadString(glblQueryDllHinst(), IDS_DIAL_REDIAL_IN, achFmt,
	    	    sizeof(achFmt) / sizeof(TCHAR));

            wsprintf(ach, achFmt, hhDriver->iRedialSecsRemaining);
          	SetDlgItemText(hhDriver->hwndCnctDlg, TB_STATUS, ach);
            }

        else
            {
		    PostMessage(sessQueryHwnd(hhDriver->hSession), WM_CNCT_DIALNOW,
			    hhDriver->uDiscnctFlags, 0);
            }

        break;
	default:
		return FALSE;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	DialingMessage
 *
 * DESCRIPTION:
 *	Gets the given string ID from term's resource file and displays it
 *	in the dialing dialog.
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle
 *	resID		- ID of resource.
 *
 * RETURNS:
 *	void
 *
 */
void DialingMessage(const HHDRIVER hhDriver, const int resID)
	{
	if (!IsWindow(hhDriver->hwndCnctDlg))
		return;

	PostMessage(hhDriver->hwndCnctDlg, WM_USER+0x101, (WPARAM)resID, 0);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	EnableDialNow
 *
 * DESCRIPTION:
 *	Enables/Disables dial now button.
 *
 * ARGUMENTS:
 *	hwndDlg - dial dialog window handle
 *	fEnable - TRUE/FALSE
 *
 * RETURNS:
 *	void
 *
 */
void EnableDialNow(const HWND hwndDlg, const int fEnable)
	{
	if (IsWindow(hwndDlg))
		{
		EnableWindow(GetDlgItem(hwndDlg, IDOK), fEnable);

		if (fEnable == FALSE)
			SetFocus(GetDlgItem(hwndDlg,IDCANCEL));
		else
			SetFocus(GetDlgItem(hwndDlg, IDOK));
		}

	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\cncttapi\cnfrmdlg.c ===
/*      File: D:\WACKER\cncttapi\cnfrmdlg.c (Created: 23-Mar-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 9 $
 *	$Date: 2/02/01 3:52p $
 */

#define TAPI_CURRENT_VERSION 0x00010004     // cab:11/14/96 - required!

#include <tapi.h>
#pragma hdrstop

#include <prsht.h>
#include <time.h>

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\tdll.h>
#include <tdll\misc.h>
#include <tdll\mc.h>
#include <tdll\assert.h>
#include <tdll\errorbox.h>
#include <tdll\cnct.h>
#include <tdll\hlptable.h>
#include <tdll\globals.h>
#include <tdll\property.h>
#include <term\res.h>
#include <tdll\open_msc.h>
#include <tdll\statusbr.h>
#include <tdll\htchar.h>

#include "cncttapi.hh"
#include "cncttapi.h"

static void InitConfirmDlg(const HWND hwnd, const HHDRIVER hhDriver);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	ConfirmDlg
 *
 * DESCRIPTION:
 *	Displays dialog confirming user's choices for the requested connect.
 *	Assumes that EnumerateLines() and TranslateAddress() have been called.
 *
 * ARGUMENTS:
 *	Standard dialog
 *
 * RETURNS:
 *	Standard dialog
 *
 */
INT_PTR CALLBACK ConfirmDlg(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar)
	{
	#define IDC_TF_LOCATION 107
	#define CB_LOCATION 	108
	#define PB_EDIT_NEW 	109
    #define IDI_ICON        102
    #define IDC_TF_PHONE    104
	#define TB_PHONE		105
	#define TB_CARD 		110
	#define IDC_TF_CARD     111
	#define TB_SESSNAME 	103
	#define PB_MODIFY		106
	#define PB_DIAL			117

    TCHAR   ach[128];
	TCHAR   ach2[256];
	int i;
	long lRet;
	LRESULT lr;
	HHDRIVER hhDriver;
	static	DWORD aHlpTable[] = {	CB_LOCATION,	 IDH_TERM_DIAL_LOCATION,
									IDC_TF_LOCATION, IDH_TERM_DIAL_LOCATION,
									IDC_TF_PHONE,	 IDH_TERM_DIAL_PHONENUMBER,
									TB_PHONE,		 IDH_TERM_DIAL_PHONENUMBER,
									TB_CARD,		 IDH_TERM_DIAL_CALLING_CARD,
									IDC_TF_CARD,	 IDH_TERM_DIAL_CALLING_CARD,
									PB_MODIFY,		 IDH_TERM_DIAL_MODIFY,
									PB_EDIT_NEW,	 IDH_TERM_DIAL_EDITNEW,
									PB_DIAL,		 IDH_TERM_DIAL_DIAL,
                                    IDCANCEL,        IDH_CANCEL,
									0,0};
	switch (uMsg)
		{
	case WM_INITDIALOG:
		SetWindowLongPtr(hwnd, DWLP_USER, lPar);
		hhDriver = (HHDRIVER)lPar;
		mscCenterWindowOnWindow(hwnd, sessQueryHwnd(hhDriver->hSession));

		if ((lRet = TranslateAddress(hhDriver)) != 0)
			{
			if (lRet == LINEERR_INIFILECORRUPT)
				{
				PostMessage(hwnd, WM_COMMAND,
					MAKEWPARAM(PB_EDIT_NEW, BN_CLICKED), (LPARAM)hwnd);
				}
			}

		InitConfirmDlg(hwnd, hhDriver);

		EnumerateTapiLocations(hhDriver, GetDlgItem(hwnd, CB_LOCATION),
			GetDlgItem(hwnd, TB_CARD));

		break;

	case WM_CONTEXTMENU:
		doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		break;

	case WM_HELP:
        doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_COMMAND:
		switch (LOWORD(wPar))
			{
		case PB_DIAL:
            GetDlgItemText(hwnd, TB_PHONE, ach, sizeof(ach)/sizeof(TCHAR));

			if (strcmp(ach, TEXT("")) != 0)
				{
				hhDriver = (HHDRIVER)GetWindowLongPtr(hwnd, DWLP_USER);

				if (hhDriver->achDialableDest[0] != TEXT('\0') &&
				    hhDriver->achCanonicalDest[0] != TEXT('\0') )
					{
					EndDialog(hwnd, TRUE);
					}
				else
					{
    				LoadString(glblQueryDllHinst(), IDS_ER_CNCT_BADADDRESS,
							   ach, sizeof(ach)/sizeof(TCHAR));
					LoadString(glblQueryDllHinst(), IDS_GNRL_APPNAME, ach2,
							   sizeof(ach2)/sizeof(TCHAR));
					MessageBox(hwnd, ach, ach2, MB_OK);
					}
				}
            else
                {
    			LoadString(glblQueryDllHinst(), 40808, ach,
					       sizeof(ach)/sizeof(TCHAR));
				LoadString(glblQueryDllHinst(), IDS_GNRL_APPNAME, ach2,
					       sizeof(ach2)/sizeof(TCHAR));
                MessageBox(hwnd, ach, ach2, MB_OK);
                }

			break;

		case IDCANCEL:
			EndDialog(hwnd, FALSE);
			break;

		case PB_EDIT_NEW:
			hhDriver = (HHDRIVER)GetWindowLongPtr(hwnd, DWLP_USER);

			lineTranslateDialog(hhDriver->hLineApp, hhDriver->dwLine,
				TAPI_VER, hwnd, hhDriver->achCanonicalDest);

			EnumerateTapiLocations(hhDriver, GetDlgItem(hwnd, CB_LOCATION),
				GetDlgItem(hwnd, TB_CARD));

			if (TranslateAddress(hhDriver) == 0)
				InitConfirmDlg(hwnd, hhDriver);

			break;

		case PB_MODIFY:
			hhDriver = (HHDRIVER)GetWindowLongPtr(hwnd, DWLP_USER);

			EnableWindow(GetDlgItem(hwnd, PB_MODIFY), FALSE);
			DoInternalProperties(hhDriver->hSession,
				hwnd);

			// Fix for the statusbar was not updating when the
			// session's properties were modified when the
			// Dial Confirm dialog.  We now update the statusbar
			// when we return from DoInternalProperties() so that
			// the status bar is correct. REV: 11/08/2000
			//
			PostMessage(sessQueryHwndStatusbar(hhDriver->hSession), SBR_NTFY_REFRESH,
				(WPARAM)SBR_ALL_PARTS, 0);

			if ( IsNT() )
				{
				EnumerateLinesNT(hhDriver, 0);
				}
			else
				{
				EnumerateLines(hhDriver, 0);
				}

			lRet = TranslateAddress(hhDriver);
			if (lRet == 0 || lRet == LINEERR_INVALADDRESS)
				{
				InitConfirmDlg(hwnd, hhDriver);
				}

			EnableWindow(GetDlgItem(hwnd, PB_MODIFY), TRUE);
            SetFocus(GetDlgItem(hwnd, PB_MODIFY));
			break;

		case CB_LOCATION:
			if (HIWORD(wPar) == CBN_SELENDOK)
				{
				hhDriver = (HHDRIVER)GetWindowLongPtr(hwnd, DWLP_USER);

				if ((i = (int)SendDlgItemMessage(hwnd, CB_LOCATION, CB_GETCURSEL,
						0, 0)) != CB_ERR)
					{
					lr = SendDlgItemMessage(hwnd, CB_LOCATION, CB_GETITEMDATA,
						(WPARAM)i, 0);

					if (lr != CB_ERR)
						{
						if (lineSetCurrentLocation(hhDriver->hLineApp,
								(DWORD)lr) == 0)
							{
							// Leave the hwndCB (second paramater) zero.
							// Otherwise we go into and infinite message loop

							EnumerateTapiLocations(hhDriver, 0,
								GetDlgItem(hwnd, TB_CARD));

							if (TranslateAddress(hhDriver) == 0)
								InitConfirmDlg(hwnd, hhDriver);
							}
						}
					}
				}
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	InitConfirmDlg
 *
 * DESCRIPTION:
 *	Used to initialize some fields in the Confirmation dialog.
 *
 * ARGUMENTS:
 *	hwnd		- confirmation dialog
 *	hhDriver	- private driver handle.
 *
 * RETURNS:
 *	void
 *
 */
static void InitConfirmDlg(const HWND hwnd, const HHDRIVER hhDriver)
	{
	TCHAR ach[512];

	SendDlgItemMessage(hwnd, 101, STM_SETICON,
			(WPARAM)sessQueryIcon(hhDriver->hSession), 0);

	sessQueryName(hhDriver->hSession, ach, sizeof(ach));
	mscModifyToFit(GetDlgItem(hwnd, TB_SESSNAME), ach);
	SetDlgItemText(hwnd, TB_SESSNAME, ach);

	if (hhDriver->achDialableDest[0] == TEXT('\0'))
		{
		// We need to disable the Dial button here if there is not
		// a valid dialable destination.  REV: 10/23/2000
		//
		EnableDial(hwnd, FALSE);

		LoadString(glblQueryDllHinst(), IDS_ER_CNCT_BADADDRESS2, ach,
    		       sizeof(ach)/sizeof(TCHAR));
		SetDlgItemText(hwnd, TB_PHONE, ach);
		}
	else
		{
		EnableDial(hwnd, TRUE);
		SetDlgItemText(hwnd, TB_PHONE, hhDriver->achDisplayableDest);
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TranslateAddress
 *
 * DESCRIPTION:
 *	Translates the country code, area code, phone number into canonical
 *	format and then lets tapi translate it into the final dialable format.
 *	What is canonical format you say?
 *
 *	+Country Code SPACE [Area Code] SPACE Subscriber Number
 *
 *	Assumes EnumerateLines() has been called and a default device was
 *	selected.
 *
 * ARGUMENTS:
 *	hhDriver	- private connection driver handle
 *
 * RETURNS:
 *	0=OK
 *
 */
long TranslateAddress(const HHDRIVER hhDriver)
	{
	LONG lRet = 1;
	DWORD dwSize;
	TCHAR ach[100];
	LPLINECOUNTRYLIST pcl=NULL;
	LPLINECOUNTRYENTRY pce;
	LINETRANSLATEOUTPUT *pLnTransOutput;

	if (hhDriver == 0)
		{
		assert(FALSE);
		return -1;
		}

	if (CheckHotPhone(hhDriver, hhDriver->dwLine, &hhDriver->fHotPhone) != 0)
		return -1;	// error message displayed already.

	// Hot Phone is TAPI terminology for Direct Connects
	// We don't need to do address translation since we
	// not going to use it.

	if (hhDriver->fHotPhone)
		{
		hhDriver->achDialableDest[0] = TEXT('\0');
		hhDriver->achDisplayableDest[0] = TEXT('\0');
		return 0;
		}

	ach[0] = TEXT('\0'); // initialize the string!

	// If we not using the country code or area code, we don't want
	// or need TAPI's line translation.	 Just copy the destination
	// as the user entered it in the phonenumber field.
	//
	if (hhDriver->fUseCCAC)
		{
		/* --- Do lineGetCountry to get extension --- */

		if (DoLineGetCountry(hhDriver->dwCountryID, hhDriver->dwAPIVersion,
			&pcl) != 0)
			{
			assert(FALSE);
			return 2;
			}

		if ((pce = (LPLINECOUNTRYENTRY)
			((BYTE *)pcl + pcl->dwCountryListOffset)) == 0)
			{
			assert(FALSE);
			return 3;
			}

		/* --- Put country code in now --- */

		wsprintf(ach, "+%u ", pce->dwCountryCode);
		free(pcl);
		pcl = NULL;

		/* --- Area code ---*/

		#if 0 // mrw:4/20/95 (see phonedlg.c)
		if (hhDriver->achAreaCode[0])  &&
			fCountryUsesAreaCode(hhDriver->dwCountryID,
			hhDriver->dwAPIVersion))
		#endif
			if (!fIsStringEmpty(hhDriver->achAreaCode))
			{
			StrCharCat(ach, TEXT("("));
			StrCharCat(ach, hhDriver->achAreaCode);
			StrCharCat(ach, TEXT(") "));
			}
		}

	lstrcat(ach, hhDriver->achDest);

	/* --- Allocate some space --- */

	pLnTransOutput = malloc(sizeof(LINETRANSLATEOUTPUT));

	if (pLnTransOutput == 0)
		{
		assert (FALSE);
		return 4;
		}

	pLnTransOutput->dwTotalSize = sizeof(LINETRANSLATEOUTPUT);

	/* --- Now that we've satisifed the clergy, translate it --- */

	if ((lRet = TRAP(lineTranslateAddress(hhDriver->hLineApp,
			hhDriver->dwLine, TAPI_VER, ach, 0,
				LINETRANSLATEOPTION_CANCELCALLWAITING,
					pLnTransOutput))) != 0)
		{
		free(pLnTransOutput);
		pLnTransOutput = NULL;
		return lRet;
		}

	if (pLnTransOutput->dwTotalSize < pLnTransOutput->dwNeededSize)
		{
		dwSize = pLnTransOutput->dwNeededSize;
		free(pLnTransOutput);
		pLnTransOutput = NULL;

		if ((pLnTransOutput = malloc(dwSize)) == 0)
			{
			assert(FALSE);
			return 5;
			}

		pLnTransOutput->dwTotalSize = dwSize;

		if ((lRet = TRAP(lineTranslateAddress(hhDriver->hLineApp,
				hhDriver->dwLine, TAPI_VER, ach, 0,
					LINETRANSLATEOPTION_CANCELCALLWAITING,
						pLnTransOutput))) != 0)
			{
			assert(FALSE);
			free(pLnTransOutput);
			pLnTransOutput = NULL;
			return lRet;
			}
		}

	/* --- At last, some strings to throw at the modem --- */

	lstrcpy(hhDriver->achDialableDest,
		(LPSTR)pLnTransOutput + pLnTransOutput->dwDialableStringOffset);

	lstrcpy(hhDriver->achDisplayableDest,
		(LPSTR)pLnTransOutput + pLnTransOutput->dwDisplayableStringOffset);

	hhDriver->dwCountryCode = pLnTransOutput->dwDestCountry;
	lstrcpy(hhDriver->achCanonicalDest, ach);

	free(pLnTransOutput);
	pLnTransOutput = NULL;
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	CheckHotPhone
 *
 * DESCRIPTION:
 *	Checks to see if the selected line is a hot phone (ie. direct connect
 *	that requires no dialing).
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle.
 *	dwLine		- line to test
 *	pfHotPhone	- result
 *
 * RETURNS:
 *	0=OK
 *
 */
int CheckHotPhone(const HHDRIVER hhDriver, const DWORD dwLine, int *pfHotPhone)
	{
	DWORD	dw;
	LPLINEADDRESSCAPS pac = 0;

	if (hhDriver == 0)
		return -6;

	/* --- Get Address caps to determine line type --- */

	if ((pac = (LPLINEADDRESSCAPS)malloc(sizeof(*pac))) == 0)
		{
		return -1;
		}

	pac->dwTotalSize = sizeof(*pac);

	if (lineGetAddressCaps(hhDriver->hLineApp, dwLine, 0, TAPI_VER, 0,
			pac) != 0)
		{
		free(pac);
		pac = NULL;
		return -2;
		}

	if (pac->dwNeededSize > pac->dwTotalSize)
		{
		dw = pac->dwNeededSize;
		free(pac);
		pac = NULL;

		if ((pac = (LPLINEADDRESSCAPS)malloc(dw)) == 0)
			{
			return -3;
			}

		pac->dwTotalSize = dw;

		if (lineGetAddressCaps(hhDriver->hLineApp, dwLine,
				0, TAPI_VER, 0, pac) != 0)
			{
			free(pac);
			pac = NULL;
			return -4;
			}
		}

	*pfHotPhone = !(pac->dwAddrCapFlags & LINEADDRCAPFLAGS_DIALED);
	free(pac);
	pac = NULL;
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	EnableDial
 *
 * DESCRIPTION:
 *	Enables/Disables Dial button.
 *
 * ARGUMENTS:
 *	hwndDlg - dial dialog window handle
 *	fEnable - TRUE/FALSE
 *
 * RETURNS:
 *	void
 *
 */
void EnableDial(const HWND hwndDlg, const BOOL fEnable)
	{
	if (IsWindow(hwndDlg))
		{
		EnableWindow(GetDlgItem(hwndDlg, PB_DIAL), fEnable);

		if (fEnable == FALSE)
			{
			SetFocus(GetDlgItem(hwndDlg,PB_MODIFY));
			}
		else
			{
			SetFocus(GetDlgItem(hwndDlg, PB_DIAL));
			}
		}

	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\cncttapi\tapidlgs.c ===
/*	File: D:\WACKER\cncttapi\tapidlgs.c (Created: 13-Feb-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:55p $
 */

Nope, can't use this anymore...
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\cncttapi\phonedlg.c ===
/*      File: D:\WACKER\cncttapi\phonedlg.c (Created: 23-Mar-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 16 $
 *	$Date: 5/01/01 3:44p $
 */

#define TAPI_CURRENT_VERSION 0x00010004     // cab:11/14/96 - required!

#include <tapi.h>
#include <unimodem.h>
#pragma hdrstop

#include <prsht.h>
#include <shlobj.h>
#include <time.h>

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\tdll.h>
#include <tdll\misc.h>
#include <tdll\mc.h>
#include <tdll\com.h>
#include <tdll\assert.h>
#include <tdll\errorbox.h>
#include <tdll\cnct.h>
#include <tdll\hlptable.h>
#include <tdll\globals.h>
#include <tdll\property.h>
#include <tdll\htchar.h>
#include <term\res.h>
#include <tdll\open_msc.h>
#if defined(INCL_MINITEL)
#include "emu\emu.h"
#endif // INCL_MINITEL

#include "cncttapi.hh"
#include "cncttapi.h"

STATIC_FUNC int tapi_SAVE_NEWPHONENUM(HWND hwnd);
STATIC_FUNC LRESULT tapi_WM_NOTIFY(const HWND hwnd, const int nId);
STATIC_FUNC void EnableCCAC(const HWND hwnd);
STATIC_FUNC void ModemCheck(const HWND hwnd);
static int ValidatePhoneDlg(const HWND hwnd);
static int CheckWindow(const HWND hwnd, const int id);
static int VerifyAddress(const HWND hwnd);
STATIC_FUNC int wsck_SAVE_NEWIPADDR(HWND hwnd);

// Local structure...
// Put in whatever else you might need to access later
//
typedef struct SDS
	{

	HSESSION 	hSession;
	HDRIVER		hDriver;

	// Store these so that we can restore the values if the user cancels
	// the property sheet.
	//
	TCHAR		acSessNameCopy[256];
	int			nIconID;
	HICON		hIcon;
	//HICON 	  hLittleIcon;

	} SDS, *pSDS;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	NewPhoneDlg
 *
 * DESCRIPTION:
 *	Displays dialog for getting new connection phone number and info.
 *
 *  NOTE:  Since this dialog proc is also called by the property sheet's
 *	phone number tab dialog it has to assume that the lPar contains the
 *	LPPROPSHEETPAGE.
 *
 * ARGUMENTS:
 *	Standard dialog
 *
 * RETURNS:
 *	Standard dialog
 *
 */
INT_PTR CALLBACK NewPhoneDlg(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar)
	{
	/*
	 * NOTE: these defines must match the templates in both places, here and
	 *       int term\dialogs.rc
	 */
	#define IDC_TF_CNTRYCODES	113
	#define IDC_TF_AREACODES    106
	#define IDC_TF_MODEMS       110
	#define IDC_TF_PHONENUM     108
	
	#define IDC_IC_ICON			101
	#define IDC_CB_CNTRYCODES   114
	#define IDC_EB_AREACODE		107
	#define IDC_EB_PHONENUM 	109
	#define IDC_CB_MODEMS		111
	
	#define IDC_TB_NAME 		103
	#define IDC_PB_EDITICON 	117
	#define IDC_PB_CONFIGURE	115
	#define IDC_XB_USECCAC		116
    #define IDC_XB_REDIAL       119

    #define IDC_EB_HOSTADDR     214
    #define IDC_TF_PHONEDETAILS 105
    #define IDC_TF_TCPIPDETAILS 205
    #define IDC_TF_HOSTADDR     213
    #define IDC_TF_PORTNUM      206
    #define IDC_EB_PORTNUM      207
    #define IDC_TF_ACPROMPT     118

	HWND	    hwndParent;
	HHDRIVER    hhDriver;
	TCHAR	    ach[256];
	TCHAR 	    acNameCopy[256];
	int 	    i;
	PSTLINEIDS  pstLineIds = NULL;
    TCHAR       achSettings[100];

	static 	 DWORD aHlpTable[] = {IDC_CB_CNTRYCODES, IDH_TERM_NEWPHONE_COUNTRY,
								  IDC_TF_CNTRYCODES, IDH_TERM_NEWPHONE_COUNTRY,
								  IDC_EB_AREACODE,	 IDH_TERM_NEWPHONE_AREA,
								  IDC_TF_AREACODES,  IDH_TERM_NEWPHONE_AREA,
								  IDC_EB_PHONENUM,	 IDH_TERM_NEWPHONE_NUMBER,
								  IDC_TF_PHONENUM,   IDH_TERM_NEWPHONE_NUMBER,
								  IDC_PB_CONFIGURE,  IDH_TERM_NEWPHONE_CONFIGURE,
								  IDC_TF_MODEMS,     IDH_TERM_NEWPHONE_DEVICE,
								  IDC_CB_MODEMS,	 IDH_TERM_NEWPHONE_DEVICE,
								  IDC_PB_EDITICON,	 IDH_TERM_PHONEPROP_CHANGEICON,
                                  IDC_XB_USECCAC,    IDH_TERM_NEWPHONE_USECCAC,
                                  IDC_XB_REDIAL,     IDH_TERM_NEWPHONE_REDIAL,
								  IDC_EB_HOSTADDR,   IDH_TERM_NEWPHONE_HOSTADDRESS,
								  IDC_TF_HOSTADDR,   IDH_TERM_NEWPHONE_HOSTADDRESS,
								  IDC_EB_PORTNUM,    IDH_TERM_NEWPHONE_PORTNUMBER,
								  IDC_TF_PORTNUM,    IDH_TERM_NEWPHONE_PORTNUMBER,
                                  IDCANCEL,                           IDH_CANCEL,
                                  IDOK,                               IDH_OK,
								  0,0,
								  };
	pSDS	 pS = NULL;

	switch (uMsg)
		{
	case WM_INITDIALOG:
		pS = (SDS *)malloc(sizeof(SDS));

		if (pS == (SDS *)0)
			{
			assert(FALSE);
			EndDialog(hwnd, FALSE);
			break;
			}

		// In the effort to keep the internal driver handle internal
		// we are passing the session handle from the property sheet tab
		// dialog.
		//
		pS->hSession = (HSESSION)(((LPPROPSHEETPAGE)lPar)->lParam);

		pS->hDriver = cnctQueryDriverHdl(sessQueryCnctHdl(pS->hSession));
		hhDriver = (HHDRIVER)(pS->hDriver);

		SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)pS);

		// In order to center the property sheet we need to center the parent
		// of the hwnd on top of the session window.
		// If the parent of hwnd is the session window then this dialog has
		// not been called from the property sheet.
		//
		hwndParent = GetParent(hwnd);

		if (hwndParent != sessQueryHwnd(pS->hSession))
			mscCenterWindowOnWindow(hwndParent, sessQueryHwnd(pS->hSession));

		else
			mscCenterWindowOnWindow(hwnd, sessQueryHwnd(pS->hSession));

		// Display the session icon...
		//
		pS->nIconID = sessQueryIconID(hhDriver->hSession);
		pS->hIcon = sessQueryIcon(hhDriver->hSession);
		//pS->hLittleIcon = sessQueryLittleIcon(hhDriver->hSession);

		SendDlgItemMessage(hwnd, IDC_IC_ICON, STM_SETICON,
			(WPARAM)pS->hIcon, 0);

		/* --- Need to initialize TAPI if not already done --- */

		if (hhDriver->hLineApp == 0)
			{
            extern const TCHAR *g_achApp;

			if (lineInitialize(&hhDriver->hLineApp, glblQueryDllHinst(),
					lineCallbackFunc, g_achApp, &hhDriver->dwLineCnt))
				{
				assert(FALSE);
				}
			}

		SendDlgItemMessage(hwnd, IDC_EB_PHONENUM, EM_SETLIMITTEXT,
			sizeof(hhDriver->achDest)-1, 0);

		SendDlgItemMessage(hwnd, IDC_EB_AREACODE, EM_SETLIMITTEXT,
			sizeof(hhDriver->achAreaCode)-1, 0);

		if (hhDriver->achDest[0])
			SetDlgItemText(hwnd, IDC_EB_PHONENUM, hhDriver->achDest);

#if defined(INCL_WINSOCK)
		SendDlgItemMessage(hwnd, IDC_EB_HOSTADDR, EM_SETLIMITTEXT,
			sizeof(hhDriver->achDestAddr)-1, 0);

		if (hhDriver->achDestAddr[0])
			SetDlgItemText(hwnd, IDC_EB_HOSTADDR, hhDriver->achDestAddr);

		wsprintf(ach, "%d", hhDriver->iPort);
		SetDlgItemText(hwnd, IDC_EB_PORTNUM, ach);
#endif

		TCHAR_Fill(pS->acSessNameCopy, TEXT('\0'),
			sizeof(pS->acSessNameCopy) / sizeof(TCHAR));

		sessQueryName(hhDriver->hSession, pS->acSessNameCopy,
			sizeof(pS->acSessNameCopy));

		TCHAR_Fill(ach, TEXT('\0'), sizeof(ach) / sizeof(TCHAR));
		lstrcpy(ach, pS->acSessNameCopy);
		mscModifyToFit(GetDlgItem(hwnd, IDC_TB_NAME), ach);
		SetDlgItemText(hwnd, IDC_TB_NAME, ach);

		EnumerateCountryCodes(hhDriver, GetDlgItem(hwnd, IDC_CB_CNTRYCODES));
		EnumerateAreaCodes(hhDriver, GetDlgItem(hwnd, IDC_EB_AREACODE));
		if ( IsNT() )
			{
			EnumerateLinesNT(hhDriver, GetDlgItem(hwnd, IDC_CB_MODEMS));
			}
		else
			{	
			EnumerateLines(hhDriver, GetDlgItem(hwnd, IDC_CB_MODEMS));
			}

		//mpt 6-23-98 disable the port list drop-down if we are connected
		EnableWindow(GetDlgItem(hwnd, IDC_CB_MODEMS),
			cnctdrvQueryStatus(hhDriver) == CNCT_STATUS_FALSE);

		if (hhDriver->fUseCCAC) 	// Use country code and area code?
			{
			CheckDlgButton(hwnd, IDC_XB_USECCAC, TRUE);
			SetFocus(GetDlgItem(hwnd, IDC_EB_PHONENUM));
			}

        #if defined(INCL_REDIAL_ON_BUSY)
        if (hhDriver->fRedialOnBusy)
            {
			CheckDlgButton(hwnd, IDC_XB_REDIAL, TRUE);
			SetFocus(GetDlgItem(hwnd, IDC_EB_PHONENUM));
            }
        #endif

		// Call after Use CCAC checkbox checked or unchecked.
		//
		EnableCCAC(hwnd);
		ModemCheck(hwnd);

		/* --- Pick which control to give focus too --- */

		if (hhDriver->fUseCCAC)		// Use country code and area code?
			{
			
			if (SendDlgItemMessage(hwnd, IDC_CB_CNTRYCODES, CB_GETCURSEL,
					0, 0) == CB_ERR)
				{
				SetFocus(GetDlgItem(hwnd, IDC_CB_CNTRYCODES));
				}

			else if (GetDlgItemText(hwnd, IDC_EB_AREACODE, ach,
					sizeof(ach)) == 0)
				{
				SetFocus(GetDlgItem(hwnd, IDC_EB_AREACODE));
				}
			}

		// If we have an old session and we have not matched our stored
		// permanent line id, then pop-up a message saying the TAPI
		// configuration has changed.
		//
		if (!hhDriver->fMatchedPermanentLineID &&
				hhDriver->dwPermanentLineId != (DWORD)-1)
			{
			LoadString(glblQueryDllHinst(), IDS_ER_TAPI_CONFIG,
				ach, sizeof(ach) / sizeof(TCHAR));

			TimedMessageBox(hwnd, ach, 0, MB_OK | MB_ICONINFORMATION, 0);
			}

		return 0;

	case WM_CONTEXTMENU:
        doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		break;

	case WM_HELP:
        doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_DESTROY:
		// OK, now we know that we are actually leaving the dialog for good, so
		// free the storage...
		//
		pS = (pSDS)GetWindowLongPtr(hwnd, DWLP_USER);
		if (pS)
			{
			free(pS);
			pS = NULL;
			}

		ResetComboBox(GetDlgItem(hwnd, IDC_CB_MODEMS));
		break;

	case WM_NOTIFY:
		//
		// Property sheet messages are being channeled through here...
		//
		return tapi_WM_NOTIFY(hwnd, (int)((NMHDR *)lPar)->code);

	case WM_COMMAND:
		switch (LOWORD(wPar))
			{
		case IDC_CB_CNTRYCODES:
			if (HIWORD(wPar) == CBN_SELENDOK)
				EnableCCAC(hwnd);
			break;

		case IDC_CB_MODEMS:
			if (HIWORD(wPar) == CBN_SELENDOK)
				ModemCheck(hwnd);

			break;

		//
		// Property sheet's TAB_PHONENUMBER dialog is using this dialog proc
		// also, the following two buttons appear only in this tabbed dialog
		// template.
		//
		case IDC_PB_EDITICON:
			{
			pS = (pSDS)GetWindowLongPtr(hwnd, DWLP_USER);

			sessQueryName(pS->hSession, acNameCopy, sizeof(acNameCopy));

			if (DialogBoxParam(glblQueryDllHinst(),
				MAKEINTRESOURCE(IDD_NEWCONNECTION),
					hwnd, NewConnectionDlg,
						(LPARAM)pS->hSession) == FALSE)
				{
				return 0;
				}

			SetFocus(GetDlgItem(hwnd, IDC_PB_EDITICON));
			ach[0] = TEXT('\0');
			sessQueryName(pS->hSession, ach, sizeof(ach));
			mscModifyToFit(GetDlgItem(hwnd, IDC_TB_NAME), ach);
			SetDlgItemText(hwnd, IDC_TB_NAME, ach);

			SendDlgItemMessage(hwnd, IDC_IC_ICON, STM_SETICON,
				(WPARAM)sessQueryIcon(pS->hSession), 0);

			// The user may have changed the name of the session.
			// The new name should be reflected in the property sheet title
			// and in the app title.
			//
			propUpdateTitle(pS->hSession, hwnd, acNameCopy);
			}
			break;

		case IDC_PB_CONFIGURE:
			pS = (pSDS)GetWindowLongPtr(hwnd, DWLP_USER);
			hhDriver = (HHDRIVER)(pS->hDriver);

			if ((i = (int)SendDlgItemMessage(hwnd, IDC_CB_MODEMS, CB_GETCURSEL,
					0, 0)) != CB_ERR)
				{
				if (((LRESULT)pstLineIds = SendDlgItemMessage(hwnd,
						IDC_CB_MODEMS,  CB_GETITEMDATA, (WPARAM)i, 0))
							!= CB_ERR)
					{
					if ((LRESULT)pstLineIds != CB_ERR)
						{
						// I've "reserved" 4 permanent line ids to indentify
						// the direct to com port lines.
						//
						if (IN_RANGE(pstLineIds->dwPermanentLineId,
								DIRECT_COM1, DIRECT_COM4))
							{
							wsprintf(ach, "COM%d",
								pstLineIds->dwPermanentLineId - DIRECT_COM1 + 1);

							ComSetPortName(sessQueryComHdl(pS->hSession), ach);

                            // mrw: 2/20/96 - Set AutoDetect off if user clicks
                            // OK in this dialog.
                            //
							if (ComDeviceDialog(sessQueryComHdl(pS->hSession), hwnd) == 0)
                                {
                                ComSetAutoDetect(sessQueryComHdl(pS->hSession), FALSE);
                                }

							}

                        else if ( IsNT() && pstLineIds->dwPermanentLineId == DIRECT_COM_DEVICE)
							{
							// Get device from combobox... mrw:6/5/96
							//
							SendDlgItemMessage(hwnd, IDC_CB_MODEMS,
								CB_GETLBTEXT, (WPARAM)i,(LPARAM)ach);

							ComSetPortName(sessQueryComHdl(pS->hSession), ach);

							// mrw: 2/20/96 - Set AutoDetect off if user clicks
							// OK in this dialog.
							//
							if (ComDeviceDialog(sessQueryComHdl(pS->hSession), hwnd) == 0)
								{
								ComSetAutoDetect(sessQueryComHdl(pS->hSession), FALSE);
								ComConfigurePort(sessQueryComHdl(pS->hSession));
								}
							}
						else
							{
#if RESET_DEVICE_SETTINGS
                            LPVARSTRING pvs = NULL;
                            int         lReturn;
                            LPVOID      pv = NULL;
                            
                            lReturn = cncttapiGetLineConfig( pstLineIds->dwLineId, (VOID **) &pvs );

                            if (lReturn != 0)
                                {
                                if (pvs != NULL)
                                    {
                                    free(pvs);
                                    pvs = NULL;
                                    }

                                return FALSE;
                                }
#endif
                            //
                            // Get the current settings.
                            //
                            cncttapiGetCOMSettings(pstLineIds->dwLineId,
                                                   ach,
                                                   sizeof(ach) / sizeof(TCHAR));
							//
                            // rev: 11/30/00 - Set AutoDetect off if user clicks
							// OK in this dialog.
							//

							lineConfigDialog(pstLineIds->dwLineId,
								             hwnd, DEVCLASS);
                            
                            //
                            // Get the new settings.
                            //
                            cncttapiGetCOMSettings(pstLineIds->dwLineId,
                                                   achSettings,
                                                   sizeof(achSettings) / sizeof(TCHAR));

#if RESET_DEVICE_SETTINGS
                            //
                            // Return the settings back to what they were before our dialog was displayed.
                            //
			                if (pvs != NULL)
                                {
                                pv = (BYTE *)pvs + pvs->dwStringOffset;

                                lReturn = lineSetDevConfig(pstLineIds->dwLineId, pv,
                                                           pvs->dwStringSize, DEVCLASS);
                                free(pvs);
                                pvs = NULL;

                                if (lReturn != 0)
    		                        {
    		                        assert(FALSE);
    		                        return FALSE;
    		                        }
                                }
#endif
                            
                            //
                            // See if the settings have changed.  If so, then turn off
                            // AutoDetect. REV: 12/01/2000 
                            //
                            if (StrCharCmpi(ach, achSettings) != 0)
                                {
								ComSetAutoDetect(sessQueryComHdl(pS->hSession), FALSE);
                                }
							}
						}
					}
				}

			else
				{
				MessageBeep(MB_ICONHAND);
				}

			break;

		case IDC_XB_USECCAC:
			EnableCCAC(hwnd);
			break;

		case IDOK:
			if (ValidatePhoneDlg(hwnd) == 0)
				{
				if (tapi_SAVE_NEWPHONENUM(hwnd) != 0)
					break;

				EndDialog(hwnd, TRUE);
				}

			break;

		case IDCANCEL:
			EndDialog(hwnd, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  tapi_WM_NOTIFY
 *
 * DESCRIPTION:
 *  Process Property Sheet Notification messages.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
STATIC_FUNC LRESULT tapi_WM_NOTIFY(const HWND hDlg, const int nId)
	{
	pSDS	pS;

	switch (nId)
		{
		default:
			break;

		case PSN_APPLY:
			pS = (pSDS)GetWindowLongPtr(hDlg, DWLP_USER);
			if (pS)
				{
				if (ValidatePhoneDlg(hDlg) != 0)
					{
					SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
					return TRUE;
					}

				//
				// Do whatever saving is necessary
				//
				tapi_SAVE_NEWPHONENUM(hDlg);
				}
			break;

		case PSN_RESET:
			pS = (pSDS)GetWindowLongPtr(hDlg, DWLP_USER);
			if (pS)
				{
				//
				// If the user cancels make sure the old session name and its
				// icon are restored.
				//
				sessSetName(pS->hSession, pS->acSessNameCopy);
				sessSetIconID(pS->hSession, pS->nIconID);
				sessUpdateAppTitle(pS->hSession);

				SendMessage(sessQueryHwnd(pS->hSession), WM_SETICON,
					(WPARAM)TRUE, (LPARAM)pS->hIcon);
				}
			break;
#if 0
		case PSN_HASHELP:
			// For now gray the help button...
			//
			SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
			break;
#endif
		case PSN_HELP:
			// Display help in whatever way is appropriate
			break;
		}

	return FALSE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  tapi_SAVE_NEWPHONENUM
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
STATIC_FUNC int tapi_SAVE_NEWPHONENUM(HWND hwnd)
	{
	pSDS		pS;
	HHDRIVER	hhDriver;
	LRESULT		lr, lrx;
	PSTLINEIDS	pstLineIds = NULL;
    #if defined(INCL_WINSOCK)
	TCHAR		achPort[6];
    #endif
    #if defined(INCL_MINITEL)
    HCOM    hCom;
    BOOL    fAutoDetect = FALSE;
    #endif // INCL_MINITEL

	pS = (pSDS)GetWindowLongPtr(hwnd, DWLP_USER);
	hhDriver = (HHDRIVER)(pS->hDriver);

	/* --- Get selected modem --- */

	lrx = SendDlgItemMessage(hwnd, IDC_CB_MODEMS, CB_GETCURSEL, 0, 0);

	if (lrx != CB_ERR)
		{
		lr = SendDlgItemMessage(hwnd, IDC_CB_MODEMS, CB_GETLBTEXT, (WPARAM)lrx,
			(LPARAM)hhDriver->achLineName);

		if (lr != CB_ERR)
			{
			pstLineIds = (PSTLINEIDS)SendDlgItemMessage(hwnd, IDC_CB_MODEMS,
				CB_GETITEMDATA, (WPARAM)lrx, 0);

			if ((LRESULT)pstLineIds != CB_ERR)
				{
				hhDriver->dwPermanentLineId = pstLineIds->dwPermanentLineId;
				hhDriver->dwLine = pstLineIds->dwLineId;

				if ( IsNT() )
					{
					if (hhDriver->dwPermanentLineId == DIRECT_COM_DEVICE)
						{
						SendDlgItemMessage(hwnd, IDC_CB_MODEMS,
							CB_GETLBTEXT, (WPARAM)lrx,
							(LPARAM)hhDriver->achComDeviceName);
						}
					}
				}
			else
				{
				assert(FALSE);
				}
			}
		else
			{
			assert(FALSE);
			}
		}
	else
		{
		MessageBeep(MB_ICONHAND);
		assert(FALSE);
		return 1;
		}

	/* --- Get Country Code --- */

	if (IsWindowEnabled(GetDlgItem(hwnd, IDC_CB_CNTRYCODES)))
		{
		lr = SendDlgItemMessage(hwnd, IDC_CB_CNTRYCODES, CB_GETCURSEL, 0, 0);

		if (lr != CB_ERR)
			{
			lr = SendDlgItemMessage(hwnd, IDC_CB_CNTRYCODES, CB_GETITEMDATA,
				(WPARAM)lr, 0);

			if (lr != CB_ERR)
				hhDriver->dwCountryID = (DWORD)lr;

			else
				assert(FALSE);
			}
		}

	/* --- Get area code --- */

	if (IsWindowEnabled(GetDlgItem(hwnd, IDC_EB_AREACODE)))
		{
		GetDlgItemText(hwnd, IDC_EB_AREACODE, hhDriver->achAreaCode,
			sizeof(hhDriver->achAreaCode));
		}

	/* --- Get phone number --- */

	if (IsWindowEnabled(GetDlgItem(hwnd, IDC_EB_PHONENUM)))
		{
		GetDlgItemText(hwnd, IDC_EB_PHONENUM, hhDriver->achDest,
			sizeof(hhDriver->achDest));
		}

    #if defined(INCL_WINSOCK)
    if (IsWindowEnabled(GetDlgItem(hwnd, IDC_EB_HOSTADDR)))
        {
        GetDlgItemText(hwnd, IDC_EB_HOSTADDR, hhDriver->achDestAddr,
			sizeof(hhDriver->achDestAddr)/sizeof(TCHAR));
        }

    if (IsWindowEnabled(GetDlgItem(hwnd, IDC_EB_PORTNUM)))
        {
		GetDlgItemText(hwnd, IDC_EB_PORTNUM, achPort,
			sizeof(achPort));
		hhDriver->iPort = atoi(achPort);
        }
    #endif  // defined(INCL_WINSOCK)

	/* --- Get Use country code, area code info --- */

	if (IsWindowEnabled(GetDlgItem(hwnd, IDC_XB_USECCAC)))
		hhDriver->fUseCCAC = (BOOL)IsDlgButtonChecked(hwnd, IDC_XB_USECCAC);

    #if defined(INCL_REDIAL_ON_BUSY)
	/* --- Get Redial on Busy setting --- */

	if (IsWindowEnabled(GetDlgItem(hwnd, IDC_XB_REDIAL)))
        {
		hhDriver->fRedialOnBusy =
		    (BOOL)IsDlgButtonChecked(hwnd, IDC_XB_REDIAL);
        }
    #endif

    #if defined (INCL_MINITEL)
    hCom = sessQueryComHdl(pS->hSession);

    if (hCom && ComValidHandle(hCom) &&
        ComGetAutoDetect(hCom, &fAutoDetect) == COM_OK &&
        fAutoDetect == TRUE)
        {
        HEMU hEmu = sessQueryEmuHdl(pS->hSession);

        if (hEmu && emuQueryEmulatorId(hEmu) == EMU_MINI)
            {
            //
            // Set to seven bit, even parity, and 1 stop bit (7E1),
            // This is only done when the Minitel emulator is selected.
            // The user can change the COM settings manually after this
            // point.
            //
            ComSetDataBits(hCom, 7);
            ComSetParity(hCom, EVENPARITY);
            ComSetStopBits(hCom, ONESTOPBIT);
            ComSetAutoDetect(hCom, FALSE);
            cncttapiSetLineConfig(hhDriver->dwLine, hCom);
            }
        }
    #endif //INCL_MINITEL

    return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	EnableCCAC
 *
 * DESCRIPTION:
 *	Enables/disables controls associated with the Use Country Code,
 *	Area Code control
 *
 * ARGUMENTS:
 *	hwnd	- dialog window
 *
 * RETURNS:
 *	void
 *
 */
STATIC_FUNC void EnableCCAC(const HWND hwnd)
	{
	BOOL				fUseCCAC = TRUE;
	BOOL				fUseAC = TRUE;
	DWORD				dwCountryId;
	pSDS				pS;
	HHDRIVER			hhDriver;
	LRESULT 			lr;

	// Different templates use this same dialog proc.  If this window
	// is not there, don't do the work.  Also, selection of the direct
	// connect stuff can disable the control.

	if (IsWindowEnabled(GetDlgItem(hwnd, IDC_XB_USECCAC)))
		{
		fUseCCAC = (BOOL)IsDlgButtonChecked(hwnd, IDC_XB_USECCAC);
		EnableWindow(GetDlgItem(hwnd, IDC_CB_CNTRYCODES), fUseCCAC);
		}

	// We want to enable the area code only if both the use Country
	// code, Area code checkbox is checked and the country in
	// question uses area codes. - mrw, 2/12/95
	//
	pS = (pSDS)GetWindowLongPtr(hwnd, DWLP_USER);
	hhDriver = (HHDRIVER)(pS->hDriver);

	// Country code from dialog
	//
	lr = SendDlgItemMessage(hwnd, IDC_CB_CNTRYCODES, CB_GETCURSEL, 0, 0);

	if (lr != CB_ERR)
		{
		lr = SendDlgItemMessage(hwnd, IDC_CB_CNTRYCODES, CB_GETITEMDATA,
			(WPARAM)lr, 0);

		if (lr != CB_ERR)
			dwCountryId = (DWORD)lr;

		//fUseAC = fCountryUsesAreaCode(dwCountryId, hhDriver->dwAPIVersion);
		fUseAC = TRUE; // Microsoft changed its mind on this one -mrw:4/20/95
		}

	EnableWindow(GetDlgItem(hwnd, IDC_EB_AREACODE), fUseCCAC && fUseAC);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	ResetComboBox
 *
 * DESCRIPTION:
 *	The modem combobox allocates memory to store info about each item.
 *	This routine will free those allocated chunks.
 *
 * ARGUMENTS:
 *	hwnd	- window handle to combobox
 *
 * RETURNS:
 *	void
 *
 */
void ResetComboBox(const HWND hwnd)
	{
	void *pv = NULL;
	LRESULT lr, i;

	if (!IsWindow(hwnd))
		return;

	if ((lr = SendMessage(hwnd, CB_GETCOUNT, 0, 0)) != CB_ERR)
		{
		for (i = 0 ; i < lr ; ++i)
			{
			if (((LRESULT)pv = SendMessage(hwnd, CB_GETITEMDATA, (WPARAM)i, 0))
					!= CB_ERR)
				{
				if (pv)
					{
					free(pv);
					pv = NULL;
					}
				}
			}
		}

	SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	ModemCheck
 *
 * DESCRIPTION:
 *	Checks if the currently selected "modem" is one of the Direct to Com?
 *	selections.  If it is, it disables the country code, area code, phone
 *	number, and Use country code area code check box.
 *
 * ARGUMENTS:
 *	hwnd	- dialog window handle
 *
 * RETURNS:
 *	void
 *
 */
STATIC_FUNC void ModemCheck(const HWND hwnd)
	{
	int fModem;
	int fHotPhone;
    int fWinSock;
	LRESULT lr;
	PSTLINEIDS	pstLineIds = NULL;
	HHDRIVER hhDriver;
	const pSDS pS = (pSDS)GetWindowLongPtr(hwnd, DWLP_USER);
	const HWND hwndCB = GetDlgItem(hwnd, IDC_CB_MODEMS);
    HWND hwndTmp;

	if (!IsWindow(hwndCB))
		return;

	if ((lr = SendMessage(hwndCB, CB_GETCURSEL, 0, 0)) != CB_ERR)
		{
		pstLineIds = (PSTLINEIDS)SendMessage(hwndCB, CB_GETITEMDATA, lr, 0);

		if ((LRESULT)pstLineIds != CB_ERR)
			{
			fModem = TRUE;
            fWinSock = FALSE;

			if (IN_RANGE(pstLineIds->dwPermanentLineId, DIRECT_COM1,
					DIRECT_COM4))

				{
				fModem = FALSE;
				}

			if ( IsNT() )
				{
				if (pstLineIds->dwPermanentLineId == DIRECT_COM_DEVICE)
					{
					fModem = FALSE;
					}
				}

#if defined(INCL_WINSOCK)
			if (pstLineIds->dwPermanentLineId == DIRECT_COMWINSOCK)
			    {
			    fModem = FALSE;
			    fWinSock = TRUE;
			    }
#endif

			// Also check if we have a hotphone
			//
			if (fModem == TRUE && pS)
				{
				hhDriver = (HHDRIVER)(pS->hDriver);

				if (hhDriver)
					{
					if (CheckHotPhone(hhDriver, pstLineIds->dwLineId,
							&fHotPhone) == 0)
						{
						fModem = !fHotPhone;
						}
					}
				}

            // Swap between phone number and host address prompts
            if ((hwndTmp = GetDlgItem(hwnd, IDC_TF_PHONEDETAILS)))
                {
                ShowWindow(hwndTmp, fWinSock ? SW_HIDE : SW_SHOW);
                }
            if ((hwndTmp = GetDlgItem(hwnd, IDC_TF_TCPIPDETAILS)))
                {
                ShowWindow(hwndTmp, fWinSock ? SW_SHOW : SW_HIDE);
                }
            if ((hwndTmp = GetDlgItem(hwnd, IDC_TF_ACPROMPT)))
                {
                ShowWindow(hwndTmp, fWinSock ? SW_HIDE : SW_SHOW);
                }

            // Swap between Country code and Host address static text
            hwndTmp = GetDlgItem(hwnd, IDC_TF_CNTRYCODES);
            ShowWindow(hwndTmp, fWinSock ? SW_HIDE : SW_SHOW);
            EnableWindow(hwndTmp, ! fWinSock);
            hwndTmp = GetDlgItem(hwnd, IDC_TF_HOSTADDR);
            ShowWindow(hwndTmp, fWinSock ? SW_SHOW : SW_HIDE);
            EnableWindow(hwndTmp, fWinSock);

            // Swap between country code and host address edit boxes
            hwndTmp = GetDlgItem(hwnd, IDC_CB_CNTRYCODES);
            ShowWindow(hwndTmp, fWinSock ? SW_HIDE : SW_SHOW);
			EnableWindow(hwndTmp, fModem);
            hwndTmp = GetDlgItem(hwnd, IDC_EB_HOSTADDR);
            ShowWindow(hwndTmp, fWinSock ? SW_SHOW : SW_HIDE);
            EnableWindow(hwndTmp, fWinSock);

            // Swap between area code and port number static text
            hwndTmp = GetDlgItem(hwnd, IDC_TF_AREACODES);
            ShowWindow(hwndTmp, fWinSock ? SW_HIDE : SW_SHOW);
            EnableWindow(hwndTmp, ! fWinSock);
            hwndTmp = GetDlgItem(hwnd, IDC_TF_PORTNUM);
            ShowWindow(hwndTmp, fWinSock ? SW_SHOW : SW_HIDE);
            EnableWindow(hwndTmp, fWinSock);

            // Swap between area code and port number edit boxes
            hwndTmp = GetDlgItem(hwnd, IDC_EB_AREACODE);
            ShowWindow(hwndTmp, fWinSock ? SW_HIDE : SW_SHOW);
			EnableWindow(hwndTmp, fModem);
            hwndTmp = GetDlgItem(hwnd, IDC_EB_PORTNUM);
            ShowWindow(hwndTmp, fWinSock ? SW_SHOW : SW_HIDE);
            EnableWindow(hwndTmp, fWinSock);

            hwndTmp = GetDlgItem(hwnd, IDC_TF_PHONENUM);
            ShowWindow(hwndTmp, ! fWinSock);
            EnableWindow(hwndTmp, ! fWinSock);
            hwndTmp = GetDlgItem(hwnd, IDC_EB_PHONENUM);
            ShowWindow(hwndTmp, ! fWinSock);
            EnableWindow(hwndTmp, fModem);

            if ((hwndTmp = GetDlgItem(hwnd, IDC_XB_USECCAC)))
                {
                ShowWindow(hwndTmp, ! fWinSock);
                EnableWindow(hwndTmp, fModem);
                }

            if ((hwndTmp = GetDlgItem(hwnd, IDC_PB_CONFIGURE)))
                {
                ShowWindow(hwndTmp, !fWinSock);
                EnableWindow(hwndTmp, !fWinSock);
                if (pS)
				    EnableWindow(hwndTmp, cnctdrvQueryStatus((HHDRIVER)(pS->hDriver)) == CNCT_STATUS_FALSE);
                }

            // Set focus to modem combo when direct connect selected.
            // mrw:11/3/95
            //
            if (fModem == FALSE)
                {
                SetFocus(fWinSock ? GetDlgItem(hwnd,IDC_EB_HOSTADDR) : hwndCB);
                }

#if defined(INCL_REDIAL_ON_BUSY)
            if ((hwndTmp = GetDlgItem(hwnd, IDC_XB_REDIAL)))
                {
                ShowWindow(hwndTmp, ! fWinSock);
                EnableWindow(hwndTmp, fModem);
                }
#endif

			if (fModem == TRUE)
				EnableCCAC(hwnd);
			}
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	ValidatePhoneDlg
 *
 * DESCRIPTION:
 *	Checks phone dialog entries for proper values.	This mostly means
 *	checking for blank entry fields.
 *
 * ARGUMENTS:
 *	hwnd		- phone dialog
 *
 * RETURNS:
 *	0=OK,else error
 *
 */
static int ValidatePhoneDlg(const HWND hwnd)
	{
	if (CheckWindow(hwnd, IDC_CB_CNTRYCODES) != 0)
		return -1;

	//if (CheckWindow(hwnd, IDC_EB_AREACODE) != 0) - mrw:4/20/95
	//	  return -2;

	// Removed per MHG discussions - MPT 12/21/95
	//if (CheckWindow(hwnd, IDC_EB_PHONENUM) != 0)
	//	return -3;

	if (CheckWindow(hwnd, IDC_CB_MODEMS) != 0)
		return -4;

	if (VerifyAddress(hwnd) != 0)
		return -5;

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	CheckWindow
 *
 * DESCRIPTION:
 *	Since the dialog only enables windows that require entries, it just
 *	needs to check if an enabled window has text.  This function sets
 *	the focus to the offending field and beeps.
 *
 * ARGUMENTS:
 *	hwnd	- dialog window
 *	id		- control id
 *
 * RETURNS:
 *	0=OK, else not ok.
 *
 */
static int CheckWindow(const HWND hwnd, const int id)
	{
	char ach[256];

	if (IsWindowEnabled(GetDlgItem(hwnd, id)))
		{
		if (GetDlgItemText(hwnd, id, ach, sizeof(ach)) == 0)
			{
			MessageBeep(MB_ICONHAND);
			SetFocus(GetDlgItem(hwnd, id));
			return -1;
			}
		}

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	VerifyAddress
 *
 * DESCRIPTION:
 *	I can't believe how much code it takes to verify a stinking address.
 *
 * ARGUMENTS:
 *	hwnd	- dialog window handle.
 *
 * RETURNS:
 *	0=OK
 *
 */
static int VerifyAddress(const HWND hwnd)
	{
	pSDS		pS;
	HHDRIVER	hhDriver;
	LRESULT		lr, lrx;
	PSTLINEIDS	pstLineIds = NULL;
	int   fHotPhone;
	int   fUseCCAC;
	long  lRet;
	DWORD dwSize;
	DWORD dwLine;
	DWORD dwCountryID;
	DWORD dwPermanentLineId;
	TCHAR achAreaCode[10];
	TCHAR achDest[(TAPIMAXDESTADDRESSSIZE/2)+1];
	TCHAR ach[256];
	LPLINECOUNTRYLIST pcl;
	LPLINECOUNTRYENTRY pce;
	LINETRANSLATEOUTPUT *pLnTransOutput;

	pS = (pSDS)GetWindowLongPtr(hwnd, DWLP_USER);
	hhDriver = (HHDRIVER)(pS->hDriver);

	/* --- Get selected modem --- */

	lrx = SendDlgItemMessage(hwnd, IDC_CB_MODEMS, CB_GETCURSEL, 0, 0);

	if (lrx != CB_ERR)
		{
		pstLineIds = (PSTLINEIDS)SendDlgItemMessage(hwnd, IDC_CB_MODEMS,
			CB_GETITEMDATA, (WPARAM)lrx, 0);

		if ((LRESULT)pstLineIds != CB_ERR)
			{
			dwPermanentLineId = pstLineIds->dwPermanentLineId;
			dwLine = pstLineIds->dwLineId;
			}
		}

	else
		{
		return 0;
		}

	/* --- Get Country Code --- */

	if (IsWindowEnabled(GetDlgItem(hwnd, IDC_CB_CNTRYCODES)))
		{
		lr = SendDlgItemMessage(hwnd, IDC_CB_CNTRYCODES, CB_GETCURSEL, 0, 0);

		if (lr != CB_ERR)
			{
			lr = SendDlgItemMessage(hwnd, IDC_CB_CNTRYCODES, CB_GETITEMDATA,
				(WPARAM)lr, 0);

			if (lr != CB_ERR)
				dwCountryID = (DWORD)lr;
			}
		}

	else
		{
		return 0;
		}

	/* --- Get area code --- */

	achAreaCode[0] = TEXT('\0');
	GetDlgItemText(hwnd, IDC_EB_AREACODE, achAreaCode, sizeof(achAreaCode));

	/* --- Get phone number --- */

	achDest[0] = TEXT('\0');
	GetDlgItemText(hwnd, IDC_EB_PHONENUM, achDest, sizeof(achDest));

	/* --- Get Use country code, area code info --- */

	fUseCCAC = TRUE;

	if (IsWindowEnabled(GetDlgItem(hwnd, IDC_XB_USECCAC)))
		fUseCCAC = (BOOL)IsDlgButtonChecked(hwnd, IDC_XB_USECCAC);

	/* --- Try to translate --- */

	if (CheckHotPhone(hhDriver, dwLine, &fHotPhone) != 0)
		{
		assert(0);
		return 0;  // error message displayed already.
		}

	// Hot Phone is TAPI terminology for Direct Connects
	// We don't need to do address translation since we
	// not going to use it.

	if (fHotPhone)
		return 0;

	ach[0] = TEXT('\0');

	// If we not using the country code or area code, we still need to
	// pass a dialable string format to TAPI so that we get the
	// pulse/tone dialing modifiers in the dialable string.
	//
	if (fUseCCAC)
		{
		/* --- Do lineGetCountry to get extension --- */

		if (DoLineGetCountry(dwCountryID, TAPI_VER, &pcl) != 0)
			{
			assert(FALSE);
			return 0;
			}

		if ((pce = (LPLINECOUNTRYENTRY)
				((BYTE *)pcl + pcl->dwCountryListOffset)) == 0)
			{
			assert(FALSE);
			return 0;
			}

		/* --- Put country code in now --- */

		wsprintf(ach, "+%u ", pce->dwCountryCode);
		free(pcl);
		pcl = NULL;

		if (!fIsStringEmpty(achAreaCode))
			{
			lstrcat(ach, "(");
			lstrcat(ach, achAreaCode);
			lstrcat(ach, ") ");
			}
		}

	lstrcat(ach, achDest);

	/* --- Allocate some space --- */

	pLnTransOutput = malloc(sizeof(LINETRANSLATEOUTPUT));

	if (pLnTransOutput == 0)
		{
		assert (FALSE);
		return 0;
		}

	pLnTransOutput->dwTotalSize = sizeof(LINETRANSLATEOUTPUT);

	/* --- Now that we've satisifed the clergy, translate it --- */

	if (TRAP(lRet = lineTranslateAddress(hhDriver->hLineApp,
			dwLine, TAPI_VER, ach, 0,
				LINETRANSLATEOPTION_CANCELCALLWAITING,
					pLnTransOutput)) != 0)
		{
		free(pLnTransOutput);
		pLnTransOutput = NULL;

		if (lRet == LINEERR_INVALADDRESS)
			goto MSG_EXIT;

		return 0;
		}

	if (pLnTransOutput->dwTotalSize < pLnTransOutput->dwNeededSize)
		{
		dwSize = pLnTransOutput->dwNeededSize;
		free(pLnTransOutput);
		pLnTransOutput = NULL;

		if ((pLnTransOutput = malloc(dwSize)) == 0)
			{
			assert(FALSE);
			return 0;
			}

		pLnTransOutput->dwTotalSize = dwSize;

		if ((lRet = lineTranslateAddress(hhDriver->hLineApp,
				dwLine, TAPI_VER, ach, 0,
					LINETRANSLATEOPTION_CANCELCALLWAITING,
						pLnTransOutput)) != 0)
			{
			assert(FALSE);
			free(pLnTransOutput);
			pLnTransOutput = NULL;

			if (lRet == LINEERR_INVALADDRESS)
				goto MSG_EXIT;
			}
		}

	free(pLnTransOutput);
	pLnTransOutput = NULL;
	return 0;

	MSG_EXIT:
		hhDriver->achDialableDest[0] = TEXT('\0');
		hhDriver->achDisplayableDest[0] = TEXT('\0');
		hhDriver->achCanonicalDest[0] = TEXT('\0');

		LoadString(glblQueryDllHinst(), IDS_ER_CNCT_BADADDRESS, ach,
			sizeof(ach) / sizeof(TCHAR));

		TimedMessageBox(hwnd, ach, 0, MB_OK | MB_ICONINFORMATION, 0);

#if defined (NT_EDITION)
		if (lRet != LINEERR_INVALADDRESS)
			{
			return -2;
			}
#endif

		// per MHG discussion - MPT 12/21/95
		return 0;
	}

#if 0
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	fCountryUsesAreaCode
 *
 * DESCRIPTION:
 *	Checks if the specified country uses area codes.
 *
 * ARGUMENTS:
 *	hwnd	- window handle of dialog.
 *
 * RETURNS:
 *	TRUE/FALSE, <0=error
 *
 * AUTHOR: Mike Ward, 26-Jan-1995
 */
int fCountryUsesAreaCode(const DWORD dwCountryID, const DWORD dwAPIVersion)
	{
	LPTSTR pachLongDistDialRule;
	LPLINECOUNTRYLIST pcl;
	LPLINECOUNTRYENTRY pce;

	// Get country information
	//
	if (DoLineGetCountry(dwCountryID, TAPI_VER, &pcl) != 0)
		{
		assert(0);
		return -1;
		}

	// Find offset to country info.
	//
	if ((pce = (LPLINECOUNTRYENTRY)
			((BYTE *)pcl + pcl->dwCountryListOffset)) == 0)
		{
		assert(0);
		return -1;
		}

	// Get long distance dialing rule
	//
	pachLongDistDialRule = (BYTE *)pcl + pce->dwLongDistanceRuleOffset;

	// If dial rule has an 'F', we need the area code.
	//
	if (strchr(pachLongDistDialRule, 'F'))
		return TRUE;

	return FALSE;
	}
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	fIsStringEmpty
 *
 * DESCRIPTION:
 *	Used for checking if areacode is just blanks.  lineTranslateAddress
 *	pukes badly if you give it a string of blanks for the area code.
 *
 * ARGUMENTS:
 *	ach 	- areacode string (can be NULL)
 *
 * RETURNS:
 *	1=emtpy, 0=not empty
 *
 * AUTHOR: Mike Ward, 20-Apr-1995
 */
int fIsStringEmpty(LPTSTR ach)
	{
	int i;

	if (ach == 0)
		return 1;

	if (ach[0] == TEXT('\0'))
		return 1;

	for (i = lstrlen(ach) - 1 ; i >= 0 ; --i)
		{
		if (ach[i] != TEXT(' '))
			return 0;
		}

	return 1;
	}


int cncttapiGetCOMSettings( const DWORD dwLineId, LPTSTR pachStr, const size_t cb )
    {
    static CHAR  acParity[] = "NOEMS";  // see com.h
    static CHAR *pachStop[] = {"1", "1.5", "2"};

    TCHAR       ach[100];
    DWORD       dwSize;
    LPVARSTRING pvs;
    int         fAutoDetect = FALSE;
    long        lBaud = 0;
    int         iDataBits = 0;
    int         iParity = 0;
    int         iStopBits = 0;
    int         lReturn = 0;

    LPCOMMPROP pComProp = 0;


    // Check the parameters
    //
    if (pachStr == 0 || cb == 0)
    	{
    	assert(0);
    	return -2;
    	}

    ach[0] = TEXT('\0');

    if ((pvs = malloc(sizeof(VARSTRING))) == 0)
    	{
    	assert(FALSE);
    	return -3;
    	}

	memset(pvs, 0, sizeof(VARSTRING));
    pvs->dwTotalSize = sizeof(VARSTRING);
	pvs->dwNeededSize = 0;

    if (lineGetDevConfig(dwLineId, pvs, DEVCLASS) != 0)
    	{
    	assert(FALSE);
    	free(pvs);
  		pvs = NULL;
    	return -4;
    	}

    if (pvs->dwNeededSize > pvs->dwTotalSize)
    	{
    	dwSize = pvs->dwNeededSize;
    	free(pvs);
  		pvs = NULL;

    	if ((pvs = malloc(dwSize)) == 0)
    		{
    		assert(FALSE);
    		return -5;
    		}

		memset(pvs, 0, dwSize);
    	pvs->dwTotalSize = dwSize;

    	if (lineGetDevConfig(dwLineId, pvs, DEVCLASS) != 0)
    		{
    		assert(FALSE);
    		free(pvs);
  			pvs = NULL;
    		return -6;
    		}
    	}

    // The structure of the DevConfig block is as follows
    //
    //	VARSTRING
    //	UMDEVCFGHDR
    //	COMMCONFIG
    //	MODEMSETTINGS
    //
    // The UMDEVCFG structure used below is defined in the
    // UNIMODEM.H provided in the platform SDK (in the nih
    // directory for HTPE). REV: 12/01/2000 
    //
    {
    PUMDEVCFG pDevCfg = NULL;
    
    pDevCfg = (UMDEVCFG *)((BYTE *)pvs + pvs->dwStringOffset);

    // commconfig struct has a DCB structure we dereference for the
    // com settings.
    //
	lBaud = pDevCfg->commconfig.dcb.BaudRate;
	iDataBits = pDevCfg->commconfig.dcb.ByteSize;
	iParity = pDevCfg->commconfig.dcb.Parity;
	iStopBits = pDevCfg->commconfig.dcb.StopBits;
	wsprintf(ach, "%ld %d-%c-%s", lBaud, iDataBits,
    	acParity[iParity], pachStop[iStopBits]);
#if 0	//DEADWOOD:jkh 9/9/98
    wsprintf(ach, "%u %d-%c-%s", pDevCfg->commconfig.dcb.BaudRate,
    	pDevCfg->commconfig.dcb.ByteSize,
    	acParity[pDevCfg->commconfig.dcb.Parity],
    	pachStop[pDevCfg->commconfig.dcb.StopBits]);
#endif
    }

    StrCharCopyN(pachStr, ach, cb);
    pachStr[cb-1] = TEXT('\0');
    free(pvs);
    pvs = NULL;

    return 0;
    }

#if 0   //JMH 02-05-96 Previously defined (INCL_WINSOCK)

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctwsNewPhoneDlg
 *
 * DESCRIPTION:
 *	Displays dialog for getting new connection info.
 *
 *  NOTE:  Since this dialog proc is also called by the property sheet's
 *	phone number tab dialog it has to assume that the lPar contains the
 *	LPPROPSHEETPAGE.
 *
 * ARGUMENTS:
 *	Standard dialog
 *
 * RETURNS:
 *	Standard dialog
 *
 * AUTHOR
 *	mcc 01/04/96
 *
 */
BOOL CALLBACK cnctwsNewPhoneDlg(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar)
	{
	/*
	 * NOTE: these defines must match the templates in both places, here and
	 *       int term\dialogs.rc
	 */
	//#define IDC_TF_PORTNUM      110
	//#define IDC_TF_IPADDR	    108
	
	#define IDC_IC_ICON			101
	#define IDC_EB_IPADDR	 	109
	#define IDC_EB_PORTNUM		111
	
	#define IDC_TB_NAME 		103
	#define IDC_PB_EDITICON 	117
	#define IDC_PB_CONFIGURE	115

	HWND	 hwndParent;
	HHDRIVER hhDriver;
	TCHAR	 ach[256];
	TCHAR	 achPort[6];
	TCHAR 	 acNameCopy[256];
	//int 	 i;

#if 0 // TODO:mcc 01/03/96
	static 	 DWORD aHlpTable[] = {IDC_CB_CNTRYCODES, IDH_TERM_NEWPHONE_COUNTRY,
								  IDC_TF_CNTRYCODES, IDH_TERM_NEWPHONE_COUNTRY,
								  IDC_EB_AREACODE,	 IDH_TERM_NEWPHONE_AREA,
								  IDC_TF_AREACODES,  IDH_TERM_NEWPHONE_AREA,
								  IDC_EB_PHONENUM,	 IDH_TERM_NEWPHONE_NUMBER,
								  IDC_TF_PHONENUM,   IDH_TERM_NEWPHONE_NUMBER,
								  IDC_PB_CONFIGURE,  IDH_TERM_NEWPHONE_CONFIGURE,
								  IDC_TF_MODEMS,     IDH_TERM_NEWPHONE_DEVICE,
								  IDC_CB_MODEMS,	 IDH_TERM_NEWPHONE_DEVICE,
								  IDC_PB_EDITICON,	 IDH_TERM_PHONEPROP_CHANGEICON,
                                  IDCANCEL,                           IDH_CANCEL,
                                  IDOK,                               IDH_OK,
								  0,0,
								  };
#endif
	pSDS	 pS;

	switch (uMsg)
		{
	case WM_INITDIALOG:
		pS = (SDS *)malloc(sizeof(SDS));

		if (pS == (SDS *)0)
			{
			assert(FALSE);
			EndDialog(hwnd, FALSE);
			break;
			}

		// In the effort to keep the internal driver handle internal
		// we are passing the session handle from the property sheet tab
		// dialog.
		//
		pS->hSession = (HSESSION)(((LPPROPSHEETPAGE)lPar)->lParam);

		pS->hDriver = cnctQueryDriverHdl(sessQueryCnctHdl(pS->hSession));
		hhDriver = (HHDRIVER)(pS->hDriver);

		SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)pS);

		// In order to center the property sheet we need to center the parent
		// of the hwnd on top of the session window.
		// If the parent of hwnd is the session window then this dialog has
		// not been called from the property sheet.
		//
		hwndParent = GetParent(hwnd);

		if (hwndParent != sessQueryHwnd(pS->hSession))
			mscCenterWindowOnWindow(hwndParent, sessQueryHwnd(pS->hSession));

		else
			mscCenterWindowOnWindow(hwnd, sessQueryHwnd(pS->hSession));

		// Display the session icon...
		//
		pS->nIconID = sessQueryIconID(hhDriver->hSession);
		pS->hIcon = sessQueryIcon(hhDriver->hSession);
		//pS->hLittleIcon = sessQueryLittleIcon(hhDriver->hSession);

		SendDlgItemMessage(hwnd, IDC_IC_ICON, STM_SETICON,
			(WPARAM)pS->hIcon, 0);

		SendDlgItemMessage(hwnd, IDC_EB_IPADDR, EM_SETLIMITTEXT,
			((sizeof(hhDriver->achDestAddr)/sizeof(TCHAR))-1), 0);

		if (hhDriver->achDestAddr[0])
			SetDlgItemText(hwnd, IDC_EB_IPADDR, hhDriver->achDestAddr);

		wsprintf(achPort, "%d", hhDriver->iPort);
		SetDlgItemText(hwnd, IDC_EB_PORTNUM, achPort);

		TCHAR_Fill(pS->acSessNameCopy, TEXT('\0'),
			sizeof(pS->acSessNameCopy) / sizeof(TCHAR));

		sessQueryName(hhDriver->hSession, pS->acSessNameCopy,
			sizeof(pS->acSessNameCopy));

		TCHAR_Fill(ach, TEXT('\0'), sizeof(ach) / sizeof(TCHAR));
		lstrcpy(ach, pS->acSessNameCopy);
		mscModifyToFit(GetDlgItem(hwnd, IDC_TB_NAME), ach);
		SetDlgItemText(hwnd, IDC_TB_NAME, ach);

		return 0;

	case WM_CONTEXTMENU:
		//WinHelp((HWND)wPar, glblQueryHelpFileName(), HELP_CONTEXTMENU,
			//(DWORD)(LPSTR)aHlpTable);
		break;

	case WM_HELP:
	   //	WinHelp(((LPHELPINFO)lPar)->hItemHandle, glblQueryHelpFileName(),
			//HELP_WM_HELP, (DWORD)(LPSTR)aHlpTable);
		break;

	case WM_DESTROY:
		// OK, now we know that we are actually leaving the dialog for good, so
		// free the storage...
		//
		pS = (pSDS)GetWindowLongPtr(hwnd, DWLP_USER);
		if (pS)
			{
			free(pS);
			pS = NULL;
			}

		break;

	case WM_NOTIFY:
		//
		// Property sheet messages are being channeled through here...
		//
		// TODO:mcc ??? return wsck_WM_NOTIFY(hwnd, (int)((NMHDR *)lPar)->code);
		break;

	case WM_COMMAND:
		switch (LOWORD(wPar))
			{

		//
		// Property sheet's TAB_PHONENUMBER dialog is using this dialog proc
		// also, the following two buttons appear only in this tabbed dialog
		// template.
		//
		case IDC_PB_EDITICON:
			{
			pS = (pSDS)GetWindowLongPtr(hwnd, DWLP_USER);

			sessQueryName(pS->hSession, acNameCopy, sizeof(acNameCopy));

			if (DialogBoxParam(glblQueryDllHinst(),
				MAKEINTRESOURCE(IDD_NEWCONNECTION),
					hwnd, NewConnectionDlg,
						(LPARAM)pS->hSession) == FALSE)
				{
				return 0;
				}

			SetFocus(GetDlgItem(hwnd, IDC_PB_EDITICON));
			ach[0] = TEXT('\0');
			sessQueryName(pS->hSession, ach, sizeof(ach));
			mscModifyToFit(GetDlgItem(hwnd, IDC_TB_NAME), ach);
			SetDlgItemText(hwnd, IDC_TB_NAME, ach);

			SendDlgItemMessage(hwnd, IDC_IC_ICON, STM_SETICON,
				(WPARAM)sessQueryIcon(pS->hSession), 0);

			// The user may have changed the name of the session.
			// The new name should be reflected in the property sheet title
			// and in the app title.
			//
			propUpdateTitle(pS->hSession, hwnd, acNameCopy);
			}
			break;

		case IDC_PB_CONFIGURE:
			pS = (pSDS)GetWindowLongPtr(hwnd, DWLP_USER);
			hhDriver = (HHDRIVER)(pS->hDriver);

			break;

		case IDOK:
			wsck_SAVE_NEWIPADDR(hwnd);
			EndDialog(hwnd, TRUE);
			break;

		case IDCANCEL:
			EndDialog(hwnd, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}



/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  wsck_SAVE_NEWIPADDR
 *
 * DESCRIPTION:
 *	Saves chanes to the address/port setting back to the handle
 *
 * ARGUMENTS:
 *	hwnd		Window handle of "New Phonebook Entry" dialog
 *
 * RETURNS:
 *	0 		if data entered for all necessary values
 * 	-1		otherwise
 *
 */
STATIC_FUNC int wsck_SAVE_NEWIPADDR(HWND hwnd)
  	{
	int			iErr = 0;
	pSDS		pS;
	HHDRIVER	hhDriver;
	TCHAR		achPort[6];

	pS = (pSDS)GetWindowLongPtr(hwnd, DWLP_USER);
	hhDriver = (HHDRIVER)(pS->hDriver);


	/* --- Get port number --- */

	if (IsWindowEnabled(GetDlgItem(hwnd, IDC_EB_PORTNUM)))
		{
		GetDlgItemText(hwnd, IDC_EB_PORTNUM, achPort,
			sizeof(achPort));
		hhDriver->iPort = atoi(achPort);
		}
	else
		{
		iErr = -1;
		goto cleanup;
		}

	/* --- Get IP Address --- */

	if (IsWindowEnabled(GetDlgItem(hwnd, IDC_EB_IPADDR)))
		{
		GetDlgItemText(hwnd, IDC_EB_IPADDR, hhDriver->achDestAddr,
			sizeof(hhDriver->achDestAddr)/sizeof(TCHAR));
		}
	else
		iErr = -1;

cleanup:
	return iErr;
	}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\comstd\comstd.c ===
/*  File: D:\WACKER\comstd\comstd.c (Created: 08-Dec-1993)
 *
 *  Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *  All rights reserved
 *
 *  $Revision: 10 $
 *  $Date: 5/01/01 2:51p $
 */
#include <windows.h>
#pragma hdrstop

//#define     DEBUGSTR
//#define DEBUG_CHARDUMP

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\mc.h>
#include <tdll\sf.h>
#include <tdll\timers.h>
#include <tdll\com.h>
#include <tdll\comdev.h>
#include "comstd.hh"
#if defined(INCL_WINSOCK)
#include <comwsock\comwsock.hh>
#endif  // defined(INCL_WINSOCK)
#include <tdll\assert.h>
#include <tdll\statusbr.h>
#include <tdll\com.hh>
#include "rc_id.h"
#include <tdll\open_msc.h>  // IsNT()

#if defined(DEBUG_CHARDUMP)
    #include <stdio.h>
	FILE *pfDbgR = NULL;
    FILE *pfDbgC = NULL;
#endif

BOOL WINAPI ComStdEntry(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);
BOOL WINAPI _CRT_INIT(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);
static void DeviceBreakTimerProc(void *pvData, long ulSince); //mrw:6/15/95

HINSTANCE hinstDLL = (HINSTANCE)0;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *      very temporary - mrw
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int GetAutoDetect(ST_STDCOM *pstPrivate)
    {
    return pstPrivate->stWorkSettings.fAutoDetect;
    }

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  ComStdEntry
 *
 * DESCRIPTION:
 *  Currently, just initializes the C-Runtime library but may be used
 *  for other things later.
 *
 * ARGUMENTS:
 *  hInstDll    - Instance of this DLL
 *  fdwReason   - Why this entry point is called
 *  lpReserved  - reserved
 *
 * RETURNS:
 *  BOOL
 *
 */
BOOL WINAPI ComStdEntry(HINSTANCE hInst, DWORD fdwReason, LPVOID lpReserved)
    {
    hinstDLL = hInst;
    return _CRT_INIT(hInst, fdwReason, lpReserved);
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: DeviceInitialize
 *
 * DESCRIPTION:
 *  Called whenever the driver is being loaded
 *
 * ARGUMENTS:
 *  hCom               -- A copy of the com handle. Can be used in the
 *                          driver code to call com services
 *  usInterfaceVersion -- A version number identifying the version of the
 *                          driver interface
 *  ppvDriverData      -- A place to put the pointer to our private data.
 *                          This value will be passed back to us in all
 *                          subsequent calls.
 *
 * RETURNS:
 *  COM_OK if all is hunky dory
 *  COM_DEVICE_VERSION_ERROR if HA/Win expects a different interface version.
 *  COM_NOT_ENOUGH_MEMORY
 *  COM_DEVICE_ERROR if anything else goes wrong
 */
int WINAPI DeviceInitialize(HCOM hCom,
    unsigned nInterfaceVersion,
    void **ppvDriverData)
    {
    int        iRetVal = COM_OK;
    int        ix;
    ST_STDCOM *pstPrivate = NULL;

    //              Check version number and compatibility

    if (nInterfaceVersion != COM_VERSION)
        {
        // This error is reported by Com Routines. We cannot report errors
        // until after DeviceInitialize has completed.
        return COM_DEVICE_VERSION_ERROR;
        }

    if (*ppvDriverData)
        {
        pstPrivate = *ppvDriverData;
        }
    else
        {
        // Allocate our private storage structure
        if ((pstPrivate = malloc(sizeof(*pstPrivate))) == NULL)
            return COM_NOT_ENOUGH_MEMORY;
        *ppvDriverData = pstPrivate;

        // These members are common to both com drivers
        //
        pstPrivate->hCom = hCom;
        pstPrivate->fNotifyRcv = TRUE;
        pstPrivate->dwEventMask = 0;
        pstPrivate->fSending = FALSE;
        pstPrivate->lSndTimer = 0L;
        pstPrivate->lSndLimit = 0L;
        pstPrivate->lSndStuck = 0L;
        pstPrivate->hwndEvents = (HWND)0;
        pstPrivate->nRBufrSize = SIZE_INQ;
        pstPrivate->pbBufrStart = NULL;
        pstPrivate->fHaltThread = TRUE;

        InitializeCriticalSection(&pstPrivate->csect);
        for (ix = 0; ix < EVENT_COUNT; ++ix)
            {
            pstPrivate->ahEvent[ix] = CreateEvent((LPSECURITY_ATTRIBUTES)0,
                TRUE, FALSE, NULL);
            if (!pstPrivate->ahEvent[ix])
                {
                iRetVal = COM_FAILED;
                break;
                }
            }
        }

    // These members are specific to the stdcom driver
    //
    pstPrivate->bLastMdmStat = 0;
    pstPrivate->pbSndBufr = NULL;
    pstPrivate->nParityErrors = 0;
    pstPrivate->nFramingErrors = 0;
    pstPrivate->nOverrunErrors = 0;
    pstPrivate->nOverflowErrors = 0;

    pstPrivate->hWinComm = INVALID_HANDLE_VALUE;
    pstPrivate->fBreakSignalOn = FALSE;
    // Setup up reasonable default device values in case this type of
    //  device has not been used in a session before
    pstPrivate->stWorkSettings.lBaud          = 2400L;
    //pstPrivate->stWorkSettings.lBaud          = 9600L;
    pstPrivate->stWorkSettings.nDataBits      = 8;
    pstPrivate->stWorkSettings.nStopBits      = ONESTOPBIT;
    pstPrivate->stWorkSettings.nParity        = NOPARITY;
    pstPrivate->stWorkSettings.afHandshake    = HANDSHAKE_RCV_RTS |
        HANDSHAKE_SND_CTS;
    pstPrivate->stWorkSettings.chXON          = 0x11;
    pstPrivate->stWorkSettings.chXOFF         = 0x13;
    pstPrivate->stWorkSettings.nBreakDuration = 750;
    pstPrivate->stWorkSettings.fAutoDetect    = TRUE;
    pstPrivate->stFileSettings = pstPrivate->stWorkSettings;

    pstPrivate->fADRunning = FALSE;
    pstPrivate->nADTotal = 0;
    pstPrivate->nADMix = 0;
    pstPrivate->nAD7o1 = 0;
    pstPrivate->nADHighBits = 0;
    pstPrivate->nADBestGuess = AD_DONT_KNOW;
    pstPrivate->chADLastChar = TEXT('\0');
    pstPrivate->fADToggleParity = FALSE;
    pstPrivate->fADReconfigure = FALSE;

    pstPrivate->hComstdThread = NULL;

    if (iRetVal != COM_OK)
        {
        if (pstPrivate)
			{
            free(pstPrivate);
			pstPrivate = NULL;
			}
        }

    return iRetVal;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: DeviceClose
 *
 * DESCRIPTION:
 *  Called when HA/Win is done with this driver and is about to release .DLL
 *
 * ARGUMENTS:
 *  pstPrivate -- Pointer to our private data structure
 *
 * RETURNS:
 *  COM_OK
 */
int WINAPI DeviceClose(ST_STDCOM *pstPrivate)
    {
    int ix;

    // Driver is about to be let go, do any cleanup
    // Port should have been deactivated before we are called, but
    //  check anyway.
    PortDeactivate(pstPrivate);

    for (ix = 0; ix < EVENT_COUNT; ++ix)
        {
        CloseHandle(pstPrivate->ahEvent[ix]);
        }
    DeleteCriticalSection(&pstPrivate->csect);
    // Free our private data area
    free(pstPrivate);
	pstPrivate = NULL;

    return COM_OK;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  ComLoadStdcomDriver
 *
 * DESCRIPTION:
 *  Loads the COM handle with pointers to the stdcom driver functions
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *  COM_OK		if successful
 *	COM_FAILED	otherwise
 *
 * AUTHOR:
 * mcc 12/26/95
 */
int ComLoadStdcomDriver(HCOM pstCom)
	{
	int	iRetVal = COM_OK;

	if ( !pstCom )
		return COM_FAILED;

	pstCom->pfPortActivate   = PortActivate;
	pstCom->pfPortDeactivate = PortDeactivate;
	pstCom->pfPortConnected  = PortConnected;
	pstCom->pfRcvRefill 	 = RcvRefill;
	pstCom->pfRcvClear		 = RcvClear;
	pstCom->pfSndBufrSend	 = SndBufrSend;
	pstCom->pfSndBufrIsBusy  = SndBufrIsBusy;
	pstCom->pfSndBufrClear	 = SndBufrClear;
	pstCom->pfSndBufrQuery	 = SndBufrQuery;
	pstCom->pfDeviceSpecial	 = DeviceSpecial;
	pstCom->pfPortConfigure	 = PortConfigure;
    pstCom->pfDeviceDialog   = DeviceDialog;

	return iRetVal;
	}



/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: DeviceDialog
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
/*lint ARGSUSED*/
int WINAPI DeviceDialog(ST_STDCOM *pstPrivate, HWND hwndParent)
    {
    int iRetValue = COM_OK;
    COMMCONFIG stCC;
    TCHAR szPortName[COM_MAX_PORT_NAME];
    int nLen;

    memset(&stCC, 0, sizeof(stCC));
    stCC.dwSize = sizeof(stCC);
    stCC.wVersion = 1;
    stCC.dwProviderSubType = PST_RS232;
    nLen = sizeof(szPortName);
    ComGetPortName(pstPrivate->hCom, szPortName, &nLen);
    ComstdSettingsToDCB(&pstPrivate->stWorkSettings, &stCC.dcb);

    if (CommConfigDialog(szPortName, hwndParent, &stCC))
        {
        ComstdDCBToSettings(&stCC.dcb, &pstPrivate->stWorkSettings);
        }
    else
        {
        iRetValue = COM_CANCELLED;
		//DbgShowLastError();
        }

    return iRetValue;
    }

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: DeviceGetCommon
 *
 * DESCRIPTION:
 *  Gets user settings common to all drivers
 *
 * ARGUMENTS:
 *  pstPrivate -- Our private data structure
 *  pstcommon  -- Pointer to structure of type ST_COMMON to be filled in
 *                  with the desired settings
 *
 * RETURNS:
 *  Always returns COM_OK
 */
int WINAPI DeviceGetCommon(ST_STDCOM *pstPrivate, ST_COMMON *pstCommon)
    {
    pstCommon->afItem = (COM_BAUD |
             COM_DATABITS |
             COM_STOPBITS |
                         COM_PARITY |
                         COM_AUTO);
    pstCommon->lBaud           = pstPrivate->stWorkSettings.lBaud;
    pstCommon->nDataBits   = pstPrivate->stWorkSettings.nDataBits;
    pstCommon->nStopBits   = pstPrivate->stWorkSettings.nStopBits;
    pstCommon->nParity         = pstPrivate->stWorkSettings.nParity;
    pstCommon->fAutoDetect = pstPrivate->stWorkSettings.fAutoDetect;

    return COM_OK;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: DeviceSetCommon
 *
 * DESCRIPTION:
 *  Passes common user settings to driver for use and storage.
 *
 * ARGUMENTS:
 *  pstPrivate
 *  pstCommon  -- Structure containing common user settings to be used
 *                by driver
 *
 * RETURNS:
 *  Always returns COM_OK
 */
int WINAPI DeviceSetCommon(ST_STDCOM *pstPrivate, ST_COMMON *pstCommon)
    {
    if (bittest(pstCommon->afItem, COM_BAUD))
        pstPrivate->stWorkSettings.lBaud     = pstCommon->lBaud;
    if (bittest(pstCommon->afItem, COM_DATABITS))
        pstPrivate->stWorkSettings.nDataBits = pstCommon->nDataBits;
    if (bittest(pstCommon->afItem, COM_STOPBITS))
        pstPrivate->stWorkSettings.nStopBits = pstCommon->nStopBits;
    if (bittest(pstCommon->afItem, COM_PARITY))
        pstPrivate->stWorkSettings.nParity   = pstCommon->nParity;
    if (bittest(pstCommon->afItem, COM_AUTO))
        pstPrivate->stWorkSettings.fAutoDetect = pstCommon->fAutoDetect;

    return COM_OK;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: DeviceSpecial
 *
 * DESCRIPTION:
 *  The means for others to control any special features in this driver
 *  that are not supported by all drivers.
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *  COM_NOT_SUPPORTED if the instruction string was not recognized
 *  otherwise depends on instruction string
 */
/*ARGSUSED*/
int WINAPI DeviceSpecial(ST_STDCOM *pstPrivate,
    const TCHAR *pszInstructions,
    TCHAR *pszResult,
    int   nBufrSize)
    {

    int           iRetVal = COM_NOT_SUPPORTED;
    HSESSION      hSession;
#if 0           //* do port of this odd fellow later
    unsigned      usMask = 0;
    unsigned long ulSetVal;
    TCHAR        *pszEnd;
	//
	// MAX_IP_ADDR_LEN+11+1 = buffer size of pstPrivate->szRemoteAddr +
	// settings string "SET IPADDR=" + 1 for the terminating NULL
	// character.  REV 09/20/2000
	//
    TCHAR         achInstructions[MAX_IP_ADDR_LEN+11+1]; // John: decide how you want to handle
    TCHAR        *pszToken = achInstructions;
    int           iIndex;
    TCHAR         szResult[MAX_IP_ADDR_LEN+11+1];

    static TCHAR *apszItems[] =
    {
    "HANDSHAKE_RCV_X",
    "HANDSHAKE_RCV_DTR",
    "HANDSHAKE_RCV_RTS",
    "HANDSHAKE_SND_X",
    "HANDSHAKE_SND_CTS",
    "HANDSHAKE_SND_DSR",
    "HANDSHAKE_SND_DCD",
    "XON_CHAR",
    "XOFF_CHAR",
    "BREAK_DURATION",
    "CTS_STATUS",
    "DSR_STATUS",
    "DCD_STATUS",
    "DTR_STATE",
    "RTS_STATE",
    "MODIFIED",     // remove when real temporary settings are in
    NULL
    };

    // supported instruction strings:
    // "Set xxx=vv"
    // "Query xxx"

    if (!pszInstructions || !*pszInstructions)
        return COM_FAILED;
    if (sizeof(achInstructions) < (size_t)(lstrlen(pszInstructions) + 1))
        return COM_NOT_SUPPORTED;

    strcpy(achInstructions, pszInstructions);

    if (pszResult)
        *pszResult = TEXT('\0');

    pszToken = strtok(achInstructions, " ");
    if (!pszToken)
        return COM_NOT_SUPPORTED;

    if (lstrcmpi(pszToken, "SET") == 0)
        {
        iRetVal = COM_OK;
        pszToken = strtok(NULL, " =");
        if (!pszToken)
            pszToken = "";

        // Look up the item to set
        for (iIndex = 0; apszItems[iIndex]; ++iIndex)
            if (lstrcmpi(pszToken, apszItems[iIndex]) == 0)
                break;

        // Isolate the new value to be set
        pszToken = strtok(NULL, "\n");

        if (pszToken && *pszToken)
            {
            // Several items take numeric values
            ulSetVal = strtoul(pszToken, &pszEnd, 0);

            switch(iIndex)
                {
            case 0: // RCV_X
                usMask = HANDSHAKE_RCV_X;
                break;

            case 1: // RCV_DTR
                usMask = HANDSHAKE_RCV_DTR;
                break;

            case 2: // RCV_RTS
                usMask = HANDSHAKE_RCV_RTS;
                break;

            case 3: // SND_X
                usMask = HANDSHAKE_SND_X;
                break;

            case 4: // SND_CTS
                usMask = HANDSHAKE_SND_CTS;
                break;

            case 5: // SND_DSR
                usMask = HANDSHAKE_SND_DSR;
                break;

            case 6: // SND_DCD
                usMask = HANDSHAKE_SND_DCD;
                break;

            case 7: // XON_CHAR
                if (!*pszEnd && ulSetVal <= UCHAR_MAX)
                    pstPrivate->stWorkSettings.chXON = (TCHAR)ulSetVal;
                else
                    iRetVal = COM_FAILED;
                break;

            case 8: // XOFF_CHAR
                if (!*pszEnd && ulSetVal <= UCHAR_MAX)
                    pstPrivate->stWorkSettings.chXOFF = (TCHAR)ulSetVal;
                else
                    iRetVal = COM_FAILED;
                break;

            case 9: // BREAK_DURATION
                if (!*pszEnd && ulSetVal <= USHRT_MAX)
                    pstPrivate->stWorkSettings.nBreakDuration = (USHORT)ulSetVal;
                else
                    iRetVal = COM_FAILED;
                break;

            case 13: // DTR_STATE
                if (pstPrivate->hWinComm != INVALID_HANDLE_VALUE)
                    {
                    switch (ulSetVal)
                        {
                    case 0:
                        EscapeCommFunction(pstPrivate->hWinComm, CLRDTR);
                        break;

                    case 1:
                        EscapeCommFunction(pstPrivate->hWinComm, SETDTR);
                        break;

                    default:
                        iRetVal = COM_FAILED;
                        break;
                        }
                    }
                else
                    iRetVal = COM_PORT_NOT_OPEN;

                break;

            case 14: // RTS_STATE
                if (pstPrivate->hWinComm != INVALID_HANDLE_VALUE)
                    {
                    switch (ulSetVal)
                        {
                    case 0:
                        EscapeCommFunction(pstPrivate->hWinComm, CLRRTS);
                        break;

                    case 1:
                        EscapeCommFunction(pstPrivate->hWinComm, SETRTS);
                        break;

                    default:
                        iRetVal = COM_FAILED;
                        break;
                        }
                    }
                else
                    iRetVal = COM_PORT_NOT_OPEN;

                break;

                // TODO: remove when real temp settings are implemented
            case 15: // MODIFIED
                break;

            default:  // Who was that masked man?
                iRetVal = COM_FAILED;
                break;
                }

            if (usMask != 0)
                {
                // Must have been a handshake setting
                if (strcmp(pszToken, "1") == 0)
                    bitset(pstPrivate->stWorkSettings.afHandshake, usMask);
                else if (strcmp(pszToken, "0") == 0)
                    bitclear(pstPrivate->stWorkSettings.afHandshake,usMask);
                else
                    {
                    iRetVal = COM_FAILED;
                    }
                }
            }
        else    // if (pszToken && *pszToken)
            {
            iRetVal = COM_NOT_SUPPORTED;
            }
        }
    else if (lstrcmpi(pszToken, "QUERY") == 0)
        {
        iRetVal = COM_OK;
        pszToken = strtok(NULL, "\n");
        szResult[0] = TEXT('\0');

        // Look up the item to query
        for (iIndex = 0; apszItems[iIndex]; ++iIndex)
            if (lstrcmpi(pszToken, apszItems[iIndex]) == 0)
                break;

        if (*pszToken)
            {
            switch(iIndex)
                {
            case 0: // RCV_X
                usMask = HANDSHAKE_RCV_X;
                break;

            case 1: // RCV_DTR
                usMask = HANDSHAKE_RCV_DTR;
                break;

            case 2: // RCV_RTS
                usMask = HANDSHAKE_RCV_RTS;
                break;

            case 3: // SND_X
                usMask = HANDSHAKE_SND_X;
                break;

            case 4: // SND_CTS
                usMask = HANDSHAKE_SND_CTS;
                break;

            case 5: // SND_DSR
                usMask = HANDSHAKE_SND_DSR;
                break;

            case 6: // SND_DCD
                usMask = HANDSHAKE_SND_DCD;
                break;

            case 7: // XON_CHAR
                wsprintf(szResult, "%u", pstPrivate->stWorkSettings.chXON);
                break;

            case 8: // XOFF_CHAR
                wsprintf(szResult, "%u", pstPrivate->stWorkSettings.chXOFF);
                break;

            case 9: // BREAK_DURATION
                wsprintf(szResult, "%u", pstPrivate->stWorkSettings.nBreakDuration);
                break;

            case 10: // CTS_STATUS
                strcpy(szResult, bittest(*pbMdmStat, MDMSTAT_CTS) ? "1" : "0");
                break;

            case 11: // DSR_STATUS
                strcpy(szResult, bittest(*pbMdmStat, MDMSTAT_DSR) ? "1" : "0");
                break;

            case 12: // DCD_STATUS
                strcpy(szResult, bittest(*pbMdmStat, MDMSTAT_DCD) ? "1" : "0");
                break;

            case 15: // MODIFIED
                strcpy(szResult, "0");
                break;

            default:  // Who was that masked man?
                iRetVal = COM_FAILED;
                break;
                }

            if (usMask != 0)
                {
                // Must have been a handshake setting
                strcpy(szResult,
                    bittest(pstPrivate->stWorkSettings.afHandshake, usMask) ? "1" : "0");
                }

            if (szResult[0])
                {
                if (!pszResult || strlen(szResult) > uiBufrSize)
                    iRetVal = COM_FAILED;
                else
                    strcpy(pszResult, szResult);
                }
            }
        }
    else if (lstrcmpi(pszToken, "SEND") == 0)
        {
        pszToken = strtok(NULL, "\n");
        if (lstrcmpi(pszToken, "BREAK") == 0)
            {
            if (pstPrivate->hWinComm != INVALID_HANDLE_VALUE && !pstPrivate->fBreakSignalOn)
                {
                SndBufrClear(pstPrivate);
                SetCommBreak(pstPrivate->hWinComm);
                ComGetSession(pstPrivate->hCom, &hSession);

                if (TimerCreate(mGetTimerMuxHdl(hSession),
                    &pstPrivate->hTmrBreak, pstPrivate->stWorkSettings.nBreakDuration,
                    MakeProcInstance((FARPROC)DeviceBreakTimerProc, hinstDLL),
                    (DWORD)pstPrivate) != TIMER_OK)
                    {
                    //* DeviceReportError(pstPrivate, SID_ERR_NOTIMER, 0, TRUE);
                    iRetVal = COM_DEVICE_ERROR;
                    }

                pstPrivate->fBreakSignalOn = TRUE;
                iRetVal = COM_OK;
                }
            }
        }

#endif
    // Implement only the Break function.  All other comm functions handled
    // through TAPI. - mrw:6/15/95
    //
    if (_stricmp(pszInstructions, "Send Break") == 0)
        {
        if (pstPrivate->hWinComm != INVALID_HANDLE_VALUE && !pstPrivate->fBreakSignalOn)
            {
            SndBufrClear(pstPrivate);
            SetCommBreak(pstPrivate->hWinComm);
            ComGetSession(pstPrivate->hCom, &hSession);

            if (TimerCreate(sessQueryTimerMux(hSession),
                    &pstPrivate->hTmrBreak, pstPrivate->stWorkSettings.nBreakDuration,
                    DeviceBreakTimerProc,
                    pstPrivate) != TIMER_OK)
                {
                //* DeviceReportError(pstPrivate, SID_ERR_NOTIMER, 0, TRUE);
                iRetVal = COM_DEVICE_ERROR;
                }

            pstPrivate->fBreakSignalOn = TRUE;
            iRetVal = COM_OK;
            }
        }

    return iRetVal;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  DeviceLoadHdl
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *  pstPrivate  -- driver data structure
 *
 * RETURNS:
 *
 */
int WINAPI DeviceLoadHdl(ST_STDCOM *pstPrivate, SF_HANDLE sfHdl)
    {
    unsigned long ul;

    // Load comm settings from the session file. If we connect via TAPI,
    // several of these settings will be inherited from TAPI and these
    // values will not be used.
    ul = sizeof(pstPrivate->stWorkSettings.lBaud);
    sfGetSessionItem(sfHdl, SFID_COMSTD_BAUD, &ul,
            &pstPrivate->stWorkSettings.lBaud);

    ul = sizeof(pstPrivate->stWorkSettings.nDataBits);
    sfGetSessionItem(sfHdl, SFID_COMSTD_DATABITS, &ul,
            &pstPrivate->stWorkSettings.nDataBits);

    ul = sizeof(pstPrivate->stWorkSettings.nStopBits);
    sfGetSessionItem(sfHdl, SFID_COMSTD_STOPBITS, &ul,
            &pstPrivate->stWorkSettings.nStopBits);

    ul = sizeof(pstPrivate->stWorkSettings.nParity);
    sfGetSessionItem(sfHdl, SFID_COMSTD_PARITY, &ul,
            &pstPrivate->stWorkSettings.nParity);

    ul = sizeof(pstPrivate->stWorkSettings.afHandshake);
    sfGetSessionItem(sfHdl, SFID_COMSTD_HANDSHAKING, &ul,
            &pstPrivate->stWorkSettings.afHandshake);

    ul = sizeof(pstPrivate->stWorkSettings.fAutoDetect);
    sfGetSessionItem(sfHdl, SFID_COMSTD_AUTODETECT, &ul,
        &pstPrivate->stWorkSettings.fAutoDetect);

    return SF_OK;
    }

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  DeviceSaveHdl
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *  pstPrivate  -- driver data structure
 *
 * RETURNS:
 *
 */
int WINAPI DeviceSaveHdl(ST_STDCOM *pstPrivate, SF_HANDLE sfHdl)
    {
    // Save settings in session file space. Many of these values may be
    // overwritten by TAPI settings but are used by direct connect.
    sfPutSessionItem(sfHdl, SFID_COMSTD_BAUD,
            sizeof(pstPrivate->stWorkSettings.lBaud),
            &pstPrivate->stWorkSettings.lBaud);

    sfPutSessionItem(sfHdl, SFID_COMSTD_DATABITS,
            sizeof(pstPrivate->stWorkSettings.nDataBits),
            &pstPrivate->stWorkSettings.nDataBits);

    sfPutSessionItem(sfHdl, SFID_COMSTD_STOPBITS,
            sizeof(pstPrivate->stWorkSettings.nStopBits),
            &pstPrivate->stWorkSettings.nStopBits);

    sfPutSessionItem(sfHdl, SFID_COMSTD_PARITY,
            sizeof(pstPrivate->stWorkSettings.nParity),
            &pstPrivate->stWorkSettings.nParity);

    sfPutSessionItem(sfHdl, SFID_COMSTD_HANDSHAKING,
            sizeof(pstPrivate->stWorkSettings.afHandshake),
            &pstPrivate->stWorkSettings.afHandshake);

    sfPutSessionItem(sfHdl, SFID_COMSTD_AUTODETECT,
        sizeof(pstPrivate->stWorkSettings.fAutoDetect),
        &pstPrivate->stWorkSettings.fAutoDetect);

    return SF_OK;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: PortActivate
 *
 * DESCRIPTION:
 *  Called to activate the port and open it for use
 *
 * ARGUMENTS:
 *  pstPrivate  -- driver data structure
 *  pszPortName -- the name of the port to activate
 *
 * RETURNS:
 *  COM_OK if port is successfully activated
 *  COM_NOT_ENOUGH_MEMORY if there in insufficient memory for data storage
 *  COM_NOT_FOUND if named port cannot be opened
 *  COM_DEVICE_ERROR if API errors are encountered
 */
int WINAPI PortActivate(ST_STDCOM *pstPrivate,
    TCHAR *pszPortName,
    DWORD_PTR dwMediaHdl)
    {
    TCHAR           szFullPortName[_MAX_PATH];
    int             iRetVal = COM_OK;
    ST_COM_CONTROL *pstComCntrl;
    DWORD           dwThreadID;

    //
    // Free the send bufers prior to setting to malloc so we don't
    // have a memory leak.  REV: 02/27/2001.
    //
    if (pstPrivate->pbBufrStart)
        {
        free(pstPrivate->pbBufrStart);
        pstPrivate->pbBufrStart = NULL;
        }

    // Make sure we can get enough memory for buffers before opening device
    pstPrivate->pbBufrStart = malloc((size_t)pstPrivate->nRBufrSize);

    if (pstPrivate->pbBufrStart == NULL)
        {
        iRetVal = COM_NOT_ENOUGH_MEMORY;
        //* DeviceReportError(pstPrivate, SID_ERR_NOMEM, 0, TRUE);
        goto checkout;
        }

    //
    // Free the send bufers prior to setting to malloc so we don't
    // have a memory leak.  REV: 02/27/2001.
    //
    if (pstPrivate->pbSndBufr)
        {
        free(pstPrivate->pbSndBufr);
        pstPrivate->pbSndBufr = NULL;
        }

    pstPrivate->pbSndBufr = malloc((size_t) SIZE_OUTQ);
    if (pstPrivate->pbSndBufr == 0)
        {
        iRetVal = COM_NOT_ENOUGH_MEMORY;
        free(pstPrivate->pbBufrStart);
        pstPrivate->pbBufrStart = NULL;
        goto checkout;
        }

    pstPrivate->pbBufrEnd = pstPrivate->pbBufrStart + pstPrivate->nRBufrSize;
    pstPrivate->pbReadEnd = pstPrivate->pbBufrStart;
    pstPrivate->pbComStart = pstPrivate->pbComEnd = pstPrivate->pbBufrStart;
    pstPrivate->fBufrEmpty = TRUE;

#if defined(DEBUG_CHARDUMP)
	if (!pfDbgR)
		pfDbgR = fopen("comreads.dbg", "wt");
	fprintf(pfDbgR, "Port opened, internal buffer = 0x%p to 0x%p\n",
			pstPrivate->pbBufrStart, pstPrivate->pbBufrEnd - 1);
	if (!pfDbgC)
		pfDbgC = fopen("comused.dbg", "wt");
	fprintf(pfDbgC, "Port opened, internal buffer = 0x%p to 0x%p\n",
			pstPrivate->pbBufrStart, pstPrivate->pbBufrEnd - 1);
#endif

    pstPrivate->dwSndOffset = 0;
    pstPrivate->dwBytesToSend = 0;

    if (dwMediaHdl)
        {
        pstPrivate->hWinComm = (HANDLE)dwMediaHdl;

        if (PortExtractSettings(pstPrivate) != COM_OK)
            iRetVal = COM_DEVICE_ERROR;
        }

    else
        {
        // Win32 internally maps ports COM1 to COM9 to
        // \\.\COMx. We need to add this for ports COMxx,
        // and for special com devices in the registry.
        //
        lstrcpy(szFullPortName, TEXT("\\\\.\\"));
        lstrcat(szFullPortName, pszPortName);
        pstPrivate->hWinComm = CreateFile(szFullPortName,
                   GENERIC_READ | GENERIC_WRITE,
                   0,
                   (LPSECURITY_ATTRIBUTES)0,
                   OPEN_EXISTING,
                   FILE_FLAG_OVERLAPPED,
                   (HANDLE)0);


        if (pstPrivate->hWinComm == INVALID_HANDLE_VALUE)
            {
            //* Figure out which errors to report specifically

            DWORD dwError = GetLastError();

            if( dwError == ERROR_NOT_ENOUGH_MEMORY ||
                dwError == ERROR_OUTOFMEMORY ||
                dwError == ERROR_OUT_OF_STRUCTURES ||
                dwError == ERROR_INSUFFICIENT_BUFFER ||
                dwError == ERROR_COMMITMENT_LIMIT ||
                dwError == ERROR_NOT_ENOUGH_QUOTA)
                {
                iRetVal = COM_NOT_ENOUGH_MEMORY;
                }
            else if(dwError == ERROR_ACCESS_DENIED ||
                    dwError == ERROR_SHARING_VIOLATION ||
                    dwError == ERROR_LOCK_VIOLATION ||
                    dwError == ERROR_OPEN_FAILED ||
                    dwError == ERROR_IRQ_BUSY ||
                    dwError == ERROR_DEVICE_IN_USE)
                {
                iRetVal = COM_PORT_IN_USE;
                }
            else
                {
                iRetVal = COM_NOT_FOUND;
                }
            }
        }

    if (iRetVal == COM_OK)
        {
		// Major bug in Win95 - If you call SetupComm() for a standard
		// comm handle (not one given to us by TAPI) the WriteFile
        // call fails and locks the system. - mrw:2/29/96
		//
		if (IsNT())
			{
			if (SetupComm(pstPrivate->hWinComm, 8192, 8192) == FALSE)
				assert(0);
			}
        }

    if (iRetVal == COM_OK)
        {
        iRetVal = PortConfigure(pstPrivate);
        }

    if (iRetVal == COM_OK)
        {
        pstComCntrl = (ST_COM_CONTROL *)pstPrivate->hCom;
        pstComCntrl->puchRBData =
            pstComCntrl->puchRBDataLimit =
            pstPrivate->pbBufrStart;

        pstPrivate->dwEventMask = EV_ERR | EV_RLSD;
        pstPrivate->fNotifyRcv = TRUE;
        pstPrivate->fBufrEmpty = TRUE;

        if (!SetCommMask(pstPrivate->hWinComm, pstPrivate->dwEventMask))
            iRetVal = COM_DEVICE_ERROR;

        // Clear error counts on new connection
        pstPrivate->nParityErrors = 0;
        pstPrivate->nFramingErrors = 0;
        pstPrivate->nOverrunErrors = 0;
        pstPrivate->nOverflowErrors = 0;

        // Start thread to handle Reading, Writing (& 'rithmetic) & events
        pstPrivate->fHaltThread = FALSE;
        DBG_THREAD("DBG_THREAD: Calling CreateThread\r\n",0,0,0,0,0);
        pstPrivate->hComstdThread = CreateThread((LPSECURITY_ATTRIBUTES)0,
                    2000, ComstdThread, pstPrivate, 0, &dwThreadID);

        if (pstPrivate->hComstdThread)
            {
            SetThreadPriority(pstPrivate->hComstdThread,
                    THREAD_PRIORITY_ABOVE_NORMAL);
                    //THREAD_PRIORITY_TIME_CRITICAL); // - mrw:7/8/96
            }

        DBG_THREAD("DBG_THREAD: CreateThread returned %08X\r\n",
            pstPrivate->hComstdThread,0,0,0,0);
        }

checkout:
    if (iRetVal != COM_OK)
        PortDeactivate(pstPrivate);

    return iRetVal;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: PortDeactivate
 *
 * DESCRIPTION:
 *  Deactivates and closes an open port
 *
 * ARGUMENTS:
 *  pstPrivate -- Driver data structure
 *
 * RETURNS:
 *  COM_OK
 */
int WINAPI PortDeactivate(ST_STDCOM *pstPrivate)
    {
    int iRetVal = COM_OK;

    if (pstPrivate->hComstdThread)
        {
        // Halt the thread by setting a flag for the thread to detect and then
        // forcing WaitCommEvent to return by changing the event mask
        DBG_THREAD("DBG_THREAD: Shutting down comstd thread\r\n", 0,0,0,0,0);
        pstPrivate->fHaltThread = TRUE;
        SetCommMask(pstPrivate->hWinComm, pstPrivate->dwEventMask);
        PurgeComm(pstPrivate->hWinComm,
            PURGE_TXABORT | PURGE_RXABORT);  // Abort any calls in progress

        // thread should exit now, it's handle will signal when it has exited
        WaitForSingleObject(pstPrivate->hComstdThread, 5000);
        CloseHandle(pstPrivate->hComstdThread);
        pstPrivate->hComstdThread = NULL;
        DBG_THREAD("DBG_THREAD: Comstd thread has shut down\r\n", 0,0,0,0,0);
        }

    if (pstPrivate->pbBufrStart)
        {
        free(pstPrivate->pbBufrStart);
        pstPrivate->pbBufrStart = NULL;
        }

    if (pstPrivate->pbSndBufr)
        {
        free(pstPrivate->pbSndBufr);
        pstPrivate->pbSndBufr = 0;
        }

    if (pstPrivate->hWinComm != INVALID_HANDLE_VALUE)
        {
        //* As of 2/9/94, this PurgeComm call caused the program to hang
        //   or reboot
        // PurgeComm(pstPrivate->hWinComm,
        //        PURGE_TXABORT | PURGE_RXABORT);  // Flush transmit queue

        CloseHandle(pstPrivate->hWinComm);
        }

    pstPrivate->hWinComm = INVALID_HANDLE_VALUE;

    return iRetVal;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: PortConfigure
 *
 * DESCRIPTION:
 *  Configures an open port with the current set of user settings
 *
 * ARGUMENTS:
 *  pstPrivate -- The driver data structure
 *
 * RETURNS:
 *  COM_OK if port is configured successfully
 *  COM_DEVICE_ERROR if API errors are encountered
 *  COM_DEVICE_INVALID_SETTING if some user settings are not valid
 */
int WINAPI PortConfigure(ST_STDCOM *pstPrivate)
    {
    int          iRetVal = COM_OK;
    unsigned     uOverrides = 0;
    DWORD        dwError;
    DWORD        dwStructSize;
    DCB         *pstDcb;
    COMMCONFIG   stCommConfig;
    COMMTIMEOUTS stCT;

    dwStructSize = sizeof(stCommConfig);
    stCommConfig.dwSize = sizeof(stCommConfig);

    if (!GetCommConfig(pstPrivate->hWinComm, &stCommConfig, &dwStructSize))
        {
        //* DeviceReportError(pstPrivate, SID_ERR_WINDRIVER, 0, TRUE);
        iRetVal = COM_DEVICE_ERROR;
        }
    else
        {
        pstDcb = &stCommConfig.dcb;
        ComstdSettingsToDCB(&pstPrivate->stWorkSettings, pstDcb);

        // Check for overrides
        ComQueryOverride(pstPrivate->hCom, &uOverrides);

        if (bittest(uOverrides, COM_OVERRIDE_8BIT))
            {
            pstDcb->ByteSize = 8;
            pstDcb->Parity = NOPARITY;
            }

        // If we need to receive all 256 chars., we need to override
        //   XON/XOFF during sending since it will strip XON & XOFF from
        //   the incoming stream if enabled
        if (bittest(uOverrides, COM_OVERRIDE_RCVALL))
            pstDcb->fOutX = 0;

        stCommConfig.dwSize = sizeof(stCommConfig);

        if (!SetCommConfig(pstPrivate->hWinComm, &stCommConfig,
            dwStructSize))
            {
            dwError = GetLastError();

            //* Use GetLastError to figure out what went wrong, but
            //*  docs don't specify which error to check for.

            // At this point SOME setting in the DCB is bad but there is
            // no way to find out which. Since the baud rate is a likely
            // candidate. Try reissuing the command with a common baud
            // rate to see if the problem goes away
            //
            pstDcb->BaudRate = 1200;

            if (!SetCommConfig(pstPrivate->hWinComm, &stCommConfig,
                sizeof(stCommConfig)))
                {
                // If its still no good them some other setting is bad
                //* DeviceReportError(pstPrivate, SID_ERR_BADSETTING, 0, TRUE);
                }
            else
                {
                // Changing baud rate to 1200 worked, so the user's baud
                // rate must be what the driver is refusing
                //* DeviceReportError(pstPrivate, SID_ERR_BADBAUD, 0, TRUE);
                }
            iRetVal = COM_DEVICE_INVALID_SETTING;
            }
        else
            {
            stCT.ReadIntervalTimeout = 10;
            stCT.ReadTotalTimeoutMultiplier = 0;
            stCT.ReadTotalTimeoutConstant = 0;
            stCT.WriteTotalTimeoutMultiplier = 0;
            stCT.WriteTotalTimeoutConstant = 5000;
            if (!SetCommTimeouts(pstPrivate->hWinComm, &stCT))
                {
                assert(FALSE);
                iRetVal = COM_DEVICE_INVALID_SETTING;
                }
            else
                {
                }
            }
        }
    return iRetVal;
    }

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  PortExtactSettings
 *
 * DESCRIPTION:
 *  Extracts current Com settings from the Windows Com driver. This is
 *  needed when we are passed an existing Com handle by something like TAPI
 *
 * ARGUMENTS:
 *  pstPrivate -- The driver data structure
 *
 * RETURNS:
 *  COM_OK if port is configured successfully
 *  COM_DEVICE_ERROR if API errors are encountered
 */
int PortExtractSettings(ST_STDCOM *pstPrivate)
    {
    int        iRetVal;
    DWORD      dwError;
    DWORD      dwSize;
    COMMCONFIG stCommConfig;

    dwSize = sizeof(stCommConfig);
    if (!GetCommConfig(pstPrivate->hWinComm, &stCommConfig, &dwSize))
        {
        dwError = GetLastError();
        //* DeviceReportError(pstPrivate, SID_ERR_WINDRIVER, 0, TRUE);
        iRetVal = COM_DEVICE_ERROR;
        }
    else
        {
        // Unload appropriate values from DCB to our settings structure
        ComstdDCBToSettings(&stCommConfig.dcb, &pstPrivate->stWorkSettings);

        // Don't leave autodetect on if user has already set something
        // other than 8N1
        DBG_AD("DBG_AD: fAutoDetect = %d\r\n",
            pstPrivate->stWorkSettings.fAutoDetect, 0,0,0,0);
        if (pstPrivate->stWorkSettings.fAutoDetect)
            {
            if (pstPrivate->stWorkSettings.nDataBits != 8 ||
                    pstPrivate->stWorkSettings.nParity != NOPARITY ||
                    pstPrivate->stWorkSettings.nStopBits != ONESTOPBIT)
                {
                DBG_AD("DBG_AD: Turning fAutoDetect off due to non 8N1\r\n",
                    0,0,0,0,0);
                pstPrivate->stWorkSettings.fAutoDetect = FALSE;
                }
            }
        iRetVal = COM_OK;
        }
    return iRetVal;
    }

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: PortConnected
 *
 * DESCRIPTION:
 *  Determines whether the driver is currently connected to a host system.
 *  In the case of this driver, the presence of the carrier signal determines
 *  when we are connected.
 *
 * ARGUMENTS:
 *  pstPrivate -- Our private data structure
 *
 * RETURNS:
 *  TRUE if carrier is present
 *  FALSE if carrier is off
 */
int WINAPI PortConnected(ST_STDCOM *pstPrivate)
    {
    int   iRetVal = FALSE;
    DWORD dwModemStat;

    if (GetCommModemStatus(pstPrivate->hWinComm, &dwModemStat))
        iRetVal = bittest(dwModemStat, MS_RLSD_ON);
    return iRetVal;
    }

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: RcvRefill
 *
 * DESCRIPTION:
 *  Called when the receive buffer is empty to refill it. This routine
 *  should attempt to refill the buffer and return the first character.
 *  It is important that this function be implemented efficiently.
 *
 * ARGUMENTS:
 *  pstPrivate -- the driver data structure
 *
 * RETURNS:
 *  TRUE if data is put in the receive buffer
 *  FALSE if there is no new incoming data
 */
int WINAPI RcvRefill(ST_STDCOM *pstPrivate)
    {
    int fRetVal = FALSE;
    ST_COM_CONTROL *pstComCntrl;

    EnterCriticalSection(&pstPrivate->csect);

    pstPrivate->pbComStart = (pstPrivate->pbComEnd == pstPrivate->pbBufrEnd) ?
        pstPrivate->pbBufrStart : pstPrivate->pbComEnd;
    pstPrivate->pbComEnd = (pstPrivate->pbReadEnd >= pstPrivate->pbComStart) ?
        pstPrivate->pbReadEnd : pstPrivate->pbBufrEnd;
    DBG_READ("DBG_READ: Refill ComStart==%x, ComEnd==%x (ReadEnd==%x)\r\n",
        pstPrivate->pbComStart, pstPrivate->pbComEnd,
        pstPrivate->pbReadEnd, 0,0);
    if (pstPrivate->fBufrFull)
        {
        DBG_READ("DBG_READ: Refill Signalling EVENT_READ\r\n", 0,0,0,0,0);
        SetEvent(pstPrivate->ahEvent[EVENT_READ]);
        }
    if (pstPrivate->pbComStart == pstPrivate->pbComEnd)
        {
        DBG_READ("DBG_READ: Refill setting fBufrEmpty = TRUE\r\n", 0,0,0,0,0);
        pstPrivate->fBufrEmpty = TRUE;
        ComNotify(pstPrivate->hCom, NODATA);
        }
    else
        {
        pstComCntrl = (ST_COM_CONTROL *)pstPrivate->hCom;
        pstComCntrl->puchRBData = pstPrivate->pbComStart;
        pstComCntrl->puchRBDataLimit = pstPrivate->pbComEnd;

#if defined(DEBUG_CHARDUMP)
		{
        int iAvail;
        int iCnt;

        iAvail = (int) pstComCntrl->puchRBDataLimit - pstComCntrl->puchRBData;
		fprintf(pfDbgC,
			"Consumed -- %d bytes 0x%p to 0x%p:",
				iAvail,
                pstComCntrl->puchRBData,
				pstComCntrl->puchRBDataLimit - 1);
		for (iCnt = 0; iCnt < iAvail; ++iCnt)
			{
			if ((iCnt % 16) == 0)
				fputs("\n", pfDbgC);
			fprintf(pfDbgC, "%02X ", pstComCntrl->puchRBData[iCnt]);
			}
		fputs("\n", pfDbgC);
		}
#endif

        // If this com driver were being used to make the connection, we
        //  would have to check here to see whether we were connected before
        //  we called AutoDetect. Since TAPI takes care of making the
        //  connection for this app, we can just start auto detecting
        //  whenever we get control

        // Remove IsNT() to fix 420514.
        //if (!IsNT() && pstPrivate->stWorkSettings.fAutoDetect)

        if (pstPrivate->stWorkSettings.fAutoDetect)
            {
            AutoDetectAnalyze(pstPrivate,
                (int)(pstPrivate->pbComEnd - pstPrivate->pbComStart),
                pstPrivate->pbComStart);
            }

        fRetVal = TRUE;
        }

    LeaveCriticalSection(&pstPrivate->csect);
    return fRetVal;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: RcvClear
 *
 * DESCRIPTION:
 *  Clears the receiver of all received data.
 *
 * ARGUMENTS:
 *  hCom -- a comm handle returned by an earlier call to ComCreateHandle
 *
 * RETURNS:
 *  COM_OK if data is cleared
 *  COM_DEVICE_ERROR if Windows com device driver returns an error
 */
int WINAPI RcvClear(ST_STDCOM *pstPrivate)
    {
    int iRetVal = COM_OK;
    ST_COM_CONTROL *pstComCntrl = (ST_COM_CONTROL *)pstPrivate->hCom;

    EnterCriticalSection(&pstPrivate->csect);

    // Set buffer pointers to clear out any data we might have queued
    pstComCntrl->puchRBData = pstComCntrl->puchRBDataLimit =
        pstPrivate->pbBufrStart;
    pstPrivate->pbReadEnd = pstPrivate->pbBufrStart;
    pstPrivate->pbComStart = pstPrivate->pbComEnd = pstPrivate->pbBufrStart;

    if (!PurgeComm(pstPrivate->hWinComm, PURGE_RXCLEAR | PURGE_RXABORT))
        iRetVal = COM_DEVICE_ERROR;

    LeaveCriticalSection(&pstPrivate->csect);
    return iRetVal;
    }



//          Buffered send routines


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: SndBufrSend
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int WINAPI SndBufrSend(ST_STDCOM *pstPrivate, void *pvBufr, int  nSize)
    {
    int  iRetVal = COM_OK;
    DWORD dwBytesWritten;
    DWORD dwError;

    assert(pvBufr != (void *)0);
    assert(nSize <= SIZE_OUTQ);

    if (nSize > 0)
        {
        // If Auto Detection is on, we may need to manually alter the
        // parity of the output
        if (pstPrivate->stWorkSettings.fAutoDetect)
            AutoDetectOutput(pstPrivate, pvBufr, nSize);

        ComNotify(pstPrivate->hCom, SEND_STARTED);

		// We had a bug that caused the session to stop displaying new characters when
		// you used auto-connect to start typing to a modem on Win 95. I tracked it down
		// to this point in the code by moving a debug trace statement around. Put it
		// just before this EnterCriticalSection and the bug goes away. Put it just after
		// and the bug comes back. I discovered that replacing the DbgOutStr with a Sleep(0)
		// had the same effect. This is a cheap fix but seems to work. We may want to
		// spend the time to figure out exactly what is going on sometime in the future.
		//jkh 9/9/98
		Sleep(0);

        EnterCriticalSection(&pstPrivate->csect);

        assert(pstPrivate->dwBytesToSend == 0);
        assert(pstPrivate->dwSndOffset == 0);
		MemCopy(pstPrivate->pbSndBufr, (BYTE*) pvBufr, nSize);
        pstPrivate->dwBytesToSend = nSize;
        pstPrivate->dwSndOffset = 0;

        pstPrivate->stWriteOv.Offset = pstPrivate->stWriteOv.OffsetHigh = 0;
        pstPrivate->stWriteOv.hEvent = pstPrivate->ahEvent[EVENT_WRITE];

        DBG_WRITE("DBG_WRITE: %d WriteFile nSize==%d 0x%x\r\n", GetTickCount(),nSize,pstPrivate->hWinComm,0,0);
        // jmh:01-12-96 When the OVERLAPPED structure is passed to WriteFile,
        // there is character loss. Thorough investigation indicates a problem
        // within Win32 comm. Documentation says behavior is undefined when
        // this structure is not passed, but it works.
        if (WriteFile(pstPrivate->hWinComm, pstPrivate->pbSndBufr, (DWORD)nSize,
            &dwBytesWritten, &pstPrivate->stWriteOv)) // mrw:12/6/95 restored stWriteOv
            {
            assert(dwBytesWritten == (DWORD)nSize);
            DBG_WRITE("DBG_WRITE: %d WriteFile completed synchronously\r\n",GetTickCount(),0,0,0,0);
            LeaveCriticalSection(&pstPrivate->csect);
            ComNotify(pstPrivate->hCom, SEND_DONE);
            EnterCriticalSection(&pstPrivate->csect);
            pstPrivate->dwBytesToSend = 0;
            }
        else
            {
            dwError = GetLastError();
            if (dwError == ERROR_IO_PENDING)
                {
                pstPrivate->fSending = TRUE;
                }
            else
                {
                iRetVal = COM_FAILED;
                DBG_WRITE("DBG_WRITE: %d WriteFile failed %d 0x%x\r\n", GetTickCount(),dwError,pstPrivate->hWinComm,0,0);
                }
            }
        LeaveCriticalSection(&pstPrivate->csect);
        }

    return iRetVal;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: SndBufrIsBusy
 *
 * DESCRIPTION:
 *  Determines whether the driver is available to transmit a buffer of
 *  data or not.
 *
 * ARGUMENTS:
 *  pstPrivate -- address of com driver's data structure
 *
 * RETURNS:
 *  COM_OK   if data can be transmitted
 *  COM_BUSY if driver is still working on a previous buffer
 */
int WINAPI SndBufrIsBusy(ST_STDCOM *pstPrivate)
    {
    int  iRetVal = COM_OK;

    EnterCriticalSection(&pstPrivate->csect);

    if (pstPrivate->fBreakSignalOn || pstPrivate->fSending)
        {
        iRetVal = COM_BUSY;
        }

    LeaveCriticalSection(&pstPrivate->csect);

    return iRetVal;
    }



/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: SndBufrQuery
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int WINAPI SndBufrQuery(ST_STDCOM *pstPrivate,
    unsigned *pafStatus,
    long *plHandshakeDelay)
    {
    int     iRetVal = COM_OK;
    DWORD   dwErrors;
    COMSTAT stComStat;

    assert(pafStatus != NULL);

    *pafStatus = 0;

    //* temporary
    if (!SndBufrIsBusy(pstPrivate))
        {
        // If no send is in progress, return clear status
        *pafStatus = 0;
        if (plHandshakeDelay)
            *plHandshakeDelay = 0L;
        }
    else
        {
        if (ClearCommError(pstPrivate->hWinComm, &dwErrors, &stComStat))
            {
            if (stComStat.fXoffHold)
                bitset(*pafStatus, COMSB_WAIT_XON);
            if (stComStat.fCtsHold)
                bitset(*pafStatus, COMSB_WAIT_CTS);
            if (stComStat.fDsrHold)
                bitset(*pafStatus, COMSB_WAIT_DSR);
            if (stComStat.fRlsdHold)
                bitset(*pafStatus, COMSB_WAIT_DCD);
            if (stComStat.fXoffSent)
                bitset(*pafStatus, COMSB_WAIT_BUSY);

            if (*pafStatus && pstPrivate->lSndStuck == -1L)
                pstPrivate->lSndStuck = (long)startinterval();

            if (plHandshakeDelay)
                *plHandshakeDelay =
                (pstPrivate->lSndStuck == -1L ?
                0L : (long)interval(pstPrivate->lSndStuck));
            }
        }

    return iRetVal;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: SndBufrClear
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int WINAPI SndBufrClear(ST_STDCOM *pstPrivate)
    {
    int iRetVal = COM_OK;

    EnterCriticalSection(&pstPrivate->csect);
    if (SndBufrIsBusy(pstPrivate))
        {
        if (!PurgeComm(pstPrivate->hWinComm, PURGE_TXCLEAR | PURGE_TXABORT))
            iRetVal = COM_DEVICE_ERROR;
        }
    LeaveCriticalSection(&pstPrivate->csect);

    return iRetVal;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComstdThread
 *
 * DESCRIPTION:
 *	This thread services three events, reads, writes and rithmatic, uh
 *	no, I mean comm events.  It uses overlapped I/O to accomplish this
 *	task which simplifies the task since thread contention between the
 *	different events is eliminated.
 *
 * ARGUMENTS:
 *	pvData - pointer to private comm handle
 *
 * RETURNS:
 *	Eventually
 *
 */
DWORD WINAPI ComstdThread(void *pvData)
    {
    ST_STDCOM *pstPrivate =  (ST_STDCOM *)pvData;
    DWORD      dwResult;
    DWORD      dwError;
    DWORD      dwBytes;
    DWORD      dwComEvent = 0;
    long       lBytesRead;
    long       lReadSize;
    BYTE      *pbReadFrom;
    OVERLAPPED stReadOv;
    OVERLAPPED stEventOv;
    COMSTAT    stComStat;
#if defined(DEBUG_CHARDUMP)
	int        iCnt;
#endif

    DBG_THREAD("DBG_THREAD: ComstdThread starting\r\n",0,0,0,0,0);
    EnterCriticalSection(&pstPrivate->csect);

    // Set Read event to signaled to get the first Read operation going
    //
    pstPrivate->fBufrFull = TRUE;
    SetEvent(pstPrivate->ahEvent[EVENT_READ]);

    // Set ComEvent event to signaled to to get the first WaitCommEvent
    // started
    //
    SetEvent(pstPrivate->ahEvent[EVENT_COMEVENT]);

    // Clear any set state left by a previous connection.
    //
    ResetEvent(pstPrivate->ahEvent[EVENT_WRITE]);

    for ( ; ; )
        {
        LeaveCriticalSection(&pstPrivate->csect);
        DBG_THREAD("DBG_THREAD: Waiting\r\n", 0,0,0,0,0);

        dwResult = WaitForMultipleObjects(EVENT_COUNT, pstPrivate->ahEvent,
            FALSE, INFINITE);

        DBG_THREAD("DBG_THREAD: WaitForMultipleObjects returned %d\r\n",
            dwResult,0,0,0,0);

        EnterCriticalSection(&pstPrivate->csect);

        // To get this thread to exit, the deactivate routine forces a
        // fake com event by calling SetCommMask
        //
        if (pstPrivate->fHaltThread)
            {
            LeaveCriticalSection(&pstPrivate->csect);
            DBG_THREAD("DBG_THREAD: ComStd exiting thread\r\n",0,0,0,0,0);
            ExitThread(0);
            }

        switch (dwResult)
            {
        case WAIT_OBJECT_0 + EVENT_READ:
            if (pstPrivate->fBufrFull)
                {
                DBG_READ("DBG_READ: Thread -- fBufrFull = FALSE\r\n",
                    0,0,0,0,0);

                pstPrivate->fBufrFull = FALSE;
                }
            else
                {
                if (GetOverlappedResult(pstPrivate->hWinComm, &stReadOv,
                    (DWORD *)&lBytesRead, FALSE))
                    {

                    pstPrivate->pbReadEnd += lBytesRead;
#if defined(DEBUG_CHARDUMP)
					if (lBytesRead > 0)
						{
						fprintf(pfDbgR,
							"Overlapped Read -- %d bytes 0x%p to 0x%p:",
								lBytesRead, pbReadFrom,
								pstPrivate->pbReadEnd - 1);
						for (iCnt = 0; iCnt < lBytesRead; ++iCnt)
							{
							if ((iCnt % 16) == 0)
								fputs("\n", pfDbgR);
							fprintf(pfDbgR, "%02X ", pbReadFrom[iCnt]);
							}
						fputs("\n", pfDbgR);
						}
#endif

                    if (pstPrivate->pbReadEnd >= pstPrivate->pbBufrEnd)
                        pstPrivate->pbReadEnd = pstPrivate->pbBufrStart;

                    DBG_READ("DBG_READ: Thread -- got %ld, ReadEnd==%x\r\n",
                        lBytesRead, pstPrivate->pbReadEnd,0,0,0);

                    if (pstPrivate->fBufrEmpty)
                        {
                        DBG_READ("DBG_READ: Thread -- fBufrEmpty = FALSE\r\n",
                            0,0,0,0,0);

                        pstPrivate->fBufrEmpty = FALSE;
                        LeaveCriticalSection(&pstPrivate->csect);
                        ComNotify(pstPrivate->hCom, DATA_RECEIVED);
                        EnterCriticalSection(&pstPrivate->csect);
                        }
                    }

                else
					{
					switch (GetLastError())
						{
					case ERROR_OPERATION_ABORTED:
						// Operations can be aborted by calls to PurgeComm()
						// Allow setup for another read request.
						// mrw:12/14/95
						//
						break;

					default:
						// Com is failing for some reason.  Exit thread
						// so that we don't tie-up resources.
						//
	                    DBG_EVENTS("DBG_EVENTS: GetOverlappedResult "
                            "failed!\r\n",0,0,0,0,0);

						LeaveCriticalSection(&pstPrivate->csect);
						ExitThread(0);
						}
					}
                }

            // Do reads until we fill the buffer or we get an overlapped read
			//
            for ( ; ; )
                {
				// Check for wrap around in circular buffer
				//
                pbReadFrom = (pstPrivate->pbReadEnd >= pstPrivate->pbBufrEnd) ?
                    pstPrivate->pbBufrStart : pstPrivate->pbReadEnd;

#if 0   // mrw:10/7/96 - enabled shiva fix for NT 4.0 Service Pack
        // Enabled for NT 4.0 release. Per Microsoft, leave this bug
        // in, so US and international versions are identical. It was
        // found between US and international releases.
        //
                // This was causing bad packets in Zmodem transfers when
                // using Shiva's LanRover, which appeared at baud rates
                // of 57600 or higher, and using TCP/IP to connect to the
                // LanRover. lReadSize in this code would not leave an
                // unused byte at the end of the buffer if pbComStart was
                // pointing to the beginning of the buffer.
                // - jmh 07-31-96
                lReadSize = (pbReadFrom < pstPrivate->pbComStart) ?
                    (pstPrivate->pbComStart - pbReadFrom - 1) :
                    (pstPrivate->pbBufrEnd - pbReadFrom);
#else
                // Determine the extent to which we're allowed to fill the
                // buffer. pbComStart points to the start of where the buffer
                // is "reserved", waiting to be emptied from. We make sure we
                // leave the byte before pbComStart empty. - jmh 07-31-96
                //
                if (pbReadFrom < pstPrivate->pbComStart)
                    lReadSize = (long)(pstPrivate->pbComStart - pbReadFrom - 1);
                else
                    {
                    lReadSize = (long)(pstPrivate->pbBufrEnd - pbReadFrom);
                    // The circular buffer code was written so that the address
                    // pointed to by pbBufrEnd is equated with pbBufrStart. We
                    // also need to make sure that if we've just calculated
                    // that we can read to the end of the buffer (aka the
                    // *start* of the buffer), and pbComStart is pointing to
                    // the start of the buffer, there's still an empty byte
                    // before pbComStart. - jmh 07-31-96
                    //
                    if (pstPrivate->pbComStart == pstPrivate->pbBufrStart)
                        lReadSize -= 1;
                    }
#endif

                if (lReadSize > MAX_READSIZE)
                    lReadSize = MAX_READSIZE;

                if (!lReadSize)
                    {
                    DBG_READ("DBG_READ: Thread -- fBufrFull = TRUE, "
                        "unsignalling EVENT_READ\r\n",0,0,0,0,0);

                    pstPrivate->fBufrFull = TRUE;
                    ResetEvent(pstPrivate->ahEvent[EVENT_READ]);
                    break;
                    }
                else
                    {
                    // Set up to do an overlapped read. From what I can make
                    // of the documenation, this may or may not complete
                    // immediately. So, to be safe, I will code it to expect
                    // either result.
                    //
                    stReadOv.Offset = stReadOv.OffsetHigh = 0;
                    stReadOv.hEvent = pstPrivate->ahEvent[EVENT_READ];

                    DBG_READ("DBG_READ: Thread -- ReadFile started, "
                        "ReadFrom==%x, ReadSize==%ld\r\n",
                        pbReadFrom, lReadSize, 0,0,0);

					// ReadFile resets the read event semaphore
					//
                    if (ReadFile(pstPrivate->hWinComm, pbReadFrom,
                        (DWORD)lReadSize, (DWORD *)&lBytesRead,
                        &stReadOv))
                        {
                        pstPrivate->pbReadEnd += lBytesRead;

#if defined(DEBUG_CHARDUMP)
						fprintf(pfDbgR,
							"Overlapped Read -- %d bytes 0x%p to 0x%p:",
								lBytesRead, pbReadFrom,
								pstPrivate->pbReadEnd - 1);
						for (iCnt = 0; iCnt < lBytesRead; ++iCnt)
							{
							if ((iCnt % 16) == 0)
								fputs("\n", pfDbgR);
							fprintf(pfDbgR, "%02X ", pbReadFrom[iCnt]);
							}
						fputs("\n", pfDbgR);
#endif

                        if (pstPrivate->pbReadEnd >= pstPrivate->pbBufrEnd)
                            pstPrivate->pbReadEnd = pstPrivate->pbBufrStart;

                        DBG_READ("DBG_READ: Thread -- ReadFile completed "
                            "synchronously, lBytesRead==%ld, ReadEnd==%x\r\n",
                            lBytesRead, pstPrivate->pbReadEnd,0,0,0);

                        if (pstPrivate->fBufrEmpty)
                            {
                            DBG_READ("DBG_READ: Thread -- fBufrEmpty = "
                                "FALSE\r\n", 0,0,0,0,0);

                            pstPrivate->fBufrEmpty = FALSE;
                            LeaveCriticalSection(&pstPrivate->csect);
                            ComNotify(pstPrivate->hCom, DATA_RECEIVED);
                            EnterCriticalSection(&pstPrivate->csect);
                            }
                        }

					else
						{
						switch (GetLastError())
							{
						case ERROR_IO_PENDING:
							break;

						case ERROR_OPERATION_ABORTED:
							// PurgeComm can do this.  Setup for another read.
							// mrw:12/14/95
							// But clear errors or the read may fail from
                            // now to eternity! We're in an infinite for-loop,
                            // after all. jmh:06-12-96
                            ClearCommError(pstPrivate->hWinComm, &dwError, &stComStat);
							continue;

						default:
							// Com is failing for some reason.  Exit thread
							// so that we don't tie-up resources.
							//
		                    DBG_READ("DBG_READ: ReadFile failed!\r\n",
                                0,0,0,0,0);

							LeaveCriticalSection(&pstPrivate->csect);
							ExitThread(0);
							}

						break;  // Come back when event signals
						}
                    }
                }
            break;

        case WAIT_OBJECT_0 + EVENT_WRITE:
            if (GetOverlappedResult(pstPrivate->hWinComm,
                &pstPrivate->stWriteOv, &dwBytes, FALSE) == FALSE)
                {
                dwError = GetLastError();
                DBG_WRITE("DBG_WRITE: %d Overlapped WriteFile failed: errno=%d\n",
                    GetTickCount(), dwError, 0, 0, 0);
                }
            else if (dwBytes < pstPrivate->dwBytesToSend && dwBytes != 0)
                {
                // ResetEvent(pstPrivate->ahEvent[EVENT_WRITE]);

                DBG_WRITE("DBG_WRITE: %d Write result -- dwBytes==%d\r\n",
                    GetTickCount(),dwBytes,0,0,0);

                // There's more to write. Seems kinda silly, but WriteFile
                // will return a success code, and dwBytes will show
                // there's still stuff to write. So we make another call
                // to WriteFile for what's remaining. Perhaps the write
                // timeout is too short. This happens for slower baud rates
                //
                pstPrivate->dwBytesToSend -= dwBytes;
                pstPrivate->dwSndOffset += dwBytes;

                pstPrivate->stWriteOv.Offset = pstPrivate->stWriteOv.OffsetHigh = 0;
                pstPrivate->stWriteOv.hEvent = pstPrivate->ahEvent[EVENT_WRITE];

                DBG_WRITE("DBG_WRITE: %d WriteFile(2) nSize==%d 0x%x\r\n",
                    GetTickCount(), pstPrivate->dwBytesToSend, pstPrivate->hWinComm, 0, 0);
                if (WriteFile(pstPrivate->hWinComm,
                    &pstPrivate->pbSndBufr[pstPrivate->dwSndOffset],
                    pstPrivate->dwBytesToSend,
                    &dwBytes, &pstPrivate->stWriteOv))
                    {
                    assert(dwBytes == pstPrivate->dwBytesToSend);
                    DBG_WRITE("DBG_WRITE: %d WriteFile(2) completed synchronously\r\n", GetTickCount(),0,0,0,0);
                    }
                else
                    {
                    dwError = GetLastError();
                    if (dwError == ERROR_IO_PENDING)
                        {
                        break;  // This is what we expect
                        }
                    else
                        {
                        DBG_WRITE("DBG_WRITE: %d WriteFile(2) failed %d 0x%x\r\n", GetTickCount(),dwError,pstPrivate->hWinComm,0,0);
                        }
                    }
                }
            else
                {
                // The write semaphore must be reset after the call to
                // GetOverlappedResult, because it checks the semaphore
                // to see if there's an outstanding write call. jmh 01-10-96
                //
                ResetEvent(pstPrivate->ahEvent[EVENT_WRITE]);
                }

            DBG_WRITE("DBG_WRITE: %d Write result -- dwBytes==%d\r\n",
                GetTickCount(),dwBytes,0,0,0);

            pstPrivate->dwBytesToSend = 0;
            pstPrivate->dwSndOffset = 0;

            pstPrivate->fSending = FALSE;
            LeaveCriticalSection(&pstPrivate->csect);
            ComNotify(pstPrivate->hCom, SEND_DONE);
            EnterCriticalSection(&pstPrivate->csect);
            break;

        case WAIT_OBJECT_0 + EVENT_COMEVENT:
            // WaitCommEvent is returning an event flag
            //
            ResetEvent(pstPrivate->ahEvent[EVENT_COMEVENT]);

            switch (dwComEvent)
                {
            case EV_ERR:
                ClearCommError(pstPrivate->hWinComm, &dwError, &stComStat);

                DBG_EVENTS("DBG_EVENTS: EV_ERR dwError==%x\r\n",
                    dwError,0,0,0,0);

                //* need code here to record errors, handle HHS stuck etc.
                break;

            case EV_RLSD: // receive-line-signal-detect changed state.
                LeaveCriticalSection(&pstPrivate->csect);
                ComNotify(pstPrivate->hCom, CONNECT);
                EnterCriticalSection(&pstPrivate->csect);
                DBG_EVENTS("DBG_EVENTS: EV_RLSD\r\n", 0,0,0,0,0);
                break;

            default:
                DBG_EVENTS("DBG_EVENTS: EV_??? (dwComEvent==%x)\r\n",
                    dwComEvent,0,0,0,0);
                break;
                }

            // Start up another overlapped WaitCommEvent to get the
            // next event
            //
            stEventOv.Offset = stEventOv.OffsetHigh = (DWORD)0;
            stEventOv.hEvent = pstPrivate->ahEvent[EVENT_COMEVENT];

            if (WaitCommEvent(pstPrivate->hWinComm, &dwComEvent, &stEventOv))
                {
                // Call completed synchronously, re-signal our event object
                //
                DBG_EVENTS("DBG_EVENTS: WaitCommEvent completed "
                    "synchronously\r\n",0,0,0,0,0);

                SetEvent(pstPrivate->ahEvent[EVENT_COMEVENT]);
                }

            else
                {
				switch (GetLastError())
					{
				case ERROR_IO_PENDING:
                    break;

				case ERROR_OPERATION_ABORTED:
                    // Not sure this can happen but we'll code it like
                    // the read. - mrw:12/14/95
                    //
                    DBG_EVENTS("DBG_EVENTS: WaitCommEvent - "
                        "ERROR_OPERATION_ABORTED\r\n",0,0,0,0,0);

                    SetEvent(pstPrivate->ahEvent[EVENT_COMEVENT]);
					break;

				default:
					// Com is failing for some reason.  Exit thread
					// so that we don't tie-up resources.
					//
                    DBG_EVENTS("DBG_EVENTS: WaitCommEvent failed!\r\n",
                        0,0,0,0,0);

					LeaveCriticalSection(&pstPrivate->csect);
					ExitThread(0);
					}
                }
            break;

        default:
            break;
            }
        }

    return (DWORD)0;
    }


/* --- AUTO DETECT ROUTINES --- */

static int Nibble[] = {0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0}; // 1=odd, 0=even
#define OddBits(b) (Nibble[(b) / 16] ^ Nibble[(b) % 16])

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  AutoDetectAnalyze
 *
 * DESCRIPTION:
 *  Analyzes incoming data to determine the char size, parity type and
 *  stop bits
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void AutoDetectAnalyze(ST_STDCOM *pstPrivate, int nBytes, char *pchBufr)
    {
    char *pchScan = pchBufr;
    char *pszMsg;
    int fForceTo7Bits = FALSE;
    int iCnt = nBytes;

    if (!pstPrivate->fADRunning)
		{
        AutoDetectStart(pstPrivate);

		// This was a temporary fix I used while debugging a 7E1 problem that I decided
		// to leave in because it may help in some situations and shouldn't hurt.
		// In my case, when a GVC Fax 11400 V.42bis/MNP5 modem was installed as
		// "Standard Modem", an initial 8N1 CRLF from the modem negotiation got through
		// even when connecting to a 7E1 host. This made auto detect decide the whole
		// connection was 8N1. I fixed it with this little patch. Once I reinstalled the
		// modem as itself, it worked without the patch. This is not a rigourous fix
		// because there is no guarantee that there will be only two extraneous characters
		// or that they will be read all by themselves -- but this will fix the problems
		// in some typical cases and will do no harm.	jkh 9/9/98
		if (iCnt <= 2)	
			return;
		}

    if (pstPrivate->nFramingErrors > 0)
        {
        DBG_AD("DBG_AD: Got Framing Errors: shutting down\r\n", 0,0,0,0,0);
        AutoDetectStop(pstPrivate);
        // MessageBox(NULL,
        //            "Would use Wizard code here. Either wrong baud rate "
        //            "is set or unusual settings have been encountered. "
        //            "Finished code may be able to handle some cases included here.",
        //             "Auto Detection Wizard", MB_OK);
        return;
        }

    pstPrivate->nADTotal += iCnt;

    // for each byte, determine whether the lower 7 bits contain an odd
    //  number of 1 bits, then determine whether the byte would be a valid
    //  7e1 character.
    while (iCnt--)
        {
        if (OddBits(*pchScan & 0x7F))
            ++pstPrivate->nADMix;
        if (OddBits(*pchScan))
            ++pstPrivate->nAD7o1;
        if (*pchScan & 0x80)
            ++pstPrivate->nADHighBits;
        ++pchScan;
        }

    // See whether we can make any decision with what we've got
    if (pstPrivate->nADMix > 0 && pstPrivate->nADMix < pstPrivate->nADTotal)
        {
        // We now have both kinds of characters: those with an even and
        //  an odd number of bits in the lower 7 bits - so we can make
        //  a guess.
        if (pstPrivate->nAD7o1 == pstPrivate->nADTotal)
            pstPrivate->nADBestGuess = AD_7O1;
        else if (pstPrivate->nAD7o1 == 0)
            pstPrivate->nADBestGuess = AD_7E1;
        else
            pstPrivate->nADBestGuess = AD_8N1;
        }

    DBG_AD("DBG_AD: Cnt=%3d, Mix=%3d, 7o1=%3d, HB=%3d BG=%d\r\n",
        pstPrivate->nADTotal, pstPrivate->nADMix,
        pstPrivate->nAD7o1,   pstPrivate->nADHighBits,
        pstPrivate->nADBestGuess);

    // See whether we've checked a sufficient sample to determine settings
    if (pstPrivate->nADBestGuess != AD_8N1 &&
    (pstPrivate->nADTotal < MIN_AD_TOTAL ||
        pstPrivate->nADMix < MIN_AD_MIX ||
        (pstPrivate->nADTotal - pstPrivate->nADMix) < MIN_AD_MIX))
        {
        // Data sample is insufficient to draw a conclusion.
        // For now, let the data display as 7-bit data and wait for more
        fForceTo7Bits = TRUE;
        }
    else
        {
        // We have enough data to make a decision
        if (pstPrivate->nAD7o1 == 0)
            {
            // Data is 7-even-1
            pstPrivate->stWorkSettings.nDataBits = 7;
            pstPrivate->stWorkSettings.nParity = EVENPARITY;
            fForceTo7Bits = TRUE;
            pstPrivate->fADReconfigure = TRUE;
            pszMsg = "Establishing settings of 7-Even-1";
            }
        else if (pstPrivate->nAD7o1 == pstPrivate->nADTotal)
            {
            // Data is 7-odd-1
            pstPrivate->stWorkSettings.nDataBits = 7;
            pstPrivate->stWorkSettings.nParity = ODDPARITY;
            fForceTo7Bits = TRUE;
            pstPrivate->fADReconfigure = TRUE;
            pszMsg = "Establishing settings of 7-Odd-1";
            }
        else
            {
            // Data is most likely 8-none-1. But if the high bit was
            //  set on all the received data, it may have been 7-mark-1 or
            //  some other odd setting
            pstPrivate->stWorkSettings.nDataBits = 8;
            pstPrivate->stWorkSettings.nParity = NOPARITY;
            if (pstPrivate->nADHighBits == pstPrivate->nADTotal)
                pszMsg = "Settings are either 8-none-1 or something quite "
                "odd like 7-mark-one. A wizard would pop up here"
                "asking the user if the data looked correct and"
                "offering suggestions if it did not.";
            else
                pszMsg = "Establishing settings of 8-none-1";
            }

        // Decision has been made, so turn auto detect off
        DBG_AD("DBG_AD: %s\r\n", pszMsg, 0,0,0,0);
        AutoDetectStop(pstPrivate);
        if (pstPrivate->fADReconfigure)
            {
            DBG_AD("DBG_AD: Reconfiguring port\r\n", 0,0,0,0,0);
            PortConfigure(pstPrivate);
            }
        // MessageBox(NULL, pszMsg, "Auto Detection Done", MB_OK);
        }

    if (fForceTo7Bits)
        {
        while (nBytes--)
            {
            *pchBufr = (char)(*pchBufr & 0x7F);
            ++pchBufr;
            }
        }
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  AutoDetectOutput
 *
 * DESCRIPTION:
 *  Checks state of auto detection and alters outgoing characters to
 *  reflect the best guess of their parity status.
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void AutoDetectOutput(ST_STDCOM *pstPrivate, void *pvBufr, int nSize)
    {
    char *pch  = (char *)pvBufr;

    if (!pstPrivate->fADRunning)
        AutoDetectStart(pstPrivate);

    switch (pstPrivate->nADBestGuess)
        {
    case AD_8N1:
        // Do nothing
        break;

    case AD_7E1:
        // Make output look like 7e1
        DBG_AD("DBG_AD: Converting %d output char(s) to 7E1\r\n",
            nSize, 0,0,0,0);
        while (nSize--)
            {
            if (OddBits(*pch & 0x7F))
                *pch |= 0x80;
            ++pch;
            }
        break;

    case AD_7O1:
        // Make output look like 7o1
        DBG_AD("DBG_AD: Converting %d output char(s) to 7O1\r\n",
            nSize, 0,0,0,0);
        while (nSize--)
            {
            if (!OddBits(*pch & 0x7F))
                *pch |= 0x80;
            ++pch;
            }
        break;

    case AD_DONT_KNOW:
        // As long as the same single character is being sent
        //  out repeatedly, toggle the parity bit every other time

        if (nSize != 1)
            {
            pstPrivate->chADLastChar = '\0';
            pstPrivate->fADToggleParity = FALSE;
            }
        else
            {
            if (*pch != pstPrivate->chADLastChar)
                {
                pstPrivate->chADLastChar = *pch;
                pstPrivate->fADToggleParity = FALSE;
                }
            else
                {
                if (pstPrivate->fADToggleParity)
                    *pch = (*pch ^ (char)0x80);
                pstPrivate->fADToggleParity = !pstPrivate->fADToggleParity;
                }
            }
        break;

    default:
        assert(FALSE);
        break;
        }
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  AutoDetectStart
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void AutoDetectStart(ST_STDCOM *pstPrivate)
    {
    DBG_AD("DBG_AD: AutoDetectStart\r\n", 0,0,0,0,0);
    pstPrivate->nADTotal = 0;
    pstPrivate->nADMix = 0;
    pstPrivate->nAD7o1 = 0;
    pstPrivate->nADHighBits = 0;
    pstPrivate->nADBestGuess = AD_DONT_KNOW;
    pstPrivate->fADRunning = TRUE;
    pstPrivate->chADLastChar = '\0';
    pstPrivate->fADToggleParity = FALSE;
    pstPrivate->fADReconfigure = FALSE;
    pstPrivate->nFramingErrors = 0;
    }

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  AutoDetectStop
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void AutoDetectStop(ST_STDCOM *pstPrivate)
    {
    HSESSION hSession;

    DBG_AD("DBG_AD: AutoDetectStop\r\n", 0,0,0,0,0);
    pstPrivate->stWorkSettings.fAutoDetect = FALSE;
    pstPrivate->fADRunning = FALSE;

    ComGetSession(pstPrivate->hCom, &hSession);

    PostMessage(sessQueryHwndStatusbar(hSession),
        SBR_NTFY_REFRESH, (WPARAM)SBR_COM_PART_NO, 0);
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  ComstdGetAutoDetectResults
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int ComstdGetAutoDetectResults(void *pvData, BYTE *bByteSize,
    BYTE *bParity, BYTE *bStopBits)
    {
    ST_STDCOM *pstPrivate =  (ST_STDCOM *)pvData;

    assert(bByteSize);
    assert(bParity);
    assert(bStopBits);

    if (pstPrivate->fADReconfigure)
        {
        *bByteSize = (BYTE)pstPrivate->stWorkSettings.nDataBits;
        *bParity   = (BYTE)pstPrivate->stWorkSettings.nParity;
        *bStopBits = (BYTE)pstPrivate->stWorkSettings.nStopBits;
        }
    DBG_AD("DBG_AD: ComstdGetAutoDetectResults returning %d\r\n",
        pstPrivate->fADReconfigure, 0,0,0,0);
    DBG_AD("   (bits = %d, parity = %d, stops = %d)\r\n",
        *bByteSize, *bParity, *bStopBits, 0,0);
    return pstPrivate->fADReconfigure;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *      ComstdSettingsToDCB
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
static void ComstdSettingsToDCB(ST_STDCOM_SETTINGS *pstSettings, DCB *pstDcb)
    {
    unsigned         afHandshake;

    afHandshake = pstSettings->afHandshake;

    // fill in device control block
    pstDcb->BaudRate = (DWORD)pstSettings->lBaud;
    pstDcb->fBinary = 1;
    pstDcb->fParity = 1;
    pstDcb->fOutxCtsFlow = (BYTE)((bittest(afHandshake, HANDSHAKE_SND_CTS)) ? 1 : 0);
    pstDcb->fOutxDsrFlow = (BYTE)(bittest(afHandshake, HANDSHAKE_SND_DSR) ? 1 : 0);
    pstDcb->fDtrControl = bittest(afHandshake, HANDSHAKE_RCV_DTR) ?
        DTR_CONTROL_HANDSHAKE : DTR_CONTROL_ENABLE;
    pstDcb->fDsrSensitivity = 0;
    pstDcb->fTXContinueOnXoff = TRUE;
    pstDcb->fOutX = (BYTE)(bittest(afHandshake, HANDSHAKE_SND_X) ? 1 :0);
    pstDcb->fInX =  (BYTE)(bittest(afHandshake, HANDSHAKE_RCV_X) ? 1 :0);
    pstDcb->fErrorChar = 0;
    pstDcb->fNull = 0;
    pstDcb->fRtsControl = bittest(afHandshake, HANDSHAKE_RCV_RTS) ?
        RTS_CONTROL_HANDSHAKE : RTS_CONTROL_ENABLE;
    pstDcb->fAbortOnError = 1;      // so we can count all errors
    pstDcb->XonLim = 80;
    pstDcb->XoffLim = 200;
    pstDcb->ByteSize = (BYTE)pstSettings->nDataBits;
    pstDcb->Parity   = (BYTE)pstSettings->nParity;
    pstDcb->StopBits = (BYTE)pstSettings->nStopBits;
    pstDcb->XonChar = pstSettings->chXON;
    pstDcb->XoffChar = pstSettings->chXOFF;

    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *      ComstdDCBToSettings
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
static void ComstdDCBToSettings(DCB *pstDcb, ST_STDCOM_SETTINGS *pstSettings)
    {
    pstSettings->lBaud = (long)pstDcb->BaudRate;
    pstSettings->afHandshake = 0;
    if (pstDcb->fOutxCtsFlow)
        bitset(pstSettings->afHandshake, HANDSHAKE_SND_CTS);
    if (pstDcb->fOutxDsrFlow)
        bitset(pstSettings->afHandshake, HANDSHAKE_SND_DSR);
    if (pstDcb->fDtrControl == DTR_CONTROL_HANDSHAKE)
        bitset(pstSettings->afHandshake, HANDSHAKE_RCV_DTR);
    if (pstDcb->fOutX)
        bitset(pstSettings->afHandshake, HANDSHAKE_SND_X);
    if (pstDcb->fInX)
        bitset(pstSettings->afHandshake, HANDSHAKE_RCV_X);
    if (pstDcb->fRtsControl == RTS_CONTROL_HANDSHAKE)
        bitset(pstSettings->afHandshake, HANDSHAKE_RCV_RTS);
    pstSettings->nDataBits = pstDcb->ByteSize;
    pstSettings->nParity = pstDcb->Parity;
    pstSettings->nStopBits = pstDcb->StopBits;
    pstSettings->chXON = pstDcb->XonChar;
    pstSettings->chXOFF = pstDcb->XoffChar;
    }

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: DeviceBreakTimerProc
 *
 * DESCRIPTION:
 *  Called when the break timer goes off. A timer is started whenever we
 *  set the break signal on. It goes off after the break signal duration.
 *  This function clears the break signal and destroys the timer
 *
 * ARGUMENTS:
 *  dwData  -- A value stored when the timer is created. Contains pstPrivate
 *
 * RETURNS:
 *
 */
static void DeviceBreakTimerProc(void *pvData, long ulSince)
    {
    ST_STDCOM *pstPrivate = (ST_STDCOM *)pvData;

    TimerDestroy(&pstPrivate->hTmrBreak);       // this is a one-shot op
    ClearCommBreak(pstPrivate->hWinComm);    // have Win comm driver do it
    pstPrivate->fBreakSignalOn = FALSE;
    }

#if 0
void StdcomRecordErrors(ST_STDCOM *pstPrivate, int iErrorBits)
    {
    if (bittest(iErrorBits, CE_FRAME | CE_OVERRUN | CE_RXOVER | CE_RXPARITY))
        {
        if (bittest(iErrorBits, CE_FRAME))
            ++pstPrivate->nFramingErrors;

        if (bittest(iErrorBits, CE_OVERRUN))
            ++pstPrivate->nOverrunErrors;

        if (bittest(iErrorBits, CE_RXOVER))
            ++pstPrivate->nOverflowErrors;

        if (bittest(iErrorBits, CE_RXPARITY))
            ++pstPrivate->nParityErrors;
        }
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: DeviceReportError
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void DeviceReportError(ST_STDCOM *pstPrivate, UINT uiStringID,
    LPSTR pszOptInfo, BOOL fFirstOnly)
    {
    CHAR szFmtString[250];
    CHAR szErrString[250];

    if (LoadString(hinstDLL, uiStringID, szFmtString, sizeof(szFmtString) / sizeof(TCHAR)) > 0)
        {
        wsprintf(szErrString, szFmtString, pszOptInfo);
        ComReportError(pstPrivate->hCom, 0, szErrString, fFirstOnly);
        }
    }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\cncttapi\cncttapi.hh ===
/*	File: D:\WACKER\cncttapi\cncttapi.hh (Created: 10-Feb-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 7 $
 *	$Date: 5/01/01 3:44p $
 */

typedef struct stCnctDrvPrivate *HHDRIVER;

/* --- Macros --- */

#define TAPI_VER (MAKELONG(4,1))

// Required in lineGetDevConfig calls
//
#define DEVCLASS		TEXT("comm/datamodem")
#define REDIAL_MAX      40

// Essentially, I picked what I hope is a permanent line ID a TAPI
// service provider would never use.  My odds are pretty good since
// UNIMODEM numbers them from 1. - mrw
//
#define DIRECT_COM1		    0x5A2175D1
#define DIRECT_COM2		    (DIRECT_COM1+1)
#define DIRECT_COM3		    (DIRECT_COM1+2)
#define DIRECT_COM4		    (DIRECT_COM1+3)
#define DIRECT_COMWINSOCK	(DIRECT_COM1+4)
#define DIRECT_COM_DEVICE   (DIRECT_COM1 - 1)

#if defined(INCL_WINSOCK)
#define MAX_IP_ADDR_LEN		128
#endif

// Trap is similar to assert except it displays the error return code.
//
#if defined(NDEBUG)
#define TRAP(x) x
#else
#define TRAP(x) tapiTrap(x, __FILE__, __LINE__)
#endif

// Connection driver handle

struct stCnctDrvPrivate
	{
	HCNCT	 hCnct; 		// public connection handle passed to create func
	HSESSION hSession;		// public session handle passed to create func

	CRITICAL_SECTION cs;	// critical section semaphore

	int 	 iStatus;		// connection status

	HLINEAPP hLineApp;		// returned for lineInitialize(), main TAPI handle
	HLINE	 hLine; 		// handle to line we're using from lineOpen()
	HCALL	 hCall; 		// handle returned by lineMakeCall()
	LONG	 lMakeCallId;	// ID returned by lineMakeCall() used in callback
	DWORD	 dwLineCnt; 	// number of available lines from lineInitialize
	DWORD	 dwLine;		// current line we're using
	DWORD	 dwAPIVersion;	// current api version
	DWORD	 dwCountryID;	// internal TAPI ID for selected country
	DWORD	 dwCountryCode; // set in TranslateAddress()
	DWORD	 dwPermanentLineId; // identifies the modem as saved

	BOOL	 fMatchedPermanentLineID,
			 fHotPhone; 	// TAPI for is it Direct Connect

	TCHAR	 achDest[(TAPIMAXDESTADDRESSSIZE/2)+1],	// local portion of phone num.
			 achAreaCode[10],
			 achDefaultAreaCode[10],// As reported from TAPI
			 achDialableDest[TAPIMAXDESTADDRESSSIZE+1],
			 achDisplayableDest[TAPIMAXDESTADDRESSSIZE+1],
			 achCanonicalDest[TAPIMAXDESTADDRESSSIZE+1];

	TCHAR	 achLineName[100];	// used in dialing dialog
    TCHAR    achComDeviceName[256]; // used with enumerated ports.

	HWND	 hwndCnctDlg;		// connection dialog handle
	HWND	 hwndStupid;		// stupid TAPI reinit
	HWND	 hwndPCMCIA;		// valid only when PCMCIA dialog showing.

	LINECALLPARAMS 	stCallPar;	// Call params used for lineMakeCall()
	
	BOOL	 fUseCCAC;			// Use country code & area code flag.
	unsigned int uDiscnctFlags;	// Used for asychronous disconnects.

    int      iRedialCnt;        // Counter for redials.
    int      fRedialOnBusy;     // TRUE, we redial
    int      iRedialSecsRemaining; // seconds remaining to redial

	int		 iPort;

	TCHAR	 achDestAddr[MAX_IP_ADDR_LEN];

#ifdef INCL_CALL_ANSWERING
	int  fAnswering;		// Are we answering?
	int  fRestoreSettings;	// Do we need to restore our ASCII settings?
	int	 nSendCRLF;			// Temporary storage for ASCII setting.
	int  nLocalEcho;		// Temporary storage for ASCII setting.
	int  nAddLF;			// Temporary storage for ASCII setting.
	int  nEchoplex;			// Temporary storage for ASCII setting.
	void *pvUnregister;		// Un-registration data for CLoop callback.
#endif
	};

/* --- Line id struct used to store info in combo boxes	--- */

struct _stLineIds
	{
	DWORD dwLineId;
	DWORD dwPermanentLineId;
	};

typedef	struct _stLineIds * PSTLINEIDS;

/* --- Function Prototypes --- */

void cnctdrvLock(const HHDRIVER hhDriver);
void cnctdrvUnlock(const HHDRIVER hhDriver);
INT_PTR CALLBACK ConfirmDlg(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar);
int CplConfigDlg(const HWND hwnd, const int ordinal);
int EnumerateCountryCodes(const HHDRIVER hhDriver, const HWND hwndCB);
int EnumerateAreaCodes(const HHDRIVER hhDriver, const HWND hwndCB);
int EnumerateLines(const HHDRIVER hhDriver, const HWND hwndCB);
int EnumerateLinesNT(const HHDRIVER hhDriver, const HWND hwndCB);
long TranslateAddress(const HHDRIVER hhDriver);
INT_PTR CALLBACK DialingDlg(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar);
void DialingMessage(const HHDRIVER hhDriver, const int resID);
void CALLBACK lineCallbackFunc(DWORD hDevice, DWORD dwMsg, DWORD_PTR dwCallback,
                               DWORD_PTR dwParm1, DWORD_PTR dwParm2, DWORD_PTR dwParm3);

void PostDisconnect(const HHDRIVER hhDriver, const unsigned int uFlags);
int Handoff(const HHDRIVER hhDriver);
void SetStatus(const HHDRIVER hhDriver, const int iStatus);
int DoLineGetCountry(const DWORD dwCountryID, const DWORD dwAPIVersion,
    LPLINECOUNTRYLIST *ppcl);

int EnumerateTapiLocations(const HHDRIVER hhDriver, const HWND hwndCB,
								  const HWND hwndTB);

int CheckHotPhone(const HHDRIVER hhDriver, const DWORD dwLine, int *pfHotPhone);
DWORD tapiTrap(const DWORD dw, const TCHAR *file, const int line);
void ResetComboBox(const HWND hwnd);
void EnableDialNow(const HWND hwndDlg, const int fEnable);
int fCountryUsesAreaCode(const DWORD dwCountryId, const DWORD dwAPIVersion);
INT_PTR CALLBACK PCMCIADlg(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar);
int fIsStringEmpty(LPTSTR ach);
void EnableDial(const HWND hwndDlg, const BOOL fEnable);
int cncttapiGetCOMSettings( const DWORD dwLineId, LPTSTR pachStr, const size_t cb );
int cncttapiGetLineConfig( const DWORD dwLineId, VOID** ppvs );
int cncttapiSetLineConfig( const DWORD dwLineId, const HCOM hCom );

#if defined(INCL_WINSOCK)
BOOL CALLBACK cnctwsNewPhoneDlg(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar);
#endif

/* --- Driver entry points --- */

HDRIVER WINAPI cnctdrvCreate(const HCNCT hCnct, const HSESSION hSession);
int WINAPI cnctdrvDestroy(const HHDRIVER hhDriver);
int WINAPI cnctdrvInit(const HHDRIVER hhDriver);
int WINAPI cnctdrvLoad(const HHDRIVER hhDriver);
int WINAPI cnctdrvSave(const HHDRIVER hhDriver);

int WINAPI cnctdrvSetDestination(const HHDRIVER hhDriver, TCHAR * const ach,
								 const size_t cb);

int WINAPI cnctdrvQueryStatus(const HHDRIVER hhDriver);
int WINAPI cnctdrvConnect(const HHDRIVER hhDriver, const unsigned int uFlags);
int WINAPI cnctdrvDisconnect(const HHDRIVER hhDriver, const unsigned int uFlags);
int WINAPI cnctdrvComEvent(const HHDRIVER hhDriver, const enum COM_EVENTS event);

int cnctdrvGetComSettingsString(const HHDRIVER hhDriver, LPTSTR pachStr,
								const size_t cb);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\cncttapi\pcmcia.c ===
/*	File: D:\WACKER\cncttapi\pcmcia.c (Created: 28-Feb-1995)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 2/05/99 3:19p $
 */

#define TAPI_CURRENT_VERSION 0x00010004     // cab:11/14/96 - required!

#include <tapi.h>
#pragma hdrstop

#include <prsht.h>
#include <time.h>

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\misc.h>
#include <tdll\cnct.h>

#include "cncttapi.h"
#include "cncttapi.hh"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	ConfirmDlg
 *
 * DESCRIPTION:
 *	PCMCIADlg pops up when a hotplug modem is specified but
 *	not inservice.
 *
 * AUTHOR: Mike Ward, 28-Feb-1995
 */
INT_PTR CALLBACK PCMCIADlg(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar)
	{
	HHDRIVER hhDriver;

	switch (uMsg)
		{
	case WM_INITDIALOG:
		SetWindowLongPtr(hwnd, DWLP_USER, lPar);
		hhDriver = (HHDRIVER)lPar;
		hhDriver->hwndPCMCIA = hwnd;
		mscCenterWindowOnWindow(hwnd, sessQueryHwnd(hhDriver->hSession));
		break;

	case WM_COMMAND:
		switch (LOWORD(wPar))
			{
		case IDOK:
			// There is no OK button.  Instead, when the user plugs the
			// modem in, the tapi callback function will send a message.
			//
			EndDialog(hwnd, TRUE);
			break;

		case IDCANCEL:
			EndDialog(hwnd, FALSE);
			break;

		default:
			break;
			}
		break;

	case WM_DESTROY:
		hhDriver = (HHDRIVER)GetWindowLongPtr(hwnd, DWLP_USER);

		if (hhDriver)
			hhDriver->hwndPCMCIA = 0;

		break;

	default:
		return FALSE;
		}

	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\cncttapi\enum.c ===
/*      File: D:\WACKER\cncttapi\enum.c (Created: 23-Mar-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 18 $
 *	$Date: 5/01/01 3:35p $
 */

#define TAPI_CURRENT_VERSION 0x00010004     // cab:11/14/96 - required!

#include <tapi.h>
#include <unimodem.h>
#include <limits.h>
#pragma hdrstop

#include <time.h>
#include <string.h>

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\tdll.h>
#include <tdll\mc.h>
#include <tdll\assert.h>
#include <tdll\errorbox.h>
#include <tdll\cnct.h>
#include <tdll\hlptable.h>
#include <tdll\globals.h>
#include <tdll\com.h>
#include <term\res.h>
#include <tdll\htchar.h>

#include "cncttapi.hh"
#include "cncttapi.h"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	EnumerateTapiLocations
 *
 * DESCRIPTION:
 *	Enumerates tapi locations and puts them in the given combo box.
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle
 *	hwndCB		- window handle of combo box
 *	hwndTB		- calling card text window
 *
 * RETURNS:
 *	0 on success, else error
 *
 */
int EnumerateTapiLocations(const HHDRIVER hhDriver, const HWND hwndCB,
    					   const HWND hwndTB)
    {
    DWORD i, dwSize;
    LRESULT lr;
    TCHAR *pach = NULL;
    TCHAR ach[256];
    DWORD dwPreferredCardID = (DWORD)-1;
    DWORD dwCountryID = 1;
    LINETRANSLATECAPS *pLnTransCap = NULL;
    LINELOCATIONENTRY *pLnLocEntry = NULL;
    LINECARDENTRY *pLnCardEntry = NULL;

    /* --- Enumerate locations --- */

    if (hhDriver == 0)
        {
        return -1;
        }

    if ((pLnTransCap = malloc(sizeof(LINETRANSLATECAPS))) == 0)
    	{
    	assert(FALSE);
    	return -2;
    	}

    dwSize = 0; // used in this loop to call the dialog only once.

    do	{
    	memset(pLnTransCap, 0, sizeof(LINETRANSLATECAPS)); //* temp
    	pLnTransCap->dwTotalSize = sizeof(LINETRANSLATECAPS); //* temp

    	if ((i = TRAP(lineGetTranslateCaps(hhDriver->hLineApp, TAPI_VER,
    			pLnTransCap))) != 0)
    		{
    		if ( i == LINEERR_INIFILECORRUPT )
    			{
    			// Unfortunately, lineTranslateDialog does not return
    			// a failure code if the user clicks cancel.  So if
    			// we fail the second time on lineGetTranslateCaps()
    			// don't bother to do anything else.
    			//
    			if (dwSize == 0)
    				{
    				LoadString(glblQueryDllHinst(), IDS_ER_TAPI_NEEDS_INFO,
    					ach, sizeof(ach) / sizeof(TCHAR));

    				TimedMessageBox(sessQueryHwnd(hhDriver->hSession), ach,
    					0, MB_OK | MB_ICONINFORMATION, 0);

    		        free(pLnTransCap);
  		            pLnTransCap = NULL;
    				return -3;
    				}

    			if (TRAP(lineTranslateDialog(hhDriver->hLineApp, 0,
    					TAPI_VER, sessQueryHwnd(hhDriver->hSession), 0))
    						== 0)
    				{
    				dwSize = 1;
    				continue;
    				}
    			}

    		free(pLnTransCap);
  		    pLnTransCap = NULL;
    		return -4;
    		}
    	}
    while (i);	// end of do.

    if (pLnTransCap->dwNeededSize > pLnTransCap->dwTotalSize)
    	{
    	dwSize = pLnTransCap->dwNeededSize;
    	free(pLnTransCap);
  	    pLnTransCap = NULL;

    	if ((pLnTransCap = malloc(dwSize)) == 0)
    		{
    		assert(FALSE);
    		return -5;
    		}

    	pLnTransCap->dwTotalSize = dwSize;

    	if (TRAP(lineGetTranslateCaps(hhDriver->hLineApp, TAPI_VER,
    			pLnTransCap)) != 0)
    		{
            free(pLnTransCap);
  		    pLnTransCap = NULL;
    		return -6;
    		}
    	}

    /* --- Clear combo box --- */

    if (IsWindow(hwndCB))
    	SendMessage(hwndCB, CB_RESETCONTENT, 0, 0);

    /* --- Setup pointer to entry structure and enumerate --- */

    pLnLocEntry = (LINELOCATIONENTRY *)
    	((LPSTR)pLnTransCap + pLnTransCap->dwLocationListOffset);

    for (i = 0 ; i < pLnTransCap->dwNumLocations ; ++i)
    	{
    	if (pLnLocEntry->dwLocationNameSize == 0)
    		continue;

    	pach = (LPSTR)pLnTransCap + pLnLocEntry->dwLocationNameOffset;
        if (pLnLocEntry->dwLocationNameSize)   		
            MemCopy(ach, pach, pLnLocEntry->dwLocationNameSize);
    	ach[pLnLocEntry->dwLocationNameSize] = TEXT('\0');

    	if (IsWindow(hwndCB))
    		{
    		lr = SendMessage(hwndCB, CB_ADDSTRING, 0, (LPARAM)ach);

    		if (lr != CB_ERR)
    			{
    			SendMessage(hwndCB, CB_SETITEMDATA, (WPARAM)lr,
    				(LPARAM)pLnLocEntry->dwPermanentLocationID);
    			}

    		else
    			{
    			assert(FALSE);
    			}
    		}

    	// Make sure we have a default by setting the first valid entry
    	// we ecounter to the default.	Later in the enumeration, if we
    	// encounter another ID as the default, we can reset it.

    	if (pLnLocEntry->dwPermanentLocationID ==
    			pLnTransCap->dwCurrentLocationID
    				|| dwPreferredCardID == (DWORD)-1)
    		{
    		dwPreferredCardID = pLnLocEntry->dwPreferredCardID;

    		if (hhDriver->dwCountryID == (DWORD)-1)
    			dwCountryID = pLnLocEntry->dwCountryID;

    		/* --- Get default location area code if not specified --- */

    		if (pLnLocEntry->dwCityCodeSize)
    			{
    			pach = (LPSTR)pLnTransCap +
    				pLnLocEntry->dwCityCodeOffset;

   				if (pLnLocEntry->dwCityCodeSize)
                    MemCopy(hhDriver->achDefaultAreaCode, pach, pLnLocEntry->dwCityCodeSize);

    			hhDriver->achDefaultAreaCode[pLnLocEntry->dwCityCodeSize] =
    				TEXT('\0');
    			}
    		}

    	pLnLocEntry += 1;
    	}

    // If we don't have a country code loaded for this session, then
    // use the country code of the current location.
    //
    if (hhDriver->dwCountryID == (DWORD)-1)
    	hhDriver->dwCountryID = dwCountryID;

    /* --- Select the default location --- */
    	
    if (IsWindow(hwndCB))
    	{
    	// mrw,2/13/95 - changed so that selection is made by quering
    	// the combo box rather than saving the index which proved
    	// unreliable.
    	//
    	for (i = 0 ; i < pLnTransCap->dwNumLocations ; ++i)
    		{
    		lr = SendMessage(hwndCB, CB_GETITEMDATA, (WPARAM)i, 0);

    		if (lr != CB_ERR)
    			{
    			if ((DWORD)lr == pLnTransCap->dwCurrentLocationID)
    				SendMessage(hwndCB, CB_SETCURSEL, i, 0);
    			}
    		}
    	}

    /* --- Now find the card entry --- */

    if (dwPreferredCardID != (DWORD)-1)
    	{
    	pLnCardEntry = (LINECARDENTRY *)
    		((LPSTR)pLnTransCap + pLnTransCap->dwCardListOffset);

    	for (i = 0 ; i < pLnTransCap->dwNumCards ; ++i)
    		{
    		if (pLnCardEntry->dwPermanentCardID == dwPreferredCardID)
    			{
    			if (pLnCardEntry->dwCardNameSize == 0)
    				break;

    			pach = (LPSTR)pLnTransCap + pLnCardEntry->dwCardNameOffset;
   				if (pLnCardEntry->dwCardNameSize)
                    MemCopy(ach, pach, pLnCardEntry->dwCardNameSize);
    			ach[pLnCardEntry->dwCardNameSize] = TEXT('\0');

    			if (IsWindow(hwndTB))
    				SetWindowText(hwndTB, ach);

    			break;
    			}

    		pLnCardEntry += 1;
    		}
    	}

    free(pLnTransCap);
    pLnTransCap = NULL;
    return 0;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	EnumerateCountryCodes
 *
 * DESCRIPTION:
 *	Enumerates available country codes.
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle
 *	hwndCB		- combobox to fill
 *
 * RETURNS:
 *	0=success, else error code.
 *
 */
int EnumerateCountryCodes(const HHDRIVER hhDriver, const HWND hwndCB)
    {
    int iIdx;
    DWORD dw;
    DWORD dwID;
    DWORD dwSize;
    TCHAR ach[100];
    LPLINECOUNTRYLIST pcl = NULL;
    LPLINECOUNTRYENTRY pce;

    if (hhDriver == 0)
        goto ERROR_EXIT;

    /* --- Usual junk to make a TAPI call --- */

    if ((pcl = (LPLINECOUNTRYLIST)malloc(sizeof(LINECOUNTRYLIST))) == 0)
        {
        assert(0);
        goto ERROR_EXIT;
        }

	memset( pcl, 0, sizeof(LINECOUNTRYLIST) );
    pcl->dwTotalSize = sizeof(LINECOUNTRYLIST);

    // Get the country list all at once.
    //
    if (lineGetCountry(0, TAPI_VER, pcl) != 0)
        {
        assert(0);
        goto ERROR_EXIT;
        }

    if (pcl->dwNeededSize > pcl->dwTotalSize)
        {
        dwSize = pcl->dwNeededSize;
        free(pcl);
  	    pcl = NULL;

        if ((pcl = (LPLINECOUNTRYLIST)malloc(dwSize)) == 0)
            {
            assert(0);
            goto ERROR_EXIT;
            }

		memset( pcl, 0, dwSize );
        pcl->dwTotalSize = dwSize;

        if (lineGetCountry(0, TAPI_VER, pcl) != 0)
            {
            assert(0);
            goto ERROR_EXIT;
            }
        }

    // Empty contents of combo box.
    //
    if (hwndCB)
        SendMessage(hwndCB, CB_RESETCONTENT, 0, 0);

    // Country List array starts here...
    //
    pce = (LPLINECOUNTRYENTRY)((BYTE *)pcl + pcl->dwCountryListOffset);

    // Loop thru list of countries and insert into combo box.
    //
    for (dw = 0 ; dw < pcl->dwNumCountries ; ++dw, ++pce)
        {
        // Format so country name is first.
        //
        wsprintf(ach, "%s (%d)", (BYTE *)pcl + pce->dwCountryNameOffset,
            pce->dwCountryCode);

        // Add to combo box
        //
    	iIdx = (int)SendMessage(hwndCB, CB_ADDSTRING, 0, (LPARAM)ach);

        if (iIdx != CB_ERR)
            {
        	SendMessage(hwndCB, CB_SETITEMDATA, (WPARAM)iIdx,
    			    (LPARAM)pce->dwCountryID);
            }
        }

    // Find the current ID and select it.
    //
    for (dw = 0 ; dw < pcl->dwNumCountries ; ++dw)
        {
    	dwID = (DWORD)SendMessage(hwndCB, CB_GETITEMDATA, (WPARAM)dw, 0);

        if (dwID == hhDriver->dwCountryID)
            {
            SendMessage(hwndCB, CB_SETCURSEL, (WPARAM)dw, 0);
            break;
            }
        }

    // Clean up and exit
    //
    free(pcl);
    pcl = NULL;
    return 0;

    /*==========*/
ERROR_EXIT:
    /*==========*/
    if (pcl)
        {
        free(pcl);
  	    pcl = NULL;
        }

    return -1;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	EnumerateAreaCodes
 *
 * DESCRIPTION:
 *	Lists last 10 area codes used.
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle
 *	hwndCB		- combobox to fill
 *
 * RETURNS:
 *	0=success, else error.
 *
 */
int EnumerateAreaCodes(const HHDRIVER hhDriver, const HWND hwndCB)
    {
    if (hhDriver == 0)
    	{
    	assert(FALSE);
    	return -1;
    	}

    if (hhDriver->achAreaCode[0] == TEXT('\0'))
        {
    	StrCharCopyN(hhDriver->achAreaCode, hhDriver->achDefaultAreaCode,
            sizeof(hhDriver->achAreaCode) / sizeof(TCHAR));
        }

    SetWindowText(hwndCB, hhDriver->achAreaCode);
    return 0;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	EnumerateLines
 *
 * DESCRIPTION:
 *	Enumerates available lines.  If hwndCB is non-zero, loads names.
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle
 *	hwndCB		- combo box
 *
 * RETURNS:
 *	0=success, -1=error
 *
 */
int EnumerateLines(const HHDRIVER hhDriver, const HWND hwndCB)
    {
    int             fHotPhone;
    int             fRet;
    DWORD           i;
    DWORD           dwSize;
    DWORD           dwAPIVersion;
    LINEEXTENSIONID LnExtId;
    LPLINEDEVCAPS   pLnDevCaps = NULL;
    PSTLINEIDS	    pstLineIds = NULL;
    TCHAR *         pachLine;
    TCHAR           achLine[256];
    TCHAR           ach[256];
    LRESULT         lr;

    if (hhDriver == 0)
        {
        return -1;
        }

    // This call knows to free the itemdata associated with this combo.
    //
    ResetComboBox(hwndCB);

    /* --- Initialize stuff --- */

    pLnDevCaps = 0;
    hhDriver->dwLine = (DWORD)-1;
    hhDriver->fMatchedPermanentLineID = FALSE;

    /* --- Enumerate the devices --- */

    for (i = 0 ; i < hhDriver->dwLineCnt ; ++i)
    	{
    	if (lineNegotiateAPIVersion(hhDriver->hLineApp, i, TAPI_VER,
    			TAPI_VER, &dwAPIVersion, &LnExtId) != 0)
    		{
            // Could be a 1.3 driver, we continue.
    		continue;
    		}

        fRet = CheckHotPhone(hhDriver, i, &fHotPhone);
        if (fRet < 0)
            {
    		assert(0);
            continue;
            }
        else if (fRet == 0 && fHotPhone)
            {
    		continue;
    		}

    	if ((pLnDevCaps = malloc(sizeof(LINEDEVCAPS))) == 0)
    		{
    		assert(0);
    		continue;
    		}

    	// TAPI says its too small if we just allocate sizeof(LINEDEVCAPS)
    	//
    	memset( pLnDevCaps, 0, sizeof(LINEDEVCAPS) );
		pLnDevCaps->dwTotalSize = sizeof(LINEDEVCAPS);

    	/* --- Make call to find out how much we need for this device --- */

    	if (TRAP(lineGetDevCaps(hhDriver->hLineApp, i, dwAPIVersion, 0,
    			pLnDevCaps)) != 0)
    		{
    		assert(0);
    		continue;
    		}

    	/* --- Find out how big structure really needs to be --- */

    	if (pLnDevCaps->dwNeededSize > pLnDevCaps->dwTotalSize)
    		{
    		dwSize = pLnDevCaps->dwNeededSize;
    		free(pLnDevCaps);
  		    pLnDevCaps = NULL;

    		pLnDevCaps = malloc(dwSize);

    		if (pLnDevCaps == 0)
    			{
    			assert(FALSE);
    			continue;
    			}

    		pLnDevCaps->dwTotalSize = dwSize;

    		/* --- Try again --- */

    	    if (lineGetDevCaps(hhDriver->hLineApp, i, dwAPIVersion, 0,
    			    pLnDevCaps) != 0)
    			{
    			assert(FALSE);
    			free(pLnDevCaps);
                pLnDevCaps = NULL;
    			continue;
    			}
    		}

    	/* --- Check the information we're interested in --- */
        //mpt:03-19-98 added a MaxRate check to eliminate the MS VPN adapter
        //             from the list of available devices.
        if (pLnDevCaps->dwLineNameSize == 0 || pLnDevCaps->dwMaxRate == 0)
    		{
    		free(pLnDevCaps);
  		    pLnDevCaps = NULL;
    		continue;
    		}

    	pachLine = (BYTE *)pLnDevCaps + pLnDevCaps->dwLineNameOffset;
   		if (pLnDevCaps->dwLineNameSize)
            MemCopy(achLine, pachLine, pLnDevCaps->dwLineNameSize);
    	achLine[pLnDevCaps->dwLineNameSize] = TEXT('\0');

    	/* --- Put name in combo box if given one --- */

    	if (IsWindow(hwndCB))
    		{
    		// I need to associate two pieces of data with each
    		// item (permanent line id and relative line id).  Both
    		// are double words and CB_SETITEMDATA only stores a
    		// a double word.  So malloc a structure to hold both
    		// ids and store a pointer to the memory in the combobox.
    		// Call the ResetComboBox() defined in the file to reset
    		// the contents of the combobox and free the associated
    		// memory.  ResetComboBox() is also called in the dialog
    		// destroy.
    		//
    		pstLineIds = malloc(sizeof(*pstLineIds));

    		if (pstLineIds == 0)
    			{
    			assert(FALSE);
    			free(pLnDevCaps);
                pLnDevCaps = NULL;
    			continue;
    			}

    		pstLineIds->dwLineId = i;
    		pstLineIds->dwPermanentLineId = pLnDevCaps->dwPermanentLineID;

    		// Add the name to the combobox.  Since names are sorted,
    		// the index of the item is returned from SendMessage and
    		// stored in lr.  Save this index for use below.
    		//
    		lr = SendMessage(hwndCB, CB_ADDSTRING, 0, (LPARAM)achLine);

    		if (lr != CB_ERR)
    			{
    			// Note: lr was set above CB_ADDSTRING call.
    			//
    			if (SendMessage(hwndCB, CB_SETITEMDATA, (WPARAM)lr,
    					(LPARAM)pstLineIds) == CB_ERR)
    				{
    				assert(FALSE);
    				free(pstLineIds);
    				free(pLnDevCaps);
  				    pstLineIds = NULL;
  				    pLnDevCaps = NULL;
    				continue;
    				}
    			}

    		else
    			{
    			free(pstLineIds);
    			free(pLnDevCaps);
  			    pstLineIds = NULL;
  			    pLnDevCaps = NULL;
    			continue;
    			}
    		}

    	if (pLnDevCaps->dwPermanentLineID == hhDriver->dwPermanentLineId ||
    			hhDriver->dwLine == (DWORD)-1)
    		{
    		hhDriver->dwLine = i;
    		hhDriver->dwAPIVersion = dwAPIVersion;
    		StrCharCopyN(hhDriver->achLineName, achLine,
                sizeof(hhDriver->achLineName) / sizeof(TCHAR));

    		if (IsWindow(hwndCB))
    			{
    			// Note: lr was set above CB_ADDSTRING call.
    			//
    			SendMessage(hwndCB, CB_SETCURSEL, (WPARAM)lr, 0);
    			}

    		if (pLnDevCaps->dwPermanentLineID == hhDriver->dwPermanentLineId)
    			hhDriver->fMatchedPermanentLineID = TRUE;
    		}

    	/* --- Free allocated space --- */

    	free(pLnDevCaps);
  	    pLnDevCaps = NULL;
    	}

    // Load the direct to com port stuff first

    if (LoadString(glblQueryDllHinst(), IDS_CNCT_DIRECTCOM, achLine,
    	    sizeof(achLine) / sizeof(TCHAR)) == 0)
        {
        assert(FALSE);
        // The loading of the string has failed from the resource, so
        // add the non-localized string here (I don't believe this string
        // is ever translated). REV 8/13/99
        //
        StrCharCopyN(ach, TEXT("Com%d"), sizeof(ach) / sizeof(TCHAR));
        //return -1;
        }

    // Another nasty bug, DIRECT_COM4 is defined as 0x5A2175d4, which
    // makes this one heck of a loop. I think we only want to do this
    // four times (as opposed to 1.5 billion). - cab:11/14/96
    //
    // for (i = 0 ; i < DIRECT_COM4 ; ++i)
    //
    for( i = 0; i < 4; i++ )
        {
    	wsprintf(ach, achLine, i+1);

    	if (IsWindow(hwndCB))
            {
    	    lr = SendMessage(hwndCB, CB_INSERTSTRING, (WPARAM)-1,
    		    (LPARAM)ach);

    	    pstLineIds = malloc(sizeof(*pstLineIds));

    	    if (pstLineIds == 0)
    		    {
    		    assert(FALSE);
    		    continue;
    		    }

    	    // We don't use a line id here, only a permanent line id.
    	    //
    	    pstLineIds->dwPermanentLineId = DIRECT_COM1+i;

    		// Note: lr was set above CB_INSERTSTRING call.
    	    //
    	    if (SendMessage(hwndCB, CB_SETITEMDATA, (WPARAM)lr,
    			    (LPARAM)pstLineIds) == CB_ERR)
    		    {
    		    assert(FALSE);
    		    free(pstLineIds);
                pstLineIds = NULL;
    		    continue;
    		    }
            }

    	// If this is what was saved in the data file, then set
    	// the line ids.
        //
    	if ((DIRECT_COM1+i) == hhDriver->dwPermanentLineId ||
    			hhDriver->dwLine == (DWORD)-1)
    		{
    		hhDriver->dwLine = 0;
    		StrCharCopyN(hhDriver->achLineName, ach,
                sizeof(hhDriver->achLineName) / sizeof(TCHAR));

    		if (IsWindow(hwndCB))
    			{
    			// Note: lr was set above CB_ADDSTRING call.
    			//
    			SendMessage(hwndCB, CB_SETCURSEL, (WPARAM)lr, 0);
    			}

    		if ((DIRECT_COM1+i) == hhDriver->dwPermanentLineId)
    			hhDriver->fMatchedPermanentLineID = TRUE;
    		}
    	}

#if defined(INCL_WINSOCK)
    // This is causing a syntax error, so I am fixing it. Why nobody
    // found this sooner, I have no idea. - cab:11/14/96
    //
    //if (LoadString(glblQueryDllHinst(), IDS_WINSOCK_SETTINGS_STR, ach,
    //    sizeof(ach));
    //
    if (LoadString(glblQueryDllHinst(), IDS_WINSOCK_SETTINGS_STR, ach,
            sizeof(ach) / sizeof(TCHAR)) == 0)
        {
        assert(FALSE);
        // The loading of the string has failed from the resource, so
        // add the non-localized string here (I don't believe this string
        // is ever translated). REV 8/13/99
        //
        StrCharCopyN(ach, TEXT("TCP/IP (Winsock)"), sizeof(ach) / sizeof(TCHAR));
        //return -1;
        }

    if (IsWindow(hwndCB))
        {
    	lr = SendMessage(hwndCB, CB_INSERTSTRING, (WPARAM)-1,
    		(LPARAM)ach);

    	pstLineIds = malloc(sizeof(*pstLineIds));

    	if (pstLineIds == 0)
    		{
    		assert(FALSE);
    		free(pstLineIds);
  		    pstLineIds = NULL;
    		return 0;
    		}

    	// We don't use a line id here, only a permanent line id.
    	//
    	pstLineIds->dwPermanentLineId = DIRECT_COMWINSOCK;

    	// Note: lr was set above CB_INSERTSTRING call.
    	//
    	if (SendMessage(hwndCB, CB_SETITEMDATA, (WPARAM)lr,
    			(LPARAM)pstLineIds) == CB_ERR)
    		{
    		assert(FALSE);
    		}
        }

    // Check to see if the current connection is winsock. - cab:11/15/96
    //
    if (DIRECT_COMWINSOCK == hhDriver->dwPermanentLineId ||
    		hhDriver->dwLine == (DWORD)-1)
    	{
    	hhDriver->dwLine = 0;
    	StrCharCopyN(hhDriver->achLineName, ach, sizeof(hhDriver->achLineName) / sizeof(TCHAR));

    	if (IsWindow(hwndCB))
    		{
    		// Note: lr was set above CB_INSERTSTRING call.
    		//
    		SendMessage(hwndCB, CB_SETCURSEL, (WPARAM)lr, 0);
    		}

    	if (DIRECT_COMWINSOCK == hhDriver->dwPermanentLineId)
            {
    		hhDriver->fMatchedPermanentLineID = TRUE;
            }

        // Don't free the pstLineIds since it will be freed in the
  	    // ResetComboBox() function.  We were previously freeing the
  	    // memory twice causing a crash with the MSVC 6.0 runtime DLL's.
  	    // I'm suprised this did not present itself earlier. REV 8/17/98
  	    //
        //free(pstLineIds);
        }
#endif

    return 0;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	EnumerateLinesNT
 *
 * DESCRIPTION:
 *	Enumerates available lines.  This function is similar to EnumerateLines, but
 *  we use different methods to enumerate the ports under Windows NT.
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle
 *	hwndCB		- combo box
 *
 * RETURNS:
 *	0=success, -1=error
 *
 */
int EnumerateLinesNT(const HHDRIVER hhDriver, const HWND hwndCB)
    {
    int             fHotPhone;
    int             fRet;
    DWORD           i;
    DWORD           dwSize;
    DWORD           dwAPIVersion;
    LINEEXTENSIONID LnExtId;
    LPLINEDEVCAPS   pLnDevCaps = NULL;
    PSTLINEIDS	    pstLineIds = NULL;
    TCHAR *         pachLine;
    TCHAR           achLine[256];
    TCHAR           ach[256];
    TCHAR           ab[256];
    LRESULT         lr;
    LRESULT         nNumberItemInList = 0;
    HKEY            hKey;
    LONG            retval;
    DWORD           dwType;
    DWORD           dwSizeBuf;
    DWORD           iMaxComPortEnum = SHRT_MAX;   // Make sure we have a
                                                  // limit on the number of
                                                  // ports we enumerate so
                                                  // that we don't get into
                                                  // an endless loop.  SHRT_MAX
                                                  // is the scroll bar maximum
                                                  // used in the combo box
                                                  // dropdown list.
                                                  // REV: 11/14/2000.
    if (hhDriver == 0)
        {
        return -1;
        }

    // This call knows to free the itemdata associated with this combo.
    //
    ResetComboBox(hwndCB);

    /* --- Initialize stuff --- */

    pLnDevCaps = 0;
    if ( StrCharCmp(hhDriver->achLineName, "") == 0 )
        {
        hhDriver->dwLine = (DWORD)-1;
        }
    else
        {
        hhDriver->dwLine = 0;
        }

    hhDriver->fMatchedPermanentLineID = FALSE;

    /* --- Enumerate the devices --- */

    for (i = 0 ; i < hhDriver->dwLineCnt ; ++i)
    	{
    	if (retval = lineNegotiateAPIVersion(hhDriver->hLineApp, i, TAPI_VER,
    			TAPI_VER, &dwAPIVersion, &LnExtId) != 0)
    		{
            // Could be a 1.3 driver, we continue.
    		continue;
    		}

        fRet = CheckHotPhone(hhDriver, i, &fHotPhone);
        if (fRet < 0)
            {
    		assert(0);
            continue;
            }
        else if (fRet == 0 && fHotPhone)
            {
    		continue;
    		}

    	if ((pLnDevCaps = malloc(sizeof(LINEDEVCAPS))) == 0)
    		{
    		assert(0);
    		continue;
    		}

        if (hhDriver->hLineApp == 0)
            {
    		assert(FALSE);
            continue;
            }

    	// TAPI says its too small if we just allocate sizeof(LINEDEVCAPS)
    	//
    	pLnDevCaps->dwTotalSize = sizeof(LINEDEVCAPS);

    	/* --- Make call to find out how much we need for this device --- */

    	if (TRAP(lineGetDevCaps(hhDriver->hLineApp, i, dwAPIVersion, 0,
    			pLnDevCaps)) != 0)
    		{
    		assert(0);
    		continue;
    		}

    	/* --- Find out how big structure really needs to be --- */

    	if (pLnDevCaps->dwNeededSize > pLnDevCaps->dwTotalSize)
    		{
    		dwSize = pLnDevCaps->dwNeededSize;
    		free(pLnDevCaps);
  		    pLnDevCaps = NULL;

    		pLnDevCaps = malloc(dwSize);

    		if (pLnDevCaps == 0)
    			{
    			assert(FALSE);
    			continue;
    			}

    		pLnDevCaps->dwTotalSize = dwSize;

    		/* --- Try again --- */

    		if (lineGetDevCaps(hhDriver->hLineApp, i, dwAPIVersion, 0,
    				pLnDevCaps) != 0)
    			{
    			assert(FALSE);
    			continue;
    			}
    		}

    	/* --- Check the information we're interested in --- */

        //mpt:03-19-98 added a MaxRate check to eliminate the MS VPN adapter
        //             from the list of available devices.
    	//mpt 06-23-98 added a MaxNumActiveCalls check to eliminate the
    	//             H323 and Line0 devices from showing up in our list
        if (pLnDevCaps->dwLineNameSize == 0 ||
    		(pLnDevCaps->dwMaxRate == 0 || pLnDevCaps->dwMaxRate >= 1048576) ||
    		(pLnDevCaps->dwMaxNumActiveCalls > 1 && pLnDevCaps->dwMaxNumActiveCalls != 32768) )
    		{
    		free(pLnDevCaps);
  		    pLnDevCaps = NULL;
    		continue;
    		}

    	pachLine = (BYTE *)pLnDevCaps + pLnDevCaps->dwLineNameOffset;
   		if (pLnDevCaps->dwLineNameSize)
            MemCopy(achLine, pachLine, pLnDevCaps->dwLineNameSize);
    	
        achLine[pLnDevCaps->dwLineNameSize] = TEXT('\0');

    	/* --- Put name in combo box if given one --- */

    	if (IsWindow(hwndCB))
    		{
    		// I need to associate two pieces of data with each
    		// item (permanent line id and relative line id).  Both
    		// are double words and CB_SETITEMDATA only stores a
    		// a double word.  So malloc a structure to hold both
    		// ids and store a pointer to the memory in the combobox.
    		// Call the ResetComboBox() defined in the file to reset
    		// the contents of the combobox and free the associated
    		// memory.  ResetComboBox() is also called in the dialog
    		// destroy.
    		//
    		pstLineIds = malloc(sizeof(*pstLineIds));

    		if (pstLineIds == 0)
    			{
    			assert(FALSE);
    			free(pLnDevCaps);
  			    pLnDevCaps = NULL;
    			continue;
    			}

    		pstLineIds->dwLineId = i;
    		pstLineIds->dwPermanentLineId = pLnDevCaps->dwPermanentLineID;

    		// Add the name to the combobox.  Since names are sorted,
    		// the index of the item is returned from SendMessage and
    		// stored in lr.  Save this index for use below.
    		//
    		lr = SendMessage(hwndCB, CB_ADDSTRING, 0, (LPARAM)achLine);

    		if (lr != CB_ERR && lr != CB_ERRSPACE)
    			{
                nNumberItemInList++;

    			// Note: lr was set above CB_ADDSTRING call.
    			//
    			if (SendMessage(hwndCB, CB_SETITEMDATA, (WPARAM)lr,
    					(LPARAM)pstLineIds) == CB_ERR)
    				{
    				assert(FALSE);
    				free(pstLineIds);
    				free(pLnDevCaps);
  				    pstLineIds = NULL;
  				    pLnDevCaps = NULL;
    				continue;
    				}
    			}

    		else
    			{
    			free(pstLineIds);
    			free(pLnDevCaps);
  			    pstLineIds = NULL;
  			    pLnDevCaps = NULL;
    			continue;
    			}
    		}

    	if (pLnDevCaps->dwPermanentLineID == hhDriver->dwPermanentLineId ||
    			hhDriver->dwLine == (DWORD)-1)
    		{
    		hhDriver->dwLine = i;
    		hhDriver->dwAPIVersion = dwAPIVersion;
    		StrCharCopyN(hhDriver->achLineName, achLine,
                sizeof(hhDriver->achLineName) / sizeof(TCHAR));

    		if (IsWindow(hwndCB))
    			{
    			// Note: lr was set above CB_ADDSTRING call.
    			//
    			SendMessage(hwndCB, CB_SETCURSEL, (WPARAM)lr, 0);
    			}

    		if (pLnDevCaps->dwPermanentLineID == hhDriver->dwPermanentLineId)
    			hhDriver->fMatchedPermanentLineID = TRUE;
    		}

    	/* --- Free allocated space --- */

    	free(pLnDevCaps);
  	    pLnDevCaps = NULL;
    	}

    // Load the direct to com port stuff first

    if (RegOpenKey(HKEY_LOCAL_MACHINE,
    	TEXT("hardware\\devicemap\\serialcomm"), &hKey) != ERROR_SUCCESS)
    	{
    	assert(FALSE);
        // We used to return FALSE here which would mean the TCP/IP
        // would not be in the enumerated connection methods (modem,
        // COM port or Winsock) in the "Connect Using:" dropdown
        // combobox in the properties for the entries.  Since the
        // return value was never checked, we can just continue on
        // to finish the enumerations for the combobox.  Now we just
        // set the number of COM ports to enumerate to 0. REV 8/13/99.
        //
        //return FALSE;
        iMaxComPortEnum = 0;
    	}

    // Make sure we don't enumerate mar than the maximum number of ports
    // minus the number of TAPI devices.  If we are including WINSOCK, then
    // subtract 1 for the TCP/IP (WinSock) combobox item.

    #if defined(INCL_WINSOCK)
    iMaxComPortEnum = iMaxComPortEnum - (DWORD)nNumberItemInList - 1;
    #else
    iMaxComPortEnum = iMaxComPortEnum - (DWORD)nNumberItemInList;
    #endif


    // We now use a variable for the number of drives to enumerate.
    // We have set the number of COM ports to enumerate in a variable
    // above (iMaxComPortEnum == 0 if no COM ports installed). REV 8/13/99.
    //
    for (i = 0 ; i < iMaxComPortEnum ; ++i)
        {
        dwSizeBuf = sizeof(ab) / sizeof(TCHAR);
        dwSize = sizeof(ach) / sizeof(TCHAR);

        // Enumerate devices under our serialcomm key
        //
        if (RegEnumValue(hKey, i, ach, &dwSize, 0, &dwType, ab,
            &dwSizeBuf) != ERROR_SUCCESS)
            {
            break;
            }

        // Ignore anything that isn't a string.
        //
        if (dwType != REG_SZ)
            continue;

    	if (IsWindow(hwndCB))
            {
    	    lr = SendMessage(hwndCB, CB_INSERTSTRING, (WPARAM)-1,
    		    (LPARAM)ab);

            //
            // See if an error occured due to out of memory.  If so,
            // then don't enumerate any more ports.  REV: 11/15/2000
            //
            if( lr == CB_ERRSPACE || lr == CB_ERR )
                {
                break;
                }

            nNumberItemInList++;

    	    pstLineIds = malloc(sizeof(*pstLineIds));

    	    if (pstLineIds == 0)
    		    {
    		    assert(FALSE);
    		    continue;
    		    }

    	    // We don't use a line id here, only a permanent line id.
    	    //
            pstLineIds->dwPermanentLineId = DIRECT_COM_DEVICE;

    	    // Note: lr was set above CB_INSERTSTRING call.
    	    //
    	    if (SendMessage(hwndCB, CB_SETITEMDATA, (WPARAM)lr,
    			    (LPARAM)pstLineIds) == CB_ERR)
    		    {
    		    assert(FALSE);
    		    free(pstLineIds);
                pstLineIds = NULL;
    		    continue;
    		    }
            }

        if (hhDriver->fMatchedPermanentLineID == FALSE &&
    	    StrCharCmp(hhDriver->achComDeviceName, ab) == 0 || 
            hhDriver->dwLine == (DWORD)-1 )
            {
    		hhDriver->dwLine = 0;
    		StrCharCopyN(hhDriver->achLineName, ab,
                sizeof(hhDriver->achLineName) / sizeof(TCHAR));

    		if (IsWindow(hwndCB))
    			{
    			// Note: lr was set above CB_ADDSTRING call.
    			//
    			SendMessage(hwndCB, CB_SETCURSEL, (WPARAM)lr, 0);
    			}

    		hhDriver->fMatchedPermanentLineID = TRUE;
            }
    	}

#if defined(INCL_WINSOCK)
    // This is causing a syntax error, so I am fixing it. Why nobody
    // found this sooner, I have no idea. - cab:11/14/96
    //
    //if (LoadString(glblQueryDllHinst(), IDS_WINSOCK_SETTINGS_STR, ach,
    //    sizeof(ach));
    //
    if (LoadString(glblQueryDllHinst(), IDS_WINSOCK_SETTINGS_STR, ach,
            sizeof(ach) / sizeof(TCHAR)) == 0)
        {
        assert(FALSE);
        // The loading of the string has failed from the resource, so
        // add the non-localized string here (I don't believe this string
        // is ever translated). REV 8/13/99
        //
        StrCharCopyN(ach, TEXT("TCP/IP (Winsock)"), sizeof(ach) / sizeof(TCHAR));
        //return -1;
        }

    if (IsWindow(hwndCB))
        {
    	lr = SendMessage(hwndCB, CB_INSERTSTRING, (WPARAM)-1,
    		(LPARAM)ach);

        //
        // See if an error occured due to out of memory.  If so,
        // then delete the last COM port added so there is room
        // for the TCP/IP (Winsock) item.  REV: 11/15/2000
        //
        if( lr == CB_ERRSPACE )
            {
            lr = SendMessage(hwndCB, CB_DELETESTRING, (WPARAM)nNumberItemInList - 1,
                (LPARAM)0);

    	    lr = SendMessage(hwndCB, CB_INSERTSTRING, (WPARAM)-1,
    		    (LPARAM)ach);
            }

        if (lr != CB_ERR && lr != CB_ERRSPACE)
            {
    	    pstLineIds = malloc(sizeof(*pstLineIds));

    	    if (pstLineIds == 0)
    		    {
    		    assert(FALSE);
    		    free(pstLineIds);
                pstLineIds = NULL;
    		    return 0;
    		    }

            // We don't use a line id here, only a permanent line id.
            //
            pstLineIds->dwPermanentLineId = DIRECT_COMWINSOCK;

            // Note: lr was set above CB_INSERTSTRING call.
            //
            if (SendMessage(hwndCB, CB_SETITEMDATA, (WPARAM)lr,
    		        (LPARAM)pstLineIds) == CB_ERR)
    	        {
    	        assert(FALSE);
    	        }
            }
        }


    // Check to see if the current connection is winsock. - cab:11/15/96
    //
    if (DIRECT_COMWINSOCK == hhDriver->dwPermanentLineId ||
    		hhDriver->dwLine == (DWORD)-1)
    	{
    	hhDriver->dwLine = 0;
    	StrCharCopyN(hhDriver->achLineName, ach,
            sizeof(hhDriver->achLineName) / sizeof(TCHAR));

    	if (IsWindow(hwndCB))
    		{
    		// Note: lr was set above CB_INSERTSTRING call.
    		//
    		SendMessage(hwndCB, CB_SETCURSEL, (WPARAM)lr, 0);
    		}

    	if (DIRECT_COMWINSOCK == hhDriver->dwPermanentLineId)
            {
    		hhDriver->fMatchedPermanentLineID = TRUE;
            }

        // Don't free the pstLineIds since it will be freed in the
  	    // ResetComboBox() function.  We were previously freeing the
  	    // memory twice causing a crash with the MSVC 6.0 runtime DLL's.
  	    // I'm suprised this did not present itself earlier. REV 8/17/98
  	    //
  	    //free(pstLineIds);
        }
#endif

    return 0;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	DoLineGetCountry
 *
 * DESCRIPTION:
 *	Wrapper indended to query for a single country.  The caller must
 *	free the pcl when finished.
 *
 * ARGUMENTS:
 *	dwCountryID - ID of country
 *	dwApiVersion - Api version (no longer used)
 *	ppcl		- pointer to a LPLINECOUNTRYLIST
 *
 * RETURNS:
 *	0=OK
 *
 */
int DoLineGetCountry(const DWORD dwCountryID, const DWORD dwAPIVersion,
        LPLINECOUNTRYLIST *ppcl)
    {
    DWORD dwSize;
    LPLINECOUNTRYLIST pcl = NULL;

    if ((pcl = malloc(sizeof(LINECOUNTRYLIST))) == 0)
    	{
    	assert(FALSE);
    	return -1;
    	}

    pcl->dwTotalSize = sizeof(LINECOUNTRYLIST);

    if (lineGetCountry(dwCountryID, TAPI_VER, pcl) != 0)
    	{
    	assert(FALSE);
    	free(pcl);
  	    pcl = NULL;
    	return -1;
    	}

    if (pcl->dwNeededSize > pcl->dwTotalSize)
    	{
    	dwSize = pcl->dwNeededSize;
    	free(pcl);
  	    pcl = NULL;

    	if ((pcl = malloc(dwSize)) == 0)
    		{
    		assert(FALSE);
    		return -1;
    		}

    	pcl->dwTotalSize = dwSize;

    	if (lineGetCountry(dwCountryID, TAPI_VER, pcl) != 0)
    		{
    		assert(FALSE);
    		free(pcl);
  		    pcl = NULL;
    		return -1;
    		}
    	}

    *ppcl = pcl;
    return 0;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctdrvGetComSettingsString
 *
 * DESCRIPTION:
 *	Retrieves a string formatted for display on the status line.
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle
 *	pachStr 	- buffer to store string
 *	cb			- size of buffer
 *
 * RETURNS:
 *	0=OK,else error
 *
 */
int cnctdrvGetComSettingsString(const HHDRIVER hhDriver, LPTSTR pachStr,
    							const size_t cb)
    {
    static CHAR acParity[] = "NOEMS";  // see com.h
    static CHAR *pachStop[] = {"1", "1.5", "2"};
    HCOM         hCom;
    TCHAR        ach[100];
    LPVARSTRING  pvs = NULL;
    int          fAutoDetect = FALSE;
    long         lBaud = 0;
    int          iDataBits = 8;
    int          iParity = 0;
    int          iStopBits = 0;


    // Check the parameters
    //
    if (hhDriver == 0)
    	{
    	assert(0);
    	return -1;
    	}

    if (pachStr == 0 || cb == 0)
    	{
    	assert(0);
    	return -2;
    	}

    ach[0] = TEXT('\0');

    if ((hCom = sessQueryComHdl(hhDriver->hSession)) == 0)
    	return -7;

//	//MPT:11-01-98 Microsoft made these changes to fix a bug relating
//	//             to working with multiple connection devices.
//	if (ComGetAutoDetect(hCom, &fAutoDetect) == COM_OK && fAutoDetect)
//		{
//		LoadString(glblQueryDllHinst(), IDS_STATUSBR_AUTODETECT, ach,
//			sizeof(ach) / sizeof(TCHAR));
//		}
#if defined(INCL_WINSOCK)
    /*else*/ if (hhDriver->dwPermanentLineId == DIRECT_COMWINSOCK)
        {
        // Baud rate, data bits, parity, stop bits don't make sense in
        // TCP/IP. Load an alternate string.
        //
        LoadString(glblQueryDllHinst(), IDS_STATUSBR_COM_TCPIP, ach,
            sizeof(ach) / sizeof(TCHAR));
        }
#endif
    else if (IN_RANGE(hhDriver->dwPermanentLineId, DIRECT_COM1, DIRECT_COM4)
            || hhDriver->dwPermanentLineId == DIRECT_COM_DEVICE)
    	{
		long  lBaud = 0;
		int   iDataBits = 0;
		int   iParity = 0;
		int   iStopBits = 0;

    	ComGetBaud(hCom, &lBaud);
    	ComGetDataBits(hCom, &iDataBits);
    	ComGetParity(hCom, &iParity);
    	ComGetStopBits(hCom, &iStopBits);

    	wsprintf(ach, "%ld %d-%c-%s", lBaud, iDataBits,
    			acParity[iParity], pachStop[iStopBits]);
    	}

    // Usual 100 lines of code for a TAPI call
    //
    else if (hhDriver->dwLine != (DWORD)-1)
    	{
        int   retValue = 0;

        iDataBits = 8;
        iParity = NOPARITY;
        iStopBits = ONESTOPBIT;

        retValue = cncttapiGetLineConfig( hhDriver->dwLine, (VOID **) &pvs);

        if (retValue != 0)
            {
            return retValue;
            }
        else
    	    {
            // The structure of the DevConfig block is as follows
            //
            //	VARSTRING
            //	UMDEVCFGHDR
            //	COMMCONFIG
            //	MODEMSETTINGS
            //
            // The UMDEVCFG structure used below is defined in the
            // UNIMODEM.H provided in the platform SDK (in the nih
            // directory for HTPE). REV: 12/01/2000 
            //
    	    PUMDEVCFG pDevCfg = NULL;
        
            pDevCfg = (UMDEVCFG *)((BYTE *)pvs + pvs->dwStringOffset);

    		// commconfig struct has a DCB structure we dereference for the
    		// com settings.
    		//
			lBaud = pDevCfg->commconfig.dcb.BaudRate;
			iDataBits = pDevCfg->commconfig.dcb.ByteSize;
			iParity = pDevCfg->commconfig.dcb.Parity;
			iStopBits = pDevCfg->commconfig.dcb.StopBits;
            }

		wsprintf(ach, "%ld %d-%c-%s", lBaud, iDataBits,
                 acParity[iParity], pachStop[iStopBits]);
    	}

	// Moved this test to last so any change from 8N1 will not show auto-detect jkh 9/9/98
    if (iDataBits == 8 && iParity == NOPARITY && iStopBits == ONESTOPBIT &&
			ComGetAutoDetect(hCom, &fAutoDetect) == COM_OK && fAutoDetect)
    	{
    	LoadString(glblQueryDllHinst(), IDS_STATUSBR_AUTODETECT, ach,
    		sizeof(ach) / sizeof(TCHAR));
    	}

    StrCharCopyN(pachStr, ach, cb);
    pachStr[cb-1] = TEXT('\0');
    free(pvs);
    pvs = NULL;

    return 0;
    }

#if !defined(NDEBUG)
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	tapiTrap
 *
 * DESCRIPTION:
 *	Take one part stupidity, add two parts frustration, and stir
 *	until throughly confused.
 *
 * ARGUMENTS:
 *	dw	- result code from tapi
 *	file - file where error occured
 *	line - line where error occured
 *
 * RETURNS:
 *	dw
 *
 */
DWORD tapiTrap(const DWORD dw, const TCHAR *file, const int line)
    {
    char ach[256];

    if (dw != 0)
    	{
    	wsprintf(ach, "TAPI returned %x on line %d of file %s", dw, line, file);
    	MessageBox(GetFocus(), ach, "TAPI Trap", MB_OK | MB_ICONINFORMATION);
    	}

    return dw;
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\comstd\rc_id.h ===
/* rc_id.hh -- Private header file for stdcom communications driver module
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:02p $
 */

/* --- Resource IDs --- */

// Dialog control IDs
#define ID_CB_XSENDING	101
#define ID_CB_XRECVING	102
#define ID_CMB_XON		103
#define ID_CMB_XOFF 	104
#define ID_RB_RX_NONE	105
#define ID_RB_RX_RTS	106
#define ID_RB_RX_DTR	107
#define ID_RB_TX_NONE	108
#define ID_RB_TX_CTS	109
#define ID_RB_TX_DSR	110
#define ID_CMB_BREAK_DUR 111
#define ID_TEXT_PARITY	 112
#define ID_TEXT_FRAMING  113
#define ID_TEXT_OVERFLOW 114
#define ID_TEXT_OVERRUN  115


// String IDs
#define SID_DEVICE_NAME 	1
#define SID_ERR_VERSION 	2
#define SID_ERR_NOMEM		3
#define SID_ERR_NOPORT		4
#define SID_ERR_NOOPEN		5
#define SID_ERR_NOTIMER 	6
#define SID_ERR_WINDRIVER	7
#define SID_ERR_BADSETTING	8
#define SID_ERR_BADBAUD 	9
#define SID_ERR_BADCHARVAL	10
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\comstd\comstd.hh ===
/* comstd.hh -- Private header file for stdcom communications driver module
 *
 *  Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *  All rights reserved
 *
 *  $Revision: 4 $
 *  $Date: 5/01/01 1:41p $
 */

// -=-=-=-=-=-=-=-=-=-=-=-=-=- DEBUG CONTROL -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

// These constants are used to turn on various types of debug display
//#define DEBUG_THREAD 	  // Thread startup and shutdown
//#define DEBUG_READ		  // Read operations, main & thread
//#define DEBUG_WRITE		  // Write operations, main & thread
//#define DEBUG_EVENTS       // Com Events handled in thread
//#define DEBUG_AD           // Auto Detect

#if defined(DEBUG_THREAD)
    #define DEBUGSTR
    #define DBG_THREAD(s,a1,a2,a3,a4,a5) DbgOutStr(s,a1,a2,a3,a4,a5)
#else
    #define DBG_THREAD(s,a1,a2,a3,a4,a5)
#endif

#if defined(DEBUG_READ)
    #define DEBUGSTR
    #define DBG_READ(s,a1,a2,a3,a4,a5) DbgOutStr(s,a1,a2,a3,a4,a5)
#else
    #define DBG_READ(s,a1,a2,a3,a4,a5)
#endif

#if defined(DEBUG_WRITE)
    #define DEBUGSTR
    #define DBG_WRITE(s,a1,a2,a3,a4,a5) DbgOutStr(s,a1,a2,a3,a4,a5)
#else
    #define DBG_WRITE(s,a1,a2,a3,a4,a5)
#endif

#if defined(DEBUG_EVENTS)
    #define DEBUGSTR
    #define DBG_EVENTS(s,a1,a2,a3,a4,a5) DbgOutStr(s,a1,a2,a3,a4,a5)
#else
    #define DBG_EVENTS(s,a1,a2,a3,a4,a5)
#endif

#if defined(DEBUG_AD)
    #define DEBUGSTR
    #define DBG_AD(s,a1,a2,a3,a4,a5) DbgOutStr(s,a1,a2,a3,a4,a5)
#else
    #define DBG_AD(s,a1,a2,a3,a4,a5)
#endif


// -=-=-=-=-=-=-=-=-=-=-=-=-=- DEFINITIONS -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

#define SIZE_INQ     1152
#define SIZE_OUTQ    2048
#define MAX_READSIZE 80L

// Set these values to make auto detection work
#define MIN_AD_TOTAL 15
#define MIN_AD_MIX   6

// Values for nBestGuess
#define AD_DONT_KNOW 0
#define AD_8N1       1
#define AD_7O1       2
#define AD_7E1       3

// Flag values in afHandshake
#define HANDSHAKE_RCV_X     0x0001
#define HANDSHAKE_RCV_DTR   0x0002
#define HANDSHAKE_RCV_RTS   0x0004
#define HANDSHAKE_SND_X     0x0008
#define HANDSHAKE_SND_CTS   0x0010
#define HANDSHAKE_SND_DSR   0x0020
#define HANDSHAKE_SND_DCD   0x0040

#define MDMSTAT_CTS 0x10
#define MDMSTAT_DSR 0x20
#define MDMSTAT_DCD 0x80

#define STDCOM struct s_stdcom *

// System value item IDs

#define SFID_COMSTD_BAUD          0x1011
#define SFID_COMSTD_DATABITS      0x1012
#define SFID_COMSTD_STOPBITS      0x1013
#define SFID_COMSTD_PARITY        0x1014
#define SFID_COMSTD_HANDSHAKING   0x1015
#define SFID_COMSTD_XON           0x1016
#define SFID_COMSTD_XOFF          0x1017
#define SFID_COMSTD_BREAK         0x1018
#define SFID_COMSTD_AUTODETECT    0x1019

// Identifiers for events in ahEvents
#define EVENT_COMEVENT  0
#define EVENT_READ      1
#define EVENT_WRITE     2
#define EVENT_COUNT     3

#if defined(INCL_WINSOCK)
// Size of receive circular buffer
#define WSOCK_SIZE_INQ       	1500

// Size of send circular bufffer. Don't make too big or status displays
//  during file transfers will act oddly.
#define WSOCK_SIZE_OUTQ      	3000

#define WSOCK_MAX_READSIZE 	1500L
#define IP_ADDR_LEN     128

// Note: This was once "HA/WinSock" however this would cause HyperTerminal
// to crash if HAWin16 was running and using WinSock. Since this was an
// obvious cut-and-paste job, I have changed this to be unique for
// HyperTerminal. - cab:12/06/96
//
#define	WINSOCK_EVENT_WINDOW_CLASS	"HyperTrm/WinSock"

#define	WM_WINSOCK_NOTIFY	(WM_USER+133)
#define	WM_WINSOCK_RESOLVE	(WM_USER+134)
#define WM_WINSOCK_STARTUP  (WM_USER+135)

#define MODE_MAX    5
#endif  // defined(INCL_WINSOCK)

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-= TYPES =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

typedef struct s_stdcom_settings
    {
    long     lBaud;
    int      nDataBits;
    int      nStopBits;
    int      nParity;
    unsigned afHandshake;
    TCHAR    chXON;
    TCHAR    chXOFF;
    int      nBreakDuration;
    int      fAutoDetect;
    } ST_STDCOM_SETTINGS;

#if defined(INCL_WINSOCK)
struct stOptionStateData
	{
	int option;
	int us;
	int usq;
	int him;
	int himq;
	};
typedef struct stOptionStateData STOPT;
typedef STOPT FAR * PSTOPT;
#endif  // defined(INCL_WINSOCK)

typedef struct s_stdcom
    {
    // Configuration details
    ST_STDCOM_SETTINGS stFileSettings;
    ST_STDCOM_SETTINGS stWorkSettings;

    // These are control variables private to the stdcom driver
    HCOM     hCom;                 // access to com routines
    HANDLE   hWinComm;             // handle to windows comm device
    HTIMER   hTmrBreak;            // Timer to control break duration
    int      fBreakSignalOn;       // TRUE while sending break signal
    int      fNotifyRcv;           // TRUE if driver should send notification
    DWORD    dwEventMask;          // Mask used in Set/GetCommEventmask
    int      fSending;             // TRUE if we've sent a buffer of data
    long     lSndTimer;            // started when we issue a WriteComm
    long     lSndLimit;            // amt. of time to wait for send
    long     lSndStuck;            // amt. of time we've been waiting for
                                   //   handshaking
    HWND     hwndEvents;           // window to process event messages
                                   //  generate messages for us
    BYTE     bLastMdmStat;
    OVERLAPPED stWriteOv;

    // Control fields for receiving
    int     nRBufrSize;            // Size of receive buffer
    BYTE   *pbBufrStart;           // Address of receive buffer
    BYTE   *pbBufrEnd;
    BYTE   *pbReadEnd;             // Where read thread left off
    BYTE   *pbComStart;            // Marks area being unloaded by main Com
    BYTE   *pbComEnd;
    int     fBufrFull;             // True when driver buffers are full
    int     fBufrEmpty;            // True when driver buffers are empty

    // Control fields for sending
    DWORD   dwBytesToSend;          // Number of bytes pending for write
    DWORD   dwSndOffset;            // Offset into send buffer for write
    BYTE   *pbSndBufr;              // Buffer used by pending write calls

    // Error counts
    int     nParityErrors;
    int     nFramingErrors;
    int     nOverrunErrors;
    int     nOverflowErrors;

    // Auto detection fields
    int  fADRunning;
    int  nADTotal;
    int  nADMix;
    int  nAD7o1;
    int  nADHighBits;
    int  nADBestGuess;
    char chADLastChar;
    int  fADToggleParity;
    int  fADReconfigure;

    HANDLE  hComstdThread;         // Thread to handle ongoing activity
    int     fHaltThread;           // To control when thread shuts down

    // Data access control
    CRITICAL_SECTION csect;        // To synchronize access to driver vars.
    HANDLE  ahEvent[EVENT_COUNT];  // To control scheduling

#if defined(INCL_WINSOCK)
    // Configuration details
	// These are control variables private to the tcpip comm driver
	SOCKET          hSocket;            // connected socket
	int             fConnected;         // -1 initially, 0 if init'd, 1 connected
	TCHAR           szRemoteAddr[IP_ADDR_LEN];// IP address
	short           nPort;              // Port number
	unsigned long   ulCompatibility;    // to pass flags into dialogs

	ULONG  ulAddr;

	// These are control variables private to the stdcom driver
	int		 fSndBreak;		   	   // emulate a break sequence

    // Control fields for receiving
	BYTE	*pbSendBufr;			// Pointer to data passed to SndBufrSend
	int	    nSendBufrLen;			// Amount of data to send
	BYTE	abSndBufr[WSOCK_SIZE_OUTQ*2];	// Buffer to send when Winsock is ready
	BYTE    *pbSndPtrEnd;			// Current offset in auchSndBufr

    HANDLE  hComReadThread;        	// Thread to handle reading from network
    HANDLE  hComWriteThread;       	// Thread to handle writing to network
    HANDLE  hComConnectThread;      // Thread to handle connecting to host
	int		fClearSendBufr;			// flag to signal send buffer to be cleared
	int		fEscapeFF;				// We are escaping FF characters (by doubling)
	int		fSeenFF;				// We have just encountered and FF character

    union {                                     // JYF: 29-Sep-2000, fix alignment fault
        HOSTENT stHostBuf;                      // used by WSAGetHostByName
        BYTE    pcharHostBuf[MAXGETHOSTSTRUCT]; // for allocating MAXGETHOSTSTRUCT bytes
        };

    struct sockaddr_in  stHost;

    // Pointers to socket library functions (porting note: these are just pasted in from winsock.h
    // with the function pointer declaration fixed up)
    int (PASCAL * FAR accept)( int, struct sockaddr *, int * );
    int (PASCAL * FAR bind)( int, struct sockaddr *, int );
    int (PASCAL * FAR connect)( int, struct sockaddr *, int );
    int (PASCAL * FAR gethostid)(void);
    int (PASCAL * FAR listen)( int, int);
    int (PASCAL * FAR recv)( int, char *, int, int );
    int (PASCAL * FAR send)( int, char *, int, int );
    int (PASCAL * FAR sock_init)( void );
    int (PASCAL * FAR sock_errno)( void );
    int (PASCAL * FAR socket)( int, int, int );
    int (PASCAL * FAR soclose)( int );
    int (PASCAL * FAR shutdown)(int, int);
    int (PASCAL * FAR setsockopt)( int, int, int, char *, int );

    // from netdb.h
    struct hostent * (PASCAL * FAR gethostbyname)( char * );

    // from netinet/in.h
    unsigned long (PASCAL * FAR inet_addr)(char *);

    // from utils.h
    unsigned short (PASCAL * FAR bswap)(unsigned short);

    // Telnet emulation data
    int         NVTstate;       // Current state of Network Virtual Terminal
    STOPT       stMode[MODE_MAX];

#ifdef INCL_CALL_ANSWERING
	// Answer mode variables - cab:11/19/96
	//
	int	fAnswer;			// Are we waiting for a call?
#endif
	
#endif  // defined(INCL_WINSOCK)
    } ST_STDCOM;


// -=-=-=-=-=-=-=-=-=-=-=- Globals -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
extern   HINSTANCE hinstDLL;



// -=-=-=-=-=-=-=-=-=-=-=- EXPORTED PROTOTYPES -=-=-=-=-=-=-=-=-=-=-=-=-=-=-

int    WINAPI DeviceInitialize(HCOM hCom, unsigned usInterfaceVersion,
                    void **ppvDriverData);
int    WINAPI DeviceClose(ST_STDCOM *pstPrivate);
int    WINAPI DeviceDialog(ST_STDCOM *pstPrivate, HWND hwndParent);
int    WINAPI DeviceGetCommon(ST_STDCOM *pstPrivate, ST_COMMON *pstCommon);
int    WINAPI DeviceSetCommon(ST_STDCOM *pstPrivate, ST_COMMON *pstCommon);
int    WINAPI DeviceSpecial(ST_STDCOM *pstPrivate,
                    const TCHAR *pszInstructions,
                    TCHAR *pszResult,
                    int   nBufrSize);
int    WINAPI DeviceLoadHdl(ST_STDCOM *pstPrivate, SF_HANDLE sfHdl);
int    WINAPI DeviceSaveHdl(ST_STDCOM *pstPrivate, SF_HANDLE sfHdl);
int    WINAPI PortConfigure(ST_STDCOM *pstPrivate);
int    WINAPI PortActivate(ST_STDCOM *pstPrivate,
                    TCHAR *pszPortName,
                    DWORD_PTR dwMediaHdl);
int    WINAPI PortDeactivate(ST_STDCOM *pstPrivate);
int    WINAPI PortConnected(ST_STDCOM *pstPrivate);
int           PortExtractSettings(ST_STDCOM *pstPrivate);

int    WINAPI RcvRefill(ST_STDCOM *pstPrivate);
int    WINAPI RcvClear(ST_STDCOM *pstPrivate);

int    WINAPI SndBufrSend(ST_STDCOM *pstPrivate, void *pvBufr,
                      int nSize);
int    WINAPI SndBufrIsBusy(ST_STDCOM *pstPrivate);
int    WINAPI SndBufrQuery(ST_STDCOM *pstPrivate, unsigned *pafStatus,
                      long *plHandshakeDelay);
int    WINAPI SndBufrClear(ST_STDCOM *pstPrivate);
DWORD  WINAPI ComstdThread(void *pvData);
void          AutoDetectAnalyze(ST_STDCOM *pstPrivate, int nBytes, char *pchBufr);
void          AutoDetectOutput(ST_STDCOM *pstPrivate, void *pvBufr, int nSize);
void          AutoDetectStart(ST_STDCOM *pstPrivate);
void          AutoDetectStop(ST_STDCOM *pstPrivate);
void          ComstdSettingsToDCB(ST_STDCOM_SETTINGS *pstSettings, DCB *pstDcb);
void          ComstdDCBToSettings(DCB *pstDcb, ST_STDCOM_SETTINGS *pstSettings);

// Temporary til TAPI lets us change media handle settings correctly
int           ComstdGetAutoDetectResults(void *pvData, BYTE *bByteSize,
                BYTE *bParity, BYTE *bStopBits);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\comwsock\comwsock.hh ===
/* comwsock.hh -- Private header file for winsock communications driver module
 *
 *  Copyright 1996 by Hilgraeve Inc. -- Monroe, MI
 *  All rights reserved
 *
 *  $Revision: 3 $
 *  $Date: 9/20/00 4:54p $
 */

// -=-=-=-=-=-=-=-=-=-=-=- EXPORTED PROTOTYPES -=-=-=-=-=-=-=-=-=-=-=-=-=-=-

int    WINAPI WsckDeviceInitialize(HCOM hCom, unsigned usInterfaceVersion,
                    void **ppvDriverData);
int    WINAPI WsckDeviceClose(void *pstPrivate);
int    WINAPI WsckDeviceDialog(void *pstPrivate, HWND hwndParent);
int    WINAPI WsckDeviceSpecial(void *pstPrivate,
                    const TCHAR *pszInstructions,
                    TCHAR *pszResult,
                    int   nBufrSize);
int    WINAPI WsckDeviceLoadHdl(void *pstPrivate, SF_HANDLE sfHdl);
int    WINAPI WsckDeviceSaveHdl(void *pstPrivate, SF_HANDLE sfHdl);
int    WINAPI WsckDeviceStub(void *pstPrivate);
int    WINAPI WsckPortActivate(void *pstPrivate,
                    TCHAR *pszPortName,
                    DWORD_PTR dwMediaHdl);
int    WINAPI WsckPortDeactivate(void *pstPrivate);
int    WINAPI WsckPortConnected(void *pstPrivate);


int    WINAPI WsckRcvRefill(void *pstPrivate);
int    WINAPI WsckRcvClear(void *pstPrivate);

int    WINAPI WsckSndBufrSend(void *pstPrivate, void *pvBufr,
                      int nSize);
int    WINAPI WsckSndBufrIsBusy(void *pstPrivate);
int    WINAPI WsckSndBufrQuery(void *pstPrivate, unsigned *pafStatus,
                      long *plHandshakeDelay);
int    WINAPI WsckSndBufrClear(void *pstPrivate);
int    WINAPI WsckPortConfigure(void *pstPrivate);
DWORD  WINAPI WsckComConnectThread(void *pvData);
DWORD  WINAPI WsckComReadThread(void *pvData);
DWORD  WINAPI WsckComWriteThread(void *pvData);


#if defined(INCL_WINSOCK)
/*
 * This block of defines is used by the Telnet / NVT code,
 * and is taken from RFC1143
 */
#define NO              1
#define YES             2
#define WANTNO          3
#define WANTYES         4

#define EMPTY           1
#define OPPOSITE        2
#define NONE            3

#define NVT_THRU        0
#define NVT_IAC         1
#define NVT_WILL        2
#define NVT_WONT        3
#define NVT_DO          4
#define NVT_DONT        5

#define NVT_SB          6
#define NVT_SB_TT       7
#define NVT_SB_TT_S     8
#define NVT_SB_TT_S_I   9

#define ECHO_MODE   0
#define SGA_MODE    1
#define TTYPE_MODE  2
#define BINARY_MODE 3
#define NAWS_MODE   4
// If any new modes are added, be sure to update MODE_MAX in comstd.

#define NVT_DISCARD 1
#define NVT_KEEP    2

/*
 * Definitions for the TELNET protocol.
 */
#define IAC     255     /* interpret as command: */
#define DONT    254     /* you are not to use option */
#define DO      253     /* please, you use option */
#define WONT    252     /* I won't use option */
#define WILL    251     /* I will use option */
#define SB      250     /* interpret as subnegotiation */
#define GA      249     /* you may reverse the line */
#define EL      248     /* erase the current line */
#define EC      247     /* erase the current character */
#define AYT     246     /* are you there */
#define AO      245     /* abort output--but let prog finish */
#define IP      244     /* interrupt process--permanently */
#define BREAK   243     /* break */
#define DM      242     /* data mark--for connect. cleaning */
#define NOP     241     /* nop */
#define SE      240     /* end sub negotiation */
#define EOR     239     /* end of record (transparent mode) */

#define SYNCH   242     /* for telfunc calls */

/* telnet options */
#define TELOPT_BINARY   0   /* 8-bit data path */
#define TELOPT_ECHO     1   /* echo */
#define TELOPT_RCP      2   /* prepare to reconnect */
#define TELOPT_SGA      3   /* suppress go ahead */
#define TELOPT_NAMS     4   /* approximate message size */
#define TELOPT_STATUS   5   /* give status */
#define TELOPT_TM       6   /* timing mark */
#define TELOPT_RCTE     7   /* remote controlled transmission and echo */
#define TELOPT_NAOL     8   /* negotiate about output line width */
#define TELOPT_NAOP     9   /* negotiate about output page size */
#define TELOPT_NAOCRD   10  /* negotiate about CR disposition */
#define TELOPT_NAOHTS   11  /* negotiate about horizontal tabstops */
#define TELOPT_NAOHTD   12  /* negotiate about horizontal tab disposition */
#define TELOPT_NAOFFD   13  /* negotiate about formfeed disposition */
#define TELOPT_NAOVTS   14  /* negotiate about vertical tab stops */
#define TELOPT_NAOVTD   15  /* negotiate about vertical tab disposition */
#define TELOPT_NAOLFD   16  /* negotiate about output LF disposition */
#define TELOPT_XASCII   17  /* extended ascic character set */
#define TELOPT_LOGOUT   18  /* force logout */
#define TELOPT_BM       19  /* byte macro */
#define TELOPT_DET      20  /* data entry terminal */
#define TELOPT_SUPDUP   21  /* supdup protocol */
#define TELOPT_SUPDUPOUTPUT 22  /* supdup output */
#define TELOPT_SNDLOC   23  /* send location */
#define TELOPT_TTYPE    24  /* terminal type */
#define TELOPT_EOR      25  /* end or record */
#define TELOPT_TACACS   26  /* TACACS user identification */
#define TELOPT_OUTMARK  27  /* output marking */
#define TELOPT_TERMLOC  28  /* terminal location number */
#define TELOPT_X3_PAD   30
#define TELOPT_NAWS     31  /* negotiate about terminal size */
#define TELOPT_SPEED    32  /* negotiate terminal speed */
#define TELOPT_TOGGLEFLOW 33    /* toggle flow control */
#define TELOPT_XDISPLOC 35  /* X display location */
#define TELOPT_EXOPL    255 /* extended-options-list */

/* sub-option qualifiers */
#define TELQUAL_IS      0   /* option is... */
#define TELQUAL_SEND    1   /* send option */
#define TELQUAL_OFF     0   /* turn off option */
#define TELQUAL_ON      1   /* turn on option */

#define MAX_IP_ADDR_LEN		128


/* --- These implement the Telnet NVT(network virtual terminal) --- */

VOID WinSockCreateNVT(ST_STDCOM * pstWS);
VOID WinSockReleaseNVT(ST_STDCOM * pstWS);
int FAR PASCAL WinSockNetworkVirtualTerminal(ECHAR mc, void *pD);

VOID WinSockSendMessage(ST_STDCOM * pstWS, INT nMsg, INT nChar);
VOID WinSockSendBuffer(ST_STDCOM * pstWS, INT nSize, LPSTR pszBuffer);

VOID WinSockGotDO  (ST_STDCOM * pstWS, const PSTOPT pstO);
VOID WinSockGotWILL(ST_STDCOM * pstWS, const PSTOPT pstO);
VOID WinSockGotDONT(ST_STDCOM * pstWS, const PSTOPT pstO);
VOID WinSockGotWONT(ST_STDCOM * pstWS, const PSTOPT pstO);

VOID WinSockSendNAWS( ST_STDCOM * hhDriver );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\ansiinit.c ===
/*	File: D:\WACKER\emu\ansiinit.c (Created: 08-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:28p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\cloop.h>
#include <tdll\mc.h>
#include <tdll\assert.h>
#include <tdll\backscrl.h>

#include "emu.h"
#include "emu.hh"
#include "emuid.h"
#include "ansi.hh"
#include "keytbls.h"


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuAnsiInit
 *
 * DESCRIPTION:
 *	 Sets up and installs the ANSI state table. Defines the ANSI
 *	 keyboard. Either resets the emulator completely or redefines emulator
 *	 conditions as they were when last saved.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *	 nothing
 */
void emuAnsiInit(const HHEMU hhEmu)
	{
	PSTANSIPRIVATE pstPRI;

	static struct trans_entry const ansi_tbl[] =
		{
		{NEW_STATE, 0, 0, 0}, // State 0
#if !defined(FAR_EAST)
		{0, ETEXT('\x20'),	ETEXT('\xFF'),	emuStdGraphic}, 	// Space - All
#else
		{0, ETEXT('\x20'),	0xFFFF,			emuStdGraphic}, 	// Space - All
#endif
		{1, ETEXT('\x1B'),	ETEXT('\x1B'),	nothing},			// Esc
		{0, ETEXT('\x05'),	ETEXT('\x05'),	vt100_answerback},	// Ctrl-E
		{0, ETEXT('\x07'),	ETEXT('\x07'),	emu_bell},			// Ctrl-G
		{0, ETEXT('\x08'),	ETEXT('\x08'),	backspace}, 		// Backspace
		{0, ETEXT('\x09'),	ETEXT('\x09'),	tabn},				// Tab
		{0, ETEXT('\x0A'),	ETEXT('\x0B'),	emuLineFeed},		// NL - VT
		{0, ETEXT('\x0C'),	ETEXT('\x0C'),	AnsiFormFeed},		// Form Feed
		{0, ETEXT('\x0D'),	ETEXT('\x0D'),	carriagereturn},	// CR
		{3, ETEXT('\x18'),	ETEXT('\x18'),	EmuStdChkZmdm}, 	// Ctrl-X
		{0, ETEXT('\x00'),	ETEXT('\x1F'),	emuStdGraphic}, 	// All Ctrl's

		{NEW_STATE, 0, 0, 0}, // State 1						// Esc
		{2, ETEXT('\x5B'),	ETEXT('\x5B'),	ANSI_Pn_Clr},		// [
		{0, ETEXT('\x44'),	ETEXT('\x44'),	ANSI_IND},			// D
		{0, ETEXT('\x45'),	ETEXT('\x45'),	ANSI_NEL},			// E
		{0, ETEXT('\x48'),	ETEXT('\x48'),	ANSI_HTS},			// H
		{0, ETEXT('\x4D'),	ETEXT('\x4D'),	ANSI_RI},			// M

		{NEW_STATE, 0, 0, 0}, // State 2						// Esc[
		{2, ETEXT('\x30'),	ETEXT('\x39'),	ANSI_Pn},			// 0 - 9
		{2, ETEXT('\x3B'),	ETEXT('\x3B'),	ANSI_Pn_End},		// ;
		{5, ETEXT('\x3D'),	ETEXT('\x3D'),	nothing},			// =
		{2, ETEXT('\x3A'),	ETEXT('\x3F'),	ANSI_Pn},			// : - ?
		{0, ETEXT('\x41'),	ETEXT('\x41'),	ANSI_CUU},			// A
		{0, ETEXT('\x42'),	ETEXT('\x42'),	ANSI_CUD},			// B
		{0, ETEXT('\x43'),	ETEXT('\x43'),	ANSI_CUF},			// C
		{0, ETEXT('\x44'),	ETEXT('\x44'),	ANSI_CUB},			// D
		{0, ETEXT('\x48'),	ETEXT('\x48'),	ANSI_CUP},			// H
		{0, ETEXT('\x4A'),	ETEXT('\x4A'),	ANSI_ED},			// J
		{0, ETEXT('\x4B'),	ETEXT('\x4B'),	ANSI_EL},			// K
		{0, ETEXT('\x4C'),	ETEXT('\x4C'),	ANSI_IL},			// L
		{0, ETEXT('\x4D'),	ETEXT('\x4D'),	ANSI_DL},			// M
		{0, ETEXT('\x50'),	ETEXT('\x50'),	ANSI_DCH},			// P
		{0, ETEXT('\x66'),	ETEXT('\x66'),	ANSI_CUP},			// f
		{0, ETEXT('\x67'),	ETEXT('\x67'),	ANSI_TBC},			// g
		{0, ETEXT('\x68'),	ETEXT('\x68'),	ansi_setmode},		// h
		{0, ETEXT('\x69'),	ETEXT('\x69'),	vt100PrintCommands},// i
		{0, ETEXT('\x6C'),	ETEXT('\x6C'),	ansi_resetmode},	// l
		{0, ETEXT('\x6D'),	ETEXT('\x6D'),	ANSI_SGR},			// m
		{0, ETEXT('\x6E'),	ETEXT('\x6E'),	ANSI_DSR},			// n
		{0, ETEXT('\x70'),	ETEXT('\x70'),	nothing},			// p
		{0, ETEXT('\x72'),	ETEXT('\x72'),	vt_scrollrgn},		// r
		{0, ETEXT('\x73'),	ETEXT('\x73'),	ansi_savecursor},	// s
		{0, ETEXT('\x75'),	ETEXT('\x75'),	ansi_savecursor},	// u

		{NEW_STATE, 0, 0, 0}, // State 3						// Ctrl-X
		{3, ETEXT('\x00'),	ETEXT('\xFF'),	EmuStdChkZmdm}, 	// all codes

		{NEW_STATE, 0, 0, 0}, // State 4						// Ctrl-A
		{4, ETEXT('\x00'),	ETEXT('\xFF'),	nothing},			// all codes

		{NEW_STATE, 0, 0, 0}, // State 5						// Esc[=
		{5, ETEXT('\x32'),	ETEXT('\x32'),	ANSI_Pn},			// 2
		{5, ETEXT('\x35'),	ETEXT('\x35'),	ANSI_Pn},			// 5
		{0, ETEXT('\x68'),	ETEXT('\x68'),	DoorwayMode},		// h
		{0, ETEXT('\x6C'),	ETEXT('\x6C'),	DoorwayMode},		// l
		};

	emuInstallStateTable(hhEmu, ansi_tbl, DIM(ansi_tbl));

	// Allocate space for and initialize data that is used only by the
	// ANSI emulator.
	//
	hhEmu->pvPrivate = malloc(sizeof(ANSIPRIVATE));

	if (hhEmu->pvPrivate == 0)
		{
		assert(FALSE);
		return;
		}

	pstPRI = (PSTANSIPRIVATE)hhEmu->pvPrivate;

	memset(pstPRI, 0, sizeof(ANSIPRIVATE));

	// Initialize standard handle items.
	//
	hhEmu->emuResetTerminal = emuAnsiReset;

	emuKeyTableLoad(hhEmu, AnsiKeyTable, 
					 sizeof(AnsiKeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl);
	emuKeyTableLoad(hhEmu, IBMPCKeyTable, 
					 sizeof(IBMPCKeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl2);

	hhEmu->emu_kbdin = ansi_kbdin;
	hhEmu->emu_deinstall = emuAnsiUnload;
	emuAnsiReset(hhEmu, FALSE);

#if !defined(FAR_EAST)
	hhEmu->emu_highchar = (TCHAR)0xFF;
#else
	hhEmu->emu_highchar = (TCHAR)0xFFFF;
#endif

	backscrlSetShowFlag(sessQueryBackscrlHdl(hhEmu->hSession), TRUE);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuAnsiReset
 *
 * DESCRIPTION:
 *	 Resets the ANSI emulator.
 *
 * ARGUMENTS:
 *	fHostRequest	-	TRUE if result of codes from host
 *
 * RETURNS:
 *	 nothing
 */
int emuAnsiReset(const HHEMU hhEmu, const int fHostRequest)
	{
	hhEmu->mode_KAM = hhEmu->mode_IRM = hhEmu->mode_VEM =
	hhEmu->mode_HEM = hhEmu->mode_LNM = hhEmu->mode_DECCKM =
	hhEmu->mode_DECOM  = hhEmu->mode_DECCOLM  = hhEmu->mode_DECPFF =
	hhEmu->mode_DECPEX = hhEmu->mode_DECSCNM =
	hhEmu->mode_25enab = hhEmu->mode_protect =
	hhEmu->mode_block = hhEmu->mode_local = RESET;

	hhEmu->mode_SRM = hhEmu->mode_DECTCEM = SET;

	hhEmu->mode_AWM = hhEmu->stUserSettings.fWrapLines;

	if (fHostRequest)
		{
		ANSI_Pn_Clr(hhEmu);
		ANSI_SGR(hhEmu);
		ANSI_RIS(hhEmu);
		}

	return 0;
	}

/* end of ansiinit.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\ansi.c ===
/*	File: D:\WACKER\emu\ansi.c (Created: 08-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 12/20/00 5:28p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\chars.h>
#include <tdll\session.h>
#include <tdll\mc.h>
#include <tdll\assert.h>

#include "emu.h"
#include "emu.hh"
#include "ansi.hh"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ansi_setmode
 *
 * DESCRIPTION:
 *	 Sets a mode for ANSI emulator
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ansi_setmode(const HHEMU hhEmu)
	{
	int mode_id, i;

	for (i = 0; i <= hhEmu->selector_cnt; i++)
		{
		mode_id = hhEmu->selector[i];
		switch (mode_id)
			{
		case 0x02:
			break;
		case 0x04:
			break;
		case 0x07:
			break;
		case 0x10:
			break;
		case 0x12:
			break;
		case 0x18:
			break;
		case 0x19:
			break;
		case 0x20:
			break;
		case 0xF1:
			break;
		case 0xF2:
			break;
		case 0xF3:
			break;
		case 0xF4:
			break;
		case 0xF5:
			break;
		case 0xF6:
		case 0xD7:
		case 0xF7:
			hhEmu->mode_AWM = SET;
			break;
		case 0xF8:
			/* select auto repeat mode */
			break;
		case 0xF18:
			break;
		case 0xF19:
			break;
		default:
			commanderror(hhEmu);
			break;
			}
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ansi_resetmode
 *
 * DESCRIPTION:
 *	 Resets a mode for the ANSI emulator.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ansi_resetmode(const HHEMU hhEmu)
	{
	int mode_id, i;

	for (i = 0; i <= hhEmu->selector_cnt; i++)
		{
		mode_id = hhEmu->selector[i];
		switch (mode_id)
			{
		case 0x02:
			break;
		case 0x04:
			break;
		case 0x07:
			break;
		case 0x10:
			break;
		case 0x12:
			break;
		case 0x18:
			break;
		case 0x19:
			break;
		case 0x20:
			break;
		case 0xF1:
			break;
		case 0xF2:
			break;
		case 0xF3:
			break;
		case 0xF4:
			break;
		case 0xF5:
			break;
		case 0xF6:
		case 0xD7:
		case 0xF7:
			hhEmu->mode_AWM = RESET; break;
		case 0xF8:
			/* select auto repeat mode */
			break;
		case 0xF18:
			break;
		case 0xF19:
			break;
		default:
			commanderror(hhEmu); break;
			}
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ansi_savecursor
 *
 * DESCRIPTION:
 *	 Saves the current cursor postion
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ansi_savecursor(const HHEMU hhEmu)
	{
	const PSTANSIPRIVATE pstPRI = (PSTANSIPRIVATE)hhEmu->pvPrivate;

	// Save or restor the cursor position.
	//
	if (hhEmu->emu_code == ETEXT('s'))
		(*hhEmu->emu_getcurpos)
			(hhEmu, &pstPRI->iSavedRow, &pstPRI->iSavedColumn);
	else		
		(*hhEmu->emu_setcurpos)
			(hhEmu, pstPRI->iSavedRow, pstPRI->iSavedColumn);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ansi_kbdin
 *
 * DESCRIPTION:
 *	 Processes local keyboard keys for the ANSI emulator.
 *
 * ARGUMENTS:
 *	 key -- key to process
 *
 * RETURNS:
 *	 nothing
 */
int ansi_kbdin(const HHEMU hhEmu, int key, const int fTest)
	{
	int index;

	/* -------------- Check Backspace & Delete keys ------------- */

	if (hhEmu->stUserSettings.fReverseDelBk && ((key == VK_BACKSPACE) ||
			(key == DELETE_KEY) || (key == DELETE_KEY_EXT)))
		{
		key = (key == VK_BACKSPACE) ? DELETE_KEY : VK_BACKSPACE;
		}

	if (hhEmu->stUserSettings.nTermKeys == EMU_KEYS_SCAN)
		{
		if ((index = emuKbdKeyLookup(hhEmu, key, &hhEmu->stEmuKeyTbl2)) != -1)
			{
			if (!fTest)
				emuSendKeyString(hhEmu, index, &hhEmu->stEmuKeyTbl2);
			}

		else
			{
			index = std_kbdin(hhEmu, key, fTest);
			}
		}

	else if ((index = emuKbdKeyLookup(hhEmu, key, &hhEmu->stEmuKeyTbl)) != -1)
		{
		if (!fTest)
			emuSendKeyString(hhEmu, index, &hhEmu->stEmuKeyTbl);
		}

	else
		{
		index = std_kbdin(hhEmu, key, fTest);
		}

	return index;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	DoorwayMode
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void DoorwayMode(const HHEMU hhEmu)
	{
	static INT iOldUseTermKeys;
	ECHAR ccode = hhEmu->emu_code;

	if (hhEmu->num_param[hhEmu->num_param_cnt] != 255)
		return;

	if (ccode == ETEXT('h'))
		{
		iOldUseTermKeys = hhEmu->stUserSettings.nTermKeys;
		hhEmu->stUserSettings.nTermKeys = EMU_KEYS_SCAN;
		}

	else if (ccode == ETEXT('l'))
		{
		hhEmu->stUserSettings.nTermKeys = iOldUseTermKeys;
		}

	NotifyClient(hhEmu->hSession, EVENT_EMU_SETTINGS, 0);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuAnsiUnload
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void emuAnsiUnload(const HHEMU hhEmu)
	{
	assert(hhEmu);

	if (hhEmu->pvPrivate)
		{
		free(hhEmu->pvPrivate);
		hhEmu->pvPrivate = NULL;
		}

	emuKeyTableFree(&hhEmu->stEmuKeyTbl);
	emuKeyTableFree(&hhEmu->stEmuKeyTbl2);

	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\comwsock\comnvt.c ===
/*  File: D:\WACKER\comwsock\comnvt.c (Created: 14-Feb-1996)
 *
 *  Copyright 1996 by Hilgraeve Inc. -- Monroe, MI
 *  All rights reserved
 *
 *	$Revision: 4 $
 *	$Date: 3/16/01 4:48p $
 */


//#define DEBUGSTR

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>

#if defined (INCL_WINSOCK)

#include <tdll\session.h>
#include <tdll\com.h>
#include <tdll\comdev.h>
#include <comstd\comstd.hh>
#include "comwsock.hh"
#include <tdll\assert.h>
#include <tdll\htchar.h>
#include <emu\emu.h>

static PSTOPT LookupOption( ST_STDCOM *hhDriver, ECHAR mc );


	// This is the "Network Virtual Terminal" emulation, i.e., the code
	// that handles Telnet option negotiations.  WinSockNetworkVirtualTerminal
	// is called to check incoming data to see if there is
	// a Telnet command in there.
	
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  WinSockCreateNVT
 *
 * DESCRIPTION:
 *  This function is called to create the necessary hooks and stuff to create
 *  a Telnet NVT(network virtual terminal).
 *
 * PARAMETERS:
 *  hhDriver    -- private connection handle
 *
 * RETURNS:
 *  Nothing.
 *
 * AUTHOR
 *  mcc 01/09/96 (Ported from NPORT)
 */
VOID WinSockCreateNVT(ST_STDCOM * hhDriver)
	{
	int ix;
    DbgOutStr("WinSockCreateNVT\r\n", 0,0,0,0,0);

	hhDriver->NVTstate = NVT_THRU;

	hhDriver->stMode[ECHO_MODE].option   = TELOPT_ECHO;
    hhDriver->stMode[SGA_MODE].option    = TELOPT_SGA;
    hhDriver->stMode[TTYPE_MODE].option  = TELOPT_TTYPE;
    hhDriver->stMode[BINARY_MODE].option = TELOPT_BINARY;
    hhDriver->stMode[NAWS_MODE].option   = TELOPT_NAWS;

	for (ix = 0; ix < MODE_MAX; ++ix)	//jkh 6/18/98
		{
		hhDriver->stMode[ix].us  = hhDriver->stMode[ix].him  = NO;
		hhDriver->stMode[ix].usq = hhDriver->stMode[ix].himq = EMPTY;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  WinSockReleaseNVT
 *
 * DESCRIPTION:
 *  This function is currently a stub
 *
 * PARAMETERS:
 *  hhDriver    -- private connection handle
 *
 * RETURNS:
 *  Nothing.
 */
VOID WinSockReleaseNVT(ST_STDCOM * hhDriver)
	{

	DbgOutStr("WS releaseNVT\r\n", 0,0,0,0,0);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  WinSockGotDO
 *
 * DESCRIPTION:
 *  Handles the case of us agreeing that the other side should enable an option
 *
 * PARAMETERS:
 *  hhDriver    --  private handle for this connection driver
 *  pstO        --  Telnet options data structure
 *
 * RETURNS:
 *  nothing
 *
 * AUTHOR:
 *  mcc 01/09/96 (Ported from NPORT)
 */
VOID WinSockGotDO  (ST_STDCOM * hhDriver, const PSTOPT pstO)
	{

	DbgOutStr("Got DO: %lx\r\n", pstO->option, 0,0,0,0);
	switch (pstO->us)
		{
	case NO:
		// We were off, but server want's us on so we agree and respond
		pstO->us = YES;
		WinSockSendMessage(hhDriver, WILL, pstO->option);
		break;

	case YES:
		// Ignore, we're already enabled
		break;

	case WANTNO:
		// This is an error,we had sent a WON'T and they responded with DO
		if (pstO->usq == EMPTY)
			pstO->us = NO;	// leave option as WE wanted it
		else if (pstO->usq == OPPOSITE) // we were going to enable anyway so turn us on
			pstO->us = YES;
		pstO->usq = EMPTY;
		break;

	case WANTYES:
		// They're agreeing with our earlier WILL
		if (pstO->usq == EMPTY)
			{
			pstO->us = YES;	// all done negotiating
			}
		else if (pstO->usq == OPPOSITE)
			{
			// we changed our mind while negotiating, renegotiate for WONT
			pstO->us = WANTNO;
			pstO->usq = EMPTY;
			WinSockSendMessage(hhDriver, WONT, pstO->option);
			}
		break;

	default:
		assert(FALSE);
		break;
		}

	// If the NAWS option was just turned on, we must respond with our terminal size
	// right away. (The WinsockSendNAWS function will check whether the option is now
	// on or off).
	if ( pstO->option == TELOPT_NAWS )
		WinSockSendNAWS( hhDriver );
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
* FUNCTION:
*   WinSockGotWILL
*
* DESCRIPTION:
*   Handles the case of getting a WILL response from the remote Telnet,
*   indicating that an option will be enabled
*
* PARAMETERS:
*  hhDriver --  private handle for this connection driver
*  pstO     --  Telnet options data structure
*
* RETURNS:
*  nothing
*
* AUTHOR:
*  mcc 01/09/96 (Ported from NPORT)
*/
VOID WinSockGotWILL(ST_STDCOM * hhDriver, const PSTOPT pstO)
	{
	DbgOutStr("Got WILL: %lx\r\n", pstO->option, 0,0,0,0);
	switch(pstO->him)
		{
	case NO:
		// He was off but want's to be on so agree and respond
		pstO->him = YES;
		WinSockSendMessage(hhDriver, DO, pstO->option);
		break;

	case YES:
		// He was already on so do nothing
		break;

	case WANTNO:
		// Error: he responded to our DONT with a WILL
		if (pstO->himq == EMPTY)
			pstO->him = NO;
		else if (pstO->himq == OPPOSITE)
			pstO->him = YES;
		pstO->himq = EMPTY;
		break;

	case WANTYES:
		// He responded to our DO with a WILL (life is good!)
		if (pstO->himq == EMPTY)
			{
			pstO->him = YES;
			}
		else if (pstO->himq == OPPOSITE)
			{
			// He agreed to our DO, but we changed our mind -- renegotiate
			pstO->him = WANTNO;
			pstO->himq = EMPTY;
			WinSockSendMessage(hhDriver, DONT, pstO->option);
			}
		break;

	default:
		assert(FALSE);
		break;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  WinSockGotDONT
 *
 * DESCRIPTION:
 *  Handles the case of getting a DONT option from the remote Telnet,
 *  indicating a request not to implement a particular option
 *
 * PARAMETERS:
 *  hhDriver    Private driver handle
 *  pstO
 *
 * RETURNS:
 *  nothing
 */
VOID WinSockGotDONT(ST_STDCOM * hhDriver, const PSTOPT pstO)
	{
	DbgOutStr("Got DONT: %lx\r\n", pstO->option, 0,0,0,0);
	switch (pstO->us)
		{
	case NO:
		// Got a DONT while we were already off, just ignore
		break;

	case YES:
		// Got a DONT while we were on, agree and respond
		pstO->us = NO;
		WinSockSendMessage(hhDriver, WONT, pstO->option);
		break;

	case WANTNO:
		// He responded to our WONT with a DONT (how appropriate)
		if (pstO->usq == EMPTY)
			{
			pstO->us = NO;
			}
		else if (pstO->usq == OPPOSITE)
			{
			// He agreed to our earlier WONT but we changed our mind
			pstO->us = WANTYES;
			pstO->usq = EMPTY;
			WinSockSendMessage(hhDriver, WILL, pstO->option);
			}
		break;

	case WANTYES:
		// He responded to our WILL with a DONT, so leave it off
		if (pstO->usq == EMPTY)
			{
			pstO->us = NO;
			}
		else if (pstO->usq == OPPOSITE)
			{
			// If he'd agreed to our WILL, we'd have immediately asked for WONT
			// but since he didn't agree, we already got what we wanted
			pstO->us = NO;
			pstO->usq = EMPTY;
			}
		break;

	default:
		assert(FALSE);
		break;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 */
VOID WinSockGotWONT(ST_STDCOM * hhDriver, const PSTOPT pstO)
	{
	DbgOutStr("Got WONT: %lx\r\n", pstO->option, 0,0,0,0);
	switch (pstO->him)
		{
	case NO:
		// Got a WONT while he was already off, just ignore
		break;

	case YES:
		// He wants to change from on to off, agree and respond
		pstO->him = NO;
		WinSockSendMessage(hhDriver, DONT, pstO->option);
		break;

	case WANTNO:
		// He responded to our DONT with a WONT (how agreeable of him)
		if (pstO->himq == EMPTY)
			{
			pstO->him = NO;
			}
		else if (pstO->himq == OPPOSITE)
			{
			// He agreed to our DONT but we changed our mind while waiting
			pstO->him = WANTYES;
			pstO->himq = EMPTY;
			WinSockSendMessage(hhDriver, DO, pstO->option);
			}
		break;

	case WANTYES:
		// He responded to our DO with a WONT -- let the wimp have his way
		if (pstO->himq == EMPTY)
			{
			pstO->him = NO;
			}
		else if (pstO->himq == OPPOSITE)
			{
			// If he'd agreed to our DO, we'd have asked for a DONT so
			// now we're happy anyway
			pstO->him = NO;
			pstO->himq = EMPTY;
			}
		break;

	default:
		assert(FALSE);
		break;
		}
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  WinSockNetworkVirtualTerminal
 *
 * DESCRIPTION:
 *  called from CLoop to handle Telnet option negotiation
 *
 * PARAMETERS:
 *	mc		The current character being processed
 *	pD		Pointer to Winsock connection driver private handle
 *
 * RETURNS:
 *	NVT_DISCARD		if mc is to be discarded
 *	NVT_KEEP			if mc is to be processed further
 *
 * AUTHOR
 *	mcc  01/09/96 (mostly from NPORT)
 */
int FAR PASCAL WinSockNetworkVirtualTerminal(ECHAR mc, void *pD)
	{
	ST_STDCOM * hhDriver = (ST_STDCOM *)pD;
#ifdef INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID
    STEMUSET stEmuSet;
#else
	int nTtype;
#endif
	LPSTR pszPtr;
	UCHAR acTerm[64];
	HEMU  hEmu;
	HSESSION hSession;
	PSTOPT pstTelnetOpt;

	assert(hhDriver);
	
	//DbgOutStr("NVT %d %c(0x%x = %d)\n", hhDriver->NVTstate,
		// ((mc == 0)? ' ': mc), mc, mc,0);

	switch (hhDriver->NVTstate)
		{
	case NVT_THRU:
		if (mc == IAC)
			{
			hhDriver->NVTstate = NVT_IAC;
			return NVT_DISCARD ;
			}
		return NVT_KEEP ;

	case NVT_IAC:
		switch (mc)
			{
		case IAC:
			hhDriver->NVTstate = NVT_THRU;       // Got a doubled IAC, keep one
			return  NVT_KEEP ;
		case DONT:
			hhDriver->NVTstate = NVT_DONT;
			return  NVT_DISCARD ;
		case DO:
			hhDriver->NVTstate = NVT_DO;
			return  NVT_DISCARD ;
		case WONT:
			hhDriver->NVTstate = NVT_WONT;
			return  NVT_DISCARD ;
		case WILL:
			hhDriver->NVTstate = NVT_WILL;
			return  NVT_DISCARD ;
		case SB:
			hhDriver->NVTstate = NVT_SB;
			return  NVT_DISCARD ;
		case GA:
		case EL:
		case EC:
		case AYT:
		case AO:
		case IP:
		case BREAK:
		case DM:
		case SE:
			//MessageBeep((UINT)-1);
			hhDriver->NVTstate = NVT_THRU;
			return  NVT_DISCARD ;	// ignore all these
		case NOP:
		default:
			hhDriver->NVTstate = NVT_THRU;
			return NVT_KEEP;
			}

	case NVT_WILL:
		pstTelnetOpt = LookupOption( hhDriver, mc );
		if ( pstTelnetOpt )
			WinSockGotWILL( hhDriver, pstTelnetOpt ); // We support the option, negotiate
		else
			WinSockSendMessage( hhDriver, DONT, mc ); // We don't support it, decline	

		hhDriver->NVTstate = NVT_THRU;
		return  NVT_DISCARD ;

	case NVT_WONT:
		pstTelnetOpt = LookupOption( hhDriver, mc );
		if ( pstTelnetOpt )
			WinSockGotWONT( hhDriver, pstTelnetOpt ); // We support the option, negotiate

		// Since we don't support this option, it is always off, and we never respond
		// when the other side tries to set a state that already exists

		hhDriver->NVTstate = NVT_THRU;
		return  NVT_DISCARD ;

	case NVT_DO:
		pstTelnetOpt = LookupOption( hhDriver, mc );
		if ( pstTelnetOpt )
			WinSockGotDO( hhDriver, pstTelnetOpt ); // We support the option, negotiate
		else
			WinSockSendMessage( hhDriver, WONT, mc ); // We don't support it, decline

		hhDriver->NVTstate = NVT_THRU;
		return  NVT_DISCARD ;

	case NVT_DONT:
		pstTelnetOpt = LookupOption( hhDriver, mc );
		if ( pstTelnetOpt )
			WinSockGotDONT( hhDriver, pstTelnetOpt ); // We support the option, negotiate

		// Since we don't support this option, it is always off, and we never respond
		// when the other side tries to set a state that already exists

		hhDriver->NVTstate = NVT_THRU;
		return  NVT_DISCARD ;

	case NVT_SB:
		/* At this time we only handle one sub-negotiation */
		switch (mc)
			{
		case TELOPT_TTYPE:
			hhDriver->NVTstate = NVT_SB_TT;
			return  NVT_DISCARD ;
		default:
			break;
			}
		hhDriver->NVTstate = NVT_THRU;
		return NVT_KEEP;

	case NVT_SB_TT:
		switch (mc)
			{
		case TELQUAL_SEND:
			hhDriver->NVTstate = NVT_SB_TT_S;
			return NVT_DISCARD ;
		default:
			break;
			}
		hhDriver->NVTstate = NVT_THRU;
		return NVT_KEEP;

	case NVT_SB_TT_S:
		switch (mc)
			{
		case IAC:
			hhDriver->NVTstate = NVT_SB_TT_S_I;
			return NVT_DISCARD ;
		default:
			break;
			}
		hhDriver->NVTstate = NVT_THRU;
		return NVT_KEEP;

	case NVT_SB_TT_S_I:
		switch (mc)
			{
		case SE:
			memset(acTerm, 0, sizeof(acTerm));
			pszPtr = (LPSTR)acTerm;
			*pszPtr++ = (UCHAR)IAC;
			*pszPtr++ = (UCHAR)SB;
			*pszPtr++ = (UCHAR)TELOPT_TTYPE;
			*pszPtr++ = (UCHAR)TELQUAL_IS;

			ComGetSession(hhDriver->hCom, &hSession);
			assert(hSession);

			hEmu = sessQueryEmuHdl(hSession);
			assert(hEmu);

#ifdef INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID
            // The telnet terminal ids are no longer hard-coded. We
            // are now using the terminal id that is supplied by the
            // user in the "Settings" properties page. - cab:11/18/96
            //
            emuQuerySettings(hEmu, &stEmuSet);
            strcpy(pszPtr, stEmuSet.acTelnetId);
#else
			nTtype = emuQueryEmulatorId(hEmu);
			switch (nTtype)
				{
			case EMU_ANSI:
				strcpy(pszPtr, "ANSI");
				break;
			case EMU_TTY:
				strcpy(pszPtr, "TELETYPE-33");
				break;
			case EMU_VT52:
				strcpy(pszPtr, "DEC-VT52");
				break;
			case EMU_VT100:
                // strcpy(pszPtr, "VT100");
                strcpy(pszPtr, "DEC-VT100");
				break;
#if defined(INCL_VT220)
			case EMU_VT220:
                // strcpy(pszPtr, "VT220");
                strcpy(pszPtr, "DEC-VT220");
				break;
#endif
#if defined(INCL_VT320)
			case EMU_VT220:
                // strcpy(pszPtr, "VT320");
                strcpy(pszPtr, "DEC-VT320");
				break;
#endif

#if defined(INCL_VT100PLUS)
			case EMU_VT100PLUS:
                // strcpy(pszPtr, "VT100");
                strcpy(pszPtr, "DEC-VT100");
				break;
#endif

#if defined(INCL_VTUTF8)
			case EMU_VTUTF8:
                strcpy(pszPtr, "VT-UTF8");
				break;
#endif

			default:
                strcpy(pszPtr, "DEC-VT100"); // "UNKNOWN");
				break;
				}
#endif

			DbgOutStr("NVT: Terminal=%s", pszPtr, 0,0,0,0);
			pszPtr = pszPtr + strlen(pszPtr);
			*pszPtr++ = (UCHAR)IAC;
			*pszPtr++ = (UCHAR)SE;

			WinSockSendBuffer(hhDriver,
				(INT)(pszPtr - (LPSTR)acTerm),
				(LPSTR)acTerm);
			hhDriver->NVTstate = NVT_THRU;
			return NVT_DISCARD ;
		default:
			break;
			}
		hhDriver->NVTstate = NVT_THRU;
		return NVT_KEEP;

	default:
		hhDriver->NVTstate = NVT_THRU;
		return NVT_KEEP;
		}

	}


//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// FUNCTION:    WinSockSendNAWS
//
// DESCRIPTION: Sends our terminal dimensions according to the Telnet NAWS option
//              specification. NAWS stands for Negotiate About Window Size. It is
//              defined in RFC 1073, "Telnet Window Size Option". If a telnet server
//              enables this capability by sending us an IAC DO NAWS sequence, we
//              will agree to it by responding with IAC WILL NAWS and then sending
//              the number of rows and columns in a sub-option negotiation sequence
//              as implemented here. We also send the sub-option sequence whenever
//              our terminal size changes.
//
// ARGUMENTS:   hhDriver -- pointer to our com driver
//
// RETURNS:     void
//
// AUTHOR:      John Hile, 6/17/98
//
VOID WinSockSendNAWS( ST_STDCOM *hhDriver )
	{
	HEMU	 hEmu;
	HSESSION hSession;
	int		 iRows;
	int		 iCols;
	UCHAR    achOutput[9];	// exact size

	// We've been asked to send our terminal size to the server. We're only
	// allowed to do so if we have successfully enabled the NAWS option with
	// the server.
	if ( hhDriver->stMode[NAWS_MODE].us == YES)
		{
		// OK, option has been turned on. Send
		//  "IAC SB NAWS WIDTH[1] WIDTH[0] HEIGHT[1] HEIGHT[0] IAC SE" to server

		// Get actual terminal size (not menu settings) from emulator
		ComGetSession(hhDriver->hCom, &hSession);
		assert(hSession);

		hEmu = sessQueryEmuHdl(hSession);
		assert(hEmu);
		emuQueryRowsCols( hEmu, &iRows, &iCols );
		achOutput[0] = (UCHAR)IAC;
		achOutput[1] = (UCHAR)SB;
		achOutput[2] = (UCHAR)TELOPT_NAWS;
		achOutput[3] = (UCHAR)(iCols / 0xFF);
		achOutput[4] = (UCHAR)(iCols % 0xFF);
		achOutput[5] = (UCHAR)(iRows / 0xFF);
		achOutput[6] = (UCHAR)(iRows % 0xFF);
		achOutput[7] = (UCHAR)IAC;
		achOutput[8] = (UCHAR)SE;

		WinSockSendBuffer(hhDriver, sizeof(achOutput), (LPSTR)achOutput);
		}
	}


//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// FUNCTION:    LookupTelnetOption
//
// DESCRIPTION: Searches our table of telnet option management structures to
//              see whether we support the option coded by character mc.
//
// ARGUMENTS:   hhDriver -- our comm driver handle
//              mc       -- the character that defines the option we're looking up
//
// RETURNS:     Pointer to the option management structure if found or NULL otherwise
//
// AUTHOR:      John Hile, 6/17/98
//
static PSTOPT LookupOption( ST_STDCOM *hhDriver, ECHAR mc )
	{
	int ix;

	for (ix = 0; ix < MODE_MAX; ix++)
	if (hhDriver->stMode[ix].option == mc)
		return &hhDriver->stMode[ix];

	return (PSTOPT)0;
	}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\ansi.hh ===
/*	File: D:\WACKER\emu\ansi.hh (Created: 21-July-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:28p $
 */

// Private emulator data for ANSI.
//
typedef struct stPrivateANSI
	{
	int iSavedRow,
		iSavedColumn;

	} ANSIPRIVATE;

typedef ANSIPRIVATE *PSTANSIPRIVATE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\csb.h ===
/*	File: D:\WACKER\emu\csb.h (Created: 27-Dec-1993)
 *
 *	Copyright 1989 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:27p $
 */


/* Display rows for receive screen */

#define CR_DR_RCV_FILE	1
#define CR_DR_VIR_SCAN	1
#define CR_DR_STORING	2
#define CR_DR_ERR_CHK	3
#define CR_DR_PACKET	4
#define CR_DR_RETRIES	4
#define CR_DR_TOTAL_RET 4
#define CR_DR_LAST_ERR	5
#define CR_DR_AMT_RCVD	5
#define CR_DR_BOTM_LINE 7

/* Display rows for send screen */
#define CS_DR_SND_FILE	1
#define CS_DR_ERR_CHK	2
#define CS_DR_PACKET	3
#define CS_DR_RETRIES	3
#define CS_DR_TOTAL_RET 3
#define CS_DR_LAST_ERR	4
#define CS_DR_AMT_RCVD	4
#define CS_DR_VUF		7
#define CS_DR_BOTM_LINE 10

extern USHORT csb_rcv(BOOL attended, BOOL single_file);
extern USHORT csb_snd(BOOL attended, unsigned nfiles, long nbytes);

/* for export to emulator */
extern VOID   CsbENQ(VOID);
extern VOID   CsbAdvanceSetup(VOID);
extern VOID   CsbInterrogate(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\comwsock\comwsock.c ===
/*  File: D:\WACKER\comwsock\comwsock.c (Created: 12/26/95)
 *
 *  Copyright 1996 by Hilgraeve Inc. -- Monroe, MI
 *  All rights reserved
 *
 *  $Revision: 9 $
 *  $Date: 3/22/01 11:26a $
 *
 *  $Log: /Products/wacker/Comwsock/Comwsock.c $
 * 
 * 9     3/22/01 11:26a Ronv
 * Removed previous revisions needed (include shfusion.h) for Windows XP
 * Themeing.
 * 
 * 8     2/27/01 5:45p Ronv
 * Revisions needed (include shfusion.h) for Windows XP Themeing.
 * 
 * 7     2/16/01 4:01p Ronv
 * Fix for not dereferencing a null pointer.
 * 
 * 6     12/21/00 11:15a Ronv
 * Corrected usage of sizeof().
 * 
 * 5     11/07/00 12:06p Ronv
 * Fix for setting character in a TCHAR array to correct NULL character.
 * 
 * Fix for setting character in a TCHAR array to correct NULL character.
 * 
 * Using StrCharCopyN() instead of StrCharCopy() to make sure there is not
 * a buffer overrun.
 * 
 * 
 * 4     9/20/00 4:54p Ronv
 * Fix for buffer overrun in with WINSOCK sessions when the URL was > 116
 * characters.  We will now truncate the URL to 127 characters to make
 * sure we don't overwrite the buffer allocated for the URL.
 * 
 * 3     11/16/99 9:56a Johnh
 * Fixed bug reported by IBM that isolated, unsupported NVT control
 * sequences (when sent alone) caused cursor movement.
 * 
 * 2     2/05/99 3:20p Supervisor
 * 64-bit changes and bug fixes for Microsoft
 *
 * 1     10/05/98 1:02p Supervisor
 * Revision 1.16  1998/09/11  11:41:41  JKH
 * none
 *
 * Revision 1.15  1998/09/10  14:54:58  bld
 * none
 *
 * Revision 1.14  1998/09/10  11:04:39  bld
 * none
 *
 * Revision 1.13  1998/09/09  16:15:37  rev
 * none
 *
 * Revision 1.12  1998/08/28  15:24:13  rev
 * none
 *
 * Revision 1.11  1998/08/28  10:31:23  bld
 * none
 *
 * Revision 1.10  1998/06/17  16:04:17  JKH
 * none
 *
 * Revision 1.9  1998/03/10  15:49:00  bld
 * none
 *
 * Revision 1.8  1997/03/24  09:53:07  JKH
 * Added Telnet break and command line telnet port selection
 *
 * Revision 1.7  1997/02/26  09:34:37  dmn
 * none
 *
 * Revision 1.6  1996/11/21  14:15:43  cab
 * Added call answering
 *
 * Revision 1.5  1996/02/22  14:24:07  jmh
 * Winsock com driver now uses same private data structure as standard com.
 *
 * Revision 1.4  1996/02/22  11:22:39  mcc
 * none
 *
 * Revision 1.3  1996/02/22  10:20:19  mcc
 * none
 *
 * Revision 1.2  1996/02/05  14:17:12  mcc
 * none
 *
 * Revision 1.1  1996/01/31  15:52:15  mcc
 * Winsock Comm driver
 *

 *Design Overview =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

    This module would do Dr. Frankenstein proud ... it's basic structure is
	taken from WACKER's COMSTD module, but the internal logic is taken from
	HAWIN.  (I tried to port NPORT's OS/2 code but there is apparently some
	flaw in Win95's support for threaded Winsock apps, anyway I could not
	get it to work). This code is preserved here (controlled by #ifdef
	MULTITHREAD), it would be interesting to see if it works under Windows NT.
	
	A few random bits from NPORT are stitched in too ...
	
	This driver gets its remote address and port number settings from the
	connection driver via DeviceSpecial calls.  It stores nothing in
	the session file, so those load/save calls are stubs.
	
	Tidbits of possibly useful information:
	
		Sometimes a send() appears to succeed but no data appears at the other
		end. It appears that sometimes Winsock is internally waiting forever
		for something to happen, and never actually sends the data.  This
		might be caused by a recv() call outstanding that asks for
		a large amount of data, and maybe the send() call can't get enough
		memory until it completes (but it never WILL complete because the
		other system is waiting for data).  Also, I've seen this happening
		with the MULTITHREAD code, possibly due to a Winsock bug
		under Win95.
		
		The EscFF business is because Telnet (a protocol on top of TCP/IP
		that we will often encounter) uses FF as a command character,
		and sends FF FF as a literal FF.  Thus, file transfers to
		a system running Telnet must escape FF characters in a file
		by doubling them.
		
		The STDCOM drivers work by activating the port then sending
		data out to dial the modem, thus there is no ComConnect
		call in the high-level Com API.  For better or worse, TCP/IP
		requires that the IP address and Port number be supplied
		by the CNCT driver (via ComDeviceSpecial calls) before
		ComActivatePort is called so that activating the port actually
		establishes the link to the other system. In this kinda kludgy
		non-threaded implementation, ComActivatePort cannot block, so
		it will return success if it can successfully send out a
		connection request.  If the request ultimately fails, this
		driver will call ComNotify to let the CNCT driver know that there
		is a connection status change, and it must pick up the pieces.
		
		

*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

//#define DEBUGSTR

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>

#if defined(INCL_WINSOCK)

#include <tdll\session.h>
#include <tdll\mc.h>
#include <tdll\sf.h>
#include <tdll\timers.h>
#include <tdll\com.h>
#include <tdll\comdev.h>
#include <comstd\comstd.hh>
#include "comwsock.hh"
#include <tdll\assert.h>
#include <tdll\statusbr.h>
#include <tdll\htchar.h>
#include <tdll\com.hh>

BOOL WINAPI _CRT_INIT(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);
int wsckResolveAddress(TCHAR *pszRemote, unsigned long *pulAddr);
LRESULT FAR PASCAL WndSockWndProc(HWND hWnd, UINT uiMsg, WPARAM uiPar1, LPARAM lPar2);
BOOL WinSockCreateEventWindow (ST_STDCOM *pstPrivate);
int FAR PASCAL sndQueueAppend(ST_STDCOM *pstPrivate,
						VOID FAR *pvBufr, int nBytesToAppend);
int WinSockConnectSpecial(ST_STDCOM *pstPrivate);
int WinSockAnswerSpecial(ST_STDCOM *pstPrivate);

LONG WinSockConnectEvent(ST_STDCOM* pstPrivate, LPARAM lPar);
LONG WinSockReadEvent(ST_STDCOM* pstPrivate, LPARAM lPar);
LONG WinSockWriteEvent(ST_STDCOM*pstPrivate, LPARAM lPar);
LONG WinSockResolveEvent(ST_STDCOM* pstPrivate, LPARAM lPar);
LONG WinSockCloseEvent(ST_STDCOM* pstPrivate, LPARAM lPar);
LONG WinSockAcceptEvent(ST_STDCOM*pstPrivate, LPARAM lPar);

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  ComLoadWinsockDriver
 *
 * DESCRIPTION:
 *  Loads the COM handle with pointers to the Winsock driver functions
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *  COM_OK		if successful
 *	COM_FAILED	otherwise
 *
 * AUTHOR:
 * mcc 12/26/95
 */
int ComLoadWinsockDriver(HCOM pstCom)
	{

	int	iRetVal = COM_OK;

	if ( !pstCom )
		return COM_FAILED;

	pstCom->pfPortActivate   = WsckPortActivate;
	pstCom->pfPortDeactivate = WsckPortDeactivate;
	pstCom->pfPortConnected  = WsckPortConnected;
	pstCom->pfRcvRefill 	 = WsckRcvRefill;
	pstCom->pfRcvClear		 = WsckRcvClear;
	pstCom->pfSndBufrSend	 = WsckSndBufrSend;
	pstCom->pfSndBufrIsBusy  = WsckSndBufrIsBusy;
	pstCom->pfSndBufrClear	 = WsckSndBufrClear;
	pstCom->pfSndBufrQuery	 = WsckSndBufrQuery;
	pstCom->pfDeviceSpecial	 = WsckDeviceSpecial;
	pstCom->pfPortConfigure	 = WsckPortConfigure;

	return iRetVal;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  WsckComWinsockEntry
 *
 * DESCRIPTION:
 *  Currently, just initializes the C-Runtime library but may be used
 *  for other things later.
 *
 * ARGUMENTS:
 *  hInstDll    - Instance of this DLL
 *  fdwReason   - Why this entry point is called
 *  lpReserved  - reserved
 *
 * RETURNS:
 *  BOOL
 *
 * AUTHOR:
 * mcc 12/26/95
 */
BOOL WINAPI WsckComWinsockEntry(HINSTANCE hInst, DWORD fdwReason, LPVOID lpReserved)
    {
    hinstDLL = hInst;
    return _CRT_INIT(hInst, fdwReason, lpReserved);
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckDeviceInitialize
 *
 * DESCRIPTION:
 *  Called whenever the driver is being loaded
 *
 * ARGUMENTS:
 *  hCom               -- A copy of the com handle. Can be used in the
 *                          driver code to call com services
 *  usInterfaceVersion -- A version number identifying the version of the
 *                          driver interface
 *  ppvDriverData      -- A place to put the pointer to our private data.
 *                          This value will be passed back to us in all
 *                          subsequent calls.
 *
 * RETURNS:
 *  COM_OK if all is hunky dory
 *  COM_DEVICE_VERSION_ERROR if Wacker expects a different interface version.
 *  COM_NOT_ENOUGH_MEMORY
 *  COM_DEVICE_ERROR if anything else goes wrong
 *
 * AUTHOR:
 * mcc 12/26/95
 */
int WINAPI WsckDeviceInitialize(HCOM hCom,
    unsigned nInterfaceVersion,
    void **ppvDriverData)
    {
    int        iRetVal = COM_OK;
    int        ix;
    ST_STDCOM *pstPrivate = NULL;

    //              Check version number and compatibility

    if (nInterfaceVersion != COM_VERSION)
        {
        // This error is reported by Com Routines. We cannot report errors
        // until after DeviceInitialize has completed.
        return COM_DEVICE_VERSION_ERROR;
        }

    if (*ppvDriverData)
        {
        pstPrivate = (ST_STDCOM*) *ppvDriverData;
        }
    else
        {
        // Allocate our private storage structure
        if ((pstPrivate = malloc(sizeof(*pstPrivate))) == NULL)
            return COM_NOT_ENOUGH_MEMORY;
        *ppvDriverData = pstPrivate;
	    pstPrivate->hCom = hCom;
        pstPrivate->fNotifyRcv = TRUE;
	    pstPrivate->dwEventMask = 0;
	    pstPrivate->fSending = FALSE;
        pstPrivate->lSndTimer = 0L;
        pstPrivate->lSndLimit = 0L;
        pstPrivate->lSndStuck = 0L;
        pstPrivate->hwndEvents = (HWND)0;
        pstPrivate->nRBufrSize = WSOCK_SIZE_INQ;
        pstPrivate->pbBufrStart = NULL;
        pstPrivate->fHaltThread = TRUE;

        InitializeCriticalSection(&pstPrivate->csect);
        for (ix = 0; ix < EVENT_COUNT; ++ix)
            {
            pstPrivate->ahEvent[ix] = CreateEvent((LPSECURITY_ATTRIBUTES)0,
                TRUE, FALSE, NULL);
            if (!pstPrivate->ahEvent[ix])
                {
                iRetVal = COM_FAILED;
                break;
                }
            }
        }

    // Setup up reasonable default device values in case this type of
    //  device has not been used in a session before
	pstPrivate->hSocket = INVALID_SOCKET;
	pstPrivate->nPort = 23;
	pstPrivate->fConnected = 0;
    pstPrivate->hComReadThread = NULL;
    pstPrivate->hComWriteThread = NULL;
	pstPrivate->fEscapeFF = TRUE;
#ifdef INCL_CALL_ANSWERING
    pstPrivate->fAnswer = 0;
#endif

    if (iRetVal != COM_OK)
        {
        if (pstPrivate)
			{
            free(pstPrivate);
			pstPrivate = NULL;
			}
        }

    return iRetVal;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckDeviceClose
 *
 * DESCRIPTION:
 *  Called when Wacker is done with this driver and is about to release .DLL
 *
 * ARGUMENTS:
 *  pstPrivate -- Pointer to our private data structure
 *
 * RETURNS:
 *  COM_OK
 *
 * AUTHOR:
 * mcc 01/19/96
 */
int WINAPI WsckDeviceClose(void *pvPrivate)
    {
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
    int ix;

    // Driver is about to be let go, do any cleanup
    // Port should have been deactivated before we are called, but
    //  check anyway.
    WsckPortDeactivate(pstPrivate);

    for (ix = 0; ix < EVENT_COUNT; ++ix)
        {
        CloseHandle(pstPrivate->ahEvent[ix]);
        }
    DeleteCriticalSection(&pstPrivate->csect);
    // Free our private data area
    free(pstPrivate);
	pstPrivate = NULL;

	DbgOutStr("WsckDeviceClose complete", 0,0,0,0,0);

    return COM_OK;
    }



/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckDeviceSpecial
 *
 * DESCRIPTION:
 *  The means for others to control any special features in this driver
 *  that are not supported by all drivers.
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *  COM_NOT_SUPPORTED if the instruction string was not recognized
 *  otherwise depends on instruction string
 *
 * AUTHOR:
 * mcc 12/26/95	(ported from NPORT)
 */
int WINAPI WsckDeviceSpecial(void *pvPrivate,
    const TCHAR *pszInstructions,
    TCHAR *pszResult,
    int   nBufrSize)
    {
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
	int				iRetVal = COM_NOT_SUPPORTED;
	unsigned long   ulSetVal;
	TCHAR			*pszEnd;
	//
	// MAX_IP_ADDR_LEN+11+1 = buffer size of pstPrivate->szRemoteAddr +
	// settings string "SET IPADDR=" + 1 for the terminating NULL
	// character.  REV 09/20/2000
	//
	TCHAR			achInstructions[MAX_IP_ADDR_LEN+11+1];
	TCHAR			*pszToken = achInstructions;
	int				iIndex;
	TCHAR			szResult[MAX_IP_ADDR_LEN+11+1];
	//ULONG			dwThreadID;

	static TCHAR *apszItems[] =
		{
		"IPADDR",
		"PORTNUM",
		"ISCONNECTED",
		"ESC_FF",					/* 3 */
        "ANSWER",
		NULL
		};

	// supported instruction strings:
	// "Set xxx=vv"
	// "Query xxx"


	if (!pszInstructions || !*pszInstructions)
		return COM_FAILED;

	//DbgOutStr("DevSpec: %s", pszInstructions, 0,0,0,0);

	if (sizeof(achInstructions)/sizeof(TCHAR) < (size_t)(StrCharGetStrLength(pszInstructions) + 1))
		return COM_NOT_SUPPORTED;

	StrCharCopyN(achInstructions, (LPTSTR)pszInstructions, nBufrSize);

	if (pszResult)
		*pszResult = TEXT('\0');

	pszToken = strtok(achInstructions, " ");
	if (!pszToken)
		return COM_NOT_SUPPORTED;

	EnterCriticalSection(&pstPrivate->csect);

	if (StrCharCmpi(pszToken, "SET") == 0)
		{
		iRetVal = COM_OK;
		pszToken = strtok(NULL, " =");
		if (!pszToken)
			pszToken = "";

		// Look up the item to set.
		for (iIndex = 0; apszItems[iIndex]; ++iIndex)
			if (StrCharCmpi(pszToken, apszItems[iIndex]) == 0)
				break;

		// Isolate the new value to be set
		pszToken = strtok(NULL, "\n");

		if (pszToken && *pszToken)
			{
			// Several items take numeric values
			ulSetVal = strtoul(pszToken, &pszEnd, 0);

			switch(iIndex)
				{
			case 0: // IPADDR
				ulSetVal = (unsigned) StrCharGetByteCount(pszToken);
				if ( ulSetVal < sizeof(pstPrivate->szRemoteAddr))
					{
					StrCharCopy(pstPrivate->szRemoteAddr, pszToken);
					iRetVal = 0;
					}
				else
					iRetVal = -1;
				break;

			case 1: // PORTNUM
				pstPrivate->nPort = (short) ulSetVal;
				iRetVal = 0;
				break;

			case 3: // ESC_FF
				pstPrivate->fEscapeFF = (int) atoi(pszToken);
				//DbgOutStr("set fEscapeFF = %d (%d) %s %d",
				//pstPrivate->fEscapeFF,ulSetVal,pszToken,
				//(int) atoi(pszToken),0);
				break;

            case 4: // ANSWER
#ifdef INCL_CALL_ANSWERING
                pstPrivate->fAnswer = ulSetVal;
                iRetVal = 0;
#else
                iRetVal = COM_FAILED;
#endif
                break;

			default:
				iRetVal = COM_FAILED;
				//DbgOutStr("DevSpec: Unrecognized instructions!", 0,0,0,0,0);
				break;
				}
			}
		else	// if (pszToken && *pszToken)
			{
			assert(0);
			iRetVal = COM_NOT_SUPPORTED;
			}
		}
	else if (StrCharCmpi(pszToken, "QUERY") == 0)
		{
		iRetVal = COM_OK;
		pszToken = strtok(NULL, "\n");
		szResult[0] = TEXT('\0');

		// Look up the item to query
		for (iIndex = 0; apszItems[iIndex]; ++iIndex)
			if (StrCharCmpi(pszToken, apszItems[iIndex]) == 0)
				break;

		if (*pszToken)
			{
			switch(iIndex)
				{
			case 0: // IPADDR
				StrCharCopyN(szResult, pstPrivate->szRemoteAddr, (sizeof(szResult)/sizeof(TCHAR)));
				szResult[sizeof(szResult)/sizeof(TCHAR) - 1] = TEXT('\0');
				iRetVal = 0;
				break;

			case 1: // PORTNUM
				wsprintf(szResult, "%d", pstPrivate->nPort);
				iRetVal = 0;
				break;

			case 2: // ISCONNECTED
				wsprintf(szResult, "%d", pstPrivate->fConnected);
				iRetVal = 0;
				break;

            case 4: // ANSWER
#ifdef INCL_CALL_ANSWERING
                wsprintf(szResult, "%d", pstPrivate->fAnswer);
                iRetVal = 0;
#else
                iRetVal = COM_FAILED;
#endif
                break;

			default:
				iRetVal = COM_FAILED;
				break;
				}
			if ( iRetVal == 0 && StrCharGetByteCount(szResult) <
				nBufrSize )
				StrCharCopy(pszResult, szResult);
			else
				iRetVal = COM_FAILED;
			}
		}
     else if (lstrcmpi(pszInstructions, "Send Break") == 0)
        {
        // This is the telent "Break" key processing.  When
        // the user presses Ctrl-Break on the terminal sreen
        // with a WinSOck connection, we arrive here.
        //
        // Please refer to RFC 854 for specifics on this
        // implementation.  Basically, we need to..
        // send the IAC BREAK signal (0xFF 0xF3)
        unsigned char ach[2];

        ach[0] = IAC;
        ach[1] = BREAK;

		if (send(pstPrivate->hSocket, ach,	2, 0) != 2)
            {
            assert(0);
            }

        iRetVal = COM_OK;
        }
   else if (lstrcmpi(pszInstructions, "Send IP") == 0)
        {
        // This is the telent Interrupt Process.  When
        // the user presses Alt-Break on the terminal sreen
        // with a WinSock connection, we arrive here.
        //
        // Please refer to RFC 854 for specifics on this
        // implementation.  Basically, we need to..
        //
        // Send the Telnet IP (Interrupt Processs)
        // sequence (0xFF 0xF4).
        //
        // Send the Telnet SYNC sequence.  That is,
        // send the Data Mark (DM) as the only character
        // is a TCP urgent mode send operation (the mode
        // flag MSG_OOB does this for us).
        //
        unsigned char ach[2];

        SndBufrClear(pstPrivate);

        ach[0] = IAC;
        ach[1] = IP;

		if (send(pstPrivate->hSocket, ach,	2, 0) != 2)
            {
            assert(0);
            }

        ach[0] = IAC;
        ach[1] = DM;

        if (send(pstPrivate->hSocket, ach,	2, MSG_OOB) != 2)
            {
            assert(0);
            }


        iRetVal = COM_OK;
        }
	else if (lstrcmpi(pszInstructions, "Update Terminal Size") == 0)
        {
		// The dimensions of the terminal have changed. If we have negotiated
		// to use the Telnet NAWS option, (Negotiate About Terminal Size), then
		// we must send the new terminal size to the server. This method will
		// only send data out if the option has been enabled.
		WinSockSendNAWS( pstPrivate );
		}

	LeaveCriticalSection(&pstPrivate->csect);

	return iRetVal;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  WsckDeviceLoadHdl
 *
 * DESCRIPTION:
 *	We need a function that appears to load/save to the session file,
 *  returning SF_OK, but actually doing nothing since this driver saves
 *  no settings.
 *
 * ARGUMENTS:
 *  pstPrivate  -- dummy (not used)
 *  sfHdl       -- dummy (not used)
 *
 * RETURNS:
 *
 * AUTHOR:
 * mcc 01/19/95
 */
int WINAPI WsckDeviceLoadHdl(void *pvPrivate, SF_HANDLE sfHdl)
    {
    return SF_OK;
    }/*lint !e715 */


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  WsckDeviceSaveStub
 *
 * DESCRIPTION:
 *	We need a function that appears to Save/save to the session file,
 *  returning SF_OK, but actually doing nothing since this driver saves
 *  no settings.
 *
 * ARGUMENTS:
 *  pstPrivate  -- dummy (not used)
 *  sfHdl       -- dummy (not used)
 *
 * RETURNS:
 *
 * AUTHOR:
 * mcc 01/19/95
 */
int WINAPI WsckDeviceSaveHdl(void *pvPrivate, SF_HANDLE sfHdl)
    {
    return SF_OK;
    }/*lint !e715 */



/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckDeviceStub
 *
 * DESCRIPTION:
 *  Stub that returns COM_OK (unlike default stubs)
 *
 * ARGUMENTS:
 *  pstPrivate -- not used
 *
 * RETURNS:
 *  COM_OK if port is configured successfully
 *
 * AUTHOR:
 * mcc 12/26/95
 */
int WINAPI WsckDeviceStub(void *pvPrivate)
    {
    int          iRetVal = COM_OK;

    return iRetVal;
    } /*lint !e715 */


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckPortConfigure
 *
 * DESCRIPTION:
 *  Configures an open port with the current set of user settings
 *
 * ARGUMENTS:
 *  pstPrivate -- The driver data structure
 *
 * RETURNS:
 *  COM_OK if port is configured successfully
 *  COM_DEVICE_ERROR if API errors are encountered
 *  COM_DEVICE_INVALID_SETTING if some user settings are not valid
 */
int WINAPI WsckPortConfigure(void *pvPrivate)
    {
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
    int          iRetVal = COM_OK;
    unsigned     uOverrides = 0;

    // Check for overrides
    ComQueryOverride(pstPrivate->hCom, &uOverrides);
    if (bittest(uOverrides, COM_OVERRIDE_8BIT))
        {
    	DbgOutStr("Requesting binary Telnet mode\n", 0,0,0,0,0);
		// Ask the other side to send binary data (default
		// is 7-bit ASCII), and inform them that we will
		// be sending binary data.
		WinSockSendMessage(pstPrivate, DO, TELOPT_BINARY);
		WinSockSendMessage(pstPrivate, WILL, TELOPT_BINARY);
    }

    return iRetVal;
    }

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckPortConnected
 *
 * DESCRIPTION:
 *  Determines whether the driver is currently connected to a host system.
 *	(Sort of like having a "carrier" in the STDCOM drivers)
 *
 * ARGUMENTS:
 *  pstPrivate -- Our private data structure
 *
 * RETURNS:
 *  TRUE if we have an active connection
 *  FALSE otherwise
 *
 * AUTHOR:
 * mcc 01/19/96
*/
int WINAPI WsckPortConnected(void *pvPrivate)
    {
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;

    return pstPrivate->fConnected;
    }

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckSndBufrIsBusy
 *
 * DESCRIPTION:
 *  Determines whether the driver is available to transmit a buffer of
 *  data or not.
 *
 * ARGUMENTS:
 *  pstPrivate -- address of com driver's data structure
 *
 * RETURNS:
 *  COM_OK   if data can be transmitted
 *  COM_BUSY if driver is still working on a previous buffer
 *
 * AUTHOR:
 * mcc 12/26/95
 */
int WINAPI WsckSndBufrIsBusy(void *pvPrivate)
    {
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
    int  iRetVal = COM_OK;

    EnterCriticalSection(&pstPrivate->csect);

    if (pstPrivate->fSending)
		{
        iRetVal = COM_BUSY;
		}

    LeaveCriticalSection(&pstPrivate->csect);

    // DBG_WRITE((iRetVal==COM_BUSY)?"Snd Bufr Busy\r\n":"Snd Bufr Ready\r\n",
		// 0,0,0,0,0);

    return iRetVal;
    }

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	WsckSndBufrQuery
 *
 * DESCRIPTION:
 *	A stub; I'm not really sure what else it COULD do in TCP/IP
 *
 * ARGUMENTS:
 *	ignored
 *
 * RETURNS:
 *	COM_OK
 *
 * AUTHOR:
 * 	mcc 12/26/95
 */	
int WINAPI WsckSndBufrQuery(void *pvPrivate,
    unsigned *pafStatus,
    long *plHandshakeDelay)
    {
    int     iRetVal = COM_OK;

    return iRetVal;
    }


#if !defined(MULTITHREAD)
	// WINSOCK the way we know and love it from Win3.1 days

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckPortActivate
 *
 * DESCRIPTION:
 *  Called to activate the port and connect to destination
 *
 * ARGUMENTS:
 *  pstPrivate  -- driver data structure
 *  pszPortName -- not used
 *  dwMediaHdl  -- not used (stub used only by TAPI-aware drivers)
 *
 * RETURNS:
 *  COM_OK if port is successfully activated
 *  COM_NOT_ENOUGH_MEMORY if there in insufficient memory for data storage
 *  COM_NOT_FOUND if named port cannot be opened
 *  COM_DEVICE_ERROR if API errors are encountered
 *
 * AUTHOR:
 * 	mcc 12/26/95
 */
int WINAPI WsckPortActivate(void *pvPrivate,
    TCHAR *pszPortName,
    DWORD_PTR dwMediaHdl)
    {
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
    int             iRetVal = COM_OK;
	WNDCLASS wc;
    ST_COM_CONTROL *pstComCntrl;

    // Make sure we can get enough memory for buffers before opening device
    pstPrivate->pbBufrStart = malloc((size_t)pstPrivate->nRBufrSize);

    if (pstPrivate->pbBufrStart == NULL)
        {
        iRetVal = COM_NOT_ENOUGH_MEMORY;
        //* DeviceReportError(pstPrivate, SID_ERR_NOMEM, 0, TRUE);
        goto checkout;
        }

    pstPrivate->pbBufrEnd = pstPrivate->pbBufrStart + pstPrivate->nRBufrSize;
    pstPrivate->pbReadEnd = pstPrivate->pbBufrStart;
    pstPrivate->pbComStart = pstPrivate->pbComEnd = pstPrivate->pbBufrStart;
    pstPrivate->fBufrEmpty = TRUE;
	pstPrivate->nSendBufrLen = 0;


    if (iRetVal == COM_OK)
        {
        pstComCntrl = (ST_COM_CONTROL *)pstPrivate->hCom;
        pstComCntrl->puchRBData =
            pstComCntrl->puchRBDataLimit =
            pstPrivate->pbBufrStart;

        pstPrivate->dwEventMask = EV_ERR | EV_RLSD;
        pstPrivate->fNotifyRcv = TRUE;
        pstPrivate->fBufrEmpty = TRUE;
		}



	// Register event window class to handle Winsock asynchronous
	// notifications
	wc.style         = CS_GLOBALCLASS;
	wc.lpfnWndProc   = WndSockWndProc;
	wc.cbClsExtra    = 0;
	wc.cbWndExtra    = sizeof(ST_STDCOM*);
	wc.hInstance     = hinstDLL;
	wc.hIcon         = (HICON)0;
	wc.hCursor       = (HCURSOR)0;
	wc.hbrBackground = (HBRUSH)0;
	wc.lpszMenuName  = NULL;
	wc.lpszClassName = WINSOCK_EVENT_WINDOW_CLASS;

	// Register the class, we don't check for failure because the driver
	//  can operate without it if it has to
	RegisterClass(&wc);
		
	WinSockCreateNVT(pstPrivate);
		
		
	if (!WinSockCreateEventWindow(pstPrivate))
		{
		iRetVal = COM_DEVICE_ERROR;
		goto checkout;
		}

	// Kick off Winsock processing
	PostMessage(pstPrivate->hwndEvents, WM_WINSOCK_STARTUP,
				0, 0L);


checkout:
    if (iRetVal != COM_OK)
        WsckPortDeactivate(pstPrivate);

    return iRetVal;
    }  /*lint !e715 */


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckPortDeactivate
 *
 * DESCRIPTION:
 *  Deactivates and closes an open port
 *
 * ARGUMENTS:
 *  pstPrivate -- Driver data structure
 *
 * RETURNS:
 *  COM_OK
 *
 * AUTHOR:
 * 	mcc 12/26/95
 */
int WINAPI WsckPortDeactivate(void *pvPrivate)
    {
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
    int iRetVal = COM_OK;


	// Shut down socket and WINSOCK
	shutdown(pstPrivate->hSocket, 2);
	closesocket(pstPrivate->hSocket);
	WSACleanup();
	pstPrivate->hSocket = INVALID_SOCKET;
	
	// Destroy the WINSOCK event window
	if (pstPrivate->hwndEvents)
		{
		DestroyWindow(pstPrivate->hwndEvents);
		pstPrivate->hwndEvents = 0;
		}
		
	// Destroy the read buffer		
    if (pstPrivate->pbBufrStart)
        {
        free(pstPrivate->pbBufrStart);
        pstPrivate->pbBufrStart = NULL;
        }

    return iRetVal;
    }

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckRcvRefill
 *
 * DESCRIPTION:
 *  Called when the receive buffer is empty to refill it. This routine
 *  should attempt to refill the buffer and return the first character.
 *  It is important that this function be implemented efficiently.
 *
 * ARGUMENTS:
 *  pstPrivate -- the driver data structure
 *
 * RETURNS:
 *  TRUE if data is put in the receive buffer
 *  FALSE if there is no new incoming data
 *
 * AUTHOR:
 * 	mcc 01/18/95 (from HAWIN)
 */
int WINAPI WsckRcvRefill(void *pvPrivate)
	{
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
	int nIndx;
	int iBytesRead = 0;
	int nNVTRes;
	int nBytesCopied;
	ST_COM_CONTROL FAR *pstComCntrl;
    int iReturn = TRUE;

	if (pstPrivate->fConnected == 0)
		return FALSE;

	//for (nIndx = 0; nIndx < (int)pstPrivate->usRBufrSize; nIndx += 1)
		//pstPrivate->puchRBufr[nIndx] = 0;

	// Read up to pstPrivate->usRBufrSize bytes into pstPrivate->puchRBufr
	// and set iBytesRead to the number read.
	iBytesRead = 0;
	iBytesRead = recv(pstPrivate->hSocket,
						(LPSTR)pstPrivate->pbBufrStart,
						(int)pstPrivate->nRBufrSize,
						0);
	if (iBytesRead == SOCKET_ERROR)
		{
		int iErr;

		iBytesRead = 0;
		iErr = WSAGetLastError();
		if (iErr != WSAEWOULDBLOCK)
			DbgOutStr("Refill: error %d reading %d bytes on socket %d\n", iErr,
			pstPrivate->nRBufrSize,
				pstPrivate->hSocket,0,0);
		}

	if (iBytesRead == 0)
		{
		ComNotify(pstPrivate->hCom, NODATA);
		return FALSE;
		}
		

	// update the com handle with info on new data. This is implemented
	// this way to allow HA to access these characters quickly
	nBytesCopied = 0;
	for (nIndx = 0; nIndx < iBytesRead; nIndx++)
		{

        if (pstPrivate->pbBufrStart == NULL)
            {
            return FALSE;
            }

		// If we have an FF or we are in the middle of a Telnet
		// command, run this character thru the NVT.  Unless the
		// says to discard the character, we then copy it to the
		// output position.
		if (pstPrivate->pbBufrStart[nIndx] == 0xFF ||
            pstPrivate->NVTstate != NVT_THRU)
			{
			nNVTRes = WinSockNetworkVirtualTerminal(
				(ECHAR) pstPrivate->pbBufrStart[nIndx],
				(void far *) pstPrivate);
			//DbgOutStr("NVT returns %d\n", nNVTRes, 0,0,0,0);		
			}
		else
			nNVTRes = NVT_KEEP;
		
		if (nNVTRes != NVT_DISCARD)
			{
			pstPrivate->pbBufrStart[nBytesCopied] = pstPrivate->pbBufrStart[nIndx];
			nBytesCopied++;
			}
		}

	// if we got no data (perhaps because data were "eaten" by NVT),
	// make sure we return -1
	if (nBytesCopied == 0)
        {
		*(pstPrivate->pbBufrStart) = (char) -1;
        iReturn = FALSE;
        }

	pstComCntrl = (ST_COM_CONTROL *)pstPrivate->hCom;
	pstComCntrl->puchRBData = pstPrivate->pbBufrStart;
	pstComCntrl->puchRBDataLimit = pstPrivate->pbBufrStart + nBytesCopied;

	return iReturn;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckRcvClear
 *
 * DESCRIPTION:
 *  Clears the receiver of all received data.
 *
 * ARGUMENTS:
 *  hCom -- a comm handle returned by an earlier call to ComCreateHandle
 *
 * RETURNS:
 *  COM_OK if data is cleared
 *  COM_DEVICE_ERROR if Windows com device driver returns an error
 *
 * AUTHOR:
 * mcc 01/18/96	(taken almost entirely from HAWIN)
 */
int WINAPI WsckRcvClear(void *pvPrivate)
	{
	CHAR ch[128];
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
    ST_COM_CONTROL *pstComCntrl = (ST_COM_CONTROL *)pstPrivate->hCom;

	if (pstPrivate->fConnected == 0)
		return COM_DEVICE_ERROR;

	pstComCntrl->puchRBData = pstComCntrl->puchRBDataLimit =
			pstPrivate->pbBufrStart;

	// Do whatever is necessary to remove any buffered data from the com port

	while (recv(pstPrivate->hSocket, ch, 128, 0) != SOCKET_ERROR)
			{
			}

	return COM_OK;
	}



/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckSndBufrSend
 *
 * DESCRIPTION:
 *	Transmits a buffer of characters. This routine need only queue up a
 *	buffer to be transmitted. If the com device supports interrupt-driven
 *	or hardware-controlled transmission, this function should start the
 *	process but should not wait until all the data has actually been sent.
 *
 * ARGUMENTS:
 *	pstPrivate -- Pointer to driver data structure
 *	pvBufr	   -- Pointer to data to send
 *	nSize	   -- Number of bytes to send
 *
 * RETURNS:
 *	COM_OK
 *	or appropriate error code
 *
 * AUTHOR:
 * 	mcc 01/19/96
 */
int WINAPI WsckSndBufrSend(void *pvPrivate, void *pvBufr, int  nBytesToSend)
	{
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
	int 	nCount;
	int 	nError;
	int	 	nSize;		 	// num bytes to send during this pass
	int		usReturnValue = COM_OK;
	unsigned char *pszPtr = (unsigned char *)pvBufr;
  	unsigned char *pcThisPassData;
	int		fGotFF = FALSE;	// TRUE if last char detected was an FF
	int		nOffset;
	LPSTR   puchRemains;
	int		fQueueing = FALSE;


	assert(pvBufr != (VOID FAR *)0);
	assert(nBytesToSend <= WSOCK_SIZE_OUTQ);
	
	
	if (pstPrivate->fSending)
		{
		DbgOutStr("SBS: Busy = %d\n", pstPrivate->fSending, 0,0,0,0);
		return COM_BUSY;
		}
		
	assert(pstPrivate->nSendBufrLen == 0);

	if (pstPrivate->fConnected == 0)	
		return COM_DEVICE_ERROR;


	// If we are escaping FF characters by sending them as FFFF,
	// things are a bit tricky because we have no extra room in the buffer
	// for the doubled characters.  The idea here is to send the buffer
	// in several passes; if an FF character is found, it is sent once
	// at the end of one pass and again at the beginning of the next
	// At the end of each pass, we decrement nBytesToSend by the
	// number of bytes sent during the pass (nSize), and keep looping
	// until all the data are sent
	nOffset = 0;
	ComNotify(pstPrivate->hCom, SEND_STARTED);						
	while (nBytesToSend > 0 && usReturnValue == COM_OK)
		{
		if (pstPrivate->fEscapeFF)
			{
			pcThisPassData = &pszPtr[nOffset];
			
			// If we are processing an FF that was found on the
			// last pass, send it out again by itself.	Otherwise,
			// search for the next FF and send everything up to and
			// including it.
			if (fGotFF)
				{
				//DbgOutStr("SndBufrSend: 2nd FF\n", 0,0,0,0,0);
				nSize = 1;
				nOffset++;
				fGotFF = FALSE;
				}
			else
				{
				nSize = 0;
				while (pszPtr[nOffset] != 0xFF && nOffset < nBytesToSend)
					nSize++, nOffset++;
				
				// If no FF's were found, send everything
				if (nOffset >= nBytesToSend)	
					{
					nBytesToSend = 0;
					fGotFF = 0;
					}
				// otherwise, send data up to and including FF
				else
					{
					nSize++;  		// include the FF!
					fGotFF = TRUE;	// Send the 2nd FF on next pass
					//DbgOutStr("SndBufrSend: 1st FF ...", 0,0,0,0,0);
					}
				}
													
			}
		else  // send everything in one pass
			{
			nSize = nBytesToSend;
			nBytesToSend = 0;
			pcThisPassData = pvBufr;
			}
		// If we already have data queued, don't try to send directly, since
		// it might get out before the queued data do.	
		if (fQueueing)
			{
			DbgOutStr("SBS queueing output.  Queueing %d bytes\n",
						nSize,0,0,0,0);
			if (sndQueueAppend(pstPrivate,pcThisPassData,nSize) != COM_OK)
						usReturnValue = COM_DEVICE_ERROR;
			}
		else
			{
			// Pass data to TCP/IP
			nCount = 0;
			nCount = send(pstPrivate->hSocket,
							pcThisPassData,	(int)nSize,	0);
								
			// If we got a "would block" error, copy the data to send
			// to pstPrivate->auchSndBufr.  (Since the FF processing may
			// cause this block of code to be executed multiple times in
			// one SndBufrSend call, we will append new data to existing
			// data in the buffer).
			if (nCount == SOCKET_ERROR)
				{								
				nError = WSAGetLastError();

				if (nError == WSAEWOULDBLOCK)
					{
					// Winsock won't accept data, so queue it up for
					// WinSockWriteEvent to handle.  Also, lock the handle
					// until we are done so that WinSockWriteEvent can't get in
					// there.
					fQueueing = TRUE;

					DbgOutStr("SBS would block.  Queueing %d bytes\n",
						nSize,0,0,0,0);
					EnterCriticalSection(&pstPrivate->csect);
					if (sndQueueAppend(pstPrivate,pcThisPassData,nSize) != COM_OK)
						usReturnValue = COM_DEVICE_ERROR;
					}
				else
					{
					DbgOutStr("WinSock send error %d\r\n", nError, 0,0,0,0);
					//DeviceReportError(pstPrivate, (UINT)nError, 0, FALSE);
					usReturnValue = COM_DEVICE_ERROR;
					DbgOutStr("SBS: Bad error\n", 0,0,0,0,0);
					}
				}
			else
				{
   				ComNotify(pstPrivate->hCom, SEND_DONE);
				if (nCount < (int)nSize)
					{
					/*
					 * Set stuff up for next time through
					 */
					DbgOutStr("SBS send incomplete..  Queueing %d bytes\n",
						(int)nSize-nCount,0,0,0,0);
			
					// Get pointer to remaining data and queue it up		
					puchRemains = pcThisPassData + nCount;
					if (sndQueueAppend(pstPrivate, puchRemains,
							(nSize - nCount)) != COM_OK)
						{
						usReturnValue = COM_DEVICE_ERROR;
						DbgOutStr("SBS: Bad error\n", 0,0,0,0,0);
						}
					}
				}
			}

   	}
	if (fQueueing)
		LeaveCriticalSection(&pstPrivate->csect);

	return   usReturnValue;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: sndQueueAppend
 *
 * DESCRIPTION:
 *  Appends new data to any data that have been queued up for
 *  re-transmission by WinSockWriteEvent
 *
 * ARGUMENTS:
 *	pstPrivate 		-- address of com driver's data structure
 *  pvBufr      	-- address of new data block to queue up
 *  nBytesToAppend	-- size of new data	block to append
 *
 * RETURNS:
 *	COM_OK	 if data can be transmitted
 *	COM_BUSY if no more room for data to queue up
 *
 * AUTHOR:
 * 	mcc 01/19/96 (from HAWIN)
 */

int FAR PASCAL sndQueueAppend(ST_STDCOM* pstPrivate,
						VOID FAR *pvBufr, int nBytesToAppend)
						
	{					
	LPSTR	puchEnd;
	USHORT  usReturns = COM_OK;

	assert( pstPrivate != NULL );
	assert( pvBufr != NULL );

	//jkh 9/11/98 to avoid memcpy with invalid params
	if ( pstPrivate && pvBufr && nBytesToAppend > 0 )
		{
		if (pstPrivate->nSendBufrLen + nBytesToAppend >
				(int) sizeof(pstPrivate->abSndBufr))
			{
			DbgOutStr("SQAPP: buffer full", 0,0,0,0,0);
			return COM_BUSY;
			}
	
		// Set the flag that SndBufrIsBusy looks at; we are
		// in the middle of a send until the buffer is cleared
		// by WinSockWriteEvent
		pstPrivate->fSending = TRUE;
		
		pstPrivate->pbSendBufr = pstPrivate->abSndBufr;			
		puchEnd = pstPrivate->pbSendBufr + pstPrivate->nSendBufrLen;

		DbgOutStr("sQA: appending %d bytes to addr = %lx.  Existing buffer is %d bytes at %lx\n",
			nBytesToAppend,	puchEnd, pstPrivate->nSendBufrLen, pstPrivate->pbSendBufr,0);
		pstPrivate->nSendBufrLen += nBytesToAppend;
		MemCopy(puchEnd, (LPSTR) pvBufr, (unsigned) nBytesToAppend);
		}

	DbgOutStr("sQA: copy done\n", 0,0,0,0,0);
	return usReturns;
	}




/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckSndBufrClear
 *
 * DESCRIPTION:
 *	Clear any data waiting to be transmitted
 *
 * ARGUMENTS:
 *	pstPrivate -- pointer to driver data structure
 *
 * RETURNS:
 *	COM_OK
 *	or appropriate error code
 *
 * AUTHOR
 * 	mcc 01/19/96 (from HAWIN)
 */
int WINAPI WsckSndBufrClear(ST_STDCOM *pstPrivate)
	{
	USHORT usReturnValue = COM_OK;

	DbgOutStr("SndBufrClear called", 0,0,0,0,0);

	if (WsckSndBufrIsBusy(pstPrivate))
		{
		pstPrivate->nSendBufrLen = 0;
		pstPrivate->pbSendBufr = 0;
		}

	// Call SndBufrIsBusy again to clear flags, timers, etc.
	WsckSndBufrIsBusy(pstPrivate);
	return usReturnValue;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WndSockWndProc
 *
 * DESCRIPTION:
 *	This is the window procedure for the window that is used to receive event
 *	messages from the WinSock interface.  It uses this to get around the pesky
 *	problem of blocking vs. non-blocking requirements and expectations.
 *
 * ARGUEMENTS:
 *	The usual stuff for a window procedure.
 *
 * RETURNS:
 *	The usual stuff for a window procedure.
 *
 * AUTHOR
 * 	mcc 01/19/96 (from HAWIN)
 */
LRESULT FAR PASCAL WndSockWndProc(HWND hWnd, UINT uiMsg, WPARAM uiPar1, LPARAM lPar2)
	{
	ST_STDCOM*pstPrivate;
	WORD wVersion;
	WSADATA stWsaData;

	switch (uiMsg)
		{
		case WM_WINSOCK_STARTUP:
			pstPrivate = (ST_STDCOM*)GetWindowLongPtr(hWnd, 0);
			if (pstPrivate == (ST_STDCOM*)0)
				break;

			DbgOutStr("Calling WSAStartup\n", 0,0,0,0,0);
			/*
			 * Initialize the Windows Socket DLL
			 */
			wVersion = 0x0101;			// The version of WinSock that we want
			if (WSAStartup(wVersion, &stWsaData) != 0)
				{
				/* No DLL was available */
				return COM_DEVICE_ERROR;
				}
			DbgOutStr("Done calling WSAStartup\n", 0,0,0,0,0);
		   //	pstPrivate->fActive = TRUE;

			/* Confirm that the Windows Socket DLL supports 1.1. */
			/* Note that if the DLL supports versions greater    */
			/* than 1.1 in addition to 1.1, it will still return */
			/* 1.1 in wVersion since that is the version we      */
			/* requested                                         */
			if ((LOBYTE(stWsaData.wVersion) != 1) &&
				(HIBYTE(stWsaData.wVersion) != 1))
				{
				/* No acceptable DLL was available */
				return COM_DEVICE_ERROR;
				}

			/*
			 * Create a socket for later use.
			 */
			DbgOutStr("Calling socket\n", 0,0,0,0,0);
			
			pstPrivate->hSocket = socket(PF_INET, SOCK_STREAM, 0);
			if (pstPrivate->hSocket == INVALID_SOCKET)
				{
				return COM_DEVICE_ERROR;
				}
			DbgOutStr("Done calling socket\n", 0,0,0,0,0);

#ifdef INCL_CALL_ANSWERING			
            if (pstPrivate->fAnswer)
                {
			    WinSockAnswerSpecial(pstPrivate);
                }
            else
                {
			    WinSockConnectSpecial(pstPrivate);
                }
#else
			WinSockConnectSpecial(pstPrivate);
#endif
			break;
			
		case WM_WINSOCK_NOTIFY:
			{
			pstPrivate = (ST_STDCOM*)GetWindowLongPtr(hWnd, 0);
			if (pstPrivate == (ST_STDCOM*)0)
				break;

			switch(LOWORD(lPar2))
				{
				case FD_READ:
					return WinSockReadEvent(pstPrivate, lPar2);

				case FD_WRITE:
					return WinSockWriteEvent(pstPrivate, lPar2);

				case FD_CLOSE:
					//DbgOutStr("FD_CLOSE\r\n", 0,0,0,0,0);
					return WinSockCloseEvent(pstPrivate, lPar2);

				case FD_CONNECT:
					//DbgOutStr("FD_CONNECT\r\n", 0,0,0,0,0);
					return WinSockConnectEvent(pstPrivate, lPar2);

				case FD_ACCEPT:
					//DbgOutStr("FD_ACCEPT\r\n", 0,0,0,0,0);
					return WinSockAcceptEvent(pstPrivate, lPar2);

				default:
					break;
				}
			}
			break;

		case WM_WINSOCK_RESOLVE:
			{
			/* We get here after a call to WSAAsyncGetHostByName */
			pstPrivate = (ST_STDCOM*)GetWindowLongPtr(hWnd, 0);
			if (pstPrivate == (ST_STDCOM*)0)
				break;

			return WinSockResolveEvent(pstPrivate, lPar2);
			}

		default:
			break;
		}

	return DefWindowProc(hWnd, uiMsg, uiPar1, lPar2);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WndSockCreateEventWindow
 *
 * DESCRIPTION:
 *	Creates the event window used to process messages sent by the WinSock DLL.
 *
 * ARGUMENTS:
 *	pstPrivate		pointer to private data structure; attach to window
 *
 * RETURNS:
 *	TRUE if everything is OK, otherwise FALSE.
 *
 * AUTHOR
 * 	mcc 01/19/96 (from HAWIN)
 */
BOOL WinSockCreateEventWindow (ST_STDCOM *pstPrivate)
	{
	BOOL fRetVal = TRUE;

	if (fRetVal)
		{
		pstPrivate->hwndEvents = CreateWindow(
										WINSOCK_EVENT_WINDOW_CLASS,
										"",
										WS_OVERLAPPEDWINDOW,
										0, 0, 0, 0,
										HWND_DESKTOP,
										NULL,
										hinstDLL,
										NULL);
		fRetVal = (pstPrivate->hwndEvents != (HWND)0);
		}

	if (fRetVal)
		{
		SetWindowLongPtr(pstPrivate->hwndEvents, 0, (LONG_PTR)pstPrivate);
		}

	return fRetVal;
	}
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	WinSockSendBreak
 *
 * DESCRIPTION:
 *	This function attempts to send a break condition to the NVT on the other
 *	end of the connection.  See RFC854 for details and good luck.
 *
 * PARAMETERS:
 *	pstPrivate		Driver's private data structure
 *
 * RETURNS:
 *
 * AUTHOR
 * 	mcc 01/19/96 (from HAWIN)
 */
VOID WinSockSendBreak(ST_STDCOM*pstPrivate)
	{
	UCHAR acSendBreak[2];

	//DbgOutStr("WinSockSendBreak\r\n", 0,0,0,0,0);

	acSendBreak[0] = 255;
	acSendBreak[1] = 243;
	send(pstPrivate->hSocket, acSendBreak, 2, 0);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 */
USHORT WinSockSendBreakSpecial(ST_STDCOM *pstPrivate,
							LPSTR pszData,
							UINT uiSize)
	{
	if (pstPrivate->nSendBufrLen > 0)
		{
		/* Can't do it now, wait until next time */
		pstPrivate->fSndBreak = TRUE;
		}
	else
		{
		WinSockSendBreak(pstPrivate);
		}

	return 0;
	} /*lint !e715 */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
 * AUTHOR
 * 	mcc 01/19/96 (from HAWIN)
 */
int WinSockConnectSpecial(ST_STDCOM*pstPrivate)
	{
	USHORT usRetVal;
	int nIndx;
	int nError;
	unsigned long ulAddr;
	struct sockaddr_in	srv_addr;
	struct sockaddr_in	cli_addr;
	HANDLE  hReturn;

	usRetVal = COM_OK;

	cli_addr.sin_family = AF_INET;
	cli_addr.sin_addr.s_addr = INADDR_ANY;
	cli_addr.sin_port = 0;

	// Bind the socket to any internet address.  Ignore errors;
	// real ones will be detected later, and this WILL fail
	// if the socket is already bound.
	usRetVal = (USHORT)bind(pstPrivate->hSocket, (LPSOCKADDR)&cli_addr,
			sizeof(cli_addr));
	DbgOutStr("Socket %d bind returns %d\n", pstPrivate->hSocket, usRetVal, 0,0,0);

	// See if the remote address has been entered in numeric form.  If not,
	// we will have to call WSAAsynchGetHostByName to translate it; in that
	// case, the EventWindow handler will call connect.
	ulAddr = inet_addr(pstPrivate->szRemoteAddr);
	if ((ulAddr == INADDR_NONE) || (ulAddr == 0))
		{
		DbgOutStr("WSCnctSp: calling WSA...HostByName\n", 0,0,0,0,0);
		/* We take the long way around */
		hReturn = WSAAsyncGetHostByName(
							pstPrivate->hwndEvents,
							WM_WINSOCK_RESOLVE,
							pstPrivate->szRemoteAddr,
							(char *) &pstPrivate->stHostBuf,
							MAXGETHOSTSTRUCT);
		
		if (hReturn == 0)
			nError = WSAGetLastError();
		else
			nError = 0 ;		
		DbgOutStr("WSAAsynchGetHostByName returns %lx (err = %d)\n", hReturn,
				nError,0,0,0);
		goto WSCSexit;
		}

	/*
	 * This is the alternate pathway for the connect.  We go thru here if
	 * the address was in the form of a 123.456.789.123 address.
	 */
	srv_addr.sin_family = AF_INET;
	srv_addr.sin_addr.s_addr = ulAddr;
	srv_addr.sin_port = htons((USHORT)pstPrivate->nPort);

	nIndx = WSAAsyncSelect(pstPrivate->hSocket,
							pstPrivate->hwndEvents,
							WM_WINSOCK_NOTIFY,
							FD_CONNECT | FD_READ | FD_WRITE | FD_CLOSE
							);

	if (nIndx != 0)
		{
		/* Oops, something goofed */
		usRetVal = COM_DEVICE_ERROR;
		DbgOutStr("WSAAsyncSelect failed\n", 0,0,0,0,0);
		goto WSCSexit;
		}

	if (connect(pstPrivate->hSocket,
							(LPSOCKADDR)&srv_addr,
							sizeof(srv_addr)) == SOCKET_ERROR)
		{
		nIndx = WSAGetLastError();
		if (nIndx != WSAEWOULDBLOCK)
			{
			usRetVal = COM_DEVICE_ERROR;
			//DeviceReportError(pstPrivate, (UINT)nIndx, 0, FALSE);
			DbgOutStr("Connect failed (err = %d)\n", nIndx, 0,0,0,0);
			goto WSCSexit;
			}
		}

WSCSexit:
	//DbgOutStr(" returns %d\r\n", usRetVal, 0,0,0,0);
	if (usRetVal != COM_OK)
		{
	   closesocket(pstPrivate->hSocket);
		}

	return usRetVal;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  WinSockAnswerSpecial
 *
 * DESCRIPTION:
 *  Sets up WinSock to answer a call.
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
 * AUTHOR:  C. Baumgartner, 11/19/96 (ported from HAWin16)
 */
int WinSockAnswerSpecial(ST_STDCOM*pstPrivate)
	{
	int                nError = 0;
	USHORT             usRetVal = COM_OK;
	struct sockaddr_in host_addr;

    // Create our local internet address.
    //
	host_addr.sin_family = AF_INET;
	host_addr.sin_addr.s_addr = INADDR_ANY;
	host_addr.sin_port = htons((USHORT)pstPrivate->nPort);

    // Bind the socket to our local address.
    //
    nError = bind(pstPrivate->hSocket, (LPSOCKADDR)&host_addr,
        sizeof(host_addr));
    DbgOutStr("Socket %d bind returns %d\n", pstPrivate->hSocket, nError, 0,0,0);

	if (nError != 0)
		{
		usRetVal = COM_DEVICE_ERROR;
		goto WSASexit;
		}

    // Tell the socket to notify us of events that we are interested
    // in (like when somebody connects to us).
    //
	nError = WSAAsyncSelect(pstPrivate->hSocket, pstPrivate->hwndEvents,
        WM_WINSOCK_NOTIFY, FD_ACCEPT | FD_READ | FD_WRITE | FD_CLOSE);

    if (nError != 0)
        {
        usRetVal = COM_DEVICE_ERROR;
        goto WSASexit;
        }

    // Tell the socket to wait for incoming calls.
    //
	if (listen(pstPrivate->hSocket, 1) != 0)
		{
		usRetVal = COM_DEVICE_ERROR;
		goto WSASexit;
		}

WSASexit:
	if (usRetVal != COM_OK)
		{
		closesocket(pstPrivate->hSocket);
		}

	return usRetVal;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
 * AUTHOR
 * 	mcc 01/19/96 (from HAWIN)
USHORT WinSockDisconnectSpecial(ST_STDCOM*pstPrivate,
							LPSTR pszData,
							UINT uiSize)
	{

	if (pstPrivate->hSocket != INVALID_SOCKET)
		{
		closesocket(pstPrivate->hSocket);
		pstPrivate->hSocket = INVALID_SOCKET;
		}

	pstPrivate->fConnected = 0;

	return COM_OK;
	} /*lint !e715 */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
 * AUTHOR
 * 	mcc 01/19/96 (from HAWIN)
 */
LONG WinSockCloseEvent(ST_STDCOM*pstPrivate, LPARAM lPar)
	{
	pstPrivate->fConnected = 0;
	ComNotify(pstPrivate->hCom, CONNECT);

	return 0;
	}  /*lint !e715 */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *	pstPrivate		Driver's private data structure
 *  lPar			status code from Winsock
 *
 * RETURNS:
 */
LONG WinSockConnectEvent(ST_STDCOM*pstPrivate, LPARAM lPar)
	{
	int status;
	status = (int)HIWORD(lPar);
	if (status)
		{
		pstPrivate->fConnected = 0;
		ComNotify(pstPrivate->hCom, CONNECT);
		}
	else
		{
		pstPrivate->fConnected = 1;
		ComNotify(pstPrivate->hCom, CONNECT);
		}
	return 0;
	}	/*lint !e715 */


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  WinSockAcceptEvent
 *
 * DESCRIPTION:
 *  Accepts an incoming call.
 *
 * PARAMETERS:
 *	pstPrivate		Driver's private data structure
 *  lPar			status code from Winsock
 *
 * RETURNS:
 *
 * AUTHOR:  C. Baumgartner, 11/19/96 (ported from HAWin16)
 */
LONG WinSockAcceptEvent(ST_STDCOM*pstPrivate, LPARAM lPar)
	{
	int    status = HIWORD(lPar);
	SOCKET hAnswer = INVALID_SOCKET;
    SOCKET hOldSocket = INVALID_SOCKET;

    // We aren't connected yet.
    //
	pstPrivate->fConnected = 0;

    // Attempt to accept the call.
    //
	hAnswer = accept(pstPrivate->hSocket, NULL, 0);

	if (hAnswer != INVALID_SOCKET)
		{
        // Now we are connected.
        //
		pstPrivate->fConnected = 1;

        // Get the newly accepted socket.
        //
        hOldSocket = pstPrivate->hSocket;
		pstPrivate->hSocket = hAnswer;

        // Now close the old socket because we don't want to
        // be listening when we are connected.
        //
        closesocket(hOldSocket);
		}

    // Let the rest of the world know that we are connected.
    //
	ComNotify(pstPrivate->hCom, CONNECT);

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *	pstPrivate		Driver's private data structure
 *  lPar			status code from Winsock
 *
 * RETURNS:
 *
 * AUTHOR
 * 	mcc 01/19/96 (from HAWIN)
 */
LONG WinSockReadEvent(ST_STDCOM*pstPrivate, LPARAM lPar)
	{

	ComNotify(pstPrivate->hCom, DATA_RECEIVED);
	return 0;
	}   /*lint !e715 */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	WinSockWriteEvent
 *
 * DESCRIPTION:
 *	Called back by Winsock when write completes; updates data structures
 *	to allow another write to take place
 *
 * PARAMETERS:
 *	pstPrivate		Driver's private data structure
 *  lPar			status code from Winsock
 *
 * RETURNS:
 *	
 * AUTHOR
 * 	mcc 01/19/96 (from HAWIN)

 */
LONG WinSockWriteEvent(ST_STDCOM *pstPrivate, LPARAM lPar)
	{
	int nCount;
	int nError;


	DbgOutStr("WinSockWriteEvent called to handle %d bytes ...",
      		pstPrivate->nSendBufrLen,0,0,0,0);
	
	if (pstPrivate->fConnected == 0)
		return 0;

	if (pstPrivate->fSndBreak)
		{
		WinSockSendBreak(pstPrivate);
		pstPrivate->fSndBreak = FALSE;
		}

	if (pstPrivate->nSendBufrLen)
		{
		// This is done to keep the "main thread" from updating the buffer
		//  while we send it.  OK, I think, since send won't block.
	    EnterCriticalSection(&pstPrivate->csect);

		nCount = send(pstPrivate->hSocket,
								pstPrivate->pbSendBufr,
								(int)pstPrivate->nSendBufrLen,
								0);
	    LeaveCriticalSection(&pstPrivate->csect);


		// DbgOutStr("WinSock send returned %d\r\n", nCount, 0,0,0,0);

		// assert((int)pstPrivate->SendBufrLen == nCount);

		if (nCount == SOCKET_ERROR)
			{
			nError = WSAGetLastError();

			if (nError == WSAEWOULDBLOCK)
				{
				DbgOutStr("  still blocked\n", 0,0,0,0,0);
				/*
				 * Nothing to do in this case
				 */
				}
			else
				{
				// Got some weird error.  Notify interested parties
				// that our connection is suspect
				DbgOutStr(" got error %d\r\n", nError, 0,0,0,0);
				pstPrivate->nSendBufrLen = 0;
				pstPrivate->pbSendBufr = 0;
				ComNotify(pstPrivate->hCom, CONNECT);
				}
			}
		else
			{
			DbgOutStr("%d bytes sent.\n", nCount, 0,0,0,0);
	
			if (nCount < (int)pstPrivate->nSendBufrLen)
				{
				pstPrivate->nSendBufrLen -= (USHORT)nCount;
				pstPrivate->pbSendBufr += nCount;
				}
			else
				{
				pstPrivate->nSendBufrLen = 0;
				pstPrivate->pbSendBufr = 0;
				}
			}
		}

	if (pstPrivate->nSendBufrLen == 0)
		{
		pstPrivate->fSending = FALSE;


		//DbgOutStr("Sending WM_COM_SEND_DONE in WinSockWriteEvent\n",0,0,0,0,0);
   		ComNotify(pstPrivate->hCom, SEND_DONE);
		}

	return 0;
	}   /*lint !e715 */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	WinSockResolveEvent
 *
 * DESCRIPTION:
 *	Called once WSAAsynchGetHostByName has done its dirty work to actually
 *  generate a connect call
 *
 * PARAMETERS:
 *	pstPrivate		Driver's private data structure
 *  lPar			returned from previous Winsock call
 *
 * RETURNS:
 *	0
 *
 * AUTHOR
 *	mcc 01/18/96 (borrowed from HAWIN)
 */
LONG WinSockResolveEvent(ST_STDCOM *pstPrivate, LPARAM lPar)
	{
	int nError;
	struct sockaddr_in	srv_addr;
	LPHOSTENT			pstHost;
	ULONG				*pulAddress;

	DbgOutStr("WinSockResolveEvent called\n", 0,0,0,0,0);

	nError = HIWORD(lPar);
	if (nError)
		{
		// Notify the connection driver that a change in status may
		// have taken place.  It will follow up and display
		// an appropriate message
		DbgOutStr("Resolve: hiword of lpar = %d\n", nError,0,0,0,0);
		
		ComNotify(pstPrivate->hCom, CONNECT);
		pstPrivate->fConnected = 0;
		
		return 0;
		}

	pstHost = (LPHOSTENT) &pstPrivate->stHostBuf;
	pulAddress = (ULONG FAR *)*(pstHost->h_addr_list);

	nError = WSAAsyncSelect(pstPrivate->hSocket,
							pstPrivate->hwndEvents,
							WM_WINSOCK_NOTIFY,
							FD_CONNECT | FD_READ | FD_WRITE | FD_CLOSE
							);

	if (nError != 0)
		{
		DbgOutStr("Resolve: WSAAsyncSelect failed\n", 0,0,0,0,0);
		ComNotify(pstPrivate->hCom, CONNECT);
		return 0;
		}


	srv_addr.sin_family = AF_INET;
	srv_addr.sin_addr.s_addr = *pulAddress;
	srv_addr.sin_port = (short) htons(pstPrivate->nPort);

 	if (connect(pstPrivate->hSocket,
							(LPSOCKADDR)&srv_addr,
							sizeof(srv_addr)) == SOCKET_ERROR)
		{
		nError = WSAGetLastError();
		if (nError != WSAEWOULDBLOCK)
			{
			DbgOutStr("Resolve: connect failed, code = %d\n", nError,
					0,0,0,0);
			//DeviceReportError(pstPrivate, (UINT)nError, 0, FALSE);
			ComNotify(pstPrivate->hCom, CONNECT);
			}
		}

	return 0;
	}
	
	
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	WinSockSendMessage
 *
 * DESCRIPTION:
 *	Used to send a Telnet option message. This calls send() directly so
 *	that data can go out while SndBufrSend is reporting COM_BUSY.
 *
 * PARAMETERS:
 *	pstPrivate		Com driver private data
 *	nMsg			The message number , e.g. DO, WILL, WONT, (see comwsock.hh)
 *	nChar			The message data, e.g. TELOPT_BINARY (see comwsock.hh)
 *
 * RETURNS:
 *	void
 *
 * AUTHOR
 *	mcc 02/06/96
 */
VOID WinSockSendMessage(ST_STDCOM * pstPrivate, INT nMsg, INT nChar)
    {
	unsigned char 	acMsg[3];

#if defined(_DEBUG)
	char *nNames[] = {"WILL", "WONT", "DO", "DONT"};
	assert( nMsg >= WILL && nMsg <= DONT );
	DbgOutStr("Send %s: %lx\r\n", nNames[nMsg - WILL], nChar,0,0,0);
#endif
	acMsg[0] = IAC;
	acMsg[1] = (UCHAR) nMsg;
	acMsg[2] = (UCHAR) nChar;
			
	
	WinSockSendBuffer(pstPrivate, 3, acMsg);
	
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	WinSockSendBuffer
 *
 * DESCRIPTION:
 *	Used to send an arbitrary string of data (e.g., a terminal type)
 *  during Telnet option negotiation
 *
 * PARAMETERS:
 *	pstPrivate		Winsock Com driver private data
 *	nSize			Number of bytes to send
 *	pszBuffer		Pointer to data to send
 *
 * RETURNS:
 *	void
 *
 * AUTHOR
 *	mcc 02/06/96
 */
VOID WinSockSendBuffer(ST_STDCOM * pstPrivate, INT nSize, LPSTR pszBuffer)
	{
	int nCount, nError;
	
	nCount = send(pstPrivate->hSocket, pszBuffer, nSize,0);
						
	if (nCount == SOCKET_ERROR)
		{								
		nError = WSAGetLastError();

		if (nError == WSAEWOULDBLOCK)
			{
			DbgOutStr("WSSB would block.  Queueing 3 bytes\n",
				0,0,0,0,0);
			if (sndQueueAppend(pstPrivate,pszBuffer, 3) != COM_OK)
				ComNotify(pstPrivate->hCom, CONNECT);
			}
		else
			ComNotify(pstPrivate->hCom, CONNECT);
		
		}
	else
		{
		int i;
		DbgOutStr("%4d >> ", nCount,0,0,0,0);
    	for (i = 0; i < nCount; i++)
    	DbgOutStr("%x ", pszBuffer[i],0,0,0,0);
		DbgOutStr("\n", 0,0,0,0,0);	
		}	
	}

	

#endif



#ifdef MULTITHREAD
	// This is essentially the NPORT TCPCOM driver ported to
	// Win32.  It uses different threads for reading and
	// writing to the TCP socket.
	// This code is deadwood at the moment, but might prove
	// useful in Upper Wacker if someone can figure out
	// why it does not work reliably under Win95. (send() calls
	// would often appear to work but no data would come out
	// over the socket.)

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckPortActivate
 *
 * DESCRIPTION:
 *  Called to activate the port and connect to destination
 *
 * ARGUMENTS:
 *  pstPrivate  -- driver data structure
 *  pszPortName -- not used
 *
 * RETURNS:
 *  COM_OK if port is successfully activated
 *  COM_NOT_ENOUGH_MEMORY if there in insufficient memory for data storage
 *  COM_NOT_FOUND if named port cannot be opened
 *  COM_DEVICE_ERROR if API errors are encountered
 *
 * AUTHOR:
 * mcc 12/26/95
 */
int WINAPI WsckPortActivate(void *pvPrivate,
    TCHAR *pszPortName,
    DWORD_PTR dwMediaHdl)
    {
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
    int             iRetVal = COM_OK;
    ST_COM_CONTROL *pstComCntrl;
    DWORD           dwThreadID;
	WORD wVersion;
	WSADATA stWsaData;
	struct sockaddr_in	cli_addr;



	/*
	 * Initialize the Windows Socket DLL
	 */
	wVersion = 0x0101;			// The version of WinSock that we want
	if (WSAStartup(wVersion, &stWsaData) != 0)
		{
		/* No DLL was available */
		iRetVal = COM_DEVICE_ERROR;
        goto checkout;
		}
	DbgOutStr("Done calling WSAStartup\n", 0,0,0,0,0);

	/* Confirm that the Windows Socket DLL supports 1.1. */
	/* Note that if the DLL supports versions greater    */
	/* than 1.1 in addition to 1.1, it will still return */
	/* 1.1 in wVersion since that is the version we      */
	/* requested                                         */
	if ((LOBYTE(stWsaData.wVersion) != 1) &&
		(HIBYTE(stWsaData.wVersion) != 1))
		{
		/* No acceptable DLL was available */
		iRetVal = COM_DEVICE_ERROR;
        goto checkout;
		}

	/*
	 * Create a socket for later use.
	 */
	pstPrivate->hSocket = socket(PF_INET, SOCK_STREAM, 0);
	if (pstPrivate->hSocket == INVALID_SOCKET)
		{
		iRetVal = WSAGetLastError();
		DbgOutStr("Error %d creating socket\n", iRetVal, 0,0,0,0);
		iRetVal = COM_DEVICE_ERROR;
		goto checkout;
		}
	DbgOutStr("Done creating socket %d \n", pstPrivate->hSocket,0,0,0,0);




	cli_addr.sin_family = AF_INET;
	cli_addr.sin_addr.s_addr = INADDR_ANY;
	cli_addr.sin_port = 0;

	// Bind the socket to any internet address.  Ignore errors;
	// real ones will be detected later, and this WILL fail
	// if the socket is already bound.
	iRetVal = bind(pstPrivate->hSocket, (LPSOCKADDR)&cli_addr,
			sizeof(cli_addr));
	DbgOutStr("Socket %d bind returns %d\n", pstPrivate->hSocket, iRetVal, 0,0,0);

    // Make sure we can get enough memory for buffers before opening device
    pstPrivate->pbBufrStart = malloc((size_t)pstPrivate->nRBufrSize);

    if (pstPrivate->pbBufrStart == NULL)
        {
        iRetVal = COM_NOT_ENOUGH_MEMORY;
        //* DeviceReportError(pstPrivate, SID_ERR_NOMEM, 0, TRUE);
        goto checkout;
        }

    pstPrivate->pbBufrEnd = pstPrivate->pbBufrStart + pstPrivate->nRBufrSize;
    pstPrivate->pbReadEnd = pstPrivate->pbBufrStart;
    pstPrivate->pbComStart = pstPrivate->pbComEnd = pstPrivate->pbBufrStart;
    pstPrivate->fBufrEmpty = TRUE;


    if (iRetVal == COM_OK)
        {
        pstComCntrl = (ST_COM_CONTROL *)pstPrivate->hCom;
        pstComCntrl->puchRBData =
            pstComCntrl->puchRBDataLimit =
            pstPrivate->pbBufrStart;

        pstPrivate->dwEventMask = EV_ERR | EV_RLSD;
        pstPrivate->fNotifyRcv = TRUE;
        pstPrivate->fBufrEmpty = TRUE;


        // Start thread to handle Reading, Writing (& 'rithmetic) & events
        pstPrivate->fHaltThread = FALSE;
        pstPrivate->hComReadThread = CreateThread((LPSECURITY_ATTRIBUTES)0,
                    16384, WsckComReadThread, pstPrivate, 0, &dwThreadID);
		DBG_THREAD("CreateThread (Read Thread)  returned %08X %08X\r\n",
            pstPrivate->hComReadThread,0,0,0,0);

        pstPrivate->hComWriteThread = CreateThread((LPSECURITY_ATTRIBUTES)0,
                    16384, WsckComWriteThread, pstPrivate, 0, &dwThreadID);
        DBG_THREAD("CreateThread  (Write Thread) returned %08X %08X\r\n",
            pstPrivate->hComWriteThread,0,0,0,0);
			
		// TODO discuss with JKH what thread priorities should be

		// Make sure that we have a valid address to connect to
		if ( wsckResolveAddress(pstPrivate->szRemoteAddr, &pstPrivate->ulAddr) != COM_OK )
			{
			pstPrivate->fConnected = 0;
			ComNotify(pstPrivate->hCom, CONNECT);
			iRetVal = COM_NOT_FOUND;
			goto checkout;
			}

		// Connect to the specified host
		pstPrivate->stHost.sin_family = AF_INET;
		pstPrivate->stHost.sin_addr.s_addr = pstPrivate->ulAddr;
		pstPrivate->stHost.sin_port = htons(pstPrivate->nPort);
		//DbgOutStr("About to call connect", 0,0,0,0,0);
		iRetVal = connect(pstPrivate->hSocket,
					  (struct sockaddr *) &pstPrivate->stHost,
					  sizeof(pstPrivate->stHost));
		if ( iRetVal == COM_OK )
			{
			pstPrivate->fConnected = TRUE;
			// Turn loose the read thread
			DbgOutStr("connect OK", 0,0,0,0,0);
			SetEvent(pstPrivate->ahEvent[EVENT_READ]);
			SetEvent(pstPrivate->ahEvent[EVENT_WRITE]);
			}
		else
			{
			iRetVal = WSAGetLastError();
			DbgOutStr(" connect() failed, rc = %d",iRetVal, 0,0,0,0);
			iRetVal = COM_NOT_FOUND;
			pstPrivate->fConnected = 0;
			ComNotify(pstPrivate->hCom, CONNECT);
			}
        }

checkout:
    if (iRetVal != COM_OK)
        WsckPortDeactivate(pstPrivate);

    return iRetVal;
    }  /*lint !e715 */


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckPortDeactivate
 *
 * DESCRIPTION:
 *  Deactivates and closes an open port
 *
 * ARGUMENTS:
 *  pstPrivate -- Driver data structure
 *
 * RETURNS:
 *  COM_OK
 *
 * AUTHOR:
 * mcc 12/26/95
 */
int WINAPI WsckPortDeactivate(void *pvPrivate)
    {
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
    int iRetVal = COM_OK;



	
	if (pstPrivate->hComReadThread || pstPrivate->hComWriteThread)
        {
        // Halt the thread by setting a flag for the thread to detect and then
        // forcing WaitCommEvent to return by changing the event mask
        DBG_THREAD("DBG_THREAD: Shutting down ComWinsock thread\r\n", 0,0,0,0,0);
        pstPrivate->fHaltThread = TRUE;

        // Read thread should exit now, it's handle will signal when it has exited
        CloseHandle(pstPrivate->hComReadThread);
		WaitForSingleObject(pstPrivate->hComReadThread, 5000);

        pstPrivate->hComReadThread = NULL;
        DBG_THREAD("DBG_THREAD: ComWinsock thread has shut down\r\n", 0,0,0,0,0);

		// Write thread should exit now, it's handle will signal when it has exited
        CloseHandle(pstPrivate->hComWriteThread);
		WaitForSingleObject(pstPrivate->hComWriteThread, 5000);

        pstPrivate->hComWriteThread = NULL;
        DBG_THREAD("DBG_THWrite: ComWriteThread has shut down\r\n", 0,0,0,0,0);
		}

    if (pstPrivate->pbBufrStart)
        {
        free(pstPrivate->pbBufrStart);
        pstPrivate->pbBufrStart = NULL;
        }


	// Shut down socket and WINSOCK
	closesocket(pstPrivate->hSocket);


	WSACleanup();

	pstPrivate->hSocket = INVALID_SOCKET;

    return iRetVal;
    }



/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckRcvRefill
 *
 * DESCRIPTION:
 *  Called when the receive buffer is empty to refill it. This routine
 *  should attempt to refill the buffer and return the first character.
 *  It is important that this function be implemented efficiently.
 *
 * ARGUMENTS:
 *  pstPrivate -- the driver data structure
 *
 * RETURNS:
 *  TRUE if data is put in the receive buffer
 *  FALSE if there is no new incoming data
 *
 * AUTHOR:
 * mcc 12/26/95	(taken almost entirely from comstd.c)
 */
int WINAPI WsckRcvRefill(void *pvPrivate)
    {
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
    int fRetVal = FALSE;
    ST_COM_CONTROL *pstComCntrl;

    EnterCriticalSection(&pstPrivate->csect);

    pstPrivate->pbComStart = (pstPrivate->pbComEnd == pstPrivate->pbBufrEnd) ?
        pstPrivate->pbBufrStart : pstPrivate->pbComEnd;
    pstPrivate->pbComEnd = (pstPrivate->pbReadEnd >= pstPrivate->pbComStart) ?
        pstPrivate->pbReadEnd : pstPrivate->pbBufrEnd;
    DBG_READ("DBG_READ: Refill ComStart==%x, ComEnd==%x (ReadEnd==%x)\r\n",
        pstPrivate->pbComStart, pstPrivate->pbComEnd,
        pstPrivate->pbReadEnd, 0,0);
    if (pstPrivate->fBufrFull)
        {
        DBG_READ("DBG_READ: Refill Signalling EVENT_READ\r\n", 0,0,0,0,0);
        SetEvent(pstPrivate->ahEvent[EVENT_READ]);
        }
    if (pstPrivate->pbComStart == pstPrivate->pbComEnd)
        {
        DBG_READ("DBG_READ: Refill setting fBufrEmpty = TRUE\r\n", 0,0,0,0,0);
        pstPrivate->fBufrEmpty = TRUE;
        ComNotify(pstPrivate->hCom, NODATA);
        }
    else
        {
        pstComCntrl = (ST_COM_CONTROL *)pstPrivate->hCom;
        pstComCntrl->puchRBData = pstPrivate->pbComStart;
        pstComCntrl->puchRBDataLimit = pstPrivate->pbComEnd;
        fRetVal = TRUE;
        }

    LeaveCriticalSection(&pstPrivate->csect);
    return fRetVal;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckRcvClear
 *
 * DESCRIPTION:
 *  Clears the receiver of all received data.
 *
 * ARGUMENTS:
 *  hCom -- a comm handle returned by an earlier call to ComCreateHandle
 *
 * RETURNS:
 *  COM_OK if data is cleared
 *  COM_DEVICE_ERROR if Windows com device driver returns an error
 *
 * AUTHOR:
 * mcc 12/26/95	(taken almost entirely from comstd.c)
 */
int WINAPI WsckRcvClear(void *pvPrivate)
    {
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
    int iRetVal = COM_OK;
    ST_COM_CONTROL *pstComCntrl = (ST_COM_CONTROL *)pstPrivate->hCom;

    EnterCriticalSection(&pstPrivate->csect);

    // Set buffer pointers to clear out any data we might have queued
    pstComCntrl->puchRBData = pstComCntrl->puchRBDataLimit =
        pstPrivate->pbBufrStart;
    pstPrivate->pbReadEnd = pstPrivate->pbBufrStart;
    pstPrivate->pbComStart = pstPrivate->pbComEnd = pstPrivate->pbBufrStart;

    LeaveCriticalSection(&pstPrivate->csect);
    return iRetVal;
    }



//          Buffered send routines


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckSndBufrSend
 *
 * DESCRIPTION:
 *	Sends a buffer over the socket
 *
 * ARGUMENTS:
 *	pstPrivate		Driver's private data structure
 *  pvBufr			Pointer to data to send
 *	nSize			Number of bytes to send
 *
 * RETURNS:
 *	COM_OK			if successful
 *  COM_FAILED		otherwise
 *
 *
 * AUTHOR:
 * mcc 12/26/95	
 */
int WINAPI WsckSndBufrSend(void *pvPrivate, void *pvBufr, int  nSize)
    {
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
    int  iRetVal = COM_OK;
	int  iCode;

    assert(pvBufr != (void *)0);
    assert(nSize <= WSOCK_SIZE_OUTQ);

	if (pstPrivate->fSending)
		{
		DbgOutStr("SBS: Busy", 0,0,0,0,0);
		return COM_BUSY;
		}
    else if (nSize > 0)
        {
        ComNotify(pstPrivate->hCom, SEND_STARTED);
        EnterCriticalSection(&pstPrivate->csect);
		pstPrivate->pbSendBufr = pvBufr;
		pstPrivate->nSendBufrLen = nSize;
		pstPrivate->fSending = TRUE;


		LeaveCriticalSection(&pstPrivate->csect);
		
		// Tell the write thread to run
		iCode = SetEvent(pstPrivate->ahEvent[EVENT_WRITE]);
		DbgOutStr("SBS: %d bytes in buffer. SetEvent returns %d", nSize,
				iCode,0,0,0);

        }

    return iRetVal;
    }





/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckSndBufrClear
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 * AUTHOR:
 * mcc 12/26/95
 */
int WINAPI WsckSndBufrClear(void *pvPrivate)
    {
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
    int iRetVal = COM_OK;

    EnterCriticalSection(&pstPrivate->csect);
    if (WsckSndBufrIsBusy(pstPrivate))
        {
		pstPrivate->fClearSendBufr = TRUE;
        }
    LeaveCriticalSection(&pstPrivate->csect);

    return iRetVal;
    }



/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckComWriteThread
 *
 * DESCRIPTION:
 *  One of the "main" threads of the comm driver ...
 *  Waits on an "anything to write?" semaphore
 *  When awakened, writes the write buffer in the driver data structure
 *  to the comm port and resets the semaphore
 *
 * ARGUMENTS
 *  pvData		Address of driver data structure
 *
 *
 * RETURNS:
 *  Nothing
 *
 * AUTHOR
 *	mcc 12/27/95 (stolen from Northport)
 */
DWORD  WINAPI WsckComWriteThread(void *pvData)
	{
	ST_STDCOM		*pstPrivate =  (ST_STDCOM *)pvData;
	int				nBytesWritten;
	unsigned		uSize, nBytesToSend, nBytesSent;
	int				fRunning = TRUE;
	DWORD			iResult = COM_OK;
	char			*pchData;
	int				iCode;



	DBG_THREAD("DBG_THREAD: ComWriteThread starting",0,0,0,0,0);

	// Initialize the "Something to write" semaphore to Reset, so that
	// we will wait for SndBufrSend to hand something to us
	if (! ResetEvent(pstPrivate->ahEvent[EVENT_WRITE]))
		{
		assert(0);
		}

	while (fRunning)
		{
		// Wait on a semaphore for something to write
		iCode = WaitForSingleObject(pstPrivate->ahEvent[EVENT_WRITE],
			(unsigned long) 60000);

		DBG_WRITE("WrThread: Got EVENT_WRITE %d\n", iCode,0,0,0,0);

		// Has anybody told us to shut down?
		//
		if (pstPrivate->fHaltThread)
			{
			DBG_WRITE("  WrThread: fHaltThread==TRUE, shutting down", 0,0,0,0,0);
			ExitThread(0);
			}

		else
			{
			iResult = COM_OK;
			EnterCriticalSection(&pstPrivate->csect);
			pchData = pstPrivate->pbSendBufr;
			nBytesToSend = (unsigned) pstPrivate->nSendBufrLen;

			nBytesSent = 0;
			if (nBytesToSend > 0)
				{
				DbgOutStr("WriteThrd: %d to send\n", nBytesToSend, 0,0,0,0);

				// Loop until we send all the requested data
				while ( fRunning && nBytesSent < nBytesToSend )
					{
					uSize = nBytesToSend - nBytesSent;
					LeaveCriticalSection(&pstPrivate->csect);
					assert(uSize > 0 && uSize < 32767);
					nBytesWritten = send(pstPrivate->hSocket,
						pchData,(int) uSize, 0);
					DbgOutStr("WriteThrd: %d bytes of %d sent. 1st 3 = %x %x %x\n",
							nBytesWritten, uSize, pchData[0], pchData[1], pchData[2]);

					// We have an error -- probably the connection got dropped
					// report it to the various interested parties
					if ( nBytesWritten == -1 )
						{
						iResult = (unsigned) WSAGetLastError();
						DbgOutStr("WriteThrd: error %d sending %d bytes (%d - %d). Byebye.\n",
							iResult, (int) uSize, nBytesToSend,nBytesSent,0);
						ComNotify(pstPrivate->hCom, CONNECT);
						pstPrivate->fConnected = 0;
						fRunning = 0;
						}
					nBytesSent += (unsigned) nBytesWritten;
					if (nBytesSent < nBytesToSend  )
						{
						DbgOutStr("WrtThrd: can't send all data to socket\n",
							 0,0,0,0,0);
						pchData += nBytesWritten;
						}
					}
				EnterCriticalSection(&pstPrivate->csect);
				//DbgOutStr("  WrThread: Wrote %u bytes, %lu written, ret=%lu\n",
				//uSize, nBytesWritten, 0, 0, 0);

				// We've sent the buffer, so clear the Sending flag
				pstPrivate->fSending = FALSE;

				pstPrivate->nSendBufrLen = 0;
				pstPrivate->pbSendBufr = NULL;
				pstPrivate->fClearSendBufr = FALSE;
				
				//DBG_WRITE("  WrThread: posting EVENT_SENT", 0,0,0,0,0);
				// TOCO:mcc 12/29/95 SetEvent(pstPrivate->ahEvent[EVENT_SENT]);
				}
			if (pstPrivate->fHaltThread)
				{
				DBG_WRITE("  WrThread: fHaltThread==TRUE, shutting down", 0,0,0,0,0);
				ExitThread(0);
				}
			DbgOutStr("  WrThread: setting fSending=FALSE, resetting EVENT_WRITE\n",
				0,0,0,0,0);
			if (!ResetEvent(pstPrivate->ahEvent[EVENT_WRITE]))
				{
				assert(0);
				}
			LeaveCriticalSection(&pstPrivate->csect);
			ComNotify(pstPrivate->hCom, SEND_DONE);
			}
		}

	DbgOutStr("WriteThread exiting ...", 0,0,0,0,0);
	ExitThread(0);
	return (iResult);
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckComReadThread
 *
 * DESCRIPTION:
 *  One of the main threads of the comm driver ...
 *  Reads data from the comm port as long as we have a place to put it
 *  If the buffer fills up, go to sleep until RcvRefill takes some data
 *  out of the buffer
 *
 *
 * ARGUMENTS:
 *  pvData		 address of our private data structure
 *
 * RETURNS:
 *  nothing
 *
 * AUTHOR
 *	mcc 12/27/95 (stolen from Northport)
 */
DWORD  WINAPI WsckComReadThread(void *pvData)
	{
	ST_STDCOM			*pstPrivate =  (ST_STDCOM *)pvData;
	int					fRunning = TRUE;
	int					fReading = TRUE;
	char				*pbReadFrom, *pOut;
	unsigned			nReadSize;
	long				lBytesRead, nFFs;
	int					iResult;
	int					nIndx;
	DWORD				rc;


	DBG_THREAD("DBG_THREAD: ComtcpReadThread starting",0,0,0,0,0);
	EnterCriticalSection(&pstPrivate->csect);

	// Set Read event to reset so we don't read until the connection is up
	// By setting fBufrFull TRUE, the thread will think it is being
	// reawakened from a full buffer condition when PortActivate posts the
	// semaphore
	pstPrivate->fBufrFull = TRUE;
	ResetEvent(pstPrivate->ahEvent[EVENT_READ]);
	LeaveCriticalSection(&pstPrivate->csect);

	pstPrivate->fSeenFF = 0;
	while ( fRunning )
		{

		// Wait for a wakeup call if we put ourself to sleep
		//DbgOutStr("ReadThread: Waiting for EVENT_READ", 0,0,0,0,0);
		rc = WaitForSingleObject(pstPrivate->ahEvent[EVENT_READ], 60000);
		if ( rc != 0 )
			{
			DbgOutStr("ReadThread: EVENT_READ timed out. fBufFull=%d",
				pstPrivate->fBufrFull,0,0,0,0);
			}
		else
			{
			//DbgOutStr("ReadThread: Got EVENT_READ.", 0,0,0,0,0);
			}

		// To get this thread to exit, the deactivate routine forces a
		// fake com event by posting EVENT_READ
		if (pstPrivate->fHaltThread)
			{
			DBG_THREAD("DBG_THREAD: Comtcp exiting thread",0,0,0,0,0);
			fRunning = FALSE;
			}
		else
			{
			EnterCriticalSection(&pstPrivate->csect);
			if (pstPrivate->fBufrFull)
				{
				//DbgOutStr("ReadThread: fBufrFull = FALSE", 0,0,0,0,0);
				pstPrivate->fBufrFull = FALSE;
				fReading = TRUE;
				}
			LeaveCriticalSection(&pstPrivate->csect);

			// Do reads until we fill the buffer
			while (fReading && fRunning)
				{
				// Check for wrap around in circular buffer
                pbReadFrom = (pstPrivate->pbReadEnd >= pstPrivate->pbBufrEnd) ?
                    pstPrivate->pbBufrStart : pstPrivate->pbReadEnd;

                nReadSize = (unsigned) (pbReadFrom < pstPrivate->pbComStart) ?
                    (unsigned) (pstPrivate->pbComStart - pbReadFrom - 1) :
                    (unsigned) (pstPrivate->pbBufrEnd - pbReadFrom);

                if (nReadSize > WSOCK_MAX_READSIZE)
                    nReadSize = WSOCK_MAX_READSIZE;

                if (!nReadSize)
                    {
                    DBG_READ("Read Thread -- fBufrFull = TRUE, unsignalling EVENT_READ\r\n",
                        0,0,0,0,0);
                    pstPrivate->fBufrFull = TRUE;
                    ResetEvent(pstPrivate->ahEvent[EVENT_READ]);
                    break;
                    }
                else
                    {
					DBG_READ("ReadThread posting a recv\n", 0,0,0,0,0);
					lBytesRead = recv(pstPrivate->hSocket, pbReadFrom,
													  (int)nReadSize, 0);
                    if (lBytesRead > 0)
                        {
                        pstPrivate->pbReadEnd += lBytesRead;

                        if (pstPrivate->pbReadEnd >= pstPrivate->pbBufrEnd)
                            pstPrivate->pbReadEnd = pstPrivate->pbBufrStart;

                        DBG_READ("DBG_READ: Thread -- recv completed synchronously,"
                            " lBytesRead==%ld, ReadEnd==%x\r\n",
                            lBytesRead, pstPrivate->pbReadEnd,0,0,0);

                        if (pstPrivate->fBufrEmpty)
                            {
                            DBG_READ("DBG_READ: Thread -- fBufrEmpty = FALSE\r\n", 0,0,0,0,0);
                            pstPrivate->fBufrEmpty = FALSE;
                            ComNotify(pstPrivate->hCom, DATA_RECEIVED);
                            }

						if (pstPrivate->fEscapeFF)
							{
							// The sender escaped FF characters by doubling
							// them.  Copy the received data buffer onto itself,
							// skipping every other FF
							pOut = pbReadFrom;
							nFFs = 0;
							for (nIndx = 0; nIndx < lBytesRead; nIndx += 1)
								{
								if (pstPrivate->fSeenFF)
									{
									if (pbReadFrom[nIndx] == 0xFF)
										{
										// Skip this one
										nFFs++;
										}
									else
										{
										// This should not happen, but copy
										// anyway
										*pOut = pbReadFrom[nIndx];
										pOut++;
										}
									pstPrivate->fSeenFF = FALSE;
									}
								else
									{
									// Test to see if this is an FF; copy
									// input to output.
									if (pbReadFrom[nIndx] == 0xFF)
										{
										pstPrivate->fSeenFF = TRUE;
										}
									*pOut = pbReadFrom[nIndx];
									pOut++;
									}
								}
							// Decrement the number of bytes read by the
							// number of duplicate FF's we tossed.
							lBytesRead -= nFFs;
							}

						// Notify application that we got some data
						// if buffer had been empty
						EnterCriticalSection(&pstPrivate->csect);
						if (pstPrivate->fBufrEmpty)
							{
							DBG_READ("DBG_READ: Thread -- fBufrEmpty = FALSE", 0,0,0,0,0);
							pstPrivate->fBufrEmpty = FALSE;
							}
						LeaveCriticalSection(&pstPrivate->csect);
						ComNotify(pstPrivate->hCom, DATA_RECEIVED);

						}
					else
						{

						// 0 value from recv indicates that the connection is closed;
						// -1 indicates another error.  Notify CNCT driver.
						// (re-set the connection status
						// if the error code indicates that the connection is down)
						iResult = WSAGetLastError();
						DbgOutStr("ReadThread: Got no data, err=%d", iResult, 0,0,0,0);
						EnterCriticalSection(&pstPrivate->csect);
						if ( lBytesRead == 0 ||
							iResult == WSAENETDOWN ||
							iResult == WSAENOTCONN ||
							iResult == WSAEHOSTDOWN ||
							iResult == WSAETIMEDOUT)
							{
							// Wait until we are told to shut down; don't try to read
							// anymore!
							ResetEvent(pstPrivate->ahEvent[EVENT_READ]);
							pstPrivate->fConnected = 0;
							}

						LeaveCriticalSection(&pstPrivate->csect);
						ComNotify(pstPrivate->hCom, DATA_RECEIVED);

						}

					}


				if (pstPrivate->fHaltThread)
					{
					DBG_THREAD("DBG_THREAD: Comtcp exiting thread",0,0,0,0,0);
					fRunning = FALSE;
					}
				}  // end of fReading && fRunning
			}

		}  // end of fRunning loop

	EnterCriticalSection(&pstPrivate->csect);
	pstPrivate->hComReadThread = 0;
	LeaveCriticalSection(&pstPrivate->csect);
	DbgOutStr("ReadThread exiting ...", 0,0,0,0,0);
	ExitThread(0);

	return(0);
	}
	
	
/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	wsckResolveAddress
 *
 * DESCRIPTION:
 *	Takes a numeric or symbolic net address string and returns
 *  a valid binary internet address.
 *
 * ARGUMENTS:
 *  pszRemote		The remote system's address as a string
 *  pulAddr			Pointer to binary internet address
 *
 * RETURNS:
 *  COM_OK			If successful
 *	COM_NOT_FOUND	If the address is invalid
 *
 * AUTHOR
 *	mcc 01/09/96 (stolen from Northport)
 */
int wsckResolveAddress(TCHAR *pszRemote, unsigned long *pulAddr)
	{
	int				iRetVal = COM_NOT_FOUND;
	struct hostent  *pstHost;

	assert(pszRemote);
	assert(pulAddr);
	
	if (pszRemote && pulAddr)
		{

		// Convert pszRemote to an internet address.  If not successful,
		// assume that the string is a host NAME and try to turn
		// that into an address
		*pulAddr = inet_addr(pszRemote);
		if ((*pulAddr == INADDR_NONE) || (*pulAddr == 0))
			{
			// If not a valid network address, it should be a name, so
			// look that up (in the hosts file or via a name server)
			pstHost = gethostbyname(pszRemote);
			if ( pstHost)
				*pulAddr = *((unsigned long *)pstHost->h_addr);
			}
		if ((*pulAddr != INADDR_NONE) && (*pulAddr != 0))
			iRetVal = COM_OK;
		else
			iRetVal = COM_NOT_FOUND;
		}

	return iRetVal;
	}


#endif // MULTITHREAD
#endif // INCL_WINSOCK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\autoinit.c ===
/*	File: D:\WACKER\emu\autoinit.c (Created: 28-Feb-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:28p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\cloop.h>
#include <tdll\assert.h>
#include <tdll\mc.h>
#include <tdll\backscrl.h>

#include "emu.h"
#include "emu.hh"
#include "emuid.h"
#include "ansi.hh"
#include "viewdata.hh"
#include "minitel.hh"
#include "keytbls.h"


static void emuAutoNothingVT52(const HHEMU hhEmu);
static void emuAutoVT52toAnsi(const HHEMU hhEmu);
static void emuAutoAnsiEdVT52(const HHEMU hhEmu);
static void emuAutoAnsiElVT52(const HHEMU hhEmu);
static void emuAutoCharPnVT52(const HHEMU hhEmu);
static void emuAutoNothingVT100(const HHEMU hhEmu);
static void emuAutoScs1VT100(const HHEMU hhEmu);
static void emuAutoSaveCursorVT100(const HHEMU hhEmu);
static void emuAutoAnsiPnEndVT100(const HHEMU hhEmu);
static void emuAutoResetVT100(const HHEMU hhEmu);
static void emuAutoAnsiDaVT100(const HHEMU hhEmu);
static void emuAutoReportVT100(const HHEMU hhEmu);
static void emuAutoNothingViewdata(const HHEMU hhEmu);
static void emuAutoSetAttrViewdata(const HHEMU hhEmu);
static void emuAutoNothingAnsi(const HHEMU hhEmu);
static void emuAutoScrollAnsi(const HHEMU hhEmu);
static void emuAutoSaveCurAnsi(const HHEMU hhEmu);
static void emuAutoPnAnsi(const HHEMU hhEmu);
static void emuAutoDoorwayAnsi(const HHEMU hhEmu);
static void emuAutoNothingMinitel(const HHEMU hhEmu);
static void emuAutoMinitelCharAttr(const HHEMU hhEmu);
static void emuAutoMinitelFieldAttr(const HHEMU hhEmu);
static void emuAutoMinitelCursorReport(const HHEMU hhEmu);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuAutoInit
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *	 nothing
 */
void emuAutoInit(const HHEMU hhEmu)
	{
	PSTANSIPRIVATE pstPRI;

	static struct trans_entry const astfAutoAnsiTable[] =
		{
		// State 0
		//
		// Ansi emulation occupies all of state 0 codes.
		//
		{NEW_STATE, 0, 0, 0},
#if !defined(FAR_EAST)
		{0, ETEXT('\x20'),	ETEXT('\xFF'),	emuStdGraphic}, 	// Space - All
#else
		{0, ETEXT('\x20'),	0xFFFF,			emuStdGraphic}, 	// Space - All
#endif
		{1, ETEXT('\x1B'),	ETEXT('\x1B'),	nothing},			// Esc
		{0, ETEXT('\x05'),	ETEXT('\x05'),	vt100_answerback},	// Ctrl-E
		{0, ETEXT('\x07'),	ETEXT('\x07'),	emu_bell},			// Ctrl-G
		{0, ETEXT('\x08'),	ETEXT('\x08'),	backspace}, 		// Backspace
		{0, ETEXT('\x09'),	ETEXT('\x09'),	tabn},				// Tab
		{0, ETEXT('\x0A'),	ETEXT('\x0B'),	emuLineFeed},		// NL - VT
		{0, ETEXT('\x0C'),	ETEXT('\x0C'),	AnsiFormFeed},		// Form Feed
		{0, ETEXT('\x0D'),	ETEXT('\x0D'),	carriagereturn},	// CR
		{3, ETEXT('\x18'),	ETEXT('\x18'),	EmuStdChkZmdm}, 	// Ctrl-X
		{0, ETEXT('\x00'),	ETEXT('\x1F'),	emuStdGraphic}, 	// All Ctrl's
		//
		// State 1
		// At this point, an ESC has been seen.
		//
		{NEW_STATE, 0, 0, 0},										// Esc
		{2, ETEXT('\x5B'),	ETEXT('\x5B'),	ANSI_Pn_Clr},			// [
		{0, ETEXT('\x44'),	ETEXT('\x44'),	ANSI_IND},				// D
		{0, ETEXT('\x45'),	ETEXT('\x45'),	ANSI_NEL},				// E
		{0, ETEXT('\x48'),	ETEXT('\x48'),	ANSI_HTS},				// H
		{0, ETEXT('\x4D'),	ETEXT('\x4D'),	ANSI_RI},				// M
		//
		// Autodetect sequences for for VT52, State 1.
		//
		{2, ETEXT('\x59'),	ETEXT('\x59'),	emuAutoNothingVT52},	// Y
		{0, ETEXT('\x3C'),	ETEXT('\x3C'),	emuAutoVT52toAnsi}, 	// <
		{0, ETEXT('\x4A'),	ETEXT('\x4A'),	emuAutoAnsiEdVT52}, 	// J
		{0, ETEXT('\x4B'),	ETEXT('\x4B'),	emuAutoAnsiElVT52}, 	// K
		//
		// Autodetect sequences for for VT100, State 1.
		//
#if !defined(INCL_MINITEL)
		{3, ETEXT('\x23'),	ETEXT('\x23'),	emuAutoNothingVT100},	// #
#endif
		{4, ETEXT('\x28'),	ETEXT('\x29'),	emuAutoScs1VT100},		// ( - )
		{0, ETEXT('\x38'),	ETEXT('\x38'),	emuAutoSaveCursorVT100},// 8
#if !defined(INCL_MINITEL)
		{1, ETEXT('\x3B'),	ETEXT('\x3B'),	emuAutoAnsiPnEndVT100}, // ;
#endif
		{0, ETEXT('\x63'),	ETEXT('\x63'),	emuAutoResetVT100}, 	// c
		//
		// Autodetect sequences for for Viewdata, State 1.
		//
#if defined(INCL_VIEWDATA)
		{0, ETEXT('\x31'),	ETEXT('\x34'),	emuAutoNothingViewdata},// 1 - 4
#endif
		//
		// Autodetect sequences for for Minitel, State 1.
		//
#if defined(INCL_MINITEL)
		//{1, ETEXT('\x00'),  ETEXT('\x00'),  emuAutoNothingMinitel},
		//{14,ETEXT('\x25'),  ETEXT('\x25'),  emuAutoNothingMinitel},
		//{13,ETEXT('\x35'),  ETEXT('\x37'),  emuAutoNothingMinitel},	  // eat ESC,35-37,X sequences
		//{6, ETEXT('\x39'),  ETEXT('\x39'),  emuAutoNothingMinitel},	  // PROT1, p134
		{7, ETEXT('\x3A'),	ETEXT('\x3A'),	emuAutoNothingMinitel}, 	// PROT2, p134
		{0, ETEXT('\x40'),	ETEXT('\x43'),	emuAutoMinitelCharAttr},	// forground color, flashing
		//{0, ETEXT('\x4C'),  ETEXT('\x4C'),  emuAutoMinitelCharAttr},	  // char width & height
		//{0, ETEXT('\x4E'),  ETEXT('\x4E'),  emuAutoMinitelCharAttr},	  // char width & height
		//{0, ETEXT('\x4F'),  ETEXT('\x4F'),  emuAutoMinitelCharAttr},	  // char width & height
		//{0, ETEXT('\x50'),  ETEXT('\x59'),  emuAutoMinitelFieldAttr},   // background, underlining
		//{0, ETEXT('\x5F'),  ETEXT('\x5F'),  emuAutoMinitelFieldAttr},   // reveal display
		//{0, ETEXT('\x5C'),  ETEXT('\x5D'),  emuAutoMinitelCharAttr},	  // inverse
		//{0, ETEXT('\x61'),  ETEXT('\x61'),  emuAutoMinitelCursorReport},
#endif
		//
		// State 2
		//
		{NEW_STATE, 0, 0, 0},										// Esc[
		{2, ETEXT('\x30'),	ETEXT('\x39'),	ANSI_Pn},				// 0 - 9
		{2, ETEXT('\x3B'),	ETEXT('\x3B'),	ANSI_Pn_End},			// ;
		{5, ETEXT('\x3D'),	ETEXT('\x3D'),	nothing},				// =
		{2, ETEXT('\x3A'),	ETEXT('\x3F'),	ANSI_Pn},				// : - ?
		{0, ETEXT('\x41'),	ETEXT('\x41'),	ANSI_CUU},				// A
		{0, ETEXT('\x42'),	ETEXT('\x42'),	ANSI_CUD},				// B
		{0, ETEXT('\x43'),	ETEXT('\x43'),	ANSI_CUF},				// C
		{0, ETEXT('\x44'),	ETEXT('\x44'),	ANSI_CUB},				// D
		{0, ETEXT('\x48'),	ETEXT('\x48'),	ANSI_CUP},				// H
		{0, ETEXT('\x4A'),	ETEXT('\x4A'),	ANSI_ED},				// J
		{0, ETEXT('\x4B'),	ETEXT('\x4B'),	ANSI_EL},				// K
		{0, ETEXT('\x4C'),	ETEXT('\x4C'),	ANSI_IL},				// L
		{0, ETEXT('\x4D'),	ETEXT('\x4D'),	ANSI_DL},				// M
		{0, ETEXT('\x50'),	ETEXT('\x50'),	ANSI_DCH},				// P
		{0, ETEXT('\x66'),	ETEXT('\x66'),	ANSI_CUP},				// f
		{0, ETEXT('\x67'),	ETEXT('\x67'),	ANSI_TBC},				// g
		{0, ETEXT('\x68'),	ETEXT('\x68'),	ansi_setmode},			// h
		{0, ETEXT('\x69'),	ETEXT('\x69'),	vt100PrintCommands},	// i
		{0, ETEXT('\x6C'),	ETEXT('\x6C'),	ansi_resetmode},		// l
		{0, ETEXT('\x6D'),	ETEXT('\x6D'),	ANSI_SGR},				// m
		{0, ETEXT('\x6E'),	ETEXT('\x6E'),	ANSI_DSR},				// n
		{0, ETEXT('\x70'),	ETEXT('\x70'),	emuAutoNothingAnsi},	// p
		{0, ETEXT('\x72'),	ETEXT('\x72'),	emuAutoScrollAnsi}, 	// r
		{0, ETEXT('\x73'),	ETEXT('\x73'),	emuAutoSaveCurAnsi},	// s
		{0, ETEXT('\x75'),	ETEXT('\x75'),	ansi_savecursor},		// u
		//
		//Autodetect sequences for for VT52, State 2.
		//
		{3, ETEXT('\x20'),	ETEXT('\x20'),	emuAutoCharPnVT52}, 	// Space 
		{3, ETEXT('\x22'),	ETEXT('\x22'),	emuAutoCharPnVT52}, 	// "
		{3, ETEXT('\x24'),	ETEXT('\x2F'),	emuAutoCharPnVT52}, 	// $ - /
		//
		// Autodetect sequences for for VT100, State 2.
		//
		{0, ETEXT('\x63'),	ETEXT('\x63'),	emuAutoAnsiDaVT100},	// c
		{0, ETEXT('\x71'),	ETEXT('\x71'),	emuAutoNothingVT100},	// q
		{0, ETEXT('\x78'),	ETEXT('\x78'),	emuAutoReportVT100},	// x
		//
		// State 3
		//
		{NEW_STATE, 0, 0, 0},
		{3, ETEXT('\x00'),	ETEXT('\xFF'),	EmuStdChkZmdm}, 		// All
		//
		// State 4
		//
		{NEW_STATE, 0, 0, 0},
		{4, ETEXT('\x00'),	ETEXT('\xFF'),	nothing},				// All
		//
		// State 5
		//
		{NEW_STATE, 0, 0, 0},
		{5, ETEXT('\x32'),	ETEXT('\x32'),	emuAutoPnAnsi}, 		// 2
		{5, ETEXT('\x35'),	ETEXT('\x35'),	emuAutoPnAnsi}, 		// 5
		{0, ETEXT('\x68'),	ETEXT('\x68'),	emuAutoDoorwayAnsi},	// h
		{0, ETEXT('\x6C'),	ETEXT('\x6C'),	emuAutoDoorwayAnsi},	// l
		//
		// Autodetect sequences for for VT100, State 5.
		//
		{0, ETEXT('\x70'),	ETEXT('\x70'),	emuAutoNothingVT100},	// p
		//
		// Autodetect sequences for for VT52, State 5.
		//
		{0, ETEXT('\x00'),	ETEXT('\xFF'),	EmuStdChkZmdm}, 		// All
		//
		// State 6
		//
		{NEW_STATE, 0, 0, 0},
		//
		// Autodetect sequences for for VT52, VT100, State 6.
		//
		{6, ETEXT('\x00'),	ETEXT('\xFF'),	nothing},				// All
		//
		// State 7
		//
		// Autodetect sequences for for VT100, State 7.
		//
		{NEW_STATE, 0, 0, 0},
		{7, ETEXT('\x00'),	ETEXT('\xFF'),	EmuStdChkZmdm}, 		// All
		//
		// State 8
		//
		// Autodetect sequences for for VT100, State 8.
		//
		{NEW_STATE, 0, 0, 0},
		{8, ETEXT('\x00'),	ETEXT('\xFF'),	nothing},				// All
		};

	emuInstallStateTable(hhEmu, astfAutoAnsiTable, DIM(astfAutoAnsiTable));

	// Allocate space for and initialize data that is used only by the
	// Auto ANSI emulator.
	//
	hhEmu->pvPrivate = malloc(sizeof(ANSIPRIVATE));

	if (hhEmu->pvPrivate == 0)
		{
		assert(FALSE);
		return;
		}

	pstPRI = (PSTANSIPRIVATE)hhEmu->pvPrivate;

	memset(pstPRI, 0, sizeof(ANSIPRIVATE));

	hhEmu->emuResetTerminal = emuAnsiReset;

	// The Auto Detect emulator is ANSI based.	So, do the same
	// stuff we do when initializing the ANSI emulator.
	//
	emuKeyTableLoad(hhEmu, AnsiKeyTable, 
					 sizeof(AnsiKeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl);
	emuKeyTableLoad(hhEmu, IBMPCKeyTable, 
					 sizeof(IBMPCKeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl2);

	hhEmu->emu_kbdin = ansi_kbdin;
	hhEmu->emu_deinstall = emuAnsiUnload;
	emuAnsiReset(hhEmu, FALSE);
#if !defined(FAR_EAST)
	hhEmu->emu_highchar = (ECHAR)0xFF;
#else
	hhEmu->emu_highchar = (ECHAR)0xFFFF;
#endif

	backscrlSetShowFlag(sessQueryBackscrlHdl(hhEmu->hSession), TRUE);
	return;
	}

// Ansi Auto Detect Functions.
//
void emuAutoNothingAnsi(const HHEMU hhEmu)
	{
#if !defined(FAR_EAST)
	emuAutoDetectLoad(hhEmu, EMU_ANSI);
#else
	emuAutoDetectLoad(hhEmu, EMU_ANSIW);
#endif
	nothing(hhEmu);
	return;
	}

void emuAutoScrollAnsi(const HHEMU hhEmu)
	{
#if !defined(FAR_EAST)
	emuAutoDetectLoad(hhEmu, EMU_ANSI);
#else
	emuAutoDetectLoad(hhEmu, EMU_ANSIW);
#endif
	vt_scrollrgn(hhEmu);
	return;
	}

void emuAutoSaveCurAnsi(const HHEMU hhEmu)
	{
#if !defined(FAR_EAST)
	emuAutoDetectLoad(hhEmu, EMU_ANSI);
#else
	emuAutoDetectLoad(hhEmu, EMU_ANSIW);
#endif
	ansi_savecursor(hhEmu);
	return;
	}

void emuAutoPnAnsi(const HHEMU hhEmu)
	{
#if !defined(FAR_EAST)
	emuAutoDetectLoad(hhEmu, EMU_ANSI);
#else
	emuAutoDetectLoad(hhEmu, EMU_ANSIW);
#endif
	ANSI_Pn(hhEmu);
	return;
	}

void emuAutoDoorwayAnsi(const HHEMU hhEmu)
	{
#if !defined(FAR_EAST)
	emuAutoDetectLoad(hhEmu, EMU_ANSI);
#else
	emuAutoDetectLoad(hhEmu, EMU_ANSIW);
#endif
	DoorwayMode(hhEmu);
	return;
	}

// VT52 Auto Detect Functions.
//
void emuAutoNothingVT52(const HHEMU hhEmu)
	{
	emuAutoDetectLoad(hhEmu, EMU_VT52);
	return;
	}

void emuAutoVT52toAnsi(const HHEMU hhEmu)
	{
	emuAutoDetectLoad(hhEmu, EMU_VT52);
	vt52_toANSI(hhEmu);
	return;
	}

void emuAutoAnsiEdVT52(const HHEMU hhEmu)
	{
	emuAutoDetectLoad(hhEmu, EMU_VT52);
	ANSI_ED(hhEmu);
	return;
	}

void emuAutoAnsiElVT52(const HHEMU hhEmu)
	{
	emuAutoDetectLoad(hhEmu, EMU_VT52);
	ANSI_EL(hhEmu);
	return;
	}

void emuAutoCharPnVT52(const HHEMU hhEmu)
	{
	emuAutoDetectLoad(hhEmu, EMU_VT52);
	char_pn(hhEmu);
	return;
	}

// VT100 Auto Detect Functions.
//
void emuAutoNothingVT100(const HHEMU hhEmu)
	{
#if !defined(FAR_EAST)
	emuAutoDetectLoad(hhEmu, EMU_VT100);
#else
	emuAutoDetectLoad(hhEmu, EMU_VT100J);
#endif
	return;
	}

void emuAutoScs1VT100(const HHEMU hhEmu)
	{
#if !defined(FAR_EAST)
	emuAutoDetectLoad(hhEmu, EMU_VT100);
#else
	emuAutoDetectLoad(hhEmu, EMU_VT100J);
#endif
	vt_scs1(hhEmu);
	return;
	}

void emuAutoSaveCursorVT100(const HHEMU hhEmu)
	{
#if !defined(FAR_EAST)
	emuAutoDetectLoad(hhEmu, EMU_VT100);
#else
	emuAutoDetectLoad(hhEmu, EMU_VT100J);
#endif
	vt100_savecursor(hhEmu);
	return;
	}

void emuAutoAnsiPnEndVT100(const HHEMU hhEmu)
	{
#if !defined(FAR_EAST)
	emuAutoDetectLoad(hhEmu, EMU_VT100);
#else
	emuAutoDetectLoad(hhEmu, EMU_VT100J);
#endif
	ANSI_Pn_End(hhEmu);
	return;
	}

void emuAutoResetVT100(const HHEMU hhEmu)
	{
#if !defined(FAR_EAST)
	emuAutoDetectLoad(hhEmu, EMU_VT100);
#else
	emuAutoDetectLoad(hhEmu, EMU_VT100J);
#endif
	vt100_hostreset(hhEmu);
	return;
	}

void emuAutoAnsiDaVT100(const HHEMU hhEmu)
	{
#if !defined(FAR_EAST)
	emuAutoDetectLoad(hhEmu, EMU_VT100);
#else
	emuAutoDetectLoad(hhEmu, EMU_VT100J);
#endif
	ANSI_DA(hhEmu);
	return;
	}

void emuAutoReportVT100(const HHEMU hhEmu)
	{
#if !defined(FAR_EAST)
	emuAutoDetectLoad(hhEmu, EMU_VT100);
#else
	emuAutoDetectLoad(hhEmu, EMU_VT100J);
#endif
	vt100_report(hhEmu);
	return;
	}

#if defined(INCL_VIEWDATA)
// Viewdata Auto Detect Functions.
//
void emuAutoNothingViewdata(const HHEMU hhEmu)
	{
	emuAutoDetectLoad(hhEmu, EMU_VIEW);
	return;
	}

void emuAutoSetAttrViewdata(const HHEMU hhEmu)
	{
	emuAutoDetectLoad(hhEmu, EMU_VIEW);
	EmuViewdataSetAttr(hhEmu);
	return;
	}
#endif // INCL_VIEWDATA

#if defined(INCL_MINITEL)

void emuAutoNothingMinitel(const HHEMU hhEmu)
	{
	emuAutoDetectLoad(hhEmu, EMU_MINI);
	return;
	}

void emuAutoMinitelCharAttr(const HHEMU hhEmu)
	{
	emuAutoDetectLoad(hhEmu, EMU_MINI);
	emuMinitelCharAttr(hhEmu);
	return;
	}

void emuAutoMinitelFieldAttr(const HHEMU hhEmu)
	{
	emuAutoDetectLoad(hhEmu, EMU_MINI);
	emuMinitelFieldAttr(hhEmu);
	return;
	}

void emuAutoMinitelCursorReport(const HHEMU hhEmu)
	{
	emuAutoDetectLoad(hhEmu, EMU_MINI);
	minitelCursorReport(hhEmu);
	return;
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\emu.c ===
/*	File: D:\WACKER7\emu\emu.c (Created: 08-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *  $Revision: 8 $
 *  $Date: 4/11/01 5:39p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\tdll.h>
#include <tdll\assert.h>
#include <tdll\mc.h>
#include <tdll\com.h>
#include <tdll\cloop.h>
#include <tdll\capture.h>
#include <tdll\session.h>
#include <tdll\load_res.h>
#include <tdll\globals.h>
#include <tdll\print.h>
#include <tdll\statusbr.h>
#include <tdll\htchar.h>
#include <search.h>
#include <tdll\update.h>
#include <term\res.h>

#include "emu.h"
#include "emu.hh"
#include "emuid.h"

#if defined(INCL_VTUTF8)
extern BOOL DoUTF8;
#endif

static int FFstrlen(const BYTE *);
int _cdecl KeyCmp(const void *, const void *);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	char_pn
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void char_pn(const HHEMU hhEmu) 	 /* interpret a character as a numeric param */
	{
	if (hhEmu->emu_code < ETEXT(' '))
		hhEmu->emu_code = ETEXT(' ');

	hhEmu->selector[hhEmu->selector_cnt] =
	hhEmu->num_param[hhEmu->num_param_cnt] = hhEmu->emu_code - ETEXT(' ') + 1;

	hhEmu->num_param[++hhEmu->num_param_cnt] = 0;

	hhEmu->selector[++hhEmu->selector_cnt] = 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	commanderror
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void commanderror(const HHEMU hhEmu)
	{
	hhEmu->state = 0;
	ANSI_Pn_Clr(hhEmu);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuAutoDetectLoad
 *
 * DESCRIPTION:
 *	if auto dection is on, loads the given emulator ID and sets auto
 *	detection off.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle
 *	EmuID	- id of emulator to load
 *
 * RETURNS:
 *	void
 *
 */
void emuAutoDetectLoad(const HHEMU hhEmu, const int nEmuID)
	{
	if (hhEmu->stUserSettings.nEmuId != EMU_AUTO)
		return;

	if (hhEmu->stUserSettings.nEmuId != nEmuID)
		{
		emuLock((HEMU)hhEmu);
		hhEmu->stUserSettings.nAutoAttempts = 0;
#ifdef INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID
        // Load the default telnet terminal id for this emulator. - cab:11/18/96
        //
        emuQueryDefaultTelnetId(nEmuID, hhEmu->stUserSettings.acTelnetId,
            EMU_MAX_TELNETID);
#endif
		emuUnlock((HEMU)hhEmu);

		emuLoad((HEMU)hhEmu, nEmuID);
		}
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuStdGraphic
 *
 * DESCRIPTION:
 *	This function is called to display the normal range of characters
 *	for the emulators.	It handles insertion modes, end of line wrapping,
 *	and cursor positioning.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void emuStdGraphic(const HHEMU hhEmu)
	{
	ECHAR ccode;
	ECHAR echBuf[10];
	int iCharsToMove;

	int 	iRow = hhEmu->emu_currow;
	int 	iCol = hhEmu->emu_curcol;

	ECHAR	*tp = hhEmu->emu_apText[hhEmu->emu_imgrow];
	PSTATTR ap = hhEmu->emu_apAttr[hhEmu->emu_imgrow];

	ccode = hhEmu->emu_code;

	// Is the emulator in insert mode?
	//
	if (hhEmu->mode_IRM == SET)
		{
		iCharsToMove = hhEmu->emu_aiEnd[hhEmu->emu_imgrow] - iCol;

		if (iCharsToMove + iCol >= hhEmu->emu_maxcol)
			iCharsToMove -= 1;

		if (iCharsToMove > 0)
			{
			memmove(&tp[iCol+1], &tp[iCol], (unsigned)iCharsToMove * sizeof(ECHAR));
			memmove(&ap[iCol+1], &ap[iCol], (unsigned)iCharsToMove * sizeof(ECHAR));
			hhEmu->emu_aiEnd[hhEmu->emu_imgrow] =
				min(hhEmu->emu_aiEnd[hhEmu->emu_imgrow] + 1,
					hhEmu->emu_maxcol - 1);
			}
		}

	// Our competetor's are eating the NULL's.	DOS ANSI doesn't.
	// For now we'll try it their way... - mrw
	//
	if (ccode == (ECHAR)0)
		return;

	// Place the character and the current attribute into the image.
	//
	if ((hhEmu->stUserSettings.nEmuId == EMU_VT100) &&
			ccode < sizeof(hhEmu->dspchar))
			ccode = hhEmu->dspchar[ccode];

	tp[iCol] = ccode;
	ap[iCol] = hhEmu->emu_charattr;

#if !defined(CHAR_NARROW)
	
	if ((hhEmu->stUserSettings.nEmuId == EMU_AUTO) ||
		(hhEmu->stUserSettings.nEmuId == EMU_ANSIW))
		{
		// Process Double Byte Characters
		//		
		if (QueryCLoopMBCSState(sessQueryCLoopHdl(hhEmu->hSession)))
			{
			if (isDBCSChar(ccode))
				{
				int iColPrev = iCol;

				ap[iCol].wilf = 1;
				ap[iCol].wirt = 0;

				// Update the end of row index if necessary.
				//
				if (iCol > hhEmu->emu_aiEnd[hhEmu->emu_imgrow])
					hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = iCol;

				// Update the image.
				//
				updateChar(sessQueryUpdateHdl(hhEmu->hSession),
							iRow,
							iCol,
							hhEmu->mode_IRM ?
							hhEmu->emu_maxcol :
							hhEmu->emu_aiEnd[hhEmu->emu_imgrow]);

				iCol = min(iCol+1, hhEmu->emu_maxcol);

				tp[iCol] = ccode;
				ap[iCol] = ap[iColPrev];
				ap[iCol].wilf = 0;
				ap[iCol].wirt = 1;
				}
			}

#if 0
        //mpt:1-23-98 handles the case when an incoming character
        //            (single or double byte) overwrites the first half of
        //            a double byte character
	    if ( iCol < hhEmu->emu_maxcol )
		    {
		    //if we orphaned a right half of a dbcs char
		    if (hhEmu->emu_apAttr[iRow][iCol + 1].wirt == TRUE)
			    {
			    //slide characters and attribs to left
			    iCharsToMove = hhEmu->emu_aiEnd[hhEmu->emu_imgrow] - iCol + 1;
			    if (iCol + 2 < hhEmu->emu_maxcol && iCharsToMove > 0)
				    {
				    memmove(&tp[iCol + 1],
                            &tp[iCol + 2],
                            (unsigned)iCharsToMove * sizeof(ECHAR));

				    memmove(&ap[iCol + 1],
                            &ap[iCol + 2],
                            (unsigned)iCharsToMove * sizeof(ECHAR));
				    }
			
			
				//move end of row since we removed a character
                hhEmu->emu_aiEnd[hhEmu->emu_imgrow] -= 1;

                //update the image
                updateChar(sessQueryUpdateHdl(hhEmu->hSession),
				        hhEmu->emu_imgrow,
				        hhEmu->emu_aiEnd[hhEmu->emu_imgrow] + 1,
						hhEmu->mode_IRM ?
						hhEmu->emu_maxcol :
						hhEmu->emu_aiEnd[hhEmu->emu_imgrow] + 1);

                }	
    		}
#endif
        }
#endif //CHAR_NARROW

	// Update the end of row index if necessary.
	//
	if (iCol > hhEmu->emu_aiEnd[hhEmu->emu_imgrow])
		hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = iCol;

	// Update the image.
	//
	updateChar(sessQueryUpdateHdl(hhEmu->hSession),
				iRow,
				iCol,
				hhEmu->mode_IRM ?
				hhEmu->emu_maxcol :
				hhEmu->emu_aiEnd[hhEmu->emu_imgrow]);

	// Move the position of the cursor ahead of the last character
	// displayed, checking for end of line wrap.
	//
	iCol++;
	if (iCol > hhEmu->emu_maxcol)
		{
		if (hhEmu->mode_AWM)
			{
			// This code was added, but not enabled because we did not
			// want to introduce this without proper testing.  If line
			// wrap on capture to printer not working is reported as a
			// bug, enable this code.
			#if 0
			printEchoChar(hhEmu->hPrintEcho, ETEXT('\r'));
			printEchoChar(hhEmu->hPrintEcho, ETEXT('\n'));
			#endif
			printEchoString(hhEmu->hPrintEcho, tp, emuRowLen(hhEmu, iRow));
			CnvrtMBCStoECHAR(echBuf, sizeof(echBuf), TEXT("\r\n"),
							 StrCharGetByteCount(TEXT("\r\n")));

			printEchoString(hhEmu->hPrintEcho,
								echBuf,
								sizeof(ECHAR) * 2);

			CaptureLine(sessQueryCaptureFileHdl(hhEmu->hSession),
								CF_CAP_LINES,
								tp,
								emuRowLen(hhEmu, iRow));

			if (iRow == hhEmu->bottom_margin)
				(*hhEmu->emu_scroll)(hhEmu, 1, TRUE);
			else
				iRow += 1;

			iCol = 0;
			}
		else
			{
			iCol = hhEmu->emu_maxcol;
			}
		}

	// Finally, set the cursor position.  This wil reset emu_currow
	// and emu_curcol.
	//
	(*hhEmu->emu_setcurpos)(hhEmu, iRow, iCol);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emu_cleartabs
 *
 * DESCRIPTION:
 *	 Clears one or all tab stops.
 *
 * ARGUMENTS:
 *	 selector -- 0 clears tab at current cursor position
 *			  -- 3 clears all tabs in current line
 *
 * RETURNS:
 *	 nothing
 */
void emu_cleartabs(const HHEMU hhEmu, int selecter)
	{
	int col;

	switch (selecter)
		{
	case 0:
		hhEmu->tab_stop[hhEmu->emu_curcol] = FALSE;
		break;

	case 3:
		for (col = 0; col <= hhEmu->emu_maxcol; ++col)
			hhEmu->tab_stop[col] = FALSE;
		break;

	default:
		commanderror(hhEmu);
		break;
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuSendKeyString
 *
 * DESCRIPTION:
 *	 Sends the specified string.
 *
 * ARGUMENTS:
 *	hhEmu		- The internal emulator handle.
 *	nIndex		- Position of key in keytable array.
 *	pstKeyTbl	- Address of key strings table.

 *
 * RETURNS:
 *	 nothing
 */
void emuSendKeyString(const HHEMU hhEmu,
						const nIndex,
						const PSTKEYTABLE pstKeyTbl)
	{
	ECHAR  str[80];
	PSTKEY pstKey;
	TCHAR *pszTemp;
	
	memset(str, ETEXT('\0'), sizeof(str));

	assert(nIndex >= 0 && nIndex < pstKeyTbl->iMaxKeys);

	pstKey = pstKeyTbl->pstKeys + nIndex;

	pszTemp = pstKey->fPointer ? pstKey->u.pachKeyStr : pstKey->u.achKeyStr;
	CnvrtMBCStoECHAR(str, sizeof(str), pszTemp,
					 StrCharGetByteCount(pszTemp));

    emuSendString(
        hhEmu, 
        str, 
#if defined(INCL_VTUTF8)
        DoUTF8
         ? pstKey->uLen
         : pstKey->uLen*sizeof(ECHAR)
#else
         pstKey->uLen*sizeof(ECHAR)
#endif
       );
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuSendString
 *
 * DESCRIPTION:
 *	 Sends the specified string.
 *
 * ARGUMENTS:
 *	 str -- address of string
 *	 strlen -- length of string
 *
 * RETURNS:
 *	 nothing
 */
void emuSendString(const HHEMU hhEmu, ECHAR *str, int nLen)
	{
        TCHAR *pchMBCS = NULL;
        TCHAR *pchTemp = NULL;
        unsigned long ulSize = 0;
        unsigned int i = 0;

	// This probably allocates way to many bytes, but if the incomming
	// string is all MBC's we are safe.
	pchMBCS = malloc((unsigned long)nLen*sizeof(ECHAR));
	if (pchMBCS == NULL)
		{
		assert(FALSE);
		return;
		}
#if defined(INCL_VTUTF8)
    if (!DoUTF8) {
#endif
        ulSize = (unsigned long)CnvrtECHARtoMBCS(pchMBCS, (unsigned long)nLen*sizeof(ECHAR),
											  str, (unsigned long)nLen*sizeof(ECHAR));
#if defined(INCL_VTUTF8)
    } else {
        while (nLen > (int)ulSize) {
            pchMBCS[ulSize++] = (str[ulSize] & 0x00FF);
        }
    }
#endif
	pchTemp = pchMBCS;    

#if 0	//DEADWOOD:jkh, 12/12/1996
	// Some systems mistake something like ESC 0 D  if the codes
	// are sent in separate packets. This now sends such sequences
	// in a single socket write which should usually put them in
	// the same packet (though it doesn't guarantee to do so.

        // Loop through the # of bytes in the string
        for (i = 0 ; i < ulSize ; ++i)
                CLoopCharOut(sessQueryCLoopHdl(hhEmu->hSession), *pchTemp++);
#endif

        CLoopBufrOut(sessQueryCLoopHdl(hhEmu->hSession), pchTemp, ulSize);

        free(pchMBCS);
        pchMBCS = NULL;
        return;
        }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emu_reverse_image
 *
 * DESCRIPTION:
 *	 Reverses the foreground and background colors for the entire virtual
 *	 image.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void emu_reverse_image(const HHEMU hhEmu)
	{
	int 	nRow, nCol;
	STATTR	stOldAttr;
	PSTATTR pstAttr;

	// Set reverse screen mode for both clear and character attributes.
	//
	hhEmu->attrState[CSCLEAR_STATE].revvid =
		!hhEmu->attrState[CSCLEAR_STATE].revvid;

	hhEmu->emu_clearattr_sav =
		hhEmu->emu_clearattr = hhEmu->attrState[CSCLEAR_STATE];

	hhEmu->attrState[CS_STATE].revvid =
		!hhEmu->attrState[CS_STATE].revvid;

	hhEmu->emu_charattr = hhEmu->attrState[CS_STATE];

	for (nRow = 0; nRow < (hhEmu->emu_maxrow+1); nRow++)
		{
		pstAttr = hhEmu->emu_apAttr[nRow];

		for (nCol = 0 ; nCol <= hhEmu->emu_maxcol ; ++nCol, ++pstAttr)
			{
			stOldAttr = *pstAttr;
			pstAttr->txtclr = stOldAttr.bkclr;
			pstAttr->bkclr	= stOldAttr.txtclr;
			}
		}

	updateLine(sessQueryUpdateHdl(hhEmu->hSession), 0, hhEmu->emu_maxrow);
	NotifyClient(hhEmu->hSession, EVENT_EMU_CLRATTR, 0);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emu_is25lines
 *
 * DESCRIPTION:
 *	 Tells the calling function if the emulator is using the 25th line.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 TRUE if the emulator is using the 25th line
 */
int emu_is25lines(const HHEMU hhEmu)
	{
	return (hhEmu->mode_25enab ? TRUE : FALSE);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emu_kbdlocked
 *
 * DESCRIPTION:
 *	 Replacement kbdin that ignores all keys passed to it.
 *
 * ARGUMENTS:
 *	 key -- key to process
 *
 * RETURNS:
 *	 nothing
 */
/* ARGSUSED */
int emu_kbdlocked(const HHEMU hhEmu, int key, const int fTest)
	{
	return -1;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	nothing
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
/* ARGSUSED */
void nothing(const HHEMU hhEmu)
	{
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuKbdKeyLookup
 *
 * DESCRIPTION:
 *	Main keyboard translation routine for all emulators.  Note, this
 *	routine will not lookup keys unless the iUseTermKeys flag is set.
 *
 * ARGUMENTS:
 *	UINT	key - lower byte is char or virtual key, upper byte has flags
 *
 * RETURNS:
 *	Index if translated, else minus one.
 *
 */
int emuKbdKeyLookup(const HHEMU hhEmu,
					const int uKey,
					const PSTKEYTABLE pstKeyTbl)
	{
	PSTKEY pstKey;

	if (hhEmu->stUserSettings.nTermKeys == EMU_KEYS_ACCEL)
		return -1;

	pstKey = bsearch(&uKey,
					pstKeyTbl->pstKeys,
					(unsigned)pstKeyTbl->iMaxKeys,
					sizeof(KEY), KeyCmp);

	if (pstKey)
		return (int)(pstKey - pstKeyTbl->pstKeys);

	return -1;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuKeyTableLoad
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
/* ARGSUSED */
int emuKeyTableLoad(const HHEMU hhEmu,
					const KEYTBLSTORAGE pstKeySource[],
					const int nNumKeys,
					PSTKEYTABLE const pstKeyTbl)
	{
	int 	l;
	int 	nLoop = 0;
	PSTKEY	pstKeys;

	if (nNumKeys == 0)
		return FALSE;

	emuKeyTableFree(pstKeyTbl); // free previous instance

	if ((pstKeyTbl->pstKeys = malloc((unsigned)(nNumKeys * (int)sizeof(KEY))))
			== 0)
		{
		assert(0);
		return FALSE;
		}

	memset(pstKeyTbl->pstKeys, 0, (unsigned)(nNumKeys * (int)sizeof(KEY)));

	if (pstKeyTbl->pstKeys)
		{
		for (pstKeys = pstKeyTbl->pstKeys; nLoop < nNumKeys ; pstKeys++, nLoop++)
			{
			pstKeys->key = pstKeySource[nLoop].KeyCode;

			l = FFstrlen(pstKeySource[nLoop].achKeyStr);

			if ( l	<= (int)sizeof(LPTSTR) )
				{
				pstKeys->fPointer = FALSE;

				// Because of the goofy resource compiler, it was
				// necessary to define a "\xff" in the resource data,
				// when what we really wanted was a "\x00\xff".  So,
				// now we determine when this case occurs, and load the
				// \x00 value manually.  Note that there is an additional
				// test for this below when determining the length of the
				// the data.
				//
				if (l != 0)
					{
					MemCopy(pstKeys->u.achKeyStr, pstKeySource[nLoop].achKeyStr, (unsigned)l);
					}

				else
					{
					pstKeys->u.achKeyStr[0] = '\x00';
					}
				}
			else
				{
				pstKeys->fPointer = TRUE;
				pstKeys->u.pachKeyStr = malloc((unsigned)(l+1));

				if (!pstKeys->u.pachKeyStr)
					{
					emuKeyTableFree(pstKeyTbl);
					break;
					}

				MemCopy(pstKeys->u.pachKeyStr, pstKeySource[nLoop].achKeyStr, (unsigned)l);
				}

			// Here's the special case test, again.
			//
			if (l !=0 )
				pstKeys->uLen = (int)l;
			else
				pstKeys->uLen = 1;

			pstKeyTbl->iMaxKeys += 1;
			}
		}

	if (pstKeyTbl->iMaxKeys)
		{
		qsort(pstKeyTbl->pstKeys,
					(unsigned)pstKeyTbl->iMaxKeys,
					sizeof(KEY),
					KeyCmp);
		}

	return (int)pstKeyTbl->iMaxKeys;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuKeyTableFree
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void emuKeyTableFree(PSTKEYTABLE const pstKeyTbl)
	{
	int i;

	for (i = 0 ; i < pstKeyTbl->iMaxKeys ; i++)
		{
		if (pstKeyTbl->pstKeys[i].fPointer)
			{
			free(pstKeyTbl->pstKeys[i].u.pachKeyStr);
			pstKeyTbl->pstKeys[i].u.pachKeyStr = NULL;
			}
		}

	pstKeyTbl->iMaxKeys = 0;

	if (pstKeyTbl->pstKeys)
		{
		free(pstKeyTbl->pstKeys);
		pstKeyTbl->pstKeys = (KEY *)0;
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	FFstrlen
 *
 * DESCRIPTION:
 *	Local version of strlen that uses '\ff' as a string terminator
 *
 * ARGUMENTS:
 *	CHAR FAR *s - '\ff' terminated string.
 *
 * RETURNS:
 *	length
 *
 */
static int FFstrlen(const BYTE *s)
	{
	int i = 0;

	while (*s++ != 0xFF)
		i += 1;

	return i;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * KeyCmp
 *
 * DESCRIPTION: Compare function for qsort.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int _cdecl KeyCmp(PSTKEY pstKey1, PSTKEY pstKey2)
	{
	if (pstKey1->key > pstKey2->key)
		return 1;

	if (pstKey1->key < pstKey2->key)
		return -1;

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * emuInstallStateTable
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void emuInstallStateTable(const HHEMU hhEmu, struct trans_entry const *e, int size)
	{
	struct state_entry *state_pntr = 0;
	int nStateCnt = 0;
	int nTransCnt = 0;

	while (size--)
		{
		if (e->next_state == NEW_STATE) 	/* start a new state */
			{
			assert(nStateCnt < MAX_STATE);
			hhEmu->state_tbl[nStateCnt].first_trans = &hhEmu->trans_tbl[nTransCnt];
			state_pntr = &hhEmu->state_tbl[nStateCnt++];
			state_pntr->number_trans = 0;
			}
		else							/* add a transition */
			{
			assert(nTransCnt < MAX_TRANSITION);
			assert(state_pntr);
			if (state_pntr)
				{
				++state_pntr->number_trans;
				}
			hhEmu->trans_tbl[nTransCnt++] = *e;
			}
		++e;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuCreateTextAttrBufs
 *
 * DESCRIPTION:
 *	This one took a while to decipher but here is the bottom line.
 *	emu_maxrow and emu_maxcol refer to the last row and column from
 *	offset 0 (ZERO)!  The emulator image has 2 (two) more columns for the
 *	the stuff unknown to me at the present time.  This function wants
 *	the total number of rows and columns, so emu_maxrow = 23 means the
 *	the argument nRows is 24.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int emuCreateTextAttrBufs(const HEMU hEmu, const size_t nRows, size_t nCols)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;
	register size_t i, ndx;
	PSTATTR pstAttr;

    if (hhEmu == NULL)
        {
        return FALSE;
        }

	if (hhEmu->emu_apText && hhEmu->emu_apAttr && hhEmu->emu_aiEnd)
		return (TRUE);
	else
		emuDestroyTextAttrBufs(hEmu);

	nCols += 2; // Emulators need two extra columns.

	// Allocate the text buffer.
	//
	if ((hhEmu->emu_apText = (ECHAR **)calloc(nRows, sizeof(ECHAR *))) == 0)
		{
		assert(FALSE);
		return FALSE;
		}

	for (i = 0 ; i < nRows ; ++i)
		{
		if ((hhEmu->emu_apText[i] = (ECHAR *)calloc(nCols, sizeof(ECHAR))) == 0)
			{
			assert(FALSE);
			emuDestroyTextAttrBufs(hEmu);
			return FALSE;
			}

		ECHAR_Fill(hhEmu->emu_apText[i], EMU_BLANK_CHAR, nCols);
		}

	// Allocate the array to hold the rightmost character column number
	// for each row.
	//
	if ((hhEmu->emu_aiEnd = (int *)calloc(nRows, sizeof(int))) == 0)
		{
		assert(FALSE);
		emuDestroyTextAttrBufs(hEmu);
		return FALSE;
		}

	for (ndx = 0;  ndx < nRows; ++ndx)
			hhEmu->emu_aiEnd[ndx] = EMU_BLANK_LINE;

	// Allocate the attribute buffer.
	//
	if ((hhEmu->emu_apAttr = (PSTATTR *)calloc(nRows, sizeof(LPTSTR))) == 0)
		{
		assert(FALSE);
		emuDestroyTextAttrBufs(hEmu);
		return FALSE;
		}

	for (i = 0 ; i < nRows ; ++i)
		{
		if ((hhEmu->emu_apAttr[i] = calloc(nCols, sizeof(STATTR))) == 0)
			{
			assert(FALSE);
			emuDestroyTextAttrBufs(hEmu);
			return FALSE;
			}

		for (ndx = 0, pstAttr = hhEmu->emu_apAttr[i] ; ndx < nCols ; ++ndx)
			pstAttr[ndx] = hhEmu->emu_clearattr;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuDestroyTextAttrBufs
 *
 * DESCRIPTION:
 *	Destroys any allocated buffers for text and attributes.
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void emuDestroyTextAttrBufs(const HEMU hEmu)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;
	register int i;

    if (hEmu == NULL || hhEmu == NULL)
        {
        return;
        }

	if (hhEmu->emu_apText)
		{
        //
        // Fixed memory leak  hhEmu->emu_maxrow != MAX_EMUROWS
        // MAX_EMUROWS was what was allocated. REV: 12/20/2000
        //
		for (i = 0 ; i < MAX_EMUROWS ; ++i)
			{
			if (hhEmu->emu_apText[i])
				{
				free(hhEmu->emu_apText[i]);
				hhEmu->emu_apText[i] = NULL;
				}
			if (hhEmu->emu_apAttr[i])
				{
				free(hhEmu->emu_apAttr[i]);
				hhEmu->emu_apAttr[i] = NULL;
				}
			}

        free(hhEmu->emu_apText);
		hhEmu->emu_apText = 0;

        free(hhEmu->emu_apAttr);
		hhEmu->emu_apAttr = 0;
		}

	if (hhEmu->emu_aiEnd)
		{
		free(hhEmu->emu_aiEnd);
		hhEmu->emu_aiEnd = 0;
		}

	if (hhEmu->emu_apAttr)
		{
		for (i = 0 ; i <= hhEmu->emu_maxrow ; ++i)
			{
			if (hhEmu->emu_apAttr[i])
				{
				free(hhEmu->emu_apAttr[i]);
				hhEmu->emu_apAttr[i] = NULL;
				}
			}

		free(hhEmu->emu_apAttr);
		hhEmu->emu_apAttr = 0;
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuCreateNameTable
 *
 * DESCRIPTION:
 *	Loads the Emulator Names into a table
 *
 * ARGUMENTS:
 *	HHEMU hhEmu	-	Emulator Handle
 *
 * RETURNS:
 *	Success/Failure
 *
 */
int emuCreateNameTable(const HHEMU hhEmu)
	{
	int 	iLen, idx, iRet;
	TCHAR	achText[256];

	iRet = TRUE;

	emuLock((HEMU)hhEmu);

	if (hhEmu->pstNameTable)
		{
		free(hhEmu->pstNameTable);
		hhEmu->pstNameTable = NULL;
		}

	if ((hhEmu->pstNameTable = malloc(sizeof(STEMUNAMETABLE) * NBR_EMULATORS)) == 0)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	// Load the emulator name table.  It simply contains the name and id of
	// all of the supported emulators.
	//

	// EMU_AUTO
	//
	iLen = LoadString(glblQueryDllHinst(), IDS_EMUNAME_AUTO, achText, sizeof(achText) / sizeof(TCHAR));

	if (iLen >= EMU_MAX_NAMELEN)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	idx = 0;
	StrCharCopy(hhEmu->pstNameTable[idx].acName, achText);
	hhEmu->pstNameTable[idx].nEmuId = EMU_AUTO;

	// EMU_ANSI
	//
	iLen = LoadString(glblQueryDllHinst(), IDS_EMUNAME_ANSI, achText, sizeof(achText) / sizeof(TCHAR));

	if (iLen >= EMU_MAX_NAMELEN)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	idx++;
	StrCharCopy(hhEmu->pstNameTable[idx].acName, achText);
	hhEmu->pstNameTable[idx].nEmuId = EMU_ANSI;

	// EMU_ANSIW
	//
	iLen = LoadString(glblQueryDllHinst(), IDS_EMUNAME_ANSIW, achText, sizeof(achText) / sizeof(TCHAR));

	if (iLen >= EMU_MAX_NAMELEN)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	idx++;
	StrCharCopy(hhEmu->pstNameTable[idx].acName, achText);
	hhEmu->pstNameTable[idx].nEmuId = EMU_ANSIW;

	// EMU_MIMI
	//
	iLen = LoadString(glblQueryDllHinst(), IDS_EMUNAME_MINI, achText, sizeof(achText) / sizeof(TCHAR));

	if (iLen >= EMU_MAX_NAMELEN)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	idx++;
	StrCharCopy(hhEmu->pstNameTable[idx].acName, achText);
	hhEmu->pstNameTable[idx].nEmuId = EMU_MINI;

	// EMU_VIEW
	//
	iLen = LoadString(glblQueryDllHinst(), IDS_EMUNAME_VIEW, achText, sizeof(achText) / sizeof(TCHAR));

	if (iLen >= EMU_MAX_NAMELEN)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	idx++;
	StrCharCopy(hhEmu->pstNameTable[idx].acName, achText);
	hhEmu->pstNameTable[idx].nEmuId = EMU_VIEW;


	// EMU_TTY
	//
	iLen = LoadString(glblQueryDllHinst(), IDS_EMUNAME_TTY, achText, sizeof(achText) / sizeof(TCHAR));

	if (iLen >= EMU_MAX_NAMELEN)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	idx++;
	StrCharCopy(hhEmu->pstNameTable[idx].acName, achText);
	hhEmu->pstNameTable[idx].nEmuId = EMU_TTY;

	// EMU_VT100
	//
	iLen = LoadString(glblQueryDllHinst(), IDS_EMUNAME_VT100, achText, sizeof(achText) / sizeof(TCHAR));

	if (iLen >= EMU_MAX_NAMELEN)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	idx++;
	StrCharCopy(hhEmu->pstNameTable[idx].acName, achText);
	hhEmu->pstNameTable[idx].nEmuId = EMU_VT100;

	// EMU_VT52
	//
	iLen = LoadString(glblQueryDllHinst(), IDS_EMUNAME_VT52, achText, sizeof(achText) / sizeof(TCHAR));

	if (iLen >= EMU_MAX_NAMELEN)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	idx++;
	StrCharCopy(hhEmu->pstNameTable[idx].acName, achText);
	hhEmu->pstNameTable[idx].nEmuId = EMU_VT52;

	// EMU_VT100J
	//
	iLen = LoadString(glblQueryDllHinst(), IDS_EMUNAME_VT100J, achText, sizeof(achText) / sizeof(TCHAR));

	if (iLen >= EMU_MAX_NAMELEN)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	idx++;
	StrCharCopy(hhEmu->pstNameTable[idx].acName, achText);
	hhEmu->pstNameTable[idx].nEmuId = EMU_VT100J;

#if defined(INCL_VT220)
	// EMU_VT220
	//
	iLen = LoadString(glblQueryDllHinst(), IDS_EMUNAME_VT220, achText, sizeof(achText) / sizeof(TCHAR));

	if (iLen >= EMU_MAX_NAMELEN)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	idx++;
	StrCharCopy(hhEmu->pstNameTable[idx].acName, achText);
	hhEmu->pstNameTable[idx].nEmuId = EMU_VT220;
#endif

#if defined(INCL_VT320)
	// EMU_VT320
	//
	iLen = LoadString(glblQueryDllHinst(), IDS_EMUNAME_VT320, achText, sizeof(achText) / sizeof(TCHAR));

	if (iLen >= EMU_MAX_NAMELEN)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	idx++;
	StrCharCopy(hhEmu->pstNameTable[idx].acName, achText);
	hhEmu->pstNameTable[idx].nEmuId = EMU_VT320;
#endif

#if defined(INCL_VT100PLUS)
	// EMU_VT100+
	//
	iLen = LoadString(glblQueryDllHinst(), IDS_EMUNAME_VT100PLUS, achText, sizeof(achText) / sizeof(TCHAR));

	if (iLen >= EMU_MAX_NAMELEN)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	idx++;
	StrCharCopy(hhEmu->pstNameTable[idx].acName, achText);
	hhEmu->pstNameTable[idx].nEmuId = EMU_VTUTF8;
#endif

#if defined(INCL_VTUTF8)
	// EMU_VTUTF8
	//
	iLen = LoadString(glblQueryDllHinst(), IDS_EMUNAME_VTUTF8, achText, sizeof(achText) / sizeof(TCHAR));

	if (iLen >= EMU_MAX_NAMELEN)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	idx++;
	StrCharCopy(hhEmu->pstNameTable[idx].acName, achText);
	hhEmu->pstNameTable[idx].nEmuId = EMU_VTUTF8;
#endif

	LoadExit:

	emuUnlock((HEMU)hhEmu);
	return(iRet);

	}


/* end of emu.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\emudisp.c ===
/*	File: D:\WACKER\emu\vid2.c (Created: 12-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:29p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\assert.h>
#include <tdll\session.h>
#include <tdll\update.h>

#include "emu.h"
#include "emu.hh"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * emuDispSetCurPos
 *
 * DESCRIPTION:
 *	Sets the visible cursor on the display to row, col (zero based). If
 *	row and column values are out of range for the current display mode, they
 *	will be coerced into range.
 *
 * ARGUMENTS:
 *	row -- New row position for cursor.
 *	col -- New column poition for cursor.
 *
 * RETURNS:
 *	nothing
 */
void emuDispSetCurPos(int row, int col)
	{
	int nRow, nCol;

	if (row <= -1)
		row = emu_currow;

	if (col <= -1)
		col = emu_curcol;

	nRow = min(row, emu_maxrow);
	nCol = min(col, emu_maxcol);

	// Do range checking for DEC emulation.  This prevents the cursor
	// from being displayed in the 81st position, which is a valid
	// internal location, but is not a valid display column.
	//
	if (nCol == emu_maxcol && hhEmu->stUserSettings.nEmuId == EMU_VT100)
			nCol -= 1;

	updateCursorPos(sessQueryUpdateHdl(hhEmu->hSession), nRow, nCol);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * emuDispRgnScrollUp
 *
 * DESCRIPTION:
 *	Scrolls a rectangular area of the screen up 'nlines' lines. The color
 *	and attributes of the blank lines inserted at the bottom of the area as
 *	is scrolls up can be specified.
 *
 * ARGUMENTS:
 *	fromrow -- top row of area to be scrolled
 *	torow	-- bottom row of area to be scrolled
 *	nlines	-- number of lines to scroll
 *
 * RETURNS:
 *	nothing
 */
void emuDispRgnScrollUp(const int fromrow, const int torow, const int nlines)
	{
	updateScroll(sessQueryUpdateHdl(hhEmu->hSession),
					fromrow, torow, nlines, emu_imgtop, TRUE);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * emuDispRgnScrollDown
 *
 * DESCRIPTION:
 *	Scrolls a rectangular area of the screen down 'nlines' lines. The color
 *	and attributes of the blank lines inserted at the top of the area as
 *	is scrolls down can be specified.
 *
 * ARGUMENTS:
 *	fromrow -- top row of area to be scrolled
 *	torow	-- bottom row of area to be scrolled
 *	nlines	-- number of lines to scroll
 *
 * RETURNS:
 *	nothing
 */
void emuDispRgnScrollDown(const int fromrow,
							const int torow,
							const int nlines)
	{
	updateScroll(sessQueryUpdateHdl(hhEmu->hSession),
					fromrow, torow, -nlines, emu_imgtop, TRUE);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * emuDispRgnClear
 *
 * DESCRIPTION:
 *	Clears a rectangular area of the screen to blank spaces. The color and
 *	attributes of the spaces is determined by 'state'.
 *
 * ARGUMENTS:
 *	fromrow -- top row of area to be cleared
 *	torow	-- bottom row of area to be cleared
 *
 * RETURNS:
 *	nothing
 */
void emuDispRgnClear(const int fromrow, const int torow)
	{
	updateLine(sessQueryUpdateHdl(hhEmu->hSession), fromrow, torow);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * emuDispWrtQuickChr
 *
 * DESCRIPTION:
 *	Fast routine to write a character at current cursor position with
 *	current color and attributes. Handles all characters as displayable
 *	characters.
 *
 * ARGUMENTS:
 *	none
 *
 * RETURNS:
 *	nothing
 */
void emuDispWrtQuickChr(void)	/* assumes current cursor pos. and state */
	{
	if (++emu_curcol > emu_maxcol)
		emu_curcol = emu_maxcol;

	updateChar(sessQueryUpdateHdl(hhEmu->hSession),
					emu_currow, emu_curcol, emu_curcol);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * emuDispWrtTTYChr
 *
 * DESCRIPTION:
 *	Writes a single character to the screen at the current cursor postion
 *	using the current default colors and attributes. Unlike VidWrtQuickChr,
 *	this function will correctly interpret the TTY control codes such as
 *	'\r', '\n', '\b', and BELL
 *
 * ARGUMENTS:
 *	c -- Character to write
 *
 * RETURNS:
 *	nothing
 */
void emuDispWrtTTYChr(TCHAR c)
	{
	int beeplen = 50;

	if (c == TEXT('\007'))
		{
		if (beeplen)
			MessageBeep((UINT)-1);
		}

	else if (c == TEXT('\r'))
		{
		emu_curcol = 0;
		}

	else if (c == TEXT('\n'))
		{
		if (++emu_currow > emu_maxrow)
			--emu_currow;
		}

	else
		{
		emuDispWrtQuickChr();
		}

	//updateChar(sessQueryUpdateHdl(hhEmu->hSession),
	//				  emu_currow, emu_curcol, emu_curcol);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * emuDispWrtChrAttrStr
 *
 * DESCRIPTION:
 *	Updates the screen from memory buffers containing the text and attribute
 *	bytes of the display. This is used in cases where the contents of the
 *	screen have been stored with the low-level display attributes. The display
 *	begins at the current cursor postion.
 *
 * ARGUMENTS:
 *	nchars	-- Number of characters to be restored.
 *
 * RETURNS:
 *	none
 */
void emuDispWrtChrAttrStr(const int nChars)
	{
	updateChar(sessQueryUpdateHdl(hhEmu->hSession),
					emu_currow,
					emu_curcol,
					min( (emu_curcol + nChars), emu_maxcol));

	//if ((emu_curcol += nChars) > emu_maxcol)
	//	  emu_curcol = emu_maxcol;

	return;
	}

/* end of emudisp.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\emu.h ===
/*	File: D:\WACKER\emu\emu.h (Created: 08-Dec-1993)
 *
 *	Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 5 $
 *	$Date: 3/16/01 4:28p $
 */

/* Emulator ID's */

// Don't ever change emulator id numbers.  They are stored in session files
// and as such are cast in stone. - mrw,4/13/95
//
#define EMU_AUTO						100
#define EMU_ANSI						101
#define EMU_MINI						102
#define EMU_VIEW						109
#define EMU_TTY 						110
#define EMU_VT100						111
#define EMU_VT220						112	// rde:23 Jan 98
#define EMU_VT320						113	// rde:23 Jan 98
#define EMU_VT52						115
#define EMU_VT100J						116
#define EMU_ANSIW						117
#define EMU_VT100PLUS					118 // REV: 02/28/2001 
#define EMU_VTUTF8                      119 // REV: 02/28/2001 

#define NBR_EMULATORS					13

/* Emulator constants  */

// Note: if you change MAX_EMUROWS or MAX_EMUCOLS also change
//		 TERM_ROWS and TERM_COLS in term.hh to match - mrw
// Note: Can't find TERM_ROWS and TERM_COLS. rde 10 Jun 98

#define MAX_EMUROWS 	50		// Largest vertical size for emulator.
#define MAX_EMUCOLS 	132		// Largest horizontal size for emulator.
#define MIN_EMUROWS 	10		// Smallest allowable value for rows,
#define MIN_EMUCOLS 	20		// and columns.

#define EMU_DEFAULT_COLS			80
#define EMU_DEFAULT_ROWS			24

#define EMU_OK						0
#define TRM_NUMSTRIPCHARS			3
#define EMU_MAX_NAMELEN 			15
#define EMU_MAX_AUTODETECT_ATTEMPTS 10
#define EMU_MAX_TELNETID            256

// JCM should remove the two defines below.
//
#define EMU_DEFAULT_MAXCOL			79
#define EMU_DEFAULT_MAXROW			23

#define EMU_KEYS_ACCEL		0
#define EMU_KEYS_TERM		1
#define EMU_KEYS_SCAN		2

#define EMU_CURSOR_BLOCK	1
#define EMU_CURSOR_LINE 	2
#define EMU_CURSOR_NONE 	3

#define EMU_CHARSET_ASCII			0
#define EMU_CHARSET_UK				1
#define EMU_CHARSET_SPECIAL			2
#define EMU_CHARSET_MULTINATIONAL	3
#define EMU_CHARSET_FRENCH			4
#define EMU_CHARSET_FRENCHCANADIAN	5
#define EMU_CHARSET_GERMAN			6

#define EMU_EVENT_CONNECTED 	1
#define EMU_EVENT_DISCONNECTED	2
#define EMU_EVENT_CONNECTING	3

#define EMU_BKSPKEYS_CTRLH		1
#define EMU_BKSPKEYS_DEL		2
#define EMU_BKSPKEYS_CTRLHSPACE 3

// 8 bits just ain't enough anymore.  Going to bit fields to handle
// things like text marking, blinking, underlining, etc.  Also can
// handle more colors this way if we want.	For now though stick to
// original scheme of 4 bits for foreground color and 4 bits for
// background color.

struct stAttribute
	{
	unsigned int txtclr : 4;		// text or foreground color index.
	unsigned int bkclr	: 4;		// background color index.
	unsigned int txtmrk : 1;		// true if text is 'marked'.
	unsigned int undrln : 1;		// underline
	unsigned int hilite : 1;		// foreground intensity
	unsigned int bklite : 1;		// background intensity
	unsigned int blink	: 1;		// soon to be famous blink attribute
	unsigned int revvid : 1;		// reverse video
	unsigned int blank	: 1;		// blank attribute
	unsigned int dblwilf: 1;		// double wide left
	unsigned int dblwirt: 1;		// double wide right
	unsigned int dblhilo: 1;		// double height top half
	unsigned int dblhihi: 1;		// double height bottom half
    unsigned int protect: 1;        // protected bit for DEC emulators.
	unsigned int symbol:  1;		// use symbol font
	unsigned int wilf	: 1;		// wide left
	unsigned int wirt	: 1;		// wide right
	};

typedef struct stAttribute STATTR;
typedef STATTR *PSTATTR;

// Note: This structure is now used only internally to the program--it is
// no longer used to load in and save out data in the session file. 
// Consequently, it is safe to add and remove items at will. rde 8 Jun 98
struct emuSettings
	{
	int 	nEmuId, 			// 100 = EMU_AUTO
								// 101 = EMU_ANSI
								// 102 = EMU_MINI
								// 109 = EMU_VIEW
								// 110 = EMU_TTY
								// 111 = EMU_VT100
								// 112 = EMU_VT220
								// 113 = EMU_VT320
								// 115 = EMU_VT52
								// 116 = EMU_VT100J
                                // 117 = EMU_ANSIW
								// 118 = EMU_VT100PLUS
								// 119 = EMU_VTUTF8
								//
			nTermKeys,			// 0 = EMU_KEYS_ACCEL
								// 1 = EMU_KEYS_TERM
								// 2 = EMU_KEYS_SCAN
								//
			nCursorType,		// 1 = EMU_CURSOR_BLOCK
								// 2 = EMU_CURSOR_LINE
	        					// 3 = EMU_CURSOR_NONE
								//
			nCharacterSet,		// 0 = EMU_CHARSET_ASCII
								// 1 = EMU_CHARSET_UK
								// 2 = EMU_CHARSET_SPECIAL
								//
			nAutoAttempts,		// Count of connections using the Auto
								// Detect Emulator.  At
								// EMU_MAX_AUTODETECT_ATTEMPTS, we switch
								// to Ansi emulation.  Note, this may
								// get moved into a Statictics Handle
								// if we ever develop one.
								//
			fCursorBlink,		// Blinking cursor. 			True\False.
			fMapPFkeys, 		// PF1-PF4 to top row of keypad.True\False.
			fAltKeypadMode, 	// Alternate keypad mode.		True\False.
			fKeypadAppMode, 	// Keypad application mode. 	True\False.
			fCursorKeypadMode,	// Cursor keypad mode.			True\Fales.
			fReverseDelBk,		// Reverse Del and Backsp.		True\False.
			f132Columns,		// 132 column display.			True\False.
			fDestructiveBk, 	// Destructive backspace.		True\False.
			fWrapLines, 		// Wrap lines.					True\False.
			fLbSymbolOnEnter,	// Send # symbol on Enter.		True\False.

	// Note: The following two variables were added for the VT220/320. rde:24 Jan 98
            fUse8BitCodes,      // 8-bit control codes          True\False.
            fAllowUserKeys,     // User defined keys allowed    True\False.
    // Note: The following variable was added for VT100/220/320. mpt:5-18-00
			fPrintRaw;  		// Do not use windows print drv True\False.
                                
#ifdef INCL_TERMINAL_SIZE_AND_COLORS
	// The following four variables were added for user settable
	// terminal screen size and colors. rde 1 Jun 98
	int		nTextColor,			// Default text color.			0 thru 15.
			nBackgroundColor,	// Default background color.	0 thru 15.
			nUserDefRows,		// Number of terminal rows.		12 thru 50.
			nUserDefCols;		// Number of terminal columns.	40 thru 132.
#endif

    // Note: The following two variables are only used if the "Include
    // User Defined Backspace and Telnet Terminal Id" feature is enabled.
    // There is no compile switch here because this entire structure gets
    // written to the session file in one large chunk. Using a compile
    // switch could potentially cause version problems later on down
    // the road. - cab:11/15/96
    //
    int     nBackspaceKeys;     // 1 = EMU_BKSPKEYS_CTRLH
                                // 2 = EMU_BKSPKEYS_DEL
                                // 3 = EMU_BKSPKEYS_CTRLHSPACE

    TCHAR   acTelnetId[EMU_MAX_TELNETID];   // Telnet terminal ID
	};

typedef struct emuSettings STEMUSET;
typedef STEMUSET *PSTEMUSET;


/* emuhdl.c */
HEMU	emuCreateHdl(const HSESSION hSession);
int 	emuDestroyHdl(const HEMU hEmu);
int 	emuLoad(const HEMU hEmu, const int nEmuId);
void	emuLock(const HEMU hEmu);
void	emuUnlock(const HEMU hEmu);
ECHAR	**emuGetTxtBuf(const HEMU hEmu);
PSTATTR *emuGetAttrBuf(const HEMU hEmu);
int 	emuKbdIn(const HEMU hEmu, KEY_T key, const int fTest);
int 	emuDataIn(const HEMU hEmu, const ECHAR ccode);
int 	emuComDone(const HEMU hEmu);
int 	emuTrackingNotify(const HEMU hEmu);
int 	emuIsEmuKey(const HEMU hEmu, KEY_T key);
int 	emuQueryClearAttr(const HEMU hemu, PSTATTR pstClearAttr);
int 	emuQueryCurPos(const HEMU hEmu, int *row, int *col);
HPRINT	emuQueryPrintEchoHdl(const HEMU hEmu);
int 	emuQueryRowsCols(const HEMU hEmu, int *piRows, int *piCols);
int 	emuQueryEmulatorId(const HEMU hEmulator);
int 	emuNotify(const HEMU hEmu, const int nEvent);
int 	emuQueryCursorType(const HEMU hEmu);
int 	emuQueryName(const HEMU hEmu, TCHAR *achBuffer, int nSize);
int 	emuSetSettings(const HEMU hEmu, const PSTEMUSET pstSettings);
int 	emuQuerySettings(const HEMU hEmu, PSTEMUSET pstSettings);
int 	emuInitializeHdl(const HEMU hEmu);
int 	emuSaveHdl(const HEMU hEmu);
int 	emuHomeHostCursor(const HEMU hEmu);
int 	emuEraseTerminalScreen(const HEMU hEmu);

void	emuMinitelSendKey(const HEMU hEmu, const int iCmd); // minitel.c
int 	emuGetIdFromName(const HEMU hEmu, TCHAR *achEmuName);

int     emuQueryDefaultTelnetId(const int nEmuId, TCHAR *achTelnetId, int nSize);
int     emuLoadDefaultTelnetId(const HEMU hEmu);

/*	colors indexes */

#define VC_BLACK		0
#define VC_BLUE 		1
#define VC_GREEN		2
#define VC_CYAN 		3
#define VC_RED			4
#define VC_MAGENTA		5
#define VC_BROWN		6
#define VC_WHITE		7
#define VC_GRAY 		8
#define VC_BRT_BLUE 	9
#define VC_BRT_GREEN	10
#define VC_BRT_CYAN 	11
#define VC_BRT_RED		12
#define VC_BRT_MAGENTA	13
#define VC_BRT_YELLOW	14
#define VC_BRT_WHITE	15
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\emudlgs.h ===
/*	File: D:\WACKER\emu\emudlgs.h (Created: 14-Feb-1994)
 *
 *	Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 3 $
 *	$Date: 3/16/01 4:28p $
 */

// Function prototypes...

BOOL emuSettingsDlg(const HSESSION hSession, const HWND hwndParent,
					const int nEmuId, PSTEMUSET pstEmuSettings);
INT_PTR CALLBACK emuTTY_SettingsDlgProc	     (HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK emuANSI_SettingsDlgProc	 (HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK emuVT52_SettingsDlgProc	 (HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK emuVT100_SettingsDlgProc 	 (HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK emuVT100J_SettingsDlgProc 	 (HWND, UINT, WPARAM, LPARAM);
#if defined(INCL_VT220)
INT_PTR CALLBACK emuVT220_SettingsDlgProc 	 (HWND, UINT, WPARAM, LPARAM);
#endif
#if defined(INCL_VT320)
INT_PTR CALLBACK emuVT320_SettingsDlgProc 	 (HWND, UINT, WPARAM, LPARAM);
#endif
#if defined(INCL_VT100PLUS)
INT_PTR CALLBACK emuVT100PLUS_SettingsDlgProc 	 (HWND, UINT, WPARAM, LPARAM);
#endif
#if defined(INCL_VTUTF8)
INT_PTR CALLBACK emuVTUTF8_SettingsDlgProc 	 (HWND, UINT, WPARAM, LPARAM);
#endif
INT_PTR CALLBACK emuMinitel_SettingsDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar);
INT_PTR CALLBACK emuViewdata_SettingsDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar);

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
int emuColorSettingsDlg(const HSESSION hSession, 
						const HWND hwndParent,
						PSTEMUSET pstEmuSettings);
INT_PTR CALLBACK emuColorSettingsDlgProc(HWND hDlg, 
										UINT wMsg, 
										WPARAM wPar, 
										LPARAM lPar);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\emudec.hh ===
/*	File: \wacker\emu\emudec.hh (Created: 29-Jan-1998)
 *
 *	Copyright 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 8/03/99 2:10p $
 */

// The maximum number of user defined keys.  Used by the VT220 and VT320.
//
#define MAX_UDK_KEYS    15
#define MAX_KEY_SPACE   256

// These constants are state table states used when processing user
// defined keys for the VT220 and VT320.
//
#define KEY_NUMBER_NEXT     0
#define KEY_DIGIT2_NEXT     1
#define SLASH_NEXT          2
#define CHAR_DIGIT1_NEXT    3
#define CHAR_DIGIT2_NEXT    4
#define ESC_SEEN            5

// The following key data structures are used only for user-defined
// keys in HTPE. But in shared code, they completely replace all 
// key data structures. In shared code, these definitios are in 
// \shared\emulator\emu.hh

// Key table structure definitions.  These are conditionally defined
// so the debug version of the program can supply additional information
// for testing.  In the debug version, when the user
// presses the F1 key, we can output the name of the key "HVK_F1" and
// the sequence that is assigned to that key.  The KEYDEF macro defined
// below is used in the initialization of the emulator key tables, found
// in each emulator's initialize function.  See John Masters for more
// details.
//
#if defined(_DEBUG)

typedef struct
    {
    KEYDEF Key;
    TCHAR * pSequence;
    unsigned int iSequenceLen;
    TCHAR * pszKeyName;
    } STEMUKEYDATA;

    #define EMUKEY(K, V, C, A, S, E, SEQ, L) \
        { K | (V ? VIRTUAL_KEY : 0) | (C ? CTRL_KEY : 0) | \
        (A ? ALT_KEY : 0) | (S ? SHIFT_KEY : 0) | (E ? EXTENDED_KEY : 0), \
        { TEXT(SEQ) }, {L}, {#K} }
//{ {K, V, C, A, S, E}, { TEXT(SEQ) }, {L}, {#K} }

#else

typedef struct
    {
    KEYDEF Key;
    TCHAR * pSequence;
    unsigned int iSequenceLen;
    } STEMUKEYDATA;

    #define EMUKEY(K, V, C, A, S, E, SEQ, L) \
        { K | (V ? VIRTUAL_KEY : 0) | (C ? CTRL_KEY : 0) | \
        (A ? ALT_KEY : 0) | (S ? SHIFT_KEY : 0) | (E ? EXTENDED_KEY : 0), \
        { TEXT(SEQ) }, {L} }
//{ {K, V, C, A, S, E}, { TEXT(SEQ) }, {L} }

#endif

typedef STEMUKEYDATA const * PSTCEMUKEYDATA;
typedef STEMUKEYDATA * PSTEMUKEYDATA;

// Private emulator data for DEC Terminals.
//
typedef struct stPrivateDEC
	{
	int sv_row,
		sv_col,
		sv_state,
		sv_AWM,
		sv_DECOM,
		sv_protectmode,
		fAttrsSaved,
		len_s,
		len_t,
		nState,
		gn,
		old_gl,
		gl,
		gr,
		sv_gr,
		sv_gl,
		fDecColHold,
		*aiLineAttr;

	ECHAR	storage[40],
			vt_charset[4],
			vt_sv_charset[4],
			terminate[4],
			*pntr;

	STATTR sv_attr;

#if defined(INCL_VT220)
    PSTCEMUKEYDATA  pstcEmuKeyTbl1,
                    pstcEmuKeyTbl2,
                    pstcEmuKeyTbl3,
                    pstcEmuKeyTbl4,
                    pstcEmuKeyTbl5,
                    pstcEmuKeyTbl6;

    int             iKeyTable1Entries,
                    iKeyTable2Entries,
                    iKeyTable3Entries,
                    iKeyTable4Entries,
                    iKeyTable5Entries,
                    iKeyTable6Entries;

	// A pointer to a table of user defined keys,
	//
	PSTEMUKEYDATA  pstUDK;

	int     iUDKTableEntries;

	// This variable is a state variable used in the processing of
	// user defined keys in the VT220 and VT320.
	//
	int     iUDKState,
			iUDKTableIndex,
			iUDKSequenceLen;

	// A flag that is used identify the locked or unlocked status
	// of the UDK's, after they are defined.  See emuDecClearUDK.
	//
	int     fUnlockedUDK;

	// A temporary buffer to collect the user defined key sequence as
	// it is being processed.
	//
	TCHAR   acUDKSequence[MAX_KEY_SPACE];

	TCHAR   chUDKAssignment;

	TCHAR   const *pacUDKSelectors;
#endif
	} DECPRIVATE;

typedef DECPRIVATE *PSTDECPRIVATE;

// From vt220ini.c
void vt220_init(const HHEMU hhEmu);

// From vt220.c
void    vt220_DA(const HHEMU hhEmu);
void    vt220_hostreset(const HHEMU hhEmu);
void    vt100_printcmnds(const HHEMU hhEmu);
void    emuDecClearUDK(const HHEMU hhEmu);
void    vt220_softreset(const HHEMU hhEmu);
void    vt220_2ndDA(const HHEMU hhEmu);
void    vt220_definekey(const HHEMU hhEmu);
void    vt220_level(const HHEMU hhEmu);
void    vt220_protmode(const HHEMU hhEmu);
int     vt220_reset(const HHEMU hhEmu, const int host_request);
void    vt220mode_reset(const HHEMU hhEmu);
void    vt220_savekeys(const HHEMU hhEmu, const int iSave);
void    emuDecSendKeyString(const HHEMU hhEmu,
                        const int iIndex,
                        PSTCEMUKEYDATA pstcKeyTbl,
                        const int iMaxEntries);

void    emuDecDefineUDK(const HHEMU hhEmu);
int     emuDecStoreUDK(const HHEMU hhEmu);
int		emuDecKeyboardIn(const HHEMU hhEmu, int Key, 
				const int fTest);
int		emuDecKbdKeyLookup(const HHEMU hhEmu,
                const KEYDEF Key, PSTCEMUKEYDATA pstKeyTbl,
                const int iMaxEntries);
void	emuDecSendKeyString(const HHEMU hhEmu, const int iIndex,
                PSTCEMUKEYDATA pstcKeyTbl, const int iMaxEntries);
void	emuVT220SendKeyString(const HHEMU hhEmu,
                const int iIndex, PSTCEMUKEYDATA pstcKeyTbl,
                const int iMaxEntries);
void	emuDecEL(const HHEMU hhEmu);
void	emuDecClearLine(const HHEMU hhEmu, const int iClearSelect);
void	emuVT220ED(const HHEMU hhEmu);
void	emuDecEraseScreen(const HHEMU hhEmu, const int iClearSelect);
void	emuDecClearImageRowSelective(const HHEMU hhEmu, const int iImageRow);
void	emuDecUnload(const HHEMU hhEmu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\emudll.c ===
/*	File: D:\WACKER\emu\emudll.c (Created: 08-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:28p $
 */

#include <windows.h>

BOOL WINAPI EmuEntry(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);
BOOL WINAPI _CRT_INIT(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	EmuEntry
 *
 * DESCRIPTION:
 *	Currently, just initializes the C-Runtime library but may be used
 *	for other things later.
 *
 * ARGUMENTS:
 *	hInstDll	- Instance of this DLL
 *	fdwReason	- Why this entry point is called
 *	lpReserved	- reserved
 *
 * RETURNS:
 *	BOOL
 *
 */
BOOL WINAPI EmuEntry(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved)
	{
	return _CRT_INIT(hInstDll, fdwReason, lpReserved);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\emudlgs.c ===
/*	File: D:\WACKER\emu\emudlg.c (Created: 14-Feb-1994)
 *
 *	Copyright 1991, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 10 $
 *	$Date: 3/16/01 4:28p $
 */

#include <windows.h>
#pragma hdrstop

#include <commctrl.h>

#include <tdll\stdtyp.h>
#include <tdll\tdll.h>
#include <tdll\assert.h>
#include <tdll\session.h>
#include <tdll\statusbr.h>
#include <tdll\misc.h>
#include <term\res.h>
#include <tdll\globals.h>
#include <tdll\load_res.h>
#include <tdll\htchar.h>
#include <tdll\hlptable.h>

#include "emu.h"
#include "emuid.h"
#include "emudlgs.h"

// Static function prototypes...
//
STATIC_FUNC void emudlgInitCursorSettings  (HWND hDlg,
									  		PSTEMUSET	pstEmuSettings,
									  		INT  ID_UNDERLINE,
									  		INT  ID_BLOCK,
									  		INT  ID_BLINK);
STATIC_FUNC void emudlgInitCharSetSetting(HWND  hDlg,
											PSTEMUSET pstEmuSettings,
											int nCharSetTableID,
											int nDefaultCharSetID);
STATIC_FUNC BOOL emudlgFindCharSetName(HWND  hDlg,
										BYTE *pbCharSetTable,
										int nCharSetID,
										LPTSTR *ppszCharSetName,
										BOOL fTellDlg);
#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
STATIC_FUNC void emudlgInitRowsCols(HWND hDlg, PSTEMUSET pstEmuSettings);
STATIC_FUNC void emudlgGetRowColSettings(HWND hDlg, PSTEMUSET pstEmuSettings);
STATIC_FUNC void emudlgCreateUpDownControl(HWND hDlg,
										PSTEMUSET pstEmuSettings);
STATIC_FUNC int emudlgValidateEntryFieldSetting(HWND hDlg,
										int nIDC,
										int nMinVal,
										int nMaxVal);
#endif

// Defines...
//
#define IDC_KEYPAD_MODE					104
#define IDC_CURSOR_MODE					106
#define IDC_132_COLUMN					107
#define IDC_TF_CHARACTER_SET			109
#define IDC_CHARACTER_SET				110
#define IDC_BLOCK_CURSOR				112
#define IDC_UNDERLINE_CURSOR			113
#define IDC_BLINK_CURSOR				114
#define IDC_DESTRUCTIVE_BKSP			116
#define IDC_ALT_MODE					117
#define IDC_SEND_POUND_SYMBOL			122
#define IDC_HIDE_CURSOR					119
#define IDC_GR_CURSOR					111
#define IDC_GR_TERMINAL_MODES			118
#define IDC_USE_8_BIT_CODES				120
#define	IDC_ALLOW_USERDEFINED_KEYS		121
#define IDC_GR_SCREEN					130
#define IDC_TF_ROWS						131
#define	IDC_NUMBER_OF_ROWS				132
#define IDC_TF_COLUMNS					133
#define	IDC_NUMBER_OF_COLS				134
#define	IDC_PRINT_RAW					135

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  emuSettingsDlg
 *
 * DESCRIPTION:
 *	Decide which emulator settings dialog to call.
 *
 * ARGUMENTS:
 *  hSession 	   - the session handle.
 *  nEmuId		   - emulator id.
 *  pstEmuSettings - settings structure to fill in.  It should be initialized
 *					 up above.
 *
 * RETURNS:
 *	fResult - return value from the DoDialog().
 *
 */
BOOL emuSettingsDlg(const HSESSION hSession, const HWND hwndParent,
					const int nEmuId, PSTEMUSET pstEmuSettings)
	{
	BOOL		fResult = FALSE;

	assert(hSession && hwndParent);

	switch (nEmuId)
		{
	case EMU_ANSIW:
	case EMU_ANSI:
		fResult = (BOOL)DoDialog(glblQueryDllHinst(),
								 MAKEINTRESOURCE(IDD_ANSI_SETTINGS),
								 hwndParent,
								 (DLGPROC)emuANSI_SettingsDlgProc,
								 (LPARAM)pstEmuSettings);
		break;

	case EMU_TTY:
		fResult = (BOOL)DoDialog(glblQueryDllHinst(),
								 MAKEINTRESOURCE(IDD_TTY_SETTINGS),
								 hwndParent,
								 (DLGPROC)emuTTY_SettingsDlgProc,
								 (LPARAM)pstEmuSettings);
		break;

	case EMU_VT52:
		fResult = (BOOL)DoDialog(glblQueryDllHinst(),
								 MAKEINTRESOURCE(IDD_VT52_SETTINGS),
								 hwndParent,
								 (DLGPROC)emuVT52_SettingsDlgProc,
								 (LPARAM)pstEmuSettings);
		break;

	case EMU_VT100:
		fResult = (BOOL)DoDialog(glblQueryDllHinst(),
								 MAKEINTRESOURCE(IDD_VT100_SETTINGS),
								 hwndParent,
								 (DLGPROC)emuVT100_SettingsDlgProc,
								 (LPARAM)pstEmuSettings);
		break;

	case EMU_VT100J:
		fResult = (BOOL)DoDialog(glblQueryDllHinst(),
								 MAKEINTRESOURCE(IDD_VT100J_SETTINGS),
								 hwndParent,
								 (DLGPROC)emuVT100J_SettingsDlgProc,
								 (LPARAM)pstEmuSettings);
		break;

#if defined(INCL_VT220)
	case EMU_VT220:
		fResult = (BOOL)DoDialog(glblQueryDllHinst(),
								 MAKEINTRESOURCE(IDD_VT220_SETTINGS),
								 hwndParent,
								 (DLGPROC)emuVT220_SettingsDlgProc,
								 (LPARAM)pstEmuSettings);
		break;
#endif

#if defined(INCL_VT320)
	case EMU_VT320:
		fResult = (BOOL)DoDialog(glblQueryDllHinst(),
								 MAKEINTRESOURCE(IDD_VT220_SETTINGS),
								 hwndParent,
								 (DLGPROC)emuVT220_SettingsDlgProc,
								 (LPARAM)pstEmuSettings);
		break;
#endif

#if defined(INCL_VT100PLUS)
	case EMU_VT100PLUS:
		fResult = (BOOL)DoDialog(glblQueryDllHinst(),
								 MAKEINTRESOURCE(IDD_VT100J_SETTINGS),
								 hwndParent,
								 (DLGPROC)emuVT100_SettingsDlgProc,
								 (LPARAM)pstEmuSettings);
		break;
#endif

#if defined(INCL_VTUTF8)
	case EMU_VTUTF8:
		fResult = (BOOL)DoDialog(glblQueryDllHinst(),
								 MAKEINTRESOURCE(IDD_VT100J_SETTINGS),
								 hwndParent,
								 (DLGPROC)emuVT100_SettingsDlgProc,
								 (LPARAM)pstEmuSettings);
		break;
#endif

	case EMU_MINI:
		fResult = (BOOL)DoDialog(glblQueryDllHinst(),
								 MAKEINTRESOURCE(IDD_MINITEL_SETTINGS),
								 hwndParent,
								 (DLGPROC)emuMinitel_SettingsDlgProc,
								 (LPARAM)pstEmuSettings);
		break;

	case EMU_VIEW:
		fResult = (BOOL)DoDialog(glblQueryDllHinst(),
								 MAKEINTRESOURCE(IDD_VIEWDATA_SETTINGS),
								 hwndParent,
								 (DLGPROC)emuViewdata_SettingsDlgProc,
								 (LPARAM)pstEmuSettings);
		break;

	default:
		break;
		}

	return fResult;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  emuANSI_SettingsDlgProc
 *
 * DESCRIPTION:
 *	ANSI Settings dialog proc.
 *
 * ARGUMENTS:
 *	Standard window proc parameters.
 *
 * RETURNS:
 *	Standerd return value.
 *
 */
INT_PTR CALLBACK emuANSI_SettingsDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
	PSTEMUSET	pstEmuSettings;
	static		DWORD aHlpTable[] =
		{
		IDC_BLOCK_CURSOR,		IDH_TERM_EMUSET_CURSOR,
		IDC_UNDERLINE_CURSOR,	IDH_TERM_EMUSET_CURSOR,
		IDC_BLINK_CURSOR,		IDH_TERM_EMUSET_CURSOR,
		IDC_GR_CURSOR,			IDH_TERM_EMUSET_CURSOR,
        IDCANCEL,                           IDH_CANCEL,
        IDOK,                               IDH_OK,
		0,						0};

	switch (wMsg)
		{
	case WM_INITDIALOG:
		pstEmuSettings = (PSTEMUSET)lPar;
		SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pstEmuSettings);
		mscCenterWindowOnWindow(hDlg, GetParent(hDlg));

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
		/* -------------- Screen rows and columns ------------- */

		emudlgInitRowsCols(hDlg, pstEmuSettings);
#endif

		/* -------------- Cursor characteristics ------------- */

		emudlgInitCursorSettings(hDlg, pstEmuSettings, IDC_UNDERLINE_CURSOR,
			IDC_BLOCK_CURSOR, IDC_BLINK_CURSOR);

		break;

	case WM_CONTEXTMENU:
		doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		break;

	case WM_HELP:
		doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_COMMAND:
		switch (wPar)
			{
		case IDOK:
			pstEmuSettings = (PSTEMUSET)GetWindowLongPtr(hDlg, GWLP_USERDATA);

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
			/* -------------- Screen rows and columns ------------- */

			emudlgGetRowColSettings(hDlg, pstEmuSettings);
#endif
			/* -------------- Cursor type ------------- */

			pstEmuSettings->nCursorType =
				(int)IsDlgButtonChecked(hDlg, IDC_BLOCK_CURSOR) ?
					EMU_CURSOR_BLOCK : EMU_CURSOR_LINE;

			/* -------------- Cursor Blink ------------- */

			pstEmuSettings->fCursorBlink =
				(int)IsDlgButtonChecked(hDlg, IDC_BLINK_CURSOR);

			EndDialog(hDlg, TRUE);
			break;

		case IDCANCEL:
			EndDialog(hDlg, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  emuTTY_SettingsDlgProc
 *
 * DESCRIPTION:
 *	TTY Settings dialog proc.
 *
 * ARGUMENTS:
 *	Standard window proc parameters.
 *
 * RETURNS:
 *	Standerd return value.
 *
 */
INT_PTR CALLBACK emuTTY_SettingsDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
	PSTEMUSET	pstEmuSettings;
	static		DWORD aHlpTable[] = {IDC_DESTRUCTIVE_BKSP,	IDH_TERM_EMUSET_DESTRUCTIVE,
									 IDC_BLOCK_CURSOR,		IDH_TERM_EMUSET_CURSOR,
									 IDC_UNDERLINE_CURSOR,	IDH_TERM_EMUSET_CURSOR,
									 IDC_BLINK_CURSOR,		IDH_TERM_EMUSET_CURSOR,
									 IDC_GR_CURSOR, 		IDH_TERM_EMUSET_CURSOR,
                                     IDCANCEL,                           IDH_CANCEL,
                                     IDOK,                               IDH_OK,
									 0, 					0};

	switch (wMsg)
		{
	case WM_INITDIALOG:
		pstEmuSettings = (PSTEMUSET)lPar;
		SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pstEmuSettings);
		mscCenterWindowOnWindow(hDlg, GetParent(hDlg));

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
		/* -------------- Screen rows and columns ------------- */

		emudlgInitRowsCols(hDlg, pstEmuSettings);
#endif

		/* -------------- Destructive Backspace ------------- */

		SendDlgItemMessage(hDlg, IDC_DESTRUCTIVE_BKSP, BM_SETCHECK,
			(unsigned int)pstEmuSettings->fDestructiveBk, 0);

		/* -------------- Cursor characteristics ------------- */

		emudlgInitCursorSettings(hDlg, pstEmuSettings, IDC_UNDERLINE_CURSOR,
			IDC_BLOCK_CURSOR, IDC_BLINK_CURSOR);

		break;

	case WM_CONTEXTMENU:
		doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		break;

	case WM_HELP:
        doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_COMMAND:
		switch (wPar)
			{
		case IDOK:
			pstEmuSettings = (PSTEMUSET)GetWindowLongPtr(hDlg, GWLP_USERDATA);

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
			/* -------------- Screen rows and columns ------------- */

			emudlgGetRowColSettings(hDlg, pstEmuSettings);
#endif
			/* -------------- Destructive Backspace ------------- */

			pstEmuSettings->fDestructiveBk =
				(int)IsDlgButtonChecked(hDlg, IDC_DESTRUCTIVE_BKSP);

			/* -------------- Cursor type ------------- */

			pstEmuSettings->nCursorType =
				(int)IsDlgButtonChecked(hDlg, IDC_BLOCK_CURSOR) ?
					EMU_CURSOR_BLOCK : EMU_CURSOR_LINE;

			/* -------------- Cursor Blink ------------- */

			pstEmuSettings->fCursorBlink =
				(int)IsDlgButtonChecked(hDlg, IDC_BLINK_CURSOR);

			EndDialog(hDlg, TRUE);
			break;

		case IDCANCEL:
			EndDialog(hDlg, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  emuVT52_SettingsDlgProc
 *
 * DESCRIPTION:
 *	VT52 Settings dialog proc.
 *
 * ARGUMENTS:
 *	Standard window proc parameters.
 *
 * RETURNS:
 *	Standerd return value.
 *
 */
INT_PTR CALLBACK emuVT52_SettingsDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
	PSTEMUSET	pstEmuSettings;
	static 		DWORD aHlpTable[] = {IDC_ALT_MODE,		   IDH_TERM_EMUSET_ALTMODE,
									 IDC_BLOCK_CURSOR,	   IDH_TERM_EMUSET_CURSOR,
									 IDC_UNDERLINE_CURSOR, IDH_TERM_EMUSET_CURSOR,
									 IDC_BLINK_CURSOR,	   IDH_TERM_EMUSET_CURSOR,
									 IDC_GR_CURSOR, 	   IDH_TERM_EMUSET_CURSOR,
                                     IDCANCEL,                           IDH_CANCEL,
                                     IDOK,                               IDH_OK,
									 0, 					0};

	switch (wMsg)
		{
	case WM_INITDIALOG:
		pstEmuSettings = (PSTEMUSET)lPar;
		SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pstEmuSettings);
		mscCenterWindowOnWindow(hDlg, GetParent(hDlg));

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
		/* -------------- Screen rows and columns ------------- */

		emudlgInitRowsCols(hDlg, pstEmuSettings);
#endif

		/* -------------- Alternate keypad mode ------------- */

		SendDlgItemMessage(hDlg, IDC_ALT_MODE, BM_SETCHECK,
			(unsigned int)pstEmuSettings->fAltKeypadMode, 0);

		/* -------------- Cursor characteristics ------------- */

		emudlgInitCursorSettings(hDlg, pstEmuSettings, IDC_UNDERLINE_CURSOR,
			IDC_BLOCK_CURSOR, IDC_BLINK_CURSOR);

		break;

	case WM_CONTEXTMENU:
		doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		break;

	case WM_HELP:
        doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_COMMAND:
		switch (wPar)
			{
		case IDOK:
			pstEmuSettings = (PSTEMUSET)GetWindowLongPtr(hDlg, GWLP_USERDATA);

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
			/* -------------- Screen rows and columns ------------- */

			emudlgGetRowColSettings(hDlg, pstEmuSettings);
#endif
			/* -------------- Alternate keypad mode ------------- */

			pstEmuSettings->fAltKeypadMode =
				(int)IsDlgButtonChecked(hDlg, IDC_ALT_MODE);

			/* -------------- Cursor type ------------- */

			pstEmuSettings->nCursorType =
				(int)IsDlgButtonChecked(hDlg, IDC_BLOCK_CURSOR) ?
					EMU_CURSOR_BLOCK : EMU_CURSOR_LINE;

			/* -------------- Cursor Blink ------------- */

			pstEmuSettings->fCursorBlink =
				(int)IsDlgButtonChecked(hDlg, IDC_BLINK_CURSOR);

			EndDialog(hDlg, TRUE);
			break;

		case IDCANCEL:
			EndDialog(hDlg, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  emuVT100_SettingsDlgProc
 *
 * DESCRIPTION:
 *	VT100 Settings dialog proc.
 *
 * ARGUMENTS:
 *	Standard window proc parameters.
 *
 * RETURNS:
 *	Standerd return value.
 *
 */
INT_PTR CALLBACK emuVT100_SettingsDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
	int			nIndex;
	PSTEMUSET	pstEmuSettings;
	static 		DWORD aHlpTable[] = {IDC_KEYPAD_MODE,	   IDH_TERM_EMUSET_KEYPADMODE,
									 IDC_CURSOR_MODE,	   IDH_TERM_EMUSET_CURSORMODE,
									 IDC_132_COLUMN,	   IDH_TERM_EMUSET_132COLUMNS,
									 IDC_GR_TERMINAL_MODES,IDH_TERM_EMUSET_MODES,
									 IDC_CHARACTER_SET,	   IDH_TERM_EMUSET_CHARSETS,
									 IDC_TF_CHARACTER_SET, IDH_TERM_EMUSET_CHARSETS,
									 IDC_BLOCK_CURSOR,	   IDH_TERM_EMUSET_CURSOR,
									 IDC_UNDERLINE_CURSOR, IDH_TERM_EMUSET_CURSOR,
									 IDC_BLINK_CURSOR,	   IDH_TERM_EMUSET_CURSOR,
									 IDC_GR_CURSOR, 	   IDH_TERM_EMUSET_CURSOR,
#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
									 IDC_GR_SCREEN,			IDH_TERM_EMUSET_ROWSANDCOLS,	
									 IDC_TF_ROWS,			IDH_TERM_EMUSET_ROWSANDCOLS,	
									 IDC_NUMBER_OF_ROWS,	IDH_TERM_EMUSET_ROWSANDCOLS,
									 IDC_TF_COLUMNS,		IDH_TERM_EMUSET_ROWSANDCOLS,
									 IDC_NUMBER_OF_COLS,	IDH_TERM_EMUSET_ROWSANDCOLS,
#endif
                                     IDCANCEL,                           IDH_CANCEL,
                                     IDOK,                               IDH_OK,
									 0, 					0};

	switch (wMsg)
		{
	case WM_INITDIALOG:
		pstEmuSettings = (PSTEMUSET)lPar;
		SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pstEmuSettings);
		mscCenterWindowOnWindow(hDlg, GetParent(hDlg));

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
		/* -------------- Screen rows and columns ------------- */

		emudlgInitRowsCols(hDlg, pstEmuSettings);
#endif

		/* -------------- Keypad application mode ------------- */

		SendDlgItemMessage(hDlg, IDC_KEYPAD_MODE, BM_SETCHECK,
			(unsigned int)pstEmuSettings->fKeypadAppMode, 0);

		/* -------------- Cursor keypad mode ------------- */

		SendDlgItemMessage(hDlg, IDC_CURSOR_MODE, BM_SETCHECK,
			(unsigned int)pstEmuSettings->fCursorKeypadMode, 0);

#if !defined(INCL_TERMINAL_SIZE_AND_COLORS)
		/* -------------- 132 Column Mode ------------- */

		SendDlgItemMessage(hDlg, IDC_132_COLUMN, BM_SETCHECK,
			(unsigned int)pstEmuSettings->f132Columns, 0);
#endif

		/* -------------- Host Print Mode ------------- */
		// mpt;04-22-00 added interface to control host-controlled printing
		SendDlgItemMessage(hDlg, IDC_PRINT_RAW, BM_SETCHECK,
			(unsigned int)pstEmuSettings->fPrintRaw, 0);

		/* -------------- Cursor characteristics ------------- */

		emudlgInitCursorSettings(hDlg, pstEmuSettings, IDC_UNDERLINE_CURSOR,
			IDC_BLOCK_CURSOR, IDC_BLINK_CURSOR);

		/* -------------- VT100 Character Sets ------------- */

		emudlgInitCharSetSetting(hDlg, pstEmuSettings,
				IDT_EMU_VT100_CHAR_SETS, EMU_CHARSET_ASCII);

		break;

	case WM_CONTEXTMENU:
		doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		break;

	case WM_HELP:
		doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_COMMAND:
		switch (wPar)
			{
		case IDOK:
			pstEmuSettings = (PSTEMUSET)GetWindowLongPtr(hDlg, GWLP_USERDATA);

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
			/* -------------- Screen rows and columns ------------- */

			emudlgGetRowColSettings(hDlg, pstEmuSettings);
#endif
			/* -------------- Keypad Application mode ------------- */

			pstEmuSettings->fKeypadAppMode =
				(int)IsDlgButtonChecked(hDlg, IDC_KEYPAD_MODE);

			/* -------------- Cursor Keypad Mode ------------- */

			pstEmuSettings->fCursorKeypadMode =
				(int)IsDlgButtonChecked(hDlg, IDC_CURSOR_MODE);

#if !defined(INCL_TERMINAL_SIZE_AND_COLORS)
			/* -------------- 132 Column Mode ------------- */

			pstEmuSettings->f132Columns =
				(int)IsDlgButtonChecked(hDlg, IDC_132_COLUMN);
#endif

			/* -------------- Host Print Mode ------------- */
			//mpt:04-22-00
			pstEmuSettings->fPrintRaw =
				(int)IsDlgButtonChecked(hDlg, IDC_PRINT_RAW);

			/* -------------- Cursor type ------------- */

			pstEmuSettings->nCursorType =
				(int)IsDlgButtonChecked(hDlg, IDC_BLOCK_CURSOR) ?
					EMU_CURSOR_BLOCK : EMU_CURSOR_LINE;

			/* -------------- Cursor Blink ------------- */

			pstEmuSettings->fCursorBlink =
				(int)IsDlgButtonChecked(hDlg, IDC_BLINK_CURSOR);

			/* -------------- VT100 Character Set ------------- */

            nIndex = (int)SendDlgItemMessage(hDlg, IDC_CHARACTER_SET, CB_GETCURSEL, 0, 0);
            assert(nIndex != CB_ERR);

            //JMH 01-09-97 Get the nCharacterSet value associated with this entry
            //
            pstEmuSettings->nCharacterSet =
                (int)SendDlgItemMessage(hDlg, IDC_CHARACTER_SET, CB_GETITEMDATA,
                    (WPARAM) nIndex, (LPARAM) 0);
            assert(pstEmuSettings->nCharacterSet != CB_ERR);

			EndDialog(hDlg, TRUE);
			break;

		case IDCANCEL:
			EndDialog(hDlg, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  emuVT100J_SettingsDlgProc
 *
 * DESCRIPTION:
 *	VT100 Settings dialog proc.
 *
 * ARGUMENTS:
 *	Standard window proc parameters.
 *
 * RETURNS:
 *	Standerd return value.
 *
 */
INT_PTR CALLBACK emuVT100J_SettingsDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
	PSTEMUSET	pstEmuSettings;
	int			nIndex;
	static 		DWORD aHlpTable[] = {IDC_KEYPAD_MODE,	   IDH_TERM_EMUSET_KEYPADMODE,
									 IDC_CURSOR_MODE,	   IDH_TERM_EMUSET_CURSORMODE,
									 IDC_132_COLUMN,	   IDH_TERM_EMUSET_132COLUMNS,
									 IDC_GR_TERMINAL_MODES,IDH_TERM_EMUSET_MODES,
									 IDC_CHARACTER_SET,	   IDH_TERM_EMUSET_CHARSETS,
									 IDC_TF_CHARACTER_SET, IDH_TERM_EMUSET_CHARSETS,
									 IDC_BLOCK_CURSOR,	   IDH_TERM_EMUSET_CURSOR,
									 IDC_UNDERLINE_CURSOR, IDH_TERM_EMUSET_CURSOR,
									 IDC_BLINK_CURSOR,	   IDH_TERM_EMUSET_CURSOR,
									 IDC_GR_CURSOR, 	   IDH_TERM_EMUSET_CURSOR,
                                     IDCANCEL,                           IDH_CANCEL,
                                     IDOK,                               IDH_OK,
									 0, 					0};

	switch (wMsg)
		{
	case WM_INITDIALOG:
		pstEmuSettings = (PSTEMUSET)lPar;
		SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pstEmuSettings);
		mscCenterWindowOnWindow(hDlg, GetParent(hDlg));

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
		/* -------------- Screen rows and columns ------------- */

		emudlgInitRowsCols(hDlg, pstEmuSettings);
#endif

		/* -------------- Keypad application mode ------------- */

		SendDlgItemMessage(hDlg, IDC_KEYPAD_MODE, BM_SETCHECK,
			(unsigned int)pstEmuSettings->fKeypadAppMode, 0);

		/* -------------- Cursor keypad mode ------------- */

		SendDlgItemMessage(hDlg, IDC_CURSOR_MODE, BM_SETCHECK,
			(unsigned int)pstEmuSettings->fCursorKeypadMode, 0);

#if !defined(INCL_TERMINAL_SIZE_AND_COLORS)
		/* -------------- 132 Column Mode ------------- */

		SendDlgItemMessage(hDlg, IDC_132_COLUMN, BM_SETCHECK,
			(unsigned int)pstEmuSettings->f132Columns, 0);
#endif

		/* -------------- Host Print Mode ------------- */
		//mpt:04-22-00
		SendDlgItemMessage(hDlg, IDC_PRINT_RAW, BM_SETCHECK,
			(unsigned int)pstEmuSettings->fPrintRaw, 0);

		/* -------------- Cursor characteristics ------------- */

		emudlgInitCursorSettings(hDlg, pstEmuSettings, IDC_UNDERLINE_CURSOR,
			IDC_BLOCK_CURSOR, IDC_BLINK_CURSOR);

		/* -------------- VT100 Character Sets ------------- */

		emudlgInitCharSetSetting(hDlg, pstEmuSettings,
				IDT_EMU_VT100_CHAR_SETS, EMU_CHARSET_ASCII);

		break;

	case WM_CONTEXTMENU:
		doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		break;

	case WM_HELP:
        doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_COMMAND:
		switch (wPar)
			{
		case IDOK:
			pstEmuSettings = (PSTEMUSET)GetWindowLongPtr(hDlg, GWLP_USERDATA);

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
			/* -------------- Screen rows and columns ------------- */

			emudlgGetRowColSettings(hDlg, pstEmuSettings);
#endif
			/* -------------- Keypad Application mode ------------- */

			pstEmuSettings->fKeypadAppMode =
				(int)IsDlgButtonChecked(hDlg, IDC_KEYPAD_MODE);

			/* -------------- Cursor Keypad Mode ------------- */

			pstEmuSettings->fCursorKeypadMode =
				(int)IsDlgButtonChecked(hDlg, IDC_CURSOR_MODE);

#if !defined(INCL_TERMINAL_SIZE_AND_COLORS)
			/* -------------- 132 Column Mode ------------- */

			pstEmuSettings->f132Columns =
				(int)IsDlgButtonChecked(hDlg, IDC_132_COLUMN);
#endif
			/* -------------- Host Print Mode ------------- */

			pstEmuSettings->fPrintRaw =
				(int)IsDlgButtonChecked(hDlg, IDC_PRINT_RAW);

			/* -------------- Cursor type ------------- */

			pstEmuSettings->nCursorType =
				(int)IsDlgButtonChecked(hDlg, IDC_BLOCK_CURSOR) ?
					EMU_CURSOR_BLOCK : EMU_CURSOR_LINE;

			/* -------------- Cursor Blink ------------- */

			pstEmuSettings->fCursorBlink =
				(int)IsDlgButtonChecked(hDlg, IDC_BLINK_CURSOR);

			/* -------------- VT100 Character Set ------------- */

            nIndex = (int)SendDlgItemMessage(hDlg, IDC_CHARACTER_SET, CB_GETCURSEL, 0, 0);
            assert(nIndex != CB_ERR);

            //JMH 01-09-97 Get the nCharacterSet value associated with this entry
            //
            pstEmuSettings->nCharacterSet =
                (int)SendDlgItemMessage(hDlg, IDC_CHARACTER_SET, CB_GETITEMDATA,
                    (WPARAM) nIndex, (LPARAM) 0);
            assert(pstEmuSettings->nCharacterSet != CB_ERR);

			EndDialog(hDlg, TRUE);
			break;

		case IDCANCEL:
			EndDialog(hDlg, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}

#if defined(INCL_VT220)
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  emuVT220_SettingsDlgProc
 *
 * DESCRIPTION:
 *	VT220 Settings dialog proc.
 *
 * ARGUMENTS:
 *	Standard window proc parameters.
 *
 * RETURNS:
 *	Standerd return value.
 *
 */
INT_PTR CALLBACK emuVT220_SettingsDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
	PSTEMUSET	pstEmuSettings;
	int			nIndex;
	static 		DWORD aHlpTable[] = {IDC_KEYPAD_MODE,			IDH_TERM_EMUSET_KEYPADMODE,
									 IDC_CURSOR_MODE,			IDH_TERM_EMUSET_CURSORMODE,
									 IDC_132_COLUMN,			IDH_TERM_EMUSET_132COLUMNS,
									 IDC_GR_TERMINAL_MODES,		IDH_TERM_EMUSET_MODES,
									 IDC_CHARACTER_SET,			IDH_TERM_EMUSET_CHARSETS,
									 IDC_TF_CHARACTER_SET,		IDH_TERM_EMUSET_CHARSETS,
									 IDC_BLOCK_CURSOR,			IDH_TERM_EMUSET_CURSOR,
									 IDC_UNDERLINE_CURSOR,		IDH_TERM_EMUSET_CURSOR,
									 IDC_BLINK_CURSOR,			IDH_TERM_EMUSET_CURSOR,
									 IDC_GR_CURSOR, 			IDH_TERM_EMUSET_CURSOR,
									 IDC_USE_8_BIT_CODES,		IDH_TERM_EMUSET_8BITCODES,			
									 IDC_ALLOW_USERDEFINED_KEYS,IDH_TERM_EMUSET_USERDEFKEYS,
									 IDC_PRINT_RAW,				IDH_TERM_EMUSET_PRINTRAW,
                                     IDCANCEL,                           IDH_CANCEL,
                                     IDOK,                               IDH_OK,
									 0, 						0};

	switch (wMsg)
		{
	case WM_INITDIALOG:
		pstEmuSettings = (PSTEMUSET)lPar;
		SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pstEmuSettings);
		mscCenterWindowOnWindow(hDlg, GetParent(hDlg));

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
		/* -------------- Screen rows and columns ------------- */

		emudlgInitRowsCols(hDlg, pstEmuSettings);
#endif
		/* -------------- Keypad application mode ------------- */

		SendDlgItemMessage(hDlg, IDC_KEYPAD_MODE, BM_SETCHECK,
			(unsigned int)pstEmuSettings->fKeypadAppMode, 0);

		/* -------------- Cursor keypad mode ------------- */

		SendDlgItemMessage(hDlg, IDC_CURSOR_MODE, BM_SETCHECK,
			(unsigned int)pstEmuSettings->fCursorKeypadMode, 0);

#if !defined(INCL_TERMINAL_SIZE_AND_COLORS)
		/* -------------- 132 Column Mode ------------- */

		SendDlgItemMessage(hDlg, IDC_132_COLUMN, BM_SETCHECK,
			(unsigned int)pstEmuSettings->f132Columns, 0);
#endif
		/* -------------- Host Print Mode ------------- */

		SendDlgItemMessage(hDlg, IDC_PRINT_RAW, BM_SETCHECK,
			(unsigned int)pstEmuSettings->fPrintRaw, 0);

		/* -------------- Cursor characteristics ------------- */

		emudlgInitCursorSettings(hDlg, pstEmuSettings, IDC_UNDERLINE_CURSOR,
			IDC_BLOCK_CURSOR, IDC_BLINK_CURSOR);

		/* -------------- 8 bit codes mode ------------- */

		SendDlgItemMessage(hDlg, IDC_USE_8_BIT_CODES, BM_SETCHECK,
			(unsigned int)pstEmuSettings->fUse8BitCodes, 0);

		/* -------------- User defined keys ------------- */

		SendDlgItemMessage(hDlg, IDC_ALLOW_USERDEFINED_KEYS, BM_SETCHECK,
			(unsigned int)pstEmuSettings->fAllowUserKeys, 0);

		/* -------------- VT220 Character Sets ------------- */

		emudlgInitCharSetSetting(hDlg, pstEmuSettings,
				IDT_EMU_VT220_CHAR_SETS, EMU_CHARSET_MULTINATIONAL);

		break;

	case WM_CONTEXTMENU:
		doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		break;

	case WM_HELP:
		doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_COMMAND:
		switch (wPar)
			{
		case IDOK:
			pstEmuSettings = (PSTEMUSET)GetWindowLongPtr(hDlg, GWLP_USERDATA);

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
			/* -------------- Screen rows and columns ------------- */

			emudlgGetRowColSettings(hDlg, pstEmuSettings);
#endif
			/* -------------- Keypad Application mode ------------- */

			pstEmuSettings->fKeypadAppMode =
				(int)IsDlgButtonChecked(hDlg, IDC_KEYPAD_MODE);

			/* -------------- Cursor Keypad Mode ------------- */

			pstEmuSettings->fCursorKeypadMode =
				(int)IsDlgButtonChecked(hDlg, IDC_CURSOR_MODE);

#if !defined(INCL_TERMINAL_SIZE_AND_COLORS)
			/* -------------- 132 Column Mode ------------- */

			pstEmuSettings->f132Columns =
				(int)IsDlgButtonChecked(hDlg, IDC_132_COLUMN);
#endif
			/* -------------- Host Print Mode ------------- */

			pstEmuSettings->fPrintRaw =
				(int)IsDlgButtonChecked(hDlg, IDC_PRINT_RAW);

			/* -------------- Cursor type ------------- */

			pstEmuSettings->nCursorType =
				(int)IsDlgButtonChecked(hDlg, IDC_BLOCK_CURSOR) ?
					EMU_CURSOR_BLOCK : EMU_CURSOR_LINE;

			/* -------------- Cursor Blink ------------- */

			pstEmuSettings->fCursorBlink =
				(int)IsDlgButtonChecked(hDlg, IDC_BLINK_CURSOR);

			/* -------------- 8 bit codes mode ------------- */

			pstEmuSettings->fUse8BitCodes =
					(int)IsDlgButtonChecked(hDlg, IDC_USE_8_BIT_CODES);

			/* -------------- User defined keys ------------- */

			pstEmuSettings->fAllowUserKeys =
					(int)IsDlgButtonChecked(hDlg, IDC_ALLOW_USERDEFINED_KEYS);

			/* -------------- VT220 Character Set ------------- */

            nIndex = SendDlgItemMessage(hDlg, IDC_CHARACTER_SET, CB_GETCURSEL, 0, 0);
            assert(nIndex != CB_ERR);

            //JMH 01-09-97 Get the nCharacterSet value associated with this entry
            //
            pstEmuSettings->nCharacterSet =
                SendDlgItemMessage(hDlg, IDC_CHARACTER_SET, CB_GETITEMDATA,
                    (WPARAM) nIndex, (LPARAM) 0);
            assert(pstEmuSettings->nCharacterSet != CB_ERR);

			EndDialog(hDlg, TRUE);
			break;

		case IDCANCEL:
			EndDialog(hDlg, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  emuMinitel_SettingsDlgProc
 *
 * DESCRIPTION:
 *	TTY Settings dialog proc.
 *
 * ARGUMENTS:
 *	Standard window proc parameters.
 *
 * RETURNS:
 *	Standerd return value.
 *
 */
INT_PTR CALLBACK emuMinitel_SettingsDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
	PSTEMUSET	pstEmuSettings;
	static 		DWORD aHlpTable[] = {IDC_DESTRUCTIVE_BKSP, IDH_TERM_EMUSET_DESTRUCTIVE,
									 IDC_BLOCK_CURSOR,	   IDH_TERM_EMUSET_CURSOR,
									 IDC_UNDERLINE_CURSOR, IDH_TERM_EMUSET_CURSOR,
									 IDC_BLINK_CURSOR,	   IDH_TERM_EMUSET_CURSOR,
									 IDC_GR_CURSOR, 	   IDH_TERM_EMUSET_CURSOR,
                                     IDCANCEL,             IDH_CANCEL,
                                     IDOK,                 IDH_OK,
									 0, 					0};

	switch (wMsg)
		{
	case WM_INITDIALOG:
		pstEmuSettings = (PSTEMUSET)lPar;
		SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pstEmuSettings);
		mscCenterWindowOnWindow(hDlg, GetParent(hDlg));

		/* -------------- Cursor characteristics ------------- */

		emudlgInitCursorSettings(hDlg, pstEmuSettings, IDC_UNDERLINE_CURSOR,
			IDC_BLOCK_CURSOR, IDC_BLINK_CURSOR);

		break;

	case WM_CONTEXTMENU:
		doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		break;

	case WM_HELP:
        doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_COMMAND:
		switch (wPar)
			{
		case IDOK:
			pstEmuSettings = (PSTEMUSET)GetWindowLongPtr(hDlg, GWLP_USERDATA);

			/* -------------- Cursor type ------------- */

			pstEmuSettings->nCursorType =
				(int)IsDlgButtonChecked(hDlg, IDC_BLOCK_CURSOR) ?
					EMU_CURSOR_BLOCK : EMU_CURSOR_LINE;

			/* -------------- Cursor Blink ------------- */

			pstEmuSettings->fCursorBlink =
				(int)IsDlgButtonChecked(hDlg, IDC_BLINK_CURSOR);

			EndDialog(hDlg, TRUE);
			break;

		case IDCANCEL:
			EndDialog(hDlg, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  emuViewdata_SettingsDlgProc
 *
 * DESCRIPTION:
 *	TTY Settings dialog proc.
 *
 * ARGUMENTS:
 *	Standard window proc parameters.
 *
 * RETURNS:
 *	Standerd return value.
 *
 */
INT_PTR CALLBACK emuViewdata_SettingsDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
	PSTEMUSET	pstEmuSettings;
	static 		DWORD aHlpTable[] = {IDC_DESTRUCTIVE_BKSP,  IDH_TERM_EMUSET_DESTRUCTIVE,
									 IDC_BLOCK_CURSOR,	    IDH_TERM_EMUSET_CURSOR,
									 IDC_UNDERLINE_CURSOR,  IDH_TERM_EMUSET_CURSOR,
									 IDC_BLINK_CURSOR,	    IDH_TERM_EMUSET_CURSOR,
									 IDC_GR_CURSOR, 	    IDH_TERM_EMUSET_CURSOR,
							         IDC_SEND_POUND_SYMBOL, IDH_TERM_SETTING_ENTER,
                                     IDC_HIDE_CURSOR,       IDH_TERM_SETTING_HIDE_CURSOR,
                                     IDCANCEL,              IDH_CANCEL,
                                     IDOK,                  IDH_OK,
		                             0,0};

	switch (wMsg)
		{
	case WM_INITDIALOG:
		pstEmuSettings = (PSTEMUSET)lPar;
		SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pstEmuSettings);
		mscCenterWindowOnWindow(hDlg, GetParent(hDlg));

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
		/* -------------- Screen rows and columns ------------- */

		emudlgInitRowsCols(hDlg, pstEmuSettings);
#endif
		/* -------------- Hide cursor ------------- */

		SendDlgItemMessage(hDlg, IDC_HIDE_CURSOR, BM_SETCHECK,
			(pstEmuSettings->nCursorType == EMU_CURSOR_NONE) ? 1 : 0,
			0);

		/* -------------- Enter key sends # ------------- */

		SendDlgItemMessage(hDlg, IDC_SEND_POUND_SYMBOL, BM_SETCHECK,
			(pstEmuSettings->fLbSymbolOnEnter == TRUE) ? 1 : 0, 0);

		break;

	case WM_CONTEXTMENU:
		doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		break;

	case WM_HELP:
        doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_COMMAND:
		switch (wPar)
			{
		case IDOK:
			pstEmuSettings = (PSTEMUSET)GetWindowLongPtr(hDlg, GWLP_USERDATA);

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
			/* -------------- Screen rows and columns ------------- */

			emudlgGetRowColSettings(hDlg, pstEmuSettings);
#endif
			/* -------------- Hide cursor ------------- */

			pstEmuSettings->nCursorType =
				(int)IsDlgButtonChecked(hDlg, IDC_HIDE_CURSOR) ?
					EMU_CURSOR_NONE : EMU_CURSOR_LINE;
			
			/* -------------- Enter key sends # ------------- */

			pstEmuSettings->fLbSymbolOnEnter =
				(int)IsDlgButtonChecked(hDlg, IDC_SEND_POUND_SYMBOL) ?
					TRUE : FALSE;

			EndDialog(hDlg, TRUE);
			break;

		case IDCANCEL:
			EndDialog(hDlg, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  emudlgInitCursorSettings
 *
 * DESCRIPTION:
 *	Initialize cursor settings.
 *
 * ARGUMENTS:
 * 	hDlg - dialog window.
 *	pstEmuSettings 	- pointer to the emulator settings structure.
 *
 * RETURNS:
 *	void.
 *
 */
STATIC_FUNC void emudlgInitCursorSettings(HWND  hDlg,
									      PSTEMUSET pstEmuSettings,
									      INT  ID_UNDERLINE,
									      INT  ID_BLOCK,
									      INT  ID_BLINK)
	{
	int i;

	switch (pstEmuSettings->nCursorType)
		{
	case EMU_CURSOR_LINE:   i = ID_UNDERLINE;	break;
	case EMU_CURSOR_BLOCK: 	i = ID_BLOCK;		break;
	default:				i = ID_UNDERLINE;	break;
		}

	SendDlgItemMessage(hDlg, i, BM_SETCHECK, 1, 0);

	SendDlgItemMessage(hDlg, ID_BLINK, BM_SETCHECK,
		(unsigned int)pstEmuSettings->fCursorBlink, 0);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  emudlgInitCharSetSetting
 *
 * DESCRIPTION:
 *	Initialize the character set setting.
 *
 * ARGUMENTS:
 * 	hDlg - dialog window.
 *	pstEmuSettings 	- pointer to the emulator settings structure.
 *
 * RETURNS:
 *	void.
 *
 * AUTHOR: Bob Everett - 3 Jun 98
 */
STATIC_FUNC void emudlgInitCharSetSetting(HWND  hDlg,
											PSTEMUSET pstEmuSettings,
											int nCharSetTableID,
											int nDefaultCharSetID)
	{
	BOOL	fResult = TRUE;
	int		nLen, nIndex;
	BYTE   *pb, *pbSel;

	if (resLoadDataBlock(glblQueryDllHinst(), nCharSetTableID,
			(LPVOID *)&pb, &nLen))
		{
		assert(FALSE);
		}
	else
		{
		if (!emudlgFindCharSetName(hDlg, pb, pstEmuSettings->nCharacterSet,
				(LPTSTR *)&pbSel, TRUE))
			{
			// Couldn't find the current character set in the table of
			// characters sets. This happens when switching from one
			// terminal type to another that doesn't contain the char
			// set.	Use the default character set.
			pstEmuSettings->nCharacterSet = nDefaultCharSetID;
			if (!emudlgFindCharSetName(hDlg, pb, pstEmuSettings->nCharacterSet,
					(LPTSTR *)&pbSel, FALSE))
				{
				// We've got problems.
				fResult = FALSE;
				assert(FALSE);
				}
			}

		if (fResult)
			{
			//JMH 01-09-97 Now select the string corresponding to
			// nCharacterSet.
	        nIndex = (int)SendDlgItemMessage(hDlg, IDC_CHARACTER_SET,
					CB_SELECTSTRING, 0, (LPARAM)(LPTSTR)pbSel);
			assert(nIndex != CB_ERR);
			}
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  emudlgFindCharSetName
 *
 * DESCRIPTION:
 *	Finds the appropriate character set settings.
 *
 * ARGUMENTS:
 *	hDlg - dialog window handle
 * 	pbCharSetTable - address of the emu's table of character sets
 *	pszCharSetName - address at which to put the char set name
 *	fTellDlg - TRUE if the dialog should be made aware of the table
 *
 * RETURNS:
 *	TRUE if successful, FALSE if not.
 *
 * AUTHOR: Bob Everett - 3 Jun 98
 */
STATIC_FUNC BOOL emudlgFindCharSetName(HWND  hDlg,
										BYTE *pbCharSetTable,
										int nCharSetID,
										LPTSTR *ppszCharSetName,
										BOOL fTellDlg)
	{
	BOOL	fRetVal = FALSE;
	int		nCnt, nLen, nEmuCount, nIndex, nCharSet;
	BYTE	*pb = pbCharSetTable;

	nEmuCount = *(RCDATA_TYPE *)pb;
	pb += sizeof(RCDATA_TYPE);

	for (nCnt = 0 ; nCnt < nEmuCount; nCnt++)
		{
		nLen = StrCharGetByteCount((LPTSTR)pb) + (int)sizeof(BYTE);

		if (fTellDlg)
			{
			nIndex = (int)SendDlgItemMessage(hDlg, IDC_CHARACTER_SET, CB_ADDSTRING, 0,
					(LPARAM)(LPTSTR)pb);
			assert(nIndex != CB_ERR);
			}

		#if FALSE	// DEADWOOD:rde 10 Mar 98
        //JMH 01-09-97 Because this list gets sorted, we have to store the
        // table index with each entry, or else the selection index we get
        // when OK is pressed won't mean much.
        //
        nIndex = SendDlgItemMessage(hDlg, IDC_CHARACTER_SET, CB_SETITEMDATA,
            (WPARAM) nIndex, (LPARAM) i);
        assert(nIndex != CB_ERR);
		#endif
		// Save the real char set id with the string. rde 10 Mar 98
		nCharSet = *((RCDATA_TYPE *)(pb + nLen));

		if (fTellDlg)
			{
			nIndex = (int)SendDlgItemMessage(hDlg, IDC_CHARACTER_SET, CB_SETITEMDATA,
					(WPARAM)nIndex, (LPARAM)nCharSet);
			assert(nIndex != CB_ERR);
			}

		// Must match the char set id to nCharacterSet, not the order in
		// which they're listed in the resource data block. rde 10 Mar 98
		//if (i == pstEmuSettings->nCharacterSet)
		if (nCharSet == nCharSetID)
            {
            //JMH 01-09-97 Store a pointer to the string corresponding to
            // nCharacterSet, so we can select the appropriate entry after
            // they've all been sorted.
            //
            *ppszCharSetName = (LPTSTR)pb;
			fRetVal = TRUE;
            }

		pb += (nLen + (int)sizeof(RCDATA_TYPE));
		}

	return fRetVal;
	}

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  emudlgInitRowsCols
 *
 * DESCRIPTION:
 *  Sets up the row and column fields.
 *
 * ARGUMENTS:
 *  hDlg - edit control window.
 *	pstEmuSettings - address of emulator settings structure.
 *
 * RETURNS:
 *  void.
 *
 * AUTHOR: Bob Everett - 22 Jun 1998
 */
STATIC_FUNC void emudlgInitRowsCols(HWND hDlg, PSTEMUSET pstEmuSettings)
	{
	TCHAR		achString[20];
	TCHAR		achFormat[20];

	SendDlgItemMessage(hDlg, IDC_NUMBER_OF_ROWS, EM_LIMITTEXT, 2, 0);

	LoadString(glblQueryDllHinst(), IDS_XD_INT, achFormat,
			sizeof(achFormat) / sizeof(TCHAR));
	TCHAR_Fill(achString, TEXT('\0'), sizeof(achString) / sizeof(TCHAR));
	wsprintf(achString, achFormat, pstEmuSettings->nUserDefRows);
	SendDlgItemMessage(hDlg, IDC_NUMBER_OF_ROWS, WM_SETTEXT, 0,
			(LPARAM)(LPTSTR)achString);

	SendDlgItemMessage(hDlg, IDC_NUMBER_OF_COLS, EM_LIMITTEXT, 3, 0);

	LoadString(glblQueryDllHinst(), IDS_XD_INT, achFormat,
			sizeof(achFormat) / sizeof(TCHAR));
	TCHAR_Fill(achString, TEXT('\0'), sizeof(achString) / sizeof(TCHAR));
	wsprintf(achString, achFormat, pstEmuSettings->nUserDefCols);
	SendDlgItemMessage(hDlg, IDC_NUMBER_OF_COLS, WM_SETTEXT, 0,
			(LPARAM)(LPTSTR)achString);

	// Put the spin buttons on the row and column fields.
	emudlgCreateUpDownControl(hDlg, pstEmuSettings);
	}
#endif

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  emudlgCreateUpDownControl
 *
 * DESCRIPTION:
 *  Gets the final row and column settings.
 *
 * ARGUMENTS:
 *  hDlg - edit control window.
 *	pstEmuSettings - address of emulator settings structure.
 *
 * RETURNS:
 *  void.
 *
 * AUTHOR: Bob Everett - 22 Jun 1998
 */
STATIC_FUNC void emudlgGetRowColSettings(HWND hDlg, PSTEMUSET pstEmuSettings)
	{
	pstEmuSettings->nUserDefRows = emudlgValidateEntryFieldSetting(hDlg,
			IDC_NUMBER_OF_ROWS, MIN_EMUROWS, MAX_EMUROWS);

	pstEmuSettings->nUserDefCols = emudlgValidateEntryFieldSetting(hDlg,
			IDC_NUMBER_OF_COLS, MIN_EMUCOLS, MAX_EMUCOLS);

	pstEmuSettings->f132Columns =
			(pstEmuSettings->nUserDefCols == 132 ? TRUE : FALSE);
	}
#endif

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  emudlgCreateUpDownControl
 *
 * DESCRIPTION:
 *  This function puts an up-down control on the edit field for the row and
 *	column fields. This gives us bounds checking for free... just set the
 *	appropriate parameters in the CreateUpDownControl call.
 *
 *	NOTE: This is a duplicate of CreateUpDownControl
 *
 * ARGUMENTS:
 *  hDlg - edit control window.
 *
 * RETURNS:
 *  void.
 *
 * AUTHOR: Bob Everett - 8 Jun 1998
 */
STATIC_FUNC void emudlgCreateUpDownControl(HWND hDlg, PSTEMUSET pstEmuSettings)
	{
	RECT	rc;
	int		nHeight, nWidth;
	DWORD	dwFlags;
	HWND	hwndChild;

    // Draw a spin control for the rows field.
    GetClientRect(GetDlgItem(hDlg, IDC_NUMBER_OF_ROWS), &rc);
	nHeight = rc.top - rc.bottom;
	nWidth = (nHeight / 3) * 2;

	dwFlags = WS_CHILD       | WS_VISIBLE |
			  UDS_ALIGNRIGHT | UDS_ARROWKEYS | UDS_SETBUDDYINT;

	hwndChild = CreateUpDownControl(
					dwFlags,			// create window flags
					rc.right,			// left edge
					rc.top,				// top edge
					nWidth,				// width
					nHeight,			// height
					hDlg,				// parent window
					IDC_EDIT_ROWS,
					(HINSTANCE)GetWindowLong(hDlg, GWL_HINSTANCE),
					GetDlgItem(hDlg, IDC_NUMBER_OF_ROWS),
					MAX_EMUROWS,
					MIN_EMUROWS,
					pstEmuSettings->nUserDefRows);

    // Repeat for the columns field.
    GetClientRect(GetDlgItem(hDlg, IDC_NUMBER_OF_COLS), &rc);
	nHeight = rc.top - rc.bottom;
	nWidth = (nHeight / 3) * 2;

	hwndChild = CreateUpDownControl(
					dwFlags,			// create window flags
					rc.right,			// left edge
					rc.top,				// top edge
					nWidth,				// width
					nHeight,			// height
					hDlg,				// parent window
					IDC_EDIT_COLUMNS,
					(HINSTANCE)GetWindowLong(hDlg, GWL_HINSTANCE),
					GetDlgItem(hDlg, IDC_NUMBER_OF_COLS),
					MAX_EMUCOLS,
					MIN_EMUCOLS,
					pstEmuSettings->nUserDefCols);    			

    assert(hwndChild);
	}
#endif

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  emudlgValidateEntryFieldSetting
 *
 * DESCRIPTION:
 *  If the user entered a value outside of the range we support force the
 *	value into the range.
 *
 *	Note: copied from propValidateBackscrlSize.
 *
 * ARGUMENTS:
 *  hDlg - dialog window handle.
 *
 * RETURNS:
 *  nNewValue - number of lines to keep in the backscrol buffer.
 *
 * AUTHOR: Bob Everett - 8 Jun 1998
 */
STATIC_FUNC int emudlgValidateEntryFieldSetting(HWND hDlg,
										int nIDC,
										int nMinVal,
										int nMaxVal)
	{
	int		nValue = 0, nNewValue = 0;
	TCHAR	achStrEntered[20], achFormat[20];

	TCHAR_Fill(achStrEntered, TEXT('\0'), sizeof(achStrEntered) / sizeof(TCHAR));
	GetDlgItemText(hDlg, nIDC, achStrEntered, sizeof(achStrEntered));

	nNewValue = nValue = atoi(achStrEntered);
	if (nValue > nMaxVal)
		nNewValue = nMaxVal;
	else if (nValue < nMinVal)
		nNewValue = nMinVal;

	if (nNewValue != nValue)
		{
		LoadString(glblQueryDllHinst(),
					IDS_XD_INT,
					achFormat,
					sizeof(achFormat) / sizeof(TCHAR));
		TCHAR_Fill(achStrEntered,
					TEXT('\0'),
					sizeof(achStrEntered) / sizeof(TCHAR));
		wsprintf(achStrEntered, achFormat, nNewValue);
		SendDlgItemMessage(hDlg,
					nIDC,
					WM_SETTEXT,
					0,
					(LPARAM)(LPTSTR)achStrEntered);
		}

	return (nNewValue);
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\emustate.c ===
/*	File: D:\WACKER\emu\vidstate.c (Created: 08-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:28p $
 */

#include <windows.h>

#include <tdll\stdtyp.h>
#include "emu.h"
#include "emu.hh"

int iCurAttrState;

STATTR attrState[2] =
	{
	{VC_WHITE, VC_BLACK},	// CS_STATE
	{VC_WHITE, VC_BLACK}	// CSCLEAR_STATE
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\emuid.h ===
/*	File: D:\WACKER\emu\emuid.h (Created: 08-Dec-1993)
 *
 *	Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:27p $
 */

#define IDT_BASE 0xD00 // = 3328 in decimal

// Table identifiers should be prefixed with "IDT" meaning ID Table.
// Interestingly, the RC compiler won't do integer math on RCDATA
// indentifiers so I have to hard code the numbers.  Actually, its
// worse than that, it can't even read 0x000 format numbers!  They
// have to be decimal.	Stupid!!!

//#define IDT_EMU_NAMES 			  3328

#define IDT_EMU_VT100_CHAR_SETS 	3383
#define IDT_EMU_NAT_CHAR_SETS		3384

#define IDT_ANSI_KEYS				3385

#define IDT_VT_MAP_PF_KEYS			3386

#define IDT_VT52_KEYS				3387
#define IDT_VT52_KEYPAD_APP_MODE	3388

#define IDT_VT100_KEYS				3389
#define IDT_VT100_CURSOR_KEY_MODE	3390
#define IDT_VT100_KEYPAD_APP_MODE	3391

#define IDT_VT220_KEYS				3392
#define IDT_VT220_CURSOR_KEY_MODE	3393
#define IDT_VT220_KEYPAD_APP_MODE	3394
#define IDT_VT220_MAP_PF_KEYS_MODE	3395

#define IDT_TV950_KEYS				3396
#define IDT_TV950_FKEYS 			3397
#define IDT_WANG_KEYS				3398
#define IDT_IBM3278_KEYS			3399
#define IDT_RENX3278_KEYS			3400
#define IDT_IBM3101_KEYS			3401
#define IDT_IBMPC_KEYS				3402

#define IDT_MINITEL_KEYS			3403

#define IDT_EMU_VT220_CHAR_SETS 	3404
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\emu.hh ===
/*	File: D:\WACKER\emu\emu.hh (Created: 08-Dec-1993)
 *
 *	Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 5 $
 *	$Date: 3/07/01 9:38a $
 */
typedef struct stEmuInternal *HHEMU;

// Maximum column definitions.
// They're one more than zero base maximums.  Lines won't
// wrap until next char is displayed.
//
#define VT_MAXCOL_80MODE	79
#define VT_MAXCOL_132MODE	131

// Define terminal modes using ANSI terminology.
//
#define SET TRUE
#define RESET FALSE

// Character constants.
//
#define SOH 	001
#define STX 	002
#define ETX 	003
#define EOT 	004
#define ENQ 	005
#define ACK 	006
#define BELL	007
#define BS		010
#define LF		012
#define FF		014
#define RET 	015
#define DLE 	020
#define DC3 	023
#define NAK 	025
#define CAN 	030
#define ESC 	033
#define DEL 	177
#define IND 	204
#define SS3 	217
#define CSI 	233

// Definitions for double high, double wide character processing.
//
#define NO_LINE_ATTR			0
#define DBL_WIDE_HI 			1
#define DBL_WIDE_LO 			2
#define DBL_WIDE_SINGLE_HEIGHT	3

#define MAX_STATE		35	/* Maximum states in FSA */
#define MAX_TRANSITION 200	/* Maximum state-to-state transitions */
#define MAX_NUM_PARAM	10	/* Max # numeric parameters in one cmd */
#define MAX_SELECTOR	10	/* Max # selectors in one terminal command */
#define NEW_STATE	   255	/* Special marker to indicate new state */

#define CLEAR_CURSOR_TO_SCREEN_END      0
#define CLEAR_SCREEN_START_TO_CURSOR    1
#define CLEAR_ENTIRE_SCREEN             2

#define CLEAR_CURSOR_TO_LINE_END		0
#define CLEAR_LINE_START_TO_CURSOR		1
#define CLEAR_ENTIRE_LINE				2

#define CLEAR_TAB_AT_CURSOR             0
#define CLEAR_TABS_IN_LINE              3

#define CS_STATE		 0
#define CSCLEAR_STATE	 1

#define EMU_BLANK_LINE	(-1)
#define EMU_BLANK_CHAR	TEXT('\x20')

// Key table definitions.
//
#define VK_BACKSPACE	(VK_BACK   | VIRTUAL_KEY)
#define DELETE_KEY		(VK_DELETE | VIRTUAL_KEY)
#define DELETE_KEY_EXT	(VK_DELETE | VIRTUAL_KEY | EXTENDED_KEY)

/* -------------- Key Table Transalation ------------- */

typedef struct
	{
	int key;
	int fPointer;	// TRUE means we use the CHAR * portion of the union.
	int uLen;		// length of stored keystring.
	union
		{
		TCHAR	achKeyStr[sizeof(LPTSTR)]; // want real chars here.
		TCHAR  *pachKeyStr; 			  // want real chars here.
		} u;
	} KEY;

typedef KEY * PSTKEY;

typedef struct
	{
	int 	  iMaxKeys;
	PSTKEY	  pstKeys;
	} KEYTABLE;

typedef KEYTABLE * PSTKEYTABLE;

typedef struct KeyTblStorage
    {
	int KeyCode; 
	TCHAR achKeyStr[15];
	} KEYTBLSTORAGE;

typedef struct emuNameTable
	{
	TCHAR	acName[EMU_MAX_NAMELEN];
	int 	nEmuId;
	} STEMUNAMETABLE;

typedef STEMUNAMETABLE * PSTEMUNAMETABLE;

/* Define the Finite State Automaton (FSA) which parses commands.
 * There is an array of states which points into an array of transitions
 * from that state.
 */

struct state_entry
	{
	struct trans_entry *first_trans;	/* Pointer into transition array */
	int number_trans;				  /* Number of paths out of state */
	};

struct trans_entry
	{
	int next_state; 				  /* Next state after match */
	ECHAR lochar, hichar;				/* Match range of input chars */
	void (*funct_ptr)(const HHEMU hhEmu);			 /* Pointer to function */
	};

// The internal Emulator Handle
//
struct stEmuInternal
	{
	CRITICAL_SECTION csEmu; 		// Used to synchronize access

	void *pvPrivate;
						 
	HSESSION hSession;				// Session hdl that created this.

	HPRINT	hPrintEcho, 			// Print hdl for Printer Echo.
			hPrintHost; 			// Print hdl for Host directed printing.

	TCHAR	acAnswerback[21];

	PSTEMUNAMETABLE pstNameTable;

	int 	nEmuLoaded, 			// Identifies the emulator that is
									// currently loaded.  Use in emuLoad
									// to determine if requested emulator
									// is already loaded.
			iCurType,				// cursor type
			fWasConnected;			// used with auto attempts


	STEMUSET	stUserSettings; 	// Contains all the settings made by the 
									// user. They are initilaized from values
									// stored in the session file.

	// Variables for state table processing.
	//
	struct state_entry state_tbl[MAX_STATE];
	struct trans_entry trans_tbl[MAX_TRANSITION];

	int state,						/* State table state			*/
		num_param[MAX_NUM_PARAM],	/* Numeric valued parameters	*/
		num_param_cnt,				/* Number of parameters 		*/
		selector[MAX_SELECTOR], 	/* (Hex) option selectors		*/
		selector_cnt;				/* Number of selectors			*/

	ECHAR	emu_code,				/* current character to process */
			emu_highchar;			/* highest CHAR to bypass state table */

	// Keyboard processing tables and variables.
	//
	KEYTABLE stEmuKeyTbl,					/* the dreaded keytable 		*/
			 stEmuKeyTbl2,					/* modal keytable				*/
			 stEmuKeyTbl3,					/* modal keytable				*/
			 stEmuKeyTbl4;					/* modal keytable 				*/

	// Character attribute state information.
	//
	int iCurAttrState;

	STATTR attrState[2];

	// Virtual image variables
	//
	int emu_maxrow, 			/* maximum virtual row of emulator */
		emu_maxcol, 			/* maximum virtual column of emualtor */
		emu_currow, 			/* emulator's cursor row */
		emu_curcol, 			/* emulator's cursor column */
		emu_imgtop, 			/* line in image array of screen row 0 */
		emu_imgrow, 			/* line in image array of cursor */
		top_margin,
		bottom_margin,
		scr_scrollcnt;			/* Keeps track of screen scrolls */

	// Is the loaded emulator DBCS Enabled
	int	fDBCSSupported;			/* Emulator is DBCS Enabled	True\False. */

	// JFH:2/22/95 TCHAR	dspchar[256];		/* Character display map */
	ECHAR	dspchar[256];		/* Character display map */

	int 	tab_stop[MAX_EMUCOLS + 1],
			print_echo;

	// Pointers to text, attribute and end of line arrays.
	//
	ECHAR	*(*emu_apText);
	PSTATTR *emu_apAttr;
	int 	*emu_aiEnd;

	// Character attribute variables.
	//
	STATTR	emu_clearattr,			 /* current CHAR attribute for clearing */
			emu_clearattr_sav,		 /* Used for HA/Win - mrw */
			emu_charattr;			 /* current physical character attribute */

	// Emulator mode variables
	//
	int mode_KAM,		/* Keyboard Action Mode. RESET=enabled					*/
		mode_IRM,		/* Insertion-Replacement. RESET=replace chars			*/
		mode_VEM,		/* Vertical Editing. RESET=ins/del lines below cursor	*/
		mode_HEM,		/* Horizontal Editing. RESET=ins/del chars after cursor */
		mode_SRM,		/* Send-Receive. RESET=local character echo 			*/
		mode_AWM,		/* AutoWrap (not ANSI). RESET=wrap to next line 		*/
		mode_LNM,		/* Line feed New line. RESET=LF moves vertically only	*/
		mode_DECCKM,	/* cursor key codes. RESET=cursor, SET=application		*/
		mode_DECKPAM,	/* keypad key codeas. RESET=numeric, SET=application	*/
		mode_DECOM, 	/* DEC origin mode. RESET=cursor posn screen relative	*/
		mode_DECCOLM,	/* DEC column mode. RESET=80 column display 			*/
		mode_DECPFF,	/* Print form feed. RESET=OFF							*/
		mode_DECPEX,	/* Print extent. RESET=scroll rgn., SET=full screen 	*/
		mode_DECSCNM,	/* Screen mode. RESET=normal video, SET=reverse video	*/
		mode_DECTCEM,	/* Cursor enable. RESET=hidden, SET=visible 			*/
		mode_25enab,	/* When true (SET), emulator can use 25th line			*/
		mode_protect,	/* When true (SET), protected mode is on				*/
		mode_block, 	/* When true (SET), block mode is on					*/
		mode_local, 	/* When true (SET), local mode is on					*/
		mode_vt220,
		mode_vt280,		/* Acts as a Kanji/Katakana terminal 					*/
		mode_vt320,

        fUse8BitCodes,	// Applies to the VT220/320 emulators.
        fAllowUserKeys,	// Ditto.
        fPrintRaw,

		iZmodemState;	// This variable is used by all of the emulators
						// for processing AutoStart Zmodem codes.

	int DEC_private;   	// Set when '?' is part of sequence

    // Function pointer definitions.  These pointers get assigned to
	// emulator functions during the loading and initialization of a
	// specific emulator...emuLoad().
	//
#if defined(EXTENDED_FEATURES)
	int (*emu_datain)		(const HHEMU hhEmu, const ECHAR ccode);
#else
	int (*emu_datain)		(const HEMU hEmu, const ECHAR ccode);
#endif
	int (*emu_kbdin)		(const HHEMU hhEmu, int kcode, const int fTest);
	int (*emu_getscrollcnt) (const HHEMU hhEmu);
	int (*EmuScreenMode)	(const HHEMU hhEmu, int d);
	int (*emuResetTerminal) (const HHEMU hhEmu, int n);

	void (*emu_graphic) 	(const HHEMU hhEmu);
	void (*emu_setcolors)	(const HHEMU hhEmu, int fore, int back);
	void (*emu_getcolors)	(const HHEMU hhEmu, int *fore, int *back);
	void (*emu_initcolors)	(const HHEMU hhEmu);
	void (*emu_getscrsize)	(const HHEMU hhEmu, int *rows, int *cols);
#ifdef INCL_TERMINAL_SIZE_AND_COLORS
    void (*emu_setscrsize)  (const HHEMU hhEmu);	// Added 10 Jun 98 rde
#endif
	void (*emu_getcurpos)	(const HHEMU hhEmu, int *row, int *col);
	void (*emu_setcurpos)	(const HHEMU hhEmu, int row, int col);
	void (*emu_clearscreen) (const HHEMU hhEmu, int selector);
	void (*emu_clearline)	(const HHEMU hhEmu, int selector);
	void (*emu_setattr) 	(const HHEMU hhEmu, PSTATTR pstAttr);
	void (*emu_scroll)		(const HHEMU hhEmu, int nlines, BOOL direction);
	void (*emu_deinstall)	(const HHEMU hhEmu);
	void (*EmuSetCursorType)(const HHEMU hhEmu, int iCurType);
	void (*emu_ntfy)		(const HHEMU hhEmu, const int nNtfy);
	void (*emu_clearrgn)	(const HHEMU hhEmu,
								int toprow,
								int leftcol,
								int botmrow,
								int rightcol);

	ECHAR (*EmuGetPrnChar)	(const HHEMU hhEmu, ECHAR uch);
	STATTR (*emu_getattr)	(const HHEMU hhEmu);
	int (*emuHomeHostCursor)(const HHEMU hhEmu);
	};

// These are a group of settings saved in the session file as a block. Later
// settings were added to the session file individually rather than in a 
// structure. Do not add or remove any items from this structure!! rde 8 Jun 1998
struct stEmuBaseSFSettings
	{
	int 	nEmuId, 			// 100 = EMU_AUTO
								// 101 = EMU_ANSI
								// 102 = EMU_MINI
								// 109 = EMU_VIEW
								// 110 = EMU_TTY
								// 111 = EMU_VT100
								// 112 = EMU_VT220
								// 113 = EMU_VT320
								// 115 = EMU_VT52
								// 116 = EMU_VT100J
                                // 117 = EMU_ANSIW
								// 118 = EMU_VT100PLUS
								// 119 = EMU_VTUTF8
								//
			nTermKeys,			// 0 = EMU_KEYS_ACCEL
								// 1 = EMU_KEYS_TERM
								// 2 = EMU_KEYS_SCAN
								//
			nCursorType,		// 1 = EMU_CURSOR_BLOCK
								// 2 = EMU_CURSOR_LINE
	        					// 3 = EMU_CURSOR_NONE
								//
			nCharacterSet,		// 0 = EMU_CHARSET_ASCII
								// 1 = EMU_CHARSET_UK
								// 2 = EMU_CHARSET_SPECIAL
								//
			nAutoAttempts,		// Count of connections using the Auto
								// Detect Emulator.  At
								// EMU_MAX_AUTODETECT_ATTEMPTS, we switch
								// to Ansi emulation.  Note, this may
								// get moved into a Statictics Handle
								// if we ever develop one.
								//
			fCursorBlink,		// Blinking cursor. 			True\False.
			fMapPFkeys, 		// PF1-PF4 to top row of keypad.True\False.
			fAltKeypadMode, 	// Alternate keypad mode.		True\False.
			fKeypadAppMode, 	// Keypad application mode. 	True\False.
			fCursorKeypadMode,	// Cursor keypad mode.			True\Fales.
			fReverseDelBk,		// Reverse Del and Backsp.		True\False.
			f132Columns,		// 132 column display.			True\False.
			fDestructiveBk, 	// Destructive backspace.		True\False.
			fWrapLines, 		// Wrap lines.					True\False.
			fLbSymbolOnEnter,	// Send # symbol on Enter.		True\False.

	// Note: The following two variables were added for the VT220/320. rde:24 Jan 98
            fUse8BitCodes,      // 8-bit control codes          True\False.
            fAllowUserKeys;     // User defined keys allowed    True\False.
                                
    // Note: The following two variables are only used if the "Include
    // User Defined Backspace and Telnet Terminal Id" feature is enabled.
    // There is no compile switch here because this entire structure gets
    // written to the session file in one large chunk. Using a compile
    // switch could potentially cause version problems later on down
    // the road. - cab:11/15/96
    //
    int     nBackspaceKeys;     // 1 = EMU_BKSPKEYS_CTRLH
                                // 2 = EMU_BKSPKEYS_DEL
                                // 3 = EMU_BKSPKEYS_CTRLHSPACE

    TCHAR   acTelnetId[EMU_MAX_TELNETID];   // Telnet terminal ID
	};

// This macro returns the virtual image row of the supplied row number.  That is,
// what appears as row 10 on the terminal image may actually be row 5 in the
// virtual image.
//
#define row_index(h, r) (((r) + h->emu_imgtop + MAX_EMUROWS) % (MAX_EMUROWS))

// The emualtor image is an array of characters.  emu_aiEnd is an array that
// contains the column number of the rightmost character in a given row.
// This macro returns the a number representing the length of the image for
// the supplied row, from location 0 to the rightmost column.  It
// simplifies accessing a row of the emulator as though it were a string.
// Remember, the emualtor matrix is zero based, and EMU_BALNK_LINE indicates
// that there are no characters in the row.
//
#define emuRowLen(h, r) ((h->emu_aiEnd[r] == EMU_BLANK_LINE) ? 0 : h->emu_aiEnd[r] + 1)

// from emu_std.c
//
int 	std_kbdin(const HHEMU hhEmu, int kcode, const int fTest);
int 	std_getscrollcnt(const HHEMU hhEmu);
void	std_getscrsize(const HHEMU hhEmu, int *rows, int *cols);
#ifdef INCL_TERMINAL_SIZE_AND_COLORS
void	std_setscrsize(const HHEMU hhEmu);
#endif
void	std_getcurpos(const HHEMU hhEmu, int *row, int *col);
void	std_setcurpos(const HHEMU hhEmu, const int iRow, const int iCol);
STATTR	std_getattr(const HHEMU hhEmu);
void	std_setattr(const HHEMU hhEmu, PSTATTR pstAttr);
void	std_setcolors(const HHEMU hhEmu, const int fore, const int back);
void	std_getcolors(const HHEMU hhEmu, int *fore, int *back);
void	std_initcolors(const HHEMU hhEmu);
void	std_restorescreen(const HHEMU hhEmu);
void	std_clearscreen(const HHEMU hhEmu, const int nClearSelect);
void	std_clearline(const HHEMU hhEmu, const int nClearSelect);
void	std_clearrgn(const HHEMU hhEmu, int toprow, int leftcol, int botmrow, int rightcol);
void	EmuStdSetCursorType(const HHEMU hhEmu, int iCurType);
void	EmuChkChar(const HHEMU hhEmu);
void	EmuStdChkZmdm(const HHEMU hhEmu);
void	std_dsptbl(const HHEMU hhEmu, int bit8);
void	std_scroll(const HHEMU hhEmu, const INT nlines, const BOOL direction);
void	std_deinstall(const HHEMU hhEmu);
void	vt_dsptbl(const HHEMU hhEmu, ECHAR left, ECHAR right);
void	vt_setdtbl(const HHEMU hhEmu, ECHAR tbl[], ECHAR cset);
int 	stdResetTerminal(const HHEMU hhEmu, const int);
void	std_emu_ntfy(const HHEMU hhEmu, const int nNtfy);
int 	std_HomeHostCursor(const HHEMU hhEmu);

// from emu_scr.c
//
void	backspace(const HHEMU hhEmu);
void	carriagereturn(const HHEMU hhEmu);
void	emuLineFeed(const HHEMU hhEmu);
void	emuPrintChars(const HHEMU hhEmu, ECHAR *bufr, int nLen);
void	scrolldown(const HHEMU hhEmu, int nlines);
void	scrollup(const HHEMU hhEmu, int nlines);
void	tab(const HHEMU hhEmu);
void	backtab(const HHEMU hhEmu);
void	tabn(const HHEMU hhEmu);
void	emu_bell(const HHEMU hhEmu);
void	emu_clearword(const HHEMU hhEmu, int fromcol, int tocol);
void	clear_imgrow(const HHEMU hhEmu, int iRow);

// From autoinit.c
//
void emuAutoInit(const HHEMU hhEmu);

// From emu_ansi.c
//
void	ANSI_CNL(const HHEMU hhEmu, int nlines);
void	ANSI_CUB(const HHEMU hhEmu);
void	ANSI_CUD(const HHEMU hhEmu);
void	ANSI_CUF(const HHEMU hhEmu);
void	ANSI_CUP(const HHEMU hhEmu);
void	ANSI_CUU(const HHEMU hhEmu);
void	ANSI_DL(const HHEMU hhEmu);
void	ANSI_ED(const HHEMU hhEmu);
void	ANSI_EL(const HHEMU hhEmu);
void	ANSI_DCH(const HHEMU hhEmu);
void	AnsiFormFeed(const HHEMU hhEmu);
void	ANSI_HTS(const HHEMU hhEmu);
void	ANSI_ICH(const HHEMU hhEmu);
void	ANSI_IL(const HHEMU hhEmu);
void	ANSI_IND(const HHEMU hhEmu);
void	ANSI_NEL(const HHEMU hhEmu);
void	ANSI_Pn(const HHEMU hhEmu);
void	ANSI_Pn_Clr(const HHEMU hhEmu);
void	ANSI_Pn_End(const HHEMU hhEmu);
void	ANSI_RI(const HHEMU hhEmu);
void	ANSI_RIS(const HHEMU hhEmu);
void	ANSI_SGR(const HHEMU hhEmu);
void	ANSI_TBC(const HHEMU hhEmu);

// From emu.c
//
void	nothing(const HHEMU hhEmu);
void	char_pn(const HHEMU hhEmu);
void	commanderror(const HHEMU hhEmu);
void	emuStdGraphic(const HHEMU hhEmu);
int 	emuCreateTextAttrBufs(const HEMU hEmu, const size_t nRows, size_t nCols);
void	emuDestroyTextAttrBufs(const HEMU hEmu);
void	emu_cleartabs(const HHEMU hhEmu, int selector);
void	emu_reverse_image(const HHEMU hhEmu);
int 	emu_is25lines(const HHEMU hhEmu);
int 	emuKbdKeyLookup(const HHEMU hhEmu, const int key, const PSTKEYTABLE pstKeyTbl);
void	emuInstallStateTable(const HHEMU hhEmu, struct trans_entry const *, int iSize);
//int 	emuKeyTableLoad(const HHEMU hhEmu, const int nTableId, PSTKEYTABLE const pstKeyTbl);
int 	emuKeyTableLoad(const HHEMU hhEmu, const KEYTBLSTORAGE pstKeySource[], const int nNumKeys, PSTKEYTABLE const pstKeyTbl);
int 	emu_kbdlocked(const HHEMU hhEmu, int key, const int fTest);
void 	emuSendKeyString(const HHEMU hhEmu, const int index, const PSTKEYTABLE pstKeyTbl);
void	emuSendString(const HHEMU hhEmu, ECHAR *str, int strln);
void	emuKeyTableFree(PSTKEYTABLE const pstKeyTbl);
int		emuSetEmuName(const HEMU hEmu, const int nEmuId);
void	emuAutoDetectLoad(const HHEMU hhEmu, const int nEmuID);

// From vt_xtra.c
//
void	emuSetDecColumns(const HHEMU hhEmu, const int nColumns, const int fClear);
void	ANSI_DSR(const HHEMU hhEmu);
void	vt_scrollrgn(const HHEMU hhEmu);
void	ANSI_RM(const HHEMU hhEmu);
void	ANSI_SM(const HHEMU hhEmu);
void	vt_alt_kpmode(const HHEMU hhEmu);
void	vt_screen_adjust(const HHEMU hhEmu);
void	DEC_STBM(const HHEMU hhEmu, int top, int bottom);
void	vt52_toANSI(const HHEMU hhEmu);
void	vt_DCH(const HHEMU hhEmu);
void	vt_IL(const HHEMU hhEmu);
void	vt_DL(const HHEMU hhEmu);
void	vt_clearline(const HHEMU hhEmu, const int nSelect);
void	vt_clearscreen(const HHEMU hhEmu, const int nSelect);
void	vt_backspace(const HHEMU hhEmu);
void	vt_CUB(const HHEMU hhEmu);

// From ansi.c
//
void	ansi_setmode(const HHEMU hhEmu);
void	ansi_resetmode(const HHEMU hhEmu);
int 	ansi_kbdin(const HHEMU hhEmu, int key, const int fTest);
void	ansi_savecursor(const HHEMU hhEmu);
void	DoorwayMode(const HHEMU hhEmu);
void	emuAnsiUnload(const HHEMU hhEmu);

// From ansiinit.c
//
int 	emuAnsiReset(const HHEMU hhEmu, const int fHostRequest);
void	emuAnsiInit(const HHEMU hhEmu);
void	csrv_init(const HHEMU hhEmu, const int new_emu);

// From vt100.c
//
int 	vt100_kbdin(const HHEMU hhEmu, int key, const int fTest);
void	ANSI_DA(const HHEMU hhEmu);
void	vt100_savecursor(const HHEMU hhEmu);
void	vt100_hostreset(const HHEMU hhEmu);
int 	vt100_reset(const HHEMU hhEmu, const int host_request);
int 	fakevt_kbdin(const HHEMU hhEmu, int key, const int fTest);
void	vt100_prnc(const HHEMU hhEmu);
void	vt100PrintCommands(const HHEMU hhEmu);
void	vt100_answerback(const HHEMU hhEmu);
void	vt100_report(const HHEMU hhEmu);
void	emuDecGraphic(const HHEMU hhEmu);
void	emuSetDoubleAttr(const HHEMU hhEmu);
void	emuSetSingleAttrRow(const HHEMU hhEmu);
void	emuSetDoubleAttrRow(const HHEMU hhEmu, const int iLineAttr);
void	emuFromDblToSingle(const HHEMU hhEmu);
void	emuDecTab(const HHEMU hhEmu);
void	emuDecCUF(const HHEMU hhEmu);
void	emuDecCUP(const HHEMU hhEmu);
void	emuDecCUB(const HHEMU hhEmu);
void	emuDecED(const HHEMU hhEmu);
void	emuVT100Unload(const HHEMU hhEmu);
void	emuDecIND(const HHEMU hhEmu);
void	emuDecRI(const HHEMU hhEmu);
void	emuDecCUU(const HHEMU hhEmu);
void	emuDecCUD(const HHEMU hhEmu);
void	emuDecSetCurPos(const HHEMU hhEmu, const int iRow, const int iCol);
void	emuDecClearScreen(const HHEMU hhEmu, const int iSelector);

// From vt100ini.c
//
void	vt100_init(const HHEMU hhEmu);

// From vt_chars.c
//
void	vt_charset_init(const HHEMU hhEmu);
void	vt_charset_save(const HHEMU hhEmu);
void	vt_charset_restore(const HHEMU hhEmu);
void	vt_charshift(const HHEMU hhEmu);
void	vt_scs1(const HHEMU hhEmu);
void	vt_scs2(const HHEMU hhEmu);
#if defined(EXTENDED_FEATURES)
int 	vt_char_emulatecmd(const HHEMU hhEmu, const ECHAR ccode);
#else
int 	vt_char_emulatecmd(const HEMU hEmu, const ECHAR ccode);
#endif

// From vt52.c
//
void	vt52PrintCommands(const HHEMU hhEmu);
void	vt52Print(const HHEMU hhEmu);
void	vt52_id(const HHEMU hhEmu);
void	vt52_CUP(const HHEMU hhEmu);
int 	vt52_kbdin(const HHEMU hhEmu, int key, const BOOL fTest);
void	emuVT52Unload(const HHEMU hhEmu);

// From vt52init.c
//
void	vt52_init(const HHEMU hhEmu);

// From emuhdl.c
int emuCreateNameTable(const HHEMU hhEmu);
int emuStdDataIn(const HHEMU hhEmu, const ECHAR ccode);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\emu_load.c ===
/*	File: D:\WACKER\emu\emu_load.c (Created: 08-Dec-1993)
 *
 *	Copyright 1993 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:28p $
 */

/* This file is no longer used! --jcm */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\emu_ansi.c ===
/*	File: D:\WACKER\emu\emu_ansi.c (Created: 08-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 3/16/01 4:28p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\tdll.h>
#include <tdll\session.h>
#include <tdll\cloop.h>
#include <tdll\update.h>
#include <tdll\htchar.h>

#include "emu.h"
#include "emu.hh"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_CNL
 *
 * DESCRIPTION:
 *	 Moves the cursor to the start of the nth next line. The cursor can not
 *	 move past the end of the scrolling region.
 *
 * ARGUMENTS:
 *	 nline -- number of lines to move the cursor down
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_CNL(const HHEMU hhEmu, int nlines)
	{
	int row;

	if (nlines < 1)
		nlines = 1;

	row = hhEmu->emu_currow;
	row += nlines;

	if (row > hhEmu->bottom_margin)
		{
		(*hhEmu->emu_scroll)(hhEmu, row - hhEmu->bottom_margin, TRUE);
		row = hhEmu->bottom_margin;
		}

	(*hhEmu->emu_setcurpos)(hhEmu, row, 0);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_CUB
 *
 * DESCRIPTION:
 *	 Moves the cursor backwards (to the left) the specified number of
 *	 characters, but stops at the 1st character in the current line.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_CUB(const HHEMU hhEmu)
	{
	int nchars;
	nchars = hhEmu->num_param[hhEmu->num_param_cnt];
	if (nchars < 1)
		nchars = 1;

	(*hhEmu->emu_setcurpos)(hhEmu,
							hhEmu->emu_currow,
							hhEmu->emu_curcol - nchars);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_CUD
 *
 * DESCRIPTION: Moves the cursor down the specified number of lines, but stops
 *				at the bottom of the scrolling region. The column is constant.
 *				If below the scrolling region, it stops at the bottom of the
 *				screen.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_CUD(const HHEMU hhEmu)
	{
	int nlines, row;

	nlines = hhEmu->num_param[hhEmu->num_param_cnt];

	if (nlines < 1)
		nlines = 1;

	row = hhEmu->emu_currow;
	row += nlines;

	if (row > hhEmu->bottom_margin &&
				(hhEmu->emu_currow <= hhEmu->bottom_margin ||
				hhEmu->emu_currow > hhEmu->emu_maxrow))
		row = hhEmu->bottom_margin;

	(*hhEmu->emu_setcurpos)(hhEmu, row, hhEmu->emu_curcol);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_CUF
 *
 * DESCRIPTION:
 *	 Moves the cursor forward the specified number of characters, but stops
 *	 at the last character in the current line.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_CUF(const HHEMU hhEmu)
	{
	int nchars, col;

	nchars = hhEmu->num_param[hhEmu->num_param_cnt];

	if (nchars < 1)
		nchars = 1;

	col = hhEmu->emu_curcol;
	col += nchars;
	(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, col);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_CUP
 *
 * DESCRIPTION:
 *	 Positions the cursor at the specified row and column. The row & column
 *	 numbering start at 1. If origin mode is on, the positioning is relative
 *	 to the home of the scrolling region.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_CUP(const HHEMU hhEmu)
	{
	int row, col;

	row = hhEmu->num_param[0];
	col = hhEmu->num_param_cnt > 0 ? hhEmu->num_param[1] : 0;

	if (row <= 1)
		row = 1;

	if (col <= 1)
		col = 1;

	if (hhEmu->mode_DECOM) /* VT100 Origin mode - position rel to margin */
		{
		row += hhEmu->top_margin;
		if (row > hhEmu->bottom_margin + 1)
			row = hhEmu->bottom_margin + 1;
		}
	else			/* Position is one-based from upper left */
		{
		if (row > hhEmu->emu_maxrow + 1)
			row = hhEmu->emu_maxrow + 1;
		}

	if (col > hhEmu->emu_maxcol + 1)
		col = hhEmu->emu_maxcol + 1;

	/* ANSI is one-based, HA zero-based */
	(*hhEmu->emu_setcurpos)(hhEmu, row - 1, col - 1);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_CUU
 *
 * DESCRIPTION: Moves the cursor up the specified number of lines, but stops
 *				at the top of the scrolling region. The column is constant.
 *				If above the scrolling region, it stops at the top of the
 *				screen.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_CUU(const HHEMU hhEmu)
	{
	int nlines, row;

	nlines = hhEmu->num_param[hhEmu->num_param_cnt];

	if (nlines < 1)
		nlines = 1;

	row = hhEmu->emu_currow;
	row -= nlines;

	if (row < hhEmu->top_margin &&
		(hhEmu->emu_currow >= hhEmu->top_margin || hhEmu->emu_currow < 0))
			row = hhEmu->top_margin;

	(*hhEmu->emu_setcurpos)(hhEmu, row, hhEmu->emu_curcol);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_DCH
 *
 * DESCRIPTION:
 *	Deletes the specified number of characters starting at the current
 *	cursor position and moving right. It stops at the end of the current
 *	line.
 *
 * ARGUMENTS:
 *	none
 *
 * RETURNS:
 *	nothing
 */
void ANSI_DCH(const HHEMU hhEmu)
	{
	int iChars, iR, i;
	ECHAR *lpStart;
	PSTATTR pstAttr;

	hhEmu->emu_imgrow = row_index(hhEmu, hhEmu->emu_currow);

	// Range check.  Have we been asked to delete more characters than
	// are displayed?  If so, change the number.
	//
	iChars = min(hhEmu->num_param[hhEmu->num_param_cnt],
					(hhEmu->emu_aiEnd[hhEmu->emu_imgrow] -
					hhEmu->emu_curcol) + 1);

	if (iChars < 1)
		iChars = 1;

	if (hhEmu->emu_aiEnd[hhEmu->emu_imgrow] == EMU_BLANK_LINE)
		return;

	// Do a special test for DEC emulation.
	//
	if ((hhEmu->emu_curcol == hhEmu->emu_maxcol) &&
		((hhEmu->stUserSettings.nEmuId == EMU_VT100) ||
		 (hhEmu->stUserSettings.nEmuId == EMU_VT100J)))
		{
		hhEmu->emu_curcol = hhEmu->emu_maxcol - 1;
		}
	else if (hhEmu->emu_curcol > hhEmu->emu_aiEnd[hhEmu->emu_imgrow])
		return;

	// Determine number of character that remain after the delete.
	//
	iR = hhEmu->emu_aiEnd[hhEmu->emu_imgrow] -
			hhEmu->emu_curcol - (iChars - 1);

	// Move the text image if there are remaining characters to
	// display.  Replace iChar characters at end of line with spaces.
	//
	#if 0
	if (iR)
		{
		memmove(hhEmu->emu_apText[hhEmu->emu_imgrow + hhEmu->emu_curcol],
				 &(hhEmu->emu_apText[hhEmu->emu_imgrow + hhEmu->emu_curcol][iChars]),
				 ((size_t)iR * sizeof(ECHAR)));   
		}
	#endif

	if (iR)
		{
		lpStart = hhEmu->emu_apText[hhEmu->emu_imgrow] + hhEmu->emu_curcol;

		memmove(lpStart, (lpStart + iChars), ((size_t)iR * sizeof(ECHAR)));
		}

    ECHAR_Fill(&hhEmu->emu_apText[hhEmu->emu_imgrow][hhEmu->emu_aiEnd[hhEmu->emu_imgrow] - iChars + 1],
				EMU_BLANK_CHAR, (unsigned int)iChars);

	// Move the attributes.  Clear iChar attributes at end of line.
	//
	if (iR)
		{
		pstAttr = hhEmu->emu_apAttr[hhEmu->emu_imgrow] + hhEmu->emu_curcol;
		memmove(pstAttr,
				(pstAttr + iChars),
				(size_t)(sizeof(STATTR)*(unsigned)iR));
		}

	pstAttr = hhEmu->emu_apAttr[hhEmu->emu_imgrow];
	for (i = (hhEmu->emu_aiEnd[hhEmu->emu_imgrow] - iChars) + 1;
			i <= hhEmu->emu_aiEnd[hhEmu->emu_imgrow]; i++)
				pstAttr[i] = hhEmu->emu_clearattr;

	// Note that emu_aiEnd[emu_imgrow] is used before we reset that
	// value.  Remember there may have been some characters and attributes
	// removed from the end of the line.  We need to tell the update stuff
	// to go that far over in the line.
	//
	updateChar(sessQueryUpdateHdl(hhEmu->hSession),
				hhEmu->emu_currow,
				hhEmu->emu_curcol,
				hhEmu->emu_aiEnd[hhEmu->emu_imgrow]);

	// Reset emu_aiEnd.  Note that it is expected and intended
	// that the result of the following calculation may
	// be (-1).
	//
	hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = hhEmu->emu_curcol + (iR - 1);

	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_DL
 *
 * DESCRIPTION:
 *	 Deletes the specified number of lines starting at the current
 *	 cursor line and moving down. It stops at the bottom of the scrolling
 *	 region.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_DL(const HHEMU hhEmu)
	{
	int nlines;
	int save_top_margin;

	nlines = hhEmu->num_param[hhEmu->num_param_cnt];

	if (nlines < 1)
		nlines = 1;

	save_top_margin = hhEmu->top_margin;
	hhEmu->top_margin = hhEmu->emu_currow;

	if (hhEmu->top_margin <= hhEmu->bottom_margin)
		(*hhEmu->emu_scroll)(hhEmu, nlines, TRUE);

	hhEmu->top_margin = save_top_margin;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_ED
 *
 * DESCRIPTION:
 *	 Erases some or all of the virtual screen image and corresponding
 *	 real screen.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_ED(const HHEMU hhEmu)
	{
	int nClearSelect;

	nClearSelect = hhEmu->selector[0];
	switch (nClearSelect)
		{
	case 0: 	/* cursor to end of screen */
	case 0x0F:
	case 0xF0:
		(*hhEmu->emu_clearscreen)(hhEmu, 0);
		break;
	case 1: 	/* start of screen to cursor */
	case 0xF1:
		(*hhEmu->emu_clearscreen)(hhEmu, 1);
		break;
	case 2: 	/* Entire screen */
	case 0xF2:
		(*hhEmu->emu_clearscreen)(hhEmu, 2);

		// ANSI terminal homes after clearing.
		// DEC terminals do not
		//
		if ((hhEmu->stUserSettings.nEmuId == EMU_ANSI)  ||
			(hhEmu->stUserSettings.nEmuId == EMU_ANSIW) ||
			(hhEmu->stUserSettings.nEmuId == EMU_AUTO))
			{
			(*hhEmu->emu_setcurpos)(hhEmu, 0,0);
			}

		break;
	default:
		commanderror(hhEmu);
		break;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_EL
 *
 * DESCRIPTION:
 *	 Erases some or all of the current virtual screen line and corresponding
 *	 real screen line.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_EL(const HHEMU hhEmu)
	{
	int nClearSelect;

	nClearSelect = hhEmu->selector[0];
	switch (nClearSelect)
		{
	case 0: 	/* to end of line */
	case 0x0F:
	case 0xF0:
		(*hhEmu->emu_clearline)(hhEmu, 0);
		break;
	case 1: 	/* from start of line to cursor */
	case 0xF1:
		(*hhEmu->emu_clearline)(hhEmu, 1);
		break;
	case 2: 	/* Entire line */
	case 0xF2:
		(*hhEmu->emu_clearline)(hhEmu, 2);
		break;
	default:
		commanderror(hhEmu);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSIFormFeed
 *
 * DESCRIPTION: Scrolls the current screen until its all gone.
 *
 * ARGUMENTS:	none
 *	 none
 *
 * RETURNS: 	nothing
 */
void AnsiFormFeed(const HHEMU hhEmu)
	{
	std_clearscreen(hhEmu, 2);
	(*hhEmu->emu_setcurpos)(hhEmu, 0, 0);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_HTS
 *
 * DESCRIPTION:
 *	 Sets horizontal tab at current cursor position.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_HTS(const HHEMU hhEmu)
	{
	hhEmu->tab_stop[hhEmu->emu_curcol] = TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_ICH
 *
 * DESCRIPTION:
 *	 Inserts the specified number of spaces starting at the current
 *	 cursor position.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_ICH(const HHEMU hhEmu)
	{
	int nspaces, c, oldstate, oldrow, oldcol;
	int tmp_irm = hhEmu->mode_IRM;
	nspaces = hhEmu->num_param[hhEmu->num_param_cnt];

	if (nspaces <= 0)
		nspaces = 1;

	oldstate = hhEmu->iCurAttrState;
	hhEmu->iCurAttrState = CSCLEAR_STATE;
	oldrow = hhEmu->emu_currow;
	oldcol = hhEmu->emu_curcol;
	hhEmu->mode_IRM = SET;

	for (c = 0; c < nspaces; ++c)
		{
		hhEmu->emu_code = ETEXT(' ');
		(*hhEmu->emu_graphic)(hhEmu);
		}

	hhEmu->iCurAttrState = oldstate;
	(*hhEmu->emu_setcurpos)(hhEmu, oldrow, oldcol);

	if ((hhEmu->mode_IRM = tmp_irm) == 0)
		updateChar(sessQueryUpdateHdl(hhEmu->hSession),
					hhEmu->emu_currow,
					hhEmu->emu_curcol,
					hhEmu->emu_maxcol);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_IL
 *
 * DESCRIPTION:
 *	 Inserts the specified number of lines starting at the current
 *	 cursor row.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_IL(const HHEMU hhEmu)
	{
	int nlines;
	int save_top_margin;

	nlines = hhEmu->num_param[hhEmu->num_param_cnt];

	if (nlines < 1)
		nlines = 1;

	save_top_margin = hhEmu->top_margin;
	hhEmu->top_margin = hhEmu->emu_currow;

	if (hhEmu->top_margin < hhEmu->bottom_margin)
		(*hhEmu->emu_scroll)(hhEmu, nlines, FALSE);

	hhEmu->top_margin = save_top_margin;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_IND
 *
 * DESCRIPTION:
 *	 Moves cursor down 1 line and scrolls 1 line if necessary. IND stands
 *	 for index.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_IND(const HHEMU hhEmu)
	{
	if (hhEmu->emu_currow == hhEmu->bottom_margin)
		(*hhEmu->emu_scroll)(hhEmu, 1, TRUE);

	else
		(*hhEmu->emu_setcurpos)(hhEmu,
								hhEmu->emu_currow + 1,
								hhEmu->emu_curcol);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_NEL
 *
 * DESCRIPTION:
 *	 Inserts 1 new line on the line below current row.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_NEL(const HHEMU hhEmu)
	{
	ANSI_CNL(hhEmu, 1);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_Pn
 *
 * DESCRIPTION:
 *	 Saves ANSI style parameters and selectors. The selectors are saved as
 *	 hex and numeric parameters as decimals.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_Pn(const HHEMU hhEmu)
	{
	ECHAR ccode;

	ccode = hhEmu->emu_code;

	if (ccode == ETEXT('?') && hhEmu->selector_cnt == 0)
		hhEmu->DEC_private = TRUE;

	else if (hhEmu->DEC_private && hhEmu->selector[hhEmu->selector_cnt] == 0 && ccode != ETEXT('?'))
		hhEmu->selector[hhEmu->selector_cnt] = 0x0F;

	hhEmu->selector[hhEmu->selector_cnt] = (int)((unsigned)hhEmu->selector[hhEmu->selector_cnt] << 4) +
								ccode - ETEXT('0');
	hhEmu->num_param[hhEmu->num_param_cnt] = 10 * hhEmu->num_param[hhEmu->num_param_cnt] +
								(ccode - ETEXT('0'));
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_Pn_Clr
 *
 * DESCRIPTION:
 *	 Clears all ANSI style parameters and selectors.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_Pn_Clr(const HHEMU hhEmu)
	{
	hhEmu->num_param_cnt = hhEmu->selector_cnt = 0;
	hhEmu->num_param[0] = 0;
	hhEmu->selector[0] = 0;
	hhEmu->DEC_private = FALSE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_Pn_End
 *
 * DESCRIPTION:
 *	 Sets next numeric parameter and selector to 0 to indicate end of
 *	 escape sequence.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_Pn_End(const HHEMU hhEmu)
	{
	hhEmu->num_param[++hhEmu->num_param_cnt] = 0;
	hhEmu->selector[++hhEmu->selector_cnt] = 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_RI
 *
 * DESCRIPTION:
 *	 Moves cursor up 1 line and scrolls 1 line if necessary. RI stands
 *	 for reverse index.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_RI(const HHEMU hhEmu)
	{
	/* If at the scrolling region's top margin, scroll down 1, but
	 * if above the top margin, and below to top edge of the screen,
	 * move the cursor up. If above the top margin and at the top edge of
	 * the screen, do nothing.
	 */
	if (hhEmu->emu_currow == hhEmu->top_margin)
		(*hhEmu->emu_scroll)(hhEmu, 1, FALSE);
	else if (hhEmu->emu_currow == 0)
		;
	else
		(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow - 1, hhEmu->emu_curcol);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_RIS
 *
 * DESCRIPTION:
 *	 Resets terminal emulator to initial state.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_RIS(const HHEMU hhEmu)
	{
	int col;
	int nTab;
	HCLOOP hCLoop;

	DEC_STBM(hhEmu, 0, 0);						/* Set scrolling region */

	(*hhEmu->emu_setcurpos)(hhEmu, 0, 0);		/* Home cursor */
	(*hhEmu->emu_clearscreen)(hhEmu, 0);		/* Clear screen */
	emu_cleartabs(hhEmu, 3);					/* Clear tabs */

	hCLoop = sessQueryCLoopHdl(hhEmu->hSession);

	nTab = CLoopGetTabSizeOut(hCLoop);

	if ( nTab <= 0)
		CLoopSetTabSizeOut(hCLoop, 8);

	for (col = 0; col <= MAX_EMUCOLS; col += nTab)
			hhEmu->tab_stop[col] = TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_SGR
 *
 * DESCRIPTION:
 *	 Sets character display attributes.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 *
 * NOTES:
 *	This function contains Auto Detect code.
 */
void ANSI_SGR(const HHEMU hhEmu)
	{
	STATTR stAttr;
	int fAnsi, sel, i;

	fAnsi = ((hhEmu->stUserSettings.nEmuId == EMU_ANSI)       ||
			 (hhEmu->stUserSettings.nEmuId == EMU_ANSIW)      ||
			 (hhEmu->stUserSettings.nEmuId == EMU_VIEW)       ||
			 (hhEmu->stUserSettings.nEmuId == EMU_AUTO)       ||
			 (hhEmu->stUserSettings.nEmuId == EMU_VT100PLUS)  ||
             (hhEmu->stUserSettings.nEmuId == EMU_VTUTF8)) ? TRUE : FALSE;

	for (i = 0; i <= hhEmu->selector_cnt; i++)
		{
		sel = hhEmu->selector[i];
		stAttr = hhEmu->attrState[CS_STATE];

		switch(sel)
			{
		case 0: /* all attributes off */
			if (hhEmu->stUserSettings.nEmuId == EMU_AUTO)
				{
				// don't mess with color attributes in AutoDetect mode
				// for attribute reset case - mrw, 10/17/94
				//
				stAttr.undrln = 0;
				stAttr.hilite = 0;
				stAttr.bklite = 0;
				stAttr.blink = 0;
				stAttr.revvid = 0;
				stAttr.blank = 0;
				stAttr.dblwilf = 0;
				stAttr.dblwirt = 0;
				stAttr.dblhilo = 0;
				stAttr.dblhihi = 0;
				stAttr.symbol = 0;
				}

			else if (fAnsi)
				{
				memset(&stAttr, 0, sizeof(STATTR));

#if FALSE	// We've decided not to do this. rde 14 Jul 98
//#ifdef INCL_TERMINAL_SIZE_AND_COLORS
				// Reset to the user-defined colors. I'm afraid this may
				// re-introduce the intensity bug referred to below.
				// rde 9 Jun 98
                if (hhEmu->mode_DECSCNM == SET)
                    {
                    stAttr.txtclr = hhEmu->stUserSettings.nBackgroundColor;
                    stAttr.bkclr = hhEmu->stUserSettings.nTextColor;
                    }
                else
                    {
                    stAttr.txtclr = hhEmu->stUserSettings.nTextColor;
                    stAttr.bkclr = hhEmu->stUserSettings.nBackgroundColor;
                    }
#else
                // mrw:2/21/96 - Changed from 15 to 7 to fix bug with
                // intensity.
                //
				stAttr.txtclr = (hhEmu->mode_DECSCNM == SET) ? 0 : 7;
				stAttr.bkclr = (hhEmu->mode_DECSCNM == SET) ? 7 : 0;
#endif

				}
			else
				{
				if (hhEmu->mode_DECSCNM != SET)
					{
#if FALSE	// We've decided not to do this. rde 14 Jul 98
//#ifdef INCL_TERMINAL_SIZE_AND_COLORS
                    stAttr.txtclr = hhEmu->stUserSettings.nTextColor;
                    stAttr.bkclr = hhEmu->stUserSettings.nBackgroundColor;
#endif
					stAttr.undrln = 0;
					stAttr.hilite = 0;
					stAttr.bklite = 0;
					stAttr.blink = 0;
					stAttr.revvid = 0;
					stAttr.blank = 0;
					stAttr.dblwilf = 0;
					stAttr.dblwirt = 0;
					stAttr.dblhilo = 0;
					stAttr.dblhihi = 0;
					stAttr.symbol = 0;
					}
				}
			break;

		case 1: /* bold or increased intensity */
			stAttr.hilite = TRUE;
			break;

		case 2: /* faint */
		case 3:	/* italics */
			/* not supported */
			break;

		case 4: /* underscore */
			stAttr.undrln = TRUE;
			break;

		case 5: /* blink */
			stAttr.blink = TRUE;
			break;

		case 6:	/* rapid blink */
			/* not supported */
			break;

		case 7: /* reverse video */
            // Reverse video should be reverse video for a cell
            // reguardless of the current screen mode.  Changing
            // the following line removed a bug where blocks of
            // text would not get set to reverse video when the
            // screen was also in reverse mode. - rjk:02/04/97
            //
			//stAttr.revvid = (hhEmu->mode_DECSCNM == SET) ? FALSE : TRUE;
			stAttr.revvid = TRUE;
			break;

		case 8: /* invisible display */
			stAttr.blank = TRUE;
			break;

		case 9:	/* rapid blink */
			/* not supported */
			break;

		case 0x22:
			stAttr.hilite = FALSE;
			break;

		case 0x24:
			stAttr.undrln = FALSE;
			break;

		case 0x25:
			stAttr.blink = FALSE;
			break;

		case 0x27:
			stAttr.revvid = FALSE;
			break;

		case 0x30:
		case 0x32:
		case 0x35:
		case 0x37:
#ifndef INCL_VT100COLORS
#if !defined(FAR_EAST)
			emuAutoDetectLoad(hhEmu, EMU_ANSI);
#else
			emuAutoDetectLoad(hhEmu, EMU_ANSIW);
#endif
			if (fAnsi)
				{
				if (!stAttr.revvid)
					stAttr.txtclr = (unsigned)sel - 0x30;
				else
					stAttr.bkclr = (unsigned)sel - 0x30;
				}
#else
			stAttr.txtclr = (unsigned)sel - 0x30;
#endif
			break;

		case 0x31:
		case 0x33:
#ifndef INCL_VT100COLORS
#if !defined(FAR_EAST)
			emuAutoDetectLoad(hhEmu, EMU_ANSI);
#else
			emuAutoDetectLoad(hhEmu, EMU_ANSIW);
#endif
			if (fAnsi)
				{
				if (!stAttr.revvid)
					stAttr.txtclr = (unsigned)(sel - 0x30) + 3;
				else
					stAttr.bkclr = (unsigned)(sel - 0x30) + 3;
				}
#else
			stAttr.txtclr = (unsigned)(sel - 0x30) + 3;
#endif
			break;

		case 0x34:
		case 0x36:
#ifndef INCL_VT100COLORS
#if !defined(FAR_EAST)
			emuAutoDetectLoad(hhEmu, EMU_ANSI);
#else
			emuAutoDetectLoad(hhEmu, EMU_ANSIW);
#endif
			if (fAnsi)
				{
				if (!stAttr.revvid)
					stAttr.txtclr = (unsigned)(sel - 0x30) - 3;
				else
					stAttr.bkclr = (unsigned)(sel - 0x30) - 3;
				}
#else
			stAttr.txtclr = (unsigned)(sel - 0x30) - 3;
#endif
			break;

		case 0x40:
		case 0x42:
		case 0x45:
		case 0x47:
#ifndef INCL_VT100COLORS
#if !defined(FAR_EAST)
			emuAutoDetectLoad(hhEmu, EMU_ANSI);
#else
			emuAutoDetectLoad(hhEmu, EMU_ANSIW);
#endif
			if (fAnsi)
				{
				if (!stAttr.revvid)
					stAttr.bkclr = (unsigned)sel - 0x40;
				else
					stAttr.txtclr = (unsigned)sel - 0x40;
				}
#else
			stAttr.bkclr = (unsigned)sel - 0x40;
#endif
			break;

		case 0x41:
		case 0x43:
#ifndef INCL_VT100COLORS
#if !defined(FAR_EAST)
			emuAutoDetectLoad(hhEmu, EMU_ANSI);
#else
			emuAutoDetectLoad(hhEmu, EMU_ANSIW);
#endif
			if (fAnsi)
				{
				if (!stAttr.revvid)
					stAttr.bkclr = (unsigned)(sel - 0x40) + 3;
				else
					stAttr.txtclr = (unsigned)(sel - 0x40) + 3;
				}
#else
			stAttr.bkclr = (unsigned)(sel - 0x40) + 3;
#endif
			break;

		case 0x44:
		case 0x46:
#ifndef INCL_VT100COLORS
#if !defined(FAR_EAST)
			emuAutoDetectLoad(hhEmu, EMU_ANSI);
#else
			emuAutoDetectLoad(hhEmu, EMU_ANSIW);
#endif
			if (fAnsi)
				{
				if (!stAttr.revvid)
					stAttr.bkclr = (unsigned)(sel - 0x40) - 3;
				else
					stAttr.txtclr = (unsigned)(sel - 0x40) - 3;
				}
#else
			stAttr.bkclr = (unsigned)(sel - 0x40) - 3;
#endif
			break;

		default:
			/* keep processing--there may be valids codes remaining */
			/* commanderror();*/
			break;
			}

		/* --- commit changes --- */

		hhEmu->emu_charattr =
		hhEmu->attrState[CS_STATE] =
		hhEmu->attrState[CSCLEAR_STATE] = stAttr;

		hhEmu->attrState[CSCLEAR_STATE].revvid = 0;
		hhEmu->attrState[CSCLEAR_STATE].undrln = 0;

		if (fAnsi && hhEmu->attrState[CS_STATE].revvid)
			hhEmu->attrState[CSCLEAR_STATE].revvid =
				hhEmu->attrState[CS_STATE].revvid;

		hhEmu->emu_clearattr = hhEmu->attrState[CSCLEAR_STATE];
		}

	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_TBC
 *
 * DESCRIPTION:
 *	 Clears one or all tab stops.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_TBC(const HHEMU hhEmu)
	{
	if (hhEmu->selector[0] == 0 || hhEmu->selector[0] == 3)
		emu_cleartabs(hhEmu, hhEmu->selector[0]);
	else
		commanderror(hhEmu);
	}

// End of ansi.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\emuhdl.c ===
/*	File: D:\WACKER\emu\emuhdl.c (Created: 10-Dec-1993)
 *
 *	Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 12 $
 *	$Date: 6/21/01 4:06p $
 */

#include <windows.h>
#pragma hdrstop
// #define DEBUGSTR

#include <time.h>
#include <tapi.h>

#include <tdll\stdtyp.h>
#include <tdll\mc.h>
#include <tdll\assert.h>
#include <tdll\sf.h>
#include <tdll\sess_ids.h>
#include <tdll\session.h>
#include <tdll\capture.h>
#include <tdll\cloop.h>
#include <tdll\term.h>
#include <tdll\print.h>
#include <tdll\update.h>
#include <tdll\load_res.h>
#include <tdll\globals.h>
#include <tdll\statusbr.h>
#include <tdll\cnct.h>
#include <tdll\cnct.hh>
#include <tdll\htchar.h>
#include <tdll\com.h>
#include <tdll\open_msc.h>      // IsNT()
#include <tdll\errorbox.h>      // TimedMessageBox()
#include <cncttapi\cncttapi.hh> // cncttapiSetLineConfig()
#include <term\res.h>

#include "emu.h"
#include "emu.hh"
#include "emuid.h"
#include "viewdata.hh"
#include "minitel.hh"
#include "emudec.hh"
#include "keytbls.h"

// Function prototypes...
//
STATIC_FUNC int emuLoadSettings(const HHEMU hhEmu, 
								const unsigned int uiId,
								unsigned long ulDataSize,
								void *pvData);
STATIC_FUNC void emuCheckSettings(struct stEmuBaseSFSettings *pstBaseSettings);

// Keytable declarations
//
const KEYTBLSTORAGE AnsiKeyTable[MAX_ANSI_KEYS] =
    {
	{VK_UP		| VIRTUAL_KEY,	{"\x1B[A\xff"}},
	{VK_DOWN 	| VIRTUAL_KEY,	{"\x1B[B\xff"}},
	{VK_RIGHT	| VIRTUAL_KEY,	{"\x1B[C\xff"}},
	{VK_LEFT 	| VIRTUAL_KEY,	{"\x1B[D\xff"}},

	// Added 27 Aug 98 rde
    {VK_HOME    | VIRTUAL_KEY,	{"\x1B[H\xff"}},
    {VK_END     | VIRTUAL_KEY,	{"\x1B[K\xff"}},

	//VK_UP 	  | VIRTUAL_KEY | CTRL_KEY,  "\x1BOx\xff",
	//VK_DOWN	  | VIRTUAL_KEY | CTRL_KEY,  "\x1BOr\xff",
	//VK_RIGHT	  | VIRTUAL_KEY | CTRL_KEY,  "\x1BOv\xff",
	//VK_LEFT	  | VIRTUAL_KEY | CTRL_KEY,  "\x1BOt\xff",

	//VK_HOME	  | VIRTUAL_KEY,  "\x1B[H\xff",
	//VK_END	  | VIRTUAL_KEY,  "\x1B[K\xff",

	//VK_HOME	  | VIRTUAL_KEY | CTRL_KEY,  "\x1BOw\xff",
	//VK_END	  | VIRTUAL_KEY | CTRL_KEY,  "\x1BOq\xff",

	//VK_PRIOR	  | VIRTUAL_KEY,  "\x1B[M\xff",
	//VK_NEXT	  | VIRTUAL_KEY,  "\x1B[H\x1B[2J\xff",

	//VK_PRIOR	  | VIRTUAL_KEY | CTRL_KEY,  "\x1BOy\xff",
	//VK_NEXT	  | VIRTUAL_KEY | CTRL_KEY,  "\x1BOs\xff",

	//VK_RETURN   | VIRTUAL_KEY,  "\x0D\xff",
	//VK_RETURN   | VIRTUAL_KEY | CTRL_KEY,  "\x1BOM\xff",

	//VK_INSERT   | VIRTUAL_KEY | CTRL_KEY,  "\x1BOp\xff",

	/* -------------- Function keys ------------- */

	{VK_F1		| VIRTUAL_KEY,	{"\x1BOP\xff"}},
	{VK_F2		| VIRTUAL_KEY,	{"\x1BOQ\xff"}},
	{VK_F3		| VIRTUAL_KEY,	{"\x1BOR\xff"}},
	{VK_F4		| VIRTUAL_KEY,	{"\x1BOS\xff"}},

	/* -------------- Gray keys, (extended edit pad) ------------- */

	{VK_UP		| VIRTUAL_KEY | EXTENDED_KEY,  {"\x1B[A\xff"}},
	{VK_DOWN 	| VIRTUAL_KEY | EXTENDED_KEY,  {"\x1B[B\xff"}},
	{VK_RIGHT	| VIRTUAL_KEY | EXTENDED_KEY,  {"\x1B[C\xff"}},
	{VK_LEFT 	| VIRTUAL_KEY | EXTENDED_KEY,  {"\x1B[D\xff"}},

	// Added 27 Aug 98 rde
	{VK_HOME 	| VIRTUAL_KEY | EXTENDED_KEY,  {"\x1B[H\xff"}},
	{VK_END 	| VIRTUAL_KEY | EXTENDED_KEY,  {"\x1B[K\xff"}},

	//VK_HOME	  | VIRTUAL_KEY | EXTENDED_KEY,  "\x1B[H\xff",
	//VK_END	  | VIRTUAL_KEY | EXTENDED_KEY,  "\x1B[K\xff",

	//VK_PRIOR	  | VIRTUAL_KEY | EXTENDED_KEY,  "\x1B[M\xff",
	//VK_NEXT	  | VIRTUAL_KEY | EXTENDED_KEY,  "\x1B[H\x1B[2J\xff",
	};

/* Also for ANSI emulator */
const KEYTBLSTORAGE IBMPCKeyTable[MAX_IBMPC_KEYS] =
	{
	{VK_BACK,				   {"\x08\xff"}},		/* KN_BS */
	{VK_DELETE	| VIRTUAL_KEY, {"\x00\x53\xff"}},	/* KN_DEL */
	{VK_DOWN 	| VIRTUAL_KEY, {"\x00\x50\xff"}},	/* KN_DOWN */
	{VK_END		| VIRTUAL_KEY, {"\x00\x4F\xff"}},	/* KN_END */
	{VK_RETURN,				   {"\x0D\xff"}},		/* KN_ENTER */
	{VK_ESCAPE,				   {"\x1B\xff"}},		/* KN_ESC */
	{VK_F1		| VIRTUAL_KEY, {"\x00\x3B\xff"}},	/* KN_F1 */
	{VK_F2		| VIRTUAL_KEY, {"\x00\x3C\xff"}},	/* KN_F2 */
	{VK_F3		| VIRTUAL_KEY, {"\x00\x3D\xff"}},	/* KN_F3 */
	{VK_F4		| VIRTUAL_KEY, {"\x00\x3E\xff"}},	/* KN_F4 */
	{VK_F5		| VIRTUAL_KEY, {"\x00\x3F\xff"}},	/* KN_F5 */
	{VK_F6		| VIRTUAL_KEY, {"\x00\x40\xff"}},	/* KN_F6 */
	{VK_F7		| VIRTUAL_KEY, {"\x00\x41\xff"}},	/* KN_F7 */
	{VK_F8		| VIRTUAL_KEY, {"\x00\x42\xff"}},	/* KN_F8 */
	{VK_F9		| VIRTUAL_KEY, {"\x00\x43\xff"}},	/* KN_F9 */
	{VK_F10		| VIRTUAL_KEY, {"\x00\x44\xff"}},	/* KN_F10 */
	{VK_F11		| VIRTUAL_KEY, {"\x00\x85\xff"}},	/* KN_F11 */
	{VK_F11		| VIRTUAL_KEY, {"\x00\x86\xff"}},	/* KN_F12 */
	{VK_HOME 	| VIRTUAL_KEY, {"\x00\x47\xff"}},	/* KN_HOME */
	{VK_INSERT	| VIRTUAL_KEY, {"\x00\x52\xff"}},	/* KN_INS */
	{VK_LEFT 	| VIRTUAL_KEY, {"\x00\x4B\xff"}},	/* KN_LEFT */
	{VK_NEXT 	| VIRTUAL_KEY, {"\x00\x51\xff"}},	/* KN_PGDN */
	{VK_PRIOR	| VIRTUAL_KEY, {"\x00\x49\xff"}},	/* KN_PGUP */
	{VK_RIGHT	| VIRTUAL_KEY, {"\x00\x4D\xff"}},	/* KN_RIGHT */
	{VK_TAB, 				   {"\x09\xff"}},		/* KN_TAB */
	{VK_UP		| VIRTUAL_KEY, {"\x00\x48\xff"}},	/* KN_UP */

	{VK_BACK 	| VIRTUAL_KEY | CTRL_KEY, {"\x7F\xff"}},	   /* KT_CTRL + KN_BS */
	{VK_DELETE	| VIRTUAL_KEY | CTRL_KEY, {"\x00\x93\xff"}},  /* KT_CTRL + KN_DEL */
	{VK_DOWN 	| VIRTUAL_KEY | CTRL_KEY, {"\x00\x91\xff"}},  /* KT_CTRL + KN_DOWN */
	{VK_END		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x75\xff"}},  /* KT_CTRL + KN_END */
	{VK_RETURN	| VIRTUAL_KEY | CTRL_KEY, {"\x0A\xff"}},	   /* KT_CTRL + KN_ENTER */

	{VK_F1		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x5E\xff"}},  /* KT_CTRL + KN_F1 */
	{VK_F10		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x67\xff"}},  /* KT_CTRL + KN_F10 */
	{VK_F11		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x89\xff"}},  /* KT_CTRL + KN_F11 */
	{VK_F12		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x8A\xff"}},  /* KT_CTRL + KN_F12 */
	{VK_F2		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x5F\xff"}},  /* KT_CTRL + KN_F2 */
	{VK_F3		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x60\xff"}},  /* KT_CTRL + KN_F3 */
	{VK_F4		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x61\xff"}},  /* KT_CTRL + KN_F4 */
	{VK_F5		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x62\xff"}},  /* KT_CTRL + KN_F5 */
	{VK_F6		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x63\xff"}},  /* KT_CTRL + KN_F6 */
	{VK_F7		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x64\xff"}},  /* KT_CTRL + KN_F7 */
	{VK_F8		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x65\xff"}},  /* KT_CTRL + KN_F8 */
	{VK_F9		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x66\xff"}},  /* KT_CTRL + KN_F9 */
	{VK_HOME 	| VIRTUAL_KEY | CTRL_KEY, {"\x00\x77\xff"}},  /* KT_CTRL + KN_HOME */
	{VK_INSERT	| VIRTUAL_KEY | CTRL_KEY, {"\x00\x92\xff"}},  /* KT_CTRL + KN_INS */
	{VK_LEFT 	| VIRTUAL_KEY | CTRL_KEY, {"\x00\x73\xff"}},  /* KT_CTRL + KN_LEFT */
	{VK_F1		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x8F\xff"}},  /* KT_CTRL + KN_MID */
	{VK_PRIOR	| VIRTUAL_KEY | CTRL_KEY, {"\x00\x76\xff"}},  /* KT_CTRL + KN_PGDN */
	{VK_NEXT 	| VIRTUAL_KEY | CTRL_KEY, {"\x00\x84\xff"}},  /* KT_CTRL + KN_PGUP */
	{VK_PRINT	| VIRTUAL_KEY | CTRL_KEY, {"\x00\x72\xff"}},  /* KT_CTRL + KN_PRTSC */
	{VK_RIGHT	| VIRTUAL_KEY | CTRL_KEY, {"\x00\x74\xff"}},  /* KT_CTRL + KN_RIGHT */
	{VK_TAB		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x94\xff"}},  /* KT_CTRL + KN_TAB */
	{VK_UP		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x8D\xff"}},  /* KT_CTRL + KN_UP */
														 
	{VK_F1		| VIRTUAL_KEY | SHIFT_KEY,{"\x00\x54\xff"}},  /* KT_SHIFT + KN_F1 */
	{VK_F10		| VIRTUAL_KEY | SHIFT_KEY,{"\x00\x5D\xff"}},  /* KT_SHIFT + KN_F10 */
	{VK_F11		| VIRTUAL_KEY | SHIFT_KEY,{"\x00\x87\xff"}},  /* KT_SHIFT + KN_F11 */
	{VK_F12		| VIRTUAL_KEY | SHIFT_KEY,{"\x00\x88\xff"}},  /* KT_SHIFT + KN_F12 */
	{VK_F2		| VIRTUAL_KEY | SHIFT_KEY,{"\x00\x55\xff"}},  /* KT_SHIFT + KN_F2 */
	{VK_F3		| VIRTUAL_KEY | SHIFT_KEY,{"\x00\x56\xff"}},  /* KT_SHIFT + KN_F3 */
	{VK_F4		| VIRTUAL_KEY | SHIFT_KEY,{"\x00\x57\xff"}},  /* KT_SHIFT + KN_F4 */
	{VK_F5		| VIRTUAL_KEY | SHIFT_KEY,{"\x00\x58\xff"}},  /* KT_SHIFT + KN_F5 */
	{VK_F6		| VIRTUAL_KEY | SHIFT_KEY,{"\x00\x59\xff"}},  /* KT_SHIFT + KN_F6 */
	{VK_F7		| VIRTUAL_KEY | SHIFT_KEY,{"\x00\x5A\xff"}},  /* KT_SHIFT + KN_F7 */
	{VK_F8		| VIRTUAL_KEY | SHIFT_KEY,{"\x00\x5B\xff"}},  /* KT_SHIFT + KN_F8 */
	{VK_F9		| VIRTUAL_KEY | SHIFT_KEY,{"\x00\x5C\xff"}},  /* KT_SHIFT + KN_F9 */
	{VK_TAB		| VIRTUAL_KEY | SHIFT_KEY,{"\x00\x0F\xff"}},  /* KT_SHIFT + KN_TAB */

	{0x5C | ALT_KEY | VIRTUAL_KEY, {"\x00\x28\xff"}},  /* KT_ALT + '\'' */
	{0x2C | ALT_KEY | VIRTUAL_KEY, {"\x00\x33\xff"}},  /* KT_ALT + ',' */
	{0x2D | ALT_KEY | VIRTUAL_KEY, {"\x00\x82\xff"}},  /* KT_ALT + '-' */
	{0x2E | ALT_KEY | VIRTUAL_KEY, {"\x00\x34\xff"}},  /* KT_ALT + '.' */
	{0x2F | ALT_KEY | VIRTUAL_KEY, {"\x00\x35\xff"}},  /* KT_ALT + '/' */
	{0x30 | ALT_KEY | VIRTUAL_KEY, {"\x00\x81\xff"}},  /* KT_ALT + '0' */
	{0x31 | ALT_KEY | VIRTUAL_KEY, {"\x00\x78\xff"}},  /* KT_ALT + '1' */
	{0x32 | ALT_KEY | VIRTUAL_KEY, {"\x00\x79\xff"}},  /* KT_ALT + '2' */
	{0x33 | ALT_KEY | VIRTUAL_KEY, {"\x00\x7A\xff"}},  /* KT_ALT + '3' */
	{0x34 | ALT_KEY | VIRTUAL_KEY, {"\x00\x7B\xff"}},  /* KT_ALT + '4' */
	{0x35 | ALT_KEY | VIRTUAL_KEY, {"\x00\x7C\xff"}},  /* KT_ALT + '5' */
	{0x36 | ALT_KEY | VIRTUAL_KEY, {"\x00\x7D\xff"}},  /* KT_ALT + '6' */
	{0x37 | ALT_KEY | VIRTUAL_KEY, {"\x00\x7E\xff"}},  /* KT_ALT + '7' */
	{0x38 | ALT_KEY | VIRTUAL_KEY, {"\x00\x7F\xff"}},  /* KT_ALT + '8' */
	{0x39 | ALT_KEY | VIRTUAL_KEY, {"\x00\x80\xff"}},  /* KT_ALT + '9' */
	{0x3B | ALT_KEY | VIRTUAL_KEY, {"\x00\x27\xff"}},  /* KT_ALT + ';' */
	{0x3D | ALT_KEY | VIRTUAL_KEY, {"\x00\x83\xff"}},  /* KT_ALT + '=' */
	{0x41 | ALT_KEY | VIRTUAL_KEY, {"\x00\x1E\xff"}},  /* KT_ALT + 'A' */
	{0x42 | ALT_KEY | VIRTUAL_KEY, {"\x00\x30\xff"}},  /* KT_ALT + 'B' */
	{0x43 | ALT_KEY | VIRTUAL_KEY, {"\x00\x2E\xff"}},  /* KT_ALT + 'C' */
	{0x44 | ALT_KEY | VIRTUAL_KEY, {"\x00\x20\xff"}},  /* KT_ALT + 'D' */
	{0x45 | ALT_KEY | VIRTUAL_KEY, {"\x00\x12\xff"}},  /* KT_ALT + 'E' */
	{0x46 | ALT_KEY | VIRTUAL_KEY, {"\x00\x21\xff"}},  /* KT_ALT + 'F' */
	{0x47 | ALT_KEY | VIRTUAL_KEY, {"\x00\x22\xff"}},  /* KT_ALT + 'G' */
	{0x48 | ALT_KEY | VIRTUAL_KEY, {"\x00\x23\xff"}},  /* KT_ALT + 'H' */
	{0x49 | ALT_KEY | VIRTUAL_KEY, {"\x00\x17\xff"}},  /* KT_ALT + 'I' */
	{0x4A | ALT_KEY | VIRTUAL_KEY, {"\x00\x24\xff"}},  /* KT_ALT + 'J' */
	{0x4B | ALT_KEY | VIRTUAL_KEY, {"\x00\x25\xff"}},  /* KT_ALT + 'K' */
	{0x4C | ALT_KEY | VIRTUAL_KEY, {"\x00\x26\xff"}},  /* KT_ALT + 'L' */
	{0x4D | ALT_KEY | VIRTUAL_KEY, {"\x00\x32\xff"}},  /* KT_ALT + 'M' */
	{0x4E | ALT_KEY | VIRTUAL_KEY, {"\x00\x31\xff"}},  /* KT_ALT + 'N' */
	{0x4F | ALT_KEY | VIRTUAL_KEY, {"\x00\x18\xff"}},  /* KT_ALT + 'O' */
	{0x50 | ALT_KEY | VIRTUAL_KEY, {"\x00\x19\xff"}},  /* KT_ALT + 'P' */
	{0x51 | ALT_KEY | VIRTUAL_KEY, {"\x00\x10\xff"}},  /* KT_ALT + 'Q' */
	{0x52 | ALT_KEY | VIRTUAL_KEY, {"\x00\x13\xff"}},  /* KT_ALT + 'R' */
	{0x53 | ALT_KEY | VIRTUAL_KEY, {"\x00\x1F\xff"}},  /* KT_ALT + 'S' */
	{0x54 | ALT_KEY | VIRTUAL_KEY, {"\x00\x14\xff"}},  /* KT_ALT + 'T' */
	{0x55 | ALT_KEY | VIRTUAL_KEY, {"\x00\x16\xff"}},  /* KT_ALT + 'U' */
	{0x56 | ALT_KEY | VIRTUAL_KEY, {"\x00\x2F\xff"}},  /* KT_ALT + 'V' */
	{0x57 | ALT_KEY | VIRTUAL_KEY, {"\x00\x11\xff"}},  /* KT_ALT + 'W' */
	{0x58 | ALT_KEY | VIRTUAL_KEY, {"\x00\x2D\xff"}},  /* KT_ALT + 'X' */
	{0x59 | ALT_KEY | VIRTUAL_KEY, {"\x00\x15\xff"}},  /* KT_ALT + 'Y' */
	{0x5A | ALT_KEY | VIRTUAL_KEY, {"\x00\x2C\xff"}},  /* KT_ALT + 'Z' */
	{0x5B | ALT_KEY | VIRTUAL_KEY, {"\x00\x1A\xff"}},  /* KT_ALT + '[' */
	{0x5D | ALT_KEY | VIRTUAL_KEY, {"\x00\x1B\xff"}},  /* KT_ALT + ']' */
	{0x60 | ALT_KEY | VIRTUAL_KEY, {"\x00\x29\xff"}},  /* KT_ALT + '`' */
								   				  
	{VK_BACK 	| VIRTUAL_KEY | ALT_KEY, {"\x00\x0E\xff"}},  /* KT_ALT + KN_BS */
	{VK_RETURN	| VIRTUAL_KEY | ALT_KEY, {"\x00\x1C\xff"}},  /* KT_ALT + KN_ENTER */
	{VK_ESCAPE	| VIRTUAL_KEY | ALT_KEY, {"\x00\x01\xff"}},  /* KT_ALT + KN_ESC */
	{VK_F1		| VIRTUAL_KEY | ALT_KEY, {"\x00\x68\xff"}},  /* KT_ALT + KN_F1 */
	{VK_F10		| VIRTUAL_KEY | ALT_KEY, {"\x00\x71\xff"}},  /* KT_ALT + KN_F10 */
	{VK_F11		| VIRTUAL_KEY | ALT_KEY, {"\x00\x8B\xff"}},  /* KT_ALT + KN_F11 */
	{VK_F12		| VIRTUAL_KEY | ALT_KEY, {"\x00\x8C\xff"}},  /* KT_ALT + KN_F12 */
	{VK_F2		| VIRTUAL_KEY | ALT_KEY, {"\x00\x69\xff"}},  /* KT_ALT + KN_F2 */
	{VK_F3		| VIRTUAL_KEY | ALT_KEY, {"\x00\x6A\xff"}},  /* KT_ALT + KN_F3 */
	{VK_F4		| VIRTUAL_KEY | ALT_KEY, {"\x00\x6B\xff"}},  /* KT_ALT + KN_F4 */
	{VK_F5		| VIRTUAL_KEY | ALT_KEY, {"\x00\x6C\xff"}},  /* KT_ALT + KN_F5 */
	{VK_F6		| VIRTUAL_KEY | ALT_KEY, {"\x00\x6D\xff"}},  /* KT_ALT + KN_F6 */
	{VK_F7		| VIRTUAL_KEY | ALT_KEY, {"\x00\x6E\xff"}},  /* KT_ALT + KN_F7 */
	{VK_F8		| VIRTUAL_KEY | ALT_KEY, {"\x00\x6F\xff"}},  /* KT_ALT + KN_F8 */
	{VK_F9		| VIRTUAL_KEY | ALT_KEY, {"\x00\x70\xff"}},  /* KT_ALT + KN_F9 */
	{VK_TAB		| VIRTUAL_KEY | ALT_KEY, {"\x00\xA5\xff"}},  /* KT_ALT + KN_TAB */
										 
	{VK_RETURN | EXTENDED_KEY,	{"\x00\xE0\x0D\xff"}},  /* KT_KP + KN_ENTER */

	{0x2F | EXTENDED_KEY,   {"\x00\xE0\x2F\xff"}},	/* KT_KP + '/' */

	{VK_MULTIPLY | VIRTUAL_KEY,	  {"\x2A\xff"}},	   /* KT_KP + '*' */
	{VK_ADD		| VIRTUAL_KEY,	  {"\x2B\xff"}},	   /* KT_KP + '+' */
	{VK_SUBTRACT | VIRTUAL_KEY,	  {"\x2D\xff"}},	   /* KT_KP + '-' */
	{VK_DECIMAL | VIRTUAL_KEY,	  {"\x2E\xff"}},	   /* KT_KP + '.' */
	{VK_NUMPAD0 | VIRTUAL_KEY,	  {"\x30\xff"}},	   /* KT_KP + '0' */
	{VK_NUMPAD1 | VIRTUAL_KEY,	  {"\x31\xff"}},	   /* KT_KP + '1' */
	{VK_NUMPAD2 | VIRTUAL_KEY,	  {"\x32\xff"}},	   /* KT_KP + '2' */
	{VK_NUMPAD3 | VIRTUAL_KEY,	  {"\x33\xff"}},	   /* KT_KP + '3' */
	{VK_NUMPAD4 | VIRTUAL_KEY,	  {"\x34\xff"}},	   /* KT_KP + '4' */
	{VK_NUMPAD5 | VIRTUAL_KEY,	  {"\x35\xff"}},	   /* KT_KP + '5' */
	{VK_NUMPAD6 | VIRTUAL_KEY,	  {"\x36\xff"}},	   /* KT_KP + '6' */
	{VK_NUMPAD7 | VIRTUAL_KEY,	  {"\x37\xff"}},	   /* KT_KP + '7' */
	{VK_NUMPAD8 | VIRTUAL_KEY,	  {"\x38\xff"}},	   /* KT_KP + '8' */
	{VK_NUMPAD9 | VIRTUAL_KEY,	  {"\x39\xff"}},	   /* KT_KP + '9' */
								  
	{VK_MULTIPLY | VIRTUAL_KEY | CTRL_KEY, {"\x00\x96\xff"}},  /* KT_CTRL + KT_KP + '*' */
	{VK_ADD		| VIRTUAL_KEY | CTRL_KEY,  {"\x00\x90\xff"}},  /* KT_CTRL + KT_KP + '+' */
	{VK_SUBTRACT | VIRTUAL_KEY | CTRL_KEY, {"\x00\x8E\xff"}},  /* KT_CTRL + KT_KP + '-' */
	{VK_DIVIDE	| VIRTUAL_KEY | EXTENDED_KEY | CTRL_KEY, {"\x00\x95\xff"}},  /* KT_CTRL + KT_KP + '/' */
	{0x0a | EXTENDED_KEY | CTRL_KEY, {"\x0A\xff"}}, 	 /* KT_CTRL+KT_KP+KN_ENTER */

	{VK_MULTIPLY | VIRTUAL_KEY | ALT_KEY,  {"\x00\x37\xff"}},  /* KT_ALT + KT_KP + '*' */
	{VK_ADD		| VIRTUAL_KEY | ALT_KEY,   {"\x00\x4E\xff"}},  /* KT_ALT + KT_KP + '+' */
	{VK_SUBTRACT | VIRTUAL_KEY | ALT_KEY,  {"\x00\x4A\xff"}},  /* KT_ALT + KT_KP + '-' */
	{VK_DIVIDE	| VIRTUAL_KEY | ALT_KEY,   {"\x00\xA4\xff"}},  /* KT_ALT + KT_KP + '/' */
														  
	{0x0d | VIRTUAL_KEY | EXTENDED_KEY | ALT_KEY,  {"\x00\xA6\xff"}},  /* KT_ALT + KT_KP +KN_ENTER */

	{VK_DELETE | VIRTUAL_KEY | EXTENDED_KEY, {"\x00\xE0\x53\xff"}},  /* KT_EP +KN_DEL */
	{VK_DOWN   | VIRTUAL_KEY | EXTENDED_KEY, {"\x00\xE0\x50\xff"}},  /* KT_EP +KN_DOWN */
	{VK_END	  | VIRTUAL_KEY | EXTENDED_KEY,  {"\x00\xE0\x4F\xff"}},  /* KT_EP +KN_END */
	{VK_HOME   | VIRTUAL_KEY | EXTENDED_KEY, {"\x00\xE0\x47\xff"}},  /* KT_EP +KN_HOME */
	{VK_INSERT | VIRTUAL_KEY | EXTENDED_KEY, {"\x00\xE0\x52\xff"}},  /* KT_EP +KN_INS */
	{VK_LEFT   | VIRTUAL_KEY | EXTENDED_KEY, {"\x00\xE0\x4B\xff"}},  /* KT_EP +KN_LEFT */
	{VK_NEXT   | VIRTUAL_KEY | EXTENDED_KEY, {"\x00\xE0\x51\xff"}},  /* KT_EP +KN_PGDN */
	{VK_PRIOR  | VIRTUAL_KEY | EXTENDED_KEY, {"\x00\xE0\x49\xff"}},  /* KT_EP +KN_PGUP */
	{VK_RIGHT  | VIRTUAL_KEY | EXTENDED_KEY, {"\x00\xE0\x4D\xff"}},  /* KT_EP +KN_RIGHT */
	{VK_UP	  | VIRTUAL_KEY | EXTENDED_KEY,  {"\x00\xE0\x48\xff"}},  /* KT_EP +KN_UP */

	{VK_DELETE | VIRTUAL_KEY | EXTENDED_KEY | CTRL_KEY, {"\x00\xE0\x93\xff"}},	/* KT_CTRL + KT_EP +KN_DEL */
	{VK_DOWN   | VIRTUAL_KEY | EXTENDED_KEY | CTRL_KEY, {"\x00\xE0\x91\xff"}},	/* KT_CTRL + KT_EP +KN_DOWN */
	{VK_END	  | VIRTUAL_KEY | EXTENDED_KEY | CTRL_KEY,  {"\x00\xE0\x75\xff"}},	/* KT_CTRL + KT_EP +KN_END */
	{VK_HOME   | VIRTUAL_KEY | EXTENDED_KEY | CTRL_KEY, {"\x00\xE0\x77\xff"}},	/* KT_CTRL + KT_EP +KN_HOME */
	{VK_INSERT | VIRTUAL_KEY | EXTENDED_KEY | CTRL_KEY, {"\x00\xE0\x92\xff"}},	/* KT_CTRL + KT_EP +KN_INS */
	{VK_LEFT   | VIRTUAL_KEY | EXTENDED_KEY | CTRL_KEY, {"\x00\xE0\x73\xff"}},	/* KT_CTRL + KT_EP +KN_LEFT */
	{VK_NEXT   | VIRTUAL_KEY | EXTENDED_KEY | CTRL_KEY, {"\x00\xE0\x76\xff"}},	/* KT_CTRL + KT_EP +KN_PGDN */
	{VK_PRIOR  | VIRTUAL_KEY | EXTENDED_KEY | CTRL_KEY, {"\x00\xE0\x84\xff"}},	/* KT_CTRL + KT_EP +KN_PGUP */
	{VK_RIGHT  | VIRTUAL_KEY | EXTENDED_KEY | CTRL_KEY, {"\x00\xE0\x74\xff"}},	/* KT_CTRL + KT_EP +KN_RIGHT */
	{VK_UP	  | VIRTUAL_KEY | EXTENDED_KEY | CTRL_KEY,  {"\x00\xE0\x8D\xff"}},	/* KT_CTRL + KT_EP +KN_UP */

	{VK_DELETE | VIRTUAL_KEY | EXTENDED_KEY | ALT_KEY, {"\x00\xA3\xff"}},  /* KT_ALT + KT_EP +KN_DEL */
	{VK_DOWN   | VIRTUAL_KEY | EXTENDED_KEY | ALT_KEY, {"\x00\xA0\xff"}},  /* KT_ALT + KT_EP +KN_DOWN */
	{VK_END	  | VIRTUAL_KEY | EXTENDED_KEY | ALT_KEY,  {"\x00\x9F\xff"}},  /* KT_ALT + KT_EP +KN_END */
	{VK_HOME   | VIRTUAL_KEY | EXTENDED_KEY | ALT_KEY, {"\x00\x97\xff"}},  /* KT_ALT + KT_EP +KN_HOME */
	{VK_INSERT | VIRTUAL_KEY | EXTENDED_KEY | ALT_KEY, {"\x00\xA2\xff"}},  /* KT_ALT + KT_EP +KN_INS */
	{VK_LEFT   | VIRTUAL_KEY | EXTENDED_KEY | ALT_KEY, {"\x00\x9B\xff"}},  /* KT_ALT + KT_EP +KN_LEFT */
	{VK_NEXT   | VIRTUAL_KEY | EXTENDED_KEY | ALT_KEY, {"\x00\xA1\xff"}},  /* KT_ALT + KT_EP +KN_PGDN */
	{VK_PRIOR  | VIRTUAL_KEY | EXTENDED_KEY | ALT_KEY, {"\x00\x99\xff"}},  /* KT_ALT + KT_EP +KN_PGUP */
	{VK_RIGHT  | VIRTUAL_KEY | EXTENDED_KEY | ALT_KEY, {"\x00\x9D\xff"}},  /* KT_ALT + KT_EP +KN_RIGHT */
	{VK_UP	  | VIRTUAL_KEY | EXTENDED_KEY | ALT_KEY,  {"\x00\x98\xff"}},  /* KT_ALT + KT_EP +KN_UP */

	{0x32 | VIRTUAL_KEY | CTRL_KEY, {"\x00\x03\xff"}},	/* KT_CTRL + '@' (NUL) */
	};


/* for VT52 emulator */
const KEYTBLSTORAGE VT52KeyTable[MAX_VT52_KEYS] =
    {
	{VK_UP	  | EXTENDED_KEY | VIRTUAL_KEY,{"\x1B\x41\xff"}},  /* KN_UP */
	{VK_DOWN | EXTENDED_KEY | VIRTUAL_KEY,{"\x1B\x42\xff"}},  /* KN_DOWN */
	{VK_RIGHT| EXTENDED_KEY | VIRTUAL_KEY,{"\x1B\x43\xff"}},  /* KN_RIGHT */
	{VK_LEFT | EXTENDED_KEY | VIRTUAL_KEY,{"\x1B\x44\xff"}},  /* KN_LEFT */
	   
	{VK_UP	 | VIRTUAL_KEY,					{"\x1B\x41\xff"}},  /* KN_UP */
	{VK_DOWN | VIRTUAL_KEY,				{"\x1B\x42\xff"}},  /* KN_DOWN */
	{VK_RIGHT| VIRTUAL_KEY,				{"\x1B\x43\xff"}},  /* KN_RIGHT */
	{VK_LEFT | VIRTUAL_KEY,				{"\x1B\x44\xff"}},  /* KN_LEFT */

	{VK_F1	| VIRTUAL_KEY,					{"\x1BP\xff"}},  /* KN_F1 */
	{VK_F2	| VIRTUAL_KEY,					{"\x1BQ\xff"}},  /* KN_F2 */
	{VK_F3	| VIRTUAL_KEY,					{"\x1BR\xff"}},  /* KN_F3 */
	{VK_F4	| VIRTUAL_KEY,					{"\x1BS\xff"}},  /* KN_F4 */

	{VK_F1	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1BP\xff"}},  /* KN_F1 */
	{VK_F2	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1BQ\xff"}},  /* KN_F2 */
	{VK_F3	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1BR\xff"}},  /* KN_F3 */
	{VK_F4	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1BS\xff"}},  /* KN_F4 */

	{VK_DELETE	| VIRTUAL_KEY,				{"\x7F\xff"}}, 	/* KN_DEL */
	{VK_DELETE	| VIRTUAL_KEY | EXTENDED_KEY,{"\x7F\xff"}}, 	/* KN_DEL */

	{VK_ADD	| VIRTUAL_KEY,					{",\xff"}},
	};

const KEYTBLSTORAGE VT52_Keypad_KeyTable[MAX_VT52_KEYPAD_KEYS] =
    {
	{VK_NUMPAD0 | VIRTUAL_KEY,	 {"\x1B?p\xff"}}, /* KT_KP + '0' (alternate mode) */
	{VK_NUMPAD1 | VIRTUAL_KEY,	 {"\x1B?q\xff"}}, /* KT_KP + '1' (alternate mode) */
	{VK_NUMPAD2 | VIRTUAL_KEY,	 {"\x1B?r\xff"}}, /* KT_KP + '2' (alternate mode) */
	{VK_NUMPAD3 | VIRTUAL_KEY,	 {"\x1B?s\xff"}}, /* KT_KP + '3' (alternate mode) */
	{VK_NUMPAD4 | VIRTUAL_KEY,	 {"\x1B?t\xff"}}, /* KT_KP + '4' (alternate mode) */
	{VK_NUMPAD5 | VIRTUAL_KEY,	 {"\x1B?u\xff"}}, /* KT_KP + '5' (alternate mode) */
	{VK_NUMPAD6 | VIRTUAL_KEY,	 {"\x1B?v\xff"}}, /* KT_KP + '6' (alternate mode) */
	{VK_NUMPAD7 | VIRTUAL_KEY,	 {"\x1B?w\xff"}}, /* KT_KP + '7' (alternate mode) */
	{VK_NUMPAD8 | VIRTUAL_KEY,	 {"\x1B?x\xff"}}, /* KT_KP + '8' (alternate mode) */
	{VK_NUMPAD9 | VIRTUAL_KEY,	 {"\x1B?y\xff"}}, /* KT_KP + '9' (alternate mode) */
	{VK_DECIMAL | VIRTUAL_KEY,	 {"\x1B?n\xff"}}, /* KT_KP + '.' (alternate mode) */

	{VK_ADD		| VIRTUAL_KEY,	 {"\x1B?l\xff"}},	/* KT_KP + '+' (alternate mode) */
	{VK_RETURN	| EXTENDED_KEY,  {"\x1B?M\xff"}},	/* KT_KP + enter  (alternate mode) */
	{VK_SUBTRACT | VIRTUAL_KEY,	 {"\x1B?m\xff"}},	/* KT_KP + '-' (alternate mode) */
	};						  

const KEYTBLSTORAGE VT_PF_KeyTable[MAX_VT_PF_KEYS] =
    {
	{VK_NUMLOCK	| VIRTUAL_KEY | EXTENDED_KEY, {"\x1BP\xff"}},	/* KT_KP + NUMLOCK */
	{0x2F		| EXTENDED_KEY, 			  {"\x1BQ\xff"}},	/* KT_KP + '/' */
	{VK_MULTIPLY | VIRTUAL_KEY,				  {"\x1BR\xff"}},	/* KT_KP + '*' */
	{VK_SUBTRACT | VIRTUAL_KEY,				  {"\x1BS\xff"}},	/* KT_KP + '-' */
	};

/* for VT100 emulator */

const KEYTBLSTORAGE VT100KeyTable[MAX_VT100_KEYS] =
    {
	{VK_UP	 | VIRTUAL_KEY,				{"\x1B[A\xff"}},  /* KN_UP */
	{VK_DOWN | VIRTUAL_KEY,				{"\x1B[B\xff"}},  /* KN_DOWN */
	{VK_RIGHT| VIRTUAL_KEY,				{"\x1B[C\xff"}},  /* KN_RIGHT */
	{VK_LEFT | VIRTUAL_KEY,				{"\x1B[D\xff"}},  /* KN_LEFT */

	{VK_UP	 | EXTENDED_KEY | VIRTUAL_KEY,	{"\x1B[A\xff"}},  /* KN_UP */
	{VK_DOWN | EXTENDED_KEY | VIRTUAL_KEY,{"\x1B[B\xff"}},  /* KN_DOWN */
	{VK_RIGHT| EXTENDED_KEY | VIRTUAL_KEY,{"\x1B[C\xff"}},  /* KN_RIGHT */
	{VK_LEFT | EXTENDED_KEY | VIRTUAL_KEY,{"\x1B[D\xff"}},  /* KN_LEFT */

	{VK_F1	| VIRTUAL_KEY,					{"\x1BOP\xff"}},  /* KN_F1 */
	{VK_F2	| VIRTUAL_KEY,					{"\x1BOQ\xff"}},  /* KN_F2 */
	{VK_F3	| VIRTUAL_KEY,					{"\x1BOR\xff"}},  /* KN_F3 */
	{VK_F4	| VIRTUAL_KEY,					{"\x1BOS\xff"}},  /* KN_F4 */

	{VK_F1	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1BOP\xff"}},  /* KN_F1 */
	{VK_F2	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1BOQ\xff"}},  /* KN_F2 */
	{VK_F3	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1BOR\xff"}},  /* KN_F3 */
	{VK_F4	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1BOS\xff"}},  /* KN_F4 */

	{VK_DELETE | VIRTUAL_KEY,				{"\x7F\xff"}},	/* KN_DEL */
	{VK_DELETE | VIRTUAL_KEY | EXTENDED_KEY,{"\x7F\xff"}},	/* KN_DEL */

	{VK_ADD	| VIRTUAL_KEY,							{",\xff"}},

	{VK_SPACE | VIRTUAL_KEY | CTRL_KEY,				{"\x00\xff"}}, 	  /* CTRL + SPACE */
	{0x32   | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY,	{"\x00\xff"}}, 	/* CTRL + @ */
	{0x32	| VIRTUAL_KEY | CTRL_KEY,				{"\x00\xff"}}, 	/* CTRL + 2 */
	{0x36	| VIRTUAL_KEY | CTRL_KEY,				{"\x1e\xff"}},	/* CTRL + 6 */
	{0xbd	| VIRTUAL_KEY | CTRL_KEY,				{"\x1f\xff"}},	/* CTRL + - */
	};

const KEYTBLSTORAGE VT100_Cursor_KeyTable[MAX_VT100_CURSOR_KEYS] =
    {
	{VK_UP	 | EXTENDED_KEY | VIRTUAL_KEY,	{"\x1BOA\xff"}},  /* KN_UP */
	{VK_DOWN | EXTENDED_KEY | VIRTUAL_KEY,{"\x1BOB\xff"}},  /* KN_DOWN */
	{VK_RIGHT| EXTENDED_KEY | VIRTUAL_KEY,{"\x1BOC\xff"}},  /* KN_RIGHT */
	{VK_LEFT | EXTENDED_KEY | VIRTUAL_KEY,{"\x1BOD\xff"}},  /* KN_LEFT */

	{VK_UP	 | VIRTUAL_KEY,				{"\x1BOA\xff"}},  /* KN_UP */
	{VK_DOWN | VIRTUAL_KEY,				{"\x1BOB\xff"}},  /* KN_DOWN */
	{VK_RIGHT| VIRTUAL_KEY,				{"\x1BOC\xff"}},  /* KN_RIGHT */
	{VK_LEFT | VIRTUAL_KEY,				{"\x1BOD\xff"}},  /* KN_LEFT */
	};

const KEYTBLSTORAGE VT100_Keypad_KeyTable[MAX_VT100_KEYPAD_KEYS] =
    {
	{VK_NUMPAD0 | VIRTUAL_KEY,	 {"\x1BOp\xff"}}, /* KT_KP + '0' (alternate mode) */
	{VK_NUMPAD1 | VIRTUAL_KEY,	 {"\x1BOq\xff"}}, /* KT_KP + '1' (alternate mode) */
	{VK_NUMPAD2 | VIRTUAL_KEY,	 {"\x1BOr\xff"}}, /* KT_KP + '2' (alternate mode) */
	{VK_NUMPAD3 | VIRTUAL_KEY,	 {"\x1BOs\xff"}}, /* KT_KP + '3' (alternate mode) */
	{VK_NUMPAD4 | VIRTUAL_KEY,	 {"\x1BOt\xff"}}, /* KT_KP + '4' (alternate mode) */
	{VK_NUMPAD5 | VIRTUAL_KEY,	 {"\x1BOu\xff"}}, /* KT_KP + '5' (alternate mode) */
	{VK_NUMPAD6 | VIRTUAL_KEY,	 {"\x1BOv\xff"}}, /* KT_KP + '6' (alternate mode) */
	{VK_NUMPAD7 | VIRTUAL_KEY,	 {"\x1BOw\xff"}}, /* KT_KP + '7' (alternate mode) */
	{VK_NUMPAD8 | VIRTUAL_KEY,	 {"\x1BOx\xff"}}, /* KT_KP + '8' (alternate mode) */
	{VK_NUMPAD9 | VIRTUAL_KEY,	 {"\x1BOy\xff"}}, /* KT_KP + '9' (alternate mode) */
	{VK_DECIMAL | VIRTUAL_KEY,	 {"\x1BOn\xff"}}, /* KT_KP + '.' (alternate mode) */

	{VK_ADD		| VIRTUAL_KEY,	 {"\x1BOl\xff"}}, /* KT_KP + '*' (alternate mode) */
	{VK_RETURN	| EXTENDED_KEY,  {"\x1BOM\xff"}}, /* KT_KP + '+' (alternate mode) */
	{VK_SUBTRACT | VIRTUAL_KEY,	 {"\x1BOm\xff"}}, /* KT_KP + '-' (alternate mode) */
	};

#if defined(INCL_MINITEL)
const KEYTBLSTORAGE Minitel_KeyTable[MAX_MINITEL_KEYS] =
	{
	{0x4D		| VIRTUAL_KEY	| CTRL_KEY, 	{"\x0D\xff"}},  /* ctrl-m */

	{VK_RETURN  | VIRTUAL_KEY,					{"\x13\x41\xff"}}, /* Envoi CNTRL-MA*/
	{VK_RETURN	| EXTENDED_KEY,					{"\x13\x41\xff"}}, /* Send CNTRL-MA*/
	{VK_TAB		| VIRTUAL_KEY,					{"\x13\x41\xff"}}, /* Send CNTRL-MA*/
	{VK_F8		| VIRTUAL_KEY,					{"\x13\x41\xff"}}, /* Send CNTRL-MA*/

	{VK_HOME 	| VIRTUAL_KEY,					{"\x13\x46"}}, /* Sommaire CNTRL-MF*/
	{VK_HOME 	| VIRTUAL_KEY	| EXTENDED_KEY, {"\x13\x46\xff"}}, /* Index CNTRL-MF*/
	{VK_F1		| VIRTUAL_KEY,					{"\x13\x46\xff"}}, /* Index CNTRL-MF*/

	{VK_DELETE	| VIRTUAL_KEY,					{"\x13\x45\xff"}}, /* Annulation CNTRL-ME*/
	{VK_DELETE	| VIRTUAL_KEY	| EXTENDED_KEY, {"\x13\x45\xff"}}, /* Cancel CNTRL-ME*/
	{VK_F2		| VIRTUAL_KEY,					{"\x13\x45\xff"}}, /* Cancel CNTRL-ME*/

	{VK_PRIOR	| VIRTUAL_KEY,					{"\x13\x42\xff"}}, /* Retour CNTRL-MB*/
	{VK_PRIOR	| VIRTUAL_KEY	| EXTENDED_KEY, {"\x13\x42\xff"}}, /* Previous CNTRL-MB*/
	{VK_F3		| VIRTUAL_KEY,					{"\x13\x42\xff"}}, /* Previous CNTRL-MB*/

	{VK_INSERT	| VIRTUAL_KEY,					{"\x13\x43\xff"}}, /* Repeat CNTRL-MC*/
	{VK_INSERT	| VIRTUAL_KEY	| EXTENDED_KEY, {"\x13\x43\xff"}}, /* Repeat CNTRL-MC*/
	{VK_F4		| VIRTUAL_KEY,					{"\x13\x43\xff"}}, /* Repeat CNTRL-MC*/
															
	{VK_BACK 	| VIRTUAL_KEY,					{"\x13\x47\xff"}}, /* Correct CNTRL-MG*/
	{VK_F6		| VIRTUAL_KEY,					{"\x13\x47\xff"}}, /* Correct CNTRL-MG*/

	{VK_INSERT	| VIRTUAL_KEY,					{"\x13\x44\xff"}}, /* Guide CNTRL-MD*/
	{VK_INSERT	| VIRTUAL_KEY	| EXTENDED_KEY, {"\x13\x44\xff"}}, /* Guide CNTRL-MD*/
	{VK_F5		| VIRTUAL_KEY,					{"\x13\x44\xff"}}, /* Guide CNTRL-MD*/

	{VK_NEXT 	| VIRTUAL_KEY,					{"\x13\x48\xff"}}, /* Suite CNTRL-MH*/
	{VK_NEXT 	| VIRTUAL_KEY	| EXTENDED_KEY, {"\x13\x48\xff"}}, /* Next CNTRL-MH*/
	{VK_F7		| VIRTUAL_KEY,					{"\x13\x48\xff"}}, /* Next CNTRL-MH*/

	{VK_F9		| VIRTUAL_KEY,					{"\x13\x49\xff"}}, /* Connect (page 123) */

	// Page 124

	{VK_UP		| VIRTUAL_KEY,								   {"\x1B[A\xff"}},
	{VK_UP		| VIRTUAL_KEY | EXTENDED_KEY,				   {"\x1B[A\xff"}},
	
	{VK_UP		| VIRTUAL_KEY | SHIFT_KEY,					   {"\x1B[M\xff"}},
	{VK_UP		| VIRTUAL_KEY | EXTENDED_KEY | SHIFT_KEY,	   {"\x1B[M\xff"}},
																			
	{VK_DOWN 	| VIRTUAL_KEY,								   {"\x1B[B\xff"}},
	{VK_DOWN 	| VIRTUAL_KEY | EXTENDED_KEY,				   {"\x1B[B\xff"}},

	{VK_DOWN 	| VIRTUAL_KEY | SHIFT_KEY,					   {"\x1B[L\xff"}},
	{VK_DOWN 	| VIRTUAL_KEY | SHIFT_KEY | EXTENDED_KEY,	   {"\x1B[L\xff"}},

	{VK_RIGHT	| VIRTUAL_KEY,								   {"\x1B[C\xff"}},
	{VK_RIGHT	| VIRTUAL_KEY | EXTENDED_KEY,				   {"\x1B[C\xff"}},

	/* See minitel kbdin routine on this one - mrw */
	{VK_RIGHT	| VIRTUAL_KEY | SHIFT_KEY,					   {"\x1B[4\xff"}},
	{VK_RIGHT	| VIRTUAL_KEY | SHIFT_KEY | EXTENDED_KEY,	   {"\x1B[4\xff"}},

	{VK_LEFT 	| VIRTUAL_KEY,								   {"\x1B[D\xff"}},
	{VK_LEFT 	| VIRTUAL_KEY | EXTENDED_KEY,				   {"\x1B[D\xff"}},

	{VK_LEFT 	| VIRTUAL_KEY | SHIFT_KEY,					   {"\x1B[P\xff"}},
	{VK_LEFT 	| VIRTUAL_KEY | SHIFT_KEY | EXTENDED_KEY,	   {"\x1B[P\xff"}},
	{VK_LEFT 	| VIRTUAL_KEY | CTRL_KEY,					   {"\x7F\xff"}},	
	{VK_LEFT 	| VIRTUAL_KEY | CTRL_KEY | EXTENDED_KEY,	   {"\x7F\xff"}},	

	/* numpad enter */
	{VK_RETURN	| VIRTUAL_KEY | EXTENDED_KEY,				   {"\x13\x41\xff"}},
	{VK_RETURN	| VIRTUAL_KEY | EXTENDED_KEY | SHIFT_KEY,	   {"\x1B[H\xff"}},
	{VK_RETURN	| VIRTUAL_KEY | EXTENDED_KEY | CTRL_KEY,	   {"\x1B[2J\xff"}},

	// page 118

	{0xA3,	{"\x19\x23\xff"}},		// British pound symbol.
	{0xA7,	{"\x19\x27\xff"}},		// Paragraph symbol.
	{0xA8,	{"\x19\x48\xff"}},		// umluot

	{0xB0,	{"\x19\x30\xff"}},		// degree symbol
	{0xB1,	{"\x19\x31\xff"}},		// plus over minus symbol
	{0xB4,	{"\x19\x42\xff"}},		// accute accent
	{0xBC,	{"\x19\x3C\xff"}},		// 1/4
	{0xBD,	{"\x19\x3D\xff"}},		// 1/2
	{0xBE,	{"\x19\x3E\xff"}},		// 3/4
	{0xB8,	{"\x19\x4B\xff"}},		// beard

	{0xC0,	{"\x19\x2D\xff"}},		// up arrow symbol
	{0xC3,	{"\x19\x2C\xff"}},		// left arrow symbol
	{0xC4,	{"\x19\x2E\xff"}},		// right arrow symbol
	{0xC5,	{"\x19\x2F\xff"}},		// down arrow symbol

	{0xDF,	{"\x19\x7B\xff"}},		// Beta

	{0xE0,	{"\x19\x41\x61\xff"}},	// a grave accent
	{0xE2,	{"\x19\x43\x61\xff"}},	// a circumflex
	{0xE4,	{"\x19\x48\x61\xff"}},	// a umluot
	{0xE7,	{"\x19\x4B\x63\xff"}},	// c with a beard
	{0xE8,	{"\x19\x41\x65\xff"}},	// e grave accent
	{0xE9,	{"\x19\x42\x65\xff"}},	// e accute accent
	{0xEA,	{"\x19\x43\x65\xff"}},	// e circumflex
	{0xEB,	{"\x19\x48\x65\xff"}},	// e umluot
	{0xEE,	{"\x19\x43\x69\xff"}},	// i circumflex
	{0xEF,	{"\x19\x48\x69\xff"}},	// i umluot

	{0xF4,	{"\x19\x43\x6f\xff"}},	// o circumflex
	{0xF5,	{"\x19\x48\x6f\xff"}},	// o umluot
	{0xF7,	{"\x19\x38\xff"}},		// divide-by symbol
	{0xF9,	{"\x19\x41\x75\xff"}},	// u grave accent
	{0xFB,	{"\x19\x43\x75\xff"}},	// u circumflex
	{0xFC,	{"\x19\x48\x75\xff"}},	// u circumflex

	{0x5E,	{"\x19\x43\xff"}},		// circumflex accent (^)
	{0x60,	{"\x19\x41\xff"}},		// grave accent(`)
	{0x8C,	{"\x19\x6A\xff"}},		// big OE
	{0x9C,	{"\x19\x7A\xff"}},		// little oe
	};		
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuCreateHdl
 *
 * DESCRIPTION:
 *	Creates an emulator handle.  The creation of an Emulator handle
 *	includes setting default user settings and loading the ANSI
 *	emulator.
 *
 * ARGUMENTS:
 *	hSession - session handle.
 *
 * RETURNS:
 *	HEMU or zero on error.
 *
 */
HEMU emuCreateHdl(const HSESSION hSession)
	{
	HHEMU hhEmu;

	hhEmu = malloc(sizeof(*hhEmu));

	if (hhEmu == 0)
		{
		assert(FALSE);
		return 0;
		}

	memset(hhEmu, 0, sizeof(*hhEmu));

	InitializeCriticalSection(&hhEmu->csEmu);

	hhEmu->hSession = hSession;

	// Create and load the Emulator Name & Id table.
	//
	if (!emuCreateNameTable(hhEmu))
		{
		assert(FALSE);
		emuDestroyHdl((HEMU)hhEmu);
		hhEmu = NULL;
		return 0;
		}

	// Create the text and attribute buffers.
	//
	if (!emuCreateTextAttrBufs((HEMU)hhEmu, MAX_EMUROWS, MAX_EMUCOLS))
		{
		assert(FALSE);
		emuDestroyHdl((HEMU)hhEmu);
		hhEmu = NULL;
		return 0;
		}

	// Create the Print handle used for Printer Echo.
	//
	hhEmu->hPrintEcho = printCreateHdl(hSession);
	if(hhEmu->hPrintEcho == 0)
		{
		assert(FALSE);
		emuDestroyHdl((HEMU)hhEmu);
		hhEmu = NULL;
		return 0;
		}

	// Create the Print handle used for Host directed printing.
	//
	hhEmu->hPrintHost = printCreateHdl(hSession);
	if (hhEmu->hPrintHost == 0)
		{
		assert(FALSE);
		emuDestroyHdl((HEMU)hhEmu);
		hhEmu = NULL;
		return 0;
		}

	// Initialize the user settings for the emulation handle.
	//
	if (emuInitializeHdl((HEMU)hhEmu) != 0)
		{
		assert(FALSE);
		emuDestroyHdl((HEMU)hhEmu);
		hhEmu = NULL;
		return 0;
		}

	return (HEMU)hhEmu;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuDestroyHdl
 *
 * DESCRIPTION:
 *	Death and destruction of the once noble emulator handle.
 *
 * ARGUMENTS:
 *	hEmu	- external emulator handle.
 *
 * RETURNS:
 *	0=OK, else error
 *
 */
int emuDestroyHdl(const HEMU hEmu)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hhEmu == 0)
		{
		assert(0);
		return -1;
		}

	if (hhEmu->pstNameTable)
		{
		free(hhEmu->pstNameTable);
		hhEmu->pstNameTable = NULL;
		}

    if (hhEmu->emu_deinstall)
        {
		(*hhEmu->emu_deinstall)(hhEmu);
        }

	printDestroyHdl(hhEmu->hPrintEcho);
	hhEmu->hPrintEcho = NULL;
	printDestroyHdl(hhEmu->hPrintHost);
	hhEmu->hPrintHost = NULL;
	emuDestroyTextAttrBufs(hEmu);
	DeleteCriticalSection(&hhEmu->csEmu);

	if(hhEmu)
		free(hhEmu);

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuInitializeHdl
 *
 * DESCRIPTION:
 *	This function initializes the stUserSettings structure of the internal
 *	emulator handle with the values stored in the session file.
 *
 * ARGUMENTS:
 *	HEMU	-	The External Emulator Handle.
 *
 * RETURNS:
 *	0 if successful, otherwise -1
 *
 */
int emuInitializeHdl(const HEMU hEmu)
	{
	int nRet, nReturn;
	struct stEmuBaseSFSettings stBaseSFSettings;

	const HHEMU hhEmu = (HHEMU)hEmu;

	nReturn = -1;

	if (hhEmu == 0)
		{
		assert(FALSE);
		return nReturn;
		}

	emuLock(hEmu);

	hhEmu->emu_maxcol		= EMU_DEFAULT_MAXCOL;
	hhEmu->emu_maxrow		= EMU_DEFAULT_MAXROW;
	hhEmu->bottom_margin	= EMU_DEFAULT_MAXROW;

	hhEmu->mode_vt220 = FALSE;
	hhEmu->mode_vt320 = FALSE;

	// Added for the VT220/320 rde 16 Feb 1998
	hhEmu->fUse8BitCodes = FALSE;
	hhEmu->fAllowUserKeys = FALSE;

#if defined(INCL_PRINT_PASSTHROUGH)
	// Added for VT100/220/320 mpt: 5-19-00
	// hhEmu->fPrintRaw = FALSE;
#endif // INCL_PRINT_PASSTHROUGH

	hhEmu->attrState[0].txtclr =
	hhEmu->attrState[1].txtclr = VC_WHITE;

	hhEmu->attrState[0].bkclr =
	hhEmu->attrState[1].bkclr = VC_BLACK;

	hhEmu->iCurAttrState = CS_STATE;

	std_setcolors(hhEmu, GetNearestColorIndex(GetSysColor(COLOR_WINDOWTEXT)),
							GetNearestColorIndex(GetSysColor(COLOR_WINDOW)));

	// Initialize the user setting default values.
	//
	memset(&stBaseSFSettings, 0, sizeof(stBaseSFSettings));

	stBaseSFSettings.nTermKeys 			= EMU_KEYS_TERM;
	stBaseSFSettings.nCursorType		= EMU_CURSOR_LINE;
	stBaseSFSettings.fCursorBlink		= TRUE;
	stBaseSFSettings.nCharacterSet 		= EMU_CHARSET_ASCII;
	stBaseSFSettings.fMapPFkeys			= FALSE;
	stBaseSFSettings.fAltKeypadMode		= FALSE;
	stBaseSFSettings.fKeypadAppMode		= FALSE;
	stBaseSFSettings.fCursorKeypadMode	= FALSE;
	stBaseSFSettings.fReverseDelBk 		= FALSE;
	stBaseSFSettings.f132Columns		= FALSE;
	stBaseSFSettings.fWrapLines			= TRUE;
 	stBaseSFSettings.fDestructiveBk		= TRUE;
	stBaseSFSettings.fLbSymbolOnEnter	= FALSE;
    stBaseSFSettings.fUse8BitCodes		= FALSE; 
    stBaseSFSettings.fAllowUserKeys		= FALSE;  
	stBaseSFSettings.nEmuId				= EMU_AUTO;
#if defined(INCL_ULTC_VERSION)
	stBaseSFSettings.nEmuId				= EMU_VT220;
	stBaseSFSettings.nCharacterSet 		= EMU_CHARSET_MULTINATIONAL;
#endif
	stBaseSFSettings.nAutoAttempts		= 0;
#ifdef INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID
    // Initialize new user settings. - cab:11/14/96
    //
    stBaseSFSettings.nBackspaceKeys		= EMU_BKSPKEYS_CTRLH;

    // Zero the telnet id string. I am doing this because if there
    // isn't one in the session file, I want to load the default.
    //
    stBaseSFSettings.acTelnetId[0]		= TEXT('\0');

    emuQueryDefaultTelnetId(stBaseSFSettings.nEmuId,
			stBaseSFSettings.acTelnetId, EMU_MAX_TELNETID);
#endif

	// Load the settings if they exist.
	if ((nRet = emuLoadSettings(hhEmu, 
								SFID_EMU_SETTINGS,
								sizeof(stBaseSFSettings),
								&stBaseSFSettings)) == -1)
		{
		nReturn = -1;
		goto InitExit;
		}

	if (nRet > 0)
		{
		// The data was present.
        // Check to see if there is a telnet id. If not, use the default.
        //
		emuCheckSettings(&stBaseSFSettings); 

#ifdef INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID
        if ( stBaseSFSettings.acTelnetId[0] == TEXT('\0') )
            {
            emuQueryDefaultTelnetId(stBaseSFSettings.nEmuId,
					stBaseSFSettings.acTelnetId, EMU_MAX_TELNETID);
            }
#endif
		}

	// Initialize the emu's user settings structure from the data stored
	// in the session file.
	hhEmu->stUserSettings.nEmuId = stBaseSFSettings.nEmuId;
	hhEmu->stUserSettings.nTermKeys = stBaseSFSettings.nTermKeys;	
	hhEmu->stUserSettings.nCursorType = stBaseSFSettings.nCursorType;
	hhEmu->stUserSettings.nCharacterSet = stBaseSFSettings.nCharacterSet;
	hhEmu->stUserSettings.nAutoAttempts = stBaseSFSettings.nAutoAttempts;
	hhEmu->stUserSettings.fCursorBlink = stBaseSFSettings.fCursorBlink;
	hhEmu->stUserSettings.fMapPFkeys = stBaseSFSettings.fMapPFkeys;
	hhEmu->stUserSettings.fAltKeypadMode = stBaseSFSettings.fAltKeypadMode;
	hhEmu->stUserSettings.fKeypadAppMode = stBaseSFSettings.fKeypadAppMode;
	hhEmu->stUserSettings.fCursorKeypadMode = stBaseSFSettings.fCursorKeypadMode;
	hhEmu->stUserSettings.fReverseDelBk = stBaseSFSettings.fReverseDelBk;
	hhEmu->stUserSettings.f132Columns = stBaseSFSettings.f132Columns;
#if defined(INCL_PRINT_PASSTHROUGH)
	//hhEmu->stUserSettings.fPrintRaw = stBaseSFSettings.fPrintRaw;
#endif // INCL_PRINT_PASSTHROUGH
	hhEmu->stUserSettings.fDestructiveBk = stBaseSFSettings.fDestructiveBk;
	hhEmu->stUserSettings.fWrapLines = stBaseSFSettings.fWrapLines;
	hhEmu->stUserSettings.fLbSymbolOnEnter = stBaseSFSettings.fLbSymbolOnEnter;
    hhEmu->stUserSettings.fUse8BitCodes = stBaseSFSettings.fUse8BitCodes;	
    hhEmu->stUserSettings.fAllowUserKeys = stBaseSFSettings.fAllowUserKeys;
    hhEmu->stUserSettings.nBackspaceKeys = stBaseSFSettings.nBackspaceKeys;

    StrCharCopy(hhEmu->stUserSettings.acTelnetId, stBaseSFSettings.acTelnetId);

#ifdef INCL_TERMINAL_SIZE_AND_COLORS
	// Set up the default colors in case the user settings don't exist.
	#if TRUE  
	hhEmu->stUserSettings.nTextColor = 
			GetNearestColorIndex(GetSysColor(COLOR_WINDOWTEXT));
	hhEmu->stUserSettings.nBackgroundColor =
			GetNearestColorIndex(GetSysColor(COLOR_WINDOW));
	#else
	// We've decided not to do this. rde 14 Jul 98
	// Use white (non-bold) on black. rde 8 Jul 98
	hhEmu->stUserSettings.nBackgroundColor = VC_BLACK;
	hhEmu->stUserSettings.nTextColor = VC_WHITE;
	#endif

	// Load the settings if they exist.
	if ((nRet = emuLoadSettings(hhEmu, 
						SFID_EMU_TEXTCOLOR_SETTING,
						sizeof(hhEmu->stUserSettings.nTextColor),
						&hhEmu->stUserSettings.nTextColor)) == -1)
		{
		nReturn = -1;
		goto InitExit;
		}

	if (nRet > 0)
		{
		// The data was present, so use it.
		std_setcolors(hhEmu, 
				hhEmu->stUserSettings.nTextColor,
				hhEmu->stUserSettings.nBackgroundColor);
		}

	if ((nRet = emuLoadSettings(hhEmu, 
						SFID_EMU_BKGRNDCOLOR_SETTING,
						sizeof(hhEmu->stUserSettings.nBackgroundColor),
						&hhEmu->stUserSettings.nBackgroundColor)) == -1)
		{
		nReturn = -1;
		goto InitExit;
		}

	if (nRet > 0)
		{
		// The data was present, so use it.
		std_setcolors(hhEmu, 
				hhEmu->stUserSettings.nTextColor,
				hhEmu->stUserSettings.nBackgroundColor);
		}

	// Set up the default screen size in case the user settings don't exist.
	hhEmu->stUserSettings.nUserDefRows = 24;
	hhEmu->stUserSettings.nUserDefCols = 
			hhEmu->stUserSettings.f132Columns ? 132 : 80;

#if defined(INCL_PRINT_PASSTHROUGH)
	// default host-controlled print mode with regard to windows drivers
	hhEmu->stUserSettings.fPrintRaw = FALSE;
#endif // INCL_PRINT_PASSTHROUGH
	
	// Load the settings if they exist.
	if ((nRet = emuLoadSettings(hhEmu, 
						SFID_EMU_SCRNROWS_SETTING,
						sizeof(hhEmu->stUserSettings.nUserDefRows),
						&hhEmu->stUserSettings.nUserDefRows)) == -1)
		{
		nReturn = -1;
		goto InitExit;
		}

	if ((nRet = emuLoadSettings(hhEmu, 
						SFID_EMU_SCRNCOLS_SETTING,
						sizeof(hhEmu->stUserSettings.nUserDefCols),
						&hhEmu->stUserSettings.nUserDefCols)) == -1)
		{
		nReturn = -1;
		goto InitExit;
		}

#if defined(INCL_PRINT_PASSTHROUGH)
	if ((nRet = emuLoadSettings(hhEmu, 
						SFID_EMU_PRINT_RAW,
						sizeof(hhEmu->stUserSettings.fPrintRaw),
						&hhEmu->stUserSettings.fPrintRaw)) == -1)
		{
		nReturn = -1;
		goto InitExit;
		}
#endif // INCL_PRINT_PASSTHROUGH

	if (nRet > 0)
		{
		// The data was present, so use it.
		hhEmu->stUserSettings.f132Columns = 
				(hhEmu->stUserSettings.nUserDefCols == 132) ? TRUE : FALSE;

#if FALSE	// TODO:rde Is this needed?
		hhEmu->emu_setscrsize = std_setscrsize;
#endif
		}
#endif

	// Load the emulator.
	//
	nReturn = emuLoad((HEMU)hhEmu, hhEmu->stUserSettings.nEmuId);

    //JMH 01-09-97 emuSetSettings() was being called before emuLoad(), but
    // emuLoad() initialized some values that got set by emuSetSettings().
    // (e.g. 132-column mode).
    //
	// Tell the emulator about the user's settings.
	//
	emuSetSettings((HEMU)hhEmu, &hhEmu->stUserSettings);

	// Clear the emulator image.
	//
	//*for (nRow = 0 ; nRow < MAX_EMUROWS ; ++nRow)
	//*    clear_imgrow(hhEmu, nRow);

	//* This breaks the MINITEL bad	- mrw
	//*(hhEmu->emu_setcurpos)(hhEmu, 0, 0);

	InitExit:

	emuUnlock(hEmu);

	NotifyClient(hhEmu->hSession, EVENT_EMU_SETTINGS, 0);
	NotifyClient(hhEmu->hSession, EVENT_TERM_UPDATE, 0);

	if (nReturn < 0)
		nRet = 0;

	return nReturn;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuSaveHdl
 *
 * DESCRIPTION:
 *	This function stores the emulator user settings in the session file.
 *
 *
 * ARGUMENTS:
 *	HEMU	-	The External Emulator Handle.
 *
 * RETURNS:
 *	0=OK, else error
 *
 */
int emuSaveHdl(const HEMU hEmu)
	{
	struct stEmuBaseSFSettings stBaseSFSettings;
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hhEmu == 0)
		{
		assert(FALSE);
		return -1;
		}

	// Initialize the base structure that gets saved in the session file.
	stBaseSFSettings.nEmuId = hhEmu->stUserSettings.nEmuId;
	stBaseSFSettings.nTermKeys = hhEmu->stUserSettings.nTermKeys;		
	stBaseSFSettings.nCursorType = hhEmu->stUserSettings.nCursorType;
	stBaseSFSettings.nCharacterSet = hhEmu->stUserSettings.nCharacterSet;
	stBaseSFSettings.nAutoAttempts = hhEmu->stUserSettings.nAutoAttempts;
	stBaseSFSettings.fCursorBlink = hhEmu->stUserSettings.fCursorBlink;
	stBaseSFSettings.fMapPFkeys = hhEmu->stUserSettings.fMapPFkeys;
	stBaseSFSettings.fAltKeypadMode = hhEmu->stUserSettings.fAltKeypadMode;
	stBaseSFSettings.fKeypadAppMode = hhEmu->stUserSettings.fKeypadAppMode;
	stBaseSFSettings.fCursorKeypadMode = hhEmu->stUserSettings.fCursorKeypadMode;
	stBaseSFSettings.fReverseDelBk = hhEmu->stUserSettings.fReverseDelBk;
	stBaseSFSettings.f132Columns = hhEmu->stUserSettings.f132Columns;
	stBaseSFSettings.fDestructiveBk = hhEmu->stUserSettings.fDestructiveBk;
	stBaseSFSettings.fWrapLines = hhEmu->stUserSettings.fWrapLines;
	stBaseSFSettings.fLbSymbolOnEnter = hhEmu->stUserSettings.fLbSymbolOnEnter;
    stBaseSFSettings.fUse8BitCodes = hhEmu->stUserSettings.fUse8BitCodes;
    stBaseSFSettings.fAllowUserKeys = hhEmu->stUserSettings.fAllowUserKeys;
    stBaseSFSettings.nBackspaceKeys = hhEmu->stUserSettings.nBackspaceKeys;

    StrCharCopy(stBaseSFSettings.acTelnetId, hhEmu->stUserSettings.acTelnetId);

	emuLock(hEmu);

	sfPutSessionItem(sessQuerySysFileHdl(hhEmu->hSession),
						SFID_EMU_SETTINGS,
						sizeof(stBaseSFSettings),
						&stBaseSFSettings);

#ifdef INCL_TERMINAL_SIZE_AND_COLORS
	sfPutSessionItem(sessQuerySysFileHdl(hhEmu->hSession),
						SFID_EMU_TEXTCOLOR_SETTING,
						sizeof(hhEmu->stUserSettings.nTextColor),
						&hhEmu->stUserSettings.nTextColor);

	sfPutSessionItem(sessQuerySysFileHdl(hhEmu->hSession),
						SFID_EMU_BKGRNDCOLOR_SETTING,
						sizeof(hhEmu->stUserSettings.nBackgroundColor),
						&hhEmu->stUserSettings.nBackgroundColor);

	sfPutSessionItem(sessQuerySysFileHdl(hhEmu->hSession),
						SFID_EMU_SCRNROWS_SETTING,
						sizeof(hhEmu->stUserSettings.nUserDefRows),
						&hhEmu->stUserSettings.nUserDefRows);

	sfPutSessionItem(sessQuerySysFileHdl(hhEmu->hSession),
						SFID_EMU_SCRNCOLS_SETTING,
						sizeof(hhEmu->stUserSettings.nUserDefCols),
						&hhEmu->stUserSettings.nUserDefCols);
#endif

#if defined(INCL_PRINT_PASSTHROUGH)
	sfPutSessionItem(sessQuerySysFileHdl(hhEmu->hSession),
						SFID_EMU_PRINT_RAW,
						sizeof(hhEmu->stUserSettings.fPrintRaw),
						&hhEmu->stUserSettings.fPrintRaw);
#endif // INCL_PRINT_PASSTHROUGH

	emuUnlock(hEmu);

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuLock
 *
 * DESCRIPTION:
 *	Grabs the emulator's critical section semaphore.  Access functions
 *	to the emulator should also call this so we can call emulator
 *	functions from anywhere.
 *
 * ARGUMENTS:
 *	hEmu	- external emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void emuLock(const HEMU hEmu)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;
	EnterCriticalSection(&hhEmu->csEmu);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuUnlock
 *
 * DESCRIPTION:
 *	Releases the emulator's critical section semaphore.
 *
 * ARGUMENTS:
 *	hEmu	- external emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void emuUnlock(const HEMU hEmu)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;
	LeaveCriticalSection(&hhEmu->csEmu);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuGetTxtBuf
 *
 * DESCRIPTION:
 *	Obviously we don't need the handle here but when we do go reentrant,
 *	we only change the guts of this function.  Also, I don't call
 *	emuLock(), emuUnlock() since only termGetUpdate() calls these functions
 *	and at that point the emulator is already locked down.
 *
 * ARGUMENTS:
 *	hEmu	- external emulator handle
 *
 * RETURNS:
 *	pointer to text buf array
 *
 */
ECHAR **emuGetTxtBuf(const HEMU hEmu)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hEmu == 0)
		{
		assert(0);
		return 0;
		}

	return hhEmu->emu_apText;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuGetAttrBuf
 *
 * DESCRIPTION:
 *	Obviously we don't need the handle here but when we do go reentrant,
 *	we only change the guts of this function.  Also, I don't call
 *	emuLock(), emuUnlock() since only termGetUpdate() calls these functions
 *	and at that point the emulator is already locked down.
 *
 * ARGUMENTS:
 *	hEmu	- external emulator handle
 *
 * RETURNS:
 *	pointer to attribute buf array
 *
 */
PSTATTR *emuGetAttrBuf(const HEMU hEmu)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hEmu == 0)
		{
		assert(0);
		return 0;
		}

	return hhEmu->emu_apAttr;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuKbdIn
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *	0=termkey, -1=not termkey, -2=error
 *
 */
int emuKbdIn(const HEMU hEmu, KEY_T key, const int fTest)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;
	int iRet;

	if (hEmu == 0)
		{
		assert(0);
		return -2;
		}

	emuLock(hEmu);
	iRet = (*hhEmu->emu_kbdin)(hhEmu, (int)key, fTest);
	emuUnlock(hEmu);
	return iRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuIsEmuKey
 *
 * DESCRIPTION:
 *	Checks to see if the the given key maps to any defined terminal keys.
 *
 * ARGUMENTS:
 *	HEMU hEmu	- External emulator handle.
 *	int key 	- Key to test.
 *
 * RETURNS:
 *	TRUE=termkey, FALSE=not termkey
 *
 */
int emuIsEmuKey(const HEMU hEmu, KEY_T key)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;
	int iRet;

	if (hEmu == 0)
		{
		assert(0);
		return FALSE;
		}

	if (cnctQueryStatus(sessQueryCnctHdl(hhEmu->hSession)) !=
			CNCT_STATUS_TRUE || IsSessionSuspended(hhEmu->hSession) ||
				hhEmu->stUserSettings.nTermKeys == EMU_KEYS_ACCEL)
		{
		return FALSE;
		}

	emuLock(hEmu);
	iRet = (*hhEmu->emu_kbdin)(hhEmu, (int)key, TRUE);
	emuUnlock(hEmu);
	return (iRet == -1) ? FALSE : TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * emuComDone
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *	0=OK, else error
 *
 */
int emuComDone(const HEMU hEmu)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hEmu == 0)
		{
		assert(0);
		return -1;
		}

	NotifyClient(hhEmu->hSession, EVENT_TERM_UPDATE, 0L);
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuQueryCurPos
 *
 * DESCRIPTION: Returns the row and column position of the current
 *				cursor position.
 *
 * ARGUMENTS:	hEmu	- The External emulator handle.
 *				*row	- A pointer to an integer.
 *				*col	- A pointer to an integer.
 *
 * RETURNS:
 *	0=OK, else error
 *
 */
int emuQueryCurPos(const HEMU hEmu, int *row, int *col)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hEmu == 0)
		{
		assert(0);
		return -1;
		}

	emuLock(hEmu);
	*row = hhEmu->emu_currow;
	*col = hhEmu->emu_curcol;
	emuUnlock(hEmu);

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuQueryCursorType
 *
 * DESCRIPTION:
 *	Returns the current cursor type.
 *
 * ARGUMENTS:
 *	hEmu	- public emulator handle.
 *
 * RETURNS:
 *	The cursor type.
 *
 */
int emuQueryCursorType(const HEMU hEmu)
	{
	int iCurType;
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hEmu == 0)
		{
		assert(0);
		return -1;
		}

	emuLock(hEmu);
	iCurType = hhEmu->iCurType;
	emuUnlock(hEmu);

	return iCurType;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuTrackingNotify
 *
 * DESCRIPTION:
 *	Cloop calls this function when it detects a pause in the data flow.
 *	This allows the client side to track to the cursor position if that
 *	option is enabled.
 *
 * ARGUMENTS:
 *	HEMU hEmu	- External emulator handle.
 *
 * RETURNS:
 *	0
 *
 */
int emuTrackingNotify(const HEMU hEmu)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hhEmu == 0)
		{
		assert(FALSE);
		return 0;
		}

	NotifyClient(hhEmu->hSession, EVENT_TERM_TRACK, 0);

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuQueryClearAttr
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *	0=OK, else error
 *
 */
int emuQueryClearAttr(const HEMU hEmu, PSTATTR pstClearAttr)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hEmu == 0)
		{
		assert(0);
		return -1;
		}

	emuLock(hEmu);
	*pstClearAttr = hhEmu->emu_clearattr_sav;
	emuUnlock(hEmu);

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuQueryRowsCols
 *
 * DESCRIPTION:
 *	Returns the current number of rows and columns set in the emulator.
 *
 * ARGUMENTS:
 *	hEmu	- public emulator handle
 *	piRows	- pointer to row variable
 *	piCols	- pointer to col variable
 *
 * RETURNS:
 *	0=OK, else error
 *
 */
int emuQueryRowsCols(const HEMU hEmu, int *piRows, int *piCols)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hEmu == 0)
		{
		assert(0);
		return -1;
		}

	emuLock(hEmu);
	*piRows = hhEmu->emu_maxrow + 1;
	*piCols = hhEmu->emu_maxcol + 1;

	emuUnlock(hEmu);
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuQueryPrintEchoHdl
 *
 * DESCRIPTION: This routine returns the Print handle used for
 *				Printer Echo for the given emulator handle.
 *
 * ARGUMENTS:	hEmu	- The external emulator handle.
 *
 * RETURNS: 	HPRINT	- The External print handle for Printer Echo.
 *
 */
HPRINT emuQueryPrintEchoHdl(const HEMU hEmu)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;
	HPRINT hPrint;

	if (hEmu == 0)
		{
		assert(FALSE);
		return 0;
		}

	emuLock(hEmu);
	hPrint = hhEmu->hPrintEcho;
	emuUnlock(hEmu);

	return hPrint;
	}

#if 0
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuQueryEmuName
 *
 * DESCRIPTION:
 *	Returns the name of the emulator.
 *
 * ARGUMENTS:
 *	hEmu		- The External Emulator Handle.
 *	*acBuffer	- The address of a buffer to receive the information.
 *	nSize		- The size of the buffer.
 *
 * RETURNS:
 *	0=OK else error
 *
 */
int emuQueryName(const HEMU hEmu, TCHAR *achBuffer, int nSize)
	{
	const	HHEMU hhEmu = (HHEMU)hEmu;
	BYTE	*pv;
	BYTE	*temp;
	int 	nLen,
			indx,
			nEmuCount,
			nEmuId;

	if (hhEmu == 0)
		{
		*achBuffer = 0;
		assert(FALSE);
		return -1 ;
		}

	emuLock(hEmu);
	nEmuId = hhEmu->stUserSettings.nEmuId;
	emuUnlock(hEmu);

	if (resLoadDataBlock(glblQueryDllHinst(),
							IDT_EMU_NAMES,
							(LPVOID *)&pv, &nLen))
		{
		assert(FALSE);
		return -2;
		}

	nEmuCount = *(RCDATA_TYPE *)pv;
	pv += sizeof(RCDATA_TYPE);

	for (indx = 0 ; indx < nEmuCount ; indx++)
		{
		nLen = StrCharGetByteCount((LPTSTR)pv) + (int)sizeof(BYTE);

		if (nLen == 0)
			{
			assert(FALSE);
			return -3;
			}

		temp = pv + nLen;

		if (*(RCDATA_TYPE *)temp == nEmuId)
			{
			if (StrCharGetByteCount(pv) < nSize)
				{
				StrCharCopy(achBuffer, pv);
				break;
				}
			else
				{
				*achBuffer = 0;
				return -4;
				}
			}

		pv += (nLen + (int)sizeof(RCDATA_TYPE));
		}

	return 0;
	}
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuQueryEmuName
 *
 * DESCRIPTION:
 *	Returns the name of the emulator.
 *
 * ARGUMENTS:
 *	hEmu		- The External Emulator Handle.
 *	*acBuffer	- The address of a buffer to receive the information.
 *	nSize		- The size of the buffer.
 *
 * RETURNS:
 *	0=OK else error
 *
 */
int emuQueryName(const HEMU hEmu, TCHAR *achBuffer, int nSize)
	{
	const	HHEMU hhEmu = (HHEMU)hEmu;
	TCHAR	achText[256];
	int 	nEmuId,
			nResourceId,
			nLen;

	emuLock(hEmu);
	nEmuId = hhEmu->stUserSettings.nEmuId;
	emuUnlock(hEmu);

	switch(nEmuId)
		{
		case EMU_AUTO:
			nResourceId = IDS_EMUNAME_AUTO;
			break;

		case EMU_ANSI:
			nResourceId = IDS_EMUNAME_ANSI;
			break;

		case EMU_ANSIW:
			nResourceId = IDS_EMUNAME_ANSIW;
			break;

		case EMU_MINI:
			nResourceId = IDS_EMUNAME_MINI;
			break;

		case EMU_VIEW:
			nResourceId = IDS_EMUNAME_VIEW;
			break;

		case EMU_TTY:
			nResourceId = IDS_EMUNAME_TTY;
			break;

		case EMU_VT100:
			nResourceId = IDS_EMUNAME_VT100;
			break;

		case EMU_VT52:
			nResourceId = IDS_EMUNAME_VT52;
			break;

		case EMU_VT100J:
			nResourceId = IDS_EMUNAME_VT100J;
			break;

#if defined(INCL_VT220)
		case EMU_VT220:
			nResourceId = IDS_EMUNAME_VT220;
			break;
#endif

#if defined(INCL_VT320)
		case EMU_VT320:
			nResourceId = IDS_EMUNAME_VT320;
			break;
#endif

#if defined(INCL_VT100PLUS)
		case EMU_VT100PLUS:
			nResourceId = IDS_EMUNAME_VT100PLUS;
			break;
#endif

#if defined(INCL_VTUTF8)
		case EMU_VTUTF8:
			nResourceId = IDS_EMUNAME_VTUTF8;
			break;
#endif

		default:
			assert(FALSE);
			return(-1);
		}

	nLen = LoadString(glblQueryDllHinst(), (unsigned)nResourceId, achText,
		sizeof(achText) / sizeof(TCHAR));

	// Has the caller supplied a large enough buffer.
	//
	if (nSize <= nLen)
		return(-1);

	StrCharCopy(achBuffer, achText);

	return(0);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuGetIdFromName
 *
 * DESCRIPTION:
 *	Returns the Id for the supplied emulator name.
 *
 * ARGUMENTS:
 *	hEmu		- The External Emulator Handle.
 *	*acBuffer	- The address of a buffer to receive the information.
 *	nSize		- The size of the buffer.
 *
 * RETURNS:
 *	An emulator ID otherwise (-1) if the function fails.
 *
 */
int emuGetIdFromName(const HEMU hEmu, TCHAR *achEmuName)
	{
	const	HHEMU hhEmu = (HHEMU)hEmu;
	int 	iRet, idx;

	for(idx = 0; idx < NBR_EMULATORS; idx++)
		{
		iRet = StrCharCmp(achEmuName, hhEmu->pstNameTable[idx].acName);

		if (iRet == 0)
			{
			return(hhEmu->pstNameTable[idx].nEmuId);
			}

		}

	return(-1);

	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuQueryEmulatorId
 *
 * DESCRIPTION:
 *	Returns the oridinal value for the current emulator.  This can be
 *	used through-out the program to write conditional code for emulators.
 *
 * ARGUMENTS:
 *	HEMU	hEmulator - external emulator handle.
 *
 * RETURNS:
 *	ordinal value (>0).
 *
 */
int emuQueryEmulatorId(const HEMU hEmulator)
	{
	const HHEMU hhEmu = (HHEMU)hEmulator;
	int			nEmuId;

	if (hhEmu == 0)
		{
		assert(0);
		return -1;
		}

	emuLock(hEmulator);
	nEmuId = hhEmu->stUserSettings.nEmuId;
	emuUnlock(hEmulator);

	return (nEmuId);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuLoad
 *
 * DESCRIPTION:
 *	 Loads all pertinent tables into memory for the specified emulator.
 *
 * ARGUMENTS:	hEmu	External Emulator Handle.
 *				nEmuId	ID that identifies a specific emulator.
 *				fForceLoad -
 *
 *
 * RETURNS: 	0 if successful.  -1 if nEmuId is invalid.
 *
 */
int emuLoad(const HEMU hEmu, const int nEmuId)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;
	int col;
	void (*emuInitFunction)(const HHEMU hhEmu);

	if (hEmu == 0)
		{
		assert(0);
		return -2;
		}

	emuLock(hEmu);

	// If the requested emulator is already loaded, return.
	//
	if (hhEmu->nEmuLoaded == nEmuId)
		{
		emuUnlock(hEmu);
		return 0;
		}

	// Validate nEmuId and set set initialization function.

	switch(nEmuId)
		{
		#if defined(INCL_MINITEL)
		case EMU_MINI:
            if (hhEmu->nEmuLoaded == EMU_AUTO && hhEmu->hSession)
                {
                HCOM   hCom = sessQueryComHdl(hhEmu->hSession);
                HCLOOP hCLoop = sessQueryCLoopHdl(hhEmu->hSession);
                HCNCT  hCnct = sessQueryCnctHdl(hhEmu->hSession);

                if (hCom && ComValidHandle(hCom))
                    {
                    int iDataBits = 8;
                    int iParity = NOPARITY;
                    int iStopBits = ONESTOPBIT;
                    ComGetDataBits(hCom, &iDataBits);
                    ComGetParity(hCom, &iParity);
                    ComGetStopBits(hCom, &iStopBits);

                    //
                    // Force the incoming ASCII data to 7 bit.
                    //
                    CLoopSetASCII7(hCLoop, TRUE);

                    if (iDataBits != 7 || iParity != EVENPARITY || iStopBits != ONESTOPBIT)
                        {
                        const HCNCT  hCnct  = sessQueryCnctHdl(hhEmu->hSession);
                        const HHCNCT hhCnct = (HHCNCT)hCnct;;

                        ComSetDataBits(hCom, 7);
                        ComSetParity(hCom, EVENPARITY);
                        ComSetStopBits(hCom, ONESTOPBIT);
                        ComSetAutoDetect(hCom, FALSE);
                        if (hCnct)
                            {
                            HHDRIVER hhDriver = (HHDRIVER)hhCnct->hDriver;

                            if (hhDriver && cncttapiSetLineConfig(hhDriver->dwLine, hCom) == -16)
                                {
                                cnctDisconnect(hCnct, CNCT_DIALNOW | CNCT_XFERABORTCONFIRM);
                                }
                            }
                        }

                    }
                }

			emuInitFunction = emuMinitelInit;
			break;
		#endif

		case EMU_AUTO:
			emuInitFunction = emuAutoInit;
			break;

		case EMU_ANSIW:
		case EMU_ANSI:
			emuInitFunction = emuAnsiInit;
			break;

		case EMU_TTY:
			emuInitFunction = emuAnsiInit;
			break;

		case EMU_VT100J:
		case EMU_VT100:
			emuInitFunction = vt100_init;
			break;

		case EMU_VT52:
			emuInitFunction = vt52_init;
			break;

		#if defined(INCL_VT220)
		case EMU_VT220:
			emuInitFunction = vt220_init;
			break;
		#endif

		#if defined(INCL_VT320)
		case EMU_VT320:
			emuInitFunction = vt220_init;	// The VT320 is the same as the VT220.
			break;
		#endif

		#if defined(INCL_VT100PLUS)
		case EMU_VT100PLUS:
			emuInitFunction = vt100_init;	// The VT100+ is the same as the VT100.
			break;
		#endif

		#if defined(INCL_VTUTF8)
		case EMU_VTUTF8:
			emuInitFunction = vtutf8_init;
			break;
		#endif

		#if defined(INCL_VIEWDATA)
		case EMU_VIEW:
			emuInitFunction = EmuViewdataInit;
			break;
		#endif

		default:
			emuUnlock(hEmu);
			return(-1);
		}

	// Remove the current emulator, if one is loaded.
	//
	if (hhEmu->emu_deinstall)
		(*hhEmu->emu_deinstall)(hhEmu);

	// Save the new emulator Id.
	//
	hhEmu->stUserSettings.nEmuId = nEmuId;
	hhEmu->nEmuLoaded = nEmuId;

	// setup function pointers to standard routines.

	hhEmu->EmuSetCursorType = EmuStdSetCursorType;
	hhEmu->emuResetTerminal = stdResetTerminal;
	hhEmu->emu_graphic 		= emuStdGraphic;
#if defined(EXTENDED_FEATURES)	
	hhEmu->emu_datain 		= emuStdDataIn;
#else
	hhEmu->emu_datain 		= emuDataIn;
#endif
	hhEmu->emu_kbdin 		= std_kbdin;
	hhEmu->emu_getscrsize 	= std_getscrsize;
#ifdef INCL_TERMINAL_SIZE_AND_COLORS
    hhEmu->emu_setscrsize	= std_setscrsize;
#endif
	hhEmu->emu_getscrollcnt = std_getscrollcnt;
	hhEmu->emu_getcurpos 	= std_getcurpos;
	hhEmu->emu_setcurpos 	= std_setcurpos;
	hhEmu->emu_getattr 		= std_getattr;
	hhEmu->emu_setattr 		= std_setattr;
	hhEmu->emu_setcolors 	= std_setcolors;
	hhEmu->emu_getcolors 	= std_getcolors;
	hhEmu->emu_initcolors 	= std_initcolors;
	hhEmu->emu_clearscreen 	= std_clearscreen;
	hhEmu->emu_clearline 	= std_clearline;
	hhEmu->emu_clearrgn 	= std_clearrgn;
	hhEmu->emu_scroll 		= std_scroll;
	hhEmu->emu_deinstall 	= std_deinstall;
	hhEmu->emu_ntfy 		= std_emu_ntfy;
	hhEmu->emuHomeHostCursor= std_HomeHostCursor;

	hhEmu->emu_maxrow 		= EMU_DEFAULT_MAXROW;
	hhEmu->emu_maxcol 		= EMU_DEFAULT_MAXCOL;
    hhEmu->bottom_margin    = hhEmu->emu_maxrow;    // mrw:2/21/96
    hhEmu->top_margin       = 0;                    // mrw:2/21/96

	hhEmu->emu_charattr 	= hhEmu->attrState[CS_STATE];

	hhEmu->emu_clearattr =
	hhEmu->emu_clearattr_sav = hhEmu->attrState[CSCLEAR_STATE];

	// Initialize mode variables.
	//
	hhEmu->mode_KAM = RESET;	   /* Enable Keyboard */
	hhEmu->mode_IRM = RESET;	   /* Replace chars rather than insert */
	hhEmu->mode_VEM = RESET;	   /* Inserting lines scrolls down, not up */
	hhEmu->mode_HEM = RESET;	   /* Inserting chars scrolls right, not left */
	hhEmu->mode_SRM = SET;		   /* Send-Receive. No local character echo */
	hhEmu->mode_LNM = RESET;	   /* LF moves vertically only */
	hhEmu->mode_DECOM = RESET;	   /* Absolute cursor positioning */
	hhEmu->mode_DECPFF = RESET;    /* No form feed after screen prINT */
	hhEmu->mode_DECPEX = RESET;    /* PrINT only scroll rgn. on screen prINT */
	hhEmu->mode_DECSCNM = RESET;   /* Screen mode. RESET=normal vid, SET=reverse vid */
	hhEmu->mode_DECTCEM = SET;	   /* Cursor enable. RESET=hidden, SET=visible */
	hhEmu->mode_25enab = RESET;    /* When true (SET), emulator can use 25th line */
	hhEmu->mode_protect = RESET;   /* When true (SET), protected mode is on */
	hhEmu->mode_block = RESET;	   /* When true (SET), block mode is on */
	hhEmu->mode_local = RESET;	   /* When true (SET), block mode is on */
	hhEmu->print_echo = FALSE;

	// Initialize state table.
	//
	hhEmu->emu_highchar = 0x7F;

	// Set default tab stops to 8.
	//
	//for (col = 0; col <= EMU_DEFAULT_MAXCOL; ++col)
	// Need to define tab stops for the whole screen so received tabs
	// with cursor at column 72 or more will go to the next tab rather
	// than the right edge of the screen. 22 Apr 99 rde
	for (col = 0; col < MAX_EMUCOLS; ++col)
		{
		if (!(col % 8))
			hhEmu->tab_stop[col] = TRUE;
		}

	// Call initialization function for emulator.
	//
	(*emuInitFunction)(hhEmu);

	// Paints every cell with the new attributes...
	//
	std_initcolors(hhEmu);

#ifdef INCL_TERMINAL_SIZE_AND_COLORS
    // Update the screen size.
    //
    hhEmu->emu_setscrsize(hhEmu);
#endif

	// We want the terminal to read the emulator image after loading
	// but we don't want a scroll operation so update each line
	// individually - mrw

	updateLine(sessQueryUpdateHdl(hhEmu->hSession), 0, hhEmu->emu_maxrow);

	NotifyClient(hhEmu->hSession, EVENT_EMU_CLRATTR, 0);
	NotifyClient(hhEmu->hSession, EVENT_EMU_SETTINGS, 0);
	NotifyClient(hhEmu->hSession, EVENT_TERM_UPDATE, 0);

	emuUnlock(hEmu);

	PostMessage(sessQueryHwndStatusbar(hhEmu->hSession),
		SBR_NTFY_REFRESH, (WPARAM)SBR_EMU_PART_NO, 0);

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuQuerySettings
 *
 * DESCRIPTION:
 *	This function returns a copy of the of the User Settings structure
 *	found in the internal emulator handle.
 *
 * ARGUMENTS:
 *	HEMU		-	The External emulator handle.
 *	PSTEMUSET	-	A pointer to a structure of type STEMUSET
 *
 * RETURNS:
 *	0=OK, else error
 *
 */
int emuQuerySettings(const HEMU hEmu, PSTEMUSET pstSettings)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hEmu == 0)
		{
		assert(0);
		return -1;
		}

	emuLock(hEmu);
	MemCopy(pstSettings, &hhEmu->stUserSettings, sizeof(STEMUSET));
	emuUnlock(hEmu);

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuSetSettings
 *
 * DESCRIPTION:
 *	This function stores the Emulator Settings in the internal Emualtor
 *	handle.  This function DOES NOT save the information in the session
 *	file.  The values to be set are validated.  If any values passed
 *	into this routine are invalid, default values will be set.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *	0 if the values passed in are validated.  A number less than 0 will
 *	be returned if any one of the values are invalid.  Note that in the 
 *	case of several invalid settings, the return value will point only
 *	to the last one that was invalid.
 *
 */
int emuSetSettings(const HEMU hEmu, const PSTEMUSET pstSettings)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;
	int iReturn;

	if (hEmu == 0)
		{
		assert(0);
		return -1;
		}

	iReturn = 0;

	switch(pstSettings->nEmuId)
		{
		case EMU_AUTO:
		case EMU_ANSI:
		case EMU_ANSIW:
		case EMU_MINI:
		case EMU_VIEW:
		case EMU_TTY:
		case EMU_VT100:
		case EMU_VT100J:
		case EMU_VT52:
		case EMU_VT220:
		case EMU_VT320:
		case EMU_VT100PLUS:
		case EMU_VTUTF8:
			break;
		default:
			pstSettings->nEmuId = EMU_AUTO;
			iReturn = -1;
			assert(FALSE);
			break;
		}

	switch(pstSettings->nTermKeys)
		{
		case EMU_KEYS_ACCEL:
		case EMU_KEYS_TERM:
		case EMU_KEYS_SCAN:
			break;
		default:
			pstSettings->nTermKeys = EMU_KEYS_TERM;
			iReturn = -2;
			assert(FALSE);
			break;
		}

	switch(pstSettings->nCursorType)
		{
		case EMU_CURSOR_BLOCK:
		case EMU_CURSOR_LINE:
		case EMU_CURSOR_NONE:
			break;
		default:
			pstSettings->nCursorType = EMU_CURSOR_LINE;
			iReturn = -3;
			assert(FALSE);
			break;
		}

	switch(pstSettings->nCharacterSet)
		{
		case EMU_CHARSET_ASCII:
		case EMU_CHARSET_UK:
		case EMU_CHARSET_SPECIAL:
#if defined(INCL_VT220)
		case EMU_CHARSET_MULTINATIONAL:	
		case EMU_CHARSET_FRENCH:			
		case EMU_CHARSET_FRENCHCANADIAN:	
		case EMU_CHARSET_GERMAN:			
#endif
			break;
		default:
			pstSettings->nCharacterSet = EMU_CHARSET_ASCII;
			iReturn = -4;
			assert(FALSE);
			break;
		}

	// The values to be set have been validated.  Set the emulator handle
	// values, and the internal emualtor variables that correspond.
	//
	emuLock(hEmu);

#ifdef INCL_TERMINAL_SIZE_AND_COLORS
	if (pstSettings->nTextColor != hhEmu->stUserSettings.nTextColor ||
			pstSettings->nBackgroundColor != hhEmu->stUserSettings.nBackgroundColor)
		{
		// The user defined colors have changed--implement them.
		std_setcolors(hhEmu, 
				pstSettings->nTextColor,
				pstSettings->nBackgroundColor);
		}
#endif

	// When called from emuInitializeHdl, the source and dest pointers
	// for the following call are the same, so there's no need to
	// to do the copy.
	//
	if(&hhEmu->stUserSettings != pstSettings)
		MemCopy(&hhEmu->stUserSettings, pstSettings, sizeof(STEMUSET));

	hhEmu->iCurType = hhEmu->stUserSettings.nCursorType;
	hhEmu->mode_AWM = hhEmu->stUserSettings.fWrapLines;
	hhEmu->mode_DECKPAM = hhEmu->stUserSettings.fKeypadAppMode;
	hhEmu->mode_DECCKM = hhEmu->stUserSettings.fCursorKeypadMode;

	hhEmu->fUse8BitCodes = hhEmu->stUserSettings.fUse8BitCodes;
	hhEmu->fAllowUserKeys = hhEmu->stUserSettings.fAllowUserKeys;

	// Call emuSetDecColumns only if the emulator is a VT100, and
	// there has been change in the user setting of 132 column mode.
	//
	emuSetDecColumns(hhEmu,
						hhEmu->stUserSettings.f132Columns ?
						VT_MAXCOL_132MODE :
						VT_MAXCOL_80MODE,
						FALSE);

#ifdef INCL_TERMINAL_SIZE_AND_COLORS
    // Set the possible new row and column values if
    // the emulator is not about to change.
    //
    hhEmu->emu_setscrsize(hhEmu);
#endif

	emuUnlock(hEmu);

	NotifyClient(hhEmu->hSession, EVENT_EMU_SETTINGS, 0);
    //JMH 01-09-97 These two events also need to be sent, says JCM.
    //
    NotifyClient(hhEmu->hSession, EVENT_TERM_UPDATE, 0);
    NotifyClient(hhEmu->hSession, EVENT_EMU_CLRATTR, 0);

	return(iReturn);
	}

#if defined(EXTENDED_FEATURES)	//TODO:rde 23 mar 98
	// When we're comfortable enough with changing to using a function
	// pointer here, do it for all builds.
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  emuDataIn
 *
 * DESCRIPTION:
 *  External entry point for incoming data.
 *
 * ARGUMENTS:
 *  hEmu    - public emulator handle
 *  ccode   - character code
 *
 * RETURNS:
 *  TRUE if displayable
 *
 */
int emuDataIn(const HEMU hEmu, const ECHAR ccode)
    {
	int iRetVal = TRUE;
    const HHEMU hhEmu = (HHEMU)hEmu;

	if (hhEmu == 0)
		{
		assert(FALSE);
		}
	else
		{
    	emuLock(hEmu);

	    CaptureChar(sessQueryCaptureFileHdl(hhEmu->hSession),
					    CPF_MODE_RAW,
					    ccode); //moved from emuStdDataIn 05AUG98 mpt
        emuUnlock(hEmu);

        iRetVal = (*hhEmu->emu_datain)(hhEmu, ccode);
		}

	return iRetVal;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuStdDataIn
 *
 * DESCRIPTION:
 *	 Processes passed in codes through the emulation state tables.
 *
 * ARGUMENTS:
 *	hhEmu	- The internal emulator handle.
 *	ccode	- The character to process.
 *
 * RETURNS:
 *	 TRUE if displayable character
 */
int emuStdDataIn(const HHEMU hhEmu, const ECHAR ccode)
	{
	//ECHAR echCode;
	int ntrans;
	struct trans_entry *tptr;

	emuLock((HEMU)hhEmu);

	hhEmu->emu_code = ETEXT(ccode);

	// Capture raw data.
	//
#if 0 //moved to emuDataIn to prevent characters being captures
      //multiple times due to the re-entrant nature of this function. - mpt 5aug98
    CaptureChar(sessQueryCaptureFileHdl(hhEmu->hSession),
					CPF_MODE_RAW,
					ccode);
#endif
	// Seek next state by finding character range.
	//
	tptr = hhEmu->state_tbl[hhEmu->state].first_trans;
	ntrans = hhEmu->state_tbl[hhEmu->state].number_trans;

	for (; ntrans > 0; ntrans--, ++tptr)
		if (ccode >= tptr->lochar && ccode <= tptr->hichar)
			break;

	if (ntrans <= 0)
		{
		// Added to handle the case of 2 successive ESC chars--just
		// the 1st ESC should be thrown away

		hhEmu->state = 0;
		tptr = hhEmu->state_tbl[hhEmu->state].first_trans;
		ntrans = hhEmu->state_tbl[hhEmu->state].number_trans;

		for (; ntrans > 0; ntrans--, ++tptr)
			{
			if (ccode >= tptr->lochar && ccode <= tptr->hichar)
				break;
			}

		// 6-14-83
		// second condition (below) added to allow emulator to toss invalid
		// escpae sequences (i.e.ESC [ 0v).

		if (ntrans <= 0 || tptr->next_state == 0)
			{
			commanderror(hhEmu);
			goto DataInExit;
			}

		else
			{
			CaptureChar(sessQueryCaptureFileHdl(hhEmu->hSession),
						CF_CAP_CHARS, ccode);
			printEchoChar(hhEmu->hPrintEcho, ccode);
			}
		}

	hhEmu->state = tptr->next_state;
	(*tptr->funct_ptr)(hhEmu);

	// The code has been process through the emulator.	Check for
	// capturing and printing, and reset other emulator values.
	//
	if (hhEmu->state == 0)
		{
		if (IN_RANGE(ccode, ETEXT(' '), hhEmu->emu_highchar) ||
						ccode == ETEXT('\r') ||
						ccode == ETEXT('\n'))
			{
			CaptureChar(sessQueryCaptureFileHdl(hhEmu->hSession),
						CF_CAP_CHARS, ccode);
			printEchoChar(hhEmu->hPrintEcho, ccode);
			}
		hhEmu->num_param_cnt = hhEmu->selector_cnt =
		hhEmu->selector[0] = hhEmu->num_param[0] = 0;

		hhEmu->DEC_private = FALSE;
		}

	DataInExit:

	emuUnlock((HEMU)hhEmu);

	return(TRUE);
	}
//#if FALSE
#else
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDataIn
 *
 * DESCRIPTION:
 *	 Processes passed in codes through the emulation state tables.
 *
 * ARGUMENTS:
 *	hhEmu	- The internal emulator handle.
 *	ccode	- The character to process.
 *
 * RETURNS:
 *	 TRUE if displayable character
 */
int emuDataIn(const HEMU hEmu, const ECHAR ccode)
	{
	//ECHAR echCode;
	int ntrans;
	struct trans_entry *tptr;
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hhEmu == 0)
		{
		assert(FALSE);
		goto DataInExit;
		}

	emuLock(hEmu);

	hhEmu->emu_code = ETEXT(ccode);

	// Capture raw data.
	//
	CaptureChar(sessQueryCaptureFileHdl(hhEmu->hSession),
					CPF_MODE_RAW,
					ccode);

	// Seek next state by finding character range.
	//
	tptr = hhEmu->state_tbl[hhEmu->state].first_trans;
	ntrans = hhEmu->state_tbl[hhEmu->state].number_trans;

	for (; ntrans > 0; ntrans--, ++tptr)
		if (ccode >= tptr->lochar && ccode <= tptr->hichar)
			break;

	if (ntrans <= 0)
		{
		// Added to handle the case of 2 successive ESC chars--just
		// the 1st ESC should be thrown away

		hhEmu->state = 0;
		tptr = hhEmu->state_tbl[hhEmu->state].first_trans;
		ntrans = hhEmu->state_tbl[hhEmu->state].number_trans;

		for (; ntrans > 0; ntrans--, ++tptr)
			{
			if (ccode >= tptr->lochar && ccode <= tptr->hichar)
				break;
			}

		// 6-14-83
		// second condition (below) added to allow emulator to toss invalid
		// escpae sequences (i.e.ESC [ 0v).

		if (ntrans <= 0 || tptr->next_state == 0)
			{
			commanderror(hhEmu);
			goto DataInExit;
			}

		else
			{
			CaptureChar(sessQueryCaptureFileHdl(hhEmu->hSession),
						CF_CAP_CHARS, ccode);
			printEchoChar(hhEmu->hPrintEcho, ccode);
			}
		}

	hhEmu->state = tptr->next_state;
	(*tptr->funct_ptr)(hhEmu);

	// The code has been process through the emulator.	Check for
	// capturing and printing, and reset other emulator values.
	//
	if (hhEmu->state == 0)
		{
		if (IN_RANGE(ccode, ETEXT(' '), hhEmu->emu_highchar) ||
						ccode == ETEXT('\r') ||
						ccode == ETEXT('\n'))
			{
			CaptureChar(sessQueryCaptureFileHdl(hhEmu->hSession),
						CF_CAP_CHARS, ccode);
			printEchoChar(hhEmu->hPrintEcho, ccode);
			}
		hhEmu->num_param_cnt = hhEmu->selector_cnt =
		hhEmu->selector[0] = hhEmu->num_param[0] = 0;

		hhEmu->DEC_private = FALSE;
		}

	DataInExit:

	emuUnlock(hEmu);

	return(TRUE);
	}
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuNotify
 *
 * DESCRIPTION:
 *	A function that can be called to notify the emulators of an event.
 *	As events are identified, they can be added to this function.
 *
 * ARGUMENTS:
 *	hEmu	-	The external emulator handle.
 *	nEvent	-	The event ID.
 *
 * RETURNS:
 *	0=OK, else error
 *
 */
int emuNotify(const HEMU hEmu, const int nEvent)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hhEmu == 0)
		{
		assert(FALSE);
		return -1;
		}

	switch(nEvent)
		{
		case EMU_EVENT_CONNECTED:
			emuLock(hEmu);
			hhEmu->fWasConnected = TRUE;
			emuUnlock(hEmu);
			break;

		case EMU_EVENT_DISCONNECTED:
			emuLock(hEmu);

			if (hhEmu->stUserSettings.nEmuId == EMU_AUTO)
				{
				if (hhEmu->fWasConnected)
					hhEmu->stUserSettings.nAutoAttempts++;

				if (hhEmu->stUserSettings.nAutoAttempts ==
						EMU_MAX_AUTODETECT_ATTEMPTS)
#if !defined(FAR_EAST)
					emuAutoDetectLoad(hhEmu, EMU_ANSI);
#else
					emuAutoDetectLoad(hhEmu, EMU_ANSIW);
#endif
				}

			hhEmu->fWasConnected = FALSE;
			emuUnlock(hEmu);
			break;

		default:
			break;
		}

	emuLock(hEmu);
	(*hhEmu->emu_ntfy)(hhEmu, nEvent);
	emuUnlock(hEmu);

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuHomeHostCursor
 *
 * DESCRIPTION:
 *	Homes the cursor.  Needed when we first load a session.  Incidently,
 *	homing the cursor for a minitel places the cursor at 1,0, not 0,0
 *	which is why this function exists.
 *
 * ARGUMENTS:
 *	hEmu	- public emulator handle.
 *
 * RETURNS:
 *	0=OK,else error
 *
 */
int emuHomeHostCursor(const HEMU hEmu)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hhEmu == 0)
		{
		assert(0);
		return -1;
		}

	return (*hhEmu->emuHomeHostCursor)(hhEmu);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuEraseTerminalScreen
 *
 * DESCRIPTION:
 *	Erases emulator image, doesn't put stuff in the backscroll.
 *
 * ARGUMENTS:
 *	hEmu	- public emulator handle.
 *
 * RETURNS:
 *	0=OK,else error
 *
 */
int emuEraseTerminalScreen(const HEMU hEmu)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;
	int i;

	if (hhEmu == 0)
		{
		assert(0);
		return -1;
		}

	for (i = 0 ; i <= hhEmu->emu_maxrow ; ++i)
		clear_imgrow(hhEmu, i);

	updateLine(sessQueryUpdateHdl(hhEmu->hSession), 0, hhEmu->emu_maxrow);

	// The notify function is used to in minitel to set the state
	// of the screen based on connection status (F or C in upper corner).
	//
	hhEmu->emu_ntfy(hhEmu, 0);
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuQueryDefaultTelnetId
 *
 * DESCRIPTION:
 *	Gets the default telnet terminal id string for the given emulator.
 *
 * ARGUMENTS:
 *	nEmuId	    - id of the emulator (e.g. EMU_ANSI).
 *  achTelnetId - pointer to the buffer for the string.
 *  nSize       - size of the buffer (in characters).
 *
 * RETURNS:
 *	0=OK, else error
 *
 * AUTHOR:  C. Baumgartner, 11/15/96
 */
int emuQueryDefaultTelnetId(const int nEmuId, TCHAR *achTelnetId, int nSize)
    {
    int     iRet = 0;
    TCHAR * pszDefaultId;

    // Note : Since these strings are a part of the telnet
    // protocol, it is okay if they are hard-coded.
    //
    switch(nEmuId)
        {
    case EMU_AUTO:
    case EMU_ANSI:
        pszDefaultId = TEXT("ANSI");
        break;

    case EMU_TTY:
        pszDefaultId = TEXT("TELETYPE-33");
        break;

    case EMU_VT52:
        pszDefaultId = TEXT("VT52");
        break;

#if defined(INCL_VT220)
    case EMU_VT220:
        pszDefaultId = TEXT("VT220");
        break;
#endif

#if defined(INCL_VT320)
    case EMU_VT320:
        pszDefaultId = TEXT("VT320");
        break;
#endif

#if defined(INCL_VT100PLUS)
    case EMU_VT100PLUS:
        pszDefaultId = TEXT("VT100+");
        break;
#endif

#if defined(INCL_VTUTF8)
    case EMU_VTUTF8:
        pszDefaultId = TEXT("VT-UTF8");
        break;
#endif

    case EMU_VT100:
    default:
        pszDefaultId = TEXT("VT100");
        break;
        }

    if ( StrCharGetStrLength(pszDefaultId) < nSize )
        {
        StrCharCopyN(achTelnetId, pszDefaultId, nSize);
        iRet = 0;
        }
    else
        {
        iRet = -1;
        }

    return iRet;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuLoadDefaultTelnetId
 *
 * DESCRIPTION:
 *	Loads the given emulator handle with the default telnet terminal id
 *  string for the current emulator type.
 *
 * ARGUMENTS:
 *	hEmu - A public emulator handle
 *
 * RETURNS:
 *	0=OK, else error
 *
 * AUTHOR:  C. Baumgartner, 11/18/96
 */
int emuLoadDefaultTelnetId(const HEMU hEmu)
    {
    HHEMU hhEmu = (HHEMU)hEmu;

    return emuQueryDefaultTelnetId(hhEmu->stUserSettings.nEmuId,
        hhEmu->stUserSettings.acTelnetId, EMU_MAX_TELNETID);
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuLoadSettings
 *
 * DESCRIPTION:
 *	Loads the given emulator user settings.
 *
 * ARGUMENTS:
 *	hhEmu - an internal emulator handle
 *	uiId - the SFID of the data to load
 *	ulDataSize - the size of the data to load (in bytes)
 *	pvData - address at which to put the data
 *
 * RETURNS:
 *	The size (in bytes) of the data loaded, -1 if an error occured
 *
 * AUTHOR:	Bob Everett - 6 Jun 1998 
 */
STATIC_FUNC int emuLoadSettings(const HHEMU hhEmu, 
								const unsigned int uiId,
								unsigned long ulDataSize,
								void *pvData)
    {
	int iResult = 0;
	int iRetVal = 0;
	unsigned long ulSize = 0;

	// Do the screen color settings exist?
	sfGetSessionItem(sessQuerySysFileHdl(hhEmu->hSession), uiId, &ulSize, 0);

	if (ulSize > 0)
		{
		// The settings exist. Go get them.
		iResult = sfGetSessionItem(sessQuerySysFileHdl(hhEmu->hSession),
				uiId, &ulDataSize, pvData);

		if (iResult != 0)
			iRetVal = -1;
		else
			iRetVal = (int)ulSize;
		}

	return iRetVal;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuCheckSettings
 *
 * DESCRIPTION:
 *	This ugly piece of code checks for a mismatch in settings between versions.
 *	The settings affected are fUse8BitCodes, fAllowUserKeys, nBackspaceKeys,
 *	and acTelnetId. The mismatch occurs when moving an HTPE3 session file to
 *	any newer version. This includes HT98 and HTPE4. 
 *
 * ARGUMENTS:
 *	hhEmu - an internal emulator handle
 *
 * RETURNS:
 *	Nada, zip, not a thing.
 *
 * AUTHOR:	Bob Everett - 8 Jun 1998 
 */
STATIC_FUNC void emuCheckSettings(struct stEmuBaseSFSettings *pstBaseSFSettings) 
    {
	TCHAR *psz = 0;
	TCHAR sz[EMU_MAX_TELNETID];

	if ((pstBaseSFSettings->nBackspaceKeys != EMU_BKSPKEYS_CTRLH) &&
			(pstBaseSFSettings->nBackspaceKeys != EMU_BKSPKEYS_DEL) &&
			(pstBaseSFSettings->nBackspaceKeys != EMU_BKSPKEYS_CTRLHSPACE))
		{
		// This is the best test for this scenario. Move the data.
		psz = (TCHAR *)&pstBaseSFSettings->fAllowUserKeys;
		if (StrCharGetStrLength(psz) < EMU_MAX_TELNETID)
			{
			StrCharCopy(sz, psz);
			StrCharCopy(pstBaseSFSettings->acTelnetId, sz);
			}

		pstBaseSFSettings->nBackspaceKeys = 
				pstBaseSFSettings->fUse8BitCodes;

		// Use the defaults.
		pstBaseSFSettings->fUse8BitCodes = FALSE;
		pstBaseSFSettings->fAllowUserKeys = FALSE;
		}
		
	// Check the data.
	if ((pstBaseSFSettings->fUse8BitCodes != TRUE) &&
			(pstBaseSFSettings->fUse8BitCodes != FALSE))
		pstBaseSFSettings->fUse8BitCodes = FALSE;

	if ((pstBaseSFSettings->fAllowUserKeys != TRUE) &&
			(pstBaseSFSettings->fAllowUserKeys != FALSE))
		pstBaseSFSettings->fAllowUserKeys = FALSE;

	if ((pstBaseSFSettings->nBackspaceKeys != EMU_BKSPKEYS_CTRLH) &&
			(pstBaseSFSettings->nBackspaceKeys != EMU_BKSPKEYS_DEL) &&
			(pstBaseSFSettings->nBackspaceKeys != EMU_BKSPKEYS_CTRLHSPACE))
		{
		pstBaseSFSettings->nBackspaceKeys = EMU_BKSPKEYS_CTRLH;

		// Assume that if nBackspaceKeys is messed up, so is acTelnetId.
	    pstBaseSFSettings->acTelnetId[0] = TEXT('\0');
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\emu_scr.c ===
/*	File: D:\WACKER\emu\emu_scr.c (Created: 08-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 3 $
 *	$Date: 3/27/01 12:38p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\tdll.h>
#include <tdll\cloop.h>
#include <tdll\assert.h>
#include <tdll\capture.h>
#include <tdll\session.h>
#include <tdll\backscrl.h>
#include <tdll\print.h>
#include <tdll\update.h>
#include <tdll\htchar.h>

#include "emu.h"
#include "emu.hh"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * backspace
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void backspace(const HHEMU hhEmu)
	{
	INT bWide = 1;
	INT	iRow = row_index(hhEmu, hhEmu->emu_currow);
	INT iCol;

	// Move the cursor back.
	//
	if (hhEmu->emu_curcol > 0)
		{
		bWide = hhEmu->emu_apAttr[iRow][hhEmu->emu_curcol - 1].wirt ? 2 : 1;
		bWide = hhEmu->emu_apAttr[iRow][hhEmu->emu_curcol].wirt ? 0 : bWide;

		(*hhEmu->emu_setcurpos)(hhEmu,
								hhEmu->emu_currow,
								hhEmu->emu_curcol - bWide);

		}

	// Now see if we need to get rid of the character.
	//
	if ((hhEmu->stUserSettings.nEmuId == EMU_TTY &&
		hhEmu->stUserSettings.fDestructiveBk) || (bWide == 0))
		{
		if (bWide == 0)
			iCol = hhEmu->emu_curcol - 1;
		else
			iCol = hhEmu->emu_curcol;	// account for wide chars this way

		hhEmu->emu_code = ETEXT(' ');
		
		(*hhEmu->emu_graphic)(hhEmu);

		(*hhEmu->emu_setcurpos)(hhEmu,
								hhEmu->emu_currow,
								iCol); //MPT:12-8-97 hhEmu->emu_curcol - 1);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void carriagereturn(const HHEMU hhEmu)
	{
	(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, 0);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *	iRow -- the row to clear
 *		Note: Since this function calls row_index() with iRow, DO NOT call this
 *		function with a row number that was returned by a call to row_index().
 *		You'll clear the wrong row.
 *
 * RETURNS:
 *
 */
void clear_imgrow(const HHEMU hhEmu, int iRow)
	{
	register int i;
	PSTATTR pstAttr;

	iRow = row_index(hhEmu, iRow);

	ECHAR_Fill(hhEmu->emu_apText[iRow], EMU_BLANK_CHAR, (size_t)MAX_EMUCOLS);

	for (i = 0, pstAttr = hhEmu->emu_apAttr[iRow] ; i <= MAX_EMUCOLS ; ++i)
		pstAttr[i] = hhEmu->emu_clearattr;

	hhEmu->emu_aiEnd[iRow] = EMU_BLANK_LINE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void emuLineFeed(const HHEMU hhEmu)
	{
	ECHAR aechBuf[10];
	int 	iRow = row_index(hhEmu, hhEmu->emu_currow);

	if (hhEmu->print_echo)
		{
		printEchoLine(hhEmu->hPrintEcho,
			hhEmu->emu_apText[row_index(hhEmu, hhEmu->emu_currow)],
			emuRowLen(hhEmu, iRow));

		if (hhEmu->emu_code == ETEXT('\f'))
			{
			CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), TEXT("\f"), StrCharGetByteCount(TEXT("\f")));
			printEchoLine(hhEmu->hPrintEcho, aechBuf, sizeof(ECHAR));
			}
		}

	if (hhEmu->mode_LNM)
		ANSI_CNL(hhEmu, 1);
	else
		ANSI_IND(hhEmu);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * emu_print
 *
 * DESCRIPTION:
 *	Prints the specified bufr. Opens a print channel if one is not
 *	already open
 *
 * ARGUMENTS:
 *	bufr -- address of bufr to print
 *	length -- number of chars to print from bufr
 *
 * RETURNS:
 *	nothing
 */
void emuPrintChars(const HHEMU hhEmu, ECHAR *bufr, int nLen)
	{
	int nIndex;
	ECHAR *tChar;

	if (nLen == 0 || bufr == 0)
		return;

	for (nIndex = 0; nIndex < nLen; nIndex++)
		{
		tChar = bufr + nIndex;
		printEchoChar(hhEmu->hPrintHost, *tChar);
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void scrolldown(const HHEMU hhEmu, int nlines)
	{
	register int row, nrows;
	int toprow, botmrow;
	int nScrlInc;

	if (nlines <= 0)
		return;

	hhEmu->scr_scrollcnt -= nlines;
	nScrlInc = nlines;

	toprow = hhEmu->top_margin;
	botmrow = hhEmu->bottom_margin;

	if (hhEmu->top_margin == 0 && hhEmu->bottom_margin == hhEmu->emu_maxrow)
		{
		hhEmu->emu_imgtop = row_index(hhEmu, -nlines);
		}

	else if (nlines < hhEmu->bottom_margin - hhEmu->top_margin + 1)
		{
		nrows = hhEmu->bottom_margin - hhEmu->top_margin + 1 - nlines;

		for (row = hhEmu->bottom_margin; nrows > 0; --nrows, --row)
			{
			int c;
			PSTATTR pstAttr, pstAttr2;

			memmove(hhEmu->emu_apText[row_index(hhEmu, row)],
				 hhEmu->emu_apText[row_index(hhEmu, row - nlines)],
						(size_t)(hhEmu->emu_maxcol+2));

			hhEmu->emu_aiEnd[row_index(hhEmu, row - nlines)] =
				hhEmu->emu_aiEnd[row_index(hhEmu, row)];

			pstAttr  = hhEmu->emu_apAttr[row_index(hhEmu, row)];
			pstAttr2 = hhEmu->emu_apAttr[row_index(hhEmu, row - nlines)];

			for (c = 0 ; c <= hhEmu->emu_maxcol ; ++c)
				pstAttr[c] = pstAttr2[c];
			}
		}

	for (row = hhEmu->top_margin; nlines > 0; --nlines, ++row)
		clear_imgrow(hhEmu, row);

	hhEmu->emu_imgrow = row_index(hhEmu, hhEmu->emu_currow);

	updateScroll(sessQueryUpdateHdl(hhEmu->hSession),
					toprow, botmrow, -nScrlInc, hhEmu->emu_imgtop, TRUE);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void scrollup(const HHEMU hhEmu, int nlines)
	{
	register INT row;
	INT 	nrows, iLen, iThisRow;
	ECHAR *lp;			/* line pointer */
	ECHAR aechBuf[10];
	INT nScrlInc;		/* needed for call to Vid routine at bottom of func */

	HBACKSCRL hBackscrl = sessQueryBackscrlHdl(hhEmu->hSession);
	HCAPTUREFILE hCapture = sessQueryCaptureFileHdl(hhEmu->hSession);

	if (nlines <= 0)
		return;

	hhEmu->scr_scrollcnt += nlines;
	nScrlInc = nlines = min(nlines,
							hhEmu->bottom_margin - hhEmu->top_margin + 1);

	for (row = hhEmu->top_margin; row < (hhEmu->top_margin + nlines); ++row)
		{
		iThisRow = row_index(hhEmu, row);
		lp = hhEmu->emu_apText[iThisRow];
		iLen = emuRowLen(hhEmu, iThisRow);

		backscrlAdd(hBackscrl, lp, iLen);

		CaptureLine(hCapture, CF_CAP_SCREENS, lp, iLen);

		printEchoScreen(hhEmu->hPrintEcho, lp, iLen);
		CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), TEXT("\r\n"), StrCharGetByteCount(TEXT("\r\n")));
		printEchoScreen(hhEmu->hPrintEcho, aechBuf, sizeof(ECHAR) * 2);

		clear_imgrow(hhEmu, row);
		}

	if (hhEmu->top_margin == 0 && hhEmu->bottom_margin == hhEmu->emu_maxrow)
		{
		hhEmu->emu_imgtop = row_index(hhEmu, nlines);
		}

	else if (nlines < (hhEmu->bottom_margin - hhEmu->top_margin + 1))
		{
		nrows = hhEmu->bottom_margin - hhEmu->top_margin + 1 - nlines;

		for (row = hhEmu->top_margin; nrows > 0; --nrows, ++row)
			{
			INT c;
			PSTATTR pstAttr, pstAttr2;

			memmove(hhEmu->emu_apText[row_index(hhEmu, row)],
				 hhEmu->emu_apText[row_index(hhEmu, row + nlines)],
				 (size_t)hhEmu->emu_maxcol + 2);

			hhEmu->emu_aiEnd[row_index(hhEmu, row + nlines)] =
				hhEmu->emu_aiEnd[row_index(hhEmu, row)];

			pstAttr  = hhEmu->emu_apAttr[row_index(hhEmu, row)];
			pstAttr2 = hhEmu->emu_apAttr[row_index(hhEmu, row + nlines)];

			for (c = 0 ; c <= hhEmu->emu_maxcol ; ++c)
				pstAttr[c] = pstAttr2[c];
			}

		for (row = hhEmu->bottom_margin; nlines > 0; --nlines, --row)
			clear_imgrow(hhEmu, row);
		}

	hhEmu->emu_imgrow = row_index(hhEmu, hhEmu->emu_currow);

	updateScroll(sessQueryUpdateHdl(hhEmu->hSession),
					hhEmu->top_margin,
					hhEmu->bottom_margin,
					nScrlInc,
					hhEmu->emu_imgtop,
					TRUE);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void tab(const HHEMU hhEmu)
	{
	int col;

	col = hhEmu->emu_curcol;
	while (col <= hhEmu->emu_maxcol)
		if (hhEmu->tab_stop[++col])
			break;

	(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, col);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void backtab(const HHEMU hhEmu)
	{
	int col;

	col = hhEmu->emu_curcol;
	while (col > 0)
		{
		if (hhEmu->tab_stop[--col])
            {
			break;
            }
		}

	(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, col);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void tabn(const HHEMU hhEmu)
	{
	int iCol;
	int iTabSize;

	iCol = hhEmu->emu_curcol;

	iTabSize = CLoopGetTabSizeIn(sessQueryCLoopHdl(hhEmu->hSession));

	while (iCol <= hhEmu->emu_maxcol)
		{
		if (++iCol % iTabSize == 0)
			break;
		}

	(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, iCol);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emu_bell
 *
 * DESCRIPTION:
 *	 Displays the bell code.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void emu_bell(const HHEMU hhEmu)
	{
	MessageBeep(0xFFFFFFFF); // Standard Beep
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emu_clearword
 *
 * DESCRIPTION:
 *	 Clears a part of current line.
 *
 * ARGUMENTS:
 *	 fromcol -- virtual image column of 1st character to be cleared
 *   tocol -- virtual image column of last character to be cleared
 *
 * RETURNS:
 *	 nothing
 */
void emu_clearword(const HHEMU hhEmu, int fromcol, int tocol)
	{
	int c;
	STATTR stAttr;
	int old_mode_IRM;

	(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, fromcol);
	old_mode_IRM = hhEmu->mode_IRM;
	hhEmu->mode_IRM = RESET;		   /* overwrite, not insert */
	stAttr = hhEmu->attrState[CSCLEAR_STATE];

	for (c = fromcol; c <= tocol; ++c)
		{
		hhEmu->emu_code = ETEXT(' ');
		(*hhEmu->emu_graphic)(hhEmu);
		}

	hhEmu->attrState[CSCLEAR_STATE] = stAttr;
	hhEmu->mode_IRM = old_mode_IRM;
	(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, fromcol);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\keytbls.h ===
/*	File: D:\LELAND\emu\keytbls.h (Created: 27-Dec-1994)
 *
 *	Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:27p $
 */
// ------------  OS/2 Include Files ------------
#include <windows.h>
#pragma hdrstop
#include <tdll\chars.h>

#define MAX_ANSI_KEYS 16
extern const KEYTBLSTORAGE AnsiKeyTable[MAX_ANSI_KEYS];

#define MAX_IBMPC_KEYS 185
extern const KEYTBLSTORAGE IBMPCKeyTable[MAX_IBMPC_KEYS];

#define MAX_VT52_KEYS 19
extern const KEYTBLSTORAGE VT52KeyTable[MAX_VT52_KEYS];

#define MAX_VT52_KEYPAD_KEYS 14
extern const KEYTBLSTORAGE VT52_Keypad_KeyTable[MAX_VT52_KEYPAD_KEYS];

#define MAX_VT_PF_KEYS 4
extern const KEYTBLSTORAGE VT_PF_KeyTable[MAX_VT_PF_KEYS];

#define MAX_VT100_KEYS 24
extern const KEYTBLSTORAGE VT100KeyTable[MAX_VT100_KEYS];

#define MAX_VT100_CURSOR_KEYS 8
extern const KEYTBLSTORAGE VT100_Cursor_KeyTable[MAX_VT100_CURSOR_KEYS];

#define MAX_VT100_KEYPAD_KEYS 14
extern const KEYTBLSTORAGE VT100_Keypad_KeyTable[MAX_VT100_KEYPAD_KEYS];

#define MAX_MINITEL_KEYS 82
extern const KEYTBLSTORAGE Minitel_KeyTable[MAX_MINITEL_KEYS];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\keydef.h ===
/*  File: \shared\emulator\keydef.h (Created: 12/19/95)
 *
 *  Copyright 1995 by Hilgraeve Inc. -- Monroe, MI
 *  All rights reserved
 *
 *  Description:
 *		This header file defines structures and macros for
 *		handling keyboard imput in a plateform independent
 *		fashion.
 *
 *  $Revision: 1 $
 *  $Date: 10/05/98 12:27p $
 */
#if !defined(KEYDEF_INCLUDED)
#define KEYDEF_INCLUDED

// Here it is!  The fame and fabled KEYDEF typedef.  This type is used
// throughout our entire code base to represent a "key".  A key is any
// character data coming from the user thru a local input device (fancy
// way of saying a keyboard).  It contains reserved areas as follows:
//
// bits 00-15   : character or virtual key code.
// bits 16-19   : key state information (ALT, CTRL, SHIFT, EXTENDED)
// bit  23		: controls how bits 00-15 are interpreted (Virtual or char)
//
// This means a KEYDEF has a minimum size of 24 bits.  In practical terms
// KEYDEF should be defined in such way to be at least 32 bits.
//
// Interesting thought:  There is a world standard being proposed that
// use 32 bits to represent a character.  If this ever happens, we would
// have to have a 40 bit value to represent a key.  I suspect that when
// that happens, we'll all be using 64 bit architectures anyways.
//
// Interesting thought two:  We tried to represent a key as a bit-field
// structure but ran into difficulties.  The disadvantages were; needed
// a function to compare KEYDEF values since bit-fields are set in a
// plateform specific way; could not easily create constant KEYDEF values
// that could be used in switch statements.  Using a simply integer type
// makes manipulating and comparing KEYDEF values much easier.
//
typedef unsigned int KEYDEF;   // minimum size is 32 bits.

// Keys are interpreted as follows:
//
// If the VIRTUAL_KEY flag is clear, then the lower word of the value is the
// displayable (usually ASCII) code for the character
//
// If the VIRTUAL_KEY flag is set, then the lower word is the
// HVK key code for the key that was pressed.  In addition, the flags
// for ALT_KEY, CTRL_KEY, SHIFT_KEY, and EXTENDED_KEY are set to the
// correct values.
//
// mrw:3/4/96 - Added the HVIRTUAL_KEY flag.  Needed to do this for
// windows because many of the WM_KEYDOWN sequences in Windows look
// like our HVK_? values.  The VIRTUAL_KEY flag is stilled OR'ed in
// to the HVK_? values to maintain compatibility with our old code.
//
#define HVIRTUAL_KEY		0x01000000
#define VIRTUAL_KEY			0x00800000
#define ALT_KEY				0x00010000
#define CTRL_KEY			0x00020000
#define SHIFT_KEY			0x00040000
#define EXTENDED_KEY		0x00080000

// So just what is an HVK key code?  Virtual keys are representations
// for keys that are independent of the position on the keyboard.  For
// instance, our program deals with the concept of Page-Up.  We don't
// really care that it is one code in OS/2 and another code in Windows.
// Both OS/2 and Windows generate Virtual key codes but they are
// values (and sometimes symbolic names).  To keep our code independent
// of these differences, we translate the system specific virtual key
// code to a HVK key code.  Our code then deals only in HVK virtual key
// codes.  There of course must be function to provide a translation
// layer which is always defined on the project side.
//
// HVK constants are our definitions for virtual keys.  They are plateform
// independent.  Anyone translating keyboard input will need a function to
// map the system specific virtual key code to a HVK key code.
//
#define HVK_BUTTON1			(0x01 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_BUTTON2			(0x02 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_BUTTON3			(0x03 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_BREAK			(0x04 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_BACKSPACE		(0x05 | VIRTUAL_KEY | HVIRTUAL_KEY)   // can't be used in shared code - mrw
#define HVK_TAB				(0x06 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_BACKTAB			(0x07 | VIRTUAL_KEY | HVIRTUAL_KEY)   // can't be used in shared code - mrw
#define HVK_NEWLINE			(0x08 | VIRTUAL_KEY | HVIRTUAL_KEY)   // can't be used in shared code - mrw
#define HVK_SHIFT			(0x09 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_CTRL			(0x0A | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_ALT				(0x0B | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_ALTGRAF			(0x0C | VIRTUAL_KEY | HVIRTUAL_KEY)   // can't be used in shared code - mrw
#define HVK_PAUSE			(0x0D | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_CAPSLOCK		(0x0E | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_ESC				(0x0F | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_SPACE			(0x10 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_PAGEUP			(0x11 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_PAGEDOWN		(0x12 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_END				(0x13 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_HOME			(VK_HOME | VIRTUAL_KEY)
#define HVK_LEFT			(VK_LEFT | VIRTUAL_KEY)
#define HVK_UP				(VK_UP | VIRTUAL_KEY)
#if FALSE
#define HVK_HOME			(0x14 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_LEFT			(0x15 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_UP				(0x16 | VIRTUAL_KEY | HVIRTUAL_KEY)
#endif
#define HVK_RIGHT			(0x17 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_DOWN			(0x18 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_PRINTSCRN		(0x19 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_INSERT			(0x1A | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_DELETE			(0x1B | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_SCRLLOCK		(0x1C | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_NUMLOCK			(0x1D | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_ENTER			(0x1E | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_SYSRQ			(0x1F | VIRTUAL_KEY | HVIRTUAL_KEY)   // can't be used in shared code - mrw
#define HVK_F1				(0x20 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F2				(0x21 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F3				(0x22 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F4				(0x23 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F5				(0x24 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F6				(VK_F6 | VIRTUAL_KEY)
#define HVK_F7				(VK_F7 | VIRTUAL_KEY)
#define HVK_F8				(VK_F8 | VIRTUAL_KEY)
#define HVK_F9				(VK_F9 | VIRTUAL_KEY)
#if FALSE
#define HVK_F6				(0x25 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F7				(0x26 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F8				(0x27 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F9				(0x28 | VIRTUAL_KEY | HVIRTUAL_KEY)
#endif
#define HVK_F10				(0x29 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F11				(0x2A | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F12				(0x2B | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F13				(0x2C | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F14				(0x2D | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F15				(0x2E | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F16				(0x2F | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F17				(0x30 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F18				(0x31 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F19				(0x32 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F20				(0x33 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F21				(0x34 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F22				(0x35 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F23				(0x36 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F24				(0x37 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_ENDDRAG			(0x38 | VIRTUAL_KEY | HVIRTUAL_KEY)   // can't be used in shared code - mrw
#define HVK_EREOF			(0x3A | VIRTUAL_KEY | HVIRTUAL_KEY)   // can't be used in shared code - mrw
#define HVK_PA1				(0x3B | VIRTUAL_KEY | HVIRTUAL_KEY)

#define HVK_ADD				(0x3D | VIRTUAL_KEY | HVIRTUAL_KEY)   // Identifies key on Numeric Keypad only.
#define HVK_SUBTRACT		(0x3E | VIRTUAL_KEY | HVIRTUAL_KEY)   // Identifies key on Numeric Keypad only.

// These constants represent the keys on the numeric keypad, when
// the Num Lock key is on.  Again, when the Num Lock key is On.
//
#define HVK_NUMPAD0			(0x45 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_NUMPAD1			(0x46 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_NUMPAD2			(0x47 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_NUMPAD3			(0x48 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_NUMPAD4			(0x49 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_NUMPAD5			(0x64 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_NUMPAD6			(0x4A | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_NUMPAD7			(0x4B | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_NUMPAD8			(0x4C | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_NUMPAD9			(0x4D | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_NUMPADPERIOD	(0x53 | VIRTUAL_KEY | HVIRTUAL_KEY)

// These constants represent some of the keys on the numeric keypad, only.
//
#define HVK_DECIMAL			(0x4E | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_RETURN			(0x4F | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_FSLASH			(0x50 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_MULTIPLY		(0x51 | VIRTUAL_KEY | HVIRTUAL_KEY)

// This constant represents the 5 on the numeric keypad, or the center
// key on the edit pad.  If it's from the edit pad, the extended bit
// will be set.
//
#define HVK_CENTER			(0x52 | VIRTUAL_KEY | HVIRTUAL_KEY)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\trm.c ===
/*	File: D:\WACKER\emu\trm.c (Created: 23-Dec-1993)
 *
 *	Copyright 1993 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:28p $
 */

/* This file is no longer used! --jcm */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\vid.h ===
/*	File: D:\WACKER\emu\vid.h (Created: 09-Dec-1993)
 *
 *	Copyright 1993 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:29p $
 */

/* This file is no longer used! --jcm */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\minitel.c ===
/*	File: D:\wacker\emu\minitel.c (Created: 05-Mar-1994)
 *
 *	Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 4 $
 *	$Date: 4/19/01 5:05p $
 */

#include <windows.h>
#pragma hdrstop
													
#include <time.h>

#include <tdll\stdtyp.h>
#include <tdll\tdll.h>
#include <tdll\session.h>
#include <tdll\cloop.h>
#include <tdll\print.h>
#include <tdll\capture.h>
#include <tdll\assert.h>
#include <tdll\mc.h>
#include <tdll\update.h>
#include <tdll\chars.h>
#include <tdll\cnct.h>
#include <tdll\term.h>
#include <tdll\backscrl.h>
#include <tdll\htchar.h>
#include <term\res.h>
#include <tapi.h>
#include <cncttapi\cncttapi.hh>

#include "emu.h"
#include "emu.hh"
#include "emuid.h"
#include "minitel.hh"
#include "keytbls.h"


#if defined(INCL_MINITEL)

static void emuMinitelRedisplayLine(const HHEMU hhEmu,
										const int row,
										const int col);

static int minitel_kbdin(const HHEMU hhEmu, int key, const int fTest);
static ECHAR minitelMapMosaics(const HHEMU hhEmu, ECHAR ch);
static void minitelFullScrnReveal(const HHEMU hhEmu);
static void minitelFullScrnConceal(const HHEMU hhEmu);
static void minitelSS2(const HHEMU hhEmu);
static void minitelSS2Part2(const HHEMU hhEmu);
static void minitelInsMode(const HHEMU hhEmu);
static void minitelPRO1(const HHEMU hhEmu);
static void minitelPRO2Part1(const HHEMU hhEmu);
static void minitelPRO2Part2(const HHEMU hhEmu);
static void minitelStatusReply(const HHEMU hhEmu);

/*
	Here begins the famed and fabled Minitel emulator.	Abandon all hope
	all ye who..., well you get the idea.  The Minitel emulator uses a
	combination of character attributes and field attributes.  See the
	book "minitel 1B" for description of field attributes.	Page numbers
	referenced in this code refer to the before mentioned book. - mrw
*/

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuMinitelInit
 *
 * DESCRIPTION:
 *	Startup routine for the minitel emulator.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void emuMinitelInit(const HHEMU hhEmu)
	{
	int i;
	LOGFONT lf;
	HWND hwndTerm;
	PSTMTPRIVATE pstPRI;

	static struct trans_entry const minitel_tbl[] =
		{
		{NEW_STATE, 0, 0, 0}, // 0
		{0, ETEXT('\x00'), ETEXT('\x01'), nothing},
		{0, ETEXT('\x20'), ETEXT('\x7F'), minitelGraphic},
		{1, ETEXT('\x1B'), ETEXT('\x1B'), nothing},
		{0, ETEXT('\x07'), ETEXT('\x07'), emu_bell},

		{0, ETEXT('\b'),   ETEXT('\b'), minitelBackspace},
		{0, ETEXT('\t'),   ETEXT('\t'),	minitelHorzTab},
		{0, ETEXT('\n'),   ETEXT('\n'),	minitelLinefeed},
		{0, ETEXT('\x0B'), ETEXT('\x0B'), minitelVerticalTab},
		{0, ETEXT('\x0C'), ETEXT('\x0C'), minitelFormFeed},
		{0, ETEXT('\r'),   ETEXT('\r'),	carriagereturn},
		{0, ETEXT('\x0E'), ETEXT('\x0F'), minitelCharSet},  // change char set
		{0, ETEXT('\x11'), ETEXT('\x11'), minitelCursorOn}, // cursor on
		{5, ETEXT('\x12'), ETEXT('\x12'), nothing},		  // repeat
		{12,ETEXT('\x13'), ETEXT('\x13'), nothing},		  // SEP
		{0, ETEXT('\x14'), ETEXT('\x14'), minitelCursorOff},// cursor off
		{20,ETEXT('\x16'), ETEXT('\x16'), nothing},		  // SS2 (undocumented)
		{0, ETEXT('\x18'), ETEXT('\x18'), minitelCancel},   // cancel
		{20,ETEXT('\x19'), ETEXT('\x19'), nothing}, 	  // SS2
		{0, ETEXT('\x1C'), ETEXT('\x1C'), nothing}, // really is nothing.
		{13,ETEXT('\x1D'), ETEXT('\x1D'), nothing}, // SS3,X ingnored, p99, 1.2.7
		{0, ETEXT('\x1E'), ETEXT('\x1E'), minitelRecordSeparator},
		{3, ETEXT('\x1F'), ETEXT('\x1F'), nothing}, // Unit Seperator
		//{0, ETEXT('\x7F'), ETEXT('\x7F'), minitelDel},

		{NEW_STATE, 0, 0, 0}, // 1 - seen ESC
		{1, ETEXT('\x00'), ETEXT('\x00'), nothing},
		{0, ETEXT('\x01'), ETEXT('\x1F'), minitelResync},
		{18,ETEXT('\x23'), ETEXT('\x23'), nothing},
		{14,ETEXT('\x25'), ETEXT('\x25'), nothing},
		{13,ETEXT('\x35'), ETEXT('\x37'), nothing},	// eat ESC,35-37,X sequences
		{6, ETEXT('\x39'), ETEXT('\x39'), nothing},	// PROT1, p134
		{7, ETEXT('\x3A'), ETEXT('\x3A'), nothing},	// PROT2, p134
		{8, ETEXT('\x3B'), ETEXT('\x3B'), nothing},	// PROT3, p134
		{2, ETEXT('\x5B'), ETEXT('\x5B'), ANSI_Pn_Clr},
		{0, ETEXT('\x40'), ETEXT('\x49'), emuMinitelCharAttr}, // forground color, flashing
		{0, ETEXT('\x4C'), ETEXT('\x4F'), emuMinitelCharAttr}, // char width & height
		{0, ETEXT('\x50'), ETEXT('\x5A'), emuMinitelFieldAttr},// background, underlining
		{0, ETEXT('\x5F'), ETEXT('\x5F'), emuMinitelFieldAttr},// reveal display
		{0, ETEXT('\x5C'), ETEXT('\x5D'), emuMinitelCharAttr}, // inverse
		{0, ETEXT('\x61'), ETEXT('\x61'), minitelCursorReport},
		{22,ETEXT('\x20'), ETEXT('\x2F'), nothing}, // p.99 ISO 2022

		{NEW_STATE, 0, 0, 0}, // 2 - seen ESC [
		{2, ETEXT('\x00'), ETEXT('\x00'), nothing},
		{2, ETEXT('\x30'), ETEXT('\x39'), ANSI_Pn},
		{2, ETEXT('\x3B'), ETEXT('\x3B'), ANSI_Pn_End},
		{2, ETEXT('\x3A'), ETEXT('\x3F'), ANSI_Pn},
		{0, ETEXT('\x40'), ETEXT('\x40'), minitelInsChars},
		{0, ETEXT('\x41'), ETEXT('\x41'), minitelCursorUp},
		{0, ETEXT('\x42'), ETEXT('\x42'), ANSI_CUD},
		{0, ETEXT('\x43'), ETEXT('\x43'), ANSI_CUF},
		{0, ETEXT('\x44'), ETEXT('\x44'), ANSI_CUB},
		{0, ETEXT('\x48'), ETEXT('\x48'), minitelCursorDirect},
		{0, ETEXT('\x4A'), ETEXT('\x4A'), minitelClrScrn},
		{0, ETEXT('\x4B'), ETEXT('\x4B'), minitelClrLn},
		{0, ETEXT('\x4C'), ETEXT('\x4C'), minitelInsRows},
		{0, ETEXT('\x4D'), ETEXT('\x4D'), minitelDelRows},
		{0, ETEXT('\x50'), ETEXT('\x50'), minitelDelChars},
		{0, ETEXT('\x68'), ETEXT('\x69'), minitelInsMode},
		{0, ETEXT('\x7A'), ETEXT('\x7B'), nothing}, //* p144 12.2
		{0, ETEXT('\x7D'), ETEXT('\x7D'), nothing}, //* p144 12.2
		{0, ETEXT('\x7F'), ETEXT('\x7F'), minitelResetTerminal}, //* p145, 13.2

		{NEW_STATE, 0, 0, 0}, // 3 - unit separtor character position
		{3, ETEXT('\x00'), ETEXT('\x00'), nothing},
		{4, ETEXT('\x01'), ETEXT('\xFF'), minitelUSRow},

		{NEW_STATE, 0, 0, 0}, // 4 - end of unit separtor character position
		{4, ETEXT('\x00'), ETEXT('\x00'), nothing},
		{0, ETEXT('\x01'), ETEXT('\xFF'), minitelUSCol},

		{NEW_STATE, 0, 0, 0}, // 5 - number of repeats
		{5, ETEXT('\x00'), ETEXT('\x00'), nothing},
		{0, ETEXT('\x40'), ETEXT('\x7F'), minitelRepeat},
		{0, ETEXT('\x00'), ETEXT('\xFF'), minitelResync},

		{NEW_STATE, 0, 0, 0}, // 6 - Protocol 1 sequence (PRO1,X)
		{6, ETEXT('\x00'), ETEXT('\x00'), nothing},
		{0, ETEXT('\x01'), ETEXT('\xFF'), minitelPRO1},

		{NEW_STATE, 0, 0, 0}, // 7 - Protocol 2 sequence (PRO2,X,Y)
		{7, ETEXT('\x00'), ETEXT('\x00'), nothing},
		{8, ETEXT('\x01'), ETEXT('\xFF'), minitelPRO2Part1},

		{NEW_STATE, 0, 0, 0}, // 8 - Protocol 2 sequence (PRO2,X,Y)
		{8, ETEXT('\x00'), ETEXT('\x00'), nothing},
		{0, ETEXT('\x01'), ETEXT('\xFF'), minitelPRO2Part2},

		{NEW_STATE, 0, 0, 0}, // 9 - Protocol 3 sequence (PRO3,X,Y,Z)
		{9, ETEXT('\x00'), ETEXT('\x00'), nothing},
		{10,ETEXT('\x01'), ETEXT('\xFF'), nothing},

		{NEW_STATE, 0, 0, 0}, // 10 - Protocol 3 sequence (PRO3,X,Y,Z)
		{10,ETEXT('\x00'), ETEXT('\x00'), nothing},
		{11,ETEXT('\x01'), ETEXT('\xFF'), nothing},

		{NEW_STATE, 0, 0, 0}, // 11 - Protocol 3 sequence (PRO3,X,Y,Z)
		{11,ETEXT('\x00'), ETEXT('\x00'), nothing},
		{0, ETEXT('\x01'), ETEXT('\xFF'), nothing},

		{NEW_STATE, 0, 0, 0}, // 12 - SEP
		{12,ETEXT('\x00'), ETEXT('\x00'), nothing},
		{0, ETEXT('\x01'), ETEXT('\xFF'), nothing},

		{NEW_STATE, 0, 0, 0}, // 13 - ESC,35-39,X sequences eaten, p99, 1.2.7
		{13,ETEXT('\x00'), ETEXT('\x00'), nothing},
		{0, ETEXT('\x01'), ETEXT('\xFF'), nothing},

		{NEW_STATE, 0, 0, 0}, // 14 - screen transparency mode
		{15,ETEXT('\x1B'), ETEXT('\x1B'), nothing},
		{14,ETEXT('\x00'), ETEXT('\xFF'), nothing},
		{23,ETEXT('\x20'), ETEXT('\x2F'), nothing}, // could be ISO 2022

		{NEW_STATE, 0, 0, 0}, // 15 - screen transparency mode continued, seen ESC
		{16,ETEXT('\x25'), ETEXT('\x25'), nothing},
		{17,ETEXT('\x2F'), ETEXT('\x2F'), nothing},
		{15,ETEXT('\x00'), ETEXT('\x00'), nothing},
		{14,ETEXT('\x00'), ETEXT('\xFF'), nothing},

		{NEW_STATE, 0, 0, 0}, // 16 - screen transparency mode continued, seen ESC \x25
		{0, ETEXT('\x40'), ETEXT('\x40'), nothing},
		{16,ETEXT('\x00'), ETEXT('\x00'), nothing},
		{14,ETEXT('\x00'), ETEXT('\xFF'), nothing},

		{NEW_STATE, 0, 0, 0}, // 17 - screen transparency mode continued, seen ESC \x2F
		{0, ETEXT('\x3F'), ETEXT('\x3F'), nothing},
		{17,ETEXT('\x00'), ETEXT('\x00'), nothing},
		{14,ETEXT('\x00'), ETEXT('\xFF'), nothing},

		{NEW_STATE, 0, 0, 0}, // 18 - Full screen reveal/hide, seen ESC \x23
		{18,ETEXT('\x00'), ETEXT('\x00'), nothing},
		{19,ETEXT('\x20'), ETEXT('\x20'), nothing},
		{23,ETEXT('\x20'), ETEXT('\x2F'), nothing}, // could be ISO 2022

		{NEW_STATE, 0, 0, 0}, // 19 - Full screen reveal/hide, seen ESC \x23 \x20
		{19,ETEXT('\x00'), ETEXT('\x00'), nothing},
		{0, ETEXT('\x58'), ETEXT('\x58'), minitelFullScrnConceal},
		{0, ETEXT('\x5F'), ETEXT('\x5F'), minitelFullScrnReveal},

		{NEW_STATE, 0, 0, 0}, // 20 - SS2
		{20,ETEXT('\x00'), ETEXT('\x00'), nothing},
		{0, ETEXT('\x00'), ETEXT('\x1F'), minitelResync},
		{21,ETEXT('\x20'), ETEXT('\x7F'), minitelSS2}, // valid SS2

		{NEW_STATE, 0, 0, 0}, // 21 - SS2 part 2
		{21,ETEXT('\x00'), ETEXT('\x00'), nothing},
		{0, ETEXT('\x20'), ETEXT('\x7F'), minitelSS2Part2}, // valid SS2

		{NEW_STATE, 0, 0, 0}, // 22 - p.99 ISO 2022
		{23,ETEXT('\x20'), ETEXT('\x2F'), nothing},
		{0, ETEXT('\x00'), ETEXT('\x1F'), minitelResync},

		{NEW_STATE, 0, 0, 0}, // 23 - p.99 ISO 2022
		{24,ETEXT('\x20'), ETEXT('\x2F'), nothing},
		{0, ETEXT('\x00'), ETEXT('\x1F'), minitelResync},

		{NEW_STATE, 0, 0, 0}, // 24 - p.99 ISO 2022
		{25, ETEXT('\x30'), ETEXT('\x3F'), nothing}, // page 107.
		{0,  ETEXT('\x30'), ETEXT('\x7E'), nothing}, // final character
		{0,  ETEXT('\x00'), ETEXT('\x1F'), minitelResync},

		{NEW_STATE, 0, 0, 0}, // 25 - p.99 ISO 2022
		{0,  ETEXT('\x0D'), ETEXT('\x0D'), nothing}, // page 107. eat CR
		{0,  ETEXT('\x00'), ETEXT('\x7F'), minitelResync},
		};

	if (hhEmu == 0)
		{
		assert(0);
		return;
		}

	emuInstallStateTable(hhEmu, minitel_tbl, DIM(minitel_tbl));

	// Allocate and initialize private data for Minitel emulator.
	//
	if (hhEmu->pvPrivate != 0)
		{
		free(hhEmu->pvPrivate);
		hhEmu->pvPrivate = 0;
		}

	hhEmu->pvPrivate = malloc(sizeof(MTPRIVATE));

	if (hhEmu->pvPrivate == 0)
		{
		assert(FALSE);
		return;
		}

	pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;
	memset(pstPRI, 0, sizeof(MTPRIVATE));

	pstPRI->minitel_last_char = ETEXT(' ');

	/* load key array */

	emuKeyTableLoad(hhEmu, Minitel_KeyTable,
					 sizeof(Minitel_KeyTable)/sizeof(KEYTBLSTORAGE),
					 &hhEmu->stEmuKeyTbl);

	/* --- Allocate attribute buffer for Minitel junk --- */

	pstPRI->apstMT = malloc(MAX_EMUROWS * sizeof(PSTMINITEL));

	if (pstPRI->apstMT == 0)
		{
		assert(FALSE);
		return;
		}

	memset(pstPRI->apstMT, 0, MAX_EMUROWS * sizeof(PSTMINITEL));

	for (i = 0 ; i < MAX_EMUROWS ; ++i)
		{
		pstPRI->apstMT[i] = malloc(MAX_EMUCOLS * sizeof(STMINITEL));

		if (pstPRI->apstMT[i] == 0)
			{
			assert(FALSE);
			return;
			}

		memset(pstPRI->apstMT[i], 0, MAX_EMUCOLS * sizeof(STMINITEL));
		}

	/* --- Setup defaults --- */

	hhEmu->emu_maxrow = 24; 		   // 25 line emulator
	hhEmu->emu_maxcol = 39; 		   // start in 40 column mode
	hhEmu->top_margin = 1;			   // access to row 0 is restricted.
	hhEmu->bottom_margin = hhEmu->emu_maxrow; // this has to equal emu_maxrow which changed

	hhEmu->emu_kbdin = minitel_kbdin;
	hhEmu->emu_graphic = minitelGraphic;
	hhEmu->emu_deinstall = emuMinitelDeinstall;
	hhEmu->emu_ntfy = minitelNtfy;
	hhEmu->emuHomeHostCursor = minitelHomeHostCursor;
#ifdef INCL_TERMINAL_SIZE_AND_COLORS
    hhEmu->emu_setscrsize	= emuMinitelSetScrSize;
#endif
	hhEmu->emu_highchar = (TCHAR)0xFF;

	if (hhEmu->emu_currow == 0)
		(*hhEmu->emu_setcurpos)(hhEmu, 1, hhEmu->emu_curcol - 1);

	// Also, set font to Arial Alternative
	//
	memset(&lf, 0, sizeof(LOGFONT));
	hwndTerm = sessQueryHwndTerminal(hhEmu->hSession);
	termGetLogFont(hwndTerm, &lf);

	if (StrCharCmpi(lf.lfFaceName, "Arial Alternative") != 0)
		{
		StrCharCopy(lf.lfFaceName, "Arial Alternative");
        lf.lfWeight = FW_DONTCARE;
        lf.lfItalic = FALSE;
        lf.lfUnderline = FALSE;
        lf.lfStrikeOut = FALSE;
		lf.lfCharSet = DEFAULT_CHARSET;
        lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
        lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
        lf.lfQuality = DEFAULT_QUALITY;
		lf.lfPitchAndFamily = FIXED_PITCH | FF_MODERN;
		termSetLogFont(hwndTerm, &lf);
		}

	// Backscroll not supported in minitel
	//
	backscrlSetUNumLines(sessQueryBackscrlHdl(hhEmu->hSession), 0);

	// Initialize colors for the Minitel.
	//
	std_setcolors(hhEmu, VC_BRT_WHITE, VC_BLACK);

	// Set terminal to power-up state
	//
	minitelResetTerminal(hhEmu);

	// Turn backscroll off for Minitel
	//
	backscrlSetShowFlag(sessQueryBackscrlHdl(hhEmu->hSession), FALSE);

	// Enable Minitel toolbar buttons
	//
	PostMessage(sessQueryHwnd(hhEmu->hSession), WM_SESS_SHOW_SIDEBAR, 0, 0);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuMinitelDeinstall
 *
 * DESCRIPTION:
 *	Frees the extra attribute buffer needed to manage serial attributes.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void emuMinitelDeinstall(const HHEMU hhEmu)
	{
	int i;
	PSTMTPRIVATE pstPRI;

	assert(hhEmu);
	pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	if (pstPRI)
		{
		if (pstPRI->apstMT)
			{
			for (i = 0 ; i < MAX_EMUROWS ; ++i)
				{
				if (pstPRI->apstMT[i])
					{
					free(pstPRI->apstMT[i]);
					pstPRI->apstMT[i] = NULL;
					}
				}

			free(pstPRI->apstMT);
			pstPRI->apstMT = 0;
			}

		free(hhEmu->pvPrivate);
		hhEmu->pvPrivate = 0;
		}

	// Hide Minitel toolbar buttons
	//
	ShowWindow(sessQuerySidebarHwnd(hhEmu->hSession), SW_HIDE);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelReset
 *
 * DESCRIPTION:
 *	Sets emulator to an initial state.	Used for record and unit
 *	separators.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void minitelReset(const HHEMU hhEmu)
	{
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	pstPRI->minitelG1Active = FALSE;

	memset(&hhEmu->emu_charattr, 0, sizeof(hhEmu->emu_charattr));
	hhEmu->emu_charattr.txtclr = VC_BRT_WHITE;
	hhEmu->emu_charattr.bkclr = VC_BLACK;

	pstPRI->apstMT[hhEmu->emu_imgrow][hhEmu->emu_curcol].isattr = 0;

	memset(&pstPRI->stLatentAttr, 0, sizeof(pstPRI->stLatentAttr));
	pstPRI->stLatentAttr.fBkClr = TRUE;

	hhEmu->attrState[CS_STATE] =
		hhEmu->attrState[CSCLEAR_STATE] = hhEmu->emu_charattr;

	hhEmu->emu_clearattr = hhEmu->emu_charattr;
	minitelNtfy(hhEmu, 0);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelGraphic
 *
 * DESCRIPTION:
 *	Handles displayable characters.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void minitelGraphic(const HHEMU hhEmu)
	{
	ECHAR ccode;
	ECHAR aechBuf[10];
	int r;
	int row = hhEmu->emu_currow;
	int col = hhEmu->emu_curcol;
	BOOL fRedisplay = FALSE;
    BOOL fDblHi;
	STATTR stAttr;

	ECHAR *tp = hhEmu->emu_apText[hhEmu->emu_imgrow];
	const PSTATTR ap = hhEmu->emu_apAttr[hhEmu->emu_imgrow];
	const HUPDATE hUpdate = sessQueryUpdateHdl(hhEmu->hSession);
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	ccode = hhEmu->emu_code;

	if (ccode == 0)
		return;

	pstPRI->minitel_last_char = ccode;

	if (hhEmu->mode_IRM == SET)
		{
		if (col < hhEmu->emu_maxcol)
			{
			memmove(&tp[col+1], &tp[col],
						(unsigned)(hhEmu->emu_maxcol-col) * sizeof(ECHAR));

			memmove(&ap[col+1], &ap[col],
						(unsigned)(hhEmu->emu_maxcol-col) * sizeof(STATTR));

			memmove(&pstPRI->apstMT[hhEmu->emu_imgrow][col+1],
						&pstPRI->apstMT[hhEmu->emu_imgrow][col],
						(unsigned)(hhEmu->emu_maxcol-col) * sizeof(STMINITEL));
			}
		}

	/* --- check if we are overwriting an attribute space --- */

	if (pstPRI->apstMT[hhEmu->emu_imgrow][col].isattr)
		{
		pstPRI->apstMT[hhEmu->emu_imgrow][col].isattr = FALSE;
		fRedisplay = TRUE;
		}

	/* --- If we receive a space and have latent attributes, validate --- */

	if (ccode == ETEXT('\x20') && pstPRI->stLatentAttr.fModified
			&& pstPRI->minitelG1Active == FALSE)
		{
		r = hhEmu->emu_imgrow;

		// Color
		//
		pstPRI->apstMT[r][col].fbkclr = pstPRI->stLatentAttr.fBkClr;
		pstPRI->apstMT[r][col].bkclr = pstPRI->stLatentAttr.bkclr;

		// Conceal
		//
		pstPRI->apstMT[r][col].conceal = pstPRI->stLatentAttr.conceal;

		// Underline
		//
		pstPRI->apstMT[r][col].undrln = pstPRI->stLatentAttr.undrln;

		pstPRI->apstMT[hhEmu->emu_imgrow][col].isattr  = TRUE;

		// This is truely wierd.  We don't reset the fBkclr, fConceal, or
		// fUndrln fields, only the fModified flag.  Thus if any serial
		// attributes are set, all latent values get updated.  The only
		// guy who appears to be able to turn off an attribute is the
		// mosaic character which validates the background color and sets
		// the fBkClr flag to false.  I can't think of a reason why it
                // should work this way. - mrw
		//
		pstPRI->stLatentAttr.fModified = FALSE;
	    fRedisplay = TRUE;
		}

	/* --- If we switched to G1, map char to location in new font --- */

	if (pstPRI->minitelG1Active)
		ccode = minitelMapMosaics(hhEmu, ccode);

	pstPRI->apstMT[hhEmu->emu_imgrow][col].ismosaic =
		(unsigned)pstPRI->minitelG1Active;

	/* --- If we switched to semigraphic mode, validate the background --- */

	if (pstPRI->minitelG1Active)
		{
		// Guess what?	Latent background color is always adopted for mosaics.
		// This is a major undocumented find.  Basicly, mosaics
		// (semigraphics) always use the latent background color regardless
		// of the validation state.
		//
		ap[col].bkclr = pstPRI->stLatentAttr.bkclr;
		fRedisplay = TRUE;

		// Something tricky here.  Reception of a mosaic validates the
		// background color.  Validate means adopt the color.  It also
		// means that if we shift back to the alpha (G0 char set) and
		// recieve a space, we DON'T validate the background color a
		// second time.  So we keep a seperate flag for the background
		// color validation. - mrw
		//
		pstPRI->stLatentAttr.fBkClr = FALSE;
		}

	/* --- Normal character processing --- */

	tp[col] = ccode;

	// Update the end of row index if necessary.
	//
	if (col > hhEmu->emu_aiEnd[hhEmu->emu_imgrow])
		hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = col;

	/* --- Find out this characters current attributes and adjust --- */

	stAttr = GetAttr(hhEmu, row, col);
	ap[col] = hhEmu->emu_charattr;
	ap[col].bkclr = stAttr.bkclr;
	ap[col].blank = stAttr.blank;
	ap[col].undrln = stAttr.undrln;

	if (pstPRI->minitelG1Active)
		ap[col].symbol = 1;

	// Documented: 0x7F (mosaic or alpha) always maps to 0x5F in the G1
	// character set (solid block).
	//
	if (tp[col] == ETEXT('\x7F'))
		{
		tp[col] = ETEXT('\x5F');
		ap[col].symbol = 1;
		}

	/* --- Double high stuff --- */

	if (hhEmu->emu_charattr.dblhilo)
		{
		if (row >= 2)
			{
			r = row_index(hhEmu, row-1);

			hhEmu->emu_apText[r][col] = ccode;
			hhEmu->emu_apAttr[r][col] = ap[col];
			hhEmu->emu_apAttr[r][col].dblhilo = 0;
			hhEmu->emu_apAttr[r][col].dblhihi = 1;
			pstPRI->apstMT[r][col] = pstPRI->apstMT[hhEmu->emu_imgrow][col];
			updateChar(hUpdate, row-1, col, col);
			}
		}

	/* --- Double wide stuff --- */

	if (hhEmu->emu_charattr.dblwilf)
		{
		if (row > 0 && col < hhEmu->emu_maxcol)
			{
			tp[col+1] = ccode;
			ap[col+1] = ap[col];
			ap[col+1].dblwilf = 0;
			ap[col+1].dblwirt = 1;

			// Major league bug.
			//
			pstPRI->apstMT[hhEmu->emu_imgrow][col+1] =
				pstPRI->apstMT[hhEmu->emu_imgrow][col];
			}

		if (hhEmu->emu_charattr.dblhilo)
			{
			r = row_index(hhEmu, row-1);

			hhEmu->emu_apText[r][col+1] = ccode;
			hhEmu->emu_apAttr[r][col+1] = ap[col];
			hhEmu->emu_apAttr[r][col+1].dblwilf = 0;
			hhEmu->emu_apAttr[r][col+1].dblwirt = 1;
			hhEmu->emu_apAttr[r][col+1].dblhilo = 0;
			hhEmu->emu_apAttr[r][col+1].dblhihi = 1;
			pstPRI->apstMT[r][col+1] = pstPRI->apstMT[hhEmu->emu_imgrow][col];
			}
		}

	/* --- Need to use old row and column --- */

	if (fRedisplay)
		emuMinitelRedisplayLine(hhEmu, row, col);

	/* --- Need to bump the column guy an extra notch if double wide --- */

	if (hhEmu->emu_charattr.dblwilf)
		{
		col += 1;
		hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = col;
		}

	updateChar(hUpdate, row, hhEmu->emu_curcol, col);

	/* --- bump column position, check for wrap, etc. --- */

	if (++col > hhEmu->emu_maxcol)
		{
		// Escape code 0x18 is referred to as cancel in the minitel doco.
		// It fills from the cursor pos to the end of the row with blanks.
		// Note: Also, it does not force wrap in anyway since
		// the cursor position is not updated.	That's why we have to
		// check here. - mrw:5/3/95
		//
		if (pstPRI->fInCancel || row == 0)
			{
			col = hhEmu->emu_maxcol;
			return;
			}

		printEchoString(hhEmu->hPrintEcho, tp,
			emuRowLen(hhEmu, hhEmu->emu_imgrow));

		CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), TEXT("\r\n"),
			StrCharGetByteCount(TEXT("\r\n")));

		printEchoString(hhEmu->hPrintEcho, aechBuf, sizeof(ECHAR) * 2);

		CaptureLine(sessQueryCaptureFileHdl(hhEmu->hSession), CF_CAP_LINES,
			tp, emuRowLen(hhEmu, hhEmu->emu_imgrow));

        // Wrap around accounts for double high
		//
		fDblHi = (BOOL)hhEmu->emu_charattr.dblhilo;

		if (row == hhEmu->bottom_margin)
			{
			if (pstPRI->fScrollMode)
				minitel_scrollup(hhEmu, fDblHi ? 2 : 1);

			else
				row = fDblHi ? 2 : 1;
			}

		else if (row != 0)
			{
			row += fDblHi ? 2 : 1;

			if (row > hhEmu->emu_maxrow)
                row = 2;
			}

		col = 0;
		}

	// Finally, set the cursor position.  This will reset emu_currow
	// and emu_curcol.
	//
	(*hhEmu->emu_setcurpos)(hhEmu, row, col);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuMinitelRedisplayLine
 *
 * DESCRIPTION:
 *	The trick to field attributes is when you encounter one, you need to
 *	update the rest of the line that follows since changing or overwriting
 *	an attribute space affects stuff to the right.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *	int row - row to redisplay
 *	int col - start column
 *
 * RETURNS:
 *	void
 *
 */
static void emuMinitelRedisplayLine(const HHEMU hhEmu,
									const int row,
									const int col)
	{
	int i = row_index(hhEmu, row);
    int fDblHi = FALSE;
	const ECHAR *tp = hhEmu->emu_apText[i];
	const PSTATTR ap = hhEmu->emu_apAttr[i];
	const PSTATTR apl = hhEmu->emu_apAttr[row_index(hhEmu, row-1)];
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;
	const PSTMINITEL pstMT = pstPRI->apstMT[i];

	for (i = col ; i <= hhEmu->emu_maxcol ; ++i)
		{
		ap[i] = GetAttr(hhEmu, row, i);

		// Here's a wierd one.  Attribute spaces (as opposed to plain spaces)
		// validate but do not display the underline attribute.  I suspect
		// something similar with seperated mosaics. - mrw

		if (tp[i] == ETEXT('\x20') && pstMT[i].isattr)
			ap[i].undrln = 0;

        // If we're redisplaying a row that has a double hi character,
        // then we have to redisplay the upper-half as well.

        if (ap[i].dblhilo)
            {
            fDblHi = TRUE;
			apl[i] = GetAttr(hhEmu, row-1, i);
            }
		}

	if (fDblHi)
		{
		updateChar(sessQueryUpdateHdl(hhEmu->hSession),
						row-1, col, hhEmu->emu_maxcol);
		}

	updateChar(sessQueryUpdateHdl(hhEmu->hSession),
						row, col, hhEmu->emu_maxcol);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	GetAttr
 *
 * DESCRIPTION:
 *	Walks the current row and builds a composite attribute based on
 *	the encountered attribute spaces.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *	iRow	- logical row
 *	iCol	- logical col
 *
 * RETURNS:
 *	composite attribute.
 *
 */
STATTR GetAttr(const HHEMU hhEmu, const int iRow, const int iCol)
	{
	int i;
	STATTR stAttr;
	const int r = row_index(hhEmu, iRow);
	const PSTATTR ap = hhEmu->emu_apAttr[r];
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;
	const PSTMINITEL pstMT = pstPRI->apstMT[r];

	stAttr = hhEmu->emu_apAttr[r][iCol];
	stAttr.bkclr = 0;
	stAttr.undrln = 0;
	stAttr.blank = 0;

	for (i = 0 ; i <= iCol ; ++i)
		{
        // Mosaics validate the background color.  Do it first however,
        // because an attribute space can change it to something else.

		if (pstMT[i].ismosaic)
			stAttr.bkclr = ap[i].bkclr;

		if (pstMT[i].isattr)
			{
			if (pstMT[i].fbkclr)
				stAttr.bkclr = pstMT[i].bkclr;

			stAttr.undrln = pstMT[i].undrln;
			stAttr.blank = pstMT[i].conceal;
			}

		// Mosaics always cancel underlining.
		//
		if (pstMT[i].ismosaic)
			stAttr.undrln = 0;
		}

	return stAttr;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuMinitelCharAttr
 *
 * DESCRIPTION:
 *	Modifies the current character attribute.  Does not affect field
 *	attributes.
 *
 *	mrw - 11/1/94: Went to high intensity colors to more closely match
 *	the minitel colors.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void emuMinitelCharAttr(const HHEMU hhEmu)
	{
	STATTR stAttr = hhEmu->attrState[CS_STATE];
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	switch (hhEmu->emu_code)
		{
	case ETEXT('\x40'):	 stAttr.txtclr = 0;  break;
	case ETEXT('\x41'):	 stAttr.txtclr = 12; /*4*/	break;
	case ETEXT('\x42'):	 stAttr.txtclr = 10; /*2*/	break;
	case ETEXT('\x43'):	 stAttr.txtclr = 14; /*6*/	break;
	case ETEXT('\x44'):	 stAttr.txtclr = 9;  /*1*/	break;
	case ETEXT('\x45'):	 stAttr.txtclr = 13; /*5*/	break;
	case ETEXT('\x46'):	 stAttr.txtclr = 11; /*3*/	break;
	case ETEXT('\x47'):	 stAttr.txtclr = 15; break;

	case ETEXT('\x48'):	 stAttr.blink  = 1;  break;
	case ETEXT('\x49'):	 stAttr.blink  = 0;  break;

	case ETEXT('\x4C'):			// normal size
		if (pstPRI->minitelG1Active)
			return;

		stAttr.dblhilo = 0;
		stAttr.dblwilf = 0;
		break;

	case ETEXT('\x4D'):			// double height
		if (pstPRI->minitelG1Active || hhEmu->emu_currow <= 1)
			return;

		stAttr.dblhilo= 1;
		stAttr.dblwilf = 0;
		break;

	case ETEXT('\x4E'):			// double width
		if (pstPRI->minitelG1Active || hhEmu->emu_currow < 1)
			return;

		stAttr.dblhilo = 0;
		stAttr.dblwilf	= 1;
		break;

	case ETEXT('\x4F'):			// double size
		if (pstPRI->minitelG1Active || hhEmu->emu_currow <= 1)
			return;

		stAttr.dblhilo = 1;
		stAttr.dblwilf	= 1;
		break;

	case ETEXT(ETEXT('\x5C')):    // normal polarity
		if (pstPRI->minitelG1Active)
			return;

		stAttr.revvid = 0;
		break;

	case ETEXT(ETEXT('\x5D')):    // reverse polarity
		if (pstPRI->minitelG1Active)
			return;

		stAttr.revvid = 1;
		break;

	default:
		break;
		}

	/* --- commit changes --- */

	hhEmu->emu_charattr =
	hhEmu->attrState[CS_STATE] =
	hhEmu->attrState[CSCLEAR_STATE] = stAttr;

	hhEmu->attrState[CSCLEAR_STATE].revvid = 0;
	hhEmu->attrState[CSCLEAR_STATE].undrln = 0;

	hhEmu->emu_clearattr = hhEmu->attrState[CSCLEAR_STATE];
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuMinitelFieldAttr
 *
 * DESCRIPTION:
 *	Dreaded field attributes.  Actually, this routine updates what is
 *	called a Latent Attribute.	The attributes only become effective
 *	when a space is recieved.  Who invents this stupid stuff anyways?
 *
 *	mrw - 11/1/94: Went to high intensity colors to more closely match
 *	the minitel colors.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void emuMinitelFieldAttr(const HHEMU hhEmu)
	{
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;
	LATENTATTR * const pstLA = &pstPRI->stLatentAttr;

	switch (hhEmu->emu_code)
		{
	case ETEXT('\x50'):	 pstLA->bkclr = 0;	 break;
	case ETEXT('\x51'):	 pstLA->bkclr = 12;  break;
	case ETEXT('\x52'):	 pstLA->bkclr = 10;  break;
	case ETEXT('\x53'):	 pstLA->bkclr = 14;  break;
	case ETEXT('\x54'):	 pstLA->bkclr = 9;	 break;
	case ETEXT('\x55'):	 pstLA->bkclr = 13;  break;
	case ETEXT('\x56'):	 pstLA->bkclr = 11;  break;
	case ETEXT('\x57'):	 pstLA->bkclr = 15;  break;

	case ETEXT('\x58'):	 pstLA->conceal=1;	 break;
	case ETEXT('\x5F'):	 pstLA->conceal=0;	 break;

	case ETEXT('\x59'):	// separated mosaics off
		if (pstPRI->minitelG1Active)
			{
			pstPRI->minitelUseSeparatedMosaics = 0;
			return;
			}

		else
			{
			pstPRI->stLatentAttr.undrln = 0;
			}
		break;

	case ETEXT('\x5A'):	// separated mosaics on
		if (pstPRI->minitelG1Active)
			{
			pstPRI->minitelUseSeparatedMosaics = 1;
			return;
			}

		else
			{
			pstPRI->stLatentAttr.undrln = 1;
			}
		break;

	default:	
	    return;
		}

	// Undocumented: setting any field attribute invalidates the
	// latent color context.
	//
	pstPRI->stLatentAttr.fBkClr = TRUE;

	pstPRI->stLatentAttr.fModified = TRUE;
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * minitel_kbdin
 *
 * DESCRIPTION:
 *	 Processes keys for the minitel emulator.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *	key 	- key to process
 *
 * RETURNS:
 *	 nothing
 */
static int minitel_kbdin(const HHEMU hhEmu, int key, const int fTest)
	{
	int index;
	TCHAR c;
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	if ((index = emuKbdKeyLookup(hhEmu, key, &hhEmu->stEmuKeyTbl)) != -1)
		{
		if (!fTest)
			{
			emuSendKeyString(hhEmu, index, &hhEmu->stEmuKeyTbl);

			// This completes the code sent by emuSendKeyString(), page 124
			//
			if (key == (VK_RIGHT | VIRTUAL_KEY | SHIFT_KEY) ||
				key == (VK_RIGHT | VIRTUAL_KEY | SHIFT_KEY | EXTENDED_KEY))
				{
				c = (pstPRI->minitelSecondDep) ? TEXT('\x6c') : TEXT('\x68');

				CLoopCharOut(sessQueryCLoopHdl(hhEmu->hSession), c);
				}

			// Check for disconnect key.  If hit twice consecutively,
			// it posts a disconnect to the modem guy.
			//
			if (key == (VK_F9 | VIRTUAL_KEY))
				{
				pstPRI->F9 += 1;


				if (pstPRI->F9 == 2)
					{
					PostMessage(sessQueryHwnd(hhEmu->hSession),
						WM_DISCONNECT, 0, 0);
                    pstPRI->F9 = 0;
					}
				}
			}
		}

	else
		{
		// reset F9 counter, must have two consecutive to disconnect
		//
		pstPRI->F9 = 0;
		index = std_kbdin(hhEmu, key, fTest);
		}

	return index;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelCharSet
 *
 * DESCRIPTION:
 *	We don't really switch character sets here.  Since minitel uses
 *	7 bit ASCII, we can user the half of the ASCII table for the
 *	contigous and seperated mosaics that comprise the G1 char set.
 *	Other rule here is that switching the the G1 character set
 *	validates the background color on reception of the first mosaic.
 *	One thing I haven't figured out yet is when a field attribute is
 *	validated, does the latent attribute get reset or retain the last color?
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void minitelCharSet(const HHEMU hhEmu)
	{
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	pstPRI->stLatentAttr.undrln = 0;

	if (hhEmu->emu_code == ETEXT(0x0E)) // switch to G1
		{
		pstPRI->minitelG1Active = TRUE;
		pstPRI->minitelUseSeparatedMosaics = FALSE;
		}

	else
		{
		pstPRI->minitelG1Active = FALSE;
		}

	// underline, size and polarity attributes permanently canceled.
	//
	hhEmu->emu_charattr.undrln = 0;
	hhEmu->emu_charattr.dblhihi = 0;
	hhEmu->emu_charattr.dblhilo = 0;
	hhEmu->emu_charattr.dblwilf = 0;
	hhEmu->emu_charattr.dblwirt = 0;
	hhEmu->emu_charattr.revvid = 0;
	hhEmu->emu_charattr.symbol = 0;

	hhEmu->attrState[CS_STATE] =
		hhEmu->attrState[CSCLEAR_STATE] = hhEmu->emu_charattr;

	hhEmu->emu_clearattr = hhEmu->emu_charattr;

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelResetTerminal
 *
 * DESCRIPTION:
 *	Response to a 1B 39 7F sequence.  Puts terminal in power-up state.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void minitelResetTerminal(const HHEMU hhEmu)
	{
	minitelClearScreen(hhEmu, 0);  // clear screen
	(*hhEmu->emu_setcurpos)(hhEmu, 0, 0);

	minitelClearLine(hhEmu, 0);    // clear line 0
	(*hhEmu->emu_setcurpos)(hhEmu, 1, 0);

	minitelReset(hhEmu);		 // reset attributes

	((PSTMTPRIVATE)hhEmu->pvPrivate)->fScrollMode = 0;
	EmuStdSetCursorType(hhEmu, EMU_CURSOR_NONE);
	minitelNtfy(hhEmu, 0);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelCursorOn
 *
 * DESCRIPTION:
 *	Turns minitel cursor on.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void minitelCursorOn(const HHEMU hhEmu)
	{
	EmuStdSetCursorType(hhEmu, EMU_CURSOR_BLOCK);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelCursorOff
 *
 * DESCRIPTION:
 *	Turns minitel cursor off
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void minitelCursorOff(const HHEMU hhEmu)
	{
	#if defined(NDEBUG)
	EmuStdSetCursorType(hhEmu, EMU_CURSOR_NONE);
	#else
	EmuStdSetCursorType(hhEmu, EMU_CURSOR_BLOCK);
	#endif

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	mintelMapMosaics
 *
 * DESCRIPTION:
 *	Maps regular character to a mosaic char for our font only.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *	ch	- character to convert
 *
 * RETURNS:
 *	converted or original character.
 *
 */
static ECHAR minitelMapMosaics(const HHEMU hhEmu, ECHAR ch)
	{
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	if (ch >= ETEXT('\x21') && ch <= ETEXT('\x3F'))
		ch += ETEXT('\x1F');

	// Another weird undocumented affect.  Columns 4 and 5 (except 5F)
	// map to columns 6 and 7 (page 101)
    //
	else if (ch >= ETEXT('\x40') && ch <= ETEXT('\x5E'))
		ch += ETEXT('\x20');

	else if (ch >= ETEXT('\x60') && ch <= ETEXT('\x7E'))
		ch += 0;

	if (pstPRI->minitelUseSeparatedMosaics && ch >= ETEXT('\x21') &&
		ch <= ETEXT('\x7F'))
		{
		ch += ETEXT('\x40');
		}

	return ch;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelCursorReport
 *
 * DESCRIPTION:
 *	Return the current cursor location as US row col.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void minitelCursorReport(const HHEMU hhEmu)
	{
	TCHAR ach[40];
	ECHAR aech[40];

	wsprintf(ach, TEXT("US%c%c"), hhEmu->emu_currow, hhEmu->emu_curcol);

	CnvrtMBCStoECHAR(aech, sizeof(aech), ach,
        StrCharGetByteCount(ach) + sizeof(TCHAR));

	emuSendString(hhEmu, aech, StrCharGetEcharByteCount(aech));
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelFullScrnConceal
 *
 * DESCRIPTION:
 *	Just sets the blank bits on all the attributes.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
static void minitelFullScrnConceal(const HHEMU hhEmu)
	{
	int i, j;
	PSTATTR ap;

	for (i = 1 ; i <= hhEmu->emu_maxrow ; ++i)
		{
		ap = hhEmu->emu_apAttr[row_index(hhEmu, i)];

		for (j = 0 ; j <= hhEmu->emu_maxcol ; ++j, ++ap)
			ap->blank = 1;

		updateLine(sessQueryUpdateHdl(hhEmu->hSession),
										1, hhEmu->emu_maxrow);
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelFullScrnReveal
 *
 * DESCRIPTION:
 *	Just sets the blank bits on all the attributes.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
static void minitelFullScrnReveal(const HHEMU hhEmu)
	{
	int i, j;
	PSTATTR ap;

	for (i = 1 ; i <= hhEmu->emu_maxrow ; ++i)
		{
		ap = hhEmu->emu_apAttr[row_index(hhEmu, i)];

		for (j = 0 ; j <= hhEmu->emu_maxcol ; ++j, ++ap)
			ap->blank = 0;
		}

	updateLine(sessQueryUpdateHdl(hhEmu->hSession), 1, hhEmu->emu_maxrow);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelResync
 *
 * DESCRIPTION:
 *	Certain codes will cause the emulator to resynchronize, (goto state
 *	zero) and play the character thru.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void minitelResync(const HHEMU hhEmu)
	{
	hhEmu->state = 0;
#if defined(EXTENDED_FEATURES)
	(void)(*hhEmu->emu_datain)(hhEmu, hhEmu->emu_code);
#else
	(void)(*hhEmu->emu_datain)((HEMU)hhEmu, hhEmu->emu_code);
#endif
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelSS2
 *
 * DESCRIPTION:
 *	SS2 is an alternate character set.	It only has about 15 symbols so
 *	we just map them here to ones in our current minitel font.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
static void minitelSS2(const HHEMU hhEmu)
	{
	const int row = hhEmu->emu_currow;
	const int col = hhEmu->emu_curcol;
	BOOL  fNoAdvance = FALSE;
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	/* --- SS2 codes are ignored in semigraphic mode --- */

	if (pstPRI->minitelG1Active)
		{
		hhEmu->state = 0;
		return;
		}

	/* --- Map the character --- */

	switch (hhEmu->emu_code)
		{
	case ETEXT('\x23'):	hhEmu->emu_code = ETEXT('\xA3');  break; // british pound
	case ETEXT('\x24'):	hhEmu->emu_code = ETEXT('\x24');  break; // Dollar sign
	case ETEXT('\x26'):	hhEmu->emu_code = ETEXT('\x23');  break; // pound sign
	case ETEXT('\x27'):	hhEmu->emu_code = ETEXT('\xA7');  break; // integral
	case ETEXT('\x2C'):	hhEmu->emu_code = ETEXT('\xC3');  break; // left arrow
	case ETEXT('\x2D'):	hhEmu->emu_code = ETEXT('\xC0');  break; // up arrow
	case ETEXT('\x2E'):	hhEmu->emu_code = ETEXT('\xC4');  break; // right arrow
	case ETEXT('\x2F'):	hhEmu->emu_code = ETEXT('\xC5');  break; // down arrow
	case ETEXT('\x30'):	hhEmu->emu_code = ETEXT('\xB0');  break; // degree
	case ETEXT('\x31'):	hhEmu->emu_code = ETEXT('\xB1');  break; // plus-minus
	case ETEXT('\x38'):	hhEmu->emu_code = ETEXT('\xF7');  break; // divide
	case ETEXT('\x3C'):	hhEmu->emu_code = ETEXT('\xBC');  break; // 1/4
	case ETEXT('\x3D'):	hhEmu->emu_code = ETEXT('\xBD');  break; // 1/2
	case ETEXT('\x3E'):	hhEmu->emu_code = ETEXT('\xBE');  break; // 3/4
	case ETEXT('\x41'):	hhEmu->emu_code = ETEXT('\x60');  fNoAdvance = TRUE;  break;
	case ETEXT('\x42'):	hhEmu->emu_code = ETEXT('\xB4');  fNoAdvance = TRUE;  break;
	case ETEXT('\x43'):	hhEmu->emu_code = ETEXT('\x5E');  fNoAdvance = TRUE;  break;
	case ETEXT('\x48'):	hhEmu->emu_code = ETEXT('\xA8');  fNoAdvance = TRUE;  break;
	case ETEXT('\x4A'): hhEmu->emu_code = ETEXT('\xB8');  fNoAdvance = TRUE;  break;
	case ETEXT('\x4B'): hhEmu->emu_code = ETEXT('\xB8');  fNoAdvance = TRUE;  break;
	case ETEXT('\x6A'):	hhEmu->emu_code = ETEXT('\x8C');  break;
	case ETEXT('\x7A'):	hhEmu->emu_code = ETEXT('\x9C');  break;
	case ETEXT('\x7B'):	hhEmu->emu_code = ETEXT('\xDF');  break;
	default: hhEmu->emu_code = ETEXT('\x5F');			 break;
		}

	minitelGraphic(hhEmu);

	if (fNoAdvance)
		{
		(*hhEmu->emu_setcurpos)(hhEmu, row, col); // don't advance cursor
		}

	else
		{
		// If we don't advance the cursor, we're done with this SS2
		// sequence and reset the state to 0 - mrw, 2/3/95
		//
		hhEmu->state = 0;
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelSS2Part2
 *
 * DESCRIPTION:
 *	The second half a an SS2 code is the vowel portion for the accents
 *	page 90.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
static void minitelSS2Part2(const HHEMU hhEmu)
	{
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	switch (hhEmu->emu_code)
		{
	case ETEXT('a'):
		switch (pstPRI->minitel_last_char)
			{
		case ETEXT('\x60'):	hhEmu->emu_code = ETEXT('\xE0');    break;
		case ETEXT('\x5E'):	hhEmu->emu_code = ETEXT('\xE2');    break;
		case ETEXT('\xA8'):	hhEmu->emu_code = ETEXT('\xE4');    break;
		default: break;
			}
		break;

	case ETEXT('e'):
		switch (pstPRI->minitel_last_char)
			{
		case ETEXT('\x60'):	hhEmu->emu_code = ETEXT('\xE8');    break;
		case ETEXT('\xB4'):	hhEmu->emu_code = ETEXT('\xE9');    break;
		case ETEXT('\x5E'):	hhEmu->emu_code = ETEXT('\xEA');    break;
		case ETEXT('\xA8'):	hhEmu->emu_code = ETEXT('\xEB');    break;
		default: break;
			}
		break;

	case ETEXT('i'):
		switch (pstPRI->minitel_last_char)
			{
		case ETEXT('\x5E'):	hhEmu->emu_code = ETEXT('\xEE');    break;
		case ETEXT('\xA8'):	hhEmu->emu_code = ETEXT('\xEF');    break;
		default: break;
			}
		break;

	case ETEXT('o'):
		switch (pstPRI->minitel_last_char)
			{
		case ETEXT('\x5E'):	hhEmu->emu_code = ETEXT('\xF4');    break;
		case ETEXT('\xA8'):	hhEmu->emu_code = ETEXT('\xF6');    break;
		default: break;
			}
		break;

	case ETEXT('u'):
		switch (pstPRI->minitel_last_char)
			{
		case ETEXT('\x60'):	hhEmu->emu_code = ETEXT('\xF9');    break;
		case ETEXT('\x5E'):	hhEmu->emu_code = ETEXT('\xFB');    break;
		case ETEXT('\xA8'):	hhEmu->emu_code = ETEXT('\xFC');    break;
		default: break;
			}
		break;

	case ETEXT('c'):
		switch (pstPRI->minitel_last_char)
			{
		case ETEXT('\xB8'): hhEmu->emu_code = ETEXT('\xE7');	break;
		default: break;
			}
		break;

	default:
		// Docs say if we're not one of the above chars, then overwrite
		// position with current char.
		break;
		}

	minitelGraphic(hhEmu);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelInsMode
 *
 * DESCRIPTION:
 *	Sets or Resets the insert mode depending on received code.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
static void minitelInsMode(const HHEMU hhEmu)
	{
	hhEmu->mode_IRM = (hhEmu->emu_code == ETEXT('\x68')) ? SET : RESET;
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelNtfy
 *
 * DESCRIPTION:
 *	Paints an inverted F or C when connection/disconnection notifications
 *	come in.
 *
 * ARGUMENTS:
 *	hhEmuPass	- change this to hhEmu when reentrancy done.
 *	nNtfyCode	- why it was called, (we don't use)
 *
 * RETURNS:
 *	void
 *
 */
void minitelNtfy(const HHEMU hhEmu, const int nNtfyCode)
	{
	const int r = row_index(hhEmu, 0);
	const int c = hhEmu->emu_maxcol - 1;
	ECHAR chr;
	BOOL  fFlash = FALSE;

	switch (cnctQueryStatus(sessQueryCnctHdl(hhEmu->hSession)))
		{
	case CNCT_STATUS_FALSE:
	default:
		chr = ETEXT('F');
		break;

	case CNCT_STATUS_TRUE:
		chr = ETEXT('C');
		break;

	case CNCT_STATUS_CONNECTING:
		chr = ETEXT('C');
		fFlash = TRUE;
		break;
		}

	hhEmu->emu_apText[r][c] = chr;
	hhEmu->emu_apAttr[r][c].revvid = 1;
	hhEmu->emu_apAttr[r][c].blink = (unsigned)fFlash;
	hhEmu->emu_apAttr[r][c].symbol = 0; // mrw-5/5/95

	hhEmu->emu_aiEnd[r] = c;

	updateChar(sessQueryUpdateHdl(hhEmu->hSession), 0, c, c);
	NotifyClient(hhEmu->hSession, EVENT_TERM_UPDATE, 0);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelPRO1
 *
 * DESCRIPTION:
 *	Handles PRO1 sequences (ESC,39,X).
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle
 *
 * RETURNS:
 *	void
 *
 */
static void minitelPRO1(const HHEMU hhEmu)
	{
	ECHAR aechBuf[35];
	static const TCHAR achID[] = TEXT("\x01\x43r0\x04");

	switch (hhEmu->emu_code)
		{
	case ETEXT('\x7B'): // ENQROM (page 139)
		// See pages 21 & 22.  Basicly we send back an indentification
		// sequence delimited by SOH and EOT
		//
		CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), achID,
            StrCharGetByteCount(achID));

		CLoopSend(sessQueryCLoopHdl(hhEmu->hSession), aechBuf, 5, 0);
		break;

	case ETEXT('\x67'): // Disconnect (page 139)
		PostMessage(sessQueryHwnd(hhEmu->hSession), WM_DISCONNECT, 0, 0);
		break;

	case ETEXT('\x72'):
		minitelStatusReply(hhEmu);
		break;

	default:
		break;
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelPRO2Part1
 *
 * DESCRIPTION:
 *	Handles first half of a PRO2 sequence.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
static void minitelPRO2Part1(const HHEMU hhEmu)
	{
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	pstPRI->minitel_PRO1 = hhEmu->emu_code;
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelPRO2Part2
 *
 * DESCRIPTION:
 *	Handles the second half of a PRO2 sequence.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle
 *
 * RETURNS:
 *	void
 *
 */
static void minitelPRO2Part2(const HHEMU hhEmu)
	{
	int fUpperCase;
	BYTE abKey[256];
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	switch (hhEmu->emu_code)
		{
	case ETEXT('\x43'):	  // scrolling
		if (pstPRI->minitel_PRO1 == ETEXT('\x69'))
			pstPRI->fScrollMode = TRUE;

		if (pstPRI->minitel_PRO1 == ETEXT('\x6A'))
			pstPRI->fScrollMode = FALSE;

		minitelStatusReply(hhEmu);
		break;

	case ETEXT('\x44'):	  // error correction procedure (not implemented)
		break;

	case ETEXT('\x45'):	  // keyboard upper/lower case
		if (pstPRI->minitel_PRO1 == ETEXT('\x69'))
			fUpperCase = FALSE;

		else if (pstPRI->minitel_PRO1 == ETEXT('\x6A'))
			fUpperCase = TRUE;

		else
			break;

		GetKeyboardState(abKey);

		if (fUpperCase)
			abKey[VK_CAPITAL] |= 0x01;

		else
			abKey[VK_CAPITAL] &= 0xfe;


		SetKeyboardState(abKey);

		minitelStatusReply(hhEmu);
		break;

	default:
		return;
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelStatusReply
 *
 * DESCRIPTION:
 *	Acknowledgement sequence for some PRO2 sequences and status requests.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 * AUTHOR: Mike Ward, 08-May-1995
 */
static void minitelStatusReply(const HHEMU hhEmu)
	{
	ECHAR ach[10];
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	// The PRO2 sequences \x43 and \x45 all return and acknowledgement
	// of the form PRO2,\x73,status byte.  The format of the status byte
	// is defined in page 143, section 11.2.
	//
	// strcpy(ach, "\x1b\x3A\x73");
	CnvrtMBCStoECHAR(ach, sizeof(ach), TEXT("\x1b\x3A\x73"),
					 StrCharGetByteCount(TEXT("\x1b\x3A\x73")));

	ach[3] = ETEXT('\x40');  // bit 7 is always 1.
	ach[3] |= pstPRI->fScrollMode ? ETEXT('\x02') : ETEXT('\x00');
	ach[3] |=(GetKeyState(VK_CAPITAL) > 0) ? ETEXT('\x00') : ETEXT('\x08');
	ach[4] = ETEXT('\0');
	CLoopSend(sessQueryCLoopHdl(hhEmu->hSession), ach, 4, 0);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuMinitelSendKey
 *
 * DESCRIPTION:
 *	Used by the toolbar to emit the correct minitel sequence for the
 *	specified button.
 *
 * ARGUMENTS:
 *	hEmu	- public emulator handle.
 *	iCmd	- command string to send.
 *
 * RETURNS:
 *	void
 *
 * AUTHOR: Mike Ward, 10-Mar-1995
 */
void emuMinitelSendKey(const HEMU hEmu, const int iCmd)
	{
	TCHAR *pach;
	ECHAR aechBuf[20];
	const HHEMU hhEmu = (HHEMU)hEmu;
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;
    HCNCT hCnct = NULL;
    BOOL  bSendKey = TRUE;

	switch (iCmd)
		{
	case IDM_MINITEL_INDEX: 	pach = TEXT("\x13") TEXT("F");	   break;
	case IDM_MINITEL_CANCEL:	pach = TEXT("\x13") TEXT("E");	   break;
	case IDM_MINITEL_PREVIOUS:	pach = TEXT("\x13") TEXT("B");	   break;
	case IDM_MINITEL_REPEAT:	pach = TEXT("\x13") TEXT("C");	   break;
	case IDM_MINITEL_GUIDE: 	pach = TEXT("\x13") TEXT("D");	   break;
	case IDM_MINITEL_CORRECT:	pach = TEXT("\x13") TEXT("G");	   break;
	case IDM_MINITEL_NEXT:		pach = TEXT("\x13") TEXT("H");	   break;
	case IDM_MINITEL_SEND:		pach = TEXT("\x13") TEXT("A");	   break;
	case IDM_MINITEL_CONFIN:
		pach = TEXT("\x13") TEXT("I");
		pstPRI->F9 += 1;

		if (pstPRI->F9 == 2)
            {
			PostMessage(sessQueryHwnd(hhEmu->hSession), WM_DISCONNECT, 0, 0);
            pstPRI->F9 = 0;
            bSendKey = FALSE;
            }

		break;

	default:
		assert(0);
		return;
		}

    //
    // Attempt to make a connection if we are currently disconnected, and
    // we are supposed to initiate a connection.
    //
    hCnct = sessQueryCnctHdl(hhEmu->hSession);

	if (bSendKey == FALSE || !hCnct)
        {
        bSendKey = FALSE;
        }
    else
        {
        int iRet = cnctQueryStatus(hCnct);
        
        if (pstPRI->F9 == 1 && iCmd == IDM_MINITEL_CONFIN &&
            iRet != CNCT_STATUS_TRUE && iRet != CNCT_STATUS_CONNECTING)
            {
            if (SendMessageTimeout(sessQueryHwnd(hhEmu->hSession), WM_COMMAND,
                                  IDM_ACTIONS_DIAL, 0,
                                  SMTO_ABORTIFHUNG, 1000, NULL) == 0)
                {
                DWORD dwSendKey = GetLastError();
                bSendKey = FALSE;
                }
            else
                {
                hCnct = sessQueryCnctHdl(hhEmu->hSession);

	            if (!hCnct)
                    {
                    bSendKey = FALSE;
                    }
                else
                    {
                    int iRet = cnctQueryStatus(hCnct);
                
                    if (iRet != CNCT_STATUS_TRUE)
                        {
                        bSendKey = FALSE;
                        }
                    }
                }
            }
        else if (iRet != CNCT_STATUS_TRUE)
            {
            bSendKey = FALSE;
            }
        }

    if (bSendKey == TRUE)
        {
	    CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), pach,
		    StrCharGetByteCount(pach) + sizeof(TCHAR));

	    emuSendString((HHEMU)hEmu, aechBuf, StrCharGetEcharByteCount(aechBuf));
        }

	return;
	}											

#ifdef INCL_TERMINAL_SIZE_AND_COLORS
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  emuMinitelSetScrSize
 *
 * DESCRIPTION:
 *  Replaces std_setscrsize which was added to allow user settable screen
 *	sizes. However, the Minitel doesn't allow this.
 *
 * ARGUMENTS:
 *  hhEmu - The internal emulator handle.
 *
 * RETURNS:
 *  void
 *
 * AUTHOR:	Bob Everett - 1 Sep 1998
 */
void emuMinitelSetScrSize(const HHEMU hhEmu)
    {
    }
#endif

#endif // INCL_MINITEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\vid.hh ===
/*	File: D:\WACKER\emu\vid.hh (Created: 09-Dec-1993)
 *
 *	Copyright 1993 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:29p $
 */

/* This file is no longer used! --jcm */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\emu_std.c ===
/*	File: D:\WACKER\emu\emu_std.c (Created: 08-Dec-1993)
 *
 *	Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 2/02/01 4:02p $
 */
#include <windows.h>
#pragma hdrstop

// #define DEBUGSTR

#include <tdll\stdtyp.h>
#include <tdll\tdll.h>
#include <tdll\assert.h>
#include <tdll\chars.h>
#include <tdll\cloop.h>
#include <tdll\mc.h>
#include <tdll\session.h>
#include <tdll\backscrl.h>
#include <tdll\com.h>
#include <tdll\capture.h>
#include <tdll\print.h>
#include <tdll\update.h>
#include <tdll\htchar.h>
#include <xfer\xfer.h>

#include "emu.h"
#include "emu.hh"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	stdResetTerminal
 *
 * DESCRIPTION:
 *	Had to add a vector for reset terminal.  Reset functions appear to be
 *	in most emulators but not all and were never assigned a function
 *	pointer.  I've done this and have made a standard "stub" function
 *	for those emulators that don't have such a function.
 *
 * ARGUMENTS:
 *	BOOL
 *
 * RETURNS:
 *	0
 *
 */
/* ARGSUSED */
int stdResetTerminal(const HHEMU hhEmu, const int fHost)
	{
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *  hhEmu - Private emulator handle.
 *  kcode - The key to examine.
 *  fTest - TRUE if we only want to test the key.
 *
 * RETURNS:
 *  0 if we can process the key, -1 otherwise.
 *
 */
int std_kbdin(const HHEMU hhEmu, int kcode, const int fTest)
	{
	static const int KeyBreak    = VK_CANCEL|VIRTUAL_KEY|CTRL_KEY;
	static const int KeyExtBreak = VK_CANCEL|VIRTUAL_KEY|CTRL_KEY|EXTENDED_KEY;
	static const int KeyBreakNT	 = VK_CANCEL|EXTENDED_KEY;
	static const int KeyAltBreak = VK_PAUSE |VIRTUAL_KEY|ALT_KEY;

	ECHAR            eChar;
    HCLOOP           hCloop = sessQueryCLoopHdl(hhEmu->hSession);

    if (fTest)
        {
        // The backspace key is a special case. We must convert it to
        // whatever the user has specified in the "Settings" properties
        // page. So, if we are testing for backspace, return 0. This
        // ensures that we get called again with fTest set to FALSE. When
        // this happens we will process the key. - cab:11/18/96
        //
        if (kcode == VK_BACKSPACE)
            {
#ifdef INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID
            return 0;
#else
            return -1;
#endif
            }
        // We also process the break key.
        //
        else if (kcode == KeyBreak || kcode == KeyExtBreak || 
				kcode == KeyAltBreak || kcode == KeyBreakNT)
            {
            return 0;
            }
        else
            {
            return -1;
            }
        }

    // Process the backspace key according to the user setting
    // in the "Settings" properties page. - cab:11/18/96
    //
    if (kcode == VK_BACKSPACE)
        {
#ifdef INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID
		switch(hhEmu->stUserSettings.nBackspaceKeys)
			{
		case EMU_BKSPKEYS_CTRLH:
            CLoopCharOut(hCloop, TEXT('\x08'));
			break;

		case EMU_BKSPKEYS_DEL:
            CLoopCharOut(hCloop, TEXT('\x7F'));
			break;

		case EMU_BKSPKEYS_CTRLHSPACE:
            CLoopCharOut(hCloop, TEXT('\x08'));
            CLoopCharOut(hCloop, TEXT('\x20'));
            CLoopCharOut(hCloop, TEXT('\x08'));
			break;

		default:
			assert(0);
			break;
			}
#endif
		return -1;
        }
    // Process the break key.
    //
    else if (kcode == KeyBreak || kcode == KeyExtBreak || kcode == KeyBreakNT)
        {
		ComDriverSpecial(sessQueryComHdl(hhEmu->hSession), "Send Break", 0, 0);
		return -1;
		}
	else if (kcode == KeyAltBreak)
		{
		ComDriverSpecial(sessQueryComHdl(hhEmu->hSession), "Send IP", 0, 0);
		return -1;
        }
    //
    // Processing for the enter key
    //

    else if (kcode == (VK_RETURN | VIRTUAL_KEY))
        {
        CLoopCharOut(hCloop, TEXT('\x0D'));
        return (-1);
        }

    //
    // processing for the for the escape key
    //

    else if (kcode == (VK_ESCAPE | VIRTUAL_KEY))
        {
        CLoopCharOut(hCloop, TEXT('\x1B'));
        return (-1);
        }

    //
    // processing for the for the tab key
    //

    else if (kcode == (VK_TAB | VIRTUAL_KEY))
        {
        CLoopCharOut(hCloop, TEXT('\x09'));
        return (-1);
        }

    // Throw away any other virtual keys.
    //
	else if (kcode & VIRTUAL_KEY)
		{
		return -1;
		}

    // Send any other characters out the port.
    //    
	eChar = (ECHAR)kcode;
	CLoopCharOut(hCloop, (UCHAR)(eChar & 0x00FF));
	return -1;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * std_getscrollcnt
 *
 * DESCRIPTION: Tells caller how many lines the screen has scrolled since
 *				the last request.
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
int std_getscrollcnt(const HHEMU hhEmu)
	{
	const int retval = hhEmu->scr_scrollcnt;

	hhEmu->scr_scrollcnt = 0;

	return(retval);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void std_getscrsize(const HHEMU hhEmu, int *rows, int *cols)
	{
	*rows = hhEmu->emu_maxrow + 1;
	*cols = hhEmu->emu_maxcol + 1;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void std_getcurpos(const HHEMU hhEmu, int *row, int *col)
	{
	*row = hhEmu->emu_currow;
	*col = hhEmu->emu_curcol;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * std_setcurpos
 *
 * DESCRIPTION:
 *	 Moves the cursor to the specified position on the virtual screen.
 *	 If the cursor is beyond the end of existing text, the virtual screen
 *	 line is filled out with spaces. If the cursor is beyond the edges of
 *	 the video display, the video cursor is placed as close as possible
 *	 to the desired position as the cursor display is changed.
 *
 * ARGUMENTS:
 *	 iRow -- virtual screen row to move cursor to
 *	 iCol -- virtual screen col to move cursor to
 *
 * RETURNS:
 *	 nothing
 */
void std_setcurpos(const HHEMU hhEmu, const int iRow, const int iCol)
	{
	hhEmu->emu_currow = max(min(iRow, hhEmu->emu_maxrow), 0);
	hhEmu->emu_curcol = max(min(iCol, hhEmu->emu_maxcol), 0);

	updateCursorPos(sessQueryUpdateHdl(hhEmu->hSession),
					hhEmu->emu_currow,
					hhEmu->emu_curcol);

	hhEmu->emu_imgrow = row_index(hhEmu, hhEmu->emu_currow);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
STATTR std_getattr(const HHEMU hhEmu)
	{
	return hhEmu->attrState[CS_STATE];
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void std_setattr(const HHEMU hhEmu, PSTATTR pstAttr)
	{
	assert(pstAttr);

	hhEmu->attrState[CS_STATE] = *pstAttr;
	hhEmu->attrState[CSCLEAR_STATE] = *pstAttr;

	hhEmu->emu_charattr = *pstAttr;
	hhEmu->emu_clearattr = *pstAttr;

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void std_setcolors(const HHEMU hhEmu, const int fore, const int back)
	{
	hhEmu->attrState[CSCLEAR_STATE].txtclr = (unsigned)fore;
	hhEmu->attrState[CSCLEAR_STATE].bkclr  = (unsigned)back;
	hhEmu->emu_clearattr = hhEmu->attrState[CSCLEAR_STATE];
	hhEmu->emu_clearattr_sav = hhEmu->emu_clearattr;

	hhEmu->attrState[CS_STATE].txtclr = (unsigned)fore;
	hhEmu->attrState[CS_STATE].bkclr  = (unsigned)back;

	if (hhEmu->iCurAttrState == CS_STATE)
		hhEmu->emu_charattr = hhEmu->attrState[CS_STATE];

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void std_getcolors(const HHEMU hhEmu, int *fore, int *back)
	{
	*fore = hhEmu->attrState[hhEmu->iCurAttrState].txtclr;
	*back = hhEmu->attrState[hhEmu->iCurAttrState].bkclr;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * std_initcolors
 *
 * DESCRIPTION:	Sets the entire attr image to the current colors
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void std_initcolors(const HHEMU hhEmu)
	{
	register int row, col;

	for (row = 0; row < MAX_EMUROWS; row++)
		for (col = 0 ; col <= MAX_EMUCOLS ; ++col)
			{
			hhEmu->emu_apAttr[row][col].txtclr = hhEmu->emu_clearattr.txtclr;
			hhEmu->emu_apAttr[row][col].bkclr = hhEmu->emu_clearattr.bkclr;
			}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void std_restorescreen(const HHEMU hhEmu)
	{
	updateLine(sessQueryUpdateHdl(hhEmu->hSession), 0, hhEmu->emu_maxrow);
	hhEmu->iCurAttrState = CS_STATE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * std_clearscreen
 *
 * DESCRIPTION:
 *	 Erases some or all of the virtual screen image.
 *
 * ARGUMENTS:
 *	 select -- 0 to erase from cursor to end of screen
 *			-- 1 to erase from start of screen to cursor
 *			-- 2 to erase entire screen
 *
 * RETURNS:
 *	 nothing
 */
void std_clearscreen(const HHEMU hhEmu, const int nClearSelect)
	{
	register int r;
	int trow, tcol;
	PSTATTR pstAttr;
	ECHAR aechBuf[10];
	BOOL fSave;

	trow = hhEmu->emu_currow;
	tcol = hhEmu->emu_curcol;

	switch (nClearSelect)
		{
	/* cursor to end of screen */
	case 0:
		fSave = (hhEmu->emu_currow == 0  &&
					hhEmu->emu_curcol == 0) ? TRUE : FALSE;

		for (r = hhEmu->emu_currow + (fSave ? 0 : 1) ; r < MAX_EMUROWS; ++r)
			{
			if (fSave)
				{
				backscrlAdd(sessQueryBackscrlHdl(hhEmu->hSession),
							hhEmu->emu_apText[row_index(hhEmu, r)],
							hhEmu->emu_maxcol+1);

				CaptureLine(sessQueryCaptureFileHdl(hhEmu->hSession),
									CF_CAP_SCREENS,
									hhEmu->emu_apText[row_index(hhEmu, r)],
									emuRowLen(hhEmu, row_index(hhEmu, r)));

				printEchoScreen(hhEmu->hPrintEcho,
									hhEmu->emu_apText[row_index(hhEmu, r)],
									emuRowLen(hhEmu, row_index(hhEmu, r)));

				CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), TEXT("\r\n"), StrCharGetByteCount(TEXT("\r\n")));
				printEchoScreen(hhEmu->hPrintEcho,
									aechBuf,
									sizeof(ECHAR) * 2);
				}

			clear_imgrow(hhEmu, r);
			}

		// Clear the partial row now.
		//
		ECHAR_Fill(hhEmu->emu_apText[row_index(hhEmu, hhEmu->emu_currow)] +
						hhEmu->emu_curcol,
						EMU_BLANK_CHAR,
						(size_t)(MAX_EMUCOLS - hhEmu->emu_curcol + 1));

		if (hhEmu->emu_curcol <= hhEmu->emu_aiEnd[hhEmu->emu_imgrow])
			hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = hhEmu->emu_curcol - 1;

		pstAttr = hhEmu->emu_apAttr[row_index(hhEmu, hhEmu->emu_currow)];

		for (r = hhEmu->emu_curcol ; r <= MAX_EMUCOLS ; ++r)
			pstAttr[r] = hhEmu->emu_clearattr;

		// Tell the video image what to do.  Use the emuDispRgnScrollUp() call
		// instead of RgnClear so edges of terminal get painted if
		// clear attribute changes.

		updateScroll(sessQueryUpdateHdl(hhEmu->hSession),
						0,
						hhEmu->emu_maxrow,
						hhEmu->emu_maxrow + 1,
						hhEmu->emu_imgtop,
						TRUE);

		(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, hhEmu->emu_curcol);

		// Added a global to save the clear attribute at the time of
		// notification.  This is necessary since the message is posted
		// and a race condition can develop.

		hhEmu->emu_clearattr_sav = hhEmu->emu_clearattr;

		NotifyClient(hhEmu->hSession, EVENT_EMU_CLRATTR, 0);
		break;


	/* start of screen to cursor */

	case 1:
		for (r = 0; r < hhEmu->emu_currow; ++r)
			clear_imgrow(hhEmu, r);

		ECHAR_Fill(hhEmu->emu_apText[row_index(hhEmu, hhEmu->emu_currow)],
					EMU_BLANK_CHAR,
			  		(size_t)(hhEmu->emu_curcol + 1));

		if (hhEmu->emu_curcol >= hhEmu->emu_aiEnd[hhEmu->emu_imgrow])
			hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = EMU_BLANK_LINE;

		pstAttr = hhEmu->emu_apAttr[row_index(hhEmu, hhEmu->emu_currow)];

		for (r = 0 ; r <= hhEmu->emu_curcol ; ++r)
			pstAttr[r] = hhEmu->emu_clearattr;

		(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, hhEmu->emu_curcol);

		updateLine(sessQueryUpdateHdl(hhEmu->hSession), 0, hhEmu->emu_currow);
		break;

	/* Entire screen */
	case 2:
		for (r = 0; r < MAX_EMUROWS; ++r)
			{
			backscrlAdd(sessQueryBackscrlHdl(hhEmu->hSession),
							hhEmu->emu_apText[row_index(hhEmu, r)],
							hhEmu->emu_maxcol+1);

			CaptureLine(sessQueryCaptureFileHdl(hhEmu->hSession),
							CF_CAP_SCREENS,
							hhEmu->emu_apText[row_index(hhEmu, r)],
							emuRowLen(hhEmu, row_index(hhEmu, r)));

			printEchoScreen(hhEmu->hPrintEcho,
							hhEmu->emu_apText[row_index(hhEmu, r)],
							emuRowLen(hhEmu, row_index(hhEmu, r)));

			CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), TEXT("\r\n"), StrCharGetByteCount(TEXT("\r\n")));
			printEchoScreen(hhEmu->hPrintEcho,
							aechBuf,
							sizeof(ECHAR) * 2);

			clear_imgrow(hhEmu, r);
			}

		updateScroll(sessQueryUpdateHdl(hhEmu->hSession),
						0,
						hhEmu->emu_maxrow,
						hhEmu->emu_maxrow + 1,
						hhEmu->emu_imgtop,
						TRUE);


		// Save the clear attribute at the time of
		// notification.  This is necessary since the message is posted
		// and a race condition can develop.

		hhEmu->emu_clearattr_sav = hhEmu->emu_clearattr;

		NotifyClient(hhEmu->hSession, EVENT_EMU_CLRATTR, 0);
		break;

	default:
		commanderror(hhEmu);
		}

	(*hhEmu->emu_setcurpos)(hhEmu, trow, tcol);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * std_clearline
 *
 * DESCRIPTION:
 *	 Erases some or all of the current virtual screen line and corresponding
 *	 real screen line.
 *
 * ARGUMENTS:
 *	 select -- 0 to erase from cursor to end of line
 *			-- 1 to erase from start of line to cursor
 *			-- 2 to erase entire line
 *
 * RETURNS:
 *	 nothing
 */
void std_clearline(const HHEMU hhEmu, const int nClearSelect)
	{
	register int i;
	PSTATTR pstAttr;

	switch (nClearSelect)
		{

	/* to end of line */
	case 0:
		if (hhEmu->emu_curcol == 0)
			{
			backscrlAdd(sessQueryBackscrlHdl(hhEmu->hSession),
				hhEmu->emu_apText[row_index(hhEmu, hhEmu->emu_currow)],
				hhEmu->emu_maxcol+1);
			}

		updateLine(sessQueryUpdateHdl(hhEmu->hSession),
						hhEmu->emu_currow,
						hhEmu->emu_currow);


		ECHAR_Fill(hhEmu->emu_apText[row_index(hhEmu, hhEmu->emu_currow)] +
					hhEmu->emu_curcol,
					EMU_BLANK_CHAR,
					(size_t)(hhEmu->emu_maxcol - hhEmu->emu_curcol + 1));

		if (hhEmu->emu_curcol <= hhEmu->emu_aiEnd[hhEmu->emu_imgrow])
			hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = hhEmu->emu_curcol - 1;

		pstAttr = hhEmu->emu_apAttr[row_index(hhEmu, hhEmu->emu_currow)];

		for (i = hhEmu->emu_curcol ; i <= hhEmu->emu_maxcol ; ++i)
			pstAttr[i] = hhEmu->emu_clearattr;

		break;

	/* from start of line to cursor */
	case 1:
		updateLine(sessQueryUpdateHdl(hhEmu->hSession),
						hhEmu->emu_currow,
						hhEmu->emu_currow);


		ECHAR_Fill(hhEmu->emu_apText[row_index(hhEmu, hhEmu->emu_currow)],
					EMU_BLANK_CHAR,
					(size_t)(hhEmu->emu_curcol+1));

		if (hhEmu->emu_curcol < hhEmu->emu_aiEnd[hhEmu->emu_imgrow])
			hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = hhEmu->emu_curcol + 1;
		else if (hhEmu->emu_curcol == hhEmu->emu_aiEnd[hhEmu->emu_imgrow])
			hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = EMU_BLANK_LINE;

		pstAttr = hhEmu->emu_apAttr[row_index(hhEmu, hhEmu->emu_currow)];

		for (i = 0 ; i <= hhEmu->emu_curcol ; ++i)
			pstAttr[i] = hhEmu->emu_clearattr;

		break;

	/* Entire line */
	case 2:
		backscrlAdd(sessQueryBackscrlHdl(hhEmu->hSession),
			hhEmu->emu_apText[row_index(hhEmu, hhEmu->emu_currow)],
			hhEmu->emu_maxcol + 1);

		updateLine(sessQueryUpdateHdl(hhEmu->hSession),
						hhEmu->emu_currow,
						hhEmu->emu_currow);

		clear_imgrow(hhEmu, hhEmu->emu_currow);
		break;

	default:
		commanderror(hhEmu);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * std_clearrgn
 *
 * DESCRIPTION:
 *	 Erases a region of the current virtual screen and corresponding
 *	 real screen region.
 *
 * ARGUMENTS:
 *	toprow -- top row of region
 *	leftcol -- column of region's left edge
 *	botmrow -- bottom row of region
 *	rightcol -- column of region's right edge
 *
 * RETURNS:
 *	 nothing
 */
void std_clearrgn(const HHEMU hhEmu,
					int toprow,
					int leftcol,
					int botmrow,
					int rightcol)
	{
	int irow, num, idx;
	PSTATTR pstAttr;

	/* make sure region is within the screen */
	toprow = max(toprow, 0);
	leftcol = max(leftcol, 0);
	botmrow = min(botmrow, hhEmu->emu_maxrow);
	rightcol = min(rightcol, hhEmu->emu_maxcol);

	updateLine(sessQueryUpdateHdl(hhEmu->hSession),
						toprow,
						botmrow);

	num = (rightcol - leftcol) + 1;

	/* copy image to memory */
	for (irow = toprow; irow <= botmrow; irow++)
		{
		ECHAR_Fill(hhEmu->emu_apText[row_index(hhEmu, irow)]+leftcol,
						EMU_BLANK_CHAR,
						(size_t)num);

		// If the current end of line position is within the range
		// being cleared, we need to find the last character in the
		// row array working backwards from position leftcol - 1;
		//
		if (hhEmu->emu_aiEnd[row_index(hhEmu, irow)] >= leftcol &&
				hhEmu->emu_aiEnd[row_index(hhEmu, irow)] <= rightcol)
			{
			idx = min(0, leftcol - 1);
			while (idx >= 0)
				{
				if (*hhEmu->emu_apText[row_index(hhEmu, irow)] + idx != EMU_BLANK_CHAR)
					break;
				idx --;
				}

			hhEmu->emu_aiEnd[row_index(hhEmu, irow)] = idx;
			}


		pstAttr = hhEmu->emu_apAttr[row_index(hhEmu, irow)]+leftcol;

		for (pstAttr = hhEmu->emu_apAttr[row_index(hhEmu, irow)]+leftcol;
				num > 0 ; --num)
			*pstAttr++ = hhEmu->emu_clearattr;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * std_deinstall
 *
 * DESCRIPTION:
 *	 Uninstalls current emulator by freeing used memory.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
/* ARGSUSED */
void std_deinstall(const HHEMU hhEmu)
	{
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * std_scroll
 *
 * DESCRIPTION:
 *	 Scrolls the screen or portions of the screen.
 *
 * ARGUMENTS:
 *	 nlines -- number of lines to scroll
 *	 direction -- TRUE if scroll is up
 *
 * RETURNS:
 *	 nothing
 */
void std_scroll(const HHEMU hhEmu, const int nlines, const BOOL direction)
	{
	if (direction)
		scrollup(hhEmu, nlines);
	else
		scrolldown(hhEmu, nlines);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	EmuStdSetCursorType
 *
 * DESCRIPTION:
 *	Sets the cursor type.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void EmuStdSetCursorType(const HHEMU hhEmu, int iCurType)
	{
	hhEmu->iCurType = iCurType;
	NotifyClient(hhEmu->hSession, EVENT_EMU_SETTINGS, 0);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuChkChar
 *
 * DESCRIPTION: Called from all of the emulators when codes to process are
 *				outside of the displayable range. If the code translates
 *				to a character in the displayable range, the emulator's
 *				display function is called with the translated character.
 *
 * ARGUMENTS:	none
 *
 * RETURNS: 	nothing
 */
/* ARGSUSED */
void EmuChkChar(const HHEMU hhEmu)
	{
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuStdChkZmdm
 *
 * DESCRIPTION: Called when the current emulator picks up rz/r. Starts
 *				receiving with Zmodem.
 *
 * ARGUMENTS:	none
 *
 * RETURNS: 	nothing
 *
 * GOOD FOR:	nothing
 */
void EmuStdChkZmdm(const HHEMU hhEmu)
	{
	ECHAR old_emu_code;

	switch(hhEmu->iZmodemState++)
		{
	case 0:
		// Got the Ctrl-X
		// DbgOutStr("ZMDM - case 0\r\n", 0, 0, 0, 0, 0);
		DbgOutStr("ZMDM - case 0\r\n", 0, 0, 0, 0, 0);
		break;

	case 1:
		// Got the B?

		//DbgOutStr("ZMDM - case 1(0x%x)(%c)\r\n", emu_code, emu_code, 0, 0, 0);

		if (hhEmu->emu_code != ETEXT('B'))
			{
			hhEmu->state = 0;
			old_emu_code = hhEmu->emu_code;

			if ((hhEmu->stUserSettings.nEmuId == EMU_ANSI) ||
				(hhEmu->stUserSettings.nEmuId == EMU_ANSIW))
				{
				hhEmu->emu_code = CAN;
				(*hhEmu->emu_graphic)(hhEmu);
				}

			hhEmu->emu_code = old_emu_code;
#if defined(EXTENDED_FEATURES)
			(void)(*hhEmu->emu_datain)(hhEmu, old_emu_code);
#else
			(void)(*hhEmu->emu_datain)((HEMU)hhEmu, old_emu_code);
#endif
			hhEmu->iZmodemState = 0;
			}

		break;

	case 2:
		// Got a 0?

		//DbgOutStr("ZMDM - case 2(0x%x)(%c)\r\n", emu_code, emu_code, 0, 0, 0);

		if (hhEmu->emu_code != ETEXT('0'))
			{
			hhEmu->state = 0;
			old_emu_code = hhEmu->emu_code;

			if ((hhEmu->stUserSettings.nEmuId == EMU_ANSI) ||
				(hhEmu->stUserSettings.nEmuId == EMU_ANSIW))
				{
				hhEmu->emu_code = CAN;
				(*hhEmu->emu_graphic)(hhEmu);
				}
			hhEmu->emu_code = ETEXT('B');
			(*hhEmu->emu_graphic)(hhEmu);
			hhEmu->emu_code = old_emu_code;
#if defined(EXTENDED_FEATURES)
            (void)(*hhEmu->emu_datain)(hhEmu, old_emu_code);
#else
            (void)(*hhEmu->emu_datain)((HEMU)hhEmu, old_emu_code);
#endif
			hhEmu->iZmodemState = 0;
			}

		break;

	case 3:
		// Got a 0?

		//DbgOutStr("ZMDM - case 3(0x%x)(%c)\r\n", emu_code, emu_code, 0, 0, 0);

		if (hhEmu->emu_code == ETEXT('0'))
			{
			emuComDone((HEMU)hhEmu);

			NotifyClient(hhEmu->hSession,
						EVENT_HOST_XFER_REQ,
						XF_ZMODEM);
			}
		else
			{
			old_emu_code = hhEmu->emu_code;
			//TODO Put in a better way to display these codes.
			if ((hhEmu->stUserSettings.nEmuId == EMU_ANSI) ||
				(hhEmu->stUserSettings.nEmuId == EMU_ANSIW))
				{
				hhEmu->emu_code = CAN;
				(*hhEmu->emu_graphic)(hhEmu);
				}
			hhEmu->emu_code = ETEXT('B');
			(*hhEmu->emu_graphic)(hhEmu);
			hhEmu->emu_code = ETEXT('0');
			(*hhEmu->emu_graphic)(hhEmu);
			hhEmu->emu_code = old_emu_code;
#if defined(EXTENDED_FEATURES)
            (void)(*hhEmu->emu_datain)(hhEmu, old_emu_code);
#else
            (void)(*hhEmu->emu_datain)((HEMU)hhEmu, old_emu_code);
#endif
			}

		hhEmu->state = 0;
		hhEmu->iZmodemState = 0;
		break;

	default:
		// DbgOutStr("ZMDM - default\r\n", 0, 0, 0, 0, 0);
		hhEmu->state = 0;
		hhEmu->iZmodemState = 0;
		break;
		}
	}

void std_dsptbl(const HHEMU hhEmu, int bit8)
	{
	register INT x;

	for (x = 0; x < 128; ++x)
		hhEmu->dspchar[x] = (UCHAR)x;
	if (bit8)
		for (x = 128; x < 256; ++x)
			hhEmu->dspchar[x] = (UCHAR)x;
	else
		for (x = 128; x < 256; ++x)
			hhEmu->dspchar[x] = (UCHAR)(x - 128);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	std_emu_ntfy
 *
 * DESCRIPTION:
 *	Function called when session notified of a connection.	Place holder
 *	for function pointer.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle
 *
 * RETURNS:
 *	void
 *
 */
/* ARGSUSED */
void std_emu_ntfy(const HHEMU hhEmu, const int nNtfy)
	{
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuHomeHostCursor
 *
 * DESCRIPTION:
 *	Most terminal's home position is 0,0.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	0=OK, else error
 *
 */
int std_HomeHostCursor(const HHEMU hhEmu)
	{
	if (hhEmu == 0)
		{
		assert(0);
		return -1;
		}

	(*hhEmu->emu_setcurpos)(hhEmu, 0, 0);
	return 0;
	}

#ifdef INCL_TERMINAL_SIZE_AND_COLORS
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  std_setscrsize
 *
 * DESCRIPTION:
 *  This function is called from emuSetSettings.  It sets up the emulator
 *  to use the number of rows and columns defined un the user settings
 *  structure of the emulator handle.
 *
 * ARGUMENTS:
 *  hhEmu - The internal emulator handle.
 *
 * RETURNS:
 *  void
 *
 * AUTHOR: Bob Kundrat, 19-Feb-1996
 */
void std_setscrsize(const HHEMU hhEmu)
    {
    register int r, c;
    int iClearRow;
	PSTATTR pstAttr = 0;

    const int iOldRows = hhEmu->emu_maxrow + 1;
    const int iOldCols = hhEmu->emu_maxcol + 1;

    int iRows = hhEmu->stUserSettings.nUserDefRows;
    int iCols = hhEmu->stUserSettings.nUserDefCols;

    // Don't do anything if the values have not changed.
    //
    if (iRows == iOldRows && iCols == iOldCols)
        return;

    // Range check the requested screen size.  A minimum of 2 is
    // used to avoid a divide by zero error in row_index().
    //
    iRows = min(MAX_EMUROWS, iRows);
    iRows = max(iRows, MIN_EMUROWS);

    iCols = min(MAX_EMUCOLS, iCols);
    iCols = max(iCols, MIN_EMUCOLS);

    // Adjust global values to accomodate screen size change.  Remember,
    // most of the globals are zero based.
    //
    hhEmu->emu_maxrow = iRows - 1;
    hhEmu->emu_maxcol = iCols - 1;
    hhEmu->bottom_margin = hhEmu->emu_maxrow;

    // In the case of changing from a larger screen to a smaller one,
    // the cursor may have been at a location that isn't on the new
    // size.  Put it as close as possible on the new screen.
    //
    hhEmu->emu_currow = min(hhEmu->emu_currow, hhEmu->emu_maxrow);
    hhEmu->emu_curcol = min(hhEmu->emu_curcol, hhEmu->emu_maxcol);

    (*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, hhEmu->emu_curcol);

    // If the screen size got smaller, we need to clear the cells out
    // of the part of the buffer that is no longer being used.
    //
    if ((iOldRows - 1) > hhEmu->emu_maxrow)
        {
        for (r = hhEmu->emu_maxrow + 1; r < MAX_EMUROWS; ++r)
            {
            iClearRow = row_index(hhEmu, r);

            pstAttr = hhEmu->emu_apAttr[iClearRow];

            for (c = 0; c < MAX_EMUCOLS; c++)
                pstAttr[c] = hhEmu->emu_clearattr;
            }
        }

    if ((iOldCols - 1) > hhEmu->emu_maxcol)
        {
        for (r = 0; r < MAX_EMUROWS; ++r)
            {
            pstAttr = hhEmu->emu_apAttr[r];

            for (c = hhEmu->emu_maxcol + 1; c < MAX_EMUCOLS ; ++c)
                pstAttr[c] = hhEmu->emu_clearattr;
            }
        }

	// Telnet has a negotiated option to let the server know whenever the
	// terminal size changes. In case it has been enabled, we must let
	// the com driver know about this change.
	ComDriverSpecial(sessQueryComHdl(hhEmu->hSession), "Update Terminal Size", 0, 0);

    return;
    }
#endif

/* end of emu_std.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\vid2.c ===
/*	File: D:\WACKER\emu\vid2.c (Created: 08-Dec-1993)
 *
 *	Copyright 1993 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:28p $
 */

/* This file is no longer used! --jcm */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\minitelf.c ===
/*	File: D:\WACKER\emu\minitelf.c (Created: 12-Apr-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:28p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\tdll.h>
#include <tdll\session.h>
#include <tdll\print.h>
#include <tdll\capture.h>
#include <tdll\assert.h>
#include <tdll\mc.h>
#include <tdll\update.h>

#include "emu.h"
#include "emu.hh"
#include "emuid.h"
#include "minitel.hh"

static void minitel_clear_imgrow(const HHEMU hhEmu, const int row);

#if defined(INCL_MINITEL)
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelLinefeed
 *
 * DESCRIPTION:
 *	Linefeeds work differently in minitel.	In page mode we wrap to line
 *	one (not zero) when at the bottom.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void minitelLinefeed(const HHEMU hhEmu)
	{
	const PSTMTPRIVATE pstPRI = hhEmu->pvPrivate;
	const ECHAR *tp = hhEmu->emu_apText[hhEmu->emu_imgrow];
	const PSTATTR ap = hhEmu->emu_apAttr[hhEmu->emu_imgrow];

	printEchoString(hhEmu->hPrintEcho, (ECHAR *)tp,
		emuRowLen(hhEmu, hhEmu->emu_currow)); // mrw,3/1/95

	// see page 97, bottom of page
	//
	if (hhEmu->emu_currow == 0)
		{
		hhEmu->emu_charattr = pstPRI->minitel_saved_attr;

		(*hhEmu->emu_setcurpos)(hhEmu, pstPRI->minitel_saved_row,
			pstPRI->minitel_saved_col);

		pstPRI->minitelG1Active = pstPRI->minitel_saved_minitelG1Active;
		pstPRI->stLatentAttr = pstPRI->saved_stLatentAttr;

		pstPRI->minitelUseSeparatedMosaics =
			pstPRI->saved_minitelUseSeparatedMosaics;
		}

	else if (hhEmu->emu_currow == hhEmu->bottom_margin)
		{
		if (pstPRI->fScrollMode)
			minitel_scrollup(hhEmu, 1);

		else
			(*hhEmu->emu_setcurpos)(hhEmu, 1, hhEmu->emu_curcol);
		}

	else
		{
		(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow + 1,
			hhEmu->emu_curcol);
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelBackspace
 *
 * DESCRIPTION:
 *	Backspaces are goofy.  They wrap to the previous line.	In scroll mode
 *	they cause scrolling if in line 1
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelBackspace(const HHEMU hhEmu)
	{
	const PSTMTPRIVATE pstPRI = hhEmu->pvPrivate;

	if (hhEmu->emu_curcol > 0)
		{
		(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow,
			hhEmu->emu_curcol-1);
		}

	else if (hhEmu->emu_currow == 1)
		{
		if (pstPRI->fScrollMode)
			{
			minitel_scrolldown(hhEmu, (hhEmu->emu_charattr.dblhilo) ? 2 : 1);
			}

		else
			{
			(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_maxrow,
				hhEmu->emu_maxcol);
			}
		}

	else
		{
		(*hhEmu->emu_setcurpos)(hhEmu,	hhEmu->emu_currow-1,
			hhEmu->emu_maxcol);
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelVerticalTab
 *
 * DESCRIPTION:
 *	Vertical tabs work differently.  They move the cursor up and wrap or
 *	scroll depending on the mode.
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelVerticalTab(const HHEMU hhEmu)
	{
	const PSTMTPRIVATE pstPRI = hhEmu->pvPrivate;

	// VT sequence not available in row 0
	//
	if (hhEmu->emu_currow == 0)
		return;

	if (hhEmu->emu_currow == 1)
		{
		if (pstPRI->fScrollMode)
			{
			minitel_scrolldown(hhEmu, (hhEmu->emu_charattr.dblhilo) ? 2 : 1);
			}

		else
			{
			(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_maxrow,
				hhEmu->emu_curcol);
			}
		}

	else
		{
		(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow-1,
			hhEmu->emu_curcol);
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelCursorUp
 *
 * DESCRIPTION:
 *	Moves cursor up n rows but not into row 00
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelCursorUp(const HHEMU hhEmu)
	{
	int nlines, row;

	// CSI sequences not available in row 0
	//
	if (hhEmu->emu_currow == 0)
		return;

	nlines = hhEmu->num_param[hhEmu->num_param_cnt];

	if (nlines < 1)
		nlines = 1;

	row = hhEmu->emu_currow;
	row -= nlines;

	if (row < 1)
		row = 1;

	(*hhEmu->emu_setcurpos)(hhEmu, row, hhEmu->emu_curcol);

	ANSI_Pn_Clr(hhEmu);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelCursorDirect
 *
 * DESCRIPTION:
 *	Moves cursor to specified coordinates but not row 00
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelCursorDirect(const HHEMU hhEmu)
	{
	int row, col;

	// CSI functions not available in row 0
	//
	if (hhEmu->emu_currow == 0)
		return;

	row = hhEmu->num_param[0];
	col = hhEmu->num_param_cnt > 0 ? hhEmu->num_param[1] : 0;

	if (row < 1)
		row = 1;

	if (col < 1)
		col = 1;

	if (row > hhEmu->emu_maxrow + 1)
		row = hhEmu->emu_maxrow + 1;

	if (col > hhEmu->emu_maxcol + 1)
		col = hhEmu->emu_maxcol + 1;

	// Again, can't go to row 00 with this call.

	(*hhEmu->emu_setcurpos)(hhEmu, row, col - 1);

	ANSI_Pn_Clr(hhEmu);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelFormFeed
 *
 * DESCRIPTION:
 *	Clears rows 1 thru 24 leaving row 00 alone.
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelFormFeed(const HHEMU hhEmu)
	{
	(*hhEmu->emu_setcurpos)(hhEmu, 1, 0);
	minitelClearScreen(hhEmu, 0);
	minitelReset(hhEmu);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelClearScreen
 *
 * DESCRIPTION:
 *	Works similar to the standard function but also has to clear the
 *	latent attribute and all serial attributes.
 *
 * ARGUMENTS:
 *	int iHow	- dirction to clear screen.
 *
 * RETURNS:
 *	void
 *
 */
void minitelClearScreen(const HHEMU hhEmu, const int iHow)
	{
	#define BLACK_MOSAIC ETEXT('\xff')
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	int  i;
	int  r;
	PSTMINITEL pstMT;
	STMINITEL stMT;
	ECHAR *pText;
	PSTATTR pstAttr;
	STATTR	stAttr;

	// CSI sequences not available in row 0
	//
	if (hhEmu->emu_currow == 0)
		return;

	memset(&stMT, 0, sizeof(stMT));
    stMT.ismosaic = 1;

	memset(&stAttr, 0, sizeof(stAttr));
	stAttr.txtclr = VC_BRT_WHITE;
	stAttr.bkclr = VC_BLACK;

	switch (iHow)
		{
	case 0: 	// cursor to end of screen inclusive
	default:
		pstMT = pstPRI->apstMT[hhEmu->emu_imgrow];
		pText = hhEmu->emu_apText[hhEmu->emu_imgrow];
		pstAttr = hhEmu->emu_apAttr[hhEmu->emu_imgrow];

		for (i = hhEmu->emu_curcol ; i < MAX_EMUCOLS ; ++i)
			{
			*pstMT++ = stMT;
			*pText++ = BLACK_MOSAIC;
			*pstAttr++ = stAttr;
			}

		for (r = hhEmu->emu_currow+1 ; r < MAX_EMUROWS ; ++r)
			{
			i = row_index(hhEmu, r);
			pstMT = pstPRI->apstMT[i];
			pText = hhEmu->emu_apText[i];
			pstAttr = hhEmu->emu_apAttr[i];

			for (i = 0 ; i < MAX_EMUCOLS ; ++i)
				{
				*pstMT++ = stMT;
				*pText++ = BLACK_MOSAIC;
				*pstAttr++ = stAttr;
				}
			}

		updateLine(sessQueryUpdateHdl(hhEmu->hSession), hhEmu->emu_currow,
										hhEmu->emu_maxrow);

		hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = hhEmu->emu_curcol;
		break;

	case 1: 	// beginning of screen to cursor inclusive
		for (r = 1 ; r < hhEmu->emu_currow ; ++r)
			{
			i = row_index(hhEmu, r);
			pstMT = pstPRI->apstMT[i];
			pText = hhEmu->emu_apText[i];
			pstAttr = hhEmu->emu_apAttr[i];

			for (i = 0 ; i < MAX_EMUCOLS ; ++i)
				{
				*pstMT++ = stMT;
				*pText++ = BLACK_MOSAIC;
				*pstAttr++ = stAttr;
				}
			}

		pstMT = pstPRI->apstMT[hhEmu->emu_imgrow];
		pText = hhEmu->emu_apText[hhEmu->emu_imgrow];
		pstAttr = hhEmu->emu_apAttr[hhEmu->emu_imgrow];

		for (i = 0 ; i <= hhEmu->emu_curcol ; ++i)
			{
			*pstMT++ = stMT;
			*pText++ = BLACK_MOSAIC;
			*pstAttr++ = stAttr;
			}

		updateLine(sessQueryUpdateHdl(hhEmu->hSession),
					0, hhEmu->emu_currow);

		hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = hhEmu->emu_curcol + 1;
		break;

	case 2: 	// entire screen (cursor position not changed)
		for (r = 1 ; r < MAX_EMUROWS ; ++r)
			{
			i = row_index(hhEmu, r);
			pstMT = pstPRI->apstMT[i];
			pText = hhEmu->emu_apText[i];
			pstAttr = hhEmu->emu_apAttr[i];

			hhEmu->emu_aiEnd[r] = EMU_BLANK_LINE;

			for (i = 0 ; i < MAX_EMUCOLS ; ++i)
				{
				*pstMT++ = stMT;
				*pText++ = BLACK_MOSAIC;
				*pstAttr++ = stAttr;
				}
			}

		updateLine(sessQueryUpdateHdl(hhEmu->hSession),
									0, hhEmu->emu_maxrow);
		break;
		}

	minitelRecordSeparator(hhEmu);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelClrScrn
 *
 * DESCRIPTION:
 *	Front end for minitelClearScreen() that reads the PSN argument,
 *	converts it, and passes it to minitelClearScreen.  Called from
 *	the state tables.
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelClrScrn(const HHEMU hhEmu)
	{
	minitelClearScreen(hhEmu, hhEmu->selector[0]);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelRecordSepartor
 *
 * DESCRIPTION:
 *	Record Separtor has special duties in Minitel.	In general it homes
 *	the cursor and returns the emulator to what's called an SI condition.
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelRecordSeparator(const HHEMU hhEmu)
	{
	(*hhEmu->emu_setcurpos)(hhEmu, 1, 0);
	minitelReset(hhEmu);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelClearLine
 *
 * DESCRIPTION:
 *	Handles the various clear line functions like cursor to end, beg to
 *	cursor, etc.
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelClearLine(const HHEMU hhEmu, const int iHow)
	{
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	int i;
	ECHAR *pText = hhEmu->emu_apText[hhEmu->emu_imgrow];
	PSTMINITEL pstMT = pstPRI->apstMT[hhEmu->emu_imgrow];
	PSTATTR pstAttr = hhEmu->emu_apAttr[hhEmu->emu_imgrow];
	const HUPDATE hUpdate= sessQueryUpdateHdl(hhEmu->hSession);
	STMINITEL stMT;
	STATTR	stAttr;

	// CSI sequences not available in row 0
	//
	if (hhEmu->emu_currow == 0)
		return;

	memset(&stMT, 0, sizeof(stMT));
    stMT.ismosaic = 1;

	memset(&stAttr, 0, sizeof(stAttr));
	stAttr.txtclr = VC_BRT_WHITE;
	stAttr.bkclr = VC_BLACK;

	switch (iHow)
		{
	case 0: 	// cursor to end of line inclusive
	default:
		for (i = hhEmu->emu_curcol ; i < MAX_EMUCOLS ; ++i)
			{
			*pText++ = BLACK_MOSAIC;
			*pstMT++ = stMT;
			*pstAttr++ = stAttr;
			}

		hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = hhEmu->emu_curcol - 1;
		updateChar(hUpdate, hhEmu->emu_currow,
					hhEmu->emu_curcol, MAX_EMUCOLS);
		break;

	case 1: 	// beginning of line to cursor inclusive
		for (i = 0 ; i <= hhEmu->emu_curcol ; ++i)
			{
			*pText++ = BLACK_MOSAIC;
			*pstMT++ = stMT;
			*pstAttr++ = stAttr;
			}

		hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = hhEmu->emu_curcol + 1;
		updateChar(hUpdate, hhEmu->emu_currow, 0, hhEmu->emu_curcol);
		break;

	case 2: 	// entire line
		for (i = 0 ; i < MAX_EMUCOLS ; ++i)
			{
			*pText++ = BLACK_MOSAIC;
			*pstMT++ = stMT;
			*pstAttr++ = stAttr;
			}

		hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = EMU_BLANK_LINE;
		updateLine(hUpdate, hhEmu->emu_currow, hhEmu->emu_currow);
		break;
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelClrLn
 *
 * DESCRIPTION:
 *	Driver for minitelClearLine().
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelClrLn(const HHEMU hhEmu)
	{
	minitelClearLine(hhEmu, hhEmu->selector[0]);
	return;
	}

#if 0
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelDel
 *
 * DESCRIPTION:
 *	code 0x7F (Del) deletes the cursor location and moves the cursor
 *	one position right.
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelDel(const HHEMU hhEmu)
	{
	hhEmu->emu_apText[hhEmu->emu_imgrow][hhEmu->emu_curcol] = ETEXT('\x5F');
	hhEmu->emu_ap

	if (hhEmu->emu_aiEnd[hhEmu->emu_imgrow] == hhEmu->emu_curcol)
		hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = hhEmu->emu_curcol - 1;

	minitelHorzTab(hhEmu);
	return;
	}
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelHorzTab
 *
 * DESCRIPTION:
 *	minitel cursor has some special characteristics.  Minitel is always
 *	in wrap mode, so we wrap to begining of next row when beyond the
 *	last column.  Also, when at bottom, wrap to line 1.  Also, if in
 *	row 0, column 40, ignore.
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelHorzTab(const HHEMU hhEmu)
	{
	int row = hhEmu->emu_currow;
	int col = hhEmu->emu_curcol;

	if (col >= hhEmu->emu_maxcol)
		{
		if (hhEmu->emu_currow == 0)
			return;

		if (hhEmu->emu_currow >= hhEmu->emu_maxrow)
			row = 1;

		else
			row += 1;

		col = 0;
		}

	else
		{
		col += 1;
		}

	(*hhEmu->emu_setcurpos)(hhEmu, row, col);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelRepeat
 *
 * DESCRIPTION:
 *	Repeat code displays the last displayed character x number of
 *	times where x is the current emu_code coming in.
 *	I don't think wrapping is effective here.
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelRepeat(const HHEMU hhEmu)
	{
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	int x;

	// Already did range checking in state table to get here.
	// Repeat number is only the first six significant bits.

	x = max(0, hhEmu->emu_code-0x40);
	hhEmu->emu_code = pstPRI->minitel_last_char;

	while (x-- > 0)
		minitelGraphic(hhEmu);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelCancel
 *
 * DESCRIPTION:
 *	Fills current row from cursor position to end of row with spaces
 *	in the current character set current attributes.  Cursor doesn't move.
 *  Doco says this is not a delimiter.
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelCancel(const HHEMU hhEmu)
	{
	int i;
	int iMax;
	int fModified;
	const int row = hhEmu->emu_currow;
	const int col = hhEmu->emu_curcol;
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	hhEmu->emu_code = ETEXT('\x20');

	// Ah, the life of the undocumented.  The documentation says
	// that this guys does not validate, colors, act as a delimiter
	// and fills with spaces.  Wrong.  It does validate the color.
	// As such its a delimiter.  If the the current active char
	// set is G1, then it fills with mosaics, not spaces.
	//
	fModified = pstPRI->stLatentAttr.fModified;

	iMax = hhEmu->emu_maxcol;

	// minitelGraphic checks the InCancel flag and if TRUE suppresses
	// linewrap. mrw:5/3/95
	//
	pstPRI->fInCancel = TRUE;

	for (i = hhEmu->emu_curcol ; i <= iMax ; ++i)
		{
		minitelGraphic(hhEmu);
		}

	pstPRI->fInCancel = FALSE;

	// Ok, even though we validated the background color, we haven't
	// changed the state of the latent attribute (also undocumented).
	// So set it back to whatever is was before we entered this lovely
	// mess of a function - mrw
	//
	pstPRI->stLatentAttr.fModified = fModified;

	(*hhEmu->emu_setcurpos)(hhEmu, row, col);
	hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = hhEmu->emu_maxcol;
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelUSRow
 *
 * DESCRIPTION:
 *	Intermediate function that collects the row number
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelUSRow(const HHEMU hhEmu)
	{
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	pstPRI->us_row_code = hhEmu->emu_code;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelUSCol
 *
 * DESCRIPTION:
 *	Interestingly, columns are numbered from 1 to 40.  Unit seperators
 *  are ugly little beasts.  They indicate a row, col combo, but only
 *  if in a certain range.  Also, an obsolite sequence US,3/X,3/Y where
 *  0 < X < 3, 0 < Y < 9 and XY < 24 is not suppose to be used but 
 *  often is.
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelUSCol(const HHEMU hhEmu)
	{
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	int us_col_code = hhEmu->emu_code;
	int us_col = us_col_code - 0x41;
	int us_row = pstPRI->us_row_code - 0x40;

	if (us_row >= 0 && us_row <= hhEmu->emu_maxrow &&
		us_col >= 0 && us_col <= hhEmu->emu_maxcol)
		{
		if (us_row == 0)
			{
			// p.97, bottom of page
			//
			if (hhEmu->emu_currow != 0)
				{
				pstPRI->minitel_saved_attr = hhEmu->emu_charattr;
				pstPRI->minitel_saved_row = hhEmu->emu_currow;
				pstPRI->minitel_saved_col = hhEmu->emu_curcol;
				pstPRI->saved_stLatentAttr = pstPRI->stLatentAttr;

				pstPRI->minitel_saved_minitelG1Active =
					pstPRI->minitelG1Active;

				pstPRI->saved_minitelUseSeparatedMosaics =
					pstPRI->minitelUseSeparatedMosaics;
				}
			}

		(*hhEmu->emu_setcurpos)(hhEmu, us_row, us_col);
		minitelReset(hhEmu);
		}

	else if (pstPRI->us_row_code >= 0x30 &&
		pstPRI->us_row_code < 0x33 &&
		us_col_code >= 0x30 &&
		us_col_code <= 0x39)
		{
		us_row = ((pstPRI->us_row_code - 0x30) * 10) + (us_col_code - 0x30);

		if (us_row > 24)
			return;

		if (us_row == 0)
            {
			if (hhEmu->emu_currow != 0)
				{
				pstPRI->minitel_saved_attr = hhEmu->emu_charattr;
				pstPRI->minitel_saved_row = hhEmu->emu_currow;
				pstPRI->minitel_saved_col = hhEmu->emu_curcol;
				pstPRI->saved_stLatentAttr = pstPRI->stLatentAttr;

				pstPRI->minitel_saved_minitelG1Active =
					pstPRI->minitelG1Active;

				pstPRI->saved_minitelUseSeparatedMosaics =
					pstPRI->minitelUseSeparatedMosaics;
				}
            }

		(*hhEmu->emu_setcurpos)(hhEmu, us_row, 0);
		minitelReset(hhEmu);
        }

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelDelChars
 *
 * DESCRIPTION:
 *	Deletes n characters from cursor position inclusive.
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelDelChars(const HHEMU hhEmu)
	{
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;
	int i, n;
	ECHAR *tp = hhEmu->emu_apText[hhEmu->emu_imgrow]+hhEmu->emu_curcol;
	STATTR stAttr;
	PSTATTR ap = hhEmu->emu_apAttr[hhEmu->emu_imgrow]+hhEmu->emu_curcol;
	STMINITEL stMT;
	PSTMINITEL pstMT = pstPRI->apstMT[hhEmu->emu_imgrow];

	// CSI sequences not available in row 0
	//
	if (hhEmu->emu_currow == 0)
		return;

	n = min(hhEmu->emu_maxcol, hhEmu->num_param[0]);
	i = max(0, hhEmu->emu_maxcol - hhEmu->emu_curcol - n);

	/* --- Move characters down --- */

	memmove(tp, tp+n, (unsigned)i * sizeof(ECHAR));
	memmove(ap, ap+n, (unsigned)i * sizeof(STATTR));
	memmove(pstMT, pstMT+n, (unsigned)i * sizeof(STMINITEL));

	hhEmu->emu_aiEnd[hhEmu->emu_imgrow] =
		hhEmu->emu_aiEnd[hhEmu->emu_imgrow] - i;

	/* --- Fill remainder of line --- */

	tp += i;
	ap += i;

	memset(&stAttr, 0, sizeof(stAttr));
	stAttr.txtclr = VC_BRT_WHITE;
	stAttr.bkclr  = VC_BLACK;

	memset(&stMT, 0, sizeof(stMT));
	stMT.ismosaic = (unsigned)pstPRI->minitelG1Active;

	for (n = max(0, hhEmu->emu_maxcol - i) ; n > 0 ; --n)
		{
		*tp++ = EMU_BLANK_CHAR;
		*ap++ = stAttr;
		*pstMT++ = stMT;
		}

	updateChar(sessQueryUpdateHdl(hhEmu->hSession),
				hhEmu->emu_currow,
				hhEmu->emu_curcol,
				hhEmu->emu_maxcol);

	ANSI_Pn_Clr(hhEmu);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelInsChars
 *
 * DESCRIPTION:
 *	Inserts n characters from cursor position inclusive
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelInsChars(const HHEMU hhEmu)
	{
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;
	int i, n;
	ECHAR *tp = hhEmu->emu_apText[hhEmu->emu_imgrow]+hhEmu->emu_curcol;
	STATTR stAttr;
	PSTATTR ap = hhEmu->emu_apAttr[hhEmu->emu_imgrow]+hhEmu->emu_curcol;
	STMINITEL stMT;
	PSTMINITEL pstMT = pstPRI->apstMT[hhEmu->emu_imgrow];

	// CSI sequences not available in row 0
	//
	if (hhEmu->emu_currow == 0)
		return;

	n = min(hhEmu->emu_maxcol, hhEmu->num_param[0]);
	i = max(0, hhEmu->emu_maxcol - hhEmu->emu_curcol - n);

	/* --- Move stuff down --- */

	memmove(tp+n, tp, (unsigned)i * sizeof(ECHAR));
	memmove(ap+n, tp, (unsigned)i * sizeof(STATTR));
	memmove(pstMT+n, pstMT, (unsigned)i * sizeof(STMINITEL));

	hhEmu->emu_aiEnd[hhEmu->emu_imgrow] =
		hhEmu->emu_aiEnd[hhEmu->emu_imgrow] + i;

	/* --- Fill the gap --- */

	memset(&stAttr, 0, sizeof(stAttr));
	stAttr.txtclr = VC_BRT_WHITE;
	stAttr.bkclr  = VC_BLACK;

	memset(&stMT, 0, sizeof(stMT));
	stMT.ismosaic = (unsigned)pstPRI->minitelG1Active;

	while (--i >= 0)
		{
		*tp++ = EMU_BLANK_CHAR;
		*ap++ = stAttr;
		*pstMT++ = stMT;
		}

	updateChar(sessQueryUpdateHdl(hhEmu->hSession),
				hhEmu->emu_currow,
				hhEmu->emu_curcol,
				hhEmu->emu_maxcol);

	ANSI_Pn_Clr(hhEmu);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelDelRows
 *
 * DESCRIPTION:
 *	Deletes n rows from the current row.
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelDelRows(const HHEMU hhEmu)
	{
	int r, r1;
	int c, i, n;
	STATTR stAttr;
	STMINITEL stMT;
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	// CSI sequences not available in row 0
	//
	if (hhEmu->emu_currow == 0)
		return;

	n = min(hhEmu->emu_maxrow, hhEmu->num_param[0]);
	i = max(0, hhEmu->emu_maxrow - hhEmu->emu_currow - n);

	for (i = 0 ; i < n ; ++i)
		{
		if ((hhEmu->emu_currow+i+n) > hhEmu->emu_maxrow)
			break;

		r = row_index(hhEmu, hhEmu->emu_currow+i);
		r1 = row_index(hhEmu, hhEmu->emu_currow+i+n);

		MemCopy(hhEmu->emu_apText[r],
				hhEmu->emu_apText[r1],
				sizeof(ECHAR) * (unsigned)(hhEmu->emu_maxcol+1));

		MemCopy(hhEmu->emu_apAttr[r],
				hhEmu->emu_apAttr[r1],
				sizeof(STATTR) * (unsigned)(hhEmu->emu_maxcol+1));

		MemCopy(pstPRI->apstMT[r],
				pstPRI->apstMT[r1],
				sizeof(STMINITEL) * (unsigned)(hhEmu->emu_maxcol+1));

		hhEmu->emu_aiEnd[r] = hhEmu->emu_aiEnd[r1];
		}

	memset(&stAttr, 0, sizeof(stAttr));
	stAttr.txtclr = VC_BRT_WHITE;
	stAttr.bkclr  = VC_BLACK;

	memset(&stMT, 0, sizeof(stMT));
	stMT.ismosaic = (unsigned)pstPRI->minitelG1Active;

	for (n = max(0, hhEmu->emu_maxrow - i) ; n <= hhEmu->emu_maxrow ; ++n)
		{
		r = row_index(hhEmu, n);

		for (c = 0 ; c <= hhEmu->emu_maxcol ; ++c)
			{
			hhEmu->emu_apText[r][c] = EMU_BLANK_CHAR;
			hhEmu->emu_apAttr[r][c] = stAttr;
			pstPRI->apstMT[r][c] = stMT;
			hhEmu->emu_aiEnd[r] = EMU_BLANK_LINE;
			}
		}

	updateLine(sessQueryUpdateHdl(hhEmu->hSession),
				hhEmu->emu_currow,
				hhEmu->emu_maxrow);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelInsRows
 *
 * DESCRIPTION:
 *	Inserts n rows from current row inclusive
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelInsRows(const HHEMU hhEmu)
	{
	int r, r1;
	int c, i, n;
	STATTR stAttr;
	STMINITEL stMT;
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	if (hhEmu->emu_currow == 0)
		return;

	n = min(hhEmu->emu_maxrow, hhEmu->num_param[0]);
	i = max(0, hhEmu->emu_maxrow - hhEmu->emu_currow - n);

	for (i = 0 ; i < n ; ++i)
		{
		if ((hhEmu->emu_currow+i+n) > hhEmu->emu_maxrow)
			break;

		r = row_index(hhEmu, hhEmu->emu_currow+i);
		r1 = row_index(hhEmu, hhEmu->emu_currow+i+n);

		MemCopy(hhEmu->emu_apText[r1],
				hhEmu->emu_apText[r],
				sizeof(ECHAR) * (unsigned)(hhEmu->emu_maxcol+1));

		MemCopy(hhEmu->emu_apAttr[r1],
				hhEmu->emu_apAttr[r],
				sizeof(STATTR) * (unsigned)(hhEmu->emu_maxcol+1));

		MemCopy(pstPRI->apstMT[r1],
				pstPRI->apstMT[r],
				sizeof(STMINITEL) * (unsigned)(hhEmu->emu_maxcol+1));

		hhEmu->emu_aiEnd[r1] = hhEmu->emu_aiEnd[r];
		}

	memset(&stAttr, 0, sizeof(stAttr));
	stAttr.txtclr = VC_BRT_WHITE;
	stAttr.bkclr  = VC_BLACK;

	memset(&stMT, 0, sizeof(stMT));
	stMT.ismosaic = (unsigned)pstPRI->minitelG1Active;

	for (n = hhEmu->emu_currow ; n < (hhEmu->emu_maxrow - i) ; ++n)
		{
		r = row_index(hhEmu, n);

		for (c = 0 ; c <= hhEmu->emu_maxcol ; ++c)
			{
			hhEmu->emu_apText[r][c] = EMU_BLANK_CHAR;
			hhEmu->emu_apAttr[r][c] = stAttr;
			pstPRI->apstMT[r][c] = stMT;
			hhEmu->emu_aiEnd[r] = EMU_BLANK_LINE;
			}
		}

	updateLine(sessQueryUpdateHdl(hhEmu->hSession),
				hhEmu->emu_currow,
				hhEmu->emu_maxrow);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelHomeHostCursor
 *
 * DESCRIPTION:
 *	Sets cursor to home position which is 1, 0 in this case.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle
 *
 * RETURNS:
 *	0=OK,else error.
 *
 */
int minitelHomeHostCursor(const HHEMU hhEmu)
	{
	if (hhEmu == 0)
		{
		assert(0);
		return -1;
		}

	(*hhEmu->emu_setcurpos)(hhEmu, 1, 0);
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitel_scrollup
 *
 * DESCRIPTION:
 *	Mintels of course scroll differently.  Actually, its the way they
 *	clear lines that keeps us from using the standard stuff.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *	nlines	- number of lines to scroll.
 *
 * RETURNS:
 *	void
 *
 */
void minitel_scrollup(const HHEMU hhEmu, int nlines)
	{
	register INT row;
	INT 	nrows, iLen, iThisRow;
	ECHAR *lp;			/* line pointer */
	INT nScrlInc;		/* needed for call to Vid routine at bottom of func */

	if (nlines <= 0)
		return;

	hhEmu->scr_scrollcnt += nlines;
	nScrlInc = nlines = min(nlines,
							hhEmu->bottom_margin - hhEmu->top_margin + 1);

	for (row = hhEmu->top_margin; row < (hhEmu->top_margin + nlines); ++row)
		{
		iThisRow = row_index(hhEmu, row);
		lp = hhEmu->emu_apText[iThisRow];
		iLen = emuRowLen(hhEmu, iThisRow);
		minitel_clear_imgrow(hhEmu, row);
		}

	if (hhEmu->top_margin == 0 && hhEmu->bottom_margin == hhEmu->emu_maxrow)
		{
		hhEmu->emu_imgtop = row_index(hhEmu, nlines);
		}

	else if (nlines < (hhEmu->bottom_margin - hhEmu->top_margin + 1))
		{
		nrows = hhEmu->bottom_margin - hhEmu->top_margin + 1 - nlines;

		for (row = hhEmu->top_margin; nrows > 0; --nrows, ++row)
			{
			INT c;
			PSTATTR pstAttr, pstAttr2;
			PSTMINITEL pstMT, pstMT2;

			memmove(hhEmu->emu_apText[row_index(hhEmu, row)],
				 hhEmu->emu_apText[row_index(hhEmu, row + nlines)],
				 (size_t)hhEmu->emu_maxcol + 2);

			hhEmu->emu_aiEnd[row_index(hhEmu, row + nlines)] =
				hhEmu->emu_aiEnd[row_index(hhEmu, row)];

			pstAttr  = hhEmu->emu_apAttr[row_index(hhEmu, row)];
			pstAttr2 = hhEmu->emu_apAttr[row_index(hhEmu, row + nlines)];

			for (c = 0 ; c <= hhEmu->emu_maxcol ; ++c)
				pstAttr[c] = pstAttr2[c];

			pstMT = ((PSTMTPRIVATE)hhEmu->pvPrivate)->apstMT[row_index(hhEmu, row)];
			pstMT2= ((PSTMTPRIVATE)hhEmu->pvPrivate)->apstMT[row_index(hhEmu, row + nlines)];

			for (c = 0 ; c <= hhEmu->emu_maxcol ; ++c)
				pstMT[c] = pstMT2[c];
			}

		for (row = hhEmu->bottom_margin; nlines > 0; --nlines, --row)
			minitel_clear_imgrow(hhEmu, row);
		}

	hhEmu->emu_imgrow = row_index(hhEmu, hhEmu->emu_currow);

	updateScroll(sessQueryUpdateHdl(hhEmu->hSession),
					hhEmu->top_margin,
					hhEmu->bottom_margin,
					nScrlInc,
					hhEmu->emu_imgtop,
					TRUE);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitel_scrolldown
 *
 * DESCRIPTION:
 *	Minitel of course works differently.  Mostly is has more work to
 *	clear a line.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle
 *	nlines	- number of lines to scroll
 *
 * RETURNS:
 *	void
 *
 */
void minitel_scrolldown(const HHEMU hhEmu, int nlines)
	{
	register int row, nrows;
	int toprow, botmrow;
	int nScrlInc;

	if (nlines <= 0)
		return;

	hhEmu->scr_scrollcnt -= nlines;
	nScrlInc = nlines;

	toprow = hhEmu->top_margin;
	botmrow = hhEmu->bottom_margin;

	if (hhEmu->top_margin == 0 && hhEmu->bottom_margin == hhEmu->emu_maxrow)
		{
		hhEmu->emu_imgtop = row_index(hhEmu, -nlines);
		}

	else if (nlines < hhEmu->bottom_margin - hhEmu->top_margin + 1)
		{
		nrows = hhEmu->bottom_margin - hhEmu->top_margin + 1 - nlines;

		for (row = hhEmu->bottom_margin; nrows > 0; --nrows, --row)
			{
			int c;
			PSTATTR pstAttr, pstAttr2;
			PSTMINITEL pstMT, pstMT2;

			memmove(hhEmu->emu_apText[row_index(hhEmu, row)],
				 hhEmu->emu_apText[row_index(hhEmu, row - nlines)],
						(size_t)(hhEmu->emu_maxcol+2));

			hhEmu->emu_aiEnd[row_index(hhEmu, row - nlines)] =
				hhEmu->emu_aiEnd[row_index(hhEmu, row)];

			pstAttr  = hhEmu->emu_apAttr[row_index(hhEmu, row)];
			pstAttr2 = hhEmu->emu_apAttr[row_index(hhEmu, row - nlines)];

			for (c = 0 ; c <= hhEmu->emu_maxcol ; ++c)
				pstAttr[c] = pstAttr2[c];

			pstMT = ((PSTMTPRIVATE)hhEmu->pvPrivate)->apstMT[row_index(hhEmu, row)];
			pstMT2= ((PSTMTPRIVATE)hhEmu->pvPrivate)->apstMT[row_index(hhEmu, row + nlines)];

			for (c = 0 ; c <= hhEmu->emu_maxcol ; ++c)
				pstMT[c] = pstMT2[c];
			}
		}

	for (row = hhEmu->top_margin; nlines > 0; --nlines, ++row)
		minitel_clear_imgrow(hhEmu, row);

	hhEmu->emu_imgrow = row_index(hhEmu, hhEmu->emu_currow);

	updateScroll(sessQueryUpdateHdl(hhEmu->hSession),
					toprow, botmrow, -nScrlInc, hhEmu->emu_imgtop, TRUE);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitel_clear_imgrow
 *
 * DESCRIPTION:
 *	minitel's have to do more work to clear a line.
 *
 * ARGUMENTS:
 *	hhEmu	- private minitel handle.
 *	row 	- row to clear
 *
 * RETURNS:
 *	void
 *
 */
static void minitel_clear_imgrow(const HHEMU hhEmu, const int row)
	{
	const int save_row = hhEmu->emu_currow;
	const int save_imgrow = hhEmu->emu_imgrow;

	hhEmu->emu_currow = row;
	hhEmu->emu_imgrow = row_index(hhEmu, row);

	minitelClearLine(hhEmu, 2);

	hhEmu->emu_currow = save_row;
	hhEmu->emu_imgrow = save_imgrow;

	return;
	}
#endif	// INCL_MINITEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\vidstate.c ===
/*	File: D:\WACKER\emu\vidstate.c (Created: 08-Dec-1993)
 *
 *	Copyright 1993 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:29p $
 */

/* This file is no longer used! --jcm */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\minitel.hh ===
/*	File: D:\wacker\emu\minitel.hh (Created: 05-Mar-1994)
 *
 *	Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:28p $
 */

void emuMinitelInit(const HHEMU hhEmu);
void emuMinitelDeinstall(const HHEMU hhEmu);
void minitelGraphic(const HHEMU hhEmu);
void minitelLinefeed(const HHEMU hhEmu);
void minitelBackspace(const HHEMU hhEmu);
void minitelVerticalTab(const HHEMU hhEmu);
void minitelCursorUp(const HHEMU hhEmu);
void minitelCursorDirect(const HHEMU hhEmu);
void minitelFormFeed(const HHEMU hhEmu);
void minitelClearScreen(const HHEMU hhEmu, const int iHow);
void minitelClrScrn(const HHEMU hhEmu);
void minitelRecordSeparator(const HHEMU hhEmu);
void minitelClearLine(const HHEMU hhEmu, const int iHow);
void minitelClrLn(const HHEMU hhEmu);
void minitelUSCol(const HHEMU hhEmu);
void minitelUSRow(const HHEMU hhEmu);
void minitelReset(const HHEMU hhEmu);
void minitelHorzTab(const HHEMU hhEmu);
void minitelDel(const HHEMU hhEmu);
void minitelRepeat(const HHEMU hhEmu);
void minitelCharSet(const HHEMU hhEmu);
void minitelCharSize(const HHEMU hhEmu);
void minitelCancel(const HHEMU hhEmu);
void minitelResetTerminal(const HHEMU hhEmu);
void minitelCursorOn(const HHEMU hhEmu);
void minitelCursorOff(const HHEMU hhEmu);
void minitelResync(const HHEMU hhEmu);
void minitelDelChars(const HHEMU hhEmu);
void minitelInsChars(const HHEMU hhEmu);
void minitelDelRows(const HHEMU hhEmu);
void minitelInsRows(const HHEMU hhEmu);
void minitelNtfy(const HHEMU hhEmu, const int nNtfyCode);
void minitelCursorReport(const HHEMU hhEmu);
void emuMinitelCharAttr(const HHEMU hhEmu);
void emuMinitelFieldAttr(const HHEMU hhEmu);
int  minitelHomeHostCursor(const HHEMU hhEmu);
void minitel_scrollup(const HHEMU hhEmu, int nlines);
void minitel_scrolldown(const HHEMU hhEmu, int nlines);
void emuMinitelSetScrSize(const HHEMU hhEmu);


STATTR GetAttr(const HHEMU hhEmu, const int iRow, const int iCol);

/* --- minitel latent attribute structure --- */

typedef struct _minitel
	{
	unsigned int bkclr	 : 4;  // background color
	unsigned int conceal : 1;  // conceal
	unsigned int undrln  : 1;  // underline
	unsigned int isattr  : 1;  // true if this is an attribute space
	unsigned int ismosaic: 1;  // TRUE if char is mosaic
	unsigned int fbkclr  : 1;  // This attribute spaces validates color
	} STMINITEL;

// The latent attribute

typedef struct _latent
	{
	unsigned bkclr; 	    // background color
	unsigned conceal;	    // conceal chars
	unsigned undrln;	    // underline
	unsigned fModified; 	// latent attribute changed.
	unsigned fBkClr;		// TRUE if modified and not validated.
	} LATENTATTR;

typedef STMINITEL *PSTMINITEL;

// Private emulator data for Minitel.
//
typedef struct stPrivateMinitel
	{
	// Latent attribute and attribute array used for serial attributes.
	//
	LATENTATTR	stLatentAttr;
	LATENTATTR	saved_stLatentAttr;
	PSTMINITEL	*apstMT;
	ECHAR		minitel_last_char;
	int 		minitelG1Active;
	int 		minitelUseSeparatedMosaics;
	int 		saved_minitelUseSeparatedMosaics;
	int 		minitel_saved_row;
	int 		minitel_saved_col;
	STATTR		minitel_saved_attr;
	int 		minitel_saved_minitelG1Active;
	ECHAR		minitel_PRO1; // first part of a PRO sequence
	int 		us_row_code;  // used for US codes
	int 		minitelSecondDep;
	int 		fScrollMode;
	int 		F9; 		  // two consecutive F9's disconnect.
	int 		fInCancel;	  // used in minitelCancel and minitelGraphic
	} MTPRIVATE;

typedef MTPRIVATE *PSTMTPRIVATE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\viewdata.c ===
/*	File: D:\WACKER\emu\viewdata.c (Created: 31-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 2/02/01 4:01p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\tdll.h>
#include <tdll\session.h>
#include <tdll\chars.h>
#include <tdll\htchar.h>
#include <tdll\print.h>
#include <tdll\update.h>
#include <tdll\assert.h>

#include "emu.h"
#include "emu.hh"
#include "viewdata.hh"

#if defined(INCL_VIEWDATA)

static void EmuViewdataDisplayLine(const HHEMU hhEmu, const int iRow, const int iStartCol);
static STATTR GetAttr(const HHEMU hhEmu, const int iRow, const int iCol);
static ECHAR MapMosaics(const HHEMU hhEmu, ECHAR ch);
static int RowHasDblHigh(const HHEMU hhEmu, const int iRow);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataAnswerback
 *
 * DESCRIPTION:	Sends the answerback message defined on the menus.
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void EmuViewdataAnswerback(const HHEMU hhEmu)
	{
	TCHAR *sp;
	ECHAR *pech = NULL;

	sp = hhEmu->acAnswerback;

	// If there is nothing to send, there is nothing to send
	if (StrCharGetStrLength(sp) == 0)
		return;

        pech = malloc((unsigned int)StrCharGetByteCount(sp) + sizeof(TCHAR));

	if (pech == NULL)
		{
		assert(FALSE);
		return;
		}

        CnvrtMBCStoECHAR(pech, (unsigned long)StrCharGetByteCount(sp), sp,
                     (unsigned long)StrCharGetByteCount(sp) + sizeof(TCHAR));

	emuSendString(hhEmu, pech, (int)StrCharGetEcharByteCount(pech));
	free(pech);
	pech = NULL;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataCursorLeft
 *
 * DESCRIPTION:	Moves cursor left one column. If cursor starts at left edge,
 *				it moves cursor to the last column of the line above.
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void EmuViewdataCursorLeft(const HHEMU hhEmu)
	{
	int iRow, iCol;

	iRow = hhEmu->emu_currow;
	iCol = hhEmu->emu_curcol;

	if (hhEmu->emu_curcol > 0)
		{
		iCol -= 1;
		}

	else if (hhEmu->emu_currow > 0)
		{
		iRow -= 1;
		iCol = hhEmu->emu_maxcol;
		}

	(*hhEmu->emu_setcurpos)(hhEmu, iRow, iCol);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataCursorRight
 *
 * DESCRIPTION:	Moves cursor right one column. If cursor starts at right edge,
 *				it moves cursor to the first column of the line below.
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void EmuViewdataCursorRight(const HHEMU hhEmu)
	{
	int iRow, iCol;

	iRow = hhEmu->emu_currow;
	iCol = hhEmu->emu_curcol;

	if (hhEmu->emu_curcol < hhEmu->emu_maxcol)
		{
		iCol += 1;
		}

	else if (hhEmu->emu_currow < hhEmu->emu_maxrow)
		{
		iRow += 1;
		iCol = 0;
		}

	(*hhEmu->emu_setcurpos)(hhEmu, iRow, iCol);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataCursorDown
 *
 * DESCRIPTION:	Moves cursor down to the next line while maintaining the same
 *				column. If starting on the bottom line, the cursor moves to
 *				the top line.
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void EmuViewdataCursorDown(const HHEMU hhEmu)
	{
	int iRow = hhEmu->emu_currow;

	(*hhEmu->emu_setcurpos)(hhEmu,
					(hhEmu->emu_currow < hhEmu->emu_maxrow ? ++iRow : 0),
					hhEmu->emu_curcol);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataCursorUp
 *
 * DESCRIPTION:	Moves cursor up to the next line while maintaining the same
 *				column. If starting on the top line, the cursor moves to
 *				the bottom line.
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void EmuViewdataCursorUp(const HHEMU hhEmu)
	{
	int iRow = hhEmu->emu_currow;

	(*hhEmu->emu_setcurpos)(hhEmu,
					(hhEmu->emu_currow > 0 ? --iRow : hhEmu->emu_maxrow),
					hhEmu->emu_curcol);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataCursorHome
 *
 * DESCRIPTION:	Moves cursor to upper left corner of screen.
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void EmuViewdataCursorHome(const HHEMU hhEmu)
	{
	(*hhEmu->emu_setcurpos)(hhEmu, 0,0);
    return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataCursorSet
 *
 * DESCRIPTION:	Turns the cursor on and off.
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void EmuViewdataCursorSet(const HHEMU hhEmu)
	{
	switch(hhEmu->emu_code)
		{
	case ETEXT('\x11'):
		(*hhEmu->EmuSetCursorType)(hhEmu, EMU_CURSOR_BLOCK);
		break;

	case ETEXT('\x14'):
		(*hhEmu->EmuSetCursorType)(hhEmu, EMU_CURSOR_NONE);
		break;

	default:
		break;
		}

    return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataMosaicHold
 *
 * DESCRIPTION: Displays the last displayed mosaic TCHAR inn every attribute
 *				space that was defined during mosaic mode. If no mosaic has
 *				been displayed since the last change in alpha/mosaic setting
 *				or normal/double height setting or the last mosaic release,
 *				a space is displayed instead.
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void EmuViewdataMosaicHold(const HHEMU hhEmu)
	{
	hhEmu->emu_code = ETEXT('\x20');
	EmuViewdataCharDisplay(hhEmu);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataMosaicRelease
 *
 * DESCRIPTION:	Displays a space.
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void EmuViewdataMosaicRelease(const HHEMU hhEmu)
	{
	/* TODO write this function */
	hhEmu->emu_code = ETEXT('\x20');
	EmuViewdataCharDisplay(hhEmu);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataSetAttr
 *
 * DESCRIPTION:	Sets colors and alpha/mosaic modes.
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void EmuViewdataSetAttr(const HHEMU hhEmu)
	{
	const ECHAR uch = hhEmu->emu_code;
	const PSTVIEWDATAPRIVATE pstPRI = (PSTVIEWDATAPRIVATE)hhEmu->pvPrivate;

	// For readability.
	//
	PSTVIEWDATA *stAttr = pstPRI->apstVD;
	int iRow = hhEmu->emu_imgrow;
	int iCol = hhEmu->emu_curcol;
	unsigned int *aiColors = pstPRI->aMapColors;

	STATTR charattr;

	hhEmu->emu_code = ETEXT('\x20');

	pstPRI->fSetAttr = TRUE;

	if (uch >= ETEXT('\x41') && uch <= ETEXT('\x47'))  // A thru G
		{
		stAttr[iRow][iCol].attr = ALPHA_ATTR;
		stAttr[iRow][iCol].clr	= aiColors[uch - ETEXT('\x41')];
		}

	else if (uch >= ETEXT('\x51') && uch <= ETEXT('\x57')) // Q thru W
		{
		charattr = GetAttr(hhEmu, hhEmu->emu_currow, hhEmu->emu_curcol);
		stAttr[iRow][iCol].attr = MOSAIC_ATTR;
		stAttr[iRow][iCol].clr	= aiColors[uch - ETEXT('\x51')];
		}

	else
		{
		switch(uch)
			{
		case ETEXT('\x48'): //'H':
			stAttr[iRow][iCol].attr = FLASH_ATTR;
			break;

		case ETEXT('\x49'): //'I':
			stAttr[iRow][iCol].attr = STEADY_ATTR;
			break;

		case ETEXT('\x4C'): //'L':
			stAttr[iRow][iCol].attr = NORMALSIZE_ATTR;
			break;

		case ETEXT('\x4D'): //'M':
			stAttr[iRow][iCol].attr = DOUBLESIZE_ATTR;
			break;

		case ETEXT('\x58'): //'X':
			stAttr[iRow][iCol].attr = CONCEAL_ATTR;
			break;

		case ETEXT('\x59'): //'Y':
			stAttr[iRow][iCol].attr = CONTIGUOUS_ATTR;
			break;

		case ETEXT('\x5A'): //'Z':
			stAttr[iRow][iCol].attr = SEPARATED_ATTR;
			break;

		case ETEXT('\x5C'): //'\\':
			stAttr[iRow][iCol].attr = NEW_BACKGROUND_ATTR;
			stAttr[iRow][iCol].clr	= 0;
			break;

		case ETEXT('\x5D'): //']':
			stAttr[iRow][iCol].attr = NEW_BACKGROUND_ATTR;
			charattr = GetAttr(hhEmu, hhEmu->emu_currow, hhEmu->emu_curcol);
			stAttr[iRow][iCol].clr = charattr.txtclr;
			break;

		default:
			return;
			}
		}

	EmuViewdataCharDisplay(hhEmu);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataCharDisplay
 *
 * DESCRIPTION:	Displays a single character
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void EmuViewdataCharDisplay(const HHEMU hhEmu)
	{
	int  iRow = hhEmu->emu_currow;
	int  iCol = hhEmu->emu_curcol;
	ECHAR *tp = hhEmu->emu_apText[hhEmu->emu_imgrow];
	PSTATTR ap = hhEmu->emu_apAttr[hhEmu->emu_imgrow];
	const PSTVIEWDATAPRIVATE pstPRI = (PSTVIEWDATAPRIVATE)hhEmu->pvPrivate;

    // TODO: Temporary until we get Prestel font

	if (hhEmu->emu_code == ETEXT('\x7F'))
		hhEmu->emu_code = ETEXT('\x5B');

	if (RowHasDblHigh(hhEmu, iRow))
        goto SKIP;

	// Need to GetAtt() before calling MapMosaics() so vars are set right.
	//
	ap[iCol] = GetAttr(hhEmu, iRow, iCol);
	tp[iCol] = MapMosaics(hhEmu, hhEmu->emu_code);

	// Update the end of row index if necessary.
	//
	if (iCol > hhEmu->emu_aiEnd[hhEmu->emu_imgrow])
		hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = iCol;

	/* --- check to see if we are overwriting an attribute space --- */

	if (!pstPRI->fSetAttr)
		{
		pstPRI->fSetAttr =
			(BOOL)pstPRI->apstVD[hhEmu->emu_imgrow][hhEmu->emu_curcol].attr;

		pstPRI->apstVD[hhEmu->emu_imgrow][hhEmu->emu_curcol].attr = 0;
		}

    updateChar(sessQueryUpdateHdl(hhEmu->hSession), iRow, iCol, iCol);

    if (ap[iCol].dblhihi)
        {
		const PSTATTR apl =
			hhEmu->emu_apAttr[row_index(hhEmu, hhEmu->emu_currow+1)];

		hhEmu->emu_apText[row_index(hhEmu, hhEmu->emu_currow+1)][iCol] =
			tp[iCol];

        apl[iCol] = ap[iCol];
        apl[iCol].dblhihi = 0;
		apl[iCol].dblhilo = 1;

		pstPRI->fSetAttr = TRUE;	// need to redisplay line to get lower half to show.
        }

	if (pstPRI->fSetAttr)
        {
		EmuViewdataDisplayLine(hhEmu, iRow, iCol);
		pstPRI->fSetAttr = FALSE;
        }

    SKIP:
	if (++iCol > hhEmu->emu_maxcol)
		{
		if (hhEmu->print_echo)
			printEchoLine(hhEmu->hPrintEcho,
							tp,
							emuRowLen(hhEmu, hhEmu->emu_imgrow));

		if (++iRow > hhEmu->emu_maxrow)
			iRow = 0;

		iCol = 0;
		}

	(*hhEmu->emu_setcurpos)(hhEmu, iRow, iCol);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataDisplayLine
 *
 * DESCRIPTION:	Redisplays the specified row from the specified column
 *				using the current emu_charattr and character type up to
 *				the end of the line (the 1st nul) or the next attribute
 *				space (whichever comes first).
 *
 * ARGUMENTS:
 *				sRow -- screen row to redisplay
 *				sCol -- screen column at which to start displaying
 *
 * RETURNS:		nothing
 */
static void EmuViewdataDisplayLine(const HHEMU hhEmu,
									const int iRow,
									const int iStartCol)
	{
	int iCol;
    int fDblHi = FALSE;
	ECHAR *tp = hhEmu->emu_apText[row_index(hhEmu, iRow)];
	PSTATTR ap = hhEmu->emu_apAttr[row_index(hhEmu, iRow)];
	const PSTATTR apl = hhEmu->emu_apAttr[row_index(hhEmu, iRow+1)];

	for (iCol = iStartCol ; iCol <= hhEmu->emu_maxcol ; ++iCol)
		{
		ap[iCol] = GetAttr(hhEmu, iRow, iCol);
		tp[iCol] = MapMosaics(hhEmu, tp[iCol]);

		if (iRow < hhEmu->emu_maxrow && ap[iCol].dblhihi)
            fDblHi = TRUE;
		}

	updateChar(sessQueryUpdateHdl(hhEmu->hSession),
						iRow,
						iStartCol,
						hhEmu->emu_maxcol);

    if (fDblHi)
        {
		for (iCol = 0 ; iCol <= hhEmu->emu_maxcol ; ++iCol)
            {
            apl[iCol].bkclr = ap[iCol].bkclr;

            if (!apl[iCol].dblhilo)
                apl[iCol].blank = 1;
            }

        updateLine(sessQueryUpdateHdl(hhEmu->hSession), iRow+1, iRow+1);
        }

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	GetAttr
 *
 * DESCRIPTION:
 *	Walks the current row and builds a composite attribute based on
 *	the encountered attribute spaces.
 *
 * ARGUMENTS:
 *	iRow	- logical row
 *	iCol	- logical col
 *
 * RETURNS:
 *	composite attribute.
 *
 */
static STATTR GetAttr(const HHEMU hhEmu, const int iRow, const int iCol)
	{
	int i;
	STATTR stAttr;
	const PSTVIEWDATAPRIVATE pstPRI = (PSTVIEWDATAPRIVATE)hhEmu->pvPrivate;
	const PSTVIEWDATA pstVD = pstPRI->apstVD[row_index(hhEmu, iRow)];
	
	memset(&stAttr, 0, sizeof(STATTR));
	stAttr.txtclr = VC_BRT_WHITE;
	stAttr.bkclr  = VC_BLACK;

	pstPRI->fMosaicMode = FALSE;
	pstPRI->fSeperatedMosaic = FALSE;

	for (i = 0 ; i <= iCol ; ++i)
		{
		if (pstVD[i].attr)
			{
			switch (pstVD[i].attr)
				{
			case ALPHA_ATTR:
				pstPRI->fMosaicMode = FALSE;
				stAttr.txtclr = pstVD[i].clr;
				stAttr.symbol = FALSE;
				break;

			case MOSAIC_ATTR:
				pstPRI->fMosaicMode = TRUE;
				stAttr.txtclr = pstVD[i].clr;
				stAttr.symbol = TRUE;
				break;

			case CONTIGUOUS_ATTR:
				pstPRI->fMosaicMode = TRUE;
				pstPRI->fSeperatedMosaic = FALSE;
				stAttr.txtclr = pstVD[i].clr;
				stAttr.symbol = TRUE;
				break;

			case SEPARATED_ATTR:
				pstPRI->fMosaicMode = TRUE;
				pstPRI->fSeperatedMosaic = TRUE;
				stAttr.txtclr = pstVD[i].clr;
				stAttr.symbol = TRUE;
				break;

			case NORMALSIZE_ATTR:
				stAttr.dblhihi = 0;
				break;

			case FLASH_ATTR:
				stAttr.blink = 1;
				break;

			case STEADY_ATTR:
				stAttr.blink = 0;
				break;

			case NEW_BACKGROUND_ATTR:
				stAttr.bkclr = pstVD[i].clr;
				break;

			case DOUBLESIZE_ATTR:
				stAttr.dblhihi = 1;
				break;

			case CONCEAL_ATTR:
				stAttr.blank = 0; // ??
				break;

			default:
				break;
				}
			}
		}

	return stAttr;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	MapMosaics
 *
 * DESCRIPTION:
 *	Since attributes that come before characters affect the character
 *	display (alpha vs. mosaic) we need to map mosaic chars back to their
 *	alpha counterparts and vice-versa at anytime.  Prestel uses 7 bit
 *	ascii so we can map the mosaics to the upper 128 bytes.  This
 *	function just checks the current mode (mosaic/alpha) and if the
 *	character is in the proper range, its converted to its counterpart.
 *	Also converts NULL to a space.	View data doesn't support an end
 *	of line concept and instead always fills to the end of line.
 *
 *	Note:  This function assumes GetAttr() has been called since it
 *		   relies on fMosaic and fSeperatedMosaic to be set.
 *
 * ARGUMENTS:
 *	ch	- character to convert
 *
 * RETURNS:
 *	converted or original character.
 *
 */
static ECHAR MapMosaics(const HHEMU hhEmu, ECHAR ch)
	{
	const PSTVIEWDATAPRIVATE pstPRI = (PSTVIEWDATAPRIVATE)hhEmu->pvPrivate;

	if (pstPRI->fMosaicMode)
		{
		// This is temporary until the fonts get straightend out.
		//
		if (ch > ETEXT('\x21') && ch <= ETEXT('\x3F'))
			ch += ETEXT('\x1F');

		if (pstPRI->fSeperatedMosaic)
			ch += ETEXT('\x80');
		}

	else // convert to equivalent alpha
		{
		if (ch > ETEXT('\x80'))
			ch -= ETEXT('\x80');
		}


	return ch;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	EmuViewdataClearScreen
 *
 * DESCRIPTION:
 *	We use AnsiFormFeed() to do most of the work but we have to
 *	clear viewdata's  attribute buffer as well.
 *
 * ARGUMENTS:
 *	none
 *
 * RETURNS:
 *	void
 *
 */
void EmuViewdataClearScreen(const HHEMU hhEmu)
	{
	const PSTVIEWDATAPRIVATE pstPRI = (PSTVIEWDATAPRIVATE)hhEmu->pvPrivate;
	register int i;

	AnsiFormFeed(hhEmu);

	for (i = 0 ; i < hhEmu->emu_maxrow ; ++i)
		memset(pstPRI->apstVD[i],
				0,
				sizeof(STVIEWDATA) * VIEWDATA_COLS_40MODE);

    return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataKbd
 *
 * DESCRIPTION:
 *	 Keyboard routine for processing local keys on Viewdata terminal
 *
 * ARGUMENTS:
 *	 kcode	-	Key
 *
 * RETURNS:
 *	 nothing
 */
int EmuViewdataKbd(const HHEMU hhEmu, int kcode, const BOOL fTest)
	{
	switch (kcode)
		{
	case VK_ESCAPE | VIRTUAL_KEY:
		kcode = ETEXT('[') | CTRL_KEY;
		if (fTest)
			return kcode;
		break;

	case VK_TAB | VIRTUAL_KEY:
		kcode = ETEXT('I') | CTRL_KEY;
		if (fTest)
			return kcode;
		break;

	case VK_RETURN | VIRTUAL_KEY | CTRL_KEY:
		kcode = ETEXT('J') | CTRL_KEY;
		if (fTest)
			return kcode;
		break;
	default:
		break;
		}

	return std_kbdin(hhEmu, kcode, fTest);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * RowHasDblHigh
 *
 * DESCRIPTION:
 *  Checks if we are in the second row of a double high sequence. 
 *
 * ARGUMENTS:
 *	 void
 *
 * RETURNS:
 *	 0=FALSE, 1=TRUE
 */
static int RowHasDblHigh(const HHEMU hhEmu, const int iRow)
    {
    int i;
	const int r = row_index(hhEmu, iRow);
	const PSTATTR ap = hhEmu->emu_apAttr[r];

	if (hhEmu->emu_currow != 0)
        {
		for (i = 0 ; i < hhEmu->emu_maxcol ; ++i)
            {
            if (ap[i].dblhilo)
                return 1;
            }
        }

    return 0;
    }

#endif // INCL_VIEWDATA
/************************** end of viewdata.c *****************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\vt100.hh ===
/*	File: D:\WACKER\emu\vt100.hh (Created: 13-July-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:28p $
 */

// Private emulator data for DEC Terminals.
//
typedef struct stPrivateDEC
	{
	int sv_row,
		sv_col,
		sv_state,
		sv_AWM,
		sv_DECOM,
		sv_protectmode,
		fAttrsSaved,
		len_s,
		len_t,
		nState,
		gn,
		old_gl,
		gl,
		gr,
		sv_gr,
		sv_gl,
		fDecColHold,
		*aiLineAttr;

	ECHAR	storage[40],
			vt_charset[4],
			vt_sv_charset[4],
			terminate[4],
			*pntr;

	STATTR sv_attr;

	} DECPRIVATE;

typedef DECPRIVATE *PSTDECPRIVATE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\vt100.c ===
/*	File: D:\WACKER\emu\vt100.c (Created: 08-Dec-1993)
 *
 *	Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 8 $
 *	$Date: 4/19/01 5:02p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\tdll.h>
#include <tdll\htchar.h>
#include <tdll\session.h>
#include <tdll\chars.h>
#include <tdll\com.h>
#include <tdll\cloop.h>
#include <tdll\assert.h>
#include <tdll\print.h>
#include <tdll\capture.h>
#include <tdll\update.h>
#include <tdll\backscrl.h>
#include <tdll\mc.h>

#include "emu.h"
#include "emu.hh"
#include "emudec.hh"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuDecGraphic
 *
 * DESCRIPTION:
 *	This function is called to display the normal range of characters
 *	for the emulators.	It handles insertion modes, end of line wrapping,
 *	and cursor positioning.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void emuDecGraphic(const HHEMU hhEmu)
	{
	ECHAR ccode = hhEmu->emu_code;
	ECHAR aechBuf[10];
	int iCharsToMove;
	int fDecColHold = FALSE;

	int iRow = hhEmu->emu_currow;
	int iCol = hhEmu->emu_curcol;

	ECHAR	*tp = hhEmu->emu_apText[hhEmu->emu_imgrow];
	PSTATTR ap = hhEmu->emu_apAttr[hhEmu->emu_imgrow];

	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	// Initialize a test flag.	This is used for a special case when
	// emulating a VT100 (and maybe other DEC emulators) and the
	// current column position is the maximum.	When a character is placed
	// at emu_maxcol, instead of advancing the cursor to column 0 of the
	// next line, it is instead placed under that last character.  When the
	// next character arrives, it is placed at column 0 on the next line, and
	// then the cursor is advanced as expected.
	//

	// Special DEC test.
	//
	if (hhEmu->mode_AWM && iCol == hhEmu->emu_maxcol)
		{
		if (pstPRI->fDecColHold)
			{
			fDecColHold = FALSE;

			CaptureLine(sessQueryCaptureFileHdl(hhEmu->hSession),
							CF_CAP_LINES,
							tp,
							emuRowLen(hhEmu, hhEmu->emu_imgrow));

			printEchoString(hhEmu->hPrintEcho,
							tp,
							emuRowLen(hhEmu, hhEmu->emu_imgrow));


			CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), TEXT("\r\n"),
                             StrCharGetByteCount(TEXT("\r\n")));
			printEchoString(hhEmu->hPrintEcho,
							aechBuf,
							sizeof(ECHAR) * 2);

			if (iRow == hhEmu->bottom_margin)
				(*hhEmu->emu_scroll)(hhEmu, 1, TRUE);
			else
				++iRow;

			iCol = 0;
			(*hhEmu->emu_setcurpos)(hhEmu, iRow, iCol);

			tp = hhEmu->emu_apText[hhEmu->emu_imgrow];
			ap = hhEmu->emu_apAttr[hhEmu->emu_imgrow];
			}

		else
			{
			iCol = hhEmu->emu_maxcol;
			fDecColHold = TRUE;
			}
		}

	// Is the emulator in insert mode?
	//
	if (hhEmu->mode_IRM == SET)
		{
		iCharsToMove = (hhEmu->emu_aiEnd[hhEmu->emu_imgrow] - iCol + 1);

		if (iCharsToMove + iCol >= hhEmu->emu_maxcol)
			iCharsToMove -= 1;

		if (iCharsToMove > 0)
			{
			memmove(&tp[iCol+1],
					&tp[iCol],
					(unsigned)iCharsToMove * sizeof(ECHAR));

			memmove(&ap[iCol+1],
					&ap[iCol],
					(unsigned)iCharsToMove * sizeof(ECHAR));

			hhEmu->emu_aiEnd[hhEmu->emu_imgrow] =
				min(hhEmu->emu_aiEnd[hhEmu->emu_imgrow] + 1,
					hhEmu->emu_maxcol - 1);
			}
		}

	// Our competetor's are eating the NULL's.	DOS ANSI doesn't.
	// For now we'll try it their way... - mrw
	//
	if (ccode == (ECHAR)0)
		return;

	// Place the character and the current attribute into the image.
	//
	if (((hhEmu->stUserSettings.nEmuId == EMU_VT100)            ||
				(hhEmu->stUserSettings.nEmuId == EMU_VT220)     ||
				(hhEmu->stUserSettings.nEmuId == EMU_VT320)     ||
				(hhEmu->stUserSettings.nEmuId == EMU_VT100PLUS) ||
                (hhEmu->stUserSettings.nEmuId == EMU_VTUTF8)) &&
			ccode < sizeof(hhEmu->dspchar))
		ccode = hhEmu->dspchar[ccode];

	tp[iCol] = ccode;
	ap[iCol] = hhEmu->emu_charattr;

	// Check for double high, double wide processing.
	//
	if (pstPRI->aiLineAttr[hhEmu->emu_imgrow] != NO_LINE_ATTR)
		{
		int iColPrev = iCol;

		ap[iCol].dblwilf = 1;
		ap[iCol].dblwirt = 0;
		ap[iCol].dblhihi = (pstPRI->aiLineAttr[hhEmu->emu_imgrow] == DBL_WIDE_HI) ? 1 : 0;
		ap[iCol].dblhilo = (pstPRI->aiLineAttr[hhEmu->emu_imgrow] == DBL_WIDE_LO) ? 1 : 0;

		iCol = min(iCol+1, hhEmu->emu_maxcol);

		tp[iCol] = ccode;
		ap[iCol] = ap[iColPrev];
		ap[iCol].dblwilf = 0;
		ap[iCol].dblwirt = 1;
		}

#ifndef CHAR_NARROW
	// Process Double Byte Characters
	//
	if (QueryCLoopMBCSState(sessQueryCLoopHdl(hhEmu->hSession)))
		{
		if (isDBCSChar(ccode))
			{
			int iColPrev = iCol;

			ap[iCol].wilf = 1;
			ap[iCol].wirt = 0;

			iCol = min(iCol+1, hhEmu->emu_maxcol);

			tp[iCol] = ccode;
			ap[iCol] = ap[iColPrev];
			ap[iCol].wilf = 0;
			ap[iCol].wirt = 1;
			}
#if 0
        //mpt:1-23-98 handles the case when an incoming character
        //            (single or double byte) overwrites the first half of
        //            a double byte character
	    if ( iCol < hhEmu->emu_maxcol )
		    {
		    //if we orphaned a right half of a dbcs char
		    if (hhEmu->emu_apAttr[iRow][iCol + 1].wirt == TRUE)
			    {
			    //slide characters and attribs to left
                iCharsToMove = hhEmu->emu_aiEnd[hhEmu->emu_imgrow] - iCol - 1;
			    if (iCol + 2 < hhEmu->emu_maxcol && iCharsToMove > 0)
				    {
				    memmove(&tp[iCol + 1],
                            &tp[iCol + 2],
                            (unsigned)iCharsToMove * sizeof(ECHAR));

                    memmove(&ap[iCol + 1],
                            &ap[iCol + 2],
                            (unsigned)iCharsToMove * sizeof(ECHAR));
				    }
			    
			    //blank out character at end of line
			    tp[hhEmu->emu_aiEnd[hhEmu->emu_imgrow]] = 32;
			    ap[hhEmu->emu_aiEnd[hhEmu->emu_imgrow]].wirt = 0;
			    
                //move end of row since we removed a character
                hhEmu->emu_aiEnd[hhEmu->emu_imgrow]--;

                //update the image
                updateChar(sessQueryUpdateHdl(hhEmu->hSession),
				    hhEmu->emu_imgrow,
				    hhEmu->emu_aiEnd[hhEmu->emu_imgrow],
				    hhEmu->mode_IRM ?
				    hhEmu->emu_maxcol :
				    hhEmu->emu_aiEnd[hhEmu->emu_imgrow]);
                }	
    		}
#endif
        }
#endif //CHAR_NARROW

	// Update the end of row index if necessary.
	//
	if (iCol > hhEmu->emu_aiEnd[hhEmu->emu_imgrow])
		hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = iCol;

	// Update the image.
	//
	updateChar(sessQueryUpdateHdl(hhEmu->hSession),
				iRow,
				hhEmu->emu_curcol,
				hhEmu->mode_IRM ? hhEmu->emu_maxcol : iCol);

	// Move the position of the cursor ahead of the last character
	// displayed, checking for end of line wrap.
	//
	iCol += 1;

	// Finally, set the cursor position.  This wil reset emu_currow
	// and emu_curcol.
	//
	(*hhEmu->emu_setcurpos)(hhEmu, iRow, iCol);

	// Whenever we call setcurpos, it resets pstPRI->fDecColHold so
	// don't set till after we postion cursor.
	//
	pstPRI->fDecColHold = fDecColHold;
	return;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_DA
 *
 * DESCRIPTION:
 *	 Sends the device attribute (DA) report to the host.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_DA(const HHEMU hhEmu)
	{
	int fOldValue;
	ECHAR ech[15];

	CnvrtMBCStoECHAR(ech, sizeof(ech), TEXT("\033[?1;2c"), 
					 StrCharGetByteCount(TEXT("\033[?1;2c")));

	fOldValue = CLoopGetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession));

	CLoopSetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession), FALSE);

	emuSendString(hhEmu, ech, (int)StrCharGetEcharByteCount(ech)); 

	CLoopSetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession), fOldValue);

	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt100_savecursor
 *
 * DESCRIPTION:
 *	 Saves the current cursor postion; and, it also
 *	 saves display attributes, character set, wrap mode, and origin mode.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 *
 * NOTES:
 *	This function contains Auto Detect code.
 */
void vt100_savecursor(const HHEMU hhEmu)
	{
	ECHAR sel;
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	sel = hhEmu->emu_code;

	if (sel == ETEXT('7')) /* save cursor & attributes */
		{
		(*hhEmu->emu_getcurpos)(hhEmu, &pstPRI->sv_row, &pstPRI->sv_col);
		pstPRI->sv_state = hhEmu->iCurAttrState;
		pstPRI->sv_attr = hhEmu->attrState[hhEmu->iCurAttrState];
		vt_charset_save(hhEmu);
		pstPRI->sv_AWM = hhEmu->mode_AWM;
		pstPRI->sv_DECOM = hhEmu->mode_DECOM;
		pstPRI->sv_protectmode = hhEmu->mode_protect;
		pstPRI->fAttrsSaved = TRUE;
		}

	else if (sel == ETEXT('8'))	  /* restore cursor and attr. */
		{
		(*hhEmu->emu_setcurpos)(hhEmu, pstPRI->sv_row, pstPRI->sv_col);

		//if (pstPRI->sv_col == hhEmu->emu_maxcol)
		//	  hhEmu->emu_curcol = pstPRI->sv_col;		 /* in order to wrap on next char */

		if (pstPRI->fAttrsSaved)
			{
			hhEmu->iCurAttrState = pstPRI->sv_state;

			hhEmu->attrState[hhEmu->iCurAttrState] = pstPRI->sv_attr;

			hhEmu->emu_charattr = hhEmu->attrState[hhEmu->iCurAttrState];
			}

		vt_charset_restore(hhEmu);

		hhEmu->mode_AWM = pstPRI->sv_AWM;
		hhEmu->mode_DECOM = pstPRI->sv_DECOM;
		hhEmu->mode_protect = pstPRI->sv_protectmode;
		}

	else		/* clear saved conditions */
		{
		pstPRI->sv_row = pstPRI->sv_col = 0;
		pstPRI->sv_state = hhEmu->iCurAttrState;
		pstPRI->sv_AWM = pstPRI->sv_DECOM = RESET;
		pstPRI->sv_protectmode = FALSE;
		pstPRI->fAttrsSaved = FALSE;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt100_answerback
 *
 * DESCRIPTION:
 *	 Sends the answerback message defined on the menus.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void vt100_answerback(const HHEMU hhEmu)
	{
	int fOldValue;
	TCHAR *sp;
	ECHAR *pech = NULL;

	sp = hhEmu->acAnswerback;

	// If there is nothing to send, there is nothing to send
	if (StrCharGetStrLength(sp) == 0)
		return;

	pech = malloc((unsigned int)StrCharGetByteCount(sp));
	if (pech == NULL)
		{
		assert(FALSE);
		return;
		}

	CnvrtMBCStoECHAR(pech, StrCharGetByteCount(sp), sp, StrCharGetByteCount(sp));

	/* to not get recursive answerback's in half duplex */

	fOldValue = CLoopGetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession));

	CLoopSetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession), FALSE);

	emuSendString(hhEmu, pech, (int)StrCharGetEcharByteCount(pech));
	free(pech);
	pech = NULL;

	CLoopSetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession), fOldValue);

	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt100_hostreset
 *
 * DESCRIPTION:
 *	 Calls vt100_reset() when told to reset by the host.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void vt100_hostreset(const HHEMU hhEmu)
	{
	vt100_reset(hhEmu, TRUE);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt100_reset
 *
 * DESCRIPTION:
 *	 Resets the emulator.
 *
 * ARGUMENTS:
 *	 host_request -- TRUE when told to reset by the host.
 *
 * RETURNS:
 *	 nothing
 */
int vt100_reset(const HHEMU hhEmu, const int host_request)
	{
	hhEmu->mode_KAM = hhEmu->mode_IRM = hhEmu->mode_VEM =
	hhEmu->mode_HEM = hhEmu->mode_LNM = hhEmu->mode_DECCKM =
	hhEmu->mode_DECOM = hhEmu->mode_DECCOLM = hhEmu->mode_DECPFF =
	hhEmu->mode_DECPEX = hhEmu->mode_DECSCNM = hhEmu->mode_25enab =
	hhEmu->mode_protect = hhEmu->mode_block =
	hhEmu->mode_local = RESET;

	hhEmu->mode_SRM = hhEmu->mode_DECTCEM = SET;

	hhEmu->mode_AWM = hhEmu->stUserSettings.fWrapLines;

	vt_charset_init(hhEmu);
	if (host_request)
		{
		ANSI_Pn_Clr(hhEmu);
		ANSI_SGR(hhEmu);
		ANSI_RIS(hhEmu);
		}
	hhEmu->emu_code = ETEXT('>');

	vt_alt_kpmode(hhEmu);

	if (hhEmu->stUserSettings.nEmuId == EMU_ANSI ||
		hhEmu->stUserSettings.nEmuId == EMU_AUTO)
		hhEmu->emu_kbdin = ansi_kbdin;
	else
		hhEmu->emu_kbdin = vt100_kbdin;

	hhEmu->mode_AWM = RESET;
	hhEmu->stUserSettings.fWrapLines = RESET;

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt100_report
 *
 * DESCRIPTION:
 *	 Sends the current terminal parameters specified by the DECREQTPARM.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void vt100_report(const HHEMU hhEmu)
	{
	int sol, i = 0, xspeed = 0;
	TCHAR str[20];
	TCHAR tempstr[4];
	ECHAR ech[20];
	int fOldValue;
	TCHAR *sp;
	long lBaud;
	int nDataBits, nParity;

	HCOM hCom;

	static int baudrates[] = {50, 75, 110, 135, 150, 200, 300, 600, 1200,
								 1800, 2000, 2400, 2600, 4800, 9600, 19200};

	sol = hhEmu->num_param[0];
	if (sol != 0 && sol != 1)
		return;

	wsprintf(str, TEXT("\x01B[%s;"),
				sol == 0 ? (LPTSTR)TEXT("2") : (LPTSTR)TEXT("3"));

	hCom = sessQueryComHdl(hhEmu->hSession);
	ComGetBaud(hCom, &lBaud);
	ComGetDataBits(hCom, &nDataBits);
	ComGetParity(hCom, &nParity);

	// Parity
	//
	if (nParity == 0)		// None
		StrCharCat(str, TEXT("1;"));
	else if (nParity == 1)	// Odd
		StrCharCat(str, TEXT("4;"));
	else 					// Even
		StrCharCat(str, TEXT("5;"));

	// Data bits
	//
	nDataBits == 8 ? StrCharCat(str, TEXT("1;")) : StrCharCat(str, TEXT("2;"));

	while (xspeed < 120)
		{
		if ((long)baudrates[i] >= lBaud)
			break;
		i++;
		xspeed += 8;
		}

	// Recieving speed
	//
	wsprintf(tempstr, "%d", xspeed);
	StrCharCat(str, tempstr);

	// Sending speed
	//
	StrCharCat(str, TEXT(";"));
	StrCharCat(str, tempstr);

	// Bit rate multiplier ; Flags
	//
	StrCharCat(str, TEXT(";1;0x"));

	sp = str;

	CnvrtMBCStoECHAR(ech, sizeof(ech), sp, StrCharGetByteCount(sp));

	/* to not get recursive vt100_report's if half duplex */

	fOldValue = CLoopGetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession));

	CLoopSetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession), FALSE);

	emuSendString(hhEmu, ech, (int)StrCharGetEcharByteCount(ech));

	CLoopSetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession), fOldValue);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt100_kbdin
 *
 * DESCRIPTION:
 *	 Processes local keyboard keys for the VT100 emulator.
 *	 Note: mode_DECKPAM is TRUE or SET when in DEC KeyPad Aplication Mode.
 *	 Removed key processing 1/3/92.  Will replace with something resonable
 *	 later - mrw.
 *
 * ARGUMENTS:
 *	 key -- key to process
 *
 * RETURNS:
 *	 nothing
 */
int vt100_kbdin(const HHEMU hhEmu, int key, const int fTest)
	{
	int index;
	/* -------------- Check Backspace & Delete keys ------------- */

	if (hhEmu->stUserSettings.fReverseDelBk && ((key == VK_BACKSPACE) ||
			(key == DELETE_KEY) || (key == DELETE_KEY_EXT)))
		{
		key = (key == VK_BACKSPACE) ? DELETE_KEY : VK_BACKSPACE;
		}

	/* -------------- Mapped PF1-PF4 keys ------------- */

    #if 0 // mrw:11/3/95 - removed because we can't control num-lock
          // in Win95
	if (hhEmu->stUserSettings.fMapPFkeys &&
			(index = emuKbdKeyLookup(hhEmu, key, &hhEmu->stEmuKeyTbl4)) != -1)
		{
		if (!fTest)
			emuSendKeyString(hhEmu, index, &hhEmu->stEmuKeyTbl4);
		}
    #endif

	/* -------------- Cursor Key Mode ------------- */

	else if (hhEmu->mode_DECCKM == SET &&
			(index = emuKbdKeyLookup(hhEmu, key, &hhEmu->stEmuKeyTbl3)) != -1)
		{
		if (!fTest)
			emuSendKeyString(hhEmu, index, &hhEmu->stEmuKeyTbl3);
		}

	/* -------------- Keypad Application Mode ------------- */

	else if (hhEmu->mode_DECKPAM &&
			(index = emuKbdKeyLookup(hhEmu, key, &hhEmu->stEmuKeyTbl2)) != -1)
		{
		if (!fTest)
			emuSendKeyString(hhEmu, index, &hhEmu->stEmuKeyTbl2);
		}

	/* -------------- Normal keys ------------- */

	else if ((index = emuKbdKeyLookup(hhEmu, key, &hhEmu->stEmuKeyTbl)) != -1)
		{
		if (!fTest)
			emuSendKeyString(hhEmu, index, &hhEmu->stEmuKeyTbl);
		}

	else
		{
		index = std_kbdin(hhEmu, key, fTest);
		}

	return index;
	}

#if FALSE	// Never used in HyperTerminal.
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * fakevt_kbdin
 *
 * DESCRIPTION:
 *	 Processes local keyboard keys for the WANG, IBM3278 & RENX3278 emulators.
 *
 * ARGUMENTS:
 *	 key -- key to process
 *
 * RETURNS:
 *	 nothing
 */
int fakevt_kbdin(const HHEMU hhEmu, int key, const int fTest)
	{
	int index;

	/* -------------- Check Backspace & Delete keys ------------- */

	if (hhEmu->stUserSettings.fReverseDelBk && ((key == VK_BACKSPACE) ||
			(key == DELETE_KEY) || key == DELETE_KEY_EXT))
		{
		key = (key == VK_BACKSPACE) ? DELETE_KEY : VK_BACKSPACE;
		}

	if ((index = emuKbdKeyLookup(hhEmu, key, &hhEmu->stEmuKeyTbl)) != -1)
		{
		if (!fTest)
			emuSendKeyString(hhEmu, index, &hhEmu->stEmuKeyTbl);
		}

	else
		{
		index = std_kbdin(hhEmu, key, fTest);
		}

	return index;
	}
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt100PrintCommands
 *
 * DESCRIPTION:
 *	 Processes VT100 printing commands.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void vt100PrintCommands(const HHEMU hhEmu)
	{
	int line;
	int from;
	int to;
	ECHAR sel;
	ECHAR aechBuf[10];

	sel = (ECHAR)hhEmu->selector[0];

	switch (sel)
		{
		// Auto print on.
		//
		case ETEXT(0xF5):
			hhEmu->print_echo = TRUE;
			printSetStatus(hhEmu->hPrintEcho, TRUE);
			break;

		// Auto print off.
		//
		case ETEXT(0xF4):
			hhEmu->print_echo = FALSE;
			printSetStatus(hhEmu->hPrintEcho, FALSE);
    		printEchoClose(hhEmu->hPrintEcho);

			break;

		// Print screen.
		//
		case ETEXT(0x00):
			if (hhEmu->mode_DECPEX == RESET)
				from = hhEmu->top_margin, to = hhEmu->bottom_margin;
			else
				from = 0, to = EMU_DEFAULT_MAXROW;

			for (line = from; line <= to; ++line)
				printEchoLine(hhEmu->hPrintHost,
								hhEmu->emu_apText[row_index(hhEmu, line)],
								emuRowLen(hhEmu, row_index(hhEmu, line)));

			if (hhEmu->mode_DECPFF == SET)	 /* print form feed */
				{
				CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), TEXT("0x0C"),
                                 StrCharGetByteCount(TEXT("0x0C")));
				printEchoLine(hhEmu->hPrintHost, aechBuf, sizeof(ECHAR));
				}

			break;

		// Print Cursor line.
		//
		case ETEXT(0xF1):
			printEchoLine(hhEmu->hPrintEcho,
							hhEmu->emu_apText[row_index(hhEmu,
							hhEmu->emu_currow)],
							emuRowLen(hhEmu,
										row_index(hhEmu, hhEmu->emu_currow)));
			break;

		// Enter printer controller mode.  State is hard coded for now...
		// Bad news.
		//
		case ETEXT(0x05):
			hhEmu->state = 6;
			printSetStatus(hhEmu->hPrintHost, TRUE);
			break;

		// Exit printer controller mode.  This is seen when not in
		// controller mode.
		//
		case ETEXT(0x04):
			break;

		default:
			break;
		}
	}

void vt100_prnc(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;
	ECHAR aechBuf[10];
	size_t size;

	*pstPRI->pntr++ = hhEmu->emu_code;
	*pstPRI->pntr = 0;
	++pstPRI->len_s;

	CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), TEXT("\033[4i"),
                     StrCharGetByteCount(TEXT("\033[4i")));

	size = (size_t)StrCharGetByteCount(TEXT("\033[4i"));
	if ((pstPRI->len_s >= 4) && (memcmp(pstPRI->pntr - 4, aechBuf, size) == 0))
		{
		/* received termination string, wrap it up */
#if defined(INCL_PRINT_PASSTHROUGH)
		if( !hhEmu->stUserSettings.fPrintRaw)
			{
			printEchoRaw(hhEmu->hPrintHost, pstPRI->storage, pstPRI->len_s - ((*(pstPRI->pntr - 3) == (TCHAR)TEXT('\233')) ? 3 : 4));
			}
		else
#endif
			{
    		emuPrintChars(hhEmu, pstPRI->storage, pstPRI->len_s - ((*(pstPRI->pntr - 3) == (TCHAR)TEXT('\233')) ? 3 : 4));
	    	printEchoChar(hhEmu->hPrintHost, ETEXT('\n'));
			}
		
		pstPRI->pntr = pstPRI->storage;
		pstPRI->len_s = 0;
		hhEmu->state = 0;  /* drop out of this routine */

		// Finish-up print job
		DbgOutStr("print-control off\r\n", 0, 0, 0, 0, 0);
		printEchoClose(hhEmu->hPrintHost);
		return;
		}

	/* haven't received termination sequence yet, is storage filled? */
	if (pstPRI->len_s >= (int)(sizeof(pstPRI->storage) - 1))
		{
		/* copy most of string to print buffer */
#if defined(INCL_PRINT_PASSTHROUGH)
		if( !hhEmu->stUserSettings.fPrintRaw )
			{
			printEchoRaw(hhEmu->hPrintHost, pstPRI->storage, pstPRI->len_s - 4);
			}
		else
#endif
			{
			emuPrintChars(hhEmu, pstPRI->storage, pstPRI->len_s - 4);\
			}

		/* move end of string to beginning of storage */
		memmove(pstPRI->storage, &pstPRI->storage[pstPRI->len_s - 4], 4 * sizeof(ECHAR));
		pstPRI->pntr = pstPRI->storage + 4;
		pstPRI->len_s = 4;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void emuSetDoubleAttr(const HHEMU hhEmu)
	{

	switch(hhEmu->emu_code)
		{
		// Double width, double height, top half.
		//
		case '3':
			emuSetDoubleAttrRow(hhEmu, DBL_WIDE_HI);
			break;

		// Double width double height, bottom half.
		//
		case '4':
			emuSetDoubleAttrRow(hhEmu, DBL_WIDE_LO);
			break;

		// Single width single height.
		//
		case '5':
			emuSetSingleAttrRow(hhEmu);
			break;

		// Double width, single height.
		//
		case '6':
			emuSetDoubleAttrRow(hhEmu, DBL_WIDE_SINGLE_HEIGHT);
			break;

		default:
			break;
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void emuSetSingleAttrRow(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	int iOldRow,
		iOldCol,
		iImgRow;

	// Determine the image row.
	//
	iImgRow = row_index(hhEmu, hhEmu->emu_currow);

	// If the current line attribute is the same as the one we're
	// being asked to change to, get out-a-town.
	//
	if (pstPRI->aiLineAttr[iImgRow] == NO_LINE_ATTR)
		return;

	// Get the current cursor position.
	//
	std_getcurpos(hhEmu, &iOldRow, &iOldCol);

	// Convert the current row.
	//
	emuFromDblToSingle(hhEmu);

	// Update the line.
	//
	updateLine(sessQueryUpdateHdl(hhEmu->hSession),
				hhEmu->emu_currow,
				hhEmu->emu_currow);

	// Put the cursor back to where it was, or at the new rightmost
	// margin, whichever is less.
	//
	iOldCol = iOldCol / 2;
	iOldCol = min(iOldCol, hhEmu->emu_maxcol);
	std_setcurpos(hhEmu, iOldRow, iOldCol);

	// Finally, update this rows line attribute value.
	//
	pstPRI->aiLineAttr[iImgRow] = NO_LINE_ATTR;

	return;

	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void emuSetDoubleAttrRow(const HHEMU hhEmu, const int iLineAttr)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	int iChar,
		iImgRow,
		iOldRow,
		iOldCol,
		iUpperAttr,
		iLowerAttr;

	// Determine the image row.
	//
	iImgRow = row_index(hhEmu, hhEmu->emu_currow);

	// If the current line attribute is the same as the one we're
	// being asked to change to, get out-a-town.
	//
	if (pstPRI->aiLineAttr[iImgRow] == iLineAttr)
		return;

	// Get the current cursor position.
	//
	std_getcurpos(hhEmu, &iOldRow, &iOldCol);

	// If the current line attribute is anything but NO_LINE_ATTR, call
	// a routine that will first put the row back into that state.	That
	// is, this routine converts FROM a standard line INTO a double wide
	// line.
	//
	if (pstPRI->aiLineAttr[iImgRow] != NO_LINE_ATTR)
		{
		emuFromDblToSingle(hhEmu);
		iOldCol = iOldCol / 2;
		}

	// Start a shell game!
	//
	iChar = (hhEmu->emu_maxcol+1) / 2;

	// Remember that both of the following values will be zero in the
	// case of processing a DBL_WIDE_SINGLE_HEIGHT	request.
	//
	iUpperAttr = (iLineAttr == DBL_WIDE_HI) ? 1 : 0;
	iLowerAttr = (iLineAttr == DBL_WIDE_LO) ? 1 : 0;

	while (iChar >= 0)
		{
		hhEmu->emu_apText[iImgRow][(iChar * 2) + 1] = hhEmu->emu_apText[iImgRow][iChar];
		hhEmu->emu_apAttr[iImgRow][(iChar * 2) + 1].dblwirt = 1;
		hhEmu->emu_apAttr[iImgRow][(iChar * 2) + 1].dblwilf = 0;
		hhEmu->emu_apAttr[iImgRow][(iChar * 2) + 1].dblhihi = (unsigned)iUpperAttr;
		hhEmu->emu_apAttr[iImgRow][(iChar * 2) + 1].dblhilo = (unsigned)iLowerAttr;

		hhEmu->emu_apText[iImgRow][(iChar * 2)]  = hhEmu->emu_apText[iImgRow][iChar];
		hhEmu->emu_apAttr[iImgRow][(iChar * 2)].dblwirt = 0;
		hhEmu->emu_apAttr[iImgRow][(iChar * 2)].dblwilf = 1;
		hhEmu->emu_apAttr[iImgRow][(iChar * 2)].dblhihi = (unsigned)iUpperAttr;
		hhEmu->emu_apAttr[iImgRow][(iChar * 2)].dblhilo = (unsigned)iLowerAttr;

		iChar--;
		}

	// Null terminate the new text image.
	//
	hhEmu->emu_apText[iImgRow][hhEmu->emu_maxcol + 1] = ETEXT('\0');

	// Update the line.
	//
	updateLine(sessQueryUpdateHdl(hhEmu->hSession),
				hhEmu->emu_currow,
				hhEmu->emu_currow);

	// Put the cursor back to where it was, or at the new rightmost
	// margin, whichever is less.
	//
	iOldCol = iOldCol * 2;
	iOldCol = min(iOldCol, hhEmu->emu_maxcol);
	std_setcurpos(hhEmu, iOldRow, iOldCol);

	// Finally, update this rows line attribute value.
	//
	pstPRI->aiLineAttr[iImgRow] = iLineAttr;

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuFromDblToSingle
 *
 * DESCRIPTION:
 *	Note that this is a utility function and does not update the emulator
 *	image.	The calling function should do this.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void emuFromDblToSingle(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	register int i;

	int iSource,
		iDest,
		iLastCol,
		iImgRow;

	// Determine the image row.
	//
	iImgRow = row_index(hhEmu, hhEmu->emu_currow);

	// If the current line attribute is the same as the one we're
	// being asked to change to, get out-a-town.
	//
	if (pstPRI->aiLineAttr[iImgRow] == NO_LINE_ATTR)
		return;

	// A new shell game.
	//
	iSource = 0;
	iDest  = 0;

	iLastCol = (hhEmu->emu_maxcol+1) / 2;

	// TODO:  JCM - in two location below, the text buffer is set to
	// spaces, instead of nulls.  Figure out why this is the case.	We
	// should be able to set these to nulls.

	while (iSource <= hhEmu->emu_maxcol)
		{
		if (hhEmu->emu_apText[iImgRow][iSource] == ETEXT('\0'))  // TODO 1:
			hhEmu->emu_apText[iImgRow][iDest] = ETEXT(' ');
		else
			hhEmu->emu_apText[iImgRow][iDest] =
				hhEmu->emu_apText[iImgRow][iSource];

		hhEmu->emu_apAttr[iImgRow][iDest].dblwirt = 0;
		hhEmu->emu_apAttr[iImgRow][iDest].dblwilf = 0;
		hhEmu->emu_apAttr[iImgRow][iDest].dblhihi = 0;
		hhEmu->emu_apAttr[iImgRow][iDest].dblhilo = 0;

		iSource += 2;
		iDest += 1;
		}

	for (i = iLastCol; i < MAX_EMUCOLS ; ++i)
		{
		hhEmu->emu_apText[iImgRow][i] = ETEXT(' ');		  // TODO 2:
		hhEmu->emu_apAttr[iImgRow][i] = hhEmu->emu_clearattr;
		/*
		hhEmu->emu_apAttr[iImgRow][i].dblwirt = 0;
		hhEmu->emu_apAttr[iImgRow][i].dblwilf = 0;
		hhEmu->emu_apAttr[iImgRow][i].dblhihi = 0;
		hhEmu->emu_apAttr[iImgRow][i].dblhilo = 0;
		*/
		}

	pstPRI->aiLineAttr[iImgRow] = NO_LINE_ATTR;

	return;

	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void emuDecTab(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	int col;

	col = hhEmu->emu_curcol;

	while (col <= hhEmu->emu_maxcol)
        {
		if (hhEmu->tab_stop[++col])
            {
			break;
            }
        }

	if (pstPRI->aiLineAttr[hhEmu->emu_imgrow] != NO_LINE_ATTR)
		col = (col * 2) - 1;

	(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, col);

	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: emuDecBackTab
 *
 * DESCRIPTION:
 *      BackTab.  Move the cursor location to the previous tab stop.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void emuDecCBT(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	int col = hhEmu->emu_curcol;
    int tabs = 0;

    if (hhEmu->selector_cnt == 1 && hhEmu->selector[0] >= 0)
        {
        for (tabs = hhEmu->selector[0]; col > 0 && tabs >= 0; tabs--)
            {
		    if (hhEmu->tab_stop[--col])
                {
                tabs--;
                }
            }

        if (pstPRI->aiLineAttr[hhEmu->emu_imgrow] != NO_LINE_ATTR)
            {
		    col = (col * 2) - 1;
            }

	    (*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, col);
        }
    else
        {
		commanderror(hhEmu);
        }

    return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecCUF
 *
 * DESCRIPTION:
 *	 Moves the cursor forward the specified number of characters, but stops
 *	 at the last character in the current line.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void emuDecCUF(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	int nchars, col;

	nchars = hhEmu->num_param[hhEmu->num_param_cnt];

	if (nchars < 1)
		nchars = 1;

	if (pstPRI->aiLineAttr[hhEmu->emu_imgrow])
		nchars = (nchars * 2);

	col = hhEmu->emu_curcol;
	col += nchars;

	(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, col);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecCUP
 *
 * DESCRIPTION:
 *	 Positions the cursor at the specified row and column. The row & column
 *	 numbering start at 1. If origin mode is on, the positioning is relative
 *	 to the home of the scrolling region.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void emuDecCUP(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	int row, col;

	row = hhEmu->num_param[0];
	col = hhEmu->num_param_cnt > 0 ? hhEmu->num_param[1] : 0;

	if (pstPRI->aiLineAttr[row_index(hhEmu, row)] != NO_LINE_ATTR)
		col = (col * 2) - 1;

	if (row <= 1)
		row = 1;

	if (col <= 1)
		col = 1;

	if (hhEmu->mode_DECOM) /* VT100 Origin mode - position rel to margin */
		{
		row += hhEmu->top_margin;
		if (row > hhEmu->bottom_margin + 1)
			row = hhEmu->bottom_margin + 1;
		}
	else				/* Position is one-based from upper left */
		{
		if (row > hhEmu->emu_maxrow + 1)
			row = hhEmu->emu_maxrow + 1;
		}

	if (col > hhEmu->emu_maxcol + 1)
		col = hhEmu->emu_maxcol + 1;

	(*hhEmu->emu_setcurpos)(hhEmu, row - 1, col - 1); /* ANSI is one-based, HA zero-based */
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecCUB
 *
 * DESCRIPTION:	Moves the cursor backwards (to the left) the specified number
 *				of characters, but stops at the 1st character in the current
 *				line. The vt emus need a special function to handle the
 *				virtual column beyond the edge of the screen.
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void emuDecCUB(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	int nchars;

	nchars = hhEmu->num_param[hhEmu->num_param_cnt];

	if (nchars < 1)
		nchars = 1;

	if (pstPRI->aiLineAttr[hhEmu->emu_imgrow])
		nchars = (nchars * 2);

	(*hhEmu->emu_setcurpos)(hhEmu,
							hhEmu->emu_currow,
							hhEmu->emu_curcol - nchars);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecED
 *
 * DESCRIPTION:
 *	 Erases some or all of the virtual screen image and corresponding
 *	 real screen.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void emuDecED(const HHEMU hhEmu)
	{
	int selector = hhEmu->selector[0];

	switch (selector)
		{
	case 0: 	/* cursor to end of screen */
	case 0x0F:
	case 0xF0:
		(*hhEmu->emu_clearscreen)(hhEmu, 0);
		break;

	case 1: 	/* start of screen to cursor */
	case 0xF1:
		(*hhEmu->emu_clearscreen)(hhEmu, 1);
		break;

	case 2: 	/* Entire screen */
	case 0xF2:
		(*hhEmu->emu_clearscreen)(hhEmu, 2);
		break;
	default:
		commanderror(hhEmu);
		break;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecUnload
 *
 * DESCRIPTION:
 *	 Unloads current emulator by freeing used memory.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void emuVT100Unload(const HHEMU hhEmu)
	{
	PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	assert(hhEmu);

	if (pstPRI)
		{
		if (pstPRI->aiLineAttr)
			{
			free(pstPRI->aiLineAttr);
			pstPRI->aiLineAttr = 0;
			}

		free(hhEmu->pvPrivate);
		hhEmu->pvPrivate = 0;
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecIND
 *
 * DESCRIPTION:
 *	 Moves cursor down 1 line and scrolls 1 line if necessary. IND stands
 *	 for index.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void emuDecIND(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	int fSourceIsDbl, fDestIsDbl;
	int iCol;

	// If we're at the bottom line, scroll.
	//
	if (hhEmu->emu_currow == hhEmu->bottom_margin)
		{
		(*hhEmu->emu_scroll)(hhEmu, 1, TRUE);
		return;
		}

	fSourceIsDbl = (pstPRI->aiLineAttr[row_index(hhEmu, hhEmu->emu_currow)] == NO_LINE_ATTR)
					? FALSE : TRUE;
	fDestIsDbl = (pstPRI->aiLineAttr[row_index(hhEmu, hhEmu->emu_currow + 1)] == NO_LINE_ATTR)
					? FALSE : TRUE;

	iCol = hhEmu->emu_curcol;

	// If both source and dest are the same, regardless of size, go
	// ahead and make the move.  It only matters if they're different.
	//
	if (fSourceIsDbl == fDestIsDbl) 	// Both the same
		iCol = iCol;
	else if (fSourceIsDbl)				// Source is double, dest is single.
		iCol = iCol / 2;
	else								// Source is singel, dest is double.
		iCol = iCol * 2;

	(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow + 1, iCol);

	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecRI
 *
 * DESCRIPTION:
 *	 Moves cursor up 1 line and scrolls 1 line if necessary.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void emuDecRI(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	int fSourceIsDbl, fDestIsDbl;
	int iCol;

	// If we're at the bottom line, scroll.
	//
	if (hhEmu->emu_currow == hhEmu->top_margin)
		{
		(*hhEmu->emu_scroll)(hhEmu, 1, FALSE);
		return;
		}

	fSourceIsDbl = (pstPRI->aiLineAttr[row_index(hhEmu, hhEmu->emu_currow)] == NO_LINE_ATTR)
					? FALSE : TRUE;
	fDestIsDbl = (pstPRI->aiLineAttr[row_index(hhEmu, hhEmu->emu_currow - 1)] == NO_LINE_ATTR)
					? FALSE : TRUE;

	iCol = hhEmu->emu_curcol;

	// If both source and dest are the same, regardless of size, go
	// ahead and make the move.  It only matters if they're different.
	//
	if (fSourceIsDbl == fDestIsDbl) 	// Both the same
		iCol = iCol;
	else if (fSourceIsDbl)				// Source is double, dest is single.
		iCol = iCol / 2;
	else								// Source is singel, dest is double.
		iCol = iCol * 2;

	(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow - 1, iCol);

	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecCUU
 *
 * DESCRIPTION: Moves the cursor up the specified number of lines, but stops
 *				at the top of the scrolling region. The column is constant.
 *				If above the scrolling region, it stops at the top of the
 *				screen.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void emuDecCUU(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	int nlines,
		row,
		fSourceIsDbl,
		fDestIsDbl,
		iCol;

	nlines = hhEmu->num_param[hhEmu->num_param_cnt];

	if (nlines < 1)
		nlines = 1;

	row = hhEmu->emu_currow;
	row -= nlines;

	fSourceIsDbl = (pstPRI->aiLineAttr[row_index(hhEmu, hhEmu->emu_currow)] == NO_LINE_ATTR)
					? FALSE : TRUE;
	fDestIsDbl = (pstPRI->aiLineAttr[row_index(hhEmu, hhEmu->emu_currow - nlines)] == NO_LINE_ATTR)
					? FALSE : TRUE;

	iCol = hhEmu->emu_curcol;

	// The following code adjusts the column value for double wide
	// characters.
	//
	if (fSourceIsDbl == fDestIsDbl) 	// Both the same
		iCol = iCol;
	else if (fSourceIsDbl)				// Source is double, dest is single.
		iCol = iCol / 2;
	else								// Source is singel, dest is double.
		iCol = iCol * 2;

	if (row < hhEmu->top_margin && (hhEmu->emu_currow >= hhEmu->top_margin || hhEmu->emu_currow < 0))
		row = hhEmu->top_margin;

	(*hhEmu->emu_setcurpos)(hhEmu, row, iCol);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecCUD
 *
 * DESCRIPTION: Moves the cursor down the specified number of lines, but stops
 *				at the bottom of the scrolling region. The column is constant.
 *				If below the scrolling region, it stops at the bottom of the
 *				screen.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void emuDecCUD(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	int nlines,
		row,
		fSourceIsDbl,
		fDestIsDbl,
		iCol;

	nlines = hhEmu->num_param[hhEmu->num_param_cnt];

	if (nlines < 1)
		nlines = 1;

	row = hhEmu->emu_currow;
	row += nlines;

	fSourceIsDbl = (pstPRI->aiLineAttr[row_index(hhEmu, hhEmu->emu_currow)] == NO_LINE_ATTR)
					? FALSE : TRUE;
	fDestIsDbl = (pstPRI->aiLineAttr[row_index(hhEmu, hhEmu->emu_currow + nlines)] == NO_LINE_ATTR)
					? FALSE : TRUE;

	iCol = hhEmu->emu_curcol;

	// The following code adjusts the column value for double wide
	// characters.
	//
	if (fSourceIsDbl == fDestIsDbl) 	// Both the same
		iCol = iCol;
	else if (fSourceIsDbl)				// Source is double, dest is single.
		iCol = iCol / 2;
	else								// Source is singel, dest is double.
		iCol = iCol * 2;

	if (row > hhEmu->bottom_margin &&
				(hhEmu->emu_currow <= hhEmu->bottom_margin || hhEmu->emu_currow > hhEmu->emu_maxrow))
		row = hhEmu->bottom_margin;

	(*hhEmu->emu_setcurpos)(hhEmu, row, iCol);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecSetCurPos
 *
 * DESCRIPTION:
 *	 Moves the cursor to the specified position on the virtual screen.
 *	 If the cursor is beyond the end of existing text, the virtual screen
 *	 line is filled out with spaces. If the cursor is beyond the edges of
 *	 the video display, the video cursor is placed as close as possible
 *	 to the desired position as the cursor display is changed.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *	 nothing
 */
void emuDecSetCurPos(const HHEMU hhEmu, const int iRow, const int iCol)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	int iTempCol;
	int i;

	// If we  move the cursor, we need to clear the pstPRI->fDecHoldFlag;
	//
	pstPRI->fDecColHold = FALSE;

	hhEmu->emu_currow = max(min(iRow, hhEmu->emu_maxrow), 0);
	hhEmu->emu_curcol = max(min(iCol, hhEmu->emu_maxcol), 0);

	iTempCol = hhEmu->emu_curcol;

	// If the row is a double wide character row, don't ever let the
	// cursor land on an odd column number.  If it's there now, back
	// it up one.
	//
	i = row_index(hhEmu, hhEmu->emu_currow);

	if (pstPRI->aiLineAttr[i])
		{
		if (iTempCol  % 2 == 1)
			{
			iTempCol -= 1;
			}
		}

	updateCursorPos(sessQueryUpdateHdl(hhEmu->hSession), iRow, iTempCol);
	hhEmu->emu_imgrow = row_index(hhEmu, hhEmu->emu_currow);
	return;
#if 0
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	int iTempCol;

	hhEmu->emu_currow = max(min(iRow, hhEmu->emu_maxrow), 0);
	hhEmu->emu_curcol = max(min(iCol, hhEmu->emu_maxcol), 0);

	iTempCol = hhEmu->emu_curcol;

	// Do range checking for DEC emulation.  This prevents the cursor
	// from being displayed in the 81st position, which is a valid
	// internal location, but is not a valid display column.
	//
	if (hhEmu->emu_curcol == hhEmu->emu_maxcol &&
		    (hhEmu->stUserSettings.nEmuId == EMU_VT100 ||
		     hhEmu->stUserSettings.nEmuId == EMU_VT100J))
        {
		iTempCol -= 1;
		}

	// If the row is a double wide character row, don't ever let the
	// cursor land on an odd column number.  If it's there now, back
	// it up one.
	//
	if (pstPRI->aiLineAttr[row_index(hhEmu, hhEmu->emu_currow)])
		{
		if (iTempCol  % 2 == 1)
			{
			iTempCol -= 1;
			}
		}

	updateCursorPos(sessQueryUpdateHdl(hhEmu->hSession), iRow, iTempCol);

	hhEmu->emu_imgrow = row_index(hhEmu, hhEmu->emu_currow);
	return;
#endif
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecClearScreen
 *
 * DESCRIPTION:
 *	 Erases some or all of the virtual screen image.
 *
 * ARGUMENTS:
 *	 select -- 0 to erase from cursor to end of screen
 *			-- 1 to erase from start of screen to cursor
 *			-- 2 to erase entire screen
 *
 * RETURNS:
 *	 nothing
 */
void emuDecClearScreen(const HHEMU hhEmu, const int nClearSelect)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;
	ECHAR aechBuf[10];
	register int r;
	int trow, tcol;
	PSTATTR pstAttr;
	BOOL fSave;

	trow = hhEmu->emu_currow;
	tcol = hhEmu->emu_curcol;

	switch (nClearSelect)
		{
	/* cursor to end of screen */
	case 0:
		fSave = (hhEmu->emu_currow == 0  &&
					hhEmu->emu_curcol == 0) ? TRUE : FALSE;

		for (r = hhEmu->emu_currow + (fSave ? 0 : 1) ; r < MAX_EMUROWS; ++r)
			{
			if (fSave)
				{
				backscrlAdd(sessQueryBackscrlHdl(hhEmu->hSession),
							hhEmu->emu_apText[row_index(hhEmu, r)],
							hhEmu->emu_maxcol+1);

				CaptureLine(sessQueryCaptureFileHdl(hhEmu->hSession),
									CF_CAP_SCREENS,
									hhEmu->emu_apText[row_index(hhEmu, r)],
									emuRowLen(hhEmu, row_index(hhEmu, r)));

				printEchoScreen(hhEmu->hPrintEcho,
									hhEmu->emu_apText[row_index(hhEmu, r)],
									emuRowLen(hhEmu, row_index(hhEmu, r)));

				CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), TEXT("\r\n"), 
								 StrCharGetByteCount(TEXT("\r\n")));
				printEchoScreen(hhEmu->hPrintEcho,
									aechBuf,
									sizeof(ECHAR) * 2);
				}

			clear_imgrow(hhEmu, r);

			pstPRI->aiLineAttr[row_index(hhEmu, r)] = NO_LINE_ATTR;
			}

		// Clear the partial row now.
		//
		ECHAR_Fill(hhEmu->emu_apText[row_index(hhEmu, hhEmu->emu_currow)] +
						hhEmu->emu_curcol,
						EMU_BLANK_CHAR,
						(size_t)(MAX_EMUCOLS - hhEmu->emu_curcol + 1));

		if (hhEmu->emu_curcol <= hhEmu->emu_aiEnd[hhEmu->emu_imgrow])
			hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = hhEmu->emu_curcol - 1;

		pstAttr = hhEmu->emu_apAttr[row_index(hhEmu, hhEmu->emu_currow)];

		for (r = hhEmu->emu_curcol ; r < MAX_EMUCOLS ; ++r)
			pstAttr[r] = hhEmu->emu_clearattr;

		// Tell the video image what to do.  Use the emuDispRgnScrollUp() call
		// instead of RgnClear so edges of terminal get painted if
		// clear attribute changes.

		updateScroll(sessQueryUpdateHdl(hhEmu->hSession),
						0,
						hhEmu->emu_maxrow,
						hhEmu->emu_maxrow + 1,
						hhEmu->emu_imgtop,
						TRUE);

		(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, hhEmu->emu_curcol);

		// Added a global to save the clear attribute at the time of
		// notification.  This is necessary since the message is posted
		// and a race condition can develop.

		hhEmu->emu_clearattr_sav = hhEmu->emu_clearattr;

		NotifyClient(hhEmu->hSession, EVENT_EMU_CLRATTR, 0);
		break;


	/* start of screen to cursor */

	case 1:
		for (r = 0; r < hhEmu->emu_currow; ++r)
			{
			clear_imgrow(hhEmu, r);

			pstPRI->aiLineAttr[row_index(hhEmu, r)] = NO_LINE_ATTR;
			}

		ECHAR_Fill(hhEmu->emu_apText[row_index(hhEmu, hhEmu->emu_currow)],
					EMU_BLANK_CHAR,
			  		(size_t)(hhEmu->emu_curcol + 1));

		if (hhEmu->emu_curcol >= hhEmu->emu_aiEnd[hhEmu->emu_imgrow])
			hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = EMU_BLANK_LINE;

		pstAttr = hhEmu->emu_apAttr[row_index(hhEmu, hhEmu->emu_currow)];

		for (r = 0 ; r <= hhEmu->emu_curcol ; ++r)
			pstAttr[r] = hhEmu->emu_clearattr;

		(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, hhEmu->emu_curcol);

		updateLine(sessQueryUpdateHdl(hhEmu->hSession), 0, hhEmu->emu_currow);
		break;

	/* Entire screen */
	case 2:
		for (r = 0; r < MAX_EMUROWS; ++r)
			{
			backscrlAdd(sessQueryBackscrlHdl(hhEmu->hSession),
							hhEmu->emu_apText[row_index(hhEmu, r)],
							hhEmu->emu_maxcol+1);

			CaptureLine(sessQueryCaptureFileHdl(hhEmu->hSession),
							CF_CAP_SCREENS,
							hhEmu->emu_apText[row_index(hhEmu, r)],
							emuRowLen(hhEmu, row_index(hhEmu, r)));

			printEchoScreen(hhEmu->hPrintEcho,
							hhEmu->emu_apText[row_index(hhEmu, r)],
							emuRowLen(hhEmu, row_index(hhEmu, r)));

			CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), TEXT("\r\n"), 
							 StrCharGetByteCount(TEXT("\r\n")));
			printEchoScreen(hhEmu->hPrintEcho,
							aechBuf,
							sizeof(ECHAR) * 2);

			clear_imgrow(hhEmu, r);

			pstPRI->aiLineAttr[r] = NO_LINE_ATTR;
			}

		updateScroll(sessQueryUpdateHdl(hhEmu->hSession),
						0,
						hhEmu->emu_maxrow,
						hhEmu->emu_maxrow + 1,
						hhEmu->emu_imgtop,
						TRUE);


		// Save the clear attribute at the time of
		// notification.  This is necessary since the message is posted
		// and a race condition can develop.

		hhEmu->emu_clearattr_sav = hhEmu->emu_clearattr;

		NotifyClient(hhEmu->hSession, EVENT_EMU_CLRATTR, 0);
		break;

	default:
		commanderror(hhEmu);
		}

	(*hhEmu->emu_setcurpos)(hhEmu, trow, tcol);
	}


/* end of vt100.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\viewdini.c ===
/*	File: D:\WACKER\emu\viewdini.c (Created: 31-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:28p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\mc.h>
#include <tdll\assert.h>
#include <tdll\backscrl.h>
#include <tdll\htchar.h>
#include <tdll\term.h>
#include "emu.h"
#include "emu.hh"
#include "viewdata.hh"

#if defined(INCL_VIEWDATA)
#define MAX_ROWS 24

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataInit
 *
 * DESCRIPTION:	Performs the initialization of the Viewdata emulator that
 *              is common to DOS and OS2.
 *
 * ARGUMENTS:   ehdl -- handle the emulator session
 *
 * RETURNS:		nothing
 */
void EmuViewdataInit(const HHEMU hhEmu)
	{
	int i;
	LOGFONT lf;
	HWND hwndTerm;
	PSTVIEWDATAPRIVATE pstPRI;

	static struct trans_entry const astfViewdataTable[] =
	{
	{NEW_STATE, 0, 0, 0}, // State 0
	{0, ETEXT('\x20'),	ETEXT('\x7F'),	EmuViewdataCharDisplay},	// All
	{1, ETEXT('\x1B'),	ETEXT('\x1B'),	nothing},					// Esc
	{0, ETEXT('\x05'),	ETEXT('\x05'),	EmuViewdataAnswerback}, 	// Ctrl-E
	{0, ETEXT('\x08'),	ETEXT('\x08'),	EmuViewdataCursorLeft}, 	// Backspace
	{0, ETEXT('\x09'),	ETEXT('\x09'),	EmuViewdataCursorRight},	// Tab
	{0, ETEXT('\x0A'),	ETEXT('\x0A'),	EmuViewdataCursorDown}, 	// New Line
	{0, ETEXT('\x0B'),	ETEXT('\x0B'),	EmuViewdataCursorUp},		// VT
	{0, ETEXT('\x0C'),	ETEXT('\x0C'),	EmuViewdataClearScreen},	// Form Feed
	{0, ETEXT('\x0D'),	ETEXT('\x0D'),	carriagereturn},			// CR
	{0, ETEXT('\x11'),	ETEXT('\x11'),	EmuViewdataCursorSet},		// Ctrl-Q
	{0, ETEXT('\x14'),	ETEXT('\x14'),	EmuViewdataCursorSet},		// Ctrl-T
	{0, ETEXT('\x1E'),	ETEXT('\x1E'),	EmuViewdataCursorHome}, 	// Ctrl-^
	{0, ETEXT('\x80'),	ETEXT('\xFF'),	EmuChkChar},				// Upper Ascii

	{NEW_STATE, 0, 0, 0}, // State 1								// Esc
	{0, ETEXT('\x31'),	ETEXT('\x37'),	nothing},					// 1 - 7
	{0, ETEXT('\x41'),	ETEXT('\x49'),	EmuViewdataSetAttr},		// A - I
	{0, ETEXT('\x4C'),	ETEXT('\x4D'),	EmuViewdataSetAttr},		// L - M
	{0, ETEXT('\x51'),	ETEXT('\x5A'),	EmuViewdataSetAttr},		// Q - Z
	{0, ETEXT('\x5C'),	ETEXT('\x5D'),	EmuViewdataSetAttr},		// \ - ]
	{0, ETEXT('\x5E'),	ETEXT('\x5E'),	EmuViewdataMosaicHold}, 	// ^
	{0, ETEXT('\x5F'),	ETEXT('\x5F'),	EmuViewdataMosaicRelease},	// _
	};

	emuInstallStateTable(hhEmu, astfViewdataTable, DIM(astfViewdataTable));

	// Allocate and initialize private data for viewdata emulator.
	//
	if (hhEmu->pvPrivate != 0)
		{
		free(hhEmu->pvPrivate);
		hhEmu->pvPrivate = 0;
		}

	hhEmu->pvPrivate = malloc(sizeof(VIEWDATAPRIVATE));

	if (hhEmu->pvPrivate == 0)
		{
		assert(FALSE);
		return;
		}

	pstPRI = (PSTVIEWDATAPRIVATE)hhEmu->pvPrivate;
	pstPRI->aMapColors[0] = 4;
	pstPRI->aMapColors[1] = 2;
	pstPRI->aMapColors[2] = 6;
	pstPRI->aMapColors[3] = 1;
	pstPRI->aMapColors[4] = 5;
	pstPRI->aMapColors[5] = 3;
	pstPRI->aMapColors[6] = 15;

	/* --- Allocate attribute buffer for View Data junk --- */

	pstPRI->apstVD = malloc(MAX_EMUROWS * sizeof(PSTVIEWDATA));

	if (pstPRI->apstVD == 0)
		{
		assert(FALSE);
		return;
		}

	memset(pstPRI->apstVD, 0, MAX_EMUROWS * sizeof(PSTVIEWDATA));

	for (i = 0 ; i < MAX_EMUROWS ; ++i)
		{
		pstPRI->apstVD[i] = malloc(VIEWDATA_COLS_40MODE * sizeof(STVIEWDATA));

		if (pstPRI->apstVD[i] == 0)
			{
			assert(FALSE);
			return;
			}

		memset(pstPRI->apstVD[i], 0, sizeof(STVIEWDATA));
		}

	/* --- functions specific to prestel (viewdata) --- */

	hhEmu->emuResetTerminal = EmuViewdataReset;
	hhEmu->emu_deinstall = EmuViewdataDeinstall;

	hhEmu->emu_kbdin   = EmuViewdataKbd;
	hhEmu->emu_graphic = EmuViewdataCharDisplay;

	hhEmu->emu_highchar = ETEXT('\x7F');
	hhEmu->emu_maxcol = VIEWDATA_COLS_40MODE - 1;

	// Also, set font to Arial Alternative
	//
	memset(&lf, 0, sizeof(LOGFONT));
	hwndTerm = sessQueryHwndTerminal(hhEmu->hSession);
	termGetLogFont(hwndTerm, &lf);

	if (StrCharCmpi(lf.lfFaceName, "Arial Alternative") != 0)
		{
		StrCharCopy(lf.lfFaceName, "Arial Alternative");
		lf.lfCharSet = DEFAULT_CHARSET;
		lf.lfPitchAndFamily = FIXED_PITCH | FF_MODERN;
		termSetLogFont(hwndTerm, &lf);
		}

	EmuViewdataReset(hhEmu, FALSE);
	std_setcolors(hhEmu, VC_BRT_WHITE, VC_BLACK);

	// Turn backscroll off for Prestel
	//
	backscrlSetShowFlag(sessQueryBackscrlHdl(hhEmu->hSession), FALSE);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	EmuViewdataDeinstall
 *
 * DESCRIPTION:
 *	Frees up buffers allocated for view data junk.
 *
 * ARGUMENTS:
 *	fQuitting	- because other funcs have it.
 *
 * RETURNS:
 *	void
 *
 */
void EmuViewdataDeinstall(const HHEMU hhEmu)
	{
	int i;
	const PSTVIEWDATAPRIVATE pstPRI = (PSTVIEWDATAPRIVATE)hhEmu->pvPrivate;
	assert(hhEmu);

	if (pstPRI)
		{
		if (pstPRI->apstVD)
			{
			for (i = 0 ; i < 24 ; ++i)
				{
				if (pstPRI->apstVD[i])
					{
					free(pstPRI->apstVD[i]);
					pstPRI->apstVD[i] =NULL;
					}
				}

			free(pstPRI->apstVD);
			pstPRI->apstVD = NULL;
			}

		free(hhEmu->pvPrivate);
		hhEmu->pvPrivate = 0;
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataReset
 *
 * DESCRIPTION:	Sets the viewdata emulator to the proper conditions when
 *				starting up.
 *
 * ARGUMENTS:	ehdl -- emu handle
 *
 * RETURNS:		nothing
 */
/* ARGSUSED */
int EmuViewdataReset(const HHEMU hhEmu, int const fHost)
	{
	hhEmu->top_margin = 0;
	hhEmu->bottom_margin = MAX_ROWS-1;

	hhEmu->mode_KAM = hhEmu->mode_IRM = hhEmu->mode_VEM =
	hhEmu->mode_HEM = hhEmu->mode_DECCKM = hhEmu->mode_DECOM =
	hhEmu->mode_DECCOLM = hhEmu->mode_DECPFF = hhEmu->mode_DECPEX =
	hhEmu->mode_DECSCNM = hhEmu->mode_25enab =
	hhEmu->mode_protect = hhEmu->mode_block = hhEmu->mode_local = RESET;

	hhEmu->mode_SRM = hhEmu->mode_LNM = hhEmu->mode_DECTCEM = SET;

	hhEmu->mode_AWM = TRUE;

	emu_cleartabs(hhEmu, 3);
	return 0;
	}

#endif // INCL_VIEWDATA
/************************* end of viewdini.c **************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\viewdata.hh ===
/* viewdata.hh -- Common definitions for HyperACCESS/5 Viewdata
 *					 terminal emualation routines
 *
 *	Copyright 1990 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:28p $
 */

/* maxcol definitions */

#define VIEWDATA_COLS_40MODE	40

/* attribute definitions */

#define ALPHA_ATTR		0x01
#define MOSAIC_ATTR 	0x02
#define CONTIGUOUS_ATTR 0x03
#define SEPARATED_ATTR	0x04
#define NORMALSIZE_ATTR 0x05
#define FLASH_ATTR		0x06
#define STEADY_ATTR 	0x07
#define NEW_BACKGROUND_ATTR 0x08
#define DOUBLESIZE_ATTR 0x09
#define CONCEAL_ATTR    0x0A

/* --- view datat attribute structure --- */

typedef struct _viewdata
	{
	unsigned int attr	 : 4;	   // attribute type
	unsigned int clr	 : 4;	   // color if attribute type is color
	unsigned int smosaic : 1;	   // separated mosaics
	unsigned int cmosaic : 1;	   // contigous mosaics
	//unsigned int dblsiz  : 1;	   // double size
	} STVIEWDATA;

typedef STVIEWDATA *PSTVIEWDATA;

// Private emulator data for Viewdata.
//
typedef struct stPrivateViewdata
	{
	PSTVIEWDATA *apstVD;

	int fMosaicMode,
		fSeperatedMosaic,
		fSetAttr;

	unsigned aMapColors[7];

	} VIEWDATAPRIVATE;

typedef VIEWDATAPRIVATE *PSTVIEWDATAPRIVATE;

/* --- viewdini.c --- */

void	  EmuViewdataInit(const HHEMU hhEmu);
void	  EmuViewdataDeinstall(const HHEMU hhEmu);

/* --- viewdata.c --- */
void	  EmuViewdataAnswerback(const HHEMU hhEmu);
void	  EmuViewdataCursorLeft(const HHEMU hhEmu);
void	  EmuViewdataCursorRight(const HHEMU hhEmu);
void	  EmuViewdataCursorDown(const HHEMU hhEmu);
void	  EmuViewdataCursorUp(const HHEMU hhEmu);
void	  EmuViewdataCursorHome(const HHEMU hhEmu);
void	  EmuViewdataCursorSet(const HHEMU hhEmu);
void	  EmuViewdataSetAttr(const HHEMU hhEmu);
void	  EmuViewdataMosaicSet(const HHEMU hhEmu);
void	  EmuViewdataMosaicHold(const HHEMU hhEmu);
void	  EmuViewdataMosaicRelease(const HHEMU hhEmu);
void	  EmuViewdataCharDisplay(const HHEMU hhEmu);
int 	  EmuViewdataReset(const HHEMU hhEmu, int const fHost);

int 	  EmuViewdataKbd(const HHEMU hhEmu, int kcode, const BOOL fTest);
int 	  emuViewdataPadAttrStr(const HHEMU hhEmu, int iRow, const int iCol, const TCHAR tchar);
void	  EmuViewdataClearScreen(const HHEMU hhEmu);

/**************************** end of viewdata.hh ***************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\vt220ini.c ===
/*	File: \wacker\emu\vt220ini.c (Created: 24-Jan-1998)
 *
 *	Copyright 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:28p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\assert.h>
#include <tdll\mc.h>
#include <tdll\backscrl.h>

#include "emu.h"
#include "emu.hh"
#include "emuid.h"
#include "emudec.hh"
#include "keytbls.h"

#if defined(INCL_VT220)

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt220_init
 *
 * DESCRIPTION:
 *	 Initializes the VT220 emulator.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *	 nothing
 */
void vt220_init(const HHEMU hhEmu)
	{
	PSTDECPRIVATE pstPRI;
	int iRow;

	static struct trans_entry const vt220_tbl[] =
		{
		{NEW_STATE, 0, 0, 0}, // State 0
#if !defined(FAR_EAST)	// Left in from the VT100.
		{0, ETEXT('\x20'),	ETEXT('\x7E'),	emuDecGraphic}, 	// Space - ~
		{0, ETEXT('\xA0'),	ETEXT('\xFF'),	emuDecGraphic}, 	// 
#else
		{0, ETEXT('\x20'),	ETEXT('\x7E'),	emuDecGraphic}, 	// Space - ~
		{0, ETEXT('\xA0'),	0xFFFF,			emuDecGraphic}, 	// 
#endif

		{1, ETEXT('\x1B'),	ETEXT('\x1B'),	nothing},			// Esc
		{2, ETEXT('\x9B'),	ETEXT('\x9B'),	nothing},			// CSI

		// 7 bit control codes
//		{13,TEXT('\x01'),   ETEXT('\x01'),   nothing},			// Ctrl-A
		{0, ETEXT('\x05'),	ETEXT('\x05'),	vt100_answerback},	// Ctrl-E
		{0, ETEXT('\x07'),	ETEXT('\x07'),	emu_bell},			// Ctrl-G
		{0, ETEXT('\x08'),	ETEXT('\x08'),	vt_backspace},		// BackSpace
		{0, ETEXT('\x09'),	ETEXT('\x09'),	emuDecTab}, 		// Tab
		{0, ETEXT('\x0A'),	ETEXT('\x0C'),	emuLineFeed},		// NL - FF
		{0, ETEXT('\x0D'),	ETEXT('\x0D'),	carriagereturn},	// CR
		{0, ETEXT('\x0E'),	ETEXT('\x0F'),	vt_charshift},		// Ctrl-N, Ctrl-O
		{12,ETEXT('\x18'),	ETEXT('\x18'),	EmuStdChkZmdm}, 	// Ctrl-X

		// 8 bit control codes
		{0, ETEXT('\x84'),	ETEXT('\x84'),	emuDecIND}, 		// Index cursor
		{0, ETEXT('\x85'),	ETEXT('\x85'),	ANSI_NEL}, 			// Next line
		{0, ETEXT('\x88'),	ETEXT('\x88'),	ANSI_HTS}, 			// Set Horizontal Tab
		{0, ETEXT('\x8D'),	ETEXT('\x8D'),	emuDecRI}, 			// Reverse index
		{0, ETEXT('\x8E'),	ETEXT('\x8F'),	vt_charshift}, 		// SingleShift G2,G3
		{5, ETEXT('\x90'),	ETEXT('\x90'),	nothing}, 			// Device Control String (DCS)

		// Ignore these codes. They just show what functionality is still missing.
		{0, ETEXT('\x00'),	ETEXT('\x00'),	nothing},			// ignore nuls
		{0, ETEXT('\x1A'),	ETEXT('\x1A'),	nothing},			// ignore Substitute
		{0, ETEXT('\x7F'),	ETEXT('\x7F'),	nothing},			// ignore Delete
		{0, ETEXT('\x9C'),	ETEXT('\x9C'),	nothing},			// ignore String Terminator


		{NEW_STATE, 0, 0, 0},   // State 1						// Esc
		{2, ETEXT('\x5B'),  ETEXT('\x5B'),  ANSI_Pn_Clr},		// '['
		{7, ETEXT('\x20'),  ETEXT('\x20'),  nothing},			// Space
		{3, ETEXT('\x23'),  ETEXT('\x23'),  nothing},			// #
		{4, ETEXT('\x28'),  ETEXT('\x2B'),  vt_scs1},			// ( - +
		{0, ETEXT('\x37'),  ETEXT('\x38'),  vt100_savecursor},  // 8
		{1, ETEXT('\x3B'),  ETEXT('\x3B'),  ANSI_Pn_End},		// ;
		{0, ETEXT('\x3D'),  ETEXT('\x3E'),  vt_alt_kpmode},		// = - >
		{0, ETEXT('\x44'),  ETEXT('\x44'),  emuDecIND},			// D
		{0, ETEXT('\x45'),  ETEXT('\x45'),  ANSI_NEL},			// E
		{0, ETEXT('\x48'),  ETEXT('\x48'),  ANSI_HTS},			// H
		{0, ETEXT('\x4D'),  ETEXT('\x4D'),  emuDecRI},			// M
		{0, ETEXT('\x4E'),  ETEXT('\x4F'),  vt_charshift},		// N - O
		{5, ETEXT('\x50'),  ETEXT('\x50'),  nothing},			// P
		{0, ETEXT('\x5A'),  ETEXT('\x5A'),  vt220_DA},			// Z
		{0, ETEXT('\\'),	ETEXT('\\'),	nothing},			// Backslash
		{0, ETEXT('\x63'),  ETEXT('\x63'),  vt220_hostreset},   // c
		{0, ETEXT('\x6E'),  ETEXT('\x6F'),  vt_charshift},		// n - o
		{0, ETEXT('\x7D'),  ETEXT('\x7E'),  vt_charshift},		// } - ~

		{NEW_STATE, 0, 0, 0},   // State 2						// ESC [
		{8, ETEXT('\x21'),  ETEXT('\x21'),  nothing},			// !
		{2, ETEXT('\x3B'),  ETEXT('\x3B'),  ANSI_Pn_End},		// ;
		{9, ETEXT('\x3E'),  ETEXT('\x3E'),  nothing},			// >
		{2, ETEXT('\x30'),  ETEXT('\x3F'),  ANSI_Pn},			// 0 - ?
		{11,ETEXT('\x22'),  ETEXT('\x22'),  nothing},			// "
//		{16,ETEXT('\x24'),  ETEXT('\x24'),  nothing},			// $
		{2, ETEXT('\x27'),  ETEXT('\x27'),  nothing},			// Eat Esc [ m ; m ; ' z
		{0, ETEXT('\x40'),  ETEXT('\x40'),  ANSI_ICH},			// @
		{0, ETEXT('\x41'),  ETEXT('\x41'),  emuDecCUU},			// A
		{0, ETEXT('\x42'),  ETEXT('\x42'),  emuDecCUD},			// B
		{0, ETEXT('\x43'),  ETEXT('\x43'),  emuDecCUF},			// C
		{0, ETEXT('\x44'),  ETEXT('\x44'),  emuDecCUB},			// D
		{0, ETEXT('\x48'),  ETEXT('\x48'),  emuDecCUP},			// H
		{0, ETEXT('\x4A'),  ETEXT('\x4A'),  emuVT220ED},		// J
		{0, ETEXT('\x4B'),  ETEXT('\x4B'),  emuDecEL},			// K
		{0, ETEXT('\x4C'),  ETEXT('\x4C'),  vt_IL},				// L
		{0, ETEXT('\x4D'),  ETEXT('\x4D'),  vt_DL},				// M
		{0, ETEXT('\x50'),  ETEXT('\x50'),  vt_DCH},			// P
		{0, ETEXT('\x58'),  ETEXT('\x58'),  vt_DCH},			// X
		{0, ETEXT('\x63'),  ETEXT('\x63'),  vt220_DA},			// c
		{0, ETEXT('\x66'),  ETEXT('\x66'),  emuDecCUP},			// f
		{0, ETEXT('\x67'),  ETEXT('\x67'),  ANSI_TBC},			// g
		{0, ETEXT('\x68'),  ETEXT('\x68'),  ANSI_SM},			// h
		{0, ETEXT('\x69'),  ETEXT('\x69'),  vt100PrintCommands},// i
		{0, ETEXT('\x6C'),  ETEXT('\x6C'),  ANSI_RM},			// l
		{0, ETEXT('\x6D'),  ETEXT('\x6D'),  ANSI_SGR},			// m
		{0, ETEXT('\x6E'),  ETEXT('\x6E'),  ANSI_DSR},			// n
		{0, ETEXT('\x71'),  ETEXT('\x71'),  nothing},			// q
		{0, ETEXT('\x72'),  ETEXT('\x72'),  vt_scrollrgn},		// r
		{0, ETEXT('\x75'),  ETEXT('\x75'),  nothing},			// u
		{0, ETEXT('\x79'),  ETEXT('\x79'),  nothing},			// y
		{0, ETEXT('\x7A'),  ETEXT('\x7A'),  nothing},			// z

		{NEW_STATE, 0, 0, 0},   // State 3						// Esc #
		{0, ETEXT('\x33'),  ETEXT('\x36'),  emuSetDoubleAttr},  // 3 - 6
		{0, ETEXT('\x38'),  ETEXT('\x38'),  vt_screen_adjust},  // 8

		{NEW_STATE, 0, 0, 0},   // State 4						// Esc ( - +
		{0, ETEXT('\x01'),  ETEXT('\xFF'),  vt_scs2},			// All

		{NEW_STATE, 0, 0, 0},   // State 5						// Esc P
		{5, ETEXT('\x3B'),  ETEXT('\x3B'),  ANSI_Pn_End},		// ;
		{5, ETEXT('\x30'),  ETEXT('\x3F'),  ANSI_Pn},			// 0 - ?
		{10,ETEXT('\x7C'),  ETEXT('\x7C'),  emuDecClearUDK},	// |

		{NEW_STATE, 0, 0, 0},   // State 6
		{6, ETEXT('\x00'),  ETEXT('\xFF'),  vt100_prnc},		// All

		{NEW_STATE, 0, 0, 0},   // State 7						// Esc Sapce
		{0, ETEXT('\x46'),  ETEXT('\x47'),  nothing},			// F - G

		{NEW_STATE, 0, 0, 0},   // State 8						// Esc [ !
		{0, ETEXT('\x70'),  ETEXT('\x70'),  vt220_softreset},   // p

		{NEW_STATE, 0, 0, 0},   // State 9						// Esc [ >
		{0, ETEXT('\x63'),  ETEXT('\x63'),  vt220_2ndDA},		// c

		{NEW_STATE, 0, 0, 0},   // State 10						// Esc P n;n |
		{10,ETEXT('\x00'),  ETEXT('\xFF'),  emuDecDefineUDK},   // All

		{NEW_STATE, 0, 0, 0},   // State 11						// Esc [ "
		{0, ETEXT('\x70'),  ETEXT('\x70'),  vt220_level},		// p
		{0, ETEXT('\x71'),  ETEXT('\x71'),  vt220_protmode},	// q

		{NEW_STATE, 0, 0, 0},   // State 12						// Ctrl-X
		{12,ETEXT('\x00'),  ETEXT('\xFF'),  EmuStdChkZmdm},		// All

		// States 13-17 are not used in HT but included for reference. 
//		{NEW_STATE, 0, 0, 0},   // State 13						// Ctrl-A
//		{14,ETEXT('\x08'),  ETEXT('\x08'),  emuSerialNbr},		// Backspace
//		{15,ETEXT('\x48'),  ETEXT('\x48'),  EmuStdChkHprP},		// H

//		{NEW_STATE, 0, 0, 0},   // State 14						// Ctrl-A bs
//		{14,ETEXT('\x00'),  ETEXT('\xFF'),  emuSerialNbr},		// All

//		{NEW_STATE, 0, 0, 0},   // State 15						// Ctrl-A H
//		{15,ETEXT('\x00'),  ETEXT('\xFF'),  EmuStdChkHprP},		// All

		// A real VT220/320 does not support the status line sequences.
//		{NEW_STATE, 0, 0, 0},   // State 16								// Esc [ n $
//		{16,ETEXT('\x7E'),  ETEXT('\x7E'),  emuDecSelectStatusLine},	// ~
//		{17,ETEXT('\x7D'),  ETEXT('\x7D'),  emuDecSelectActiveDisplay}, // }

//		{NEW_STATE, 0, 0, 0},   // State 17
//		{17,ETEXT('\x00'),  ETEXT('\xFF'),  emuDecStatusLineToss},  // All

		};

	// The following key tables were copied from \shared\emulator\vt220ini.c  
	// because they support user-defined keys. The tables have been modified 
	// so keydef.h is not needed and to match HT's use of keys. rde 2 Feb 98

	// The following key tables are defined in the order that they
	// are searched.
	//

	// These are the (standard) F1 thru F4 keys on the top and left of the
	// keyboard.  Note that these keys may be mapped to the top row of the
	// numeric keypad.  In that case, these keys (at the standard locations),
	// are not mapped to emulator keys. NOTE: HTPE does not use this mapping.
	//
	// Please note that the sequences defined in this table are the
	// 8-bit versions of the responses.  The function emuDecSendKeyString
	// will convert this sequence to the 7-bit equivalent if necessary.
	//
	static  STEMUKEYDATA const VT220StdPfKeyTable[] =
		{
		EMUKEY(VK_F1,		1, 0, 0, 0, 0,  "\x8F\x50",			2), // P
		EMUKEY(VK_F2,		1, 0, 0, 0, 0,  "\x8F\x51",			2), // Q
		EMUKEY(VK_F3,		1, 0, 0, 0, 0,  "\x8F\x52",			2), // R
		EMUKEY(VK_F4,		1, 0, 0, 0, 0,  "\x8F\x53",			2), // S

		EMUKEY(VK_F1,		1, 0, 0, 0, 1,  "\x8F\x50",			2), // P
		EMUKEY(VK_F2,		1, 0, 0, 0, 1,  "\x8F\x51",			2), // Q
		EMUKEY(VK_F3,		1, 0, 0, 0, 1,  "\x8F\x52",			2), // R
		EMUKEY(VK_F4,		1, 0, 0, 0, 1,  "\x8F\x53",			2), // S
		};

	// When the user has selected the option to map the top 4 keys of the
	// numeric keypad to be the same as F1 thru F4, these key sequences are
	// used. NOTE: This is the mapping HTPE uses.
	//
	// Please note that the sequences defined in this table are the
	// 8-bit versions of the responses.  The function emuDecSendKeyString
	// will convert this sequence to the 7-bit equivalent if necessary.
	//
	static  STEMUKEYDATA const VT220MovedPfKeyTable[] =
		{
		EMUKEY(VK_NUMLOCK,	1, 0, 0, 0, 1,  "\x8F\x50",			2), // P
		EMUKEY(VK_DIVIDE,	1, 0, 0, 0, 1,  "\x8F\x51",			2), // Q
		EMUKEY(VK_MULTIPLY,	1, 0, 0, 0, 1,  "\x8F\x52",			2), // R
		EMUKEY(VK_SUBTRACT,	1, 0, 0, 0, 1,  "\x8F\x53",			2), // S
		};

	// VT220 Keypad Numeric Mode.
	//
	static STEMUKEYDATA const VT220KeypadNumericMode[] =
		{
		// Keypad keys with Numlock off.
		//
		EMUKEY(VK_INSERT,	1, 0, 0, 0, 0,  "\x30",			1), // 0
		EMUKEY(VK_END,		1, 0, 0, 0, 0,  "\x31",			1), // 1
		EMUKEY(VK_DOWN,		1, 0, 0, 0, 0,  "\x32",			1), // 2
		EMUKEY(VK_NEXT,		1, 0, 0, 0, 0,  "\x33",			1), // 3
		EMUKEY(VK_LEFT,		1, 0, 0, 0, 0,  "\x34",			1), // 4
		EMUKEY(VK_NUMPAD5,	1, 0, 0, 0, 0,  "\x35",			1), // 5
		EMUKEY(VK_RIGHT,	1, 0, 0, 0, 0,  "\x36",			1), // 6
		EMUKEY(VK_HOME,		1, 0, 0, 0, 0,  "\x37",			1), // 7
		EMUKEY(VK_UP,		1, 0, 0, 0, 0,  "\x38",			1), // 8
		EMUKEY(VK_PRIOR,	1, 0, 0, 0, 0,  "\x39",			1), // 9
		EMUKEY(VK_DELETE,	1, 0, 0, 0, 0,  "\x2E",			1), // .

		// Keypad keys with Numlock on.
		//
		EMUKEY(VK_NUMPAD0,		1, 0, 0, 0, 0,  "\x30",			1), // 0
		EMUKEY(VK_NUMPAD1,		1, 0, 0, 0, 0,  "\x31",			1), // 1
		EMUKEY(VK_NUMPAD2,		1, 0, 0, 0, 0,  "\x32",			1), // 2
		EMUKEY(VK_NUMPAD3,		1, 0, 0, 0, 0,  "\x33",			1), // 3
		EMUKEY(VK_NUMPAD4,		1, 0, 0, 0, 0,  "\x34",			1), // 4
		EMUKEY(VK_NUMPAD5,		1, 0, 0, 0, 0,  "\x35",			1), // 5
		EMUKEY(VK_NUMPAD6,		1, 0, 0, 0, 0,  "\x36",			1), // 6
		EMUKEY(VK_NUMPAD7,		1, 0, 0, 0, 0,  "\x37",			1), // 7
		EMUKEY(VK_NUMPAD8,		1, 0, 0, 0, 0,  "\x38",			1), // 8
		EMUKEY(VK_NUMPAD9,		1, 0, 0, 0, 0,  "\x39",			1), // 9
		EMUKEY(VK_DECIMAL,		1, 0, 0, 0, 0,  "\x2E",			1), // .

		// Other keypad keys (minus, plus, Enter).
		//
		EMUKEY(VK_SUBTRACT,		1, 0, 0, 0, 0,  "\x2D",			1), // -
		EMUKEY(VK_ADD,			1, 0, 0, 0, 0,  "\x2C",			1), // ,
		EMUKEY(VK_RETURN,		1, 0, 0, 0, 1,  "\x0D",			1), // CR
		};

	// VT220 Keypad Application Mode.
	//
	// Please note that the sequences defined in this table are the
	// 8-bit versions of the responses.  The function emuDecSendKeyString
	// will convert this sequence to the 7-bit equivalent if necessary.
	//
	static STEMUKEYDATA const VT220KeypadApplicationMode[] =
		{
		// Keypad keys with Numlock off.
		//
		EMUKEY(VK_NUMPAD0,		1, 0, 0, 0, 0,  "\x8F\x70",		2), // p
		EMUKEY(VK_NUMPAD1,		1, 0, 0, 0, 0,  "\x8F\x71",		2), // q
		EMUKEY(VK_NUMPAD2,		1, 0, 0, 0, 0,  "\x8F\x72",		2), // r
		EMUKEY(VK_NUMPAD3,		1, 0, 0, 0, 0,  "\x8F\x73",		2), // s
		EMUKEY(VK_NUMPAD4,		1, 0, 0, 0, 0,  "\x8F\x74",		2), // t
		EMUKEY(VK_NUMPAD5,		1, 0, 0, 0, 0,  "\x8F\x75",		2), // u
		EMUKEY(VK_NUMPAD6,		1, 0, 0, 0, 0,  "\x8F\x76",		2), // v
		EMUKEY(VK_NUMPAD7,		1, 0, 0, 0, 0,  "\x8F\x77",		2), // w
		EMUKEY(VK_NUMPAD8,		1, 0, 0, 0, 0,  "\x8F\x78",		2), // x
		EMUKEY(VK_NUMPAD9,		1, 0, 0, 0, 0,  "\x8F\x79",		2), // y
		EMUKEY(VK_DECIMAL,		1, 0, 0, 0, 0,  "\x8F\x6E",		2), // n

		// Keypad keys with Numlock on.
		//
		EMUKEY(VK_NUMPAD0,		1, 0, 0, 0, 0,  "\x8F\x70",		2), // p
		EMUKEY(VK_NUMPAD1,		1, 0, 0, 0, 0,  "\x8F\x71",		2), // q
		EMUKEY(VK_NUMPAD2,		1, 0, 0, 0, 0,  "\x8F\x72",		2), // r
		EMUKEY(VK_NUMPAD3,		1, 0, 0, 0, 0,  "\x8F\x73",		2), // s
		EMUKEY(VK_NUMPAD4,		1, 0, 0, 0, 0,  "\x8F\x74",		2), // t
		EMUKEY(VK_NUMPAD5,		1, 0, 0, 0, 0,  "\x8F\x75",		2), // u
		EMUKEY(VK_NUMPAD6,		1, 0, 0, 0, 0,  "\x8F\x76",		2), // v
		EMUKEY(VK_NUMPAD7,		1, 0, 0, 0, 0,  "\x8F\x77",		2), // w
		EMUKEY(VK_NUMPAD8,		1, 0, 0, 0, 0,  "\x8F\x78",		2), // x
		EMUKEY(VK_NUMPAD9,		1, 0, 0, 0, 0,  "\x8F\x79",		2), // y
		EMUKEY(VK_DECIMAL,		1, 0, 0, 0, 0,  "\x8F\x6E",		2), // n

		// Other keypad keys (minus, plus, Enter).
		//
		EMUKEY(VK_SUBTRACT,		1, 0, 0, 0, 0,  "\x8F\x6D",		2), // m
		EMUKEY(VK_ADD,			1, 0, 0, 0, 0,  "\x8F\x6C",		2), // l
		EMUKEY(VK_RETURN,		1, 0, 0, 0, 1,  "\x8F\x4D",		2), // M
		};

	// VT220 Cursor Key Mode.
	//
	// Please note that the sequences defined in this table are the
	// 8-bit versions of the responses.  The function emuDecSendKeyString
	// will convert this sequence to the 7-bit equivalent if necessary.
	//
	static STEMUKEYDATA const VT220CursorKeyMode[] =
		{
		// Arrow keys on the numeric keypad.  These sequences are used
		// when the emulator is using Cursor Key Mode (Application Keys).
		//
		EMUKEY(VK_UP,		1, 0, 0, 0, 0,  "\x8F\x41",			2), // A
		EMUKEY(VK_DOWN,		1, 0, 0, 0, 0,  "\x8F\x42",			2), // B
		EMUKEY(VK_RIGHT,	1, 0, 0, 0, 0,  "\x8F\x43",			2), // C
		EMUKEY(VK_LEFT,		1, 0, 0, 0, 0,  "\x8F\x44",			2), // D

		// Arrow keys on the edit pad.  These sequences are used
		// when the emulator is using Cursor Key Mode (Application Keys).
		//
		EMUKEY(VK_UP,		1, 0, 0, 0, 1,  "\x8F\x41",			2), // A
		EMUKEY(VK_DOWN,		1, 0, 0, 0, 1,  "\x8F\x42",			2), // B
		EMUKEY(VK_RIGHT,	1, 0, 0, 0, 1,  "\x8F\x43",			2), // C
		EMUKEY(VK_LEFT,		1, 0, 0, 0, 1,  "\x8F\x44",			2), // D
		};

	// VT220 Standard Key Table.
	//
	static STEMUKEYDATA const VT220StandardKeys[] =
		{
		// Some keys on the numeric keypad will respond in the same
		// way the corresponding keys on the edit pad respond.
		//
		EMUKEY(VK_HOME,		1, 0, 0, 0, 0,  "\x9B\x31\x7E",		3), // 1 ~
		EMUKEY(VK_INSERT,	1, 0, 0, 0, 0,  "\x9B\x32\x7E",		3), // 2 ~
		EMUKEY(VK_DELETE,	1, 0, 0, 0, 0,  "\x9B\x33\x7E",		3), // 3 ~
		EMUKEY(VK_END,		1, 0, 0, 0, 0,  "\x9B\x34\x7E",		3), // 4 ~
		EMUKEY(VK_PRIOR,	1, 0, 0, 0, 0,  "\x9B\x35\x7E",		3), // 5 ~
		EMUKEY(VK_NEXT,		1, 0, 0, 0, 0,  "\x9B\x36\x7E",		3), // 6 ~

		// These are the keys on the edit pad.
		//
		EMUKEY(VK_HOME,		1, 0, 0, 0, 1,  "\x9B\x31\x7E",		3), // 1 ~
		EMUKEY(VK_INSERT,	1, 0, 0, 0, 1,  "\x9B\x32\x7E",		3), // 2 ~
		EMUKEY(VK_DELETE,	1, 0, 0, 0, 1,  "\x9B\x33\x7E",		3), // 3 ~
		EMUKEY(VK_END,		1, 0, 0, 0, 1,  "\x9B\x34\x7E",		3), // 4 ~
		EMUKEY(VK_PRIOR,	1, 0, 0, 0, 1,  "\x9B\x35\x7E",		3), // 5 ~
		EMUKEY(VK_NEXT,		1, 0, 0, 0, 1,  "\x9B\x36\x7E",		3), // 6 ~

		// Arrow keys on the numeric keypad.
		//
		EMUKEY(VK_UP,		1, 0, 0, 0, 0,  "\x9B\x41",			2), // A
		EMUKEY(VK_DOWN,		1, 0, 0, 0, 0,  "\x9B\x42",			2), // B
		EMUKEY(VK_RIGHT,	1, 0, 0, 0, 0,  "\x9B\x43",			2), // C
		EMUKEY(VK_LEFT,		1, 0, 0, 0, 0,  "\x9B\x44",			2), // D

		// Arrow keys on the edit pad.
		//
		EMUKEY(VK_UP,		1, 0, 0, 0, 1,  "\x9B\x41",			2), // A
		EMUKEY(VK_DOWN,		1, 0, 0, 0, 1,  "\x9B\x42",			2), // B
		EMUKEY(VK_RIGHT,	1, 0, 0, 0, 1,  "\x9B\x43",			2), // C
		EMUKEY(VK_LEFT,		1, 0, 0, 0, 1,  "\x9B\x44",			2), // D

		// Function keys (F5)F6 thru F10.
		//
#if defined(INCL_ULTC_VERSION)
		EMUKEY(VK_F5,		1, 0, 0, 0, 0,  "\x9B\x31\x36\x7E", 4), // 1 6 ~
#endif
		EMUKEY(VK_F6,		1, 0, 0, 0, 0,  "\x9B\x31\x37\x7E", 4), // 1 7 ~
		EMUKEY(VK_F7,		1, 0, 0, 0, 0,  "\x9B\x31\x38\x7E", 4), // 1 8 ~
		EMUKEY(VK_F8,		1, 0, 0, 0, 0,  "\x9B\x31\x39\x7E", 4), // 1 9 ~
		EMUKEY(VK_F9,		1, 0, 0, 0, 0,  "\x9B\x32\x30\x7E", 4), // 2 0 ~
		EMUKEY(VK_F10,		1, 0, 0, 0, 0,  "\x9B\x32\x31\x7E", 4), // 2 1 ~

#if defined(INCL_ULTC_VERSION)
		EMUKEY(VK_F5,		1, 0, 0, 0, 1,  "\x9B\x31\x36\x7E", 4), // 1 6 ~
#endif
		EMUKEY(VK_F6,		1, 0, 0, 0, 1,  "\x9B\x31\x37\x7E", 4), // 1 7 ~
		EMUKEY(VK_F7,		1, 0, 0, 0, 1,  "\x9B\x31\x38\x7E", 4), // 1 8 ~
		EMUKEY(VK_F8,		1, 0, 0, 0, 1,  "\x9B\x31\x39\x7E", 4), // 1 9 ~
		EMUKEY(VK_F9,		1, 0, 0, 0, 1,  "\x9B\x32\x30\x7E", 4), // 2 0 ~
		EMUKEY(VK_F10,		1, 0, 0, 0, 1,  "\x9B\x32\x31\x7E", 4), // 2 1 ~

		// Function keys F11 thru F20 are invoked by the user pressing
		// Ctrl-F1 thru Ctrl-F10.
		//
		// Function keys Ctrl-F1 thru Ctrl-F10 (Top row).
		//
		EMUKEY(VK_F1,		1, 1, 0, 0, 0,  "\x9B\x32\x33\x7E", 4), // 2 3 ~
		EMUKEY(VK_F2,		1, 1, 0, 0, 0,  "\x9B\x32\x34\x7E", 4), // 2 4 ~
		EMUKEY(VK_F3,		1, 1, 0, 0, 0,  "\x9B\x32\x35\x7E", 4), // 2 5 ~
		EMUKEY(VK_F4,		1, 1, 0, 0, 0,  "\x9B\x32\x36\x7E", 4), // 2 6 ~
		EMUKEY(VK_F5,		1, 1, 0, 0, 0,  "\x9B\x32\x38\x7E", 4), // 2 8 ~
		EMUKEY(VK_F6,		1, 1, 0, 0, 0,  "\x9B\x32\x39\x7E", 4), // 2 9 ~
		EMUKEY(VK_F7,		1, 1, 0, 0, 0,  "\x9B\x33\x31\x7E", 4), // 3 1 ~
		EMUKEY(VK_F8,		1, 1, 0, 0, 0,  "\x9B\x33\x32\x7E", 4), // 3 2 ~
		EMUKEY(VK_F9,		1, 1, 0, 0, 0,  "\x9B\x33\x33\x7E", 4), // 3 3 ~
		EMUKEY(VK_F10,		1, 1, 0, 0, 0,  "\x9B\x33\x34\x7E", 4), // 3 4 ~

		EMUKEY(VK_F1,		1, 1, 0, 0, 1,  "\x9B\x32\x33\x7E", 4), // 2 3 ~
		EMUKEY(VK_F2,		1, 1, 0, 0, 1,  "\x9B\x32\x34\x7E", 4), // 2 4 ~
		EMUKEY(VK_F3,		1, 1, 0, 0, 1,  "\x9B\x32\x35\x7E", 4), // 2 5 ~
		EMUKEY(VK_F4,		1, 1, 0, 0, 1,  "\x9B\x32\x36\x7E", 4), // 2 6 ~
		EMUKEY(VK_F5,		1, 1, 0, 0, 1,  "\x9B\x32\x38\x7E", 4), // 2 8 ~
		EMUKEY(VK_F6,		1, 1, 0, 0, 1,  "\x9B\x32\x39\x7E", 4), // 2 9 ~
		EMUKEY(VK_F7,		1, 1, 0, 0, 1,  "\x9B\x33\x31\x7E", 4), // 3 1 ~
		EMUKEY(VK_F8,		1, 1, 0, 0, 1,  "\x9B\x33\x32\x7E", 4), // 3 2 ~
		EMUKEY(VK_F9,		1, 1, 0, 0, 1,  "\x9B\x33\x33\x7E", 4), // 3 3 ~
		EMUKEY(VK_F10,		1, 1, 0, 0, 1,  "\x9B\x33\x34\x7E", 4), // 3 4 ~

		EMUKEY(VK_F1,		1, 0, 0, 0, 0,	"\x8FP",			2),
		EMUKEY(VK_F2,		1, 0, 0, 0, 0,	"\x8FQ",			2),
		EMUKEY(VK_F3,		1, 0, 0, 0, 0,	"\x8FR",			2),
		EMUKEY(VK_F4,		1, 0, 0, 0, 0,	"\x8FS",			2),

		EMUKEY(VK_F1,		1, 0, 0, 0, 1,	"\x8FP",			2),
		EMUKEY(VK_F2,		1, 0, 0, 0, 1,	"\x8FQ",			2),
		EMUKEY(VK_F3,		1, 0, 0, 0, 1,	"\x8FR",			2),
		EMUKEY(VK_F4,		1, 0, 0, 0, 1,	"\x8FS",			2),

		EMUKEY(VK_DELETE,	1, 0, 0, 0, 0,	"\x7F",				1),	// KN_DEL
		EMUKEY(VK_DELETE,	1, 0, 0, 0, 1,	"\x7F",				1),	// KN_DEL

		EMUKEY(VK_ADD,		1, 0, 0, 0, 0,	",",				1),

		// Ctrl-2.
		// Ctrl-@.
		//
		EMUKEY(0x32,		1, 1, 0, 0, 0,  "\x00",				1),
		EMUKEY(0x32,		1, 1, 0, 1, 0,  "\x00",				1),

		// Ctrl-6.
		// Ctrl-^.
		EMUKEY(0x36,		1, 1, 0, 0, 0,  "\x1E",				1),
		EMUKEY(0x36,		1, 1, 0, 1, 0,  "\x1E",				1),

		// Ctrl-Space
		//
		EMUKEY(VK_SPACE,	1, 1, 0, 0, 0,  "\x00",				1),

		// Ctrl-- key.
		//
		EMUKEY(VK_SUBTRACT,	1, 1, 0, 0, 1,  "\x1F",				1),
		};

	// VT220 User Defined keys.
	static STEMUKEYDATA VT220UserDefinedKeys[MAX_UDK_KEYS] =
		{
		// NOTE: Do not change the order of these user defined entries.
		// emuDecDefineUDK assumes a 1:1 correspondance with this
		// table and the UDKSelector table defined below.
		//
		// Initialize Virtual and Shift flags.
		//
		EMUKEY(VK_F6,		1, 0, 0, 1, 0,  0,					0),
		EMUKEY(VK_F7,		1, 0, 0, 1, 0,  0,					0),
		EMUKEY(VK_F8,		1, 0, 0, 1, 0,  0,					0),
		EMUKEY(VK_F9,		1, 0, 0, 1, 0,  0,					0),
		EMUKEY(VK_F10,		1, 0, 0, 1, 0,  0,					0),

		// Initialize Virtual and Alt flags.
		//
		EMUKEY(VK_F1,		1, 0, 1, 0, 0,  0,					0),
		EMUKEY(VK_F2,		1, 0, 1, 0, 0,  0,					0),
		EMUKEY(VK_F3,		1, 0, 1, 0, 0,  0,					0),
		EMUKEY(VK_F4,		1, 0, 1, 0, 0,  0,					0),
		EMUKEY(VK_F5,		1, 0, 1, 0, 0,  0,					0),
		EMUKEY(VK_F6,		1, 0, 1, 0, 0,  0,					0),
		EMUKEY(VK_F7,		1, 0, 1, 0, 0,  0,					0),
		EMUKEY(VK_F8,		1, 0, 1, 0, 0,  0,					0),
		EMUKEY(VK_F9,		1, 0, 1, 0, 0,  0,					0),
		EMUKEY(VK_F10,		1, 0, 1, 0, 0,  0,					0),
		};

	// NOTE: Do not change the order of these entries.
	// There is a 1:1 correspondance between this table and the
	// user defined key table defined above.
	//
	static TCHAR const acUDKSelectors[MAX_UDK_KEYS] =
		{
		TEXT('\x17'), TEXT('\x18'), TEXT('\x19'), TEXT('\x20'), // F6 -  F9
		TEXT('\x21'), TEXT('\x23'), TEXT('\x24'), TEXT('\x25'), // F10 - F13
		TEXT('\x26'), TEXT('\x28'), TEXT('\x29'), TEXT('\x31'), // F14 - F17
		TEXT('\x32'), TEXT('\x33'), TEXT('\x34'),				// F18 - F20
		};

	emuInstallStateTable(hhEmu, vt220_tbl, DIM(vt220_tbl));

	// Allocate space for and initialize data that is used only by the
	// VT220 emulator.
	//
	hhEmu->pvPrivate = malloc(sizeof(DECPRIVATE));

	if (hhEmu->pvPrivate == 0)
		{
		assert(FALSE);
		return;
		}

	pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	memset(pstPRI, 0, sizeof(DECPRIVATE));

	// NOTE:	The order of these definitions directly correspond to the
	//			search order used by the emuDecKeyboardIn function.
	//			Don't change these.
	//
	// In shared code, these are all part of hhEmu.
	pstPRI->pstcEmuKeyTbl1 = VT220StdPfKeyTable;
	pstPRI->pstcEmuKeyTbl2 = VT220MovedPfKeyTable;
	pstPRI->pstcEmuKeyTbl3 = VT220KeypadNumericMode;
	pstPRI->pstcEmuKeyTbl4 = VT220KeypadApplicationMode;
	pstPRI->pstcEmuKeyTbl5 = VT220CursorKeyMode;
	pstPRI->pstcEmuKeyTbl6 = VT220StandardKeys;

	pstPRI->iKeyTable1Entries = DIM(VT220StdPfKeyTable);
	pstPRI->iKeyTable2Entries = DIM(VT220MovedPfKeyTable);
	pstPRI->iKeyTable3Entries = DIM(VT220KeypadNumericMode);
	pstPRI->iKeyTable4Entries = DIM(VT220KeypadApplicationMode);
	pstPRI->iKeyTable5Entries = DIM(VT220CursorKeyMode);
	pstPRI->iKeyTable6Entries = DIM(VT220StandardKeys);

	// Allocate an array to hold line attribute values.
	//
	pstPRI->aiLineAttr = malloc(MAX_EMUROWS * sizeof(int) );

	if (pstPRI->aiLineAttr == 0)
		{
		assert(FALSE);
		return;
		}

	for (iRow = 0; iRow < MAX_EMUROWS; iRow++)
		pstPRI->aiLineAttr[iRow] = NO_LINE_ATTR;

	pstPRI->sv_row			= 0;
	pstPRI->sv_col			= 0;
	pstPRI->gn				= 0;
	pstPRI->sv_AWM			= RESET;
	pstPRI->sv_DECOM		= RESET;
	pstPRI->sv_protectmode	= FALSE;
	pstPRI->fAttrsSaved 	= FALSE;
	pstPRI->pntr			= pstPRI->storage;

	// Initialize hhEmu values for VT220.
	//
	hhEmu->emu_setcurpos	= emuDecSetCurPos;
	hhEmu->emu_deinstall	= emuDecUnload;
	hhEmu->emu_clearline	= emuDecClearLine;
	hhEmu->emu_clearscreen  = emuDecClearScreen;
	hhEmu->emu_kbdin		= emuDecKeyboardIn;
	hhEmu->emuResetTerminal = vt220_reset;
	hhEmu->emu_graphic		= emuDecGraphic;
//	hhEmu->emu_scroll		= emuDecScroll;

#if !defined(FAR_EAST)
	hhEmu->emu_highchar 	= 0x7E;
#else
	hhEmu->emu_highchar 	= 0xFFFF;
#endif

	hhEmu->emu_maxcol		= VT_MAXCOL_80MODE;
	hhEmu->fUse8BitCodes		= FALSE;
	hhEmu->mode_vt220			= FALSE;
	hhEmu->mode_vt320			= FALSE;
	//hhEmu->vt220_protectmode	= FALSE;
	hhEmu->mode_protect			= FALSE;

	if (hhEmu->nEmuLoaded == EMU_VT220)
		hhEmu->mode_vt220 = TRUE;

	else if (hhEmu->nEmuLoaded == EMU_VT320)
		hhEmu->mode_vt320 = TRUE;

	else
		assert(FALSE);

// UNDO:rde
//	pstPRI->vt220_protimg = 0;

	pstPRI->pstUDK			= VT220UserDefinedKeys;
	pstPRI->iUDKTableEntries= DIM(VT220UserDefinedKeys);

	pstPRI->pacUDKSelectors = acUDKSelectors;
	pstPRI->iUDKState		= KEY_NUMBER_NEXT;

	std_dsptbl(hhEmu, TRUE);
	vt_charset_init(hhEmu);

	switch(hhEmu->stUserSettings.nEmuId)
		{
	case EMU_VT220:
		hhEmu->mode_vt220		= TRUE;
		hhEmu->mode_vt320		= FALSE;
		vt220_reset(hhEmu, FALSE);
		break;

	case EMU_VT320:
		hhEmu->mode_vt220		= FALSE;
		hhEmu->mode_vt320		= TRUE;
		break;

	default:
		assert(FALSE);
		break;
		}

	backscrlSetShowFlag(sessQueryBackscrlHdl(hhEmu->hSession), TRUE);
	return;
	}
#endif // INCL_VT220

/* end of vt220ini.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\vt52.hh ===
/*	File: D:\WACKER\emu\vt52.hh (Created: 13-July-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:28p $
 */

/* No Longer is use, replaced by PSTDECPRIVATE
// Private emulator data for VT52.
//

typedef struct stPrivateVT52
	{
	int 	len_t,
			len_s;

	ECHAR	terminate[4],
			storage[40],
			*pntr;

	} VT52PRIVATE;

typedef VT52PRIVATE *PSTVT52PRIVATE;
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\vt100ini.c ===
/*	File: D:\WACKER\emu\vt100ini.c (Created: 27-Dec-1993)
 *
 *	Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:29p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\assert.h>
#include <tdll\mc.h>
#include <tdll\backscrl.h>

#include "emu.h"
#include "emu.hh"
#include "emuid.h"
#include "emudec.hh"
#include "keytbls.h"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt100_init
 *
 * DESCRIPTION:
 *	 Initializes the VT100 emulator.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *	 nothing
 */
void vt100_init(const HHEMU hhEmu)
	{
	PSTDECPRIVATE pstPRI;
	int iRow;

	static struct trans_entry const vt100_tbl[] =
		{
		{NEW_STATE, 0, 0, 0}, // State 0
#if !defined(FAR_EAST)
		{0, ETEXT('\x20'),	ETEXT('\x7E'),	emuDecGraphic}, 	// Space - ~
#else
		{0, ETEXT('\x20'),	0xFFFF,			emuDecGraphic}, 	// Space - ~
#endif
		{1, ETEXT('\x1B'),	ETEXT('\x1B'),	nothing},			// Esc
		{0, ETEXT('\x05'),	ETEXT('\x05'),	vt100_answerback},	// Ctrl-E
		{0, ETEXT('\x07'),	ETEXT('\x07'),	emu_bell},			// Ctrl-G
		{0, ETEXT('\x08'),	ETEXT('\x08'),	vt_backspace},		// BackSpace
		{0, ETEXT('\x09'),	ETEXT('\x09'),	emuDecTab}, 		// Tab
		{0, ETEXT('\x0A'),	ETEXT('\x0C'),	emuLineFeed},		// NL - FF
		{0, ETEXT('\x0D'),	ETEXT('\x0D'),	carriagereturn},	// CR
		{0, ETEXT('\x0E'),	ETEXT('\x0F'),	vt_charshift},		// Ctrl-N
		{7, ETEXT('\x18'),	ETEXT('\x18'),	EmuStdChkZmdm}, 	// Ctrl-X

		{NEW_STATE, 0, 0, 0}, // State 1						// Esc
		{2, ETEXT('\x5B'),	ETEXT('\x5B'),	ANSI_Pn_Clr},		// [
		{3, ETEXT('\x23'),	ETEXT('\x23'),	nothing},			// #
		{4, ETEXT('\x28'),	ETEXT('\x29'),	vt_scs1},			// ( - )
		{0, ETEXT('\x37'),	ETEXT('\x38'),	vt100_savecursor},	// 7 - 8
		{1, ETEXT('\x3B'),	ETEXT('\x3B'),	ANSI_Pn_End},		// ;
		{0, ETEXT('\x3D'),	ETEXT('\x3E'),	vt_alt_kpmode}, 	// = - >
		{0, ETEXT('\x44'),	ETEXT('\x44'),	emuDecIND}, 		// D
		{0, ETEXT('\x45'),	ETEXT('\x45'),	ANSI_NEL},			// E
		{0, ETEXT('\x48'),	ETEXT('\x48'),	ANSI_HTS},			// H
		{0, ETEXT('\x4D'),	ETEXT('\x4D'),	emuDecRI},			// M
		{0, ETEXT('\x5A'),	ETEXT('\x5A'),	ANSI_DA},			// Z
		{0, ETEXT('\x63'),	ETEXT('\x63'),	vt100_hostreset},	// c

		{NEW_STATE, 0, 0, 0}, // State 2						// Esc[
		{2, ETEXT('\x3B'),	ETEXT('\x3B'),	ANSI_Pn_End},		// ;
		{2, ETEXT('\x30'),	ETEXT('\x3F'),	ANSI_Pn},			// 0 - ?
		{5, ETEXT('\x22'),	ETEXT('\x22'),	nothing},			// "
		{0, ETEXT('\x41'),	ETEXT('\x41'),	emuDecCUU}, 		// A
		{0, ETEXT('\x42'),	ETEXT('\x42'),	emuDecCUD}, 		// B
		{0, ETEXT('\x43'),	ETEXT('\x43'),	emuDecCUF}, 		// C
		{0, ETEXT('\x44'),	ETEXT('\x44'),	emuDecCUB}, 		// D
		{0, ETEXT('\x48'),	ETEXT('\x48'),	emuDecCUP}, 		// H
		{0, ETEXT('\x4A'),	ETEXT('\x4A'),	emuDecED},			// J
		{0, ETEXT('\x4B'),	ETEXT('\x4B'),	ANSI_EL},			// K
		{0, ETEXT('\x4C'),	ETEXT('\x4C'),	vt_IL}, 			// L
		{0, ETEXT('\x4D'),	ETEXT('\x4D'),	vt_DL}, 			// M
		{0, ETEXT('\x50'),	ETEXT('\x50'),	vt_DCH},			// P
		{0, ETEXT('\x63'),	ETEXT('\x63'),	ANSI_DA},			// c
		{0, ETEXT('\x66'),	ETEXT('\x66'),	emuDecCUP}, 		// f
		{0, ETEXT('\x67'),	ETEXT('\x67'),	ANSI_TBC},			// g
		{0, ETEXT('\x68'),	ETEXT('\x68'),	ANSI_SM},			// h
		{0, ETEXT('\x69'),	ETEXT('\x69'),	vt100PrintCommands},// i
		{0, ETEXT('\x6C'),	ETEXT('\x6C'),	ANSI_RM},			// l
		{0, ETEXT('\x6D'),	ETEXT('\x6D'),	ANSI_SGR},			// m
		{0, ETEXT('\x6E'),	ETEXT('\x6E'),	ANSI_DSR},			// n
		{0, ETEXT('\x71'),	ETEXT('\x71'),	nothing},			// q
		{0, ETEXT('\x72'),	ETEXT('\x72'),	vt_scrollrgn},		// r
		{0, ETEXT('\x78'),	ETEXT('\x78'),	vt100_report},		// x

		{NEW_STATE, 0, 0, 0}, // State 3						// Esc#
		{0, ETEXT('\x33'),	ETEXT('\x36'),	emuSetDoubleAttr},	// 3 - 6

		{0, ETEXT('\x38'),	ETEXT('\x38'),	vt_screen_adjust},	// 8

		{NEW_STATE, 0, 0, 0}, // State 4						// Esc ( - )
		{0, ETEXT('\x01'),	ETEXT('\xFF'),	vt_scs2},			// All

		{NEW_STATE, 0, 0, 0}, // State 5						// Esc["
		{0, ETEXT('\x70'),	ETEXT('\x70'),	nothing},			// p

		{NEW_STATE, 0, 0, 0}, // State 6						// Printer control
		{6, ETEXT('\x00'),	ETEXT('\xFF'),	vt100_prnc},		// All

		{NEW_STATE, 0, 0, 0}, // State 7						// Ctrl-X
		{7, ETEXT('\x00'),	ETEXT('\xFF'),	EmuStdChkZmdm}, 	// All

		};

	emuInstallStateTable(hhEmu, vt100_tbl, DIM(vt100_tbl));

	// Allocate space for and initialize data that is used only by the
	// VT100 emulator.
	//
	hhEmu->pvPrivate = malloc(sizeof(DECPRIVATE));

	if (hhEmu->pvPrivate == 0)
		{
		assert(FALSE);
		return;
		}

	pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	memset(pstPRI, 0, sizeof(DECPRIVATE));

	// Allocate an array to hold line attribute values.
	//
	pstPRI->aiLineAttr = malloc(MAX_EMUROWS * sizeof(int) );

	if (pstPRI->aiLineAttr == 0)
		{
		assert(FALSE);
		return;
		}

	for (iRow = 0; iRow < MAX_EMUROWS; iRow++)
		pstPRI->aiLineAttr[iRow] = NO_LINE_ATTR;

	pstPRI->sv_row			= 0;
	pstPRI->sv_col			= 0;
	pstPRI->gn				= 0;
	pstPRI->sv_AWM			= RESET;
	pstPRI->sv_DECOM		= RESET;
	pstPRI->sv_protectmode	= FALSE;
	pstPRI->fAttrsSaved 	= FALSE;
	pstPRI->pntr			= pstPRI->storage;

	// Initialize hhEmu values for VT100.
	//
	hhEmu->emu_kbdin		= vt100_kbdin;
	hhEmu->emuResetTerminal = vt100_reset;
	hhEmu->emu_setcurpos	= emuDecSetCurPos;
	hhEmu->emu_deinstall	= emuVT100Unload;
	hhEmu->emu_clearscreen	= emuDecClearScreen;

#if !defined(FAR_EAST)
	hhEmu->emu_highchar 	= 0x7E;
#else
	hhEmu->emu_highchar 	= 0xFFFF;
#endif
	hhEmu->emu_maxcol		= VT_MAXCOL_80MODE;
	hhEmu->mode_vt220		= FALSE;

	std_dsptbl(hhEmu, TRUE);
	vt_charset_init(hhEmu);

	emuKeyTableLoad(hhEmu, VT100KeyTable, 
					 sizeof(VT100KeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl);

	emuKeyTableLoad(hhEmu, VT100_Keypad_KeyTable, 
					 sizeof(VT100_Keypad_KeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl2);

	emuKeyTableLoad(hhEmu, VT100_Cursor_KeyTable, 
					 sizeof(VT100_Cursor_KeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl3);

	emuKeyTableLoad(hhEmu, VT_PF_KeyTable, 
					 sizeof(VT_PF_KeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl4);

	backscrlSetShowFlag(sessQueryBackscrlHdl(hhEmu->hSession), TRUE);
	return;
	}

/* end of vt100ini.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\vt52init.c ===
/*	File: D:\WACKER\emu\vt52init.c (Created: 28-Dec-1993)
 *
 *	Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 2/02/01 3:59p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\assert.h>
#include <tdll\mc.h>
#include <tdll\backscrl.h>
#include <tdll\htchar.h>

#include "emu.h"
#include "emu.hh"
#include "emuid.h"
#include "emudec.hh"
#include "keytbls.h"

static void vt52char_reset(const HHEMU hhEmu);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt52_init
 *
 * DESCRIPTION:
 *	 Loads and initializes the VT52 emulator.
 *
 * ARGUMENTS:
 *	 new_emu -- TRUE if emulating a power up on the real thing.
 *
 * RETURNS:
 *	 nothing
 */
void vt52_init(const HHEMU hhEmu)
	{
	PSTDECPRIVATE pstPRI;

	static struct trans_entry const vt52_tbl[] =
		{
		{NEW_STATE, 0, 0, 0}, // State 0
		{0, ETEXT('\x20'),	ETEXT('\x7E'),	emuStdGraphic}, 	// Space - ~
		{1, ETEXT('\x1B'),	ETEXT('\x1B'),	nothing},			// Esc
		{0, ETEXT('\x07'),	ETEXT('\x07'),	emu_bell},			// Ctrl-G
		{0, ETEXT('\x08'),	ETEXT('\x08'),	vt_backspace},		// Backspace
		{0, ETEXT('\x09'),	ETEXT('\x09'),	tabn},				// Tab
		{0, ETEXT('\x0A'),	ETEXT('\x0A'),	emuLineFeed},		// New Line
		{0, ETEXT('\x0D'),	ETEXT('\x0D'),	carriagereturn},	// CR
		{5, ETEXT('\x18'),	ETEXT('\x18'),	EmuStdChkZmdm}, 	// Ctrl-X

		{NEW_STATE, 0, 0, 0}, // State 1						// Esc
		{2, ETEXT('\x59'),	ETEXT('\x59'),	nothing},			// Y
		{0, ETEXT('\x3C'),	ETEXT('\x3C'),	vt52_toANSI},		// <
		{0, ETEXT('\x3D'),	ETEXT('\x3E'),	vt_alt_kpmode}, 	// = - >
		{0, ETEXT('\x41'),	ETEXT('\x41'),	ANSI_CUU},			// A
		{0, ETEXT('\x42'),	ETEXT('\x42'),	ANSI_CUD},			// B
		{0, ETEXT('\x43'),	ETEXT('\x43'),	ANSI_CUF},			// C
		{0, ETEXT('\x44'),	ETEXT('\x44'),	vt_CUB},			// D
		{0, ETEXT('\x46'),	ETEXT('\x47'),	vt_charshift},		// F - G
		{0, ETEXT('\x48'),	ETEXT('\x48'),	ANSI_CUP},			// H
		{0, ETEXT('\x49'),	ETEXT('\x49'),	ANSI_RI},			// I
		{0, ETEXT('\x4A'),	ETEXT('\x4A'),	ANSI_ED},			// J
		{0, ETEXT('\x4B'),	ETEXT('\x4B'),	ANSI_EL},			// K
		{0, ETEXT('\x56'),	ETEXT('\x56'),	vt52PrintCommands}, // V
		{4, ETEXT('\x57'),	ETEXT('\x57'),	nothing},			// W
		{0, ETEXT('\x58'),	ETEXT('\x58'),	nothing},			// X
		{0, ETEXT('\x5A'),	ETEXT('\x5A'),	vt52_id},			// Z
		{0, ETEXT('\x5D'),	ETEXT('\x5D'),	vt52PrintCommands}, // ]
		{0, ETEXT('\x5E'),	ETEXT('\x5E'),	vt52PrintCommands}, // ^
		{0, ETEXT('\x5F'),	ETEXT('\x5F'),	vt52PrintCommands}, // _

		{NEW_STATE, 0, 0, 0}, // State 2						// EscY
		// Accept all data--CUP will set the limits. Needed for more than 24 rows.
		{3, ETEXT('\x00'),	ETEXT('\xFF'),	char_pn},			// Space - 8
//		{3, ETEXT('\x20'),	ETEXT('\x38'),	char_pn},			// Space - 8

		{NEW_STATE, 0, 0, 0}, // State 3						// EscYn
		// Accept all data--CUP will set the limits. Needed for more than 80 columns.
		{0, ETEXT('\x00'),	ETEXT('\xFF'),	vt52_CUP},			// Space - o
//		{0, ETEXT('\x20'),	ETEXT('\x6F'),	vt52_CUP},			// Space - o

		{NEW_STATE, 0, 0, 0}, // State 4						// EscW
		{4, ETEXT('\x00'),	ETEXT('\xFF'),	vt52Print}, 		// All

		{NEW_STATE, 0, 0, 0}, // State 5						// Ctrl-X
		{5, ETEXT('\x00'),	ETEXT('\xFF'),	EmuStdChkZmdm}, 	// All

		};

	emuInstallStateTable(hhEmu, vt52_tbl, DIM(vt52_tbl));

	// Allocate space for and initialize data that is used only by the
	// VT52 emulator.
	//
	if (hhEmu->pvPrivate != 0)
		{
		free(hhEmu->pvPrivate);
		hhEmu->pvPrivate = 0;
		}

	hhEmu->pvPrivate = malloc(sizeof(DECPRIVATE));

	if (hhEmu->pvPrivate == 0)
		{
		assert(FALSE);
		return;
		}

	pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;
	CnvrtMBCStoECHAR(pstPRI->terminate, sizeof(pstPRI->terminate), TEXT("\033X"),
                     StrCharGetByteCount(TEXT("\033X")));
	pstPRI->len_t = 2;
	pstPRI->pntr = pstPRI->storage;
	pstPRI->len_s = 0;

	// Initialize standard hhEmu values.
	//
	hhEmu->emu_kbdin 	= vt52_kbdin;
	hhEmu->emu_highchar = 0x7E;
	hhEmu->emu_deinstall = emuVT52Unload;	
	
	vt52char_reset(hhEmu);

//	emuKeyTableLoad(hhEmu, IDT_VT52_KEYS, &hhEmu->stEmuKeyTbl);
//	emuKeyTableLoad(hhEmu, IDT_VT52_KEYPAD_APP_MODE, &hhEmu->stEmuKeyTbl2);
//	emuKeyTableLoad(hhEmu, IDT_VT_MAP_PF_KEYS, &hhEmu->stEmuKeyTbl3);
	emuKeyTableLoad(hhEmu, VT52KeyTable, 
					 sizeof(VT52KeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl);
	emuKeyTableLoad(hhEmu, VT52_Keypad_KeyTable, 
					 sizeof(VT52_Keypad_KeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl2);
	emuKeyTableLoad(hhEmu, VT_PF_KeyTable, 
					 sizeof(VT_PF_KeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl3);

	backscrlSetShowFlag(sessQueryBackscrlHdl(hhEmu->hSession), TRUE);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt52char_reset
 *
 * DESCRIPTION:
 *	 Sets the VT52 emulator character set to its RESET conditions.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
static void vt52char_reset(const HHEMU hhEmu)
	{
	// Set up US ASCII character set as G0 and DEC graphics as G1
	//
	vt_charset_init(hhEmu);
	hhEmu->emu_code = ETEXT(')');
	vt_scs1(hhEmu);
	hhEmu->emu_code = (ECHAR)0;
	vt_scs2(hhEmu);
	}

/* end of vt52init.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\emu\vt220.c ===
/*  File: \wacker\emu\vt220.c (Created: 28-Jan-1998)
 *
 *  Copyright 1998 by Hilgraeve Inc. -- Monroe, MI
 *  All rights reserved
 *
 *  $Revision: 7 $
 *  $Date: 2/02/01 4:00p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\tdll.h>
#include <tdll\htchar.h>
#include <tdll\session.h>
#include <tdll\cloop.h>
#include <tdll\assert.h>
#include <tdll\print.h>
#include <tdll\update.h>
#include <tdll\capture.h>
#include <tdll\backscrl.h>
#include <tdll\chars.h>
#include <tdll\mc.h>

#include "emu.h"
#include "emu.hh"
#include "emudec.hh"

#if defined(INCL_VT220)

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt220_hostreset
 *
 * DESCRIPTION:
 *   Calls vt220_reset() when told by the host to reset.
 *
 * ARGUMENTS:
 *   none
 *
 * RETURNS:
 *   nothing
 */
void vt220_hostreset(const HHEMU hhEmu)
	{
	vt220_reset(hhEmu, TRUE);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt220_reset
 *
 * DESCRIPTION:
 *   Calls vt220_reset() when told by the host to reset.
 *
 * ARGUMENTS:
 *   host_request -- TRUE if told by host to reset
 *
 * RETURNS:
 *   nothing
 */
int vt220_reset(const HHEMU hhEmu, const int host_request)
	{
	hhEmu->mode_KAM = hhEmu->mode_IRM = hhEmu->mode_VEM =
		hhEmu->mode_HEM = hhEmu->mode_LNM = hhEmu->mode_DECCKM =
		hhEmu->mode_DECOM = hhEmu->mode_DECCOLM = hhEmu->mode_DECPFF =
//		hhEmu->mode_DECSCNM = hhEmu->mode_25enab = hhEmu->mode_blank =
		hhEmu->mode_DECSCNM = hhEmu->mode_25enab =
		hhEmu->mode_block = hhEmu->mode_local = RESET;

	hhEmu->mode_SRM = hhEmu->mode_DECPEX = hhEmu->mode_DECTCEM = SET;

	hhEmu->mode_AWM = TRUE;

//	hhEmu->mode_protect = hhEmu->vt220_protectmode = FALSE;
	hhEmu->mode_protect = FALSE;

	if (host_request)
		{
		ANSI_RIS(hhEmu);
		hhEmu->mode_AWM = RESET;
		}

	hhEmu->fUse8BitCodes = FALSE;
	hhEmu->mode_vt220 = TRUE;
	hhEmu->mode_vt320 = FALSE;

	if (hhEmu->nEmuLoaded == EMU_VT320)
		{
		hhEmu->mode_vt320 = TRUE;
		}

	vt_charset_init(hhEmu);

	hhEmu->emu_code = '>';

	vt_alt_kpmode(hhEmu);

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt220_softreset
 *
 * DESCRIPTION:
 *   Does a soft reset.
 *
 * ARGUMENTS:
 *   none
 *
 * RETURNS:
 *   nothing
 */
void vt220_softreset(const HHEMU hhEmu)
	{
	hhEmu->mode_KAM = hhEmu->mode_IRM = hhEmu->mode_DECCKM =
		hhEmu->mode_DECOM = hhEmu->mode_DECKPAM = RESET;

	hhEmu->mode_AWM = RESET;

	DEC_STBM(hhEmu, 0,0);

	ANSI_Pn_Clr(hhEmu);

	ANSI_SGR(hhEmu);

	hhEmu->emu_code = 0;

	vt100_savecursor(hhEmu);

	vt_charset_init(hhEmu);

	hhEmu->emu_code = '>';

	vt_alt_kpmode(hhEmu);

	hhEmu->mode_protect = FALSE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt220mode_reset
 *
 * DESCRIPTION:
 *   Sets the VT220 emulator to the proper conditions when switching
 *  from vt100 mode.
 *
 * ARGUMENTS:
 *   none
 *
 * RETURNS:
 *   nothing
 */
void vt220mode_reset(const HHEMU hhEmu)
	{
	hhEmu->mode_KAM		= hhEmu->mode_IRM		= hhEmu->mode_VEM =
		hhEmu->mode_HEM		= hhEmu->mode_DECCKM	= hhEmu->mode_DECOM =
		hhEmu->mode_25enab  = hhEmu->mode_AWM		= RESET;

	hhEmu->mode_DECPEX = hhEmu-> mode_DECTCEM = SET;

	hhEmu->fUse8BitCodes = FALSE;

	hhEmu->mode_vt220 = TRUE;
	hhEmu->mode_vt320 = FALSE;

	vt_charset_init(hhEmu);

	hhEmu->emu_code = '>';

	vt_alt_kpmode(hhEmu);

	DEC_STBM(hhEmu, 0, hhEmu->emu_maxrow + 1);

	hhEmu->emu_code = 0;

	vt100_savecursor(hhEmu);

	hhEmu->mode_protect = FALSE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt220_DA
 *
 * DESCRIPTION:
 *   Sends the primary device attribute (DA) information to the host.
 *
 * ARGUMENTS:
 *   none
 *
 * RETURNS:
 *   nothing
 */
void vt220_DA(const HHEMU hhEmu)
	{
	int		fOldValue;
	char	achStr[50];
	ECHAR	ech[50];

	//if (emuProjSuppressEmuReporting(hhEmu))
	//		return;

	// Build the 7-bit or 8-bit response.
	//
	if (hhEmu->fUse8BitCodes)
		{
		achStr[0] = '\x9B';
		achStr[1] = '\x00';
		}
	else
		{
		achStr[0] = '\x1B';
		achStr[1] = '[';
		achStr[2] = '\x00';
		}

	// Add the VT220 or VT320 part of the response.
	//
	if (hhEmu->mode_vt320)
		StrCharCat(achStr, TEXT("?63"));
	else
		StrCharCat(achStr, TEXT("?62"));

	// Add the rest of the respnse and send the result.
	//
	StrCharCat(achStr, TEXT(";1;2;6;8;9;14c"));

	CnvrtMBCStoECHAR(ech, sizeof(ech), achStr, 
					 StrCharGetByteCount(achStr));

	fOldValue = CLoopGetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession));

	CLoopSetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession), FALSE);

	emuSendString(hhEmu, ech, (int)StrCharGetEcharByteCount(ech)); 

	CLoopSetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession), fOldValue);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt220_2ndDA
 *
 * DESCRIPTION:
 *   Sends the secondary device attribute (DA) information to the host.
 *
 * ARGUMENTS:
 *   none
 *
 * RETURNS:
 *   nothing
 */
void vt220_2ndDA(const HHEMU hhEmu)
	{
	int		fOldValue;
	char	achStr[50];
	ECHAR	ech[50];

	// Build the 7-bit or 8-bit response.
	//
	if (hhEmu->fUse8BitCodes)
		{
		achStr[0] = '\x9B';
		achStr[1] = '\x00';
		}
	else
		{
		achStr[0] = '\x1B';
		achStr[1] = '[';
		achStr[2] = '\x00';
		}

	// Add the VT220 or VT320 part of the response.
	//
	if (hhEmu->mode_vt320)
        {
		StrCharCat(achStr, TEXT(">24;14;0c"));
        }
	else
        {
		StrCharCat(achStr, TEXT(">1;23;0c"));
        }

	CnvrtMBCStoECHAR(ech, sizeof(ech), achStr, 
					 StrCharGetByteCount(achStr));

	fOldValue = CLoopGetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession));

	CLoopSetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession), FALSE);

	emuSendString(hhEmu, ech, (int)StrCharGetEcharByteCount(ech)); 

	CLoopSetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession), fOldValue);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  emuDecClearUDK
 *
 * DESCRIPTION:
 *  This function clears (frees) all of the user defined key sequences
 *  that may have been previously stored.
 *
 * ARGUMENTS:
 *  HHEMU   hhEmu   -   The internal emulator handle.
 *
 * NOTES:
 *  This function is called in response to the following escape sequence.
 *  Esc Pc;Pl |
 *
 * RETURNS:
 *  void
 *
 * AUTHOR: John Masters, 05-Sep-1995
 */
void emuDecClearUDK(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;
	PSTEMUKEYDATA pstKey = pstPRI->pstUDK;
	int idx;

	// Set a flag that identifies the locked or unlocked status of the
	// UDK's that will be set after the definition of the keys has
	// completed.
	//
	if (hhEmu->selector[1] == 1)
		pstPRI->fUnlockedUDK = 1;   // Keys are unlocked after definition.
	else
		pstPRI->fUnlockedUDK = 0;   // Keys are locked after definition.

	// This function is called in response to an escape sequence that tells
	// the emulator to either clear each key sequence when a new one is
	// defined, or to clear all of the key sequences before any are defined.
	//
	// emuDecStoreUDK always clears the current sequence before assigning
	// a new one.  So, this function will clear all of the keys only
	// if that's what we were asked to do.  If the first selector is Zero,
	// then we will go ahead and clear all of the User Defined Keys.
	//
	if (hhEmu->selector[0] != 0)
		return;

	// Cycle through the user defined key table and free
	// any memory that may have been allocated for sequences.
	//
	if (pstKey)
		{
		for (idx = 0; idx < MAX_UDK_KEYS; idx++, pstKey++)
			{
			if (pstKey->iSequenceLen != 0)
				{
				free(pstKey->pSequence);
				pstKey->iSequenceLen = 0;
				}
			}
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecDefineUDK
 *
 * DESCRIPTION:
 *   Redefines the string output by a key.
 *
 * ARGUMENTS:
 *   none
 *
 * RETURNS:
 *   nothing
 */
void emuDecDefineUDK(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	TCHAR acAscii[16] = {   TEXT('0'), TEXT('1'), TEXT('2'), TEXT('3'),
							TEXT('4'), TEXT('5'), TEXT('6'), TEXT('7'),
							TEXT('8'), TEXT('9'), TEXT('A'), TEXT('B'),
							TEXT('C'), TEXT('D'), TEXT('E'), TEXT('F') };

	unsigned int aiHex[16] = {  0x00, 0x01, 0x02, 0x03,
								0x04, 0x05, 0x06, 0x07,
								0x08, 0x09, 0x0A, 0x0B,
								0x0C, 0x0D, 0x0E, 0x0F };

	int		idx;
	ECHAR   emuCode;

	emuCode = hhEmu->emu_code;

	switch(pstPRI->iUDKState)
		{
	case(KEY_NUMBER_NEXT):
		TCHAR_Fill(pstPRI->acUDKSequence,
			0, sizeof(pstPRI->acUDKSequence) / sizeof(TCHAR));

		pstPRI->iUDKSequenceLen = 0;
		pstPRI->chUDKAssignment = 0;
		pstPRI->iUDKState		= KEY_DIGIT2_NEXT;

		if (IN_RANGE(emuCode,TEXT('1'),TEXT('3')))
			{
			for (idx = 0; idx < 16; idx++)
				{
				if (emuCode == acAscii[idx])
					break;
				}

			pstPRI->chUDKAssignment = (TCHAR)(aiHex[idx] << 4);

			}
		else
			{
			goto UDKexit;
			}

		break;

	case(KEY_DIGIT2_NEXT):
		if (isdigit(emuCode))
			{
			for (idx = 0; idx < 16; idx++)
				{
				if (emuCode == acAscii[idx])
					break;
				}

			pstPRI->chUDKAssignment += (TCHAR)aiHex[idx];

			// The key to which the following sequence will be assigned
			// has been identified.  Lookup  that key in a table and
			// store an index that corresponds to the key table index.
			// See the initialization function for the emulator for
			// further clarification.
			//
			for (idx = 0; idx < MAX_UDK_KEYS; idx++)
				{
				if (pstPRI->chUDKAssignment == pstPRI->pacUDKSelectors[idx])
					break;
				}

			// Process a possible error.
			//
			if (idx >= MAX_UDK_KEYS)
				{
				goto UDKexit;
				}

			// When the sequence is saved in the key table,
			// this index will be used to identify which
			// key in that table will get the user defined sequence.
			//
			pstPRI->iUDKTableIndex  = idx;
			pstPRI->iUDKState		= SLASH_NEXT;
			}
		else
			{
			goto UDKexit;
			}

		break;

	case (SLASH_NEXT):
		if (emuCode == TEXT('/'))
			{
			pstPRI->iUDKState = CHAR_DIGIT1_NEXT;
			}
		else
			{
			goto UDKexit;
			}

		break;

	case (CHAR_DIGIT1_NEXT):
		switch(emuCode)
			{
		case(TEXT(';')):
		case 0x9C:
			if (emuDecStoreUDK(hhEmu) != 0)
				goto UDKexit;

			if (emuCode == TEXT('\x9C'))
				goto UDKexit;

			pstPRI->iUDKState = KEY_NUMBER_NEXT;
			break;

		case(TEXT('\x1B')):
			pstPRI->iUDKState = ESC_SEEN;
			break;

		default:
			if (!isxdigit(emuCode))
				{
				goto UDKexit;
				}

			// Collect the first half of the key comming in.
			//
			for (idx = 0; idx < 16; idx++)
				{
				if (emuCode == acAscii[idx])
					break;
				}

			pstPRI->chUDKAssignment = 0;
			pstPRI->chUDKAssignment = (TCHAR)(aiHex[idx] << 4);
			pstPRI->iUDKState		= CHAR_DIGIT2_NEXT;
			break;
			}

		break;

	case(CHAR_DIGIT2_NEXT):
		if (!isxdigit(emuCode))
			{
			goto UDKexit;
			}

		// This is the second half of the key comming in.
		//
		for (idx = 0; idx < 16; idx++)
			{
			if (emuCode == acAscii[idx])
				break;
			}

		pstPRI->chUDKAssignment += (TCHAR)aiHex[idx];

		if (pstPRI->chUDKAssignment >= 127)
			{
			goto UDKexit;
			}

		pstPRI->acUDKSequence[pstPRI->iUDKSequenceLen] =
			pstPRI->chUDKAssignment;

		pstPRI->iUDKSequenceLen += 1;
		pstPRI->iUDKState = CHAR_DIGIT1_NEXT;

		break;

	case(ESC_SEEN):
		if ((emuCode = TEXT('\\')) == 0)
			{
			goto UDKexit;
			}

		if (emuDecStoreUDK(hhEmu) != 0)
			{
			assert(FALSE);
			}

		// We have completed defining the user defined key sequences.
		// A flag set in emuDecClearUDK was set to identify the locked
		// or unlocked status of the sequences after their definition.
		// Promote that setting up to the variable used by the user
		// interface.
		//
		hhEmu->fAllowUserKeys = pstPRI->fUnlockedUDK;

		goto UDKexit;

	default:
		goto UDKexit;
		}

	// Returning from here allows the state table to pass control
	// back to this function, where the internal state (pstPRI->iUDKState)
	// will be used to control flow through the case statement above.
	//
	return;

UDKexit:
	// The sequence is complete or we're dropping out because of
	// an error.
	//

	// Initialize the UDK state and the emulators state.
	//
	pstPRI->iUDKState = KEY_NUMBER_NEXT;
	hhEmu->state = 0;

	return;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  emuDecStoreUDK
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 * Author:  John Masters
 *
 */
int emuDecStoreUDK(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	PSTEMUKEYDATA pstKey = pstPRI->pstUDK + pstPRI->iUDKTableIndex;

	// There may be a user settings that disables user defined keys.
	// If this feature in not enabled, get outta town.
	//
	if (!hhEmu->fAllowUserKeys)
		{
		return(0);
		}

	// First, free a previously allocated key for this entry, if
	// necessary.
	//
	if (pstKey->iSequenceLen != 0)
		{
		free(pstKey->pSequence);
		pstKey->iSequenceLen = 0;
		}

	// Now allocate the space for the key sequence.
	//
	pstKey->pSequence = malloc( sizeof(TCHAR) *
		(unsigned int)pstPRI->iUDKSequenceLen);

	if (pstKey->pSequence == 0)
		{
		assert(FALSE);
		return(-1);
		}

	// Now, copy the previously collected sequence into the key table
	// and initialize the length variable.
	//
	MemCopy(pstKey->pSequence,
		pstPRI->acUDKSequence,
		(unsigned int)pstPRI->iUDKSequenceLen);

	pstKey->iSequenceLen = (unsigned int)pstPRI->iUDKSequenceLen;

	return(0);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt220_level
 *
 * DESCRIPTION:
 *   Sets the compatibility level of the VT220.
 *
 * ARGUMENTS:
 *   none
 *
 * RETURNS:
 *   nothing
 */
void vt220_level(const HHEMU hhEmu)
	{
	int term, level;

	term = hhEmu->num_param[0];

	level = hhEmu->num_param_cnt > 0 ? hhEmu->num_param[1] : 0;

	if (level < 1)
		level = 0;

	if (term == 61)
		{
		if (hhEmu->mode_vt220)
			vt100_init(hhEmu);
		}

	else if (term == 62 || term == 63)
		{
		if (!hhEmu->mode_vt220)
			vt220_init(hhEmu);  /* sets mode_vt220 & mode_vt320 */

		if (level == 1)
			hhEmu->fUse8BitCodes = FALSE;

		if (level == 0 || level == 2)
			hhEmu->fUse8BitCodes = TRUE;

		if (term == 62 && hhEmu->mode_vt320)
			hhEmu->mode_vt320 = FALSE;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt220_protmode
 *
 * DESCRIPTION:
 *   Sets up and clears protect mode -- called selective erase on vt220.
 *
 * ARGUMENTS:
 *   none
 *
 * RETURNS:
 *   nothing
 */
void vt220_protmode(const HHEMU hhEmu)
	{
	hhEmu->mode_protect = (hhEmu->num_param[0] == 1);

	hhEmu->emu_charattr.protect = (unsigned int)hhEmu->mode_protect;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  emuDecKeyboardIn
 *
 * DESCRIPTION:
 *  This function processes the keyboard keys for all the DEC terminal
 *  emulators.
 *
 *  Please note that both emuSendKeyString, and emuDecSendKeyString are
 *  used in this function.  emuDecSendKeyString is a function that will
 *  convert the 8-bit sequence from the key table to a 7-bit value, if
 *  necessary.
 *
 *  Keys Used to Emulate a DEC Terminal's PF1-PF4 Keys
 *
 *  The keys normally used in HyperACCESS to emulate a DEC terminal's
 *  PF1-PF4 keys are F1-F4. Some people, however, prefer to use the
 *  keys at the top of the PC's numeric keypad (Num Lock, /, *, -),
 *  because these keys' physical location matches that of a DEC
 *  terminal's PF1-PF4 keys. If you prefer using these keys, select
 *  the "PF1-PF4 mapped to top row of keypad" checkbox in the
 *  terminal settings dialog for the DEC terminal you are using.
 *
 *  When "PF1-PF4 mapped to top row of keypad" is checked ...
 *
 *  The keys at the top of the keypad act as PF1-PF4, and F1-F4
 *  revert to performing functions defined by the operating system.
 *  For example, F1 displays help, and Num Lock sends the character
 *  sequence that the DEC terminal associates with PF1. The operating
 *  system will also sense that Num Lock has been pressed, and toggle
 *  the keyboard's Num Lock state. The Num Lock state, however, has
 *  no effect on the behavior of the DEC terminal emulator when
 *  PF1-PF4 are mapped to the top row of the keypad.
 *
 *  When "PF1-PF4 mapped to top row of keypad" is NOT checked...
 *
 *  F1-F4 act as PF1-PF4, and the keys at the top of the keypad (Num
 *  Lock, /, *, -) perform their normal functions. For example, F1
 *  sends the character sequence that the DEC terminal associates
 *  with PF1, and Num Lock toggles the keyboard's Num Lock state.
 *  When Num Lock is on, your PC's keypad (except the top row)
 *  emulates the numeric keypad of a DEC terminal. When Num Lock is
 *  off, your keypad's arrow keys emulate a DEC terminal's arrow
 *  keys. (If your keyboard has a separate set of arrow keys, that
 *  set will always emulate a DEC terminal's arrow keys, regardless
 *  Num Lock's state.)
 *
 * ARGUMENTS:
 *  HHEMU   hhEmu   -   The Internal emulator handle.
 *  int     Key     -   The key to process.
 *  int     fTest   -   Are we testing, or processing the key.
 *
 * RETURNS:
 *  This function returns the index of the table in which the key was
 *  found.
 *
 * AUTHOR: John Masters, 12-Sep-1995
 */
int emuDecKeyboardIn(const HHEMU hhEmu, int Key, const int fTest)
    {
    const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

    int index;
    int fNumlock;
    int fMovedPfKeys;
    int fSearchKeypad;
    int fCursorKeyMode;
    int fKeypadNumeric;
    int fKeypadApplication;
    int fSearchUDK;

    if (!fTest)
        {
#if 0
        DbgOutStr("VT100_KBDIN", 0, 0, 0, 0, 0);
        DbgOutStr("Key: Char     :0x%x", hKey.VKchar, 0, 0, 0, 0);
        DbgOutStr("     Virtual  :%d", hKey.Virtual, 0, 0, 0, 0);
        DbgOutStr("     Ctrl     :%d", hKey.Ctrl, 0, 0, 0, 0);
        DbgOutStr("     Alt      :%d", hKey.Alt, 0, 0, 0, 0);
        DbgOutStr("     Shift    :%d", hKey.Shift, 0, 0, 0, 0);
        DbgOutStr("     Extended :%d", hKey.Extended, 0, 0, 0, 0);
#endif
        }

    // Initialize some locals.  The keypad is either in Numeric Mode,
    // or Application Mode.  So, the first two locals below are mutually
    // exclusive variables.  They have been defined only to improve
    // readability in this code.
    //
    fKeypadApplication  = hhEmu->mode_DECKPAM;
    fKeypadNumeric