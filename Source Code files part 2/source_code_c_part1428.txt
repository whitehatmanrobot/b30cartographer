WbemClassObject_FWD_DEFINED__
#define __IEnumWbemClassObject_FWD_DEFINED__
typedef interface IEnumWbemClassObject IEnumWbemClassObject;
#endif 	/* __IEnumWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemCallResult_FWD_DEFINED__
#define __IWbemCallResult_FWD_DEFINED__
typedef interface IWbemCallResult IWbemCallResult;
#endif 	/* __IWbemCallResult_FWD_DEFINED__ */


#ifndef __IWbemCallResultEx_FWD_DEFINED__
#define __IWbemCallResultEx_FWD_DEFINED__
typedef interface IWbemCallResultEx IWbemCallResultEx;
#endif 	/* __IWbemCallResultEx_FWD_DEFINED__ */


#ifndef __IWbemContext_FWD_DEFINED__
#define __IWbemContext_FWD_DEFINED__
typedef interface IWbemContext IWbemContext;
#endif 	/* __IWbemContext_FWD_DEFINED__ */


#ifndef __IUnsecuredApartment_FWD_DEFINED__
#define __IUnsecuredApartment_FWD_DEFINED__
typedef interface IUnsecuredApartment IUnsecuredApartment;
#endif 	/* __IUnsecuredApartment_FWD_DEFINED__ */


#ifndef __IWbemStatusCodeText_FWD_DEFINED__
#define __IWbemStatusCodeText_FWD_DEFINED__
typedef interface IWbemStatusCodeText IWbemStatusCodeText;
#endif 	/* __IWbemStatusCodeText_FWD_DEFINED__ */


#ifndef __IWbemBackupRestore_FWD_DEFINED__
#define __IWbemBackupRestore_FWD_DEFINED__
typedef interface IWbemBackupRestore IWbemBackupRestore;
#endif 	/* __IWbemBackupRestore_FWD_DEFINED__ */


#ifndef __IWbemRefresher_FWD_DEFINED__
#define __IWbemRefresher_FWD_DEFINED__
typedef interface IWbemRefresher IWbemRefresher;
#endif 	/* __IWbemRefresher_FWD_DEFINED__ */


#ifndef __IWbemHiPerfEnum_FWD_DEFINED__
#define __IWbemHiPerfEnum_FWD_DEFINED__
typedef interface IWbemHiPerfEnum IWbemHiPerfEnum;
#endif 	/* __IWbemHiPerfEnum_FWD_DEFINED__ */


#ifndef __IWbemConfigureRefresher_FWD_DEFINED__
#define __IWbemConfigureRefresher_FWD_DEFINED__
typedef interface IWbemConfigureRefresher IWbemConfigureRefresher;
#endif 	/* __IWbemConfigureRefresher_FWD_DEFINED__ */


#ifndef __IWbemSecureObjectSink_FWD_DEFINED__
#define __IWbemSecureObjectSink_FWD_DEFINED__
typedef interface IWbemSecureObjectSink IWbemSecureObjectSink;
#endif 	/* __IWbemSecureObjectSink_FWD_DEFINED__ */


#ifndef __IWbemEventSink_FWD_DEFINED__
#define __IWbemEventSink_FWD_DEFINED__
typedef interface IWbemEventSink IWbemEventSink;
#endif 	/* __IWbemEventSink_FWD_DEFINED__ */


#ifndef __IWbemObjectSinkEx_FWD_DEFINED__
#define __IWbemObjectSinkEx_FWD_DEFINED__
typedef interface IWbemObjectSinkEx IWbemObjectSinkEx;
#endif 	/* __IWbemObjectSinkEx_FWD_DEFINED__ */


#ifndef __WbemLocator_FWD_DEFINED__
#define __WbemLocator_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemLocator WbemLocator;
#else
typedef struct WbemLocator WbemLocator;
#endif /* __cplusplus */

#endif 	/* __WbemLocator_FWD_DEFINED__ */


#ifndef __WbemConnection_FWD_DEFINED__
#define __WbemConnection_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemConnection WbemConnection;
#else
typedef struct WbemConnection WbemConnection;
#endif /* __cplusplus */

#endif 	/* __WbemConnection_FWD_DEFINED__ */


#ifndef __WbemContext_FWD_DEFINED__
#define __WbemContext_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemContext WbemContext;
#else
typedef struct WbemContext WbemContext;
#endif /* __cplusplus */

#endif 	/* __WbemContext_FWD_DEFINED__ */


#ifndef __UnsecuredApartment_FWD_DEFINED__
#define __UnsecuredApartment_FWD_DEFINED__

#ifdef __cplusplus
typedef class UnsecuredApartment UnsecuredApartment;
#else
typedef struct UnsecuredApartment UnsecuredApartment;
#endif /* __cplusplus */

#endif 	/* __UnsecuredApartment_FWD_DEFINED__ */


#ifndef __WbemClassObject_FWD_DEFINED__
#define __WbemClassObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemClassObject WbemClassObject;
#else
typedef struct WbemClassObject WbemClassObject;
#endif /* __cplusplus */

#endif 	/* __WbemClassObject_FWD_DEFINED__ */


#ifndef __MofCompiler_FWD_DEFINED__
#define __MofCompiler_FWD_DEFINED__

#ifdef __cplusplus
typedef class MofCompiler MofCompiler;
#else
typedef struct MofCompiler MofCompiler;
#endif /* __cplusplus */

#endif 	/* __MofCompiler_FWD_DEFINED__ */


#ifndef __WbemStatusCodeText_FWD_DEFINED__
#define __WbemStatusCodeText_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemStatusCodeText WbemStatusCodeText;
#else
typedef struct WbemStatusCodeText WbemStatusCodeText;
#endif /* __cplusplus */

#endif 	/* __WbemStatusCodeText_FWD_DEFINED__ */


#ifndef __WbemBackupRestore_FWD_DEFINED__
#define __WbemBackupRestore_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemBackupRestore WbemBackupRestore;
#else
typedef struct WbemBackupRestore WbemBackupRestore;
#endif /* __cplusplus */

#endif 	/* __WbemBackupRestore_FWD_DEFINED__ */


#ifndef __WbemRefresher_FWD_DEFINED__
#define __WbemRefresher_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemRefresher WbemRefresher;
#else
typedef struct WbemRefresher WbemRefresher;
#endif /* __cplusplus */

#endif 	/* __WbemRefresher_FWD_DEFINED__ */


#ifndef __WbemObjectTextSrc_FWD_DEFINED__
#define __WbemObjectTextSrc_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemObjectTextSrc WbemObjectTextSrc;
#else
typedef struct WbemObjectTextSrc WbemObjectTextSrc;
#endif /* __cplusplus */

#endif 	/* __WbemObjectTextSrc_FWD_DEFINED__ */


#ifndef __IWbemClassObject_FWD_DEFINED__
#define __IWbemClassObject_FWD_DEFINED__
typedef interface IWbemClassObject IWbemClassObject;
#endif 	/* __IWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemClassObjectEx_FWD_DEFINED__
#define __IWbemClassObjectEx_FWD_DEFINED__
typedef interface IWbemClassObjectEx IWbemClassObjectEx;
#endif 	/* __IWbemClassObjectEx_FWD_DEFINED__ */


#ifndef __IWbemQualifierSet_FWD_DEFINED__
#define __IWbemQualifierSet_FWD_DEFINED__
typedef interface IWbemQualifierSet IWbemQualifierSet;
#endif 	/* __IWbemQualifierSet_FWD_DEFINED__ */


#ifndef __IWbemLocator_FWD_DEFINED__
#define __IWbemLocator_FWD_DEFINED__
typedef interface IWbemLocator IWbemLocator;
#endif 	/* __IWbemLocator_FWD_DEFINED__ */


#ifndef __IWbemConnection_FWD_DEFINED__
#define __IWbemConnection_FWD_DEFINED__
typedef interface IWbemConnection IWbemConnection;
#endif 	/* __IWbemConnection_FWD_DEFINED__ */


#ifndef __IWbemObjectSink_FWD_DEFINED__
#define __IWbemObjectSink_FWD_DEFINED__
typedef interface IWbemObjectSink IWbemObjectSink;
#endif 	/* __IWbemObjectSink_FWD_DEFINED__ */


#ifndef __IEnumWbemClassObject_FWD_DEFINED__
#define __IEnumWbemClassObject_FWD_DEFINED__
typedef interface IEnumWbemClassObject IEnumWbemClassObject;
#endif 	/* __IEnumWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemContext_FWD_DEFINED__
#define __IWbemContext_FWD_DEFINED__
typedef interface IWbemContext IWbemContext;
#endif 	/* __IWbemContext_FWD_DEFINED__ */


#ifndef __IWbemCallResult_FWD_DEFINED__
#define __IWbemCallResult_FWD_DEFINED__
typedef interface IWbemCallResult IWbemCallResult;
#endif 	/* __IWbemCallResult_FWD_DEFINED__ */


#ifndef __IWbemServices_FWD_DEFINED__
#define __IWbemServices_FWD_DEFINED__
typedef interface IWbemServices IWbemServices;
#endif 	/* __IWbemServices_FWD_DEFINED__ */


#ifndef __IWbemServicesEx_FWD_DEFINED__
#define __IWbemServicesEx_FWD_DEFINED__
typedef interface IWbemServicesEx IWbemServicesEx;
#endif 	/* __IWbemServicesEx_FWD_DEFINED__ */


#ifndef __IWbemComBinding_FWD_DEFINED__
#define __IWbemComBinding_FWD_DEFINED__
typedef interface IWbemComBinding IWbemComBinding;
#endif 	/* __IWbemComBinding_FWD_DEFINED__ */


#ifndef __IWbemInitComBinding_FWD_DEFINED__
#define __IWbemInitComBinding_FWD_DEFINED__
typedef interface IWbemInitComBinding IWbemInitComBinding;
#endif 	/* __IWbemInitComBinding_FWD_DEFINED__ */


#ifndef __IWbemCallResultEx_FWD_DEFINED__
#define __IWbemCallResultEx_FWD_DEFINED__
typedef interface IWbemCallResultEx IWbemCallResultEx;
#endif 	/* __IWbemCallResultEx_FWD_DEFINED__ */


#ifndef __IWbemRawSdAccessor_FWD_DEFINED__
#define __IWbemRawSdAccessor_FWD_DEFINED__
typedef interface IWbemRawSdAccessor IWbemRawSdAccessor;
#endif 	/* __IWbemRawSdAccessor_FWD_DEFINED__ */


#ifndef __IWbemObjectSinkEx_FWD_DEFINED__
#define __IWbemObjectSinkEx_FWD_DEFINED__
typedef interface IWbemObjectSinkEx IWbemObjectSinkEx;
#endif 	/* __IWbemObjectSinkEx_FWD_DEFINED__ */


#ifndef __IWbemShutdown_FWD_DEFINED__
#define __IWbemShutdown_FWD_DEFINED__
typedef interface IWbemShutdown IWbemShutdown;
#endif 	/* __IWbemShutdown_FWD_DEFINED__ */


#ifndef __IWbemCallStatus_FWD_DEFINED__
#define __IWbemCallStatus_FWD_DEFINED__
typedef interface IWbemCallStatus IWbemCallStatus;
#endif 	/* __IWbemCallStatus_FWD_DEFINED__ */


#ifndef __IWbemObjectTextSrc_FWD_DEFINED__
#define __IWbemObjectTextSrc_FWD_DEFINED__
typedef interface IWbemObjectTextSrc IWbemObjectTextSrc;
#endif 	/* __IWbemObjectTextSrc_FWD_DEFINED__ */


#ifndef __IWbemObjectAccess_FWD_DEFINED__
#define __IWbemObjectAccess_FWD_DEFINED__
typedef interface IWbemObjectAccess IWbemObjectAccess;
#endif 	/* __IWbemObjectAccess_FWD_DEFINED__ */


#ifndef __IWbemTransaction_FWD_DEFINED__
#define __IWbemTransaction_FWD_DEFINED__
typedef interface IWbemTransaction IWbemTransaction;
#endif 	/* __IWbemTransaction_FWD_DEFINED__ */


#ifndef __IMofCompiler_FWD_DEFINED__
#define __IMofCompiler_FWD_DEFINED__
typedef interface IMofCompiler IMofCompiler;
#endif 	/* __IMofCompiler_FWD_DEFINED__ */


#ifndef __IUnsecuredApartment_FWD_DEFINED__
#define __IUnsecuredApartment_FWD_DEFINED__
typedef interface IUnsecuredApartment IUnsecuredApartment;
#endif 	/* __IUnsecuredApartment_FWD_DEFINED__ */


#ifndef __IWbemStatusCodeText_FWD_DEFINED__
#define __IWbemStatusCodeText_FWD_DEFINED__
typedef interface IWbemStatusCodeText IWbemStatusCodeText;
#endif 	/* __IWbemStatusCodeText_FWD_DEFINED__ */


#ifndef __IWbemBackupRestore_FWD_DEFINED__
#define __IWbemBackupRestore_FWD_DEFINED__
typedef interface IWbemBackupRestore IWbemBackupRestore;
#endif 	/* __IWbemBackupRestore_FWD_DEFINED__ */


#ifndef __IWbemRefresher_FWD_DEFINED__
#define __IWbemRefresher_FWD_DEFINED__
typedef interface IWbemRefresher IWbemRefresher;
#endif 	/* __IWbemRefresher_FWD_DEFINED__ */


#ifndef __IWbemHiPerfEnum_FWD_DEFINED__
#define __IWbemHiPerfEnum_FWD_DEFINED__
typedef interface IWbemHiPerfEnum IWbemHiPerfEnum;
#endif 	/* __IWbemHiPerfEnum_FWD_DEFINED__ */


#ifndef __IWbemConfigureRefresher_FWD_DEFINED__
#define __IWbemConfigureRefresher_FWD_DEFINED__
typedef interface IWbemConfigureRefresher IWbemConfigureRefresher;
#endif 	/* __IWbemConfigureRefresher_FWD_DEFINED__ */


#ifndef __IWbemSecureObjectSink_FWD_DEFINED__
#define __IWbemSecureObjectSink_FWD_DEFINED__
typedef interface IWbemSecureObjectSink IWbemSecureObjectSink;
#endif 	/* __IWbemSecureObjectSink_FWD_DEFINED__ */


#ifndef __IWbemEventSink_FWD_DEFINED__
#define __IWbemEventSink_FWD_DEFINED__
typedef interface IWbemEventSink IWbemEventSink;
#endif 	/* __IWbemEventSink_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 


#ifndef __WbemClient_v1_LIBRARY_DEFINED__
#define __WbemClient_v1_LIBRARY_DEFINED__

/* library WbemClient_v1 */
/* [uuid] */ 























typedef /* [v1_enum] */ 
enum tag_WBEM_GENUS_TYPE
    {	WBEM_GENUS_CLASS	= 1,
	WBEM_GENUS_INSTANCE	= 2
    } 	WBEM_GENUS_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_CHANGE_FLAG_TYPE
    {	WBEM_FLAG_CREATE_OR_UPDATE	= 0,
	WBEM_FLAG_UPDATE_ONLY	= 0x1,
	WBEM_FLAG_CREATE_ONLY	= 0x2,
	WBEM_FLAG_UPDATE_COMPATIBLE	= 0,
	WBEM_FLAG_UPDATE_SAFE_MODE	= 0x20,
	WBEM_FLAG_UPDATE_FORCE_MODE	= 0x40,
	WBEM_MASK_UPDATE_MODE	= 0x60,
	WBEM_FLAG_ADVISORY	= 0x10000
    } 	WBEM_CHANGE_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_GENERIC_FLAG_TYPE
    {	WBEM_FLAG_RETURN_IMMEDIATELY	= 0x10,
	WBEM_FLAG_RETURN_WBEM_COMPLETE	= 0,
	WBEM_FLAG_BIDIRECTIONAL	= 0,
	WBEM_FLAG_FORWARD_ONLY	= 0x20,
	WBEM_FLAG_NO_ERROR_OBJECT	= 0x40,
	WBEM_FLAG_RETURN_ERROR_OBJECT	= 0,
	WBEM_FLAG_SEND_STATUS	= 0x80,
	WBEM_FLAG_DONT_SEND_STATUS	= 0,
	WBEM_FLAG_ENSURE_LOCATABLE	= 0x100,
	WBEM_FLAG_DIRECT_READ	= 0x200,
	WBEM_FLAG_SEND_ONLY_SELECTED	= 0,
	WBEM_RETURN_WHEN_COMPLETE	= 0,
	WBEM_RETURN_IMMEDIATELY	= 0x10,
	WBEM_MASK_RESERVED_FLAGS	= 0x1f000,
	WBEM_FLAG_USE_AMENDED_QUALIFIERS	= 0x20000,
	WBEM_FLAG_USE_SECURITY_DESCRIPTOR	= 0x40000,
	WBEM_FLAG_REMOVE_CHILD_SECURITY	= 0x80000,
	WBEM_FLAG_STRONG_VALIDATION	= 0x100000
    } 	WBEM_GENERIC_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_NOTIFICATION_FLAG_TYPE
    {	WBEM_FLAG_MONITOR	= 0x800
    } 	WBEM_NOTIFICATION_FLAG_TYPE;

typedef 
enum tag_WBEM_STATUS_TYPE
    {	WBEM_STATUS_COMPLETE	= 0,
	WBEM_STATUS_REQUIREMENTS	= 1,
	WBEM_STATUS_PROGRESS	= 2
    } 	WBEM_STATUS_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_TIMEOUT_TYPE
    {	WBEM_NO_WAIT	= 0,
	WBEM_INFINITE	= 0xffffffff
    } 	WBEM_TIMEOUT_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_CONDITION_FLAG_TYPE
    {	WBEM_FLAG_ALWAYS	= 0,
	WBEM_FLAG_ONLY_IF_TRUE	= 0x1,
	WBEM_FLAG_ONLY_IF_FALSE	= 0x2,
	WBEM_FLAG_ONLY_IF_IDENTICAL	= 0x3,
	WBEM_MASK_PRIMARY_CONDITION	= 0x3,
	WBEM_FLAG_KEYS_ONLY	= 0x4,
	WBEM_FLAG_REFS_ONLY	= 0x8,
	WBEM_FLAG_LOCAL_ONLY	= 0x10,
	WBEM_FLAG_PROPAGATED_ONLY	= 0x20,
	WBEM_FLAG_SYSTEM_ONLY	= 0x30,
	WBEM_FLAG_NONSYSTEM_ONLY	= 0x40,
	WBEM_MASK_CONDITION_ORIGIN	= 0x70,
	WBEM_FLAG_CLASS_OVERRIDES_ONLY	= 0x100,
	WBEM_FLAG_CLASS_LOCAL_AND_OVERRIDES	= 0x200,
	WBEM_MASK_CLASS_CONDITION	= 0x300
    } 	WBEM_CONDITION_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_FLAVOR_TYPE
    {	WBEM_FLAVOR_DONT_PROPAGATE	= 0,
	WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE	= 0x1,
	WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS	= 0x2,
	WBEM_FLAVOR_MASK_PROPAGATION	= 0xf,
	WBEM_FLAVOR_OVERRIDABLE	= 0,
	WBEM_FLAVOR_NOT_OVERRIDABLE	= 0x10,
	WBEM_FLAVOR_MASK_PERMISSIONS	= 0x10,
	WBEM_FLAVOR_ORIGIN_LOCAL	= 0,
	WBEM_FLAVOR_ORIGIN_PROPAGATED	= 0x20,
	WBEM_FLAVOR_ORIGIN_SYSTEM	= 0x40,
	WBEM_FLAVOR_MASK_ORIGIN	= 0x60,
	WBEM_FLAVOR_NOT_AMENDED	= 0,
	WBEM_FLAVOR_AMENDED	= 0x80,
	WBEM_FLAVOR_MASK_AMENDED	= 0x80
    } 	WBEM_FLAVOR_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_QUERY_FLAG_TYPE
    {	WBEM_FLAG_DEEP	= 0,
	WBEM_FLAG_SHALLOW	= 1,
	WBEM_FLAG_PROTOTYPE	= 2
    } 	WBEM_QUERY_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_SECURITY_FLAGS
    {	WBEM_ENABLE	= 1,
	WBEM_METHOD_EXECUTE	= 2,
	WBEM_FULL_WRITE_REP	= 4,
	WBEM_PARTIAL_WRITE_REP	= 8,
	WBEM_WRITE_PROVIDER	= 0x10,
	WBEM_REMOTE_ACCESS	= 0x20,
	WBEM_RIGHT_SUBSCRIBE	= 0x40
    } 	WBEM_SECURITY_FLAGS;

typedef /* [v1_enum] */ 
enum tag_WBEM_LIMITATION_FLAG_TYPE
    {	WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS	= 0x10,
	WBEM_FLAG_EXCLUDE_PROPERTY_QUALIFIERS	= 0x20
    } 	WBEM_LIMITATION_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_TEXT_FLAG_TYPE
    {	WBEM_FLAG_NO_FLAVORS	= 0x1
    } 	WBEM_TEXT_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_COMPARISON_FLAG
    {	WBEM_COMPARISON_INCLUDE_ALL	= 0,
	WBEM_FLAG_IGNORE_QUALIFIERS	= 0x1,
	WBEM_FLAG_IGNORE_OBJECT_SOURCE	= 0x2,
	WBEM_FLAG_IGNORE_DEFAULT_VALUES	= 0x4,
	WBEM_FLAG_IGNORE_CLASS	= 0x8,
	WBEM_FLAG_IGNORE_CASE	= 0x10,
	WBEM_FLAG_IGNORE_FLAVOR	= 0x20
    } 	WBEM_COMPARISON_FLAG;

typedef /* [v1_enum] */ 
enum tag_WBEM_LOCKING
    {	WBEM_FLAG_ALLOW_READ	= 0x1
    } 	WBEM_LOCKING_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_CONNECT
    {	WBEM_FLAG_CREDENTIALS_SPECIFIED	= 0x1,
	WBEM_FLAG_CONNECT_SETUP_MODE	= 0x2,
	WBEM_FLAG_CONNECT_CIM_COMPLIANCE_MODE	= 0x4,
	WBEM_FLAG_OPEN_COLLECTION	= 0x10,
	WBEM_FLAG_OPEN_SCOPE	= 0x20,
	WBEM_FLAG_OPEN_NESTED_ONLY	= 0x40,
	WBEM_FLAG_OPEN_NAMESPACE	= 0x80,
	WBEM_FLAG_OPEN_VECTOR	= 0x100,
	WBEM_FLAG_OPEN_ALLOW_NS_TRAVERSAL	= 0x200,
	WBEM_FLAG_OPEN_ALLOW_MACHINE_TRAVERSAL	= 0x400
    } 	WBEM_CONNECT_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_GET_FLAGS
    {	WBEM_FLAG_GET_DEFAULT	= 0,
	WBEM_FLAG_SPAWN_INSTANCE	= 0x1
    } 	WBEM_GET_FLAGS;

typedef /* [v1_enum] */ 
enum tag_WBEM_PUT_FLAGS
    {	WBEM_FLAG_USE_CURRENT_TIME	= 0x1
    } 	WBEM_PUT_FLAGS;

typedef /* [v1_enum] */ 
enum tag_WBEM_PUTEX_FLAGS
    {	WBEM_FLAG_PUTEX_APPEND	= 0,
	WBEM_FLAG_PUTEX_INSERTAT	= 0x1,
	WBEM_MASK_PUTEX_OPERATION	= 0x1
    } 	WBEM_PUTEX_FLAGS;

typedef /* [v1_enum] */ 
enum tag_WBEM_DELETEEX_FLAGS
    {	WBEM_FLAG_PUTEX_DELETE	= 0,
	WBEM_FLAG_PUTEX_DELETE_FIRST_MATCH	= 0x1,
	WBEM_FLAG_DELETE_ALL_MATCHES	= 0x2,
	WBEM_MASK_DELETEEX_OPERATION	= 0x2
    } 	WBEM_DELETEEX_FLAGS;

typedef /* [v1_enum] */ 
enum tag_WBEM_MULTI_FLAG
    {	WBEM_MULTI_FLAG_NO_OP	= 0,
	WBEM_MULTI_FLAG_ARRAY_ALL	= 0x1,
	WBEM_MULTI_FLAG_ARRAY_SUBRANGE	= 0x2
    } 	WBEM_MULTI_FLAG;

typedef /* [v1_enum] */ 
enum tag_CIMTYPE_ENUMERATION
    {	CIM_ILLEGAL	= 0xfff,
	CIM_EMPTY	= 0,
	CIM_SINT8	= 16,
	CIM_UINT8	= 17,
	CIM_SINT16	= 2,
	CIM_UINT16	= 18,
	CIM_SINT32	= 3,
	CIM_UINT32	= 19,
	CIM_SINT64	= 20,
	CIM_UINT64	= 21,
	CIM_REAL32	= 4,
	CIM_REAL64	= 5,
	CIM_BOOLEAN	= 11,
	CIM_STRING	= 8,
	CIM_DATETIME	= 101,
	CIM_REFERENCE	= 102,
	CIM_CHAR16	= 103,
	CIM_OBJECT	= 13,
	CIM_IUNKNOWN	= 104,
	CIM_FLAG_ARRAY	= 0x2000
    } 	CIMTYPE_ENUMERATION;

typedef /* [v1_enum] */ 
enum tag_WBEM_BACKUP_RESTORE_FLAGS
    {	WBEM_FLAG_BACKUP_RESTORE_DEFAULT	= 0,
	WBEM_FLAG_BACKUP_RESTORE_FORCE_SHUTDOWN	= 1
    } 	WBEM_BACKUP_RESTORE_FLAGS;

typedef /* [v1_enum] */ 
enum tag_WBEM_REFRESHER_FLAGS
    {	WBEM_FLAG_REFRESH_AUTO_RECONNECT	= 0,
	WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT	= 1
    } 	WBEM_REFRESHER_FLAGS;

typedef 
enum tag_WBEM_SHUTDOWN_FLAGS
    {	WBEM_SHUTDOWN_UNLOAD_COMPONENT	= 1,
	WBEM_SHUTDOWN_WMI	= 2,
	WBEM_SHUTDOWN_OS	= 3
    } 	WBEM_SHUTDOWN_FLAGS;

typedef long CIMTYPE;

typedef /* [v1_enum] */ 
enum tag_WBEMSTATUS_FORMAT
    {	WBEMSTATUS_FORMAT_NEWLINE	= 0,
	WBEMSTATUS_FORMAT_NO_NEWLINE	= 1
    } 	WBEMSTATUS_FORMAT;

typedef /* [v1_enum] */ 
enum tag_WBEMSTATUS
    {	WBEM_NO_ERROR	= 0,
	WBEM_S_NO_ERROR	= 0,
	WBEM_S_SAME	= 0,
	WBEM_S_FALSE	= 1,
	WBEM_S_ALREADY_EXISTS	= 0x40001,
	WBEM_S_RESET_TO_DEFAULT	= 0x40002,
	WBEM_S_DIFFERENT	= 0x40003,
	WBEM_S_TIMEDOUT	= 0x40004,
	WBEM_S_NO_MORE_DATA	= 0x40005,
	WBEM_S_OPERATION_CANCELLED	= 0x40006,
	WBEM_S_PENDING	= 0x40007,
	WBEM_S_DUPLICATE_OBJECTS	= 0x40008,
	WBEM_S_ACCESS_DENIED	= 0x40009,
	WBEM_S_PARTIAL_RESULTS	= 0x40010,
	WBEM_S_NO_POSTHOOK	= 0x40011,
	WBEM_S_POSTHOOK_WITH_BOTH	= 0x40012,
	WBEM_S_POSTHOOK_WITH_NEW	= 0x40013,
	WBEM_S_POSTHOOK_WITH_STATUS	= 0x40014,
	WBEM_S_POSTHOOK_WITH_OLD	= 0x40015,
	WBEM_S_REDO_PREHOOK_WITH_ORIGINAL_OBJECT	= 0x40016,
	WBEM_E_FAILED	= 0x80041001,
	WBEM_E_NOT_FOUND	= 0x80041002,
	WBEM_E_ACCESS_DENIED	= 0x80041003,
	WBEM_E_PROVIDER_FAILURE	= 0x80041004,
	WBEM_E_TYPE_MISMATCH	= 0x80041005,
	WBEM_E_OUT_OF_MEMORY	= 0x80041006,
	WBEM_E_INVALID_CONTEXT	= 0x80041007,
	WBEM_E_INVALID_PARAMETER	= 0x80041008,
	WBEM_E_NOT_AVAILABLE	= 0x80041009,
	WBEM_E_CRITICAL_ERROR	= 0x8004100a,
	WBEM_E_INVALID_STREAM	= 0x8004100b,
	WBEM_E_NOT_SUPPORTED	= 0x8004100c,
	WBEM_E_INVALID_SUPERCLASS	= 0x8004100d,
	WBEM_E_INVALID_NAMESPACE	= 0x8004100e,
	WBEM_E_INVALID_OBJECT	= 0x8004100f,
	WBEM_E_INVALID_CLASS	= 0x80041010,
	WBEM_E_PROVIDER_NOT_FOUND	= 0x80041011,
	WBEM_E_INVALID_PROVIDER_REGISTRATION	= 0x80041012,
	WBEM_E_PROVIDER_LOAD_FAILURE	= 0x80041013,
	WBEM_E_INITIALIZATION_FAILURE	= 0x80041014,
	WBEM_E_TRANSPORT_FAILURE	= 0x80041015,
	WBEM_E_INVALID_OPERATION	= 0x80041016,
	WBEM_E_INVALID_QUERY	= 0x80041017,
	WBEM_E_INVALID_QUERY_TYPE	= 0x80041018,
	WBEM_E_ALREADY_EXISTS	= 0x80041019,
	WBEM_E_OVERRIDE_NOT_ALLOWED	= 0x8004101a,
	WBEM_E_PROPAGATED_QUALIFIER	= 0x8004101b,
	WBEM_E_PROPAGATED_PROPERTY	= 0x8004101c,
	WBEM_E_UNEXPECTED	= 0x8004101d,
	WBEM_E_ILLEGAL_OPERATION	= 0x8004101e,
	WBEM_E_CANNOT_BE_KEY	= 0x8004101f,
	WBEM_E_INCOMPLETE_CLASS	= 0x80041020,
	WBEM_E_INVALID_SYNTAX	= 0x80041021,
	WBEM_E_NONDECORATED_OBJECT	= 0x80041022,
	WBEM_E_READ_ONLY	= 0x80041023,
	WBEM_E_PROVIDER_NOT_CAPABLE	= 0x80041024,
	WBEM_E_CLASS_HAS_CHILDREN	= 0x80041025,
	WBEM_E_CLASS_HAS_INSTANCES	= 0x80041026,
	WBEM_E_QUERY_NOT_IMPLEMENTED	= 0x80041027,
	WBEM_E_ILLEGAL_NULL	= 0x80041028,
	WBEM_E_INVALID_QUALIFIER_TYPE	= 0x80041029,
	WBEM_E_INVALID_PROPERTY_TYPE	= 0x8004102a,
	WBEM_E_VALUE_OUT_OF_RANGE	= 0x8004102b,
	WBEM_E_CANNOT_BE_SINGLETON	= 0x8004102c,
	WBEM_E_INVALID_CIM_TYPE	= 0x8004102d,
	WBEM_E_INVALID_METHOD	= 0x8004102e,
	WBEM_E_INVALID_METHOD_PARAMETERS	= 0x8004102f,
	WBEM_E_SYSTEM_PROPERTY	= 0x80041030,
	WBEM_E_INVALID_PROPERTY	= 0x80041031,
	WBEM_E_CALL_CANCELLED	= 0x80041032,
	WBEM_E_SHUTTING_DOWN	= 0x80041033,
	WBEM_E_PROPAGATED_METHOD	= 0x80041034,
	WBEM_E_UNSUPPORTED_PARAMETER	= 0x80041035,
	WBEM_E_MISSING_PARAMETER_ID	= 0x80041036,
	WBEM_E_INVALID_PARAMETER_ID	= 0x80041037,
	WBEM_E_NONCONSECUTIVE_PARAMETER_IDS	= 0x80041038,
	WBEM_E_PARAMETER_ID_ON_RETVAL	= 0x80041039,
	WBEM_E_INVALID_OBJECT_PATH	= 0x8004103a,
	WBEM_E_OUT_OF_DISK_SPACE	= 0x8004103b,
	WBEM_E_BUFFER_TOO_SMALL	= 0x8004103c,
	WBEM_E_UNSUPPORTED_PUT_EXTENSION	= 0x8004103d,
	WBEM_E_UNKNOWN_OBJECT_TYPE	= 0x8004103e,
	WBEM_E_UNKNOWN_PACKET_TYPE	= 0x8004103f,
	WBEM_E_MARSHAL_VERSION_MISMATCH	= 0x80041040,
	WBEM_E_MARSHAL_INVALID_SIGNATURE	= 0x80041041,
	WBEM_E_INVALID_QUALIFIER	= 0x80041042,
	WBEM_E_INVALID_DUPLICATE_PARAMETER	= 0x80041043,
	WBEM_E_TOO_MUCH_DATA	= 0x80041044,
	WBEM_E_SERVER_TOO_BUSY	= 0x80041045,
	WBEM_E_INVALID_FLAVOR	= 0x80041046,
	WBEM_E_CIRCULAR_REFERENCE	= 0x80041047,
	WBEM_E_UNSUPPORTED_CLASS_UPDATE	= 0x80041048,
	WBEM_E_CANNOT_CHANGE_KEY_INHERITANCE	= 0x80041049,
	WBEM_E_CANNOT_CHANGE_INDEX_INHERITANCE	= 0x80041050,
	WBEM_E_TOO_MANY_PROPERTIES	= 0x80041051,
	WBEM_E_UPDATE_TYPE_MISMATCH	= 0x80041052,
	WBEM_E_UPDATE_OVERRIDE_NOT_ALLOWED	= 0x80041053,
	WBEM_E_UPDATE_PROPAGATED_METHOD	= 0x80041054,
	WBEM_E_METHOD_NOT_IMPLEMENTED	= 0x80041055,
	WBEM_E_METHOD_DISABLED	= 0x80041056,
	WBEM_E_REFRESHER_BUSY	= 0x80041057,
	WBEM_E_UNPARSABLE_QUERY	= 0x80041058,
	WBEM_E_NOT_EVENT_CLASS	= 0x80041059,
	WBEM_E_MISSING_GROUP_WITHIN	= 0x8004105a,
	WBEM_E_MISSING_AGGREGATION_LIST	= 0x8004105b,
	WBEM_E_PROPERTY_NOT_AN_OBJECT	= 0x8004105c,
	WBEM_E_AGGREGATING_BY_OBJECT	= 0x8004105d,
	WBEM_E_UNINTERPRETABLE_PROVIDER_QUERY	= 0x8004105f,
	WBEM_E_BACKUP_RESTORE_WINMGMT_RUNNING	= 0x80041060,
	WBEM_E_QUEUE_OVERFLOW	= 0x80041061,
	WBEM_E_PRIVILEGE_NOT_HELD	= 0x80041062,
	WBEM_E_INVALID_OPERATOR	= 0x80041063,
	WBEM_E_LOCAL_CREDENTIALS	= 0x80041064,
	WBEM_E_CANNOT_BE_ABSTRACT	= 0x80041065,
	WBEM_E_AMENDED_OBJECT	= 0x80041066,
	WBEM_E_CLIENT_TOO_SLOW	= 0x80041067,
	WBEM_E_NULL_SECURITY_DESCRIPTOR	= 0x80041068,
	WBEM_E_TIMED_OUT	= 0x80041069,
	WBEM_E_INVALID_ASSOCIATION	= 0x8004106a,
	WBEM_E_AMBIGUOUS_OPERATION	= 0x8004106b,
	WBEM_E_QUOTA_VIOLATION	= 0x8004106c,
	WBEM_E_TRANSACTION_CONFLICT	= 0x8004106d,
	WBEM_E_FORCED_ROLLBACK	= 0x8004106e,
	WBEM_E_UNSUPPORTED_LOCALE	= 0x8004106f,
	WBEM_E_HANDLE_OUT_OF_DATE	= 0x80041070,
	WBEM_E_CONNECTION_FAILED	= 0x80041071,
	WBEM_E_INVALID_HANDLE_REQUEST	= 0x80041072,
	WBEM_E_PROPERTY_NAME_TOO_WIDE	= 0x80041073,
	WBEM_E_CLASS_NAME_TOO_WIDE	= 0x80041074,
	WBEM_E_METHOD_NAME_TOO_WIDE	= 0x80041075,
	WBEM_E_QUALIFIER_NAME_TOO_WIDE	= 0x80041076,
	WBEM_E_RERUN_COMMAND	= 0x80041077,
	WBEM_E_DATABASE_VER_MISMATCH	= 0x80041078,
	WBEM_E_VETO_PUT	= 0x80041078,
	WBEM_E_VETO_DELETE	= 0x80041079,
	WBEM_E_INVALID_LOCALE	= 0x80041080,
	WBEM_E_PROVIDER_SUSPENDED	= 0x80041081,
	WBEM_E_SYNCHRONIZATION_REQUIRED	= 0x80041082,
	WBEM_E_NO_SCHEMA	= 0x80041083,
	WBEMESS_E_REGISTRATION_TOO_BROAD	= 0x80042001,
	WBEMESS_E_REGISTRATION_TOO_PRECISE	= 0x80042002
    } 	WBEMSTATUS;


EXTERN_C const IID LIBID_WbemClient_v1;

#ifndef __IWbemClassObject_INTERFACE_DEFINED__
#define __IWbemClassObject_INTERFACE_DEFINED__

/* interface IWbemClassObject */
/* [uuid][object][restricted][local] */ 


EXTERN_C const IID IID_IWbemClassObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dc12a681-737f-11cf-884d-00aa004b2e24")
    IWbemClassObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetQualifierSet( 
            /* [out] */ IWbemQualifierSet **ppQualSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ CIMTYPE *pType,
            /* [unique][in][out] */ long *plFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Put( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pVal,
            /* [in] */ CIMTYPE Type) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [string][in] */ LPCWSTR wszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNames( 
            /* [string][in] */ LPCWSTR wszQualifierName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pQualifierVal,
            /* [out] */ SAFEARRAY * *pNames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnumeration( 
            /* [in] */ long lEnumFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *strName,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ CIMTYPE *pType,
            /* [unique][in][out] */ long *plFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndEnumeration( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyQualifierSet( 
            /* [string][in] */ LPCWSTR wszProperty,
            /* [out] */ IWbemQualifierSet **ppQualSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IWbemClassObject **ppCopy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectText( 
            /* [in] */ long lFlags,
            /* [out] */ BSTR *pstrObjectText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SpawnDerivedClass( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppNewClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SpawnInstance( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppNewInstance) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareTo( 
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pCompareTo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyOrigin( 
            /* [string][in] */ LPCWSTR wszName,
            /* [out] */ BSTR *pstrClassName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InheritsFrom( 
            /* [in] */ LPCWSTR strAncestor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethod( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppInSignature,
            /* [out] */ IWbemClassObject **ppOutSignature) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutMethod( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pInSignature,
            /* [in] */ IWbemClassObject *pOutSignature) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteMethod( 
            /* [string][in] */ LPCWSTR wszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginMethodEnumeration( 
            /* [in] */ long lEnumFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NextMethod( 
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *pstrName,
            /* [unique][in][out] */ IWbemClassObject **ppInSignature,
            /* [unique][in][out] */ IWbemClassObject **ppOutSignature) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndMethodEnumeration( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethodQualifierSet( 
            /* [string][in] */ LPCWSTR wszMethod,
            /* [out] */ IWbemQualifierSet **ppQualSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethodOrigin( 
            /* [string][in] */ LPCWSTR wszMethodName,
            /* [out] */ BSTR *pstrClassName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemClassObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemClassObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemClassObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemClassObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetQualifierSet )( 
            IWbemClassObject * This,
            /* [out] */ IWbemQualifierSet **ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ CIMTYPE *pType,
            /* [unique][in][out] */ long *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *Put )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pVal,
            /* [in] */ CIMTYPE Type);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNames )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszQualifierName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pQualifierVal,
            /* [out] */ SAFEARRAY * *pNames);
        
        HRESULT ( STDMETHODCALLTYPE *BeginEnumeration )( 
            IWbemClassObject * This,
            /* [in] */ long lEnumFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IWbemClassObject * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *strName,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ CIMTYPE *pType,
            /* [unique][in][out] */ long *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *EndEnumeration )( 
            IWbemClassObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyQualifierSet )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszProperty,
            /* [out] */ IWbemQualifierSet **ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IWbemClassObject * This,
            /* [out] */ IWbemClassObject **ppCopy);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectText )( 
            IWbemClassObject * This,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *pstrObjectText);
        
        HRESULT ( STDMETHODCALLTYPE *SpawnDerivedClass )( 
            IWbemClassObject * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppNewClass);
        
        HRESULT ( STDMETHODCALLTYPE *SpawnInstance )( 
            IWbemClassObject * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppNewInstance);
        
        HRESULT ( STDMETHODCALLTYPE *CompareTo )( 
            IWbemClassObject * This,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pCompareTo);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyOrigin )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [out] */ BSTR *pstrClassName);
        
        HRESULT ( STDMETHODCALLTYPE *InheritsFrom )( 
            IWbemClassObject * This,
            /* [in] */ LPCWSTR strAncestor);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethod )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppInSignature,
            /* [out] */ IWbemClassObject **ppOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE *PutMethod )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pInSignature,
            /* [in] */ IWbemClassObject *pOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteMethod )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName);
        
        HRESULT ( STDMETHODCALLTYPE *BeginMethodEnumeration )( 
            IWbemClassObject * This,
            /* [in] */ long lEnumFlags);
        
        HRESULT ( STDMETHODCALLTYPE *NextMethod )( 
            IWbemClassObject * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *pstrName,
            /* [unique][in][out] */ IWbemClassObject **ppInSignature,
            /* [unique][in][out] */ IWbemClassObject **ppOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE *EndMethodEnumeration )( 
            IWbemClassObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodQualifierSet )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszMethod,
            /* [out] */ IWbemQualifierSet **ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodOrigin )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszMethodName,
            /* [out] */ BSTR *pstrClassName);
        
        END_INTERFACE
    } IWbemClassObjectVtbl;

    interface IWbemClassObject
    {
        CONST_VTBL struct IWbemClassObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemClassObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemClassObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemClassObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemClassObject_GetQualifierSet(This,ppQualSet)	\
    (This)->lpVtbl -> GetQualifierSet(This,ppQualSet)

#define IWbemClassObject_Get(This,wszName,lFlags,pVal,pType,plFlavor)	\
    (This)->lpVtbl -> Get(This,wszName,lFlags,pVal,pType,plFlavor)

#define IWbemClassObject_Put(This,wszName,lFlags,pVal,Type)	\
    (This)->lpVtbl -> Put(This,wszName,lFlags,pVal,Type)

#define IWbemClassObject_Delete(This,wszName)	\
    (This)->lpVtbl -> Delete(This,wszName)

#define IWbemClassObject_GetNames(This,wszQualifierName,lFlags,pQualifierVal,pNames)	\
    (This)->lpVtbl -> GetNames(This,wszQualifierName,lFlags,pQualifierVal,pNames)

#define IWbemClassObject_BeginEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lEnumFlags)

#define IWbemClassObject_Next(This,lFlags,strName,pVal,pType,plFlavor)	\
    (This)->lpVtbl -> Next(This,lFlags,strName,pVal,pType,plFlavor)

#define IWbemClassObject_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#define IWbemClassObject_GetPropertyQualifierSet(This,wszProperty,ppQualSet)	\
    (This)->lpVtbl -> GetPropertyQualifierSet(This,wszProperty,ppQualSet)

#define IWbemClassObject_Clone(This,ppCopy)	\
    (This)->lpVtbl -> Clone(This,ppCopy)

#define IWbemClassObject_GetObjectText(This,lFlags,pstrObjectText)	\
    (This)->lpVtbl -> GetObjectText(This,lFlags,pstrObjectText)

#define IWbemClassObject_SpawnDerivedClass(This,lFlags,ppNewClass)	\
    (This)->lpVtbl -> SpawnDerivedClass(This,lFlags,ppNewClass)

#define IWbemClassObject_SpawnInstance(This,lFlags,ppNewInstance)	\
    (This)->lpVtbl -> SpawnInstance(This,lFlags,ppNewInstance)

#define IWbemClassObject_CompareTo(This,lFlags,pCompareTo)	\
    (This)->lpVtbl -> CompareTo(This,lFlags,pCompareTo)

#define IWbemClassObject_GetPropertyOrigin(This,wszName,pstrClassName)	\
    (This)->lpVtbl -> GetPropertyOrigin(This,wszName,pstrClassName)

#define IWbemClassObject_InheritsFrom(This,strAncestor)	\
    (This)->lpVtbl -> InheritsFrom(This,strAncestor)

#define IWbemClassObject_GetMethod(This,wszName,lFlags,ppInSignature,ppOutSignature)	\
    (This)->lpVtbl -> GetMethod(This,wszName,lFlags,ppInSignature,ppOutSignature)

#define IWbemClassObject_PutMethod(This,wszName,lFlags,pInSignature,pOutSignature)	\
    (This)->lpVtbl -> PutMethod(This,wszName,lFlags,pInSignature,pOutSignature)

#define IWbemClassObject_DeleteMethod(This,wszName)	\
    (This)->lpVtbl -> DeleteMethod(This,wszName)

#define IWbemClassObject_BeginMethodEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginMethodEnumeration(This,lEnumFlags)

#define IWbemClassObject_NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature)	\
    (This)->lpVtbl -> NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature)

#define IWbemClassObject_EndMethodEnumeration(This)	\
    (This)->lpVtbl -> EndMethodEnumeration(This)

#define IWbemClassObject_GetMethodQualifierSet(This,wszMethod,ppQualSet)	\
    (This)->lpVtbl -> GetMethodQualifierSet(This,wszMethod,ppQualSet)

#define IWbemClassObject_GetMethodOrigin(This,wszMethodName,pstrClassName)	\
    (This)->lpVtbl -> GetMethodOrigin(This,wszMethodName,pstrClassName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemClassObject_GetQualifierSet_Proxy( 
    IWbemClassObject * This,
    /* [out] */ IWbemQualifierSet **ppQualSet);


void __RPC_STUB IWbemClassObject_GetQualifierSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Get_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ VARIANT *pVal,
    /* [unique][in][out] */ CIMTYPE *pType,
    /* [unique][in][out] */ long *plFlavor);


void __RPC_STUB IWbemClassObject_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Put_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT *pVal,
    /* [in] */ CIMTYPE Type);


void __RPC_STUB IWbemClassObject_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Delete_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName);


void __RPC_STUB IWbemClassObject_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetNames_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszQualifierName,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT *pQualifierVal,
    /* [out] */ SAFEARRAY * *pNames);


void __RPC_STUB IWbemClassObject_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_BeginEnumeration_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lEnumFlags);


void __RPC_STUB IWbemClassObject_BeginEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Next_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ BSTR *strName,
    /* [unique][in][out] */ VARIANT *pVal,
    /* [unique][in][out] */ CIMTYPE *pType,
    /* [unique][in][out] */ long *plFlavor);


void __RPC_STUB IWbemClassObject_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_EndEnumeration_Proxy( 
    IWbemClassObject * This);


void __RPC_STUB IWbemClassObject_EndEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetPropertyQualifierSet_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszProperty,
    /* [out] */ IWbemQualifierSet **ppQualSet);


void __RPC_STUB IWbemClassObject_GetPropertyQualifierSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Clone_Proxy( 
    IWbemClassObject * This,
    /* [out] */ IWbemClassObject **ppCopy);


void __RPC_STUB IWbemClassObject_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetObjectText_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lFlags,
    /* [out] */ BSTR *pstrObjectText);


void __RPC_STUB IWbemClassObject_GetObjectText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_SpawnDerivedClass_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lFlags,
    /* [out] */ IWbemClassObject **ppNewClass);


void __RPC_STUB IWbemClassObject_SpawnDerivedClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_SpawnInstance_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lFlags,
    /* [out] */ IWbemClassObject **ppNewInstance);


void __RPC_STUB IWbemClassObject_SpawnInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_CompareTo_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lFlags,
    /* [in] */ IWbemClassObject *pCompareTo);


void __RPC_STUB IWbemClassObject_CompareTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetPropertyOrigin_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [out] */ BSTR *pstrClassName);


void __RPC_STUB IWbemClassObject_GetPropertyOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_InheritsFrom_Proxy( 
    IWbemClassObject * This,
    /* [in] */ LPCWSTR strAncestor);


void __RPC_STUB IWbemClassObject_InheritsFrom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetMethod_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [out] */ IWbemClassObject **ppInSignature,
    /* [out] */ IWbemClassObject **ppOutSignature);


void __RPC_STUB IWbemClassObject_GetMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_PutMethod_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemClassObject *pInSignature,
    /* [in] */ IWbemClassObject *pOutSignature);


void __RPC_STUB IWbemClassObject_PutMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_DeleteMethod_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName);


void __RPC_STUB IWbemClassObject_DeleteMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_BeginMethodEnumeration_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lEnumFlags);


void __RPC_STUB IWbemClassObject_BeginMethodEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_NextMethod_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ BSTR *pstrName,
    /* [unique][in][out] */ IWbemClassObject **ppInSignature,
    /* [unique][in][out] */ IWbemClassObject **ppOutSignature);


void __RPC_STUB IWbemClassObject_NextMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_EndMethodEnumeration_Proxy( 
    IWbemClassObject * This);


void __RPC_STUB IWbemClassObject_EndMethodEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetMethodQualifierSet_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszMethod,
    /* [out] */ IWbemQualifierSet **ppQualSet);


void __RPC_STUB IWbemClassObject_GetMethodQualifierSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetMethodOrigin_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszMethodName,
    /* [out] */ BSTR *pstrClassName);


void __RPC_STUB IWbemClassObject_GetMethodOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemClassObject_INTERFACE_DEFINED__ */


#ifndef __IWbemClassObjectEx_INTERFACE_DEFINED__
#define __IWbemClassObjectEx_INTERFACE_DEFINED__

/* interface IWbemClassObjectEx */
/* [uuid][local][restricted][object] */ 


EXTERN_C const IID IID_IWbemClassObjectEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0E130F89-81D9-4386-B3BE-092651D04588")
    IWbemClassObjectEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PutEx( 
            /* [in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pvFilter,
            /* [in] */ VARIANT *pvInVals) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteEx( 
            /* [in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pvFilter,
            /* [in] */ VARIANT *pvInVals) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEx( 
            /* [in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pvFilter,
            /* [in] */ VARIANT *pvInVals,
            /* [unique][in][out] */ CIMTYPE *pCimType,
            /* [unique][in][out] */ long *plFlavor) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemClassObjectExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemClassObjectEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemClassObjectEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemClassObjectEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *PutEx )( 
            IWbemClassObjectEx * This,
            /* [in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pvFilter,
            /* [in] */ VARIANT *pvInVals);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteEx )( 
            IWbemClassObjectEx * This,
            /* [in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pvFilter,
            /* [in] */ VARIANT *pvInVals);
        
        HRESULT ( STDMETHODCALLTYPE *GetEx )( 
            IWbemClassObjectEx * This,
            /* [in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pvFilter,
            /* [in] */ VARIANT *pvInVals,
            /* [unique][in][out] */ CIMTYPE *pCimType,
            /* [unique][in][out] */ long *plFlavor);
        
        END_INTERFACE
    } IWbemClassObjectExVtbl;

    interface IWbemClassObjectEx
    {
        CONST_VTBL struct IWbemClassObjectExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemClassObjectEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemClassObjectEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemClassObjectEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemClassObjectEx_PutEx(This,wszName,lFlags,pvFilter,pvInVals)	\
    (This)->lpVtbl -> PutEx(This,wszName,lFlags,pvFilter,pvInVals)

#define IWbemClassObjectEx_DeleteEx(This,wszName,lFlags,pvFilter,pvInVals)	\
    (This)->lpVtbl -> DeleteEx(This,wszName,lFlags,pvFilter,pvInVals)

#define IWbemClassObjectEx_GetEx(This,wszName,lFlags,pvFilter,pvInVals,pCimType,plFlavor)	\
    (This)->lpVtbl -> GetEx(This,wszName,lFlags,pvFilter,pvInVals,pCimType,plFlavor)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemClassObjectEx_PutEx_Proxy( 
    IWbemClassObjectEx * This,
    /* [in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT *pvFilter,
    /* [in] */ VARIANT *pvInVals);


void __RPC_STUB IWbemClassObjectEx_PutEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObjectEx_DeleteEx_Proxy( 
    IWbemClassObjectEx * This,
    /* [in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT *pvFilter,
    /* [in] */ VARIANT *pvInVals);


void __RPC_STUB IWbemClassObjectEx_DeleteEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObjectEx_GetEx_Proxy( 
    IWbemClassObjectEx * This,
    /* [in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT *pvFilter,
    /* [in] */ VARIANT *pvInVals,
    /* [unique][in][out] */ CIMTYPE *pCimType,
    /* [unique][in][out] */ long *plFlavor);


void __RPC_STUB IWbemClassObjectEx_GetEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemClassObjectEx_INTERFACE_DEFINED__ */


#ifndef __IWbemObjectAccess_INTERFACE_DEFINED__
#define __IWbemObjectAccess_INTERFACE_DEFINED__

/* interface IWbemObjectAccess */
/* [uuid][object][restricted][local] */ 


EXTERN_C const IID IID_IWbemObjectAccess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49353c9a-516b-11d1-aea6-00c04fb68820")
    IWbemObjectAccess : public IWbemClassObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyHandle( 
            /* [string][in] */ LPCWSTR wszPropertyName,
            /* [out] */ CIMTYPE *pType,
            /* [out] */ long *plHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WritePropertyValue( 
            /* [in] */ long lHandle,
            /* [in] */ long lNumBytes,
            /* [size_is][in] */ const byte *aData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadPropertyValue( 
            /* [in] */ long lHandle,
            /* [in] */ long lBufferSize,
            /* [out] */ long *plNumBytes,
            /* [length_is][size_is][out] */ byte *aData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadDWORD( 
            /* [in] */ long lHandle,
            /* [out] */ DWORD *pdw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteDWORD( 
            /* [in] */ long lHandle,
            /* [in] */ DWORD dw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadQWORD( 
            /* [in] */ long lHandle,
            /* [out] */ unsigned __int64 *pqw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteQWORD( 
            /* [in] */ long lHandle,
            /* [in] */ unsigned __int64 pw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyInfoByHandle( 
            /* [in] */ long lHandle,
            /* [out] */ BSTR *pstrName,
            /* [out] */ CIMTYPE *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Lock( 
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unlock( 
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemObjectAccessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemObjectAccess * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemObjectAccess * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemObjectAccess * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetQualifierSet )( 
            IWbemObjectAccess * This,
            /* [out] */ IWbemQualifierSet **ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ CIMTYPE *pType,
            /* [unique][in][out] */ long *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *Put )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pVal,
            /* [in] */ CIMTYPE Type);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNames )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszQualifierName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pQualifierVal,
            /* [out] */ SAFEARRAY * *pNames);
        
        HRESULT ( STDMETHODCALLTYPE *BeginEnumeration )( 
            IWbemObjectAccess * This,
            /* [in] */ long lEnumFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *strName,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ CIMTYPE *pType,
            /* [unique][in][out] */ long *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *EndEnumeration )( 
            IWbemObjectAccess * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyQualifierSet )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszProperty,
            /* [out] */ IWbemQualifierSet **ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IWbemObjectAccess * This,
            /* [out] */ IWbemClassObject **ppCopy);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectText )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *pstrObjectText);
        
        HRESULT ( STDMETHODCALLTYPE *SpawnDerivedClass )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppNewClass);
        
        HRESULT ( STDMETHODCALLTYPE *SpawnInstance )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppNewInstance);
        
        HRESULT ( STDMETHODCALLTYPE *CompareTo )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pCompareTo);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyOrigin )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [out] */ BSTR *pstrClassName);
        
        HRESULT ( STDMETHODCALLTYPE *InheritsFrom )( 
            IWbemObjectAccess * This,
            /* [in] */ LPCWSTR strAncestor);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethod )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppInSignature,
            /* [out] */ IWbemClassObject **ppOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE *PutMethod )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pInSignature,
            /* [in] */ IWbemClassObject *pOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteMethod )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName);
        
        HRESULT ( STDMETHODCALLTYPE *BeginMethodEnumeration )( 
            IWbemObjectAccess * This,
            /* [in] */ long lEnumFlags);
        
        HRESULT ( STDMETHODCALLTYPE *NextMethod )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *pstrName,
            /* [unique][in][out] */ IWbemClassObject **ppInSignature,
            /* [unique][in][out] */ IWbemClassObject **ppOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE *EndMethodEnumeration )( 
            IWbemObjectAccess * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodQualifierSet )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszMethod,
            /* [out] */ IWbemQualifierSet **ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodOrigin )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszMethodName,
            /* [out] */ BSTR *pstrClassName);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyHandle )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszPropertyName,
            /* [out] */ CIMTYPE *pType,
            /* [out] */ long *plHandle);
        
        HRESULT ( STDMETHODCALLTYPE *WritePropertyValue )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [in] */ long lNumBytes,
            /* [size_is][in] */ const byte *aData);
        
        HRESULT ( STDMETHODCALLTYPE *ReadPropertyValue )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [in] */ long lBufferSize,
            /* [out] */ long *plNumBytes,
            /* [length_is][size_is][out] */ byte *aData);
        
        HRESULT ( STDMETHODCALLTYPE *ReadDWORD )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [out] */ DWORD *pdw);
        
        HRESULT ( STDMETHODCALLTYPE *WriteDWORD )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [in] */ DWORD dw);
        
        HRESULT ( STDMETHODCALLTYPE *ReadQWORD )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [out] */ unsigned __int64 *pqw);
        
        HRESULT ( STDMETHODCALLTYPE *WriteQWORD )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [in] */ unsigned __int64 pw);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyInfoByHandle )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [out] */ BSTR *pstrName,
            /* [out] */ CIMTYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *Lock )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Unlock )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemObjectAccessVtbl;

    interface IWbemObjectAccess
    {
        CONST_VTBL struct IWbemObjectAccessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemObjectAccess_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemObjectAccess_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemObjectAccess_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemObjectAccess_GetQualifierSet(This,ppQualSet)	\
    (This)->lpVtbl -> GetQualifierSet(This,ppQualSet)

#define IWbemObjectAccess_Get(This,wszName,lFlags,pVal,pType,plFlavor)	\
    (This)->lpVtbl -> Get(This,wszName,lFlags,pVal,pType,plFlavor)

#define IWbemObjectAccess_Put(This,wszName,lFlags,pVal,Type)	\
    (This)->lpVtbl -> Put(This,wszName,lFlags,pVal,Type)

#define IWbemObjectAccess_Delete(This,wszName)	\
    (This)->lpVtbl -> Delete(This,wszName)

#define IWbemObjectAccess_GetNames(This,wszQualifierName,lFlags,pQualifierVal,pNames)	\
    (This)->lpVtbl -> GetNames(This,wszQualifierName,lFlags,pQualifierVal,pNames)

#define IWbemObjectAccess_BeginEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lEnumFlags)

#define IWbemObjectAccess_Next(This,lFlags,strName,pVal,pType,plFlavor)	\
    (This)->lpVtbl -> Next(This,lFlags,strName,pVal,pType,plFlavor)

#define IWbemObjectAccess_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#define IWbemObjectAccess_GetPropertyQualifierSet(This,wszProperty,ppQualSet)	\
    (This)->lpVtbl -> GetPropertyQualifierSet(This,wszProperty,ppQualSet)

#define IWbemObjectAccess_Clone(This,ppCopy)	\
    (This)->lpVtbl -> Clone(This,ppCopy)

#define IWbemObjectAccess_GetObjectText(This,lFlags,pstrObjectText)	\
    (This)->lpVtbl -> GetObjectText(This,lFlags,pstrObjectText)

#define IWbemObjectAccess_SpawnDerivedClass(This,lFlags,ppNewClass)	\
    (This)->lpVtbl -> SpawnDerivedClass(This,lFlags,ppNewClass)

#define IWbemObjectAccess_SpawnInstance(This,lFlags,ppNewInstance)	\
    (This)->lpVtbl -> SpawnInstance(This,lFlags,ppNewInstance)

#define IWbemObjectAccess_CompareTo(This,lFlags,pCompareTo)	\
    (This)->lpVtbl -> CompareTo(This,lFlags,pCompareTo)

#define IWbemObjectAccess_GetPropertyOrigin(This,wszName,pstrClassName)	\
    (This)->lpVtbl -> GetPropertyOrigin(This,wszName,pstrClassName)

#define IWbemObjectAccess_InheritsFrom(This,strAncestor)	\
    (This)->lpVtbl -> InheritsFrom(This,strAncestor)

#define IWbemObjectAccess_GetMethod(This,wszName,lFlags,ppInSignature,ppOutSignature)	\
    (This)->lpVtbl -> GetMethod(This,wszName,lFlags,ppInSignature,ppOutSignature)

#define IWbemObjectAccess_PutMethod(This,wszName,lFlags,pInSignature,pOutSignature)	\
    (This)->lpVtbl -> PutMethod(This,wszName,lFlags,pInSignature,pOutSignature)

#define IWbemObjectAccess_DeleteMethod(This,wszName)	\
    (This)->lpVtbl -> DeleteMethod(This,wszName)

#define IWbemObjectAccess_BeginMethodEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginMethodEnumeration(This,lEnumFlags)

#define IWbemObjectAccess_NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature)	\
    (This)->lpVtbl -> NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature)

#define IWbemObjectAccess_EndMethodEnumeration(This)	\
    (This)->lpVtbl -> EndMethodEnumeration(This)

#define IWbemObjectAccess_GetMethodQualifierSet(This,wszMethod,ppQualSet)	\
    (This)->lpVtbl -> GetMethodQualifierSet(This,wszMethod,ppQualSet)

#define IWbemObjectAccess_GetMethodOrigin(This,wszMethodName,pstrClassName)	\
    (This)->lpVtbl -> GetMethodOrigin(This,wszMethodName,pstrClassName)


#define IWbemObjectAccess_GetPropertyHandle(This,wszPropertyName,pType,plHandle)	\
    (This)->lpVtbl -> GetPropertyHandle(This,wszPropertyName,pType,plHandle)

#define IWbemObjectAccess_WritePropertyValue(This,lHandle,lNumBytes,aData)	\
    (This)->lpVtbl -> WritePropertyValue(This,lHandle,lNumBytes,aData)

#define IWbemObjectAccess_ReadPropertyValue(This,lHandle,lBufferSize,plNumBytes,aData)	\
    (This)->lpVtbl -> ReadPropertyValue(This,lHandle,lBufferSize,plNumBytes,aData)

#define IWbemObjectAccess_ReadDWORD(This,lHandle,pdw)	\
    (This)->lpVtbl -> ReadDWORD(This,lHandle,pdw)

#define IWbemObjectAccess_WriteDWORD(This,lHandle,dw)	\
    (This)->lpVtbl -> WriteDWORD(This,lHandle,dw)

#define IWbemObjectAccess_ReadQWORD(This,lHandle,pqw)	\
    (This)->lpVtbl -> ReadQWORD(This,lHandle,pqw)

#define IWbemObjectAccess_WriteQWORD(This,lHandle,pw)	\
    (This)->lpVtbl -> WriteQWORD(This,lHandle,pw)

#define IWbemObjectAccess_GetPropertyInfoByHandle(This,lHandle,pstrName,pType)	\
    (This)->lpVtbl -> GetPropertyInfoByHandle(This,lHandle,pstrName,pType)

#define IWbemObjectAccess_Lock(This,lFlags)	\
    (This)->lpVtbl -> Lock(This,lFlags)

#define IWbemObjectAccess_Unlock(This,lFlags)	\
    (This)->lpVtbl -> Unlock(This,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemObjectAccess_GetPropertyHandle_Proxy( 
    IWbemObjectAccess * This,
    /* [string][in] */ LPCWSTR wszPropertyName,
    /* [out] */ CIMTYPE *pType,
    /* [out] */ long *plHandle);


void __RPC_STUB IWbemObjectAccess_GetPropertyHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_WritePropertyValue_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [in] */ long lNumBytes,
    /* [size_is][in] */ const byte *aData);


void __RPC_STUB IWbemObjectAccess_WritePropertyValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_ReadPropertyValue_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [in] */ long lBufferSize,
    /* [out] */ long *plNumBytes,
    /* [length_is][size_is][out] */ byte *aData);


void __RPC_STUB IWbemObjectAccess_ReadPropertyValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_ReadDWORD_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [out] */ DWORD *pdw);


void __RPC_STUB IWbemObjectAccess_ReadDWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_WriteDWORD_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [in] */ DWORD dw);


void __RPC_STUB IWbemObjectAccess_WriteDWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_ReadQWORD_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [out] */ unsigned __int64 *pqw);


void __RPC_STUB IWbemObjectAccess_ReadQWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_WriteQWORD_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [in] */ unsigned __int64 pw);


void __RPC_STUB IWbemObjectAccess_WriteQWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_GetPropertyInfoByHandle_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [out] */ BSTR *pstrName,
    /* [out] */ CIMTYPE *pType);


void __RPC_STUB IWbemObjectAccess_GetPropertyInfoByHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_Lock_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemObjectAccess_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_Unlock_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemObjectAccess_Unlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemObjectAccess_INTERFACE_DEFINED__ */


#ifndef __IWbemQualifierSet_INTERFACE_DEFINED__
#define __IWbemQualifierSet_INTERFACE_DEFINED__

/* interface IWbemQualifierSet */
/* [uuid][local][restricted][object] */ 


EXTERN_C const IID IID_IWbemQualifierSet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dc12a680-737f-11cf-884d-00aa004b2e24")
    IWbemQualifierSet : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ long *plFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Put( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ VARIANT *pVal,
            /* [in] */ long lFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [string][in] */ LPCWSTR wszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNames( 
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY * *pNames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnumeration( 
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *pstrName,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ long *plFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndEnumeration( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemQualifierSetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemQualifierSet * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemQualifierSet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemQualifierSet * This);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            IWbemQualifierSet * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ long *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *Put )( 
            IWbemQualifierSet * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ VARIANT *pVal,
            /* [in] */ long lFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IWbemQualifierSet * This,
            /* [string][in] */ LPCWSTR wszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNames )( 
            IWbemQualifierSet * This,
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY * *pNames);
        
        HRESULT ( STDMETHODCALLTYPE *BeginEnumeration )( 
            IWbemQualifierSet * This,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IWbemQualifierSet * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *pstrName,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ long *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *EndEnumeration )( 
            IWbemQualifierSet * This);
        
        END_INTERFACE
    } IWbemQualifierSetVtbl;

    interface IWbemQualifierSet
    {
        CONST_VTBL struct IWbemQualifierSetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemQualifierSet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemQualifierSet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemQualifierSet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemQualifierSet_Get(This,wszName,lFlags,pVal,plFlavor)	\
    (This)->lpVtbl -> Get(This,wszName,lFlags,pVal,plFlavor)

#define IWbemQualifierSet_Put(This,wszName,pVal,lFlavor)	\
    (This)->lpVtbl -> Put(This,wszName,pVal,lFlavor)

#define IWbemQualifierSet_Delete(This,wszName)	\
    (This)->lpVtbl -> Delete(This,wszName)

#define IWbemQualifierSet_GetNames(This,lFlags,pNames)	\
    (This)->lpVtbl -> GetNames(This,lFlags,pNames)

#define IWbemQualifierSet_BeginEnumeration(This,lFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lFlags)

#define IWbemQualifierSet_Next(This,lFlags,pstrName,pVal,plFlavor)	\
    (This)->lpVtbl -> Next(This,lFlags,pstrName,pVal,plFlavor)

#define IWbemQualifierSet_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Get_Proxy( 
    IWbemQualifierSet * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ VARIANT *pVal,
    /* [unique][in][out] */ long *plFlavor);


void __RPC_STUB IWbemQualifierSet_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Put_Proxy( 
    IWbemQualifierSet * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ VARIANT *pVal,
    /* [in] */ long lFlavor);


void __RPC_STUB IWbemQualifierSet_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Delete_Proxy( 
    IWbemQualifierSet * This,
    /* [string][in] */ LPCWSTR wszName);


void __RPC_STUB IWbemQualifierSet_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_GetNames_Proxy( 
    IWbemQualifierSet * This,
    /* [in] */ long lFlags,
    /* [out] */ SAFEARRAY * *pNames);


void __RPC_STUB IWbemQualifierSet_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_BeginEnumeration_Proxy( 
    IWbemQualifierSet * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemQualifierSet_BeginEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Next_Proxy( 
    IWbemQualifierSet * This,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ BSTR *pstrName,
    /* [unique][in][out] */ VARIANT *pVal,
    /* [unique][in][out] */ long *plFlavor);


void __RPC_STUB IWbemQualifierSet_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_EndEnumeration_Proxy( 
    IWbemQualifierSet * This);


void __RPC_STUB IWbemQualifierSet_EndEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemQualifierSet_INTERFACE_DEFINED__ */


#ifndef __IWbemServices_INTERFACE_DEFINED__
#define __IWbemServices_INTERFACE_DEFINED__

/* interface IWbemServices */
/* [unique][uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9556dc99-828c-11cf-a37e-00aa003240c7")
    IWbemServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemServices **ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink **ppResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemClassObject **ppObject,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [unique][in][out] */ IWbemClassObject **ppOutParams,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *OpenNamespace )( 
            IWbemServices * This,
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemServices **ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *CancelAsyncCall )( 
            IWbemServices * This,
            /* [in] */ IWbemObjectSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *QueryObjectSink )( 
            IWbemServices * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink **ppResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            IWbemServices * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemClassObject **ppObject,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *PutClass )( 
            IWbemServices * This,
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *PutClassAsync )( 
            IWbemServices * This,
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteClass )( 
            IWbemServices * This,
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteClassAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *CreateClassEnum )( 
            IWbemServices * This,
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CreateClassEnumAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *PutInstance )( 
            IWbemServices * This,
            /* [in] */ IWbemClassObject *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *PutInstanceAsync )( 
            IWbemServices * This,
            /* [in] */ IWbemClassObject *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteInstance )( 
            IWbemServices * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteInstanceAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInstanceEnum )( 
            IWbemServices * This,
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInstanceEnumAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *ExecQuery )( 
            IWbemServices * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *ExecQueryAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *ExecNotificationQuery )( 
            IWbemServices * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *ExecNotificationQueryAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *ExecMethod )( 
            IWbemServices * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [unique][in][out] */ IWbemClassObject **ppOutParams,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *ExecMethodAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        END_INTERFACE
    } IWbemServicesVtbl;

    interface IWbemServices
    {
        CONST_VTBL struct IWbemServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemServices_OpenNamespace(This,strNamespace,lFlags,pCtx,ppWorkingNamespace,ppResult)	\
    (This)->lpVtbl -> OpenNamespace(This,strNamespace,lFlags,pCtx,ppWorkingNamespace,ppResult)

#define IWbemServices_CancelAsyncCall(This,pSink)	\
    (This)->lpVtbl -> CancelAsyncCall(This,pSink)

#define IWbemServices_QueryObjectSink(This,lFlags,ppResponseHandler)	\
    (This)->lpVtbl -> QueryObjectSink(This,lFlags,ppResponseHandler)

#define IWbemServices_GetObject(This,strObjectPath,lFlags,pCtx,ppObject,ppCallResult)	\
    (This)->lpVtbl -> GetObject(This,strObjectPath,lFlags,pCtx,ppObject,ppCallResult)

#define IWbemServices_GetObjectAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> GetObjectAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServices_PutClass(This,pObject,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> PutClass(This,pObject,lFlags,pCtx,ppCallResult)

#define IWbemServices_PutClassAsync(This,pObject,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> PutClassAsync(This,pObject,lFlags,pCtx,pResponseHandler)

#define IWbemServices_DeleteClass(This,strClass,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> DeleteClass(This,strClass,lFlags,pCtx,ppCallResult)

#define IWbemServices_DeleteClassAsync(This,strClass,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> DeleteClassAsync(This,strClass,lFlags,pCtx,pResponseHandler)

#define IWbemServices_CreateClassEnum(This,strSuperclass,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> CreateClassEnum(This,strSuperclass,lFlags,pCtx,ppEnum)

#define IWbemServices_CreateClassEnumAsync(This,strSuperclass,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> CreateClassEnumAsync(This,strSuperclass,lFlags,pCtx,pResponseHandler)

#define IWbemServices_PutInstance(This,pInst,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> PutInstance(This,pInst,lFlags,pCtx,ppCallResult)

#define IWbemServices_PutInstanceAsync(This,pInst,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> PutInstanceAsync(This,pInst,lFlags,pCtx,pResponseHandler)

#define IWbemServices_DeleteInstance(This,strObjectPath,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> DeleteInstance(This,strObjectPath,lFlags,pCtx,ppCallResult)

#define IWbemServices_DeleteInstanceAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> DeleteInstanceAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServices_CreateInstanceEnum(This,strFilter,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> CreateInstanceEnum(This,strFilter,lFlags,pCtx,ppEnum)

#define IWbemServices_CreateInstanceEnumAsync(This,strFilter,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> CreateInstanceEnumAsync(This,strFilter,lFlags,pCtx,pResponseHandler)

#define IWbemServices_ExecQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> ExecQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)

#define IWbemServices_ExecQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> ExecQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)

#define IWbemServices_ExecNotificationQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> ExecNotificationQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)

#define IWbemServices_ExecNotificationQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> ExecNotificationQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)

#define IWbemServices_ExecMethod(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,ppOutParams,ppCallResult)	\
    (This)->lpVtbl -> ExecMethod(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,ppOutParams,ppCallResult)

#define IWbemServices_ExecMethodAsync(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,pResponseHandler)	\
    (This)->lpVtbl -> ExecMethodAsync(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,pResponseHandler)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemServices_OpenNamespace_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strNamespace,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemServices **ppWorkingNamespace,
    /* [unique][in][out] */ IWbemCallResult **ppResult);


void __RPC_STUB IWbemServices_OpenNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CancelAsyncCall_Proxy( 
    IWbemServices * This,
    /* [in] */ IWbemObjectSink *pSink);


void __RPC_STUB IWbemServices_CancelAsyncCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_QueryObjectSink_Proxy( 
    IWbemServices * This,
    /* [in] */ long lFlags,
    /* [out] */ IWbemObjectSink **ppResponseHandler);


void __RPC_STUB IWbemServices_QueryObjectSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_GetObject_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemClassObject **ppObject,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServices_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_GetObjectAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_GetObjectAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_PutClass_Proxy( 
    IWbemServices * This,
    /* [in] */ IWbemClassObject *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServices_PutClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_PutClassAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ IWbemClassObject *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_PutClassAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_DeleteClass_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServices_DeleteClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_DeleteClassAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_DeleteClassAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CreateClassEnum_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strSuperclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IEnumWbemClassObject **ppEnum);


void __RPC_STUB IWbemServices_CreateClassEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CreateClassEnumAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strSuperclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_CreateClassEnumAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_PutInstance_Proxy( 
    IWbemServices * This,
    /* [in] */ IWbemClassObject *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServices_PutInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_PutInstanceAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ IWbemClassObject *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_PutInstanceAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_DeleteInstance_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServices_DeleteInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_DeleteInstanceAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_DeleteInstanceAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CreateInstanceEnum_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strFilter,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IEnumWbemClassObject **ppEnum);


void __RPC_STUB IWbemServices_CreateInstanceEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CreateInstanceEnumAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strFilter,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_CreateInstanceEnumAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecQuery_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IEnumWbemClassObject **ppEnum);


void __RPC_STUB IWbemServices_ExecQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecQueryAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_ExecQueryAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecNotificationQuery_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IEnumWbemClassObject **ppEnum);


void __RPC_STUB IWbemServices_ExecNotificationQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecNotificationQueryAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_ExecNotificationQueryAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecMethod_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemClassObject *pInParams,
    /* [unique][in][out] */ IWbemClassObject **ppOutParams,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServices_ExecMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecMethodAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemClassObject *pInParams,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_ExecMethodAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemServices_INTERFACE_DEFINED__ */


#ifndef __IWbemServicesEx_INTERFACE_DEFINED__
#define __IWbemServicesEx_INTERFACE_DEFINED__

/* interface IWbemServicesEx */
/* [unique][uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemServicesEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6D54E7AD-7583-4d53-BC14-CE2678F73DB3")
    IWbemServicesEx : public IWbemServices
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ const BSTR strScope,
            /* [in] */ const BSTR strSelector,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemServicesEx **ppScope,
            /* [unique][in][out] */ IWbemCallResultEx **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenAsync( 
            /* [in] */ const BSTR strScope,
            /* [in] */ const BSTR strSelector,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSinkEx *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RefreshObject( 
            /* [out][in] */ IWbemClassObject **pTarget,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RefreshObjectAsync( 
            /* [out][in] */ IWbemClassObject **pTarget,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSinkEx *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenameObject( 
            /* [in] */ const BSTR strOldObjectPath,
            /* [in] */ const BSTR strNewObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenameObjectAsync( 
            /* [in] */ const BSTR strOldObjectPath,
            /* [in] */ const BSTR strNewObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteObject( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteObjectAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutObject( 
            /* [in] */ IWbemClassObject *pObj,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutObjectAsync( 
            /* [in] */ IWbemClassObject *pObj,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemServicesExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemServicesEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemServicesEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemServicesEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *OpenNamespace )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemServices **ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *CancelAsyncCall )( 
            IWbemServicesEx * This,
            /* [in] */ IWbemObjectSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *QueryObjectSink )( 
            IWbemServicesEx * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink **ppResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemClassObject **ppObject,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectAsync )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *PutClass )( 
            IWbemServicesEx * This,
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *PutClassAsync )( 
            IWbemServicesEx * This,
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteClass )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteClassAsync )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *CreateClassEnum )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CreateClassEnumAsync )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *PutInstance )( 
            IWbemServicesEx * This,
            /* [in] */ IWbemClassObject *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *PutInstanceAsync )( 
            IWbemServicesEx * This,
            /* [in] */ IWbemClassObject *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteInstance )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteInstanceAsync )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInstanceEnum )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInstanceEnumAsync )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *ExecQuery )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *ExecQueryAsync )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *ExecNotificationQuery )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *ExecNotificationQueryAsync )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *ExecMethod )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [unique][in][out] */ IWbemClassObject **ppOutParams,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *ExecMethodAsync )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strScope,
            /* [in] */ const BSTR strSelector,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemServicesEx **ppScope,
            /* [unique][in][out] */ IWbemCallResultEx **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *OpenAsync )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strScope,
            /* [in] */ const BSTR strSelector,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSinkEx *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *AddAsync )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAsync )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *RefreshObject )( 
            IWbemServicesEx * This,
            /* [out][in] */ IWbemClassObject **pTarget,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *RefreshObjectAsync )( 
            IWbemServicesEx * This,
            /* [out][in] */ IWbemClassObject **pTarget,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSinkEx *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *RenameObject )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strOldObjectPath,
            /* [in] */ const BSTR strNewObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *RenameObjectAsync )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strOldObjectPath,
            /* [in] */ const BSTR strNewObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteObject )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteObjectAsync )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *PutObject )( 
            IWbemServicesEx * This,
            /* [in] */ IWbemClassObject *pObj,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *PutObjectAsync )( 
            IWbemServicesEx * This,
            /* [in] */ IWbemClassObject *pObj,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        END_INTERFACE
    } IWbemServicesExVtbl;

    interface IWbemServicesEx
    {
        CONST_VTBL struct IWbemServicesExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemServicesEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemServicesEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemServicesEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemServicesEx_OpenNamespace(This,strNamespace,lFlags,pCtx,ppWorkingNamespace,ppResult)	\
    (This)->lpVtbl -> OpenNamespace(This,strNamespace,lFlags,pCtx,ppWorkingNamespace,ppResult)

#define IWbemServicesEx_CancelAsyncCall(This,pSink)	\
    (This)->lpVtbl -> CancelAsyncCall(This,pSink)

#define IWbemServicesEx_QueryObjectSink(This,lFlags,ppResponseHandler)	\
    (This)->lpVtbl -> QueryObjectSink(This,lFlags,ppResponseHandler)

#define IWbemServicesEx_GetObject(This,strObjectPath,lFlags,pCtx,ppObject,ppCallResult)	\
    (This)->lpVtbl -> GetObject(This,strObjectPath,lFlags,pCtx,ppObject,ppCallResult)

#define IWbemServicesEx_GetObjectAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> GetObjectAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_PutClass(This,pObject,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> PutClass(This,pObject,lFlags,pCtx,ppCallResult)

#define IWbemServicesEx_PutClassAsync(This,pObject,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> PutClassAsync(This,pObject,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_DeleteClass(This,strClass,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> DeleteClass(This,strClass,lFlags,pCtx,ppCallResult)

#define IWbemServicesEx_DeleteClassAsync(This,strClass,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> DeleteClassAsync(This,strClass,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_CreateClassEnum(This,strSuperclass,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> CreateClassEnum(This,strSuperclass,lFlags,pCtx,ppEnum)

#define IWbemServicesEx_CreateClassEnumAsync(This,strSuperclass,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> CreateClassEnumAsync(This,strSuperclass,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_PutInstance(This,pInst,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> PutInstance(This,pInst,lFlags,pCtx,ppCallResult)

#define IWbemServicesEx_PutInstanceAsync(This,pInst,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> PutInstanceAsync(This,pInst,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_DeleteInstance(This,strObjectPath,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> DeleteInstance(This,strObjectPath,lFlags,pCtx,ppCallResult)

#define IWbemServicesEx_DeleteInstanceAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> DeleteInstanceAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_CreateInstanceEnum(This,strFilter,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> CreateInstanceEnum(This,strFilter,lFlags,pCtx,ppEnum)

#define IWbemServicesEx_CreateInstanceEnumAsync(This,strFilter,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> CreateInstanceEnumAsync(This,strFilter,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_ExecQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> ExecQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)

#define IWbemServicesEx_ExecQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> ExecQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_ExecNotificationQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> ExecNotificationQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)

#define IWbemServicesEx_ExecNotificationQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> ExecNotificationQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_ExecMethod(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,ppOutParams,ppCallResult)	\
    (This)->lpVtbl -> ExecMethod(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,ppOutParams,ppCallResult)

#define IWbemServicesEx_ExecMethodAsync(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,pResponseHandler)	\
    (This)->lpVtbl -> ExecMethodAsync(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,pResponseHandler)


#define IWbemServicesEx_Open(This,strScope,strSelector,lFlags,pCtx,ppScope,ppResult)	\
    (This)->lpVtbl -> Open(This,strScope,strSelector,lFlags,pCtx,ppScope,ppResult)

#define IWbemServicesEx_OpenAsync(This,strScope,strSelector,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> OpenAsync(This,strScope,strSelector,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_Add(This,strObjectPath,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> Add(This,strObjectPath,lFlags,pCtx,ppCallResult)

#define IWbemServicesEx_AddAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> AddAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_Remove(This,strObjectPath,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> Remove(This,strObjectPath,lFlags,pCtx,ppCallResult)

#define IWbemServicesEx_RemoveAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> RemoveAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_RefreshObject(This,pTarget,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> RefreshObject(This,pTarget,lFlags,pCtx,ppCallResult)

#define IWbemServicesEx_RefreshObjectAsync(This,pTarget,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> RefreshObjectAsync(This,pTarget,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_RenameObject(This,strOldObjectPath,strNewObjectPath,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> RenameObject(This,strOldObjectPath,strNewObjectPath,lFlags,pCtx,ppCallResult)

#define IWbemServicesEx_RenameObjectAsync(This,strOldObjectPath,strNewObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> RenameObjectAsync(This,strOldObjectPath,strNewObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_DeleteObject(This,strObjectPath,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> DeleteObject(This,strObjectPath,lFlags,pCtx,ppCallResult)

#define IWbemServicesEx_DeleteObjectAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> DeleteObjectAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_PutObject(This,pObj,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> PutObject(This,pObj,lFlags,pCtx,ppCallResult)

#define IWbemServicesEx_PutObjectAsync(This,pObj,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> PutObjectAsync(This,pObj,lFlags,pCtx,pResponseHandler)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemServicesEx_Open_Proxy( 
    IWbemServicesEx * This,
    /* [in] */ const BSTR strScope,
    /* [in] */ const BSTR strSelector,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemServicesEx **ppScope,
    /* [unique][in][out] */ IWbemCallResultEx **ppResult);


void __RPC_STUB IWbemServicesEx_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServicesEx_OpenAsync_Proxy( 
    IWbemServicesEx * This,
    /* [in] */ const BSTR strScope,
    /* [in] */ const BSTR strSelector,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSinkEx *pResponseHandler);


void __RPC_STUB IWbemServicesEx_OpenAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServicesEx_Add_Proxy( 
    IWbemServicesEx * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResultEx **ppCallResult);


void __RPC_STUB IWbemServicesEx_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServicesEx_AddAsync_Proxy( 
    IWbemServicesEx * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServicesEx_AddAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServicesEx_Remove_Proxy( 
    IWbemServicesEx * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResultEx **ppCallResult);


void __RPC_STUB IWbemServicesEx_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServicesEx_RemoveAsync_Proxy( 
    IWbemServicesEx * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServicesEx_RemoveAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServicesEx_RefreshObject_Proxy( 
    IWbemServicesEx * This,
    /* [out][in] */ IWbemClassObject **pTarget,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResultEx **ppCallResult);


void __RPC_STUB IWbemServicesEx_RefreshObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServicesEx_RefreshObjectAsync_Proxy( 
    IWbemServicesEx * This,
    /* [out][in] */ IWbemClassObject **pTarget,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSinkEx *pResponseHandler);


void __RPC_STUB IWbemServicesEx_RefreshObjectAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServicesEx_RenameObject_Proxy( 
    IWbemServicesEx * This,
    /* [in] */ const BSTR strOldObjectPath,
    /* [in] */ const BSTR strNewObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResultEx **ppCallResult);


void __RPC_STUB IWbemServicesEx_RenameObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServicesEx_RenameObjectAsync_Proxy( 
    IWbemServicesEx * This,
    /* [in] */ const BSTR strOldObjectPath,
    /* [in] */ const BSTR strNewObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServicesEx_RenameObjectAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServicesEx_DeleteObject_Proxy( 
    IWbemServicesEx * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServicesEx_DeleteObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServicesEx_DeleteObjectAsync_Proxy( 
    IWbemServicesEx * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServicesEx_DeleteObjectAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServicesEx_PutObject_Proxy( 
    IWbemServicesEx * This,
    /* [in] */ IWbemClassObject *pObj,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServicesEx_PutObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServicesEx_PutObjectAsync_Proxy( 
    IWbemServicesEx * This,
    /* [in] */ IWbemClassObject *pObj,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServicesEx_PutObjectAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemServicesEx_INTERFACE_DEFINED__ */


#ifndef __IWbemLocator_INTERFACE_DEFINED__
#define __IWbemLocator_INTERFACE_DEFINED__

/* interface IWbemLocator */
/* [unique][uuid][local][restricted][object] */ 


EXTERN_C const IID IID_IWbemLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dc12a687-737f-11cf-884d-00aa004b2e24")
    IWbemLocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConnectServer( 
            /* [in] */ const BSTR strNetworkResource,
            /* [in] */ const BSTR strUser,
            /* [in] */ const BSTR strPassword,
            /* [in] */ const BSTR strLocale,
            /* [in] */ long lSecurityFlags,
            /* [in] */ const BSTR strAuthority,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IWbemServices **ppNamespace) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemLocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemLocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemLocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectServer )( 
            IWbemLocator * This,
            /* [in] */ const BSTR strNetworkResource,
            /* [in] */ const BSTR strUser,
            /* [in] */ const BSTR strPassword,
            /* [in] */ const BSTR strLocale,
            /* [in] */ long lSecurityFlags,
            /* [in] */ const BSTR strAuthority,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IWbemServices **ppNamespace);
        
        END_INTERFACE
    } IWbemLocatorVtbl;

    interface IWbemLocator
    {
        CONST_VTBL struct IWbemLocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemLocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemLocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemLocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemLocator_ConnectServer(This,strNetworkResource,strUser,strPassword,strLocale,lSecurityFlags,strAuthority,pCtx,ppNamespace)	\
    (This)->lpVtbl -> ConnectServer(This,strNetworkResource,strUser,strPassword,strLocale,lSecurityFlags,strAuthority,pCtx,ppNamespace)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemLocator_ConnectServer_Proxy( 
    IWbemLocator * This,
    /* [in] */ const BSTR strNetworkResource,
    /* [in] */ const BSTR strUser,
    /* [in] */ const BSTR strPassword,
    /* [in] */ const BSTR strLocale,
    /* [in] */ long lSecurityFlags,
    /* [in] */ const BSTR strAuthority,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IWbemServices **ppNamespace);


void __RPC_STUB IWbemLocator_ConnectServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemLocator_INTERFACE_DEFINED__ */


#ifndef __IWbemConnection_INTERFACE_DEFINED__
#define __IWbemConnection_INTERFACE_DEFINED__

/* interface IWbemConnection */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IWbemConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("180d6598-e042-4b71-b0a2-6e2d16daf293")
    IWbemConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ const BSTR strObject,
            /* [in] */ const BSTR strUser,
            /* [in] */ const BSTR strPassword,
            /* [in] */ const BSTR strLocale,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **pInterface,
            /* [out] */ IWbemCallResultEx **pCallRes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenAsync( 
            /* [in] */ const BSTR strObject,
            /* [in] */ const BSTR strUser,
            /* [in] */ const BSTR strPassword,
            /* [in] */ const BSTR strLocale,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ REFIID riid,
            /* [in] */ IWbemObjectSinkEx *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( 
            /* [in] */ long lFlags,
            /* [in] */ IWbemObjectSinkEx *pHandler) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            IWbemConnection * This,
            /* [in] */ const BSTR strObject,
            /* [in] */ const BSTR strUser,
            /* [in] */ const BSTR strPassword,
            /* [in] */ const BSTR strLocale,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **pInterface,
            /* [out] */ IWbemCallResultEx **pCallRes);
        
        HRESULT ( STDMETHODCALLTYPE *OpenAsync )( 
            IWbemConnection * This,
            /* [in] */ const BSTR strObject,
            /* [in] */ const BSTR strUser,
            /* [in] */ const BSTR strPassword,
            /* [in] */ const BSTR strLocale,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ REFIID riid,
            /* [in] */ IWbemObjectSinkEx *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IWbemConnection * This,
            /* [in] */ long lFlags,
            /* [in] */ IWbemObjectSinkEx *pHandler);
        
        END_INTERFACE
    } IWbemConnectionVtbl;

    interface IWbemConnection
    {
        CONST_VTBL struct IWbemConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemConnection_Open(This,strObject,strUser,strPassword,strLocale,lFlags,pCtx,riid,pInterface,pCallRes)	\
    (This)->lpVtbl -> Open(This,strObject,strUser,strPassword,strLocale,lFlags,pCtx,riid,pInterface,pCallRes)

#define IWbemConnection_OpenAsync(This,strObject,strUser,strPassword,strLocale,lFlags,pCtx,riid,pResponseHandler)	\
    (This)->lpVtbl -> OpenAsync(This,strObject,strUser,strPassword,strLocale,lFlags,pCtx,riid,pResponseHandler)

#define IWbemConnection_Cancel(This,lFlags,pHandler)	\
    (This)->lpVtbl -> Cancel(This,lFlags,pHandler)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemConnection_Open_Proxy( 
    IWbemConnection * This,
    /* [in] */ const BSTR strObject,
    /* [in] */ const BSTR strUser,
    /* [in] */ const BSTR strPassword,
    /* [in] */ const BSTR strLocale,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **pInterface,
    /* [out] */ IWbemCallResultEx **pCallRes);


void __RPC_STUB IWbemConnection_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConnection_OpenAsync_Proxy( 
    IWbemConnection * This,
    /* [in] */ const BSTR strObject,
    /* [in] */ const BSTR strUser,
    /* [in] */ const BSTR strPassword,
    /* [in] */ const BSTR strLocale,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ REFIID riid,
    /* [in] */ IWbemObjectSinkEx *pResponseHandler);


void __RPC_STUB IWbemConnection_OpenAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConnection_Cancel_Proxy( 
    IWbemConnection * This,
    /* [in] */ long lFlags,
    /* [in] */ IWbemObjectSinkEx *pHandler);


void __RPC_STUB IWbemConnection_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemConnection_INTERFACE_DEFINED__ */


#ifndef __IWbemObjectSink_INTERFACE_DEFINED__
#define __IWbemObjectSink_INTERFACE_DEFINED__

/* interface IWbemObjectSink */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemObjectSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7c857801-7381-11cf-884d-00aa004b2e24")
    IWbemObjectSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Indicate( 
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject **apObjArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject *pObjParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemObjectSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemObjectSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemObjectSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemObjectSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Indicate )( 
            IWbemObjectSink * This,
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject **apObjArray);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            IWbemObjectSink * This,
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject *pObjParam);
        
        END_INTERFACE
    } IWbemObjectSinkVtbl;

    interface IWbemObjectSink
    {
        CONST_VTBL struct IWbemObjectSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemObjectSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemObjectSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemObjectSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemObjectSink_Indicate(This,lObjectCount,apObjArray)	\
    (This)->lpVtbl -> Indicate(This,lObjectCount,apObjArray)

#define IWbemObjectSink_SetStatus(This,lFlags,hResult,strParam,pObjParam)	\
    (This)->lpVtbl -> SetStatus(This,lFlags,hResult,strParam,pObjParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemObjectSink_Indicate_Proxy( 
    IWbemObjectSink * This,
    /* [in] */ long lObjectCount,
    /* [size_is][in] */ IWbemClassObject **apObjArray);


void __RPC_STUB IWbemObjectSink_Indicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectSink_SetStatus_Proxy( 
    IWbemObjectSink * This,
    /* [in] */ long lFlags,
    /* [in] */ HRESULT hResult,
    /* [in] */ BSTR strParam,
    /* [in] */ IWbemClassObject *pObjParam);


void __RPC_STUB IWbemObjectSink_SetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemObjectSink_INTERFACE_DEFINED__ */


#ifndef __IEnumWbemClassObject_INTERFACE_DEFINED__
#define __IEnumWbemClassObject_INTERFACE_DEFINED__

/* interface IEnumWbemClassObject */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IEnumWbemClassObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("027947e1-d731-11ce-a357-000000000001")
    IEnumWbemClassObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lTimeout,
            /* [in] */ ULONG uCount,
            /* [length_is][size_is][out] */ IWbemClassObject **apObjects,
            /* [out] */ ULONG *puReturned) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NextAsync( 
            /* [in] */ ULONG uCount,
            /* [in] */ IWbemObjectSink *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumWbemClassObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ long lTimeout,
            /* [in] */ ULONG nCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWbemClassObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumWbemClassObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumWbemClassObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumWbemClassObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumWbemClassObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumWbemClassObject * This,
            /* [in] */ long lTimeout,
            /* [in] */ ULONG uCount,
            /* [length_is][size_is][out] */ IWbemClassObject **apObjects,
            /* [out] */ ULONG *puReturned);
        
        HRESULT ( STDMETHODCALLTYPE *NextAsync )( 
            IEnumWbemClassObject * This,
            /* [in] */ ULONG uCount,
            /* [in] */ IWbemObjectSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumWbemClassObject * This,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumWbemClassObject * This,
            /* [in] */ long lTimeout,
            /* [in] */ ULONG nCount);
        
        END_INTERFACE
    } IEnumWbemClassObjectVtbl;

    interface IEnumWbemClassObject
    {
        CONST_VTBL struct IEnumWbemClassObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWbemClassObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumWbemClassObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumWbemClassObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumWbemClassObject_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumWbemClassObject_Next(This,lTimeout,uCount,apObjects,puReturned)	\
    (This)->lpVtbl -> Next(This,lTimeout,uCount,apObjects,puReturned)

#define IEnumWbemClassObject_NextAsync(This,uCount,pSink)	\
    (This)->lpVtbl -> NextAsync(This,uCount,pSink)

#define IEnumWbemClassObject_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumWbemClassObject_Skip(This,lTimeout,nCount)	\
    (This)->lpVtbl -> Skip(This,lTimeout,nCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Reset_Proxy( 
    IEnumWbemClassObject * This);


void __RPC_STUB IEnumWbemClassObject_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Next_Proxy( 
    IEnumWbemClassObject * This,
    /* [in] */ long lTimeout,
    /* [in] */ ULONG uCount,
    /* [length_is][size_is][out] */ IWbemClassObject **apObjects,
    /* [out] */ ULONG *puReturned);


void __RPC_STUB IEnumWbemClassObject_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_NextAsync_Proxy( 
    IEnumWbemClassObject * This,
    /* [in] */ ULONG uCount,
    /* [in] */ IWbemObjectSink *pSink);


void __RPC_STUB IEnumWbemClassObject_NextAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Clone_Proxy( 
    IEnumWbemClassObject * This,
    /* [out] */ IEnumWbemClassObject **ppEnum);


void __RPC_STUB IEnumWbemClassObject_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Skip_Proxy( 
    IEnumWbemClassObject * This,
    /* [in] */ long lTimeout,
    /* [in] */ ULONG nCount);


void __RPC_STUB IEnumWbemClassObject_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWbemClassObject_INTERFACE_DEFINED__ */


#ifndef __IWbemCallResult_INTERFACE_DEFINED__
#define __IWbemCallResult_INTERFACE_DEFINED__

/* interface IWbemCallResult */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemCallResult;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("44aca675-e8fc-11d0-a07c-00c04fb68820")
    IWbemCallResult : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetResultObject( 
            /* [in] */ long lTimeout,
            /* [out] */ IWbemClassObject **ppResultObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResultString( 
            /* [in] */ long lTimeout,
            /* [out] */ BSTR *pstrResultString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResultServices( 
            /* [in] */ long lTimeout,
            /* [out] */ IWbemServices **ppServices) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCallStatus( 
            /* [in] */ long lTimeout,
            /* [out] */ long *plStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemCallResultVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemCallResult * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemCallResult * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemCallResult * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetResultObject )( 
            IWbemCallResult * This,
            /* [in] */ long lTimeout,
            /* [out] */ IWbemClassObject **ppResultObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetResultString )( 
            IWbemCallResult * This,
            /* [in] */ long lTimeout,
            /* [out] */ BSTR *pstrResultString);
        
        HRESULT ( STDMETHODCALLTYPE *GetResultServices )( 
            IWbemCallResult * This,
            /* [in] */ long lTimeout,
            /* [out] */ IWbemServices **ppServices);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallStatus )( 
            IWbemCallResult * This,
            /* [in] */ long lTimeout,
            /* [out] */ long *plStatus);
        
        END_INTERFACE
    } IWbemCallResultVtbl;

    interface IWbemCallResult
    {
        CONST_VTBL struct IWbemCallResultVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemCallResult_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemCallResult_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemCallResult_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemCallResult_GetResultObject(This,lTimeout,ppResultObject)	\
    (This)->lpVtbl -> GetResultObject(This,lTimeout,ppResultObject)

#define IWbemCallResult_GetResultString(This,lTimeout,pstrResultString)	\
    (This)->lpVtbl -> GetResultString(This,lTimeout,pstrResultString)

#define IWbemCallResult_GetResultServices(This,lTimeout,ppServices)	\
    (This)->lpVtbl -> GetResultServices(This,lTimeout,ppServices)

#define IWbemCallResult_GetCallStatus(This,lTimeout,plStatus)	\
    (This)->lpVtbl -> GetCallStatus(This,lTimeout,plStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemCallResult_GetResultObject_Proxy( 
    IWbemCallResult * This,
    /* [in] */ long lTimeout,
    /* [out] */ IWbemClassObject **ppResultObject);


void __RPC_STUB IWbemCallResult_GetResultObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemCallResult_GetResultString_Proxy( 
    IWbemCallResult * This,
    /* [in] */ long lTimeout,
    /* [out] */ BSTR *pstrResultString);


void __RPC_STUB IWbemCallResult_GetResultString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemCallResult_GetResultServices_Proxy( 
    IWbemCallResult * This,
    /* [in] */ long lTimeout,
    /* [out] */ IWbemServices **ppServices);


void __RPC_STUB IWbemCallResult_GetResultServices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemCallResult_GetCallStatus_Proxy( 
    IWbemCallResult * This,
    /* [in] */ long lTimeout,
    /* [out] */ long *plStatus);


void __RPC_STUB IWbemCallResult_GetCallStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemCallResult_INTERFACE_DEFINED__ */


#ifndef __IWbemCallResultEx_INTERFACE_DEFINED__
#define __IWbemCallResultEx_INTERFACE_DEFINED__

/* interface IWbemCallResultEx */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemCallResultEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c1e2d758-cabd-11d3-a11b-00105a1f515a")
    IWbemCallResultEx : public IWbemCallResult
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetResult( 
            /* [in] */ long lTimeout,
            /* [in] */ long lFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemCallResultExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemCallResultEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemCallResultEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemCallResultEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetResultObject )( 
            IWbemCallResultEx * This,
            /* [in] */ long lTimeout,
            /* [out] */ IWbemClassObject **ppResultObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetResultString )( 
            IWbemCallResultEx * This,
            /* [in] */ long lTimeout,
            /* [out] */ BSTR *pstrResultString);
        
        HRESULT ( STDMETHODCALLTYPE *GetResultServices )( 
            IWbemCallResultEx * This,
            /* [in] */ long lTimeout,
            /* [out] */ IWbemServices **ppServices);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallStatus )( 
            IWbemCallResultEx * This,
            /* [in] */ long lTimeout,
            /* [out] */ long *plStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetResult )( 
            IWbemCallResultEx * This,
            /* [in] */ long lTimeout,
            /* [in] */ long lFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvResult);
        
        END_INTERFACE
    } IWbemCallResultExVtbl;

    interface IWbemCallResultEx
    {
        CONST_VTBL struct IWbemCallResultExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemCallResultEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemCallResultEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemCallResultEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemCallResultEx_GetResultObject(This,lTimeout,ppResultObject)	\
    (This)->lpVtbl -> GetResultObject(This,lTimeout,ppResultObject)

#define IWbemCallResultEx_GetResultString(This,lTimeout,pstrResultString)	\
    (This)->lpVtbl -> GetResultString(This,lTimeout,pstrResultString)

#define IWbemCallResultEx_GetResultServices(This,lTimeout,ppServices)	\
    (This)->lpVtbl -> GetResultServices(This,lTimeout,ppServices)

#define IWbemCallResultEx_GetCallStatus(This,lTimeout,plStatus)	\
    (This)->lpVtbl -> GetCallStatus(This,lTimeout,plStatus)


#define IWbemCallResultEx_GetResult(This,lTimeout,lFlags,riid,ppvResult)	\
    (This)->lpVtbl -> GetResult(This,lTimeout,lFlags,riid,ppvResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemCallResultEx_GetResult_Proxy( 
    IWbemCallResultEx * This,
    /* [in] */ long lTimeout,
    /* [in] */ long lFlags,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppvResult);


void __RPC_STUB IWbemCallResultEx_GetResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemCallResultEx_INTERFACE_DEFINED__ */


#ifndef __IWbemContext_INTERFACE_DEFINED__
#define __IWbemContext_INTERFACE_DEFINED__

/* interface IWbemContext */
/* [uuid][local][restricted][object] */ 


EXTERN_C const IID IID_IWbemContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("44aca674-e8fc-11d0-a07c-00c04fb68820")
    IWbemContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IWbemContext **ppNewCopy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNames( 
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY * *pNames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnumeration( 
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lFlags,
            /* [out] */ BSTR *pstrName,
            /* [out] */ VARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndEnumeration( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [out] */ VARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteValue( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteAll( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IWbemContext * This,
            /* [out] */ IWbemContext **ppNewCopy);
        
        HRESULT ( STDMETHODCALLTYPE *GetNames )( 
            IWbemContext * This,
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY * *pNames);
        
        HRESULT ( STDMETHODCALLTYPE *BeginEnumeration )( 
            IWbemContext * This,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IWbemContext * This,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *pstrName,
            /* [out] */ VARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *EndEnumeration )( 
            IWbemContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            IWbemContext * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IWbemContext * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [out] */ VARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteValue )( 
            IWbemContext * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAll )( 
            IWbemContext * This);
        
        END_INTERFACE
    } IWbemContextVtbl;

    interface IWbemContext
    {
        CONST_VTBL struct IWbemContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemContext_Clone(This,ppNewCopy)	\
    (This)->lpVtbl -> Clone(This,ppNewCopy)

#define IWbemContext_GetNames(This,lFlags,pNames)	\
    (This)->lpVtbl -> GetNames(This,lFlags,pNames)

#define IWbemContext_BeginEnumeration(This,lFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lFlags)

#define IWbemContext_Next(This,lFlags,pstrName,pValue)	\
    (This)->lpVtbl -> Next(This,lFlags,pstrName,pValue)

#define IWbemContext_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#define IWbemContext_SetValue(This,wszName,lFlags,pValue)	\
    (This)->lpVtbl -> SetValue(This,wszName,lFlags,pValue)

#define IWbemContext_GetValue(This,wszName,lFlags,pValue)	\
    (This)->lpVtbl -> GetValue(This,wszName,lFlags,pValue)

#define IWbemContext_DeleteValue(This,wszName,lFlags)	\
    (This)->lpVtbl -> DeleteValue(This,wszName,lFlags)

#define IWbemContext_DeleteAll(This)	\
    (This)->lpVtbl -> DeleteAll(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemContext_Clone_Proxy( 
    IWbemContext * This,
    /* [out] */ IWbemContext **ppNewCopy);


void __RPC_STUB IWbemContext_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_GetNames_Proxy( 
    IWbemContext * This,
    /* [in] */ long lFlags,
    /* [out] */ SAFEARRAY * *pNames);


void __RPC_STUB IWbemContext_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_BeginEnumeration_Proxy( 
    IWbemContext * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemContext_BeginEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_Next_Proxy( 
    IWbemContext * This,
    /* [in] */ long lFlags,
    /* [out] */ BSTR *pstrName,
    /* [out] */ VARIANT *pValue);


void __RPC_STUB IWbemContext_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_EndEnumeration_Proxy( 
    IWbemContext * This);


void __RPC_STUB IWbemContext_EndEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_SetValue_Proxy( 
    IWbemContext * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT *pValue);


void __RPC_STUB IWbemContext_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_GetValue_Proxy( 
    IWbemContext * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [out] */ VARIANT *pValue);


void __RPC_STUB IWbemContext_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_DeleteValue_Proxy( 
    IWbemContext * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemContext_DeleteValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_DeleteAll_Proxy( 
    IWbemContext * This);


void __RPC_STUB IWbemContext_DeleteAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemContext_INTERFACE_DEFINED__ */


#ifndef __IUnsecuredApartment_INTERFACE_DEFINED__
#define __IUnsecuredApartment_INTERFACE_DEFINED__

/* interface IUnsecuredApartment */
/* [object][uuid][restricted] */ 


EXTERN_C const IID IID_IUnsecuredApartment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1cfaba8c-1523-11d1-ad79-00c04fd8fdff")
    IUnsecuredApartment : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateObjectStub( 
            /* [in] */ IUnknown *pObject,
            /* [out] */ IUnknown **ppStub) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUnsecuredApartmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUnsecuredApartment * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUnsecuredApartment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUnsecuredApartment * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateObjectStub )( 
            IUnsecuredApartment * This,
            /* [in] */ IUnknown *pObject,
            /* [out] */ IUnknown **ppStub);
        
        END_INTERFACE
    } IUnsecuredApartmentVtbl;

    interface IUnsecuredApartment
    {
        CONST_VTBL struct IUnsecuredApartmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUnsecuredApartment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUnsecuredApartment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUnsecuredApartment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUnsecuredApartment_CreateObjectStub(This,pObject,ppStub)	\
    (This)->lpVtbl -> CreateObjectStub(This,pObject,ppStub)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUnsecuredApartment_CreateObjectStub_Proxy( 
    IUnsecuredApartment * This,
    /* [in] */ IUnknown *pObject,
    /* [out] */ IUnknown **ppStub);


void __RPC_STUB IUnsecuredApartment_CreateObjectStub_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUnsecuredApartment_INTERFACE_DEFINED__ */


#ifndef __IWbemStatusCodeText_INTERFACE_DEFINED__
#define __IWbemStatusCodeText_INTERFACE_DEFINED__

/* interface IWbemStatusCodeText */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IWbemStatusCodeText;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eb87e1bc-3233-11d2-aec9-00c04fb68820")
    IWbemStatusCodeText : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetErrorCodeText( 
            /* [in] */ HRESULT hRes,
            /* [in] */ LCID LocaleId,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *MessageText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFacilityCodeText( 
            /* [in] */ HRESULT hRes,
            /* [in] */ LCID LocaleId,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *MessageText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemStatusCodeTextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemStatusCodeText * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemStatusCodeText * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemStatusCodeText * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorCodeText )( 
            IWbemStatusCodeText * This,
            /* [in] */ HRESULT hRes,
            /* [in] */ LCID LocaleId,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *MessageText);
        
        HRESULT ( STDMETHODCALLTYPE *GetFacilityCodeText )( 
            IWbemStatusCodeText * This,
            /* [in] */ HRESULT hRes,
            /* [in] */ LCID LocaleId,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *MessageText);
        
        END_INTERFACE
    } IWbemStatusCodeTextVtbl;

    interface IWbemStatusCodeText
    {
        CONST_VTBL struct IWbemStatusCodeTextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemStatusCodeText_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemStatusCodeText_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemStatusCodeText_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemStatusCodeText_GetErrorCodeText(This,hRes,LocaleId,lFlags,MessageText)	\
    (This)->lpVtbl -> GetErrorCodeText(This,hRes,LocaleId,lFlags,MessageText)

#define IWbemStatusCodeText_GetFacilityCodeText(This,hRes,LocaleId,lFlags,MessageText)	\
    (This)->lpVtbl -> GetFacilityCodeText(This,hRes,LocaleId,lFlags,MessageText)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemStatusCodeText_GetErrorCodeText_Proxy( 
    IWbemStatusCodeText * This,
    /* [in] */ HRESULT hRes,
    /* [in] */ LCID LocaleId,
    /* [in] */ long lFlags,
    /* [out] */ BSTR *MessageText);


void __RPC_STUB IWbemStatusCodeText_GetErrorCodeText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemStatusCodeText_GetFacilityCodeText_Proxy( 
    IWbemStatusCodeText * This,
    /* [in] */ HRESULT hRes,
    /* [in] */ LCID LocaleId,
    /* [in] */ long lFlags,
    /* [out] */ BSTR *MessageText);


void __RPC_STUB IWbemStatusCodeText_GetFacilityCodeText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemStatusCodeText_INTERFACE_DEFINED__ */


#ifndef __IWbemBackupRestore_INTERFACE_DEFINED__
#define __IWbemBackupRestore_INTERFACE_DEFINED__

/* interface IWbemBackupRestore */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemBackupRestore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C49E32C7-BC8B-11d2-85D4-00105A1F8304")
    IWbemBackupRestore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Backup( 
            /* [string][in] */ LPCWSTR strBackupToFile,
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Restore( 
            /* [string][in] */ LPCWSTR strRestoreFromFile,
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemBackupRestoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemBackupRestore * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemBackupRestore * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemBackupRestore * This);
        
        HRESULT ( STDMETHODCALLTYPE *Backup )( 
            IWbemBackupRestore * This,
            /* [string][in] */ LPCWSTR strBackupToFile,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Restore )( 
            IWbemBackupRestore * This,
            /* [string][in] */ LPCWSTR strRestoreFromFile,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemBackupRestoreVtbl;

    interface IWbemBackupRestore
    {
        CONST_VTBL struct IWbemBackupRestoreVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemBackupRestore_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemBackupRestore_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemBackupRestore_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemBackupRestore_Backup(This,strBackupToFile,lFlags)	\
    (This)->lpVtbl -> Backup(This,strBackupToFile,lFlags)

#define IWbemBackupRestore_Restore(This,strRestoreFromFile,lFlags)	\
    (This)->lpVtbl -> Restore(This,strRestoreFromFile,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemBackupRestore_Backup_Proxy( 
    IWbemBackupRestore * This,
    /* [string][in] */ LPCWSTR strBackupToFile,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemBackupRestore_Backup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemBackupRestore_Restore_Proxy( 
    IWbemBackupRestore * This,
    /* [string][in] */ LPCWSTR strRestoreFromFile,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemBackupRestore_Restore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemBackupRestore_INTERFACE_DEFINED__ */


#ifndef __IWbemRefresher_INTERFACE_DEFINED__
#define __IWbemRefresher_INTERFACE_DEFINED__

/* interface IWbemRefresher */
/* [uuid][object][restricted][local] */ 


EXTERN_C const IID IID_IWbemRefresher;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49353c99-516b-11d1-aea6-00c04fb68820")
    IWbemRefresher : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Refresh( 
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemRefresherVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemRefresher * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemRefresher * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemRefresher * This);
        
        HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IWbemRefresher * This,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemRefresherVtbl;

    interface IWbemRefresher
    {
        CONST_VTBL struct IWbemRefresherVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemRefresher_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemRefresher_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemRefresher_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemRefresher_Refresh(This,lFlags)	\
    (This)->lpVtbl -> Refresh(This,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemRefresher_Refresh_Proxy( 
    IWbemRefresher * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemRefresher_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemRefresher_INTERFACE_DEFINED__ */


#ifndef __IWbemHiPerfEnum_INTERFACE_DEFINED__
#define __IWbemHiPerfEnum_INTERFACE_DEFINED__

/* interface IWbemHiPerfEnum */
/* [uuid][object][restricted][local] */ 


EXTERN_C const IID IID_IWbemHiPerfEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2705C288-79AE-11d2-B348-00105A1F8177")
    IWbemHiPerfEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddObjects( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [size_is][in] */ long *apIds,
            /* [size_is][in] */ IWbemObjectAccess **apObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveObjects( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [size_is][in] */ long *apIds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjects( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [length_is][size_is][out] */ IWbemObjectAccess **apObj,
            /* [out] */ ULONG *puReturned) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAll( 
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemHiPerfEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemHiPerfEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemHiPerfEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemHiPerfEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddObjects )( 
            IWbemHiPerfEnum * This,
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [size_is][in] */ long *apIds,
            /* [size_is][in] */ IWbemObjectAccess **apObj);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveObjects )( 
            IWbemHiPerfEnum * This,
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [size_is][in] */ long *apIds);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjects )( 
            IWbemHiPerfEnum * This,
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [length_is][size_is][out] */ IWbemObjectAccess **apObj,
            /* [out] */ ULONG *puReturned);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAll )( 
            IWbemHiPerfEnum * This,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemHiPerfEnumVtbl;

    interface IWbemHiPerfEnum
    {
        CONST_VTBL struct IWbemHiPerfEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemHiPerfEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemHiPerfEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemHiPerfEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemHiPerfEnum_AddObjects(This,lFlags,uNumObjects,apIds,apObj)	\
    (This)->lpVtbl -> AddObjects(This,lFlags,uNumObjects,apIds,apObj)

#define IWbemHiPerfEnum_RemoveObjects(This,lFlags,uNumObjects,apIds)	\
    (This)->lpVtbl -> RemoveObjects(This,lFlags,uNumObjects,apIds)

#define IWbemHiPerfEnum_GetObjects(This,lFlags,uNumObjects,apObj,puReturned)	\
    (This)->lpVtbl -> GetObjects(This,lFlags,uNumObjects,apObj,puReturned)

#define IWbemHiPerfEnum_RemoveAll(This,lFlags)	\
    (This)->lpVtbl -> RemoveAll(This,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemHiPerfEnum_AddObjects_Proxy( 
    IWbemHiPerfEnum * This,
    /* [in] */ long lFlags,
    /* [in] */ ULONG uNumObjects,
    /* [size_is][in] */ long *apIds,
    /* [size_is][in] */ IWbemObjectAccess **apObj);


void __RPC_STUB IWbemHiPerfEnum_AddObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemHiPerfEnum_RemoveObjects_Proxy( 
    IWbemHiPerfEnum * This,
    /* [in] */ long lFlags,
    /* [in] */ ULONG uNumObjects,
    /* [size_is][in] */ long *apIds);


void __RPC_STUB IWbemHiPerfEnum_RemoveObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemHiPerfEnum_GetObjects_Proxy( 
    IWbemHiPerfEnum * This,
    /* [in] */ long lFlags,
    /* [in] */ ULONG uNumObjects,
    /* [length_is][size_is][out] */ IWbemObjectAccess **apObj,
    /* [out] */ ULONG *puReturned);


void __RPC_STUB IWbemHiPerfEnum_GetObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemHiPerfEnum_RemoveAll_Proxy( 
    IWbemHiPerfEnum * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemHiPerfEnum_RemoveAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemHiPerfEnum_INTERFACE_DEFINED__ */


#ifndef __IWbemConfigureRefresher_INTERFACE_DEFINED__
#define __IWbemConfigureRefresher_INTERFACE_DEFINED__

/* interface IWbemConfigureRefresher */
/* [uuid][object][restricted][local] */ 


EXTERN_C const IID IID_IWbemConfigureRefresher;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49353c92-516b-11d1-aea6-00c04fb68820")
    IWbemConfigureRefresher : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddObjectByPath( 
            /* [in] */ IWbemServices *pNamespace,
            /* [string][in] */ LPCWSTR wszPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [out] */ IWbemClassObject **ppRefreshable,
            /* [unique][in][out] */ long *plId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddObjectByTemplate( 
            /* [in] */ IWbemServices *pNamespace,
            /* [in] */ IWbemClassObject *pTemplate,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [out] */ IWbemClassObject **ppRefreshable,
            /* [unique][in][out] */ long *plId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRefresher( 
            /* [in] */ IWbemRefresher *pRefresher,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ long *plId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ long lId,
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddEnum( 
            /* [in] */ IWbemServices *pNamespace,
            /* [string][in] */ LPCWSTR wszClassName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [out] */ IWbemHiPerfEnum **ppEnum,
            /* [unique][in][out] */ long *plId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemConfigureRefresherVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemConfigureRefresher * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemConfigureRefresher * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemConfigureRefresher * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddObjectByPath )( 
            IWbemConfigureRefresher * This,
            /* [in] */ IWbemServices *pNamespace,
            /* [string][in] */ LPCWSTR wszPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [out] */ IWbemClassObject **ppRefreshable,
            /* [unique][in][out] */ long *plId);
        
        HRESULT ( STDMETHODCALLTYPE *AddObjectByTemplate )( 
            IWbemConfigureRefresher * This,
            /* [in] */ IWbemServices *pNamespace,
            /* [in] */ IWbemClassObject *pTemplate,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [out] */ IWbemClassObject **ppRefreshable,
            /* [unique][in][out] */ long *plId);
        
        HRESULT ( STDMETHODCALLTYPE *AddRefresher )( 
            IWbemConfigureRefresher * This,
            /* [in] */ IWbemRefresher *pRefresher,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ long *plId);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IWbemConfigureRefresher * This,
            /* [in] */ long lId,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *AddEnum )( 
            IWbemConfigureRefresher * This,
            /* [in] */ IWbemServices *pNamespace,
            /* [string][in] */ LPCWSTR wszClassName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [out] */ IWbemHiPerfEnum **ppEnum,
            /* [unique][in][out] */ long *plId);
        
        END_INTERFACE
    } IWbemConfigureRefresherVtbl;

    interface IWbemConfigureRefresher
    {
        CONST_VTBL struct IWbemConfigureRefresherVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemConfigureRefresher_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemConfigureRefresher_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemConfigureRefresher_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemConfigureRefresher_AddObjectByPath(This,pNamespace,wszPath,lFlags,pContext,ppRefreshable,plId)	\
    (This)->lpVtbl -> AddObjectByPath(This,pNamespace,wszPath,lFlags,pContext,ppRefreshable,plId)

#define IWbemConfigureRefresher_AddObjectByTemplate(This,pNamespace,pTemplate,lFlags,pContext,ppRefreshable,plId)	\
    (This)->lpVtbl -> AddObjectByTemplate(This,pNamespace,pTemplate,lFlags,pContext,ppRefreshable,plId)

#define IWbemConfigureRefresher_AddRefresher(This,pRefresher,lFlags,plId)	\
    (This)->lpVtbl -> AddRefresher(This,pRefresher,lFlags,plId)

#define IWbemConfigureRefresher_Remove(This,lId,lFlags)	\
    (This)->lpVtbl -> Remove(This,lId,lFlags)

#define IWbemConfigureRefresher_AddEnum(This,pNamespace,wszClassName,lFlags,pContext,ppEnum,plId)	\
    (This)->lpVtbl -> AddEnum(This,pNamespace,wszClassName,lFlags,pContext,ppEnum,plId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_AddObjectByPath_Proxy( 
    IWbemConfigureRefresher * This,
    /* [in] */ IWbemServices *pNamespace,
    /* [string][in] */ LPCWSTR wszPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pContext,
    /* [out] */ IWbemClassObject **ppRefreshable,
    /* [unique][in][out] */ long *plId);


void __RPC_STUB IWbemConfigureRefresher_AddObjectByPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_AddObjectByTemplate_Proxy( 
    IWbemConfigureRefresher * This,
    /* [in] */ IWbemServices *pNamespace,
    /* [in] */ IWbemClassObject *pTemplate,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pContext,
    /* [out] */ IWbemClassObject **ppRefreshable,
    /* [unique][in][out] */ long *plId);


void __RPC_STUB IWbemConfigureRefresher_AddObjectByTemplate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_AddRefresher_Proxy( 
    IWbemConfigureRefresher * This,
    /* [in] */ IWbemRefresher *pRefresher,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ long *plId);


void __RPC_STUB IWbemConfigureRefresher_AddRefresher_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_Remove_Proxy( 
    IWbemConfigureRefresher * This,
    /* [in] */ long lId,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemConfigureRefresher_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_AddEnum_Proxy( 
    IWbemConfigureRefresher * This,
    /* [in] */ IWbemServices *pNamespace,
    /* [string][in] */ LPCWSTR wszClassName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pContext,
    /* [out] */ IWbemHiPerfEnum **ppEnum,
    /* [unique][in][out] */ long *plId);


void __RPC_STUB IWbemConfigureRefresher_AddEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemConfigureRefresher_INTERFACE_DEFINED__ */


#ifndef __IWbemSecureObjectSink_INTERFACE_DEFINED__
#define __IWbemSecureObjectSink_INTERFACE_DEFINED__

/* interface IWbemSecureObjectSink */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemSecureObjectSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("75abd540-f492-4161-86a5-37fc8898f69e")
    IWbemSecureObjectSink : public IWbemObjectSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IndicateWithSD( 
            /* [in] */ long lNumObjects,
            /* [size_is][in] */ IUnknown **apObjects,
            /* [in] */ long lSDLength,
            /* [size_is][in] */ BYTE *pSD) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemSecureObjectSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemSecureObjectSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemSecureObjectSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemSecureObjectSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Indicate )( 
            IWbemSecureObjectSink * This,
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject **apObjArray);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            IWbemSecureObjectSink * This,
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject *pObjParam);
        
        HRESULT ( STDMETHODCALLTYPE *IndicateWithSD )( 
            IWbemSecureObjectSink * This,
            /* [in] */ long lNumObjects,
            /* [size_is][in] */ IUnknown **apObjects,
            /* [in] */ long lSDLength,
            /* [size_is][in] */ BYTE *pSD);
        
        END_INTERFACE
    } IWbemSecureObjectSinkVtbl;

    interface IWbemSecureObjectSink
    {
        CONST_VTBL struct IWbemSecureObjectSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemSecureObjectSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemSecureObjectSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemSecureObjectSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemSecureObjectSink_Indicate(This,lObjectCount,apObjArray)	\
    (This)->lpVtbl -> Indicate(This,lObjectCount,apObjArray)

#define IWbemSecureObjectSink_SetStatus(This,lFlags,hResult,strParam,pObjParam)	\
    (This)->lpVtbl -> SetStatus(This,lFlags,hResult,strParam,pObjParam)


#define IWbemSecureObjectSink_IndicateWithSD(This,lNumObjects,apObjects,lSDLength,pSD)	\
    (This)->lpVtbl -> IndicateWithSD(This,lNumObjects,apObjects,lSDLength,pSD)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemSecureObjectSink_IndicateWithSD_Proxy( 
    IWbemSecureObjectSink * This,
    /* [in] */ long lNumObjects,
    /* [size_is][in] */ IUnknown **apObjects,
    /* [in] */ long lSDLength,
    /* [size_is][in] */ BYTE *pSD);


void __RPC_STUB IWbemSecureObjectSink_IndicateWithSD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemSecureObjectSink_INTERFACE_DEFINED__ */


#ifndef __IWbemEventSink_INTERFACE_DEFINED__
#define __IWbemEventSink_INTERFACE_DEFINED__

/* interface IWbemEventSink */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3ae0080a-7e3a-4366-bf89-0feedc931659")
    IWbemEventSink : public IWbemSecureObjectSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSinkSecurity( 
            /* [in] */ long lSDLength,
            /* [size_is][in] */ BYTE *pSD) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsActive( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRestrictedSink( 
            /* [in] */ long lNumQueries,
            /* [string][size_is][in] */ const LPCWSTR *awszQueries,
            /* [in] */ IUnknown *pCallback,
            /* [out] */ IWbemEventSink **ppSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBatchingParameters( 
            /* [in] */ LONG lFlags,
            /* [in] */ DWORD dwMaxBufferSize,
            /* [in] */ DWORD dwMaxSendLatency) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemEventSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemEventSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Indicate )( 
            IWbemEventSink * This,
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject **apObjArray);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            IWbemEventSink * This,
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject *pObjParam);
        
        HRESULT ( STDMETHODCALLTYPE *IndicateWithSD )( 
            IWbemEventSink * This,
            /* [in] */ long lNumObjects,
            /* [size_is][in] */ IUnknown **apObjects,
            /* [in] */ long lSDLength,
            /* [size_is][in] */ BYTE *pSD);
        
        HRESULT ( STDMETHODCALLTYPE *SetSinkSecurity )( 
            IWbemEventSink * This,
            /* [in] */ long lSDLength,
            /* [size_is][in] */ BYTE *pSD);
        
        HRESULT ( STDMETHODCALLTYPE *IsActive )( 
            IWbemEventSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRestrictedSink )( 
            IWbemEventSink * This,
            /* [in] */ long lNumQueries,
            /* [string][size_is][in] */ const LPCWSTR *awszQueries,
            /* [in] */ IUnknown *pCallback,
            /* [out] */ IWbemEventSink **ppSink);
        
        HRESULT ( STDMETHODCALLTYPE *SetBatchingParameters )( 
            IWbemEventSink * This,
            /* [in] */ LONG lFlags,
            /* [in] */ DWORD dwMaxBufferSize,
            /* [in] */ DWORD dwMaxSendLatency);
        
        END_INTERFACE
    } IWbemEventSinkVtbl;

    interface IWbemEventSink
    {
        CONST_VTBL struct IWbemEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemEventSink_Indicate(This,lObjectCount,apObjArray)	\
    (This)->lpVtbl -> Indicate(This,lObjectCount,apObjArray)

#define IWbemEventSink_SetStatus(This,lFlags,hResult,strParam,pObjParam)	\
    (This)->lpVtbl -> SetStatus(This,lFlags,hResult,strParam,pObjParam)


#define IWbemEventSink_IndicateWithSD(This,lNumObjects,apObjects,lSDLength,pSD)	\
    (This)->lpVtbl -> IndicateWithSD(This,lNumObjects,apObjects,lSDLength,pSD)


#define IWbemEventSink_SetSinkSecurity(This,lSDLength,pSD)	\
    (This)->lpVtbl -> SetSinkSecurity(This,lSDLength,pSD)

#define IWbemEventSink_IsActive(This)	\
    (This)->lpVtbl -> IsActive(This)

#define IWbemEventSink_GetRestrictedSink(This,lNumQueries,awszQueries,pCallback,ppSink)	\
    (This)->lpVtbl -> GetRestrictedSink(This,lNumQueries,awszQueries,pCallback,ppSink)

#define IWbemEventSink_SetBatchingParameters(This,lFlags,dwMaxBufferSize,dwMaxSendLatency)	\
    (This)->lpVtbl -> SetBatchingParameters(This,lFlags,dwMaxBufferSize,dwMaxSendLatency)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemEventSink_SetSinkSecurity_Proxy( 
    IWbemEventSink * This,
    /* [in] */ long lSDLength,
    /* [size_is][in] */ BYTE *pSD);


void __RPC_STUB IWbemEventSink_SetSinkSecurity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemEventSink_IsActive_Proxy( 
    IWbemEventSink * This);


void __RPC_STUB IWbemEventSink_IsActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemEventSink_GetRestrictedSink_Proxy( 
    IWbemEventSink * This,
    /* [in] */ long lNumQueries,
    /* [string][size_is][in] */ const LPCWSTR *awszQueries,
    /* [in] */ IUnknown *pCallback,
    /* [out] */ IWbemEventSink **ppSink);


void __RPC_STUB IWbemEventSink_GetRestrictedSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemEventSink_SetBatchingParameters_Proxy( 
    IWbemEventSink * This,
    /* [in] */ LONG lFlags,
    /* [in] */ DWORD dwMaxBufferSize,
    /* [in] */ DWORD dwMaxSendLatency);


void __RPC_STUB IWbemEventSink_SetBatchingParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemEventSink_INTERFACE_DEFINED__ */


#ifndef __IWbemObjectSinkEx_INTERFACE_DEFINED__
#define __IWbemObjectSinkEx_INTERFACE_DEFINED__

/* interface IWbemObjectSinkEx */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemObjectSinkEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dd0be256-50dc-48a8-9866-b559f279d0f6")
    IWbemObjectSinkEx : public IWbemObjectSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ long lFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ void *pComObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemObjectSinkExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemObjectSinkEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemObjectSinkEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemObjectSinkEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *Indicate )( 
            IWbemObjectSinkEx * This,
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject **apObjArray);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            IWbemObjectSinkEx * This,
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject *pObjParam);
        
        HRESULT ( STDMETHODCALLTYPE *Set )( 
            IWbemObjectSinkEx * This,
            /* [in] */ long lFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ void *pComObject);
        
        END_INTERFACE
    } IWbemObjectSinkExVtbl;

    interface IWbemObjectSinkEx
    {
        CONST_VTBL struct IWbemObjectSinkExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemObjectSinkEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemObjectSinkEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemObjectSinkEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemObjectSinkEx_Indicate(This,lObjectCount,apObjArray)	\
    (This)->lpVtbl -> Indicate(This,lObjectCount,apObjArray)

#define IWbemObjectSinkEx_SetStatus(This,lFlags,hResult,strParam,pObjParam)	\
    (This)->lpVtbl -> SetStatus(This,lFlags,hResult,strParam,pObjParam)


#define IWbemObjectSinkEx_Set(This,lFlags,riid,pComObject)	\
    (This)->lpVtbl -> Set(This,lFlags,riid,pComObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemObjectSinkEx_Set_Proxy( 
    IWbemObjectSinkEx * This,
    /* [in] */ long lFlags,
    /* [in] */ REFIID riid,
    /* [iid_is][in] */ void *pComObject);


void __RPC_STUB IWbemObjectSinkEx_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemObjectSinkEx_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_WbemLocator;

#ifdef __cplusplus

class DECLSPEC_UUID("4590f811-1d3a-11d0-891f-00aa004b2e24")
WbemLocator;
#endif

EXTERN_C const CLSID CLSID_WbemConnection;

#ifdef __cplusplus

class DECLSPEC_UUID("4c6055d8-84b9-4111-a7d3-6623894eedb3")
WbemConnection;
#endif

EXTERN_C const CLSID CLSID_WbemContext;

#ifdef __cplusplus

class DECLSPEC_UUID("674B6698-EE92-11d0-AD71-00C04FD8FDFF")
WbemContext;
#endif

EXTERN_C const CLSID CLSID_UnsecuredApartment;

#ifdef __cplusplus

class DECLSPEC_UUID("49bd2028-1523-11d1-ad79-00c04fd8fdff")
UnsecuredApartment;
#endif

EXTERN_C const CLSID CLSID_WbemClassObject;

#ifdef __cplusplus

class DECLSPEC_UUID("9A653086-174F-11d2-B5F9-00104B703EFD")
WbemClassObject;
#endif

EXTERN_C const CLSID CLSID_MofCompiler;

#ifdef __cplusplus

class DECLSPEC_UUID("6daf9757-2e37-11d2-aec9-00c04fb68820")
MofCompiler;
#endif

EXTERN_C const CLSID CLSID_WbemStatusCodeText;

#ifdef __cplusplus

class DECLSPEC_UUID("eb87e1bd-3233-11d2-aec9-00c04fb68820")
WbemStatusCodeText;
#endif

EXTERN_C const CLSID CLSID_WbemBackupRestore;

#ifdef __cplusplus

class DECLSPEC_UUID("C49E32C6-BC8B-11d2-85D4-00105A1F8304")
WbemBackupRestore;
#endif

EXTERN_C const CLSID CLSID_WbemRefresher;

#ifdef __cplusplus

class DECLSPEC_UUID("c71566f2-561e-11d1-ad87-00c04fd8fdff")
WbemRefresher;
#endif

EXTERN_C const CLSID CLSID_WbemObjectTextSrc;

#ifdef __cplusplus

class DECLSPEC_UUID("8D1C559D-84F0-4bb3-A7D5-56A7435A9BA6")
WbemObjectTextSrc;
#endif
#endif /* __WbemClient_v1_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_wbemcli_0000 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0000_v0_0_s_ifspec;

/* interface __MIDL_itf_wbemcli_0108 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0108_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0108_v0_0_s_ifspec;

#ifndef __IWbemComBinding_INTERFACE_DEFINED__
#define __IWbemComBinding_INTERFACE_DEFINED__

/* interface IWbemComBinding */
/* [unique][uuid][local][restricted][object] */ 


EXTERN_C const IID IID_IWbemComBinding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("974CAB5F-D7FD-4c52-958F-E3D94D6CB505")
    IWbemComBinding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCLSIDArrayForIID( 
            /* [in] */ IWbemServicesEx *pSvcEx,
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ REFIID riid,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ SAFEARRAY * *pArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindComObject( 
            /* [in] */ IWbemServicesEx *pSvcEx,
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ CLSID ClsId,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ long lFlags,
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ DWORD dwClsCntxt,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID *pInterface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCLSIDArrayForNames( 
            /* [in] */ IWbemServicesEx *pSvcEx,
            /* [in] */ IWbemClassObject *pObject,
            /* [size_is][in] */ LPCWSTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY * *pArray) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemComBindingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemComBinding * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemComBinding * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemComBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCLSIDArrayForIID )( 
            IWbemComBinding * This,
            /* [in] */ IWbemServicesEx *pSvcEx,
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ REFIID riid,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ SAFEARRAY * *pArray);
        
        HRESULT ( STDMETHODCALLTYPE *BindComObject )( 
            IWbemComBinding * This,
            /* [in] */ IWbemServicesEx *pSvcEx,
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ CLSID ClsId,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ long lFlags,
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ DWORD dwClsCntxt,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID *pInterface);
        
        HRESULT ( STDMETHODCALLTYPE *GetCLSIDArrayForNames )( 
            IWbemComBinding * This,
            /* [in] */ IWbemServicesEx *pSvcEx,
            /* [in] */ IWbemClassObject *pObject,
            /* [size_is][in] */ LPCWSTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY * *pArray);
        
        END_INTERFACE
    } IWbemComBindingVtbl;

    interface IWbemComBinding
    {
        CONST_VTBL struct IWbemComBindingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemComBinding_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemComBinding_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemComBinding_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemComBinding_GetCLSIDArrayForIID(This,pSvcEx,pObject,riid,lFlags,pCtx,pArray)	\
    (This)->lpVtbl -> GetCLSIDArrayForIID(This,pSvcEx,pObject,riid,lFlags,pCtx,pArray)

#define IWbemComBinding_BindComObject(This,pSvcEx,pObject,ClsId,pCtx,lFlags,pUnkOuter,dwClsCntxt,riid,pInterface)	\
    (This)->lpVtbl -> BindComObject(This,pSvcEx,pObject,ClsId,pCtx,lFlags,pUnkOuter,dwClsCntxt,riid,pInterface)

#define IWbemComBinding_GetCLSIDArrayForNames(This,pSvcEx,pObject,rgszNames,cNames,lcid,pCtx,lFlags,pArray)	\
    (This)->lpVtbl -> GetCLSIDArrayForNames(This,pSvcEx,pObject,rgszNames,cNames,lcid,pCtx,lFlags,pArray)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemComBinding_GetCLSIDArrayForIID_Proxy( 
    IWbemComBinding * This,
    /* [in] */ IWbemServicesEx *pSvcEx,
    /* [in] */ IWbemClassObject *pObject,
    /* [in] */ REFIID riid,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ SAFEARRAY * *pArray);


void __RPC_STUB IWbemComBinding_GetCLSIDArrayForIID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemComBinding_BindComObject_Proxy( 
    IWbemComBinding * This,
    /* [in] */ IWbemServicesEx *pSvcEx,
    /* [in] */ IWbemClassObject *pObject,
    /* [in] */ CLSID ClsId,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ long lFlags,
    /* [in] */ IUnknown *pUnkOuter,
    /* [in] */ DWORD dwClsCntxt,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPVOID *pInterface);


void __RPC_STUB IWbemComBinding_BindComObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemComBinding_GetCLSIDArrayForNames_Proxy( 
    IWbemComBinding * This,
    /* [in] */ IWbemServicesEx *pSvcEx,
    /* [in] */ IWbemClassObject *pObject,
    /* [size_is][in] */ LPCWSTR *rgszNames,
    /* [in] */ UINT cNames,
    /* [in] */ LCID lcid,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ long lFlags,
    /* [out] */ SAFEARRAY * *pArray);


void __RPC_STUB IWbemComBinding_GetCLSIDArrayForNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemComBinding_INTERFACE_DEFINED__ */


#ifndef __IWbemInitComBinding_INTERFACE_DEFINED__
#define __IWbemInitComBinding_INTERFACE_DEFINED__

/* interface IWbemInitComBinding */
/* [unique][uuid][local][restricted][object] */ 


EXTERN_C const IID IID_IWbemInitComBinding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B4AF2F3C-5FE3-405e-8A9F-D275E3079F6D")
    IWbemInitComBinding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ULONG ulFlags,
            /* [in] */ IWbemServicesEx *pSvcEx,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemInitComBindingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemInitComBinding * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemInitComBinding * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemInitComBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IWbemInitComBinding * This,
            /* [in] */ ULONG ulFlags,
            /* [in] */ IWbemServicesEx *pSvcEx,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pObject);
        
        END_INTERFACE
    } IWbemInitComBindingVtbl;

    interface IWbemInitComBinding
    {
        CONST_VTBL struct IWbemInitComBindingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemInitComBinding_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemInitComBinding_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemInitComBinding_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemInitComBinding_Initialize(This,ulFlags,pSvcEx,pCtx,pObject)	\
    (This)->lpVtbl -> Initialize(This,ulFlags,pSvcEx,pCtx,pObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemInitComBinding_Initialize_Proxy( 
    IWbemInitComBinding * This,
    /* [in] */ ULONG ulFlags,
    /* [in] */ IWbemServicesEx *pSvcEx,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemClassObject *pObject);


void __RPC_STUB IWbemInitComBinding_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemInitComBinding_INTERFACE_DEFINED__ */


#ifndef __IWbemRawSdAccessor_INTERFACE_DEFINED__
#define __IWbemRawSdAccessor_INTERFACE_DEFINED__

/* interface IWbemRawSdAccessor */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemRawSdAccessor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c1e2d759-cabd-11d3-a11b-00105a1f515a")
    IWbemRawSdAccessor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG uBufSize,
            /* [out] */ ULONG *puSDSize,
            /* [length_is][size_is][out][in] */ byte *pSD) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Put( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG uBufSize,
            /* [size_is][in] */ byte *pSD) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemRawSdAccessorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemRawSdAccessor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemRawSdAccessor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemRawSdAccessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            IWbemRawSdAccessor * This,
            /* [in] */ long lFlags,
            /* [in] */ ULONG uBufSize,
            /* [out] */ ULONG *puSDSize,
            /* [length_is][size_is][out][in] */ byte *pSD);
        
        HRESULT ( STDMETHODCALLTYPE *Put )( 
            IWbemRawSdAccessor * This,
            /* [in] */ long lFlags,
            /* [in] */ ULONG uBufSize,
            /* [size_is][in] */ byte *pSD);
        
        END_INTERFACE
    } IWbemRawSdAccessorVtbl;

    interface IWbemRawSdAccessor
    {
        CONST_VTBL struct IWbemRawSdAccessorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemRawSdAccessor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemRawSdAccessor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemRawSdAccessor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemRawSdAccessor_Get(This,lFlags,uBufSize,puSDSize,pSD)	\
    (This)->lpVtbl -> Get(This,lFlags,uBufSize,puSDSize,pSD)

#define IWbemRawSdAccessor_Put(This,lFlags,uBufSize,pSD)	\
    (This)->lpVtbl -> Put(This,lFlags,uBufSize,pSD)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemRawSdAccessor_Get_Proxy( 
    IWbemRawSdAccessor * This,
    /* [in] */ long lFlags,
    /* [in] */ ULONG uBufSize,
    /* [out] */ ULONG *puSDSize,
    /* [length_is][size_is][out][in] */ byte *pSD);


void __RPC_STUB IWbemRawSdAccessor_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemRawSdAccessor_Put_Proxy( 
    IWbemRawSdAccessor * This,
    /* [in] */ long lFlags,
    /* [in] */ ULONG uBufSize,
    /* [size_is][in] */ byte *pSD);


void __RPC_STUB IWbemRawSdAccessor_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemRawSdAccessor_INTERFACE_DEFINED__ */


#ifndef __IWbemShutdown_INTERFACE_DEFINED__
#define __IWbemShutdown_INTERFACE_DEFINED__

/* interface IWbemShutdown */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWbemShutdown;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b7b31df9-d515-11d3-a11c-00105a1f515a")
    IWbemShutdown : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Shutdown( 
            /* [in] */ LONG uReason,
            /* [in] */ ULONG uMaxMilliseconds,
            /* [in] */ IWbemContext *pCtx) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemShutdownVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemShutdown * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemShutdown * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemShutdown * This);
        
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            IWbemShutdown * This,
            /* [in] */ LONG uReason,
            /* [in] */ ULONG uMaxMilliseconds,
            /* [in] */ IWbemContext *pCtx);
        
        END_INTERFACE
    } IWbemShutdownVtbl;

    interface IWbemShutdown
    {
        CONST_VTBL struct IWbemShutdownVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemShutdown_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemShutdown_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemShutdown_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemShutdown_Shutdown(This,uReason,uMaxMilliseconds,pCtx)	\
    (This)->lpVtbl -> Shutdown(This,uReason,uMaxMilliseconds,pCtx)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemShutdown_Shutdown_Proxy( 
    IWbemShutdown * This,
    /* [in] */ LONG uReason,
    /* [in] */ ULONG uMaxMilliseconds,
    /* [in] */ IWbemContext *pCtx);


void __RPC_STUB IWbemShutdown_Shutdown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemShutdown_INTERFACE_DEFINED__ */


#ifndef __IWbemCallStatus_INTERFACE_DEFINED__
#define __IWbemCallStatus_INTERFACE_DEFINED__

/* interface IWbemCallStatus */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IWbemCallStatus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4212dc47-142e-4c6c-bc49-6ca232dd0959")
    IWbemCallStatus : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCallStatus( 
            /* [in] */ ULONG uFlags,
            /* [in] */ LCID lLocale,
            /* [out] */ HRESULT *phRes,
            /* [out] */ BSTR *pszMsg,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID *pObj) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemCallStatusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemCallStatus * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemCallStatus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemCallStatus * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallStatus )( 
            IWbemCallStatus * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ LCID lLocale,
            /* [out] */ HRESULT *phRes,
            /* [out] */ BSTR *pszMsg,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID *pObj);
        
        END_INTERFACE
    } IWbemCallStatusVtbl;

    interface IWbemCallStatus
    {
        CONST_VTBL struct IWbemCallStatusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemCallStatus_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemCallStatus_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemCallStatus_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemCallStatus_GetCallStatus(This,uFlags,lLocale,phRes,pszMsg,riid,pObj)	\
    (This)->lpVtbl -> GetCallStatus(This,uFlags,lLocale,phRes,pszMsg,riid,pObj)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemCallStatus_GetCallStatus_Proxy( 
    IWbemCallStatus * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ LCID lLocale,
    /* [out] */ HRESULT *phRes,
    /* [out] */ BSTR *pszMsg,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPVOID *pObj);


void __RPC_STUB IWbemCallStatus_GetCallStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemCallStatus_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wbemcli_0123 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum tag_WMI_OBJ_TEXT
    {	WMI_OBJ_TEXT_MOF_V1	= 0,
	WMI_OBJ_TEXT_CIM_DTD_2_0	= 1,
	WMI_OBJ_TEXT_WMI_DTD_2_0	= 2,
	WMI_OBJ_TEXT_WMI_DTD_2_0_EX	= 3,
	WMI_OBJ_TEXT_WMI_EXT1	= 4,
	WMI_OBJ_TEXT_WMI_EXT2	= 5,
	WMI_OBJ_TEXT_WMI_EXT3	= 6,
	WMI_OBJ_TEXT_WMI_EXT4	= 7,
	WMI_OBJ_TEXT_WMI_EXT5	= 8,
	WMI_OBJ_TEXT_WMI_EXT6	= 9,
	WMI_OBJ_TEXT_WMI_EXT7	= 10,
	WMI_OBJ_TEXT_WMI_EXT8	= 11,
	WMI_OBJ_TEXT_WMI_EXT9	= 12,
	WMI_OBJ_TEXT_WMI_EXT10	= 13,
	WMI_OBJ_TEXT_LAST	= 14
    } 	WMI_OBJ_TEXT;



extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0123_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0123_v0_0_s_ifspec;

#ifndef __IWbemObjectTextSrc_INTERFACE_DEFINED__
#define __IWbemObjectTextSrc_INTERFACE_DEFINED__

/* interface IWbemObjectTextSrc */
/* [uuid][local][restricted][object] */ 


EXTERN_C const IID IID_IWbemObjectTextSrc;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bfbf883a-cad7-11d3-a11b-00105a1f515a")
    IWbemObjectTextSrc : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pObj,
            /* [in] */ ULONG uObjTextFormat,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ BSTR *strText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateFromText( 
            /* [in] */ long lFlags,
            /* [in] */ BSTR strText,
            /* [in] */ ULONG uObjTextFormat,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IWbemClassObject **pNewObj) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemObjectTextSrcVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemObjectTextSrc * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemObjectTextSrc * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemObjectTextSrc * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            IWbemObjectTextSrc * This,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pObj,
            /* [in] */ ULONG uObjTextFormat,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ BSTR *strText);
        
        HRESULT ( STDMETHODCALLTYPE *CreateFromText )( 
            IWbemObjectTextSrc * This,
            /* [in] */ long lFlags,
            /* [in] */ BSTR strText,
            /* [in] */ ULONG uObjTextFormat,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IWbemClassObject **pNewObj);
        
        END_INTERFACE
    } IWbemObjectTextSrcVtbl;

    interface IWbemObjectTextSrc
    {
        CONST_VTBL struct IWbemObjectTextSrcVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemObjectTextSrc_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemObjectTextSrc_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemObjectTextSrc_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemObjectTextSrc_GetText(This,lFlags,pObj,uObjTextFormat,pCtx,strText)	\
    (This)->lpVtbl -> GetText(This,lFlags,pObj,uObjTextFormat,pCtx,strText)

#define IWbemObjectTextSrc_CreateFromText(This,lFlags,strText,uObjTextFormat,pCtx,pNewObj)	\
    (This)->lpVtbl -> CreateFromText(This,lFlags,strText,uObjTextFormat,pCtx,pNewObj)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemObjectTextSrc_GetText_Proxy( 
    IWbemObjectTextSrc * This,
    /* [in] */ long lFlags,
    /* [in] */ IWbemClassObject *pObj,
    /* [in] */ ULONG uObjTextFormat,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ BSTR *strText);


void __RPC_STUB IWbemObjectTextSrc_GetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectTextSrc_CreateFromText_Proxy( 
    IWbemObjectTextSrc * This,
    /* [in] */ long lFlags,
    /* [in] */ BSTR strText,
    /* [in] */ ULONG uObjTextFormat,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IWbemClassObject **pNewObj);


void __RPC_STUB IWbemObjectTextSrc_CreateFromText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemObjectTextSrc_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wbemcli_0125 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_wbemcli_0125_0001
    {	WBEM_TRANSACTION_STATE_NULL	= 0,
	WBEM_TRANSACTION_STATE_PENDING	= 1,
	WBEM_TRANSACTION_STATE_PRECOMMIT	= 2,
	WBEM_TRANSACTION_STATE_COMMIT	= 3,
	WBEM_TRANSACTION_STATE_EVENT_PLAYBACK	= 4,
	WBEM_TRANSACTION_STATE_COMPLETED	= 5,
	WBEM_TRANSACTION_STATE_ROLLED_BACK	= 6,
	WBEM_TRANSACTION_STATE_CLEANUP	= 7,
	WBEM_TRANSACTION_STATE_FATAL	= 8
    } 	WBEM_TRANSACTION_STATUS_FLAG;



extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0125_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0125_v0_0_s_ifspec;

#ifndef __IWbemTransaction_INTERFACE_DEFINED__
#define __IWbemTransaction_INTERFACE_DEFINED__

/* interface IWbemTransaction */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWbemTransaction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3f7bb3cc-9985-42e7-9186-2d53124ad20b")
    IWbemTransaction : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Begin( 
            /* [in] */ ULONG uTimeout,
            /* [in] */ ULONG uFlags,
            /* [in] */ GUID *pTransGUID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Rollback( 
            /* [in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryState( 
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG *puState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemTransactionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemTransaction * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemTransaction * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemTransaction * This);
        
        HRESULT ( STDMETHODCALLTYPE *Begin )( 
            IWbemTransaction * This,
            /* [in] */ ULONG uTimeout,
            /* [in] */ ULONG uFlags,
            /* [in] */ GUID *pTransGUID);
        
        HRESULT ( STDMETHODCALLTYPE *Rollback )( 
            IWbemTransaction * This,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IWbemTransaction * This,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE *QueryState )( 
            IWbemTransaction * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG *puState);
        
        END_INTERFACE
    } IWbemTransactionVtbl;

    interface IWbemTransaction
    {
        CONST_VTBL struct IWbemTransactionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemTransaction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemTransaction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemTransaction_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemTransaction_Begin(This,uTimeout,uFlags,pTransGUID)	\
    (This)->lpVtbl -> Begin(This,uTimeout,uFlags,pTransGUID)

#define IWbemTransaction_Rollback(This,uFlags)	\
    (This)->lpVtbl -> Rollback(This,uFlags)

#define IWbemTransaction_Commit(This,uFlags)	\
    (This)->lpVtbl -> Commit(This,uFlags)

#define IWbemTransaction_QueryState(This,uFlags,puState)	\
    (This)->lpVtbl -> QueryState(This,uFlags,puState)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemTransaction_Begin_Proxy( 
    IWbemTransaction * This,
    /* [in] */ ULONG uTimeout,
    /* [in] */ ULONG uFlags,
    /* [in] */ GUID *pTransGUID);


void __RPC_STUB IWbemTransaction_Begin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemTransaction_Rollback_Proxy( 
    IWbemTransaction * This,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IWbemTransaction_Rollback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemTransaction_Commit_Proxy( 
    IWbemTransaction * This,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IWbemTransaction_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemTransaction_QueryState_Proxy( 
    IWbemTransaction * This,
    /* [in] */ ULONG uFlags,
    /* [out] */ ULONG *puState);


void __RPC_STUB IWbemTransaction_QueryState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemTransaction_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wbemcli_0126 */
/* [local] */ 

typedef struct tag_CompileStatusInfo
    {
    long lPhaseError;
    HRESULT hRes;
    long ObjectNum;
    long FirstLine;
    long LastLine;
    DWORD dwOutFlags;
    } 	WBEM_COMPILE_STATUS_INFO;

typedef /* [v1_enum] */ 
enum tag_WBEM_COMPILER_OPTIONS
    {	WBEM_FLAG_CHECK_ONLY	= 0x1,
	WBEM_FLAG_AUTORECOVER	= 0x2,
	WBEM_FLAG_WMI_CHECK	= 0x4,
	WBEM_FLAG_CONSOLE_PRINT	= 0x8,
	WBEM_FLAG_DONT_ADD_TO_LIST	= 0x10,
	WBEM_FLAG_SPLIT_FILES	= 0x20
    } 	WBEM_COMPILER_OPTIONS;



extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0126_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0126_v0_0_s_ifspec;

#ifndef __IMofCompiler_INTERFACE_DEFINED__
#define __IMofCompiler_INTERFACE_DEFINED__

/* interface IMofCompiler */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IMofCompiler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6daf974e-2e37-11d2-aec9-00c04fb68820")
    IMofCompiler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CompileFile( 
            /* [string][in] */ LPWSTR FileName,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [string][in] */ LPWSTR User,
            /* [string][in] */ LPWSTR Authority,
            /* [string][in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompileBuffer( 
            /* [in] */ long BuffSize,
            /* [size_is][in] */ BYTE *pBuffer,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [string][in] */ LPWSTR User,
            /* [string][in] */ LPWSTR Authority,
            /* [string][in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBMOF( 
            /* [string][in] */ LPWSTR TextFileName,
            /* [string][in] */ LPWSTR BMOFFileName,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMofCompilerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMofCompiler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMofCompiler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMofCompiler * This);
        
        HRESULT ( STDMETHODCALLTYPE *CompileFile )( 
            IMofCompiler * This,
            /* [string][in] */ LPWSTR FileName,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [string][in] */ LPWSTR User,
            /* [string][in] */ LPWSTR Authority,
            /* [string][in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *CompileBuffer )( 
            IMofCompiler * This,
            /* [in] */ long BuffSize,
            /* [size_is][in] */ BYTE *pBuffer,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [string][in] */ LPWSTR User,
            /* [string][in] */ LPWSTR Authority,
            /* [string][in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBMOF )( 
            IMofCompiler * This,
            /* [string][in] */ LPWSTR TextFileName,
            /* [string][in] */ LPWSTR BMOFFileName,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo);
        
        END_INTERFACE
    } IMofCompilerVtbl;

    interface IMofCompiler
    {
        CONST_VTBL struct IMofCompilerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMofCompiler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMofCompiler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMofCompiler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMofCompiler_CompileFile(This,FileName,ServerAndNamespace,User,Authority,Password,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)	\
    (This)->lpVtbl -> CompileFile(This,FileName,ServerAndNamespace,User,Authority,Password,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)

#define IMofCompiler_CompileBuffer(This,BuffSize,pBuffer,ServerAndNamespace,User,Authority,Password,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)	\
    (This)->lpVtbl -> CompileBuffer(This,BuffSize,pBuffer,ServerAndNamespace,User,Authority,Password,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)

#define IMofCompiler_CreateBMOF(This,TextFileName,BMOFFileName,ServerAndNamespace,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)	\
    (This)->lpVtbl -> CreateBMOF(This,TextFileName,BMOFFileName,ServerAndNamespace,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMofCompiler_CompileFile_Proxy( 
    IMofCompiler * This,
    /* [string][in] */ LPWSTR FileName,
    /* [string][in] */ LPWSTR ServerAndNamespace,
    /* [string][in] */ LPWSTR User,
    /* [string][in] */ LPWSTR Authority,
    /* [string][in] */ LPWSTR Password,
    /* [in] */ LONG lOptionFlags,
    /* [in] */ LONG lClassFlags,
    /* [in] */ LONG lInstanceFlags,
    /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo);


void __RPC_STUB IMofCompiler_CompileFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMofCompiler_CompileBuffer_Proxy( 
    IMofCompiler * This,
    /* [in] */ long BuffSize,
    /* [size_is][in] */ BYTE *pBuffer,
    /* [string][in] */ LPWSTR ServerAndNamespace,
    /* [string][in] */ LPWSTR User,
    /* [string][in] */ LPWSTR Authority,
    /* [string][in] */ LPWSTR Password,
    /* [in] */ LONG lOptionFlags,
    /* [in] */ LONG lClassFlags,
    /* [in] */ LONG lInstanceFlags,
    /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo);


void __RPC_STUB IMofCompiler_CompileBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMofCompiler_CreateBMOF_Proxy( 
    IMofCompiler * This,
    /* [string][in] */ LPWSTR TextFileName,
    /* [string][in] */ LPWSTR BMOFFileName,
    /* [string][in] */ LPWSTR ServerAndNamespace,
    /* [in] */ LONG lOptionFlags,
    /* [in] */ LONG lClassFlags,
    /* [in] */ LONG lInstanceFlags,
    /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo);


void __RPC_STUB IMofCompiler_CreateBMOF_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMofCompiler_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wbemcli_0128 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum tag_WBEM_INFORMATION_FLAG_TYPE
    {	WBEM_FLAG_SHORT_NAME	= 0x1,
	WBEM_FLAG_LONG_NAME	= 0x2
    } 	WBEM_INFORMATION_FLAG_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0128_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0128_v0_0_s_ifspec;

/* interface __MIDL_itf_wbemcli_0134 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum tag_WBEM_BATCH_TYPE
    {	WBEM_FLAG_BATCH_IF_NEEDED	= 0,
	WBEM_FLAG_MUST_BATCH	= 0x1,
	WBEM_FLAG_MUST_NOT_BATCH	= 0x2
    } 	WBEM_BATCH_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0134_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0134_v0_0_s_ifspec;

/* interface __MIDL_itf_wbemcli_0135 */
/* [local] */ 

#define IWbemBinder IWbemConnection
#define IID_IWbemBinder IID_IWbemConnection
#define CLSID_WbemBinder CLSID_WbemConnection


extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0135_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0135_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\utils\wmisec\wmisinkdemultiplexor.cpp ===
// WmiSinkDemultiplexor.cpp : Implementation of CWmiSinkDemultiplexor
#include "stdafx.h"
#include "wbemcli.h"
#include "Wmisec.h"
#include "WmiSinkDemultiplexor.h"

/////////////////////////////////////////////////////////////////////////////
// CWmiSinkDemultiplexor


STDMETHODIMP CWmiSinkDemultiplexor::GetDemultiplexedStub(IUnknown *pObject, IUnknown **ppObject)
{
	HRESULT hr = E_FAIL;
	
	// TODO - thread safety!

	// Only call this once!
#if 0
	if (pObject && ppObject && !m_pIWbemObjectSink)
#else
	if (pObject && ppObject)
#endif
	{
		// Try and QI for the IWmiEventSource interface
		CComPtr<IWmiEventSource> pIWmiEventSource;

		if (SUCCEEDED(pObject->QueryInterface(IID_IWmiEventSource, (LPVOID*) &pIWmiEventSource)))
		{
			// We got it - make a new object sink for it
#if 0
			m_pIWbemObjectSink = new InternalWbemObjectSink (pIWmiEventSource);

			if (m_pIWbemObjectSink)
			{
				m_pIWbemObjectSink->AddRef();

				// Lazily construct the unsecured apartment
				CComPtr<IUnsecuredApartment> pIUnsecuredApartment;

				if (SUCCEEDED(CoCreateInstance(CLSID_UnsecuredApartment, 0,  CLSCTX_ALL,
									 IID_IUnsecuredApartment, (LPVOID *) &pIUnsecuredApartment)))
				{
					CComPtr<IUnknown>	pIUnknownIn;

					if (SUCCEEDED(m_pIWbemObjectSink->QueryInterface (IID_IUnknown, (LPVOID*) &pIUnknownIn)))
					{
						CComPtr<IUnknown>	pIUnknown;

						if (SUCCEEDED (hr = pIUnsecuredApartment->CreateObjectStub(pIUnknownIn, &pIUnknown)))
						{
							// Ensure we QI for IWbemObjectSink
							hr = pIUnknown->QueryInterface (IID_IWbemObjectSink, (LPVOID*) ppObject);
						}
					}
				}
			}
#else
			InternalWbemObjectSink *pInternalWbemObjectSink = new InternalWbemObjectSink (pIWmiEventSource);

			if (pInternalWbemObjectSink)
			{
				CComPtr<IUnknown>		pIUnknownIn;

				if (SUCCEEDED(pInternalWbemObjectSink->QueryInterface (IID_IUnknown, (LPVOID*) &pIUnknownIn)))
				{
					CComPtr<IUnsecuredApartment> pIUnsecuredApartment;

					if (SUCCEEDED(CoCreateInstance(CLSID_UnsecuredApartment, 0,  CLSCTX_ALL,
										 IID_IUnsecuredApartment, (LPVOID *) &pIUnsecuredApartment)))
					{
						CComPtr<IUnknown>	pIUnknownOut;

						if (SUCCEEDED (hr = pIUnsecuredApartment->CreateObjectStub(pIUnknownIn, &pIUnknownOut)))
						{
							// Ensure we QI for IWbemObjectSink
							hr = pIUnknownOut->QueryInterface (IID_IWbemObjectSink, (LPVOID*) ppObject);
						}
					}
				}
			}
#endif
				
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\utils\wmisec\wmisecurityhelper.cpp ===
// WmiSecurityHelper.cpp : Implementation of CWmiSecurityHelper
#include "stdafx.h"
#include "wbemcli.h"
#include "Wmisec.h"
#include "WmiSecurityHelper.h"

#ifndef RPC_C_AUTHZ_DEFAULT
#define RPC_C_AUTHZ_DEFAULT 0xffffffff
#endif 

#ifndef EOAC_STATIC_CLOAKING
#define EOAC_STATIC_CLOAKING	0x20
#endif

#ifndef EOAC_DYNAMIC_CLOAKING
#define EOAC_DYNAMIC_CLOAKING	0x40
#endif 

#ifndef COLE_DEFAULT_AUTHINFO
#define	COLE_DEFAULT_AUTHINFO	( ( void * )-1 )
#endif 

#ifdef LOG_DEBUG
static HANDLE logFile = NULL;

static void CreateLogFile ()
{
	logFile = CreateFile ("c:\\temp\\sec.txt", GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, 
				FILE_ATTRIBUTE_NORMAL, NULL);
	SetFilePointer (logFile, 0, NULL, FILE_END);
}

static CloseLogFile ()
{
	CloseHandle (logFile);
}
	
static void Logit (LPWSTR msg) 
{
	DWORD nBytes = 0;
	if (msg)
		WriteFile (logFile, msg, wcslen(msg)*2, &nBytes, NULL);
	else
		WriteFile (logFile, L"<null>", 12, &nBytes, NULL);
}

static void Logit (DWORD d) 
{
	DWORD nBytes = 0;
	WCHAR buf [20];
	_itow (d, buf, 10);

	WriteFile (logFile, buf, wcslen(buf)*2, &nBytes, NULL);
}

static void LogCoAuthIdentity (COAUTHIDENTITY *pAuthIdent)
{
	if (pAuthIdent)
	{
		Logit(L"User(");
		Logit(pAuthIdent->User);
		Logit(L") [");
		Logit(pAuthIdent->UserLength);
		Logit(L"] Password(");
		Logit(pAuthIdent->Password);
		Logit(L") [");
		Logit(pAuthIdent->PasswordLength);
		Logit(L"] Domain(");
		Logit(pAuthIdent->Domain);
		Logit(L") [");
		Logit(pAuthIdent->DomainLength);
		Logit(L"]\r\n");
	}
	else
		Logit(L"<null>");
}

static void LogAuthIdentity (RPC_AUTH_IDENTITY_HANDLE pAuthInfo)
{
	if (pAuthInfo)
	{
		try {
			COAUTHIDENTITY *pAuthId = (COAUTHIDENTITY*)pAuthInfo;
			LogCoAuthIdentity (pAuthId);
		} catch (...) {}
	}
	else
		Logit(L"<null>");
}

static void LogBlanket(IClientSecurity *pIClientSecurity, IUnknown *pInterface)
{
	DWORD logAuthnSvc, logAuthzSvc, logAuthnLevel, logImpLevel, logCapabilities;
	OLECHAR *logServerPrincName = NULL;
	RPC_AUTH_IDENTITY_HANDLE *logAuthInfo = NULL;

	if (SUCCEEDED(pIClientSecurity->QueryBlanket (pInterface, &logAuthnSvc,
			&logAuthzSvc, &logServerPrincName, &logAuthnLevel, &logImpLevel, (void**)&logAuthInfo, &logCapabilities)))
	{
		Logit(L"\r\n\r\nBlanket Settings:\r\n");
		Logit(L"================\r\n");
		
		Logit(L" AuthnSvc: ");
		Logit(logAuthnSvc);
		
		Logit(L"\r\n AuthzSvc: ");
		Logit(logAuthzSvc);
		
		Logit(L"\r\n Server Principal Name: ");
		Logit(logServerPrincName);
		
		Logit(L"\r\n AuthnLevel: ");
		Logit(logAuthnLevel);

		Logit(L"\r\n ImpLevel: ");
		Logit(logImpLevel);
		
		Logit(L"\r\n AuthInfo: ");
		LogAuthIdentity(logAuthInfo);
		
		Logit(L"\r\n Capabilities: ");
		Logit(logCapabilities);

		if (logServerPrincName)
			CoTaskMemFree (logServerPrincName);
	}
}

#else
#define Logit(x)
#define LogBlanket(x,y)
#define LogAuthIdentity(x)
#define LogCoAuthIdentity(x)
#define CreateLogFile()
#define CloseLogFile()
#endif

/////////////////////////////////////////////////////////////////////////////
// CWmiSecurityHelper

STDMETHODIMP CWmiSecurityHelper::BlessIWbemServices(
	IWbemServices **ppIWbemServices, 
	BSTR strUser, 
	BSTR strPassword, 
	BSTR strAuthority, 
	DWORD impLevel, 
	DWORD authnLevel)
{
	HRESULT hr = E_FAIL;

	CreateLogFile();
	Logit (L"\r\n\r\n>>Received BlessIWbemServices request<<\r\n\r\n");
	Logit (L" User: ");
	Logit (strUser);
	Logit (L"\r\n Password: ");
	Logit (strPassword);
	Logit (L"\r\n Authority: ");
	Logit (strAuthority);
	Logit (L"\r\n Impersonation: ");
	Logit (impLevel);
	Logit (L"\r\n Authentication: ");
	Logit (authnLevel);
	Logit (L"\r\n\r\n");
	
	if (ppIWbemServices && *ppIWbemServices)
	{
		// See if we get one
		CComBSTR bsUser (strUser);
		CComBSTR bsPassword (strPassword);
		CComBSTR bsAuthority (strAuthority);
	
		hr = SetInterfaceSecurity (*ppIWbemServices, bsAuthority, bsUser, bsPassword,
				authnLevel, impLevel, GetCapabilities (bsUser),
				CanUseDefaultInfo (*ppIWbemServices));
	}

	CloseLogFile ();
	return hr;
}

STDMETHODIMP CWmiSecurityHelper::BlessIEnumWbemClassObject(
	IEnumWbemClassObject **ppIEnumWbemClassObject, 
	BSTR strUser, 
	BSTR strPassword, 
	BSTR strAuthority, 
	DWORD impLevel, 
	DWORD authnLevel)
{
	HRESULT hr = E_FAIL;

	CreateLogFile();
	Logit (L"\r\n\r\n>>Received BlessIEnumWbemClassObject request<<\r\n\r\n");
	Logit (L" User: ");
	Logit (strUser);
	Logit (L"\r\n Password: ");
	Logit (strPassword);
	Logit (L"\r\n Authority: ");
	Logit (strAuthority);
	Logit (L"\r\n Impersonation: ");
	Logit (impLevel);
	Logit (L"\r\n Authentication: ");
	Logit (authnLevel);
	Logit (L"\r\n\r\n");

	if (ppIEnumWbemClassObject && *ppIEnumWbemClassObject)
	{
		// See if we get one
		CComBSTR bsUser (strUser);
		CComBSTR bsPassword (strPassword);
		CComBSTR bsAuthority (strAuthority);
	
		hr = SetInterfaceSecurity (*ppIEnumWbemClassObject, bsAuthority, bsUser, bsPassword,
				authnLevel, impLevel, GetCapabilities (bsUser),
				CanUseDefaultInfo (*ppIEnumWbemClassObject));
	}

	CloseLogFile();
	return hr;
}


STDMETHODIMP CWmiSecurityHelper::BlessIWbemCallResult(
	IWbemCallResult **ppIWbemCallResult, 
	BSTR strUser, 
	BSTR strPassword, 
	BSTR strAuthority, 
	DWORD impLevel, 
	DWORD authnLevel)
{
	HRESULT hr = E_FAIL;
	CreateLogFile();
	Logit (L"\r\n\r\n>>Received BlessIWbemCallResult request<<\r\n\r\n");
	Logit (L" User: ");
	Logit (strUser);
	Logit (L"\r\n Password: ");
	Logit (strPassword);
	Logit (L"\r\n Authority: ");
	Logit (strAuthority);
	Logit (L"\r\n Impersonation: ");
	Logit (impLevel);
	Logit (L"\r\n Authentication: ");
	Logit (authnLevel);
	Logit (L"\r\n\r\n");

	if (ppIWbemCallResult && *ppIWbemCallResult)
	{
		// See if we get one
		CComBSTR bsUser (strUser);
		CComBSTR bsPassword (strPassword);
		CComBSTR bsAuthority (strAuthority);
	
		hr = SetInterfaceSecurity (*ppIWbemCallResult, bsAuthority, bsUser, bsPassword,
				authnLevel, impLevel, GetCapabilities (bsUser),
				CanUseDefaultInfo (*ppIWbemCallResult));
	}

	CloseLogFile();
	return hr;
}

DWORD CWmiSecurityHelper::GetCapabilities (BSTR bsUser)
{
	DWORD dwCapabilities = EOAC_NONE;
	bool bUsingExplicitUserName = (bsUser && (0 < wcslen(bsUser)));
	
	if (IsNT () && (4 < GetNTMajorVersion ()) && !bUsingExplicitUserName)
		dwCapabilities |= EOAC_STATIC_CLOAKING;

	return dwCapabilities ;
}


bool CWmiSecurityHelper::CanUseDefaultInfo (IUnknown *pUnk)
{
	bool result = false; 

	if (IsNT() && (4 < GetNTMajorVersion ()))
	{
		HANDLE hToken = NULL;

		if (OpenThreadToken (GetCurrentThread (), TOKEN_QUERY, true, &hToken))
		{
			// Certainly a candidate to use default settings for
			// authorization and authentication service on the blanket.
			// Check if we are delegating.

			DWORD dwBytesReturned = 0;
			SECURITY_IMPERSONATION_LEVEL impLevel;

			if (GetTokenInformation(hToken, TokenImpersonationLevel, &impLevel,
							sizeof(SECURITY_IMPERSONATION_LEVEL), &dwBytesReturned) &&
									(SecurityDelegation == impLevel))
			{
				// Looks promising - now check for whether we are using kerberos
				
				if (pUnk)
				{
					CComQIPtr<IClientSecurity> pIClientSecurity(pUnk);
				
					if (pIClientSecurity)
					{
						DWORD dwAuthnSvc, dwAuthzSvc, dwImp, dwAuth, dwCapabilities;

						if (SUCCEEDED (pIClientSecurity->QueryBlanket(pUnk, &dwAuthnSvc, &dwAuthzSvc, 
												NULL,
												&dwAuth, &dwImp,
												NULL, &dwCapabilities)))
						{
							if (RPC_C_AUTHN_WINNT != dwAuthnSvc) 
								result = true;
						}
					}
				}
			}

			CloseHandle (hToken);
		}
	}

	return result;
}

HRESULT CWmiSecurityHelper::SetInterfaceSecurity(
			IUnknown * pInterface, 
			CComBSTR bsAuthority, 
			CComBSTR bsUser, 
			CComBSTR bsPassword,
            DWORD dwAuthLevel, 
			DWORD dwImpLevel, 
			DWORD dwCapabilities,
			bool bGetInfoFirst)
{
    
    HRESULT hr = E_FAIL;
    DWORD dwAuthenticationArg = RPC_C_AUTHN_WINNT;
    DWORD dwAuthorizationArg = RPC_C_AUTHZ_NONE;
	
#if 0
    if(!IsDcomEnabled())        // For the anon pipes clients, dont even bother
        return S_OK;
#endif

    //if(bGetInfoFirst)
        GetCurrValue(pInterface, dwAuthenticationArg, dwAuthorizationArg);

    // If we are doing trivial case, just pass in a null authenication structure which is used
    // if the current logged in user's credentials are OK.

    if((0 == bsAuthority.Length()) && 
        (0 == bsUser.Length()) && 
        (0 == bsPassword.Length()))
    {
		CComBSTR bsDummy;

		hr = SetProxyBlanket(pInterface, dwAuthenticationArg, dwAuthorizationArg, bsDummy,
            dwAuthLevel, dwImpLevel, 
            NULL,
            dwCapabilities);
    }
	else
	{
		// If user, or Authority was passed in, the we need to create an authority argument for the login
		CComBSTR bsAuthArg, bsUserArg, bsPrincipalArg;
    
		if (DetermineLoginType(bsAuthArg, bsUserArg, bsPrincipalArg, bsAuthority, bsUser))
		{
			Logit(L"\r\nPrincipal set to ");
			Logit(bsPrincipalArg);

			COAUTHIDENTITY*  pAuthIdent = NULL;
    
			// We will only need this structure if we are not cloaking and we want at least
			// connect level authorization
			bool okToProceed = true;

			if ( !( dwCapabilities & (EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING) )
				&& (dwAuthLevel >= RPC_C_AUTHN_LEVEL_CONNECT) )
			{
				okToProceed = AllocAuthIdentity( bsUserArg, bsPassword, bsAuthArg, &pAuthIdent );
				Logit(L"\r\nCOAUTHIDENTITY is ");
				LogCoAuthIdentity(pAuthIdent);
			}

			if (okToProceed)
			{
				hr = SetProxyBlanket(pInterface, 
					//(0 == bsPrincipalArg.Length()) ? 16 : dwAuthenticationArg, 
					dwAuthenticationArg, 
					dwAuthorizationArg, 
					bsPrincipalArg,
					dwAuthLevel, dwImpLevel, 
					pAuthIdent,
					dwCapabilities);
			}

			if (pAuthIdent)
				FreeAuthIdentity( pAuthIdent );
		}
	}

	return hr;
}

bool CWmiSecurityHelper::DetermineLoginType(
			CComBSTR & bsAuthArg, 
			CComBSTR & bsUserArg,
			CComBSTR & bsPrincipalArg,
            CComBSTR & bsAuthority,
			CComBSTR & bsUser)
{
    bool result = false;

    if((0 == bsAuthority.Length()) || (0 != _wcsnicmp(bsAuthority, L"KERBEROS:",9)))
        result = DetermineLoginType(bsAuthArg, bsUserArg, bsAuthority, bsUser);
	else
	{
		if(IsKerberosAvailable ())
		{
			bsPrincipalArg = (bsAuthority.m_str) + 9;
			CComBSTR bsTempArg;
			result = DetermineLoginType(bsAuthArg, bsUserArg, bsTempArg, bsUser);
		}
	}

	return result;
}

bool CWmiSecurityHelper::DetermineLoginType(
		CComBSTR & bsAuthArg, 
		CComBSTR & bsUserArg,
		CComBSTR & bsAuthority,
		CComBSTR & bsUser)
{
    // Determine the connection type by examining the Authority string
	bool result = false;

    if(0 == bsAuthority.Length() || (0 == _wcsnicmp(bsAuthority, L"NTLMDOMAIN:",11)))
	{    
		result = true;

		// The ntlm case is more complex.  There are four cases
		// 1)  Authority = NTLMDOMAIN:name" and User = "User"
		// 2)  Authority = NULL and User = "User"
		// 3)  Authority = "NTLMDOMAIN:" User = "domain\user"
		// 4)  Authority = NULL and User = "domain\user"

		// first step is to determine if there is a backslash in the user name somewhere between the
		// second and second to last character

		WCHAR * pSlashInUser = NULL;
		DWORD iDomLen = 0;

		if (0 < bsUser.Length ())
		{
			WCHAR * pEnd = bsUser + bsUser.Length() - 1;
			for(pSlashInUser = bsUser; pSlashInUser <= pEnd; pSlashInUser++)
			{
				if(*pSlashInUser == L'\\')      // dont think forward slash is allowed!
					break;

				iDomLen++;
			}

			if(pSlashInUser > pEnd)
				pSlashInUser = NULL;
		}

		if (11 < bsAuthority.Length()) 
		{
			if(!pSlashInUser)
			{
				bsAuthArg = bsAuthority.m_str + 11;

				if (0 < bsUser.Length()) 
					bsUserArg = bsUser;

			}
			else
				result = false;		// Can't have domain in Authority and in User
		}
		else if(pSlashInUser)
		{
			WCHAR cTemp[MAX_PATH];
			wcsncpy(cTemp, bsUser, iDomLen);
			cTemp[iDomLen] = 0;

			bsAuthArg = cTemp;

			if(0 < wcslen(pSlashInUser+1))
				bsUserArg = pSlashInUser+1;
		}
		else
		{
			if (0 < bsUser.Length()) 
				bsUserArg = bsUser;
		}
	}

    return result;
}

void CWmiSecurityHelper::FreeAuthIdentity( COAUTHIDENTITY* pAuthIdentity )
{
    // Make sure we have a pointer, then walk the structure members and
    // cleanup.

    if ( NULL != pAuthIdentity )
    {

		if (pAuthIdentity->User)
            CoTaskMemFree( pAuthIdentity->User );
        
        if (pAuthIdentity->Password)
            CoTaskMemFree( pAuthIdentity->Password );
        
        if (pAuthIdentity->Domain)
            CoTaskMemFree( pAuthIdentity->Domain );
        
        CoTaskMemFree( pAuthIdentity );
	}
}

bool CWmiSecurityHelper::AllocAuthIdentity( 
	CComBSTR & bsUser, 
	CComBSTR & bsPassword, 
	CComBSTR & bsDomain, 
	COAUTHIDENTITY** ppAuthIdent )
{
	bool result = false;

    if (ppAuthIdent)
    {
		// Handle an allocation failure
		COAUTHIDENTITY*  pAuthIdent = (COAUTHIDENTITY*) CoTaskMemAlloc( sizeof(COAUTHIDENTITY) );

		if (pAuthIdent)
		{
			result = true;
			memset((void *)pAuthIdent,0,sizeof(COAUTHIDENTITY));

			if(IsNT())
			{
				pAuthIdent->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
	
				if (bsUser.m_str)
				{
					pAuthIdent->User = (LPWSTR) CoTaskMemAlloc( ( bsUser.Length() + 1 ) * sizeof( WCHAR ) );
					pAuthIdent->UserLength = bsUser.Length ();

					if (pAuthIdent->User)
						wcscpy (pAuthIdent->User, bsUser.m_str);
					else
						result = false;
				}

				if (result && bsDomain.m_str)
				{
					pAuthIdent->Domain = (LPWSTR) CoTaskMemAlloc( ( bsDomain.Length() + 1 ) * sizeof( WCHAR ) );
					pAuthIdent->DomainLength = bsDomain.Length();

					if (pAuthIdent->Domain)
						wcscpy (pAuthIdent->Domain, bsDomain.m_str);
					else
						result = false;
				}

				if (result && bsPassword.m_str)
				{
					pAuthIdent->Password = (LPWSTR) CoTaskMemAlloc( (bsPassword.Length() + 1) * sizeof( WCHAR ) );
					pAuthIdent->PasswordLength = bsPassword.Length();
					
					if (pAuthIdent->Password)
						wcscpy (pAuthIdent->Password, bsPassword.m_str);
					else
						result = false;
				}
			}
			else
			{
				pAuthIdent->Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
				size_t  nBufferLength;

				if (bsUser.m_str)
				{
					nBufferLength = wcstombs( NULL, bsUser, 0 ) + 1;
					pAuthIdent->User = (LPWSTR) CoTaskMemAlloc( nBufferLength );
					pAuthIdent->UserLength = bsUser.Length ();
					
					if (pAuthIdent->User)
						wcstombs( (LPSTR) pAuthIdent->User, bsUser.m_str, nBufferLength );
					else
						result = false;
				}

				if (result && bsDomain.m_str)
				{
					nBufferLength = wcstombs( NULL, bsDomain, 0 ) + 1;
					pAuthIdent->Domain = (LPWSTR) CoTaskMemAlloc( nBufferLength );
					pAuthIdent->DomainLength = bsDomain.Length();

					if (pAuthIdent->Domain)
						wcstombs( (LPSTR) pAuthIdent->Domain, bsDomain.m_str, nBufferLength );
					else
						result = false;
				}

				if (bsPassword.m_str)
				{
					// How many characters do we need?
					nBufferLength = wcstombs( NULL, bsPassword, 0 ) + 1;
					pAuthIdent->Password = (LPWSTR) CoTaskMemAlloc( nBufferLength );
					pAuthIdent->PasswordLength = bsPassword.Length();

					if (pAuthIdent->Password)
						wcstombs( (LPSTR) pAuthIdent->Password, bsPassword.m_str, nBufferLength );
					else
						result = false;
				}
			}

			if (result)
				*ppAuthIdent = pAuthIdent;
			else
				FreeAuthIdentity (pAuthIdent);
		}
	}

    return result;
}

HRESULT CWmiSecurityHelper::SetProxyBlanket(
    IUnknown                 *pInterface,
    DWORD                     dwAuthnSvc,
    DWORD                     dwAuthzSvc,
    CComBSTR                  &bsServerPrincName,
    DWORD                     dwAuthLevel,
    DWORD                     dwImpLevel,
    RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
    DWORD                     dwCapabilities)
{
	HRESULT hr = E_FAIL;
	IUnknown * pUnk = NULL;

	if (SUCCEEDED(pInterface->QueryInterface(IID_IUnknown, (void **) &pUnk)))
	{
		CComQIPtr<IClientSecurity> pIClientSecurity(pInterface);
    
		if (pIClientSecurity)
		{
			/*
			 * Can't set pAuthInfo if cloaking requested, as cloaking implies
			 * that the current proxy identity in the impersonated thread (rather
			 * than the credentials supplied explicitly by the RPC_AUTH_IDENTITY_HANDLE)
			 * is to be used.
			 * See MSDN info on CoSetProxyBlanket for more details.
			 */
			if (dwCapabilities & (EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING))
			{
				Logit(L"\r\nUsing cloaking");
				pAuthInfo = NULL;
			}

			if (WMISEC_AUTH_LEVEL_UNCHANGED == dwAuthLevel)
			{
				Logit(L"\r\nNot changing authentication level");
				GetAuthenticationLevel (pInterface, dwAuthLevel);
			}

			Logit(L"\r\n\r\nBlanket settings to be used:");
			Logit(L"\r\n Authentication: ");
			Logit(dwAuthnSvc);
			Logit(L"\r\n Authorization: ");
			Logit(dwAuthzSvc);
			Logit(L"\r\n Server Principal Name: ");
			Logit(bsServerPrincName);
			Logit(L"\r\n Authentication Level: ");
			Logit(dwAuthLevel);
			Logit(L"\r\n Impersonation Level: ");
			Logit(dwImpLevel);
			Logit(L"\r\n Capabilities: ");
			Logit(dwCapabilities);

			if (pAuthInfo)
			{
				LogAuthIdentity(pAuthInfo);
			}
			else
			{
				Logit(L"\r\n Credentials: [none]");
			}
        
			if (SUCCEEDED(hr = pIClientSecurity->SetBlanket(
							pInterface, 
							dwAuthnSvc, 
							dwAuthzSvc, 
							bsServerPrincName,
							dwAuthLevel, 
							dwImpLevel, 
							pAuthInfo, 
							dwCapabilities)))
			{
				Logit(L"\r\nSuccessfully set blanket on interface");
				LogBlanket(pIClientSecurity, pInterface);

				// If we are not explicitly told to ignore the IUnknown, then we should
				// check the auth identity structure.  This performs a heuristic which
				// assumes a COAUTHIDENTITY structure.  If the structure is not one, we're
				// wrapped with a try/catch in case we AV (this should be benign since
				// we're not writing to memory).

				if ( DoesContainCredentials( (COAUTHIDENTITY*) pAuthInfo ) )
				{
					CComPtr<IClientSecurity>	pIClientSecurity2;

					if (SUCCEEDED(hr = pUnk->QueryInterface(IID_IClientSecurity, (void **) &pIClientSecurity2)))
					{
						hr = pIClientSecurity2->SetBlanket(
							pUnk, 
							dwAuthnSvc, 
							dwAuthzSvc, 
							bsServerPrincName,
							dwAuthLevel, 
							dwImpLevel, 
							pAuthInfo, 
							dwCapabilities);
#ifdef LOG_DEBUG
						if (SUCCEEDED(hr))
						{
							Logit(L"\r\nSuccessfully set blanket on IUnknown");
							LogBlanket(pIClientSecurity, pUnk);
						}
						else
						{
							Logit(L"\r\nFAILED to set blanket on IUnknown");
						}
#endif
					}
					else if (hr == 0x80004002)
						hr = S_OK;
				}
			}
		}

	    pUnk->Release();
	}
	else
	{
		Logit(L"\r\nFAILED to set blanket on interface");
	}

    return hr;
}

bool CWmiSecurityHelper::DoesContainCredentials( COAUTHIDENTITY* pAuthIdentity )
{
    try
    {
        if ( NULL != pAuthIdentity && COLE_DEFAULT_AUTHINFO != pAuthIdentity)
        {
            return ( pAuthIdentity->UserLength != 0 || pAuthIdentity->PasswordLength != 0 );
        }

        return false;
    }
    catch(...)
    {
        return false;
    }

}

void CWmiSecurityHelper::GetCurrValue(
		IUnknown * pInterface,
		DWORD & dwAuthenticationArg, 
		DWORD & dwAuthorizationArg)
{
	if(pInterface)
	{
		if (IsNT() && (4 < GetNTMajorVersion ()))
		{
			// Win2k or later we just use the DEFAULT constants - much safer!
			dwAuthenticationArg = RPC_C_AUTHN_DEFAULT;
			dwAuthorizationArg = RPC_C_AUTHZ_DEFAULT;
		}
		else
		{
			CComQIPtr<IClientSecurity> pIClientSecurity (pInterface);

			if(pIClientSecurity)
			{
				DWORD dwAuthnSvc, dwAuthzSvc;

				if (SUCCEEDED(pIClientSecurity->QueryBlanket(
									pInterface, &dwAuthnSvc, &dwAuthzSvc, 
									NULL, NULL, NULL, NULL, NULL)))
				{
					dwAuthenticationArg = dwAuthnSvc;
					dwAuthorizationArg = dwAuthzSvc;
				}
			}
		}

		Logit(L"Authentication service is ");
		Logit(dwAuthenticationArg);
		Logit(L"");
		Logit(L"Authorization service is ");
		Logit(dwAuthorizationArg);
		Logit(L"");
				
	}
}

void CWmiSecurityHelper::GetAuthenticationLevel(
		IUnknown * pInterface,
		DWORD & dwAuthLevel)
{
	if(pInterface)
	{
		CComQIPtr<IClientSecurity> pIClientSecurity (pInterface);

		if(pIClientSecurity)
		{
			/*
			 * Yes I know we shouldn't need to ask for dwAuthnSvc,
			 * but on Whistler passing a NULL for this into 
			 * QueryBlanket causes an AV. Until we know why, or that
			 * gets fixed, this has to stay!
			 */
			DWORD dwAuthnSvc;
			DWORD dwAuthenticationLevel;

			if (SUCCEEDED(pIClientSecurity->QueryBlanket(
								pInterface, &dwAuthnSvc, NULL,  
								NULL, &dwAuthenticationLevel, 
								NULL, NULL, NULL)))
				dwAuthLevel = dwAuthenticationLevel;
		}

		Logit(L"Authentication level is ");
		Logit(dwAuthLevel);
		Logit(L"");
				
	}
}

STDMETHODIMP CWmiSecurityHelper::SetSecurity(boolean *pNeedToReset, HANDLE *pCurrentThreadToken)
{
	HRESULT hr = E_FAIL;
	CreateLogFile();
	Logit (L"\r\n\r\n>>Received SetSecurity request<<\r\n\r\n");

	if ((NULL != pNeedToReset) && (NULL != pCurrentThreadToken))
	{
		*pNeedToReset = false;
		*pCurrentThreadToken = NULL;

		// This is a NO-OP for Win9x
		if (IsNT())
		{
			if (4 >= GetNTMajorVersion ())
			{
				HANDLE threadToken;

				if (OpenThreadToken (GetCurrentThread(), TOKEN_QUERY|TOKEN_IMPERSONATE,
										true, &threadToken))
				{
					/*
					 * We are being called on an impersonated thread. Unfortunately
					 * in NT4.0 this means our impersonation token credentials will NOT
					 * be passed to WMI (only the process token credentials will be passed). 
					 * Rather than fool the user into thinking that they will, bail out
					 * now.
					 */
					Logit(L"Being called on Impersonated NT 4.0 thread!\r\n");
					CloseHandle (threadToken);
				}

				/*
				 * For NT 4.0 we have to enable the privileges on the process token.
				 */
				HANDLE hProcessToken = NULL;
				HANDLE hProcess = GetCurrentProcess ();

				if (OpenProcessToken (
						hProcess, 
						TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES,
						&hProcessToken))
				{
					Logit(L"Adjusting privileges on NT4 process token\r\n");
					if (AdjustPrivileges (hProcessToken))
						hr = S_OK;

					CloseHandle (hProcessToken);
				}

				CloseHandle (hProcess);
			}
			else
			{
				// For NT5.0 or later we set a new thread token
				HANDLE hToken;
				SECURITY_IMPERSONATION_LEVEL secImpLevel = SecurityImpersonation;
				boolean gotToken = false;

				if (gotToken = OpenThreadToken (
									GetCurrentThread(), 
									TOKEN_QUERY|TOKEN_DUPLICATE|TOKEN_IMPERSONATE,
									true,
									&hToken))
				{
					// Already have a thread token - save it and get its' imp Level
					*pCurrentThreadToken = hToken;
					DWORD dwReturnLength = 0;

					Logit(L"Duplicating NT5 thread token\r\n");
					BOOL thisRes = GetTokenInformation (
											hToken,
											TokenImpersonationLevel, 
											&secImpLevel,
											sizeof(SECURITY_IMPERSONATION_LEVEL),
											&dwReturnLength);
				}
				else
				{
					// No thread token - use process token as our source token
					HANDLE hProcess = GetCurrentProcess ();
					Logit(L"Duplicating NT5 process token\r\n");
					gotToken = OpenProcessToken (hProcess, TOKEN_QUERY|TOKEN_DUPLICATE, &hToken);
				}

				if (gotToken)
				{
					/* 
					 * Getting here means we have a valid token (process or thread).
					 * First we check whether we need to alter the privileges
					 */
					TOKEN_PRIVILEGES *tp = NULL;

					if (NULL != (tp = AdjustPrivileges(hToken)))
					{
						/* 
						 * We do - duplicate it before setting the adjusted privileges.
						 */
						HANDLE hDupToken;

						if (DuplicateToken (hToken, hDupToken, secImpLevel))
						{
							if (AdjustTokenPrivileges(hDupToken, FALSE, tp, 0, NULL, NULL))
							{
								// Set this token into the current thread
								if (SetThreadToken (NULL, hDupToken))
								{
									Logit(L"Succesfully set thread token\r\n");
									*pNeedToReset = true;
									hr = S_OK;
									// TODO - do we need to resecure the proxy at this point?
								}
								else
								{
									Logit(L"Setting new thread token FAILED!\r\n");
								}

								CloseHandle (hDupToken);
							}
							else
							{
								Logit(L"AdjustTokenPrivileges FAILED!\r\n");
							}
						}
						else
						{
							Logit(L"Token duplication FAILED!\r\n");
						}

						delete [] tp;
						tp = NULL;
					}
					else
					{
						Logit(L"No privilege adjustment made\r\n");
					}

					// If we have duplicated the process token we can close the original now
					// as we don't need it to restore it. If we have duplicated the thread token
					// then we must hang on to it as we will need to restore it later in
					// ResetSecurity.
					if (!(*pCurrentThreadToken))
						CloseHandle (hToken);
				}
			}
		}
		else
			hr = S_OK;	// Win9x
	}

	CloseLogFile();
	return hr;
}

TOKEN_PRIVILEGES *CWmiSecurityHelper::AdjustPrivileges (HANDLE hToken)
{
	DWORD adjustedCount = 0;
	DWORD dwSize = sizeof (TOKEN_PRIVILEGES);
	TOKEN_PRIVILEGES *tp = (TOKEN_PRIVILEGES *) new BYTE [dwSize];
	DWORD dwRequiredSize = 0;
	DWORD dwLastError = 0;
	
	// Get privilege info
	bool gotInfo = false;

	if (0 ==  GetTokenInformation (hToken, TokenPrivileges, 
						(LPVOID) tp, dwSize, &dwRequiredSize))
	{
		dwSize = dwRequiredSize;
		dwRequiredSize = 0;

		// Reallocate
		delete [] tp;
		tp = (TOKEN_PRIVILEGES *) new BYTE [dwSize];

		if (tp)
		{
			if (!GetTokenInformation (hToken, TokenPrivileges, 
							(LPVOID) tp, dwSize, &dwRequiredSize))
				dwLastError = GetLastError ();
			else
				gotInfo = true;
		}
	}
	else
		gotInfo = true;

	if (gotInfo)
	{
		// Enable the bally lot of them
		for (DWORD i = 0; i < tp->PrivilegeCount; i++)
		{
			DWORD dwAttrib = tp->Privileges[i].Attributes;

			if (0 == (dwAttrib & SE_PRIVILEGE_ENABLED))
			{
				tp->Privileges[i].Attributes |= SE_PRIVILEGE_ENABLED;
				adjustedCount++;
			}
		}

		Logit(L"Enabled ");
		Logit(adjustedCount);
		Logit(L"	privileges\r\n");
	}

	// If we didn't make any changes, clean up now. Otherwise tp will be deleted by the caller
	if (0 == adjustedCount)
	{
		if (tp)
		{
			delete [] tp;
			tp = NULL;
		}
	}

	return tp;
}

bool CWmiSecurityHelper::DuplicateToken(
	HANDLE hToken, 
	HANDLE &hDupToken,
	SECURITY_IMPERSONATION_LEVEL &secImpLevel)
{
	bool result = false;

	// DuplicateTokenEx won't exist on Win9x, so we need
	// this palaver to get at it
	BOOL (STDAPICALLTYPE *pfnDuplicateTokenEx) (
		HANDLE, 
		DWORD, 
		LPSECURITY_ATTRIBUTES,
		SECURITY_IMPERSONATION_LEVEL, 
		TOKEN_TYPE,
		PHANDLE
	) = NULL; 

	TCHAR	dllName [] = _T("\\advapi32.dll");
	LPTSTR  pszSysDir = new TCHAR[ MAX_PATH + _tcslen (dllName) ];

	if (pszSysDir)
	{
		UINT    uSize = GetSystemDirectory(pszSysDir, MAX_PATH);
		
		if(uSize > MAX_PATH) {
			delete[] pszSysDir;
			pszSysDir = new TCHAR[ uSize + _tcslen (dllName) ];
        	
			if (pszSysDir)
				uSize = GetSystemDirectory(pszSysDir, uSize);
		}

		if (pszSysDir)
		{
			lstrcat (pszSysDir, dllName);
			HINSTANCE hAdvapi = LoadLibraryEx (pszSysDir, NULL, 0);
			
			if (hAdvapi)
			{
				(FARPROC&) pfnDuplicateTokenEx = GetProcAddress(hAdvapi, "DuplicateTokenEx");

				if (pfnDuplicateTokenEx && 
					pfnDuplicateTokenEx (
						hToken, 
						TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES|TOKEN_IMPERSONATE,
						NULL,
						secImpLevel,
						TokenImpersonation,
						&hDupToken))
				{
					result = true;
				}

				FreeLibrary (hAdvapi);
			}

			delete [] pszSysDir;
		}
	}
				
	return result;
}

STDMETHODIMP CWmiSecurityHelper::ResetSecurity(HANDLE hToken)
{
	CreateLogFile();
	Logit (L"\r\n\r\n>>Received ResetSecurity request<<\r\n\r\n");

	if (IsNT())
	{
		/* 
		 * Set the supplied token (which may be NULL) into
		 * the current thread.
		 */
		if (FALSE == SetThreadToken (NULL, hToken))
		{
			Logit(L"Failure to reset thread token");
		}
		else
		{
			Logit(L"Successfully set thread token");
		}

		if (hToken)
			CloseHandle (hToken);
	}

	CloseLogFile();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\managementeventargs.cs ===
using System;

namespace System.Management
{

internal class IdentifierChangedEventArgs : EventArgs
{
	internal IdentifierChangedEventArgs () {}
}

internal class InternalObjectPutEventArgs : EventArgs
{
	private ManagementPath path;

	internal InternalObjectPutEventArgs (ManagementPath path) 
	{
		this.path = path.Clone();
	}

	internal ManagementPath Path {
		get { return path; }
	}
}

	
/// <summary>
/// virtual base class for WMI event arguments
/// </summary>
public abstract class ManagementEventArgs : EventArgs
{
	private object context;

	/// <summary>
	/// Constructor. This is not callable directly by applications.
	/// </summary>
	/// <param name="context">The operation context which is echoed back
	/// from the operation which trigerred the event.</param>
	internal ManagementEventArgs (object context) {
		this.context = context;
	}

	/// <summary>
	/// The operation context which is echoed back
	/// from the operation which trigerred the event.
	/// </summary>
	public object Context { get { return context; } }
}

/// <summary>
/// The argument class for ObjectReady events.
/// </summary>
public class ObjectReadyEventArgs : ManagementEventArgs
{
	private ManagementBaseObject wmiObject;
    
	/// <summary>
	/// Constructor.
	/// </summary>
	/// <param name="context">The operation context which is echoed back
	/// from the operation which triggerred the event.</param>
	/// <param name="wmiObject">The newly arrived WmiObject.</param>
	internal ObjectReadyEventArgs (
					object context,
					ManagementBaseObject wmiObject
					) : base (context)
	{
		this.wmiObject = wmiObject;
	}

	/// <summary>
	///    <para>The Wmi object representing the newly returned object.</para>
	/// </summary>
	public ManagementBaseObject NewObject {
		get {
			return wmiObject;
		}
	}
}

/// <summary>
/// The argument class for Completed events.
/// </summary>
public class CompletedEventArgs : ManagementEventArgs
{
	private readonly int status;
	private readonly ManagementBaseObject wmiObject;

	/// <summary>
	/// Constructor.
	/// </summary>
	/// <param name="context">The operation context which is echoed back
	/// from the operation which trigerred the event.</param>
	/// <param name="status">The completion status of the operation.</param>
	/// <param name="wmiStatusObject">Additional status information
	/// encapsulated within a WmiObject. This may be null.</param>
	internal CompletedEventArgs (
					object context,
					int status,
					ManagementBaseObject wmiStatusObject
					) : base (context)
	{
		wmiObject = wmiStatusObject;
		this.status = status;
	}

	/// <summary>
	/// Additional status information
	/// encapsulated within a WmiObject. This may be null.
	/// </summary>
	public ManagementBaseObject StatusObject {
		get {
			return wmiObject;
		}
	}

	/// <summary>
	/// The completion status of the operation.
	/// </summary>
	public ManagementStatus Status {
		get {
			return (ManagementStatus) status;
		}
	}
}

/// <summary>
/// The argument class for ObjectPut events.
/// </summary>
public class ObjectPutEventArgs : ManagementEventArgs
{
	private ManagementPath wmiPath;
    
	/// <summary>
	/// Constructor
	/// </summary>
	/// <param name="context">The operation context which is echoed back
	/// from the operation which trigerred the event.</param>
	/// <param name="path">The WmiPath representing the identity of the
	/// object that has been put.</param>
	internal ObjectPutEventArgs (
					object context,
					ManagementPath path
					) : base (context)
	{
		wmiPath = path;
	}

	/// <summary>
	/// The ManagementPath representing the identity of the
	/// object that has been put.
	/// </summary>
	public ManagementPath Path {
		get {
			return wmiPath;
		}
	}
}

/// <summary>
/// The argument class for Progress events.
/// </summary>
public class ProgressEventArgs : ManagementEventArgs
{
	private int			upperBound;
	private int			current;
	private string		message;
    
	/// <summary>
	/// Constructor
	/// </summary>
	/// <param name="context">The operation context which is echoed back
	/// from the operation which trigerred the event.</param>
	/// <param name="upperBound">A quantity representing the total
	/// amount of work required to be done by the operation.</param>
	/// <param name="current">A quantity representing the current
	/// amount of work required to be done by the operation. This is
	/// always less than or equal to upperBound.</param>
	/// <param name="message">Optional additional information regarding
	/// operation progress.</param>
	internal ProgressEventArgs (
					object context,
					int upperBound,
					int current,
					string message
					) : base (context)
	{
		this.upperBound = upperBound;
		this.current = current;
		this.message = message;
	}

	/// <summary>
	/// A quantity representing the total
	/// amount of work required to be done by the operation.
	/// </summary>
	public int UpperBound {
		get {
			return upperBound;
		}
	}

	/// <summary>
	/// A quantity representing the current
	/// amount of work required to be done by the operation. This is
	/// always less than or equal to UpperBound.
	/// </summary>
	public int Current {
		get {
			return current;
		}
	}

	/// <summary>
	/// Optional additional information regarding operation progress.
	/// </summary>
	public string Message {
		get {
			return (null != message) ? message : String.Empty;
		}
	}
}

	/// <summary>
	///    The argument class for WMI event arrived events.
	/// </summary>
	public class EventArrivedEventArgs : ManagementEventArgs
	{
		private ManagementBaseObject eventObject;

		internal EventArrivedEventArgs (
					object context,
					ManagementBaseObject eventObject) : base (context)
		{
			this.eventObject = eventObject;
		}

		/// <summary>
		///    <para>The WMI event that was delivered.</para>
		/// </summary>
		public ManagementBaseObject NewEvent {
			get { return this.eventObject; }
		}
	}

	/// <summary>
	///    <para>The argument class for a 'stopped' event.</para>
	/// </summary>
	public class StoppedEventArgs : ManagementEventArgs
	{
		private int status;

		internal StoppedEventArgs (
					object context,
					int status) : base (context) 
		{
			this.status = status;
		}

		/// <summary>
		/// The completion status of the operation.
		/// </summary>
		public ManagementStatus Status {
			get {
				return (ManagementStatus) status;
			}
		}
	}

	

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\managementbaseobject.cs ===
using System.Collections;
using System.Diagnostics;
using System.Runtime.InteropServices;
using WbemClient_v1;
using System.ComponentModel;
using System.Runtime.Serialization;

namespace System.Management
{
	/// <summary>
	/// Possible text formats that can be used with ManagementBaseObject.GetText
	/// </summary>
	public enum TextFormat {
		/// <summary>
		/// Managed Object Format
		/// </summary>
		Mof
	};
		
	/// <summary>
	///    <para>Possible CIM types for properties, qualifiers or method parameters</para>
	/// </summary>
	public enum CimType 
	{
		/// <summary>
		///    Signed 8-bit integer
		/// </summary>
		SInt8 = 16,
        /// <summary>
        ///    <para>Unsigned 8-bit integer</para>
        /// </summary>
        UInt8 = 17,
        /// <summary>
        ///    <para>Signed 16-bit integer</para>
        /// </summary>
        SInt16 = 2,
        /// <summary>
        ///    <para>Unsigned 16-bit integer</para>
        /// </summary>
        UInt16 = 18,
        /// <summary>
        ///    <para>Signed 32-bit integer</para>
        /// </summary>
        SInt32 = 3,
        /// <summary>
        ///    <para>Unsigned 32-bit integer</para>
        /// </summary>
        UInt32 = 19,
        /// <summary>
        ///    <para>Signed 64-bit integer</para>
        /// </summary>
        SInt64 = 20,
        /// <summary>
        ///    <para>Unsigned 64-bit integer</para>
        /// </summary>
        UInt64 = 21,
        /// <summary>
        ///    <para>Floating-point 32-bit number</para>
        /// </summary>
        Real32 = 4,
        /// <summary>
        ///    <para>Floating point 64-bit number</para>
        /// </summary>
        Real64 = 5,
        /// <summary>
        ///    <para> Boolean</para>
        /// </summary>
        Boolean = 11,
        /// <summary>
        ///    String
        /// </summary>
        String = 8,
        /// <summary>
        ///    <para>DateTime - this is represented in a string in DMTF date/time format: 
        ///       yyyymmddHHMMSS.mmmmmmsUUU, where :</para>
        ///    <para>yyyymmdd - is the date in year/month/day</para>
        ///    <para>HHMMSS - is the time in hours/minutes/seconds</para>
        ///    <para>mmmmmm - 6 digits number of microseconds</para>
        ///    <para>sUUU - + or - and a 3 digit UTC offset</para>
        /// </summary>
        DateTime = 101,
        /// <summary>
        ///    <para>A reference to another object. This is represented by a 
        ///       string containing the path to the referenced object</para>
        /// </summary>
        Reference = 102,
        /// <summary>
        ///    <para> 16-bit character</para>
        /// </summary>
        Char16 = 103,
        /// <summary>
        ///    <para>An embedded object.</para>
        ///    <para>Note : embedded objects differ from references in that the embedded object 
        ///       doesn't have a path and it's lifetime is identical to the lifetime of the
        ///       containing object.</para>
        /// </summary>
        Object = 13,
	};

	/// <summary>
	/// Object comparison modes that can be used with ManagementBaseObject.CompareTo.
	/// Note that these values may be combined.
	/// </summary>
	[Flags]
	public enum ComparisonSettings
	{
	    /// <summary>
	    ///    Compare all elements of the compared objects.
	    /// </summary>
	    IncludeAll = 0,
		/// <summary>
		///    <para>Compare the objects ignoring qualifiers</para>
		/// </summary>
		IgnoreQualifiers = 0x1,
		/// <summary>
		///    The source of the objects, namely the server and the
		///    namespace they came from, are ignored in comparison to other objects.
		/// </summary>
		IgnoreObjectSource = 0x2,
		/// <summary>
		///    Default values of properties should be ignored.
		///    This value is only meaningful when comparing classes.
		/// </summary>
		IgnoreDefaultValues = 0x4,
		/// <summary>
		///    <para>Assumes that the objects being compared are instances of 
		///       the same class. Consequently, this value causes comparison
		///       of instance-related information only. Use this flag to optimize
		///       performance. If the objects are not of the same class, the results are undefined.</para>
		/// </summary>
		IgnoreClass = 0x8,
		/// <summary>
		///    Compares string values in a case-insensitive manner.
		///    This applies both to strings and to qualifier values. Property and qualifier
		///    names are always compared in a case-insensitive manner whether this flag is
		///    specified or not.
		/// </summary>
		IgnoreCase = 0x10,
		/// <summary>
		///    Ignore qualifier flavors. This flag still takes
		///    qualifier values into account, but ignores flavor distinctions such as
		///    propagation rules and override restrictions
		/// </summary>
		IgnoreFlavor = 0x20
	};
		
		
	internal enum QualifierType
	{
		ObjectQualifier,
		PropertyQualifier,
		MethodQualifier
	}


	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para>This class contains the basic elements of a management 
	///       object. It serves as a base class to more specific management object classes.</para>
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class ManagementBaseObject : Component, ICloneable, ISerializable
	{
		internal IWbemClassObjectFreeThreaded wbemObject;
		private PropertyDataCollection properties;
		private PropertyDataCollection systemProperties;
		private QualifierDataCollection qualifiers;
        protected ManagementBaseObject(SerializationInfo info, StreamingContext context)
        {
            wbemObject = info.GetValue("wbemObject", typeof(IWbemClassObjectFreeThreaded)) as IWbemClassObjectFreeThreaded;
            if(null == wbemObject)
                throw new SerializationException();
            properties = null;
            systemProperties = null;
            qualifiers = null;
        }

        void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue("wbemObject", wbemObject);
        }

		// Factory
		/// <summary>
		/// Factory for various types of base object
		/// </summary>
		/// <param name="wbemObject"> IWbemClassObject </param>
		/// <param name="scope"> The scope</param>
		internal static ManagementBaseObject GetBaseObject(
			IWbemClassObjectFreeThreaded wbemObject,
			ManagementScope scope) 
		{
			ManagementBaseObject newObject = null;

			if (_IsClass(wbemObject))
				newObject = ManagementClass.GetManagementClass(wbemObject, scope);
			else
				newObject = ManagementObject.GetManagementObject(wbemObject, scope);

			return newObject;
		}

		//Constructor
		internal ManagementBaseObject(IWbemClassObjectFreeThreaded wbemObject) 
		{
			this.wbemObject = wbemObject;
			properties = null;
			systemProperties = null;
			qualifiers = null;
		}

		/// <summary>
		///    <para>Provides a clone of the object</para>
		/// </summary>
		/// <returns>
		///    The new clone object
		/// </returns>
		public virtual Object Clone()
		{
			Initialize ();
			IWbemClassObjectFreeThreaded theClone = null;
			int status = (int)ManagementStatus.NoError;

			status = wbemObject.Clone_(out theClone);

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}

			return new ManagementBaseObject(theClone);
		}

		internal virtual void Initialize () {}

		//
		//Properties
		//

		/// <value>
		///    <para>A collection of property objects
		///       describing the properties of this management object</para>
		/// </value>
		/// <seealso cref='System.Management.PropertyData'/>
		/// <value>
		///    <para>A collection of property objects
		///       describing the properties of this management object</para>
		/// </value>
		/// <seealso cref='System.Management.PropertyData'/>
		/// <value>
		///  Collection of property/value pairs
		/// </value>
		public virtual PropertyDataCollection Properties {
			get { 
				Initialize ();

				if (properties == null)
					properties = new PropertyDataCollection(this, false);

				return properties;
			}
		}

		/// <value>
		///    <para>The collection of WMI system properties of this object (e.g. the class name,
		///       server &amp; namespace, etc). System property names in WMI start with "__".</para>
		/// </value>
		/// <seealso cref='System.Management.PropertyData'/>
		/// <value>
		///    <para>The collection of WMI system properties of this object (e.g. the class name,
		///       server &amp; namespace, etc). System property names in WMI start with "__".</para>
		/// </value>
		/// <seealso cref='System.Management.PropertyData'/>
		/// <value>
		/// Collection of system  properties and their values
		/// </value>
		public virtual PropertyDataCollection SystemProperties {
			get {
				Initialize ();

				if (systemProperties == null)
					systemProperties = new PropertyDataCollection(this, true);

				return systemProperties;
			}
		}

		/// <value>
		///    <para>The collection of qualifiers defined on this object.
		///       Each element in the collection is of type QualifierData and holds information such
		///       as the qualifier name, value &amp; flavor.</para>
		/// </value>
		/// <seealso cref='System.Management.QualifierData'/>
		/// <value>
		///    <para>The collection of qualifiers defined on this object.
		///       Each element in the collection is of type QualifierData and holds information such
		///       as the qualifier name, value &amp; flavor.</para>
		/// </value>
		/// <seealso cref='System.Management.QualifierData'/>
		/// <value>
		/// Collection of qualifiers and their values
		/// </value>
		public virtual QualifierDataCollection Qualifiers {
			get { 
				Initialize ();

				if (qualifiers == null)
					qualifiers = new QualifierDataCollection(this);

				return qualifiers;
			}
		}

		/// <value>
		///    <para>The path to this object's class</para>
		/// </value>
		/// <example>
		///    For example, for the \\MyBox\root\cimv2:Win32_LogicalDisk='C:'
		///    object, the class path will be \\MyBox\root\cimv2:Win32_LogicalDisk.
		/// </example>
		/// <value>
		/// The path to this object's class
		/// </value>
		public virtual ManagementPath ClassPath { 
			get { 
				Object serverName = null;
				Object scopeName = null;
				Object className = null;
				int propertyType = 0;
				int propertyFlavor = 0;
				int status = (int)ManagementStatus.NoError;

				Initialize();

				status = wbemObject.Get_("__SERVER", 0, ref serverName, ref propertyType, ref propertyFlavor);
				
				if (status == (int)ManagementStatus.NoError)
				{
					status = wbemObject.Get_("__NAMESPACE", 0, ref scopeName, ref propertyType, ref propertyFlavor);

					if (status == (int)ManagementStatus.NoError)
						status = wbemObject.Get_("__CLASS", 0, ref className, ref propertyType, ref propertyFlavor);
				}

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				ManagementPath classPath = new ManagementPath();

				// Some of these may throw if they are NULL
				try {
					classPath.Server = (string)serverName;
					classPath.NamespacePath = (string)scopeName;
					classPath.ClassName = (string)className;
				} catch (Exception) {}

				return classPath;
            } 
		}


		//
		//Methods
		//

		//******************************************************
		//[] operator by property name
		//******************************************************
		/// <summary>
		/// Allows access to property values through [] notation
		/// </summary>
		/// <param name="propertyName"> The name of the property of interest </param>
		public Object this[string propertyName] { 
			get { return GetPropertyValue(propertyName); }
			set { 
				Initialize ();
				try {
					SetPropertyValue (propertyName, value);
				}
				catch (Exception e) {
					ManagementException.ThrowWithExtendedInfo(e);
				}
			}
		}
		
		//******************************************************
		//GetPropertyValue
		//******************************************************
		/// <summary>
		///    <para>Equivalent accessor to [] to a property's value</para>
		/// </summary>
		/// <param name='propertyName'>The name of the property of interest </param>
		/// <returns>
		///    The value of the specified property.
		/// </returns>
		public Object GetPropertyValue(string propertyName)
		{ 
			if (null == propertyName)
				throw new ArgumentNullException ("propertyName");

			// Check for system properties
			if (propertyName.StartsWith ("__"))
				return SystemProperties[propertyName].Value;
			else
				return Properties[propertyName].Value;
		}

		//******************************************************
		//GetQualifierValue
		//******************************************************
		/// <summary>
		///    <para>Gets the value of the specified qualifier</para>
		/// </summary>
		/// <param name='qualifierName'>The name of the qualifier of interest </param>
		/// <returns>
		///    The value of the specified qualifier
		/// </returns>
		public Object GetQualifierValue(string qualifierName)
		{
			return Qualifiers [qualifierName].Value;
		}

		//******************************************************
		//SetQualifierValue
		//******************************************************
		/// <summary>
		/// Set the value of the named qualifier
		/// </summary>
		/// <param name="qualifierName">Name of qualifier to set, which cannot be null</param>
		/// <param name="qualifierValue">Value to set</param>
		public void SetQualifierValue(string qualifierName, object qualifierValue)
		{
			Qualifiers [qualifierName].Value = qualifierValue;
		}
			
		
		//******************************************************
		//GetPropertyQualifierValue
		//******************************************************
		/// <summary>
		///    <para>Returns the value of the specified property qualifier</para>
		/// </summary>
		/// <param name='propertyName'>The name of the property that the qualifier belongs to </param>
		/// <param name='qualifierName'>The name of the property qualifier of interest </param>
		/// <returns>
		///    The value of the specified qualifier.
		/// </returns>
		public Object GetPropertyQualifierValue(string propertyName, string qualifierName)
		{
			return Properties[propertyName].Qualifiers[qualifierName].Value;
		}

		//******************************************************
		//SetPropertyQualifierValue
		//******************************************************
		/// <summary>
		///	Sets the value of the specified property qualifier
		/// </summary>
		/// <param name="propertyName"> The name of the property that the qualifier belongs to </param>
		/// <param name="qualifierName"> The name of the property qualifier of interest </param>
		/// <param name="qualifierValue"> The new value for the qualifier </param>
		public void SetPropertyQualifierValue(string propertyName, string qualifierName,
			object qualifierValue)
		{
			Properties[propertyName].Qualifiers[qualifierName].Value = qualifierValue;
		}

		//******************************************************
		//GetText
		//******************************************************
		/// <summary>
		///    <para>Returns a textual representation of the object in the specified format.</para>
		/// </summary>
		/// <param name='format'>Specifies the requested textual format </param>
		/// <returns>
		///    The textual representation of the
		///    object in the specified format.
		/// </returns>
		/// <remarks>
		///    Currently the only format that WMI supports
		///    is MOF (Managed Object Format). However, in the future different other formats
		///    will be plugged in, such as XML.
		/// </remarks>
		// TODO: What's the relationship to ISerializable if any ?
		public string GetText(TextFormat format)
		{
			Initialize ();
			switch(format)
			{
				case TextFormat.Mof :
					string objText = null;
					int status = (int)ManagementStatus.NoError;

					status = wbemObject.GetObjectText_(0, out objText);

					if (status < 0)
					{
						if ((status & 0xfffff000) == 0x80041000)
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
						else
							Marshal.ThrowExceptionForHR(status);
					}

					return objText;

				default : 
					// TODO - integrate support for XML formats if we
					// can rely on Whistler IWbemObjectTextSrc
					return null;
			}
		}

		/// <nodoc/>
		/// <summary>
		///    <para>[To be supplied.]</para>
		/// </summary>
		public override int GetHashCode ()
		{
			// If all else fails, use the default implementation
			int result = base.GetHashCode ();

			try {
				// Use the hash of the class name
				result = ClassName.GetHashCode ();
			}
			catch(Exception e) {
				ManagementException.ThrowWithExtendedInfo(e);
			}

			return result;				
		}

		/// <nodoc/>
		/// <summary>
		///    <para>[To be supplied.]</para>
		/// </summary>
		public override bool Equals(object obj)
		{
			bool result = false;
			
			// We catch a possible cast exception here
			try {
				Initialize ();
				result = CompareTo ((ManagementBaseObject)obj, ComparisonSettings.IncludeAll);
			} catch {}

			return result;
		}

		//******************************************************
		//CompareTo
		//******************************************************
		/// <summary>
		///    <para>Compares this object to another, based on specified options</para>
		/// </summary>
		/// <param name='otherObject'>The object to compare to </param>
		/// <param name='settings'>Options on how to compare the objects </param>
		/// <returns>
		///    TRUE if the objects compared are equal
		///    according to the give options, FALSE otherwise.
		/// </returns>
		public bool CompareTo(ManagementBaseObject otherObject, ComparisonSettings settings)
		{
			if (null == otherObject)
				throw new ArgumentNullException ("otherObject");

			Initialize ();
			bool result = false;

			if (null != wbemObject)
			{
				int status = (int) ManagementStatus.NoError;

				otherObject.Initialize();

				status = wbemObject.CompareTo_((int) settings, otherObject.wbemObject);

				if ((int)ManagementStatus.Different == status)
					result = false;
				else if ((int)ManagementStatus.NoError == status)
					result = true;
				else if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else if (status < 0)
					Marshal.ThrowExceptionForHR(status);
			}
			
			return result;
		}

		internal string ClassName
		{
			get {
				Initialize ();
				object val = null;
				int dummy1 = 0, dummy2 = 0;
				int status = (int)ManagementStatus.NoError;

				status = wbemObject.Get_ ("__CLASS", 0, ref val, ref dummy1, ref dummy2);

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				if (val is System.DBNull)
					return String.Empty;
				else
					return ((string) val);
			}
		}

		internal IWbemClassObjectFreeThreaded WmiObject {
			get { 
				Initialize ();
				return wbemObject; 
			}
            set { 
				Initialize ();
				wbemObject = value; 
			}
		}

		private static bool _IsClass(IWbemClassObjectFreeThreaded wbemObject)
		{
			object val = null;
			int dummy1 = 0, dummy2 = 0;

			int status = wbemObject.Get_("__GENUS", 0, ref val, ref dummy1, ref dummy2);

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}
			
			return ((int)val == (int)tag_WBEM_GENUS_TYPE.WBEM_GENUS_CLASS);
		}

		internal bool IsClass
		{
			get {
				Initialize ();
				return _IsClass(wbemObject);
			}
		}

		/// <summary>
		///    <para>Set the value of the named property</para>
		/// </summary>
		/// <param name='propertyName'>The name of the property to be changed</param>
		/// <param name='propertyValue'>The new value for this property</param>
		public void SetPropertyValue (
			string propertyName,
			object propertyValue)
		{
			if (null == propertyName)
				throw new ArgumentNullException ("propertyName");

			// Check for system properties
			if (propertyName.StartsWith ("__"))
				SystemProperties[propertyName].Value = propertyValue;
			else
				Properties[propertyName].Value = propertyValue;
		}
		
	}//ManagementBaseObject
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\managementclass.cs ===
using System;
using System.Collections.Specialized;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using WbemClient_v1;
using System.CodeDom;

namespace System.Management
{
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	/// This class represents a basic management object
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class ManagementClass : ManagementObject
	{
		private MethodDataCollection methods;

		/// <summary>
		/// Internal factory for classes, used when deriving a class
		/// or cloning a class. For these purposes we always mark
		/// the class as "bound".
		/// </summary>
		/// <param name="wbemObject">The underlying WMI object</param>
		/// <param name="mgObj">Seed class from which we will get initialization info</param>
		internal static ManagementClass GetManagementClass(
			IWbemClassObjectFreeThreaded wbemObject,
			ManagementClass mgObj) 
		{ 
			ManagementClass newClass = new ManagementClass();
			newClass.wbemObject = wbemObject;

			if (null != mgObj)
			{
				newClass.Scope = mgObj.Scope;

				ManagementPath objPath = mgObj.Path;

				if (null != objPath)
					newClass.Path = objPath;

				// Ensure we have our class name in the path
				object className = null;
				int dummy = 0;

				int status = wbemObject.Get_("__CLASS", 0, ref className, ref dummy, ref dummy);

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				if (className != System.DBNull.Value)
					newClass.Path.ClassName = (string)className;

				ObjectGetOptions options = mgObj.Options;
				if (null != options)
					newClass.Options = options;

				/*
				 * Finally we ensure that this object is marked as bound.
				 * We do this as a last step since setting certain properties
				 * (Options, Path and Scope) would mark it as unbound
				 */
				newClass.IsBound = true;
			}

			return newClass;
		}

		internal static ManagementClass GetManagementClass(
			IWbemClassObjectFreeThreaded wbemObject,
			ManagementScope scope) 
		{
			ManagementClass newClass = new ManagementClass();
			newClass.Path = ManagementPath.GetManagementPath(wbemObject);

			if (null != scope)
				newClass.Scope = scope;
			return newClass;
		}

		//default constructor
		/// <summary>
		///    Default constructor creates an uninitialized
		///    ManagementClass object.
		/// </summary>
		/// <example>
		///    ManagementClass c = new ManagementClass();
		/// </example>
		public ManagementClass() : this ((ManagementScope)null, (ManagementPath)null, null) {}

		//parameterized constructors
		/// <summary>
		///    <para>Creates a new ManagementClass object initialized to the
		///       given path.</para>
		/// </summary>
		/// <param name='path'>A ManagementPath specifying the WMI class to bind to.</param>
		/// <remarks>
		///    <para>The path parameter must specify a WMI class
		///       path.</para>
		/// </remarks>
		/// <example>
		///    <para>ManagementClass c = new ManagementClass(new
		///       ManagementPath("Win32_LogicalDisk"));</para>
		/// </example>
		public ManagementClass(ManagementPath path) : this(null, path, null) {}
		/// <summary>
		///    <para>Creates a new ManagementClass object initialized to the given path.</para>
		/// </summary>
		/// <param name='path'>A string representing the path to the WMI class</param>
		/// <example>
		///    ManagementClass c = new
		///    ManagementClass("Win32_LogicalDisk");
		/// </example>
		public ManagementClass(string path) : this(null, new ManagementPath(path), null) {}
		/// <summary>
		///    <para>Creates a new ManagementClass object initialized to the
		///       given WMI class path, using the specified options.</para>
		/// </summary>
		/// <param name='path'>A ManagementPath representing the WMI class path.</param>
		/// <param name=' options'>An ObjectGetOptions object representing the options to be used when getting this class.</param>
		/// <example>
		///    <para>ManagementPath p = new ManagementPath("Win32_Process");</para>
		///    <para>ObjectGetOptions o = new ObjectGetOptions(null, true); //Specifies we want 
		///       amended qualifiers on the class</para>
		///    <para>ManagementClass c = new ManagementClass(p,o);</para>
		/// </example>
		public ManagementClass(ManagementPath path, ObjectGetOptions options) : this(null, path, options) {}
		/// <summary>
		///    <para>Creates a new ManagementClass object initialized to the given WMI class path, 
		///       using the specified options.</para>
		/// </summary>
		/// <param name='path'>A string representing the path to the WMI class</param>
		/// <param name=' options'>An ObjectGetOptions object representing the options to be used when getting the WMI class.</param>
		/// <example>
		///    <para>ObjectGetOptions o = new ObjectGetOptions(null, true); //Specifies we want 
		///       amended qualifiers on the class</para>
		///    <para>ManagementClass c = new ManagementClass("Win32_ComputerSystem",o);</para>
		/// </example>
		public ManagementClass(string path, ObjectGetOptions options) 
			: this(null, new ManagementPath(path), options) {}
		/// <summary>
		///    <para>Creates a new ManagementClass object for the specified
		///       WMI class in the specified scope and with the specified options.</para>
		/// </summary>
		/// <param name='scope'>A ManagementScope object specifying the scope (server &amp; namespace) where the WMI class resides. </param>
		/// <param name=' path'>A ManagementPath object representing the path to the WMI class in the specified scope.</param>
		/// <param name=' options'>An ObjectGetOptions object specifying the options to be used when retrieving the WMI class.</param>
		/// <remarks>
		///    The path can be specified as a full path
		///    (including server &amp; namespace). However if a scope is specified it will
		///    override the first portion of the full path.
		/// </remarks>
		/// <example>
		///    <p>ManagementScope s = new
		///       ManagementScope(\\\\MyBox\\root\\cimv2);</p>
		///    <p>ManagementPath p = new ManagementPath("Win32_Environment");</p>
		///    <p>ObjectGetOptions o = new ObjectGetOptions(null, true);</p>
		///    <p>ManagementClass c = new ManagementClass(s, p, o);</p>
		/// </example>

		public ManagementClass(ManagementScope scope, ManagementPath path, ObjectGetOptions options)
			: base (scope, path, options)
		{
			CheckPathAfterBaseConstructor();
		}

		/// <summary>
		///    <para>Creates a new ManagementClass object for the specified WMI class in the 
		///       specified scope and with the specified options.</para>
		/// </summary>
		/// <param name='scope'>A string representing the scope in which the WMI class resides</param>
		/// <param name=' path'>A string representing the path to the WMI class within the specified scope</param>
		/// <param name=' options'>The options to be used when retrieving the WMI class.</param>
		/// <remarks>
		///    <para>The path can be specified as a full path
		///       (including server &amp; namespace). However if a scope is specified it will
		///       override the first portion of the full path.</para>
		/// </remarks>
		/// <example>
		///    <para>ManagementClass c = new ManagementClass(\\\\MyBox\\root\\cimv2, 
		///       "Win32_Environment", new ObjectGetOptions(null, true));</para>
		/// </example>
		public ManagementClass(string scope, string path, ObjectGetOptions options)
			: base (new ManagementScope(scope), new ManagementPath(path), options) 
		{
			CheckPathAfterBaseConstructor();
		}

        ManagementClass(SerializationInfo info, StreamingContext context) : base(info, context)
        {
            CheckPathAfterBaseConstructor();
        }

		private void CheckPathAfterBaseConstructor()
		{
			// If not empty, this should be a path to a class
			ManagementPath assignedPath = Path;
			if (!assignedPath.IsEmpty && !assignedPath.IsClass)
				throw new ArgumentOutOfRangeException("path");	
		}

		/// <summary>
		///    Specifies the path of the WMI class this ManagementClass
		///    object is bound to.
		/// </summary>
		/// <remarks>
		///    When this property is set to a new value,
		///    the ManagementClass object will be disconnected from any previously bound WMI
		///    class, and at first need re-connected to the newly specified WMI class path.
		/// </remarks>
		/// <example>
		///    ManagementClass c = new ManagementClass();
		///    c.Path = "Win32_Environment";
		/// </example>
		public override ManagementPath Path {
			get {
				return base.Path;
			}
			set {
				// This must be a class path or empty (don't allow instance paths)
				if ((null == value) || value.IsClass || value.IsEmpty)
					base.Path = value;
				else
					throw new ArgumentOutOfRangeException();
			}
		}
				
		/// <summary>
		///    <para>An array containing all classes up the inheritance hierarchy from this class 
		///       to the top.</para>
		/// </summary>
		/// <remarks>
		///    This property is read-only.
		/// </remarks>
		/// <example>
		///    <p>ManagementClass c = new ManagementClass("Win32_LogicalDisk");</p>
		///    <p>foreach (string s in c.Derivation)</p>
		///    <p>Console.WriteLine("Further derived from : ", s);</p>
		/// </example>
		public StringCollection Derivation { 
			get { 
				StringCollection result = new StringCollection();

				Initialize();
				int dummy1 = 0, dummy2 = 0;
				object val = null;

				int status = wbemObject.Get_("__DERIVATION", 0, ref val, ref dummy1, ref dummy2);
				
				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				if (null != val)
					result.AddRange((String [])val);

				return result; 
			} 
		}


		/// <summary>
		///    <para>A collection of Method objects,
		///       representing the methods defined on this WMI class.</para>
		/// </summary>
		/// <example>
		///    <p>ManagementClass c = new ManagementClass("Win32_Process");</p>
		///    <p>foreach (Method m in c.Methods)</p>
		///    <p>Console.WriteLine("This class contains this method : ",
		///       m.Name);</p>
		/// </example>
		/// <value>
		/// The path of this object's class
		/// </value>
		public MethodDataCollection Methods { 
			get {
				Initialize();

				if (methods == null)
					methods = new MethodDataCollection(this);

				return methods;
			}
		}

		//
		//Methods
		//

		//******************************************************
		//GetInstances
		//******************************************************
		/// <summary>
		///    <para>Returns the collection of all instances of this class</para>
		/// </summary>
		/// <returns>
		///    A collection of ManagementObjects
		///    representing the instances of this class.
		/// </returns>
		/// <example>
		///    <para>ManagementClass c = new ManagementClass("Win32_Process");
		///       foreach (ManagementObject o in c.GetInstances())
		///       Console.WriteLine("Next instance of Win32_Process : ",
		///       o.Path);</para>
		/// </example>
		public ManagementObjectCollection GetInstances()
		{
			return GetInstances((EnumerationOptions)null);
		}

		
		/// <summary>
		///    <para>Returns the collection of all instances of this class, using the specified options</para>
		/// </summary>
		/// <param name='options'>Additional operation options</param>
		/// <returns>
		///    A collection of ManagementObjects
		///    representing the instances of this class, according to the specified options.
		/// </returns>
		/// <example>
		///    <p>GetInstancesOptions opt = new GetInstancesOptions();</p>
		///    <p>o.enumerateDeep = true; //will enumerate instances of the given class and
		///       any subclasses.</p>
		///    <p>foreach (ManagementObject o in new
		///       ManagementClass("CIM_Service").GetInstances(opt))</p>
		///    <p>Console.WriteLine(o["Name"]);</p>
		/// </example>
		public ManagementObjectCollection GetInstances(EnumerationOptions options) 
		{
			if ((null == Path) || (String.Empty == Path.Path))
				throw new InvalidOperationException();

			Initialize();
			IEnumWbemClassObject enumWbem = null;

			EnumerationOptions o = (null == options) ? new EnumerationOptions() : (EnumerationOptions)options.Clone();
			//Need to make sure that we're not passing invalid flags to enumeration APIs.
			//The only flags in EnumerationOptions not valid for enumerations are EnsureLocatable & PrototypeOnly.
			o.EnsureLocatable = false; o.PrototypeOnly = false;

			SecurityHandler securityHandler	= null;
			int status						= (int)ManagementStatus.NoError;

			try
			{
				securityHandler = Scope.GetSecurityHandler();

				status = Scope.GetIWbemServices().CreateInstanceEnum_(
															ClassName, 
															o.Flags, 
															o.GetContext(),
															out enumWbem);

				if (status >= 0)
					securityHandler.Secure(enumWbem);
			}
			finally
			{
				if (securityHandler != null)
					securityHandler.Reset();
			}

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}

			return new ManagementObjectCollection(Scope, o, enumWbem);
		}

		/// <summary>
		///    <para>Returns the collection of all instances of this class, asynchronously</para>
		/// </summary>
		/// <param name='watcher'>The object to handle the asynchronous operation's progress</param>
		/// <example>
		///    <p>ManagementClass c = new ManagementClass("Win32_Share");</p>
		///    <p>MyHandler h = new MyHandler();</p>
		///    <p>ManagementOperationObserver ob = new ManagementOperationObserver();</p>
		///    <p>ob.ObjectReady += new ObjectReadyEventHandler (h.NewObject);</p>
		///    <p>ob.Completed += new CompletedEventHandler (h.Done);</p>
		///    <p>c.GetInstances(ob);</p>
		///    <p>while (!h.Completed)</p>
		///    <p> System.Threading.Thread.Sleep (1000);</p>
		///    <p>//Here we can use the object</p>
		///    <p>Console.WriteLine(o["SomeProperty"]);</p>
		///    <p> </p>
		///    <para>public class MyHandler</para>
		///    <p>{</p>
		///    <p> private bool completed = false;</p>
		///    <p> public void NewObject(object sender, ObjectReadyEventArgs e)</p>
		///    <p> {</p>
		///    <p> 
		///       Console.WriteLine("New result arrived !", ((ManagementObject)(e.NewObject))["Name"]);</p>
		///    <p> }</p>
		///    <p> public void Done(object sender, CompletedEventArgs e)</p>
		///    <p> {</p>
		///    <p> 
		///       Console.WriteLine("async Get completed !");</p>
		///    <p> completed = true;</p>
		///    <p> }</p>
		///    <p> public bool Completed { </p>
		///    <p> get {return completed;}</p>
		///    <p> }</p>
		/// </example>
		public void GetInstances(ManagementOperationObserver watcher) 
		{
			GetInstances(watcher, (EnumerationOptions)null);
		}
		

		/// <summary>
		///    <para>Returns the collection of all instances of this class, asynchronously, using 
		///       the specified options</para>
		/// </summary>
		/// <param name='watcher'>The handler for progress of the asynchronous operation</param>
		/// <param name=' options'>Specify additional options for getting the instances.</param>
		public void GetInstances(ManagementOperationObserver watcher, EnumerationOptions options) 
		{
			if (null == watcher)
				throw new ArgumentNullException("watcher");
			
			if ((null ==Path) || (String.Empty == Path.Path))
				throw new InvalidOperationException();

			Initialize();
			WmiEventSink sink = watcher.GetNewSink(Scope, null);

			EnumerationOptions o = (null == options) ? new EnumerationOptions() : (EnumerationOptions)options.Clone();
			//Need to make sure that we're not passing invalid flags to enumeration APIs.
			//The only flags in EnumerationOptions not valid for enumerations are EnsureLocatable & PrototypeOnly.
			o.EnsureLocatable = false; o.PrototypeOnly = false;
			
			// Ensure we switch off ReturnImmediately as this is invalid for async calls
			o.ReturnImmediately = false;

			// If someone has registered for progress, make sure we flag it
			if (watcher.HaveListenersForProgress)
				o.SendStatus = true;
						
			SecurityHandler securityHandler	= null;
			int status						= (int)ManagementStatus.NoError;

			try
			{
				securityHandler = Scope.GetSecurityHandler();

				status = Scope.GetIWbemServices().CreateInstanceEnumAsync_(
					ClassName,
					o.Flags,
					o.GetContext(),
					sink.Stub);
			}
			finally
			{
				watcher.RemoveSink(sink);
				if (securityHandler != null)
					securityHandler.Reset();
			}

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}
		}

		//******************************************************
		//GetSubclasses
		//******************************************************
		/// <summary>
		///    <para>Returns the collection of all subclasses of this class</para>
		/// </summary>
		/// <returns>
		///    A collection of ManagementObjects
		///    representing the subclasses of this WMI class.
		/// </returns>
		public ManagementObjectCollection GetSubclasses()
		{
			return GetSubclasses((EnumerationOptions)null);
		}
		
		
		/// <summary>
		///    <para>Gets the subclasses of this class, using the specified
		///       options.</para>
		/// </summary>
		/// <param name='options'>GetSubclassesOptions specify additional options for getting subclasses of this class.</param>
		/// <returns>
		///    A collection of ManagementObjects
		///    representing the subclasses of this WMI class, according to the specified
		///    options.
		/// </returns>
		/// <example>
		///    <p>GetSubclassesOptions opt = new GetSubclassesOptions();</p>
		///    <p>opt.enumerateDeep = true; //Causes return of deep subclasses as opposed to
		///       only immediate ones.</p>
		///    <p>ManagementObjectCollection c = (new
		///       ManagementClass("Win32_Share")).GetSubclasses(opt);</p>
		/// </example>
		public ManagementObjectCollection GetSubclasses(EnumerationOptions options) 
		{ 
			if (null == Path)
				throw new InvalidOperationException();

			Initialize();
			IEnumWbemClassObject enumWbem = null;

			EnumerationOptions o = (null == options) ? new EnumerationOptions() : (EnumerationOptions)options.Clone();
			//Need to make sure that we're not passing invalid flags to enumeration APIs.
			//The only flags in EnumerationOptions not valid for enumerations are EnsureLocatable & PrototypeOnly.
			o.EnsureLocatable = false; o.PrototypeOnly = false;

			SecurityHandler securityHandler = null;
			int status						= (int)ManagementStatus.NoError;

			try
			{
				securityHandler = Scope.GetSecurityHandler();

				status = Scope.GetIWbemServices().CreateClassEnum_(
					ClassName, 
					o.Flags, 
					o.GetContext(),
					out enumWbem);

				if (status >= 0)
					securityHandler.Secure(enumWbem);
			}
			finally
			{
				if (securityHandler != null)
					securityHandler.Reset();
			}

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}

			return new ManagementObjectCollection(Scope, o, enumWbem);
		}

		/// <summary>
		///    <para>Returns the collection of all subclasses of this class, asynchronously.</para>
		/// </summary>
		/// <param name='watcher'>Object that handles progress and results of the asynchronous operation</param>
		public void GetSubclasses(ManagementOperationObserver watcher) 
		{ 
			GetSubclasses(watcher, (EnumerationOptions)null);
		}


		/// <summary>
		///    <para>Gets the subclasses of this class, asynchronously, using the specified 
		///       options.</para>
		/// </summary>
		/// <param name='watcher'>Object that handles progress and results of the asynchronous operation</param>
		/// <param name=' options'>Specifies additional options to be used in subclass retrieval</param>
		public void GetSubclasses(ManagementOperationObserver watcher,
										EnumerationOptions options) 
		{ 				
			if (null == watcher)
				throw new ArgumentNullException("watcher");
			
			if (null == Path)
				throw new InvalidOperationException();

			Initialize();
			WmiEventSink sink = watcher.GetNewSink(Scope, null);

			EnumerationOptions o = (null == options) ? new EnumerationOptions() : 
									  (EnumerationOptions)options.Clone();

			//Need to make sure that we're not passing invalid flags to enumeration APIs.
			//The only flags in EnumerationOptions not valid for enumerations are EnsureLocatable & PrototypeOnly.
			o.EnsureLocatable = false; o.PrototypeOnly = false;

			// Ensure we switch off ReturnImmediately as this is invalid for async calls
			o.ReturnImmediately = false;

			// If someone has registered for progress, make sure we flag it
			if (watcher.HaveListenersForProgress)
				o.SendStatus = true;

			SecurityHandler securityHandler = null;
			int status						= (int)ManagementStatus.NoError;

			try
			{
				securityHandler = Scope.GetSecurityHandler();

				status = Scope.GetIWbemServices().CreateClassEnumAsync_(
					ClassName,
					o.Flags,
					o.GetContext(),
					sink.Stub);
			}
			finally
			{
				watcher.RemoveSink(sink);
				if (securityHandler != null)
					securityHandler.Reset();
			}

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}
		}

		//******************************************************
		//Derive
		//******************************************************
		/// <summary>
		///    <para>Derives a new class from this class</para>
		/// </summary>
		/// <param name='newClassName'>Specifies the name of the new class to be derived</param>
		/// <returns>
		///    <para>A new ManagementClass object
		///       representing a newly created WMI class derived from the original class.</para>
		/// </returns>
		/// <remarks>
		///    <para>Note that the newly returned class has not
		///       been committed until the Put() method is explicitly called.</para>
		/// </remarks>
		/// <example>
		///    <p>ManagementClass existingClass = new ManagementClass("CIM_Service");</p>
		///    <p>ManagementClass newClass = existingClass.Derive("My_Service");</p>
		///    <p>newClass.Put(); //to commit the new class to the WMI repository.</p>
		/// </example>
		public ManagementClass Derive(string newClassName)
		{
			ManagementClass newClass = null;

			if (null == newClassName)
				throw new ArgumentNullException("newClassName");
			else 
			{
				// Check the path is valid
				ManagementPath path = new ManagementPath();

				try
				{
					path.ClassName = newClassName;
				}
				catch (Exception)
				{
					throw new ArgumentOutOfRangeException("newClassName");
				}

				if (!path.IsClass)
					throw new ArgumentOutOfRangeException("newClassName");
			}

			if (PutButNotGot)
			{
				//Path = new ManagementPath(putPath);
				Get();
				PutButNotGot = false;
			}
				
			Initialize();

			IWbemClassObjectFreeThreaded newWbemClass = null;
			int status = this.wbemObject.SpawnDerivedClass_(0, out newWbemClass);
				
			if (status >= 0)
			{
				object val = newClassName;
				status = newWbemClass.Put_("__CLASS", 0, ref val, 0);
					
				if (status >= 0)
					newClass = ManagementClass.GetManagementClass(newWbemClass, this);
			} 

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}

			return newClass;
		}

		//******************************************************
		//CreateInstance
		//******************************************************
		/// <summary>
		///    <para>Creates a new instance of this WMI class</para>
		/// </summary>
		/// <returns>
		///    <para>A ManagementObject representing a new
		///       instance of this WMI class.</para>
		/// </returns>
		/// <remarks>
		///    <para>Note the new instance is not committed
		///       until the Put() method is called. Before committing it the key properties must
		///       be specified.</para>
		/// </remarks>
		/// <example>
		///    <para>ManagementClass envClass = new ManagementClass("Win32_Environment");</para>
		///    <para>ManagementObject newInstance = 
		///       existingClass.CreateInstance("My_Service");</para>
		///    <para>newInstance["Name"] = "cori";</para>
		///    <para>newInstance.Put(); //to commit the new instance.</para>
		/// </example>
		public ManagementObject CreateInstance()
		{
			ManagementObject newInstance = null;

			if (PutButNotGot)
			{
				//Path = new ManagementPath(putPath);
				Get();
				PutButNotGot = false;
			}

			Initialize();

			IWbemClassObjectFreeThreaded newWbemInstance = null;
			int status = this.wbemObject.SpawnInstance_(0, out newWbemInstance);

			if (status >= 0)
				newInstance = ManagementObject.GetManagementObject(newWbemInstance, Scope);

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}

			return newInstance;
		}

		/// <summary>
		///    Creates a copy of this ManagementClass object.
		/// </summary>
		/// <returns>
		///    A new copy of the ManagementClass
		///    object.
		/// </returns>
		/// <remarks>
		///    Note this does not create a copy of the WMI
		///    class, rather only an additional representation for it.
		/// </remarks>
		public override Object Clone()
		{
			Initialize();
			
			IWbemClassObjectFreeThreaded theClone = null;
			int status = wbemObject.Clone_(out theClone);

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}

			return ManagementClass.GetManagementClass(theClone, this);
		}


		//******************************************************
		//GetRelatedClasses
		//******************************************************
		/// <summary>
		///    <para>Gets all classes related to this WMI class in the WMI schema</para>
		/// </summary>
		/// <returns>
		///    <para>A collection of ManagementClass or
		///       ManagementObject objects representing WMI classes and/or instances related to
		///       this WMI class.</para>
		/// </returns>
		/// <remarks>
		///    <para>This function queries the WMI schema for
		///       all possible associations this WMI class may have to other classes (or in rare
		///       cases to instances).</para>
		/// </remarks>
		/// <example>
		///    <para>ManagementClass c = new ManagementClass("Win32_LogicalDisk");
		///       foreach (ManagementClass r in c.GetRelatedClasses())
		///       Console.WriteLine("Instances of {0} may have
		///       relationships to this class", r["__CLASS"]);</para>
		/// </example>
		public ManagementObjectCollection GetRelatedClasses()
		{
			return GetRelatedClasses((string)null);
		}

		/// <summary>
		///    <para>Gets all classes related to this WMI class in the WMI schema</para>
		/// </summary>
		public ManagementObjectCollection GetRelatedClasses(
			string relatedClass) 
		{ 
			return GetRelatedClasses(relatedClass, null, null, null, null, null, null); 
		}

	
		/// <summary>
		///    <para>Gets all classes related to this WMI class based on the specified 
		///       options.</para>
		/// </summary>
		/// <param name='options'>Specify options for retrieving related classes.</param>
		/// <returns>
		///    A collection of classes related to
		///    this class in the WMI schema.
		/// </returns>
		public ManagementObjectCollection GetRelatedClasses(
											string relatedClass,
											string relationshipClass,
											string relationshipQualifier,
											string relatedQualifier,
											string relatedRole,
											string thisRole,
											EnumerationOptions options)
		{
			if ((null == Path) || (String.Empty == Path.Path))
				throw new InvalidOperationException();

			Initialize(); // this may throw

			IEnumWbemClassObject enumWbem = null;

			EnumerationOptions o = (null != options) ? (EnumerationOptions)options.Clone() : new EnumerationOptions();
			//Ensure EnumerateDeep flag bit is turned off as it's invalid for queries
			o.EnumerateDeep = true;

			RelatedObjectQuery q = new RelatedObjectQuery(true,	Path.Path, 
															relatedClass,
															relationshipClass, 
															relatedQualifier,
															relationshipQualifier, 
															relatedRole, thisRole);

			SecurityHandler securityHandler = null;
			int status						= (int)ManagementStatus.NoError;

    		try
			{
				securityHandler = Scope.GetSecurityHandler();
				
				status = Scope.GetIWbemServices().ExecQuery_(
					q.QueryLanguage, 
					q.QueryString, 
					o.Flags, 
					o.GetContext(), 
					out enumWbem);

				if (status >= 0)
					securityHandler.Secure(enumWbem);
			}
			finally
			{
				if (securityHandler != null)
					securityHandler.Reset();
			}
			
			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}

			//Create collection object
			return new ManagementObjectCollection(Scope, o, enumWbem);
		}


		/// <summary>
		///    <para>Gets all classes related to this WMI class in the WMI 
		///       schema, in an asynchronous manner.</para>
		/// </summary>
		/// <param name='watcher'>Handler for progress and results of the asynchronous operation</param>
		public void GetRelatedClasses(
			ManagementOperationObserver watcher)
		{
			GetRelatedClasses(watcher, (string)null);
		}

		/// <summary>
		///    <para>Gets all classes related to this WMI class in the WMI schema, in an asynchronous manner, given the related 
		///       class name.</para>
		/// </summary>
		/// <param name='watcher'>Handler for progress and results of the asynchronous operation</param>
		/// <param name=' relatedClass'>The name of the related class.</param>
		public void GetRelatedClasses(
			ManagementOperationObserver watcher, 
			string relatedClass) 
		{
			GetRelatedClasses(watcher, relatedClass, null, null, null, null, null, null);
		}

		
		/// <summary>
		///    <para>Gets all classes related to this WMI class in the WMI schema, in an 
		///       asynchronous manner, using the specified options.</para>
		/// </summary>
		/// <param name='watcher'>Handler for progress and results of the asynchronous operation</param>
		/// <param name=' options'>Specifies options for retrieving the related classes.</param>
		public void GetRelatedClasses(
			ManagementOperationObserver watcher, 
			string relatedClass,
			string relationshipClass,
			string relationshipQualifier,
			string relatedQualifier,
			string relatedRole,
			string thisRole,
			EnumerationOptions options)
		{
			if ((null == Path) || (String.Empty == Path.Path))
				throw new InvalidOperationException();

			Initialize(); // this may throw

			if (null == watcher)
				throw new ArgumentNullException("watcher");
			else
			{
				WmiEventSink sink = watcher.GetNewSink(
								Scope, 
								null);
			
				EnumerationOptions o = (null != options) 
								? (EnumerationOptions)options.Clone() : new EnumerationOptions();

				//Ensure EnumerateDeep flag bit is turned off as it's invalid for queries
				o.EnumerateDeep = true;

				// Ensure we switch off ReturnImmediately as this is invalid for async calls
				o.ReturnImmediately = false;

				// If someone has registered for progress, make sure we flag it
				if (watcher.HaveListenersForProgress)
					o.SendStatus = true;
			
				RelatedObjectQuery q = new RelatedObjectQuery(true, Path.Path, 
																relatedClass, relationshipClass, 
																relatedQualifier, relationshipQualifier, 
																relatedRole, thisRole);
            
				SecurityHandler securityHandler = null;
				int status						= (int)ManagementStatus.NoError;

				try
				{
					securityHandler = Scope.GetSecurityHandler();

					status = Scope.GetIWbemServices().ExecQueryAsync_(
							q.QueryLanguage, 
							q.QueryString, 
							o.Flags, 
							o.GetContext(), 
							sink.Stub);
				}
				finally
				{
					watcher.RemoveSink(sink);
					if (securityHandler != null)
						securityHandler.Reset();
				}

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
			}
		}

		//******************************************************
		//GetRelationshipClasses
		//******************************************************
		/// <summary>
		///	Gets relationship classes that relate this class to others
		/// </summary>
		public ManagementObjectCollection GetRelationshipClasses()
		{
			return GetRelationshipClasses((string)null);
		}

		/// <summary>
		///    <para>Gets relationship classes that relate this class to others, where the 
		///       endpoint class is the specified one.</para>
		/// </summary>
		/// <param name='relationshipClass'>The endpoint class for all relationships classes returned.</param>
		/// <returns>
		///    <para>A collection of association classes
		///       that relate this class to the specified class.</para>
		/// </returns>
		public ManagementObjectCollection GetRelationshipClasses(
			string relationshipClass)
		{ 
			return GetRelationshipClasses(relationshipClass, null, null, null); 
		}


		/// <summary>
		///    <para>Gets relationship classes that relate this class to others, according to the 
		///       specified options.</para>
		/// </summary>
		/// <param name='options'>Specify options to be used when retrieving the relationship classes</param>
		/// <returns>
		///    A collection of association classes
		///    that relate this class to others according to the specified options.
		/// </returns>
		public ManagementObjectCollection GetRelationshipClasses(
											string relationshipClass,
											string relationshipQualifier,
											string thisRole,
											EnumerationOptions options)
        {
			if ((null == Path) || (String.Empty == Path.Path))
				throw new InvalidOperationException();

			Initialize(); // this may throw

			IEnumWbemClassObject enumWbem = null;

			EnumerationOptions o = (null != options) ? options : new EnumerationOptions();
			//Ensure EnumerateDeep flag is turned off as it's invalid for queries
			o.EnumerateDeep = true;

			
			RelationshipQuery q = new RelationshipQuery(true, Path.Path, relationshipClass,  
														relationshipQualifier, thisRole);
            
			SecurityHandler securityHandler = null;
			int status						= (int)ManagementStatus.NoError;

			//Execute WMI query
			try
			{
				securityHandler = Scope.GetSecurityHandler();

				status = Scope.GetIWbemServices().ExecQuery_(
					q.QueryLanguage, 
					q.QueryString, 
					o.Flags, 
					o.GetContext(), 
					out enumWbem);

				if (status >= 0)
					securityHandler.Secure(enumWbem);
			}
			finally
			{
				if (securityHandler != null)
					securityHandler.Reset();
			}

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}

			//Create collection object
			return new ManagementObjectCollection(Scope, o, enumWbem);
		}


		/// <summary>
		///    <para>Gets relationship classes that relate this class to others, 
		///       asynchronously.</para>
		/// </summary>
		/// <param name='watcher'>The handler for progress and results of the asynchronous operation</param>
		public void GetRelationshipClasses(
			ManagementOperationObserver watcher)
		{
			GetRelationshipClasses(watcher, (string)null);
		}

		/// <summary>
		///    <para>Gets relationship classes that relate this class to the specified WMI class, 
		///       asynchronously.</para>
		/// </summary>
		/// <param name='watcher'>The handler for progress and results of the asynchronous operation</param>
		/// <param name=' relationshipClass'>The WMI class to which all returned relationships should point.</param>
		public void GetRelationshipClasses(
			ManagementOperationObserver watcher, 
			string relationshipClass)
		{
			GetRelationshipClasses(watcher, relationshipClass, null, null, null);
		}
		

		/// <summary>
		///    <para>Gets relationship classes that relate this class according to the specified 
		///       options, asynchronously.</para>
		/// </summary>
		/// <param name='watcher'>The handler for progress and results of the asynchronous operation</param>
		/// <param name=' options'>Specifies the options to be used when retrieving the relationship classes.</param>
		/// <returns>
		///    A collection of association classes
		///    relating this class to others according to the given options.
		/// </returns>
		public void GetRelationshipClasses(
			ManagementOperationObserver watcher, 
			string relationshipClass,
			string relationshipQualifier,
			string thisRole,
			EnumerationOptions options)
		{
			if ((null == Path) || (String.Empty == Path.Path))
				throw new InvalidOperationException();
			if (null == watcher)
				throw new ArgumentNullException("watcher");
			else
			{
				Initialize(); // this may throw
				WmiEventSink sink = watcher.GetNewSink(Scope, null);
			
				EnumerationOptions o = 
						(null != options) ? (EnumerationOptions)options.Clone() : new EnumerationOptions();

				//Ensure EnumerateDeep flag is turned off as it's invalid for queries
				o.EnumerateDeep = true;

				// Ensure we switch off ReturnImmediately as this is invalid for async calls
				o.ReturnImmediately = false;

				// If someone has registered for progress, make sure we flag it
				if (watcher.HaveListenersForProgress)
					o.SendStatus = true;
				
				RelationshipQuery q = new RelationshipQuery(true, Path.Path, relationshipClass,
						relationshipQualifier, thisRole);

				SecurityHandler securityHandler = null;
				int status						= (int)ManagementStatus.NoError;

				try
				{
					securityHandler = Scope.GetSecurityHandler();

					status = Scope.GetIWbemServices().ExecQueryAsync_(
							q.QueryLanguage, 
							q.QueryString, 
							o.Flags, 
							o.GetContext(), 
							sink.Stub);
				}
				finally
				{
					watcher.RemoveSink(sink);
					if (securityHandler != null)
						securityHandler.Reset();
				}

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
			}
		}

		
		/// <summary>
		///    <para>Generate Strongly typed class for a given WMI class</para>
		/// </summary>
		/// <param name='includeSystemClassinClassDef'>Boolean value to indicate if class to managing system properties has to be include</param>
		/// <param name='systemPropertyClass'>Boolean value to indicate if the code to be genereated is for class to manage System properties</param>
		/// <returns>
		///    <para>Retuns the CodeDeclarationType for the class </para>
		/// </returns>
		/// <example>
		///    <para>using System;</para>
		///    <para>using System.Management; </para>
		///    <para>using System.CodeDom;</para>
		///    <para>using System.IO;</para>
		///    <para>using System.CodeDom.Compiler;</para>
		///    <para>using Microsoft.CSharp;</para>
		///    <para>void GenerateCSharpCode()</para>
		///    <para>{</para>
		///    <para> 
		///       string strFilePath = "C:\\temp\\Logicaldisk.cs";</para>
		///    <para> 
		///       CodeTypeDeclaration ClsDom;</para>
		///    <para> 
		///       ManagementClass cls1 = new ManagementClass(null,"Win32_LogicalDisk",null);</para>
		///    <para> 
		///       ClsDom = cls1.GetStronglyTypedClassCode(false,false)</para>
		///    <para> 
		///       ICodeGenerator cg = (new CSharpCodeProvider()).CreateGenerator ();</para>
		///    <para> 
		///       CodeNamespace cn = new CodeNamespace("TestNamespace");</para>
		///    <para> 
		///       // Add any imports to the code</para>
		///    <para> 
		///       cn.Imports.Add (new CodeNamespaceImport("System"));</para>
		///    <para> 
		///       cn.Imports.Add (new CodeNamespaceImport("System.ComponentModel"));</para>
		///    <para> 
		///		  cn.Imports.Add (new CodeNamespaceImport("System.Management"));</para>
		///    <para> 
		///       cn.Imports.Add(new  CodeNamespaceImport("System.Collections"));</para>
		///    <para> 
		///       // Add class to the namespace</para>
		///    <para> 
		///       cn.Types.Add (ClsDom);</para>
		///    <para> 
		///       //Now create the filestream (output file)</para>
		///    <para> 
		///       TextWriter tw = new StreamWriter(new
		///       FileStream (strFilePath,FileMode.Create));</para>
		///    <para> 
		///       // And write it to the file</para>
		///    <para> 
		///       cg.GenerateCodeFromNamespace (cn, tw, new CodeGeneratorOptions());</para>
		///    <para>
		///    <para> tw.Close();</para>}</para>
		/// </example>

		public CodeTypeDeclaration GetStronglyTypedClassCode(bool includeSystemClassInClassDef, bool systemPropertyClass)
		{
			// Ensure that the object is valid
			Get();
			ManagementClassGenerator classGen = new ManagementClassGenerator(this);
			return classGen.GenerateCode(includeSystemClassInClassDef,systemPropertyClass);
		}
		
		
		/// <summary>
		///    <para>Generate Strongly typed class for a given WMI class. This function generates code for VB 
		///    C# or JScript depending on the input parameters</para>
		/// </summary>
		/// <param name='lang'>Language of the code to be generated</param>
		/// <param name='filePath'>Path of file where code is to be written</param>
		/// <param name='classNamespace'>The .NET namespace in which the class has to be genrated If this is empty the namespace will be generated from the WMI Namespace</param>
		/// <returns>
		///    <para>Retuns a boolean value indicating the success of the method</para>
		/// </returns>
		/// <example>
		///    <para> using System;</para>
		///    <para>using System.Management; </para>
		///    <para>ManagementClass cls = new ManagementClass(null,"Win32_LogicalDisk",null,"");</para>	
		///    <para>cls.GetStronglyTypedClassCode(CodeLanguage.CSharp,"C:\temp\Logicaldisk.cs",String.Empty); </para>
		/// </example>
		public bool GetStronglyTypedClassCode(CodeLanguage lang, String filePath,String classNamespace)
		{
			// Ensure that the object is valid
			Get();
			ManagementClassGenerator classGen = new ManagementClassGenerator(this);
			return classGen.GenerateCode(lang , filePath,classNamespace);
		}

	}//ManagementClass
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\assemblyinfo.cs ===
using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("System.Management")]
[assembly:AssemblyDescription("This assembly contains the classes necessary to access management information from managed code")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("Microsoft")]
[assembly:AssemblyProduct("WMI")]
[assembly:AssemblyCopyright("1995-2001")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.2411.0")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(true)]
[assembly:AssemblyKeyFile("FinalPublicKey.snk")]
[assembly:AssemblyKeyName("")]

[assembly:CLSCompliant(true)]

// Do not surface these APIs to class COM clients
[assembly:ComVisible(false)]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\managementeventwatcher.cs ===
using System;
using System.Collections;
using System.Runtime.InteropServices;
using WbemClient_v1;
using System.Diagnostics;
using System.ComponentModel;

namespace System.Management
{
	/// <summary>
	/// Delegate definition for the EventArrived event.
	/// </summary>
	public delegate void EventArrivedEventHandler(object sender, EventArrivedEventArgs e);

	/// <summary>
	/// Delegate definition for the Stopped event.
	/// </summary>
	public delegate void StoppedEventHandler (object sender, StoppedEventArgs e);

	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	/// This class is used to subscribe for temporary event notifications
	/// based on a specified event query
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class ManagementEventWatcher : Component
	{
		//fields
		private ManagementScope			scope;
		private EventQuery				query;
		private EventWatcherOptions		options;
		private IEnumWbemClassObject	enumWbem;
		private IWbemClassObjectFreeThreaded[]		cachedObjects; //points to objects currently available in cache
		private uint					cachedCount; //says how many objects are in the cache (when using BlockSize option)
		private uint					cacheIndex; //used to walk the cache
		private SinkForEventQuery		sink; // the sink implementation for event queries
		private WmiDelegateInvoker		delegateInvoker; 
		
		//Called when IdentifierChanged() event fires
		private void HandleIdentifierChange(object sender, 
					IdentifierChangedEventArgs e)
		{
			// Invalidate any sync or async call in progress
			Stop();
		}

		//default constructor
		/// <summary>
		///    Default constructor. Creates an empty event watcher.
		///    Further initialization can be done by setting the properties on this object.
		/// </summary>
		public ManagementEventWatcher() : this((ManagementScope)null, null, null) {}

		//parameterized constructors
		/// <summary>
		///    <para>Creates a new event watcher given a WMI event query.</para>
		/// </summary>
		/// <param name='query'>A WMI event query object holding the query that determines which events this watcher will be listening for.</param>
		/// <remarks>
		///    The namespace in which this watcher will be
		///    listening for events is the default namespace currently set.
		/// </remarks>
		public ManagementEventWatcher (
			EventQuery query) : this(null, query, null) {}
		/// <summary>
		///    <para>Creates new event watcher given a WMI event query in the 
		///       form of a string.</para>
		/// </summary>
		/// <param name='query'>A string representing the WMI event query that defines which events this watcher will be listening for.</param>
		/// <remarks>
		///    The namespace in which this watcher will be
		///    listening for events is the default namespace currently set.
		/// </remarks>
		public ManagementEventWatcher (
			string query) : this(null, new EventQuery(query), null) {}
		/// <summary>
		///    <para>Creates a new watcher that will listen for events 
		///       conforming to the given WMI event query, in the given WMI scope.</para>
		/// </summary>
		/// <param name='scope'>Defines the management scope (namespace) in which this watcher will be listening for events.</param>
		/// <param name=' query'>The query that defines which events this watcher will be listening for.</param>
		public ManagementEventWatcher(
			ManagementScope scope, 
			EventQuery query) : this(scope, query, null) {}
		/// <summary>
		///    <para>Creates a new watcher that will listen for events
		///       conforming to the given WMI event query, in the given WMI scope. For this
		///       variant the query and the scope are specified as strings.</para>
		/// </summary>
		/// <param name='scope'>Defines the management scope (namespace) in which this watcher will be listening for events.</param>
		/// <param name=' query'>The query that defines which events this watcher will be listening for.</param>
		public ManagementEventWatcher(
			string scope, 
			string query) : this(new ManagementScope(scope), new EventQuery(query), null) {}
		/// <summary>
		///    <para>Creates a new watcher that will listen for events conforming to the given WMI 
		///       event query, in the given WMI scope, and according to the specified options. For
		///       this variant the query and the scope are specified as strings. The options
		///       object specifies options such as a timeout and possibly context information.</para>
		/// </summary>
		public ManagementEventWatcher(
			string scope,
			string query,
			EventWatcherOptions options) : this(new ManagementScope(scope), new EventQuery(query), options) {}

		/// <summary>
		///    <para>Creates a new watcher that will listen for events conforming to the given WMI 
		///       event query, in the given WMI scope, and according to the specified options. For
		///       this variant the query and the scope are specified objects. The options object
		///       specifies options such as a timeout and possibly context information.</para>
		/// </summary>
		public ManagementEventWatcher(
			ManagementScope scope, 
			EventQuery query, 
			EventWatcherOptions options)
		{
			if (null != scope)
				Scope = scope;
			else Scope = new ManagementScope ();

			if (null != query)
				Query = query;
			else
				Query = new EventQuery ();

			if (null != options)
				Options = options;
			else
				Options = new EventWatcherOptions ();

			enumWbem = null;
			cachedCount = 0; 
			cacheIndex = 0;
			sink = null;
			delegateInvoker = new WmiDelegateInvoker (this);
		}
		
		/// <summary>
		/// Destructor for this object. Ensures any outstanding calls are cleared.
		/// </summary>
		~ManagementEventWatcher ()
		{
			// Ensure any outstanding calls are cleared
			Stop ();

			if (null != scope)
				scope.IdentifierChanged -= new IdentifierChangedEventHandler (HandleIdentifierChange);

			if (null != options)
				options.IdentifierChanged -= new IdentifierChangedEventHandler (HandleIdentifierChange);

			if (null != query)
				query.IdentifierChanged -= new IdentifierChangedEventHandler (HandleIdentifierChange);
		}

		// 
		// Events
		//

		/// <summary>
		/// The event fired when a new event arrives.
		/// </summary>
		public event EventArrivedEventHandler		EventArrived;

		/// <summary>
		/// The event fired when a subscription is cancelled.
		/// </summary>
		public event StoppedEventHandler			Stopped;

		//
		//Public Properties
		//

		/// <value>
		///  The scope in which we want to look for objects (namespace or scope)
		/// </value>
		public ManagementScope Scope {
			get { 
				return scope; 
			} 
			set {
				if (null != value)
				{
					ManagementScope oldScope = scope;
					scope = (ManagementScope)value.Clone ();

					// Unregister ourselves from the previous scope object
					if (null != oldScope)
						oldScope.IdentifierChanged -= new IdentifierChangedEventHandler(HandleIdentifierChange);

					//register for change events in this object
					scope.IdentifierChanged += new IdentifierChangedEventHandler(HandleIdentifierChange);
					//the scope property has changed so act like we fired the event
					HandleIdentifierChange(this, null);
				}
				else
					throw new ArgumentNullException();
			}
		}

		/// <value>
		/// The criteria to apply to the search (= the query)
		/// </value>
		public EventQuery Query {
			get { 
				return query; 
			} 
			set { 
				if (null != value)
				{
					ManagementQuery oldQuery = query;
					query = (EventQuery)value.Clone ();

					// Unregister ourselves from the previous query object
					if (null != oldQuery)
						oldQuery.IdentifierChanged -= new IdentifierChangedEventHandler(HandleIdentifierChange);

					//register for change events in this object
					query.IdentifierChanged += new IdentifierChangedEventHandler(HandleIdentifierChange);
					//the query property has changed so act like we fired the event
					HandleIdentifierChange(this, null);
				}
				else
					throw new ArgumentNullException();
			}
		}

		/// <value>
		/// Options for how to search for objects
		/// </value>
		public EventWatcherOptions Options { 
			get { 
				return options; 
			} 
			set { 
				if (null != value)
				{
					EventWatcherOptions oldOptions = options;
					options = (EventWatcherOptions)value.Clone ();

					// Unregister ourselves from the previous scope object
					if (null != oldOptions)
						oldOptions.IdentifierChanged -= new IdentifierChangedEventHandler(HandleIdentifierChange);

					cachedObjects = new IWbemClassObjectFreeThreaded[options.BlockSize];
					//register for change events in this object
					options.IdentifierChanged += new IdentifierChangedEventHandler(HandleIdentifierChange);
					//the options property has changed so act like we fired the event
					HandleIdentifierChange(this, null);
				}
				else
					throw new ArgumentNullException();
			} 
		}

		/// <summary>
		///    <para>Waits until the next event that matches the specified query arrives,
		///       and returns it</para>
		/// </summary>
		/// <remarks>
		///    If the event watcher object contains
		///    options with a specified timeout, this API will wait for the next event only for
		///    the specified time. If not, the API will block until the next event occurs.
		/// </remarks>
		public ManagementBaseObject WaitForNextEvent()
		{
			Trace.WriteLine("Entering WaitForNextEvent...");
			ManagementBaseObject obj = null;

			Initialize ();
			
			lock(this)
			{
				SecurityHandler securityHandler = Scope.GetSecurityHandler();

				int status = (int)ManagementStatus.NoError;

				try 
				{
					if (null == enumWbem)	//don't have an enumerator yet - get it
					{
						//Execute the query 
						status = Scope.GetIWbemServices().ExecNotificationQuery_(
							query.QueryLanguage,
							query.QueryString, 
							options.Flags,
							options.GetContext (),
							out enumWbem);
			
						//Set security on enumerator 
						if ((status & 0x80000000) == 0)
						{
							securityHandler.Secure(enumWbem);
						}
					}

					if ((status & 0x80000000) == 0)
					{
						if ((cachedCount - cacheIndex) == 0) //cache is empty - need to get more objects
						{
							// TODO - due to TLBIMP restrictions IEnumWBemClassObject.Next will
							// not work with arrays - have to set count to 1
	#if false
						enumWbem.Next((int)options.Timeout.TotalMilliseconds, (uint)options.BlockCount, 
							out cachedObjects, out cachedCount);
	#else
							IWbemClassObjectFreeThreaded cachedObject = cachedObjects[0];
							int timeout = (ManagementOptions.InfiniteTimeout == options.Timeout)
								? (int) tag_WBEM_TIMEOUT_TYPE.WBEM_INFINITE :
								(int) options.Timeout.TotalMilliseconds;
							status = enumWbem.Next_ (timeout, 1, out cachedObject, out cachedCount);

							cacheIndex = 0;

							if ((status & 0x80000000) == 0)
							{
								//Create ManagementObject for result. Note that we may have timed out
								//in which case we won't have an object
								if (null == cachedObject)
									ManagementException.ThrowWithExtendedInfo(ManagementStatus.Timedout);

								cachedObjects[0] = cachedObject;
							}
	#endif
						}

						if ((status & 0x80000000) == 0)
						{
							obj = new ManagementBaseObject(cachedObjects[cacheIndex]);
							cacheIndex++;
						}
					}
				} catch (Exception e) {
					// BUGBUG : securityHandler.Reset()?
					if (e is ManagementException)
						throw; //just let it propagate
					ManagementException.ThrowWithExtendedInfo(e);
				}
				finally {
					securityHandler.Reset();
					Trace.WriteLine("Returning from WaitForNextEvent...");
				}

				if ((status & 0xfffff000) == 0x80041000)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				}
				else if ((status & 0x80000000) != 0)
				{
					Marshal.ThrowExceptionForHR(status);
				}
			}

			return obj;
		}


		//********************************************
		//Start
		//********************************************
		/// <summary>
		///    <para>Subscribes for events with the given query and delivers them asynchronously, through the EventArrived event.</para>
		/// </summary>
		public void Start()
		{
			Initialize ();

			// Cancel any current event query
			Stop ();
			
			SecurityHandler securityHandler = Scope.GetSecurityHandler();

			int status = (int)ManagementStatus.NoError;

			// Submit a new query
			try 
			{
				IWbemServices wbemServices = scope.GetIWbemServices();
				sink = new SinkForEventQuery (this, options.GetContext(), wbemServices);

				// For async event queries we should ensure 0 flags as this is
				// the only legal value
				status = wbemServices.ExecNotificationQueryAsync_(
							query.QueryLanguage,
							query.QueryString,
							0,
							options.GetContext (),
							sink.Stub);
			} catch (Exception e) {
				// BUGBUG : securityHandler.Reset()?
				if (sink != null)		// BUGBUG : This looks dangerous
				{
					sink.ReleaseStub ();
					sink = null;
				}
				ManagementException.ThrowWithExtendedInfo(e);
			} finally {
				securityHandler.Reset();
			}

			if ((status & 0xfffff000) == 0x80041000)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
			}
			else if ((status & 0x80000000) != 0)
			{
				Marshal.ThrowExceptionForHR(status);
			}
		}
		
		//********************************************
		//Stop
		//********************************************
		/// <summary>
		/// Cancels the subscription, whether syncronous or asynchronous
		/// </summary>
		public void Stop()
		{
			//For semi-synchronous, release the WMI enumerator to cancel the subscription
			if (null != enumWbem)
			{
				Marshal.ReleaseComObject(enumWbem);
				enumWbem = null;
				FireStopped (new StoppedEventArgs (options.GetContext(), (int)ManagementStatus.OperationCanceled));
			}

			// In async mode cancel the call to the sink - this will
			// unwind the operation and cause a Stopped message
			if (null != sink)
			{
				sink.Cancel ();
				sink = null;
			}
		}

		private void Initialize ()
		{
			//If the query is not set yet we can't do it
			if (null == query)
				throw new InvalidOperationException();

			if (null == options)
				Options = new EventWatcherOptions ();

			//If we're not connected yet, this is the time to do it...
			lock (this)
			{
				if (null == scope)
					Scope = new ManagementScope ();

				if (null == cachedObjects)
					cachedObjects = new IWbemClassObjectFreeThreaded[options.BlockSize];
			}

			lock (scope)
			{
				scope.Initialize ();
			}
		}


		internal void FireStopped (StoppedEventArgs args)
		{
			try {
				delegateInvoker.FireEventToDelegates (Stopped, args);
				// We are done with the sink
				sink = null;
			} catch {}
		}

		internal void FireEventArrived (EventArrivedEventArgs args)
		{
			try {
				delegateInvoker.FireEventToDelegates (EventArrived, args);
			} catch {}
		}



	}

	internal class SinkForEventQuery : IWmiEventSource
	{
		private ManagementEventWatcher			eventWatcher;
		private object							context;
		private IWbemServices					services;
		private IWbemObjectSink	stub;			// The secured IWbemObjectSink

		public SinkForEventQuery (ManagementEventWatcher eventWatcher,
							 object context, 
							 IWbemServices services)
		{
			this.services = services;
			this.context = context;
			this.eventWatcher = eventWatcher;
	
			IWmiSinkDemultiplexor sinkDmux = (IWmiSinkDemultiplexor) new WmiSinkDemultiplexor ();
			object dmuxStub = null;
			sinkDmux.GetDemultiplexedStub (this, out dmuxStub);
			stub = (IWbemObjectSink) dmuxStub;
		}

		internal IWbemObjectSink Stub { 
			get { return stub; }
		}

		public void Indicate(IntPtr pWbemClassObject)
		{
            Marshal.AddRef(pWbemClassObject);
            IWbemClassObjectFreeThreaded obj = new IWbemClassObjectFreeThreaded(pWbemClassObject);
			try {
				if (null != eventWatcher)
				{
					EventArrivedEventArgs args = new EventArrivedEventArgs (context, 
											new ManagementBaseObject (obj));
					eventWatcher.FireEventArrived (args); 
				}
			} catch {}
		}
	
		public void SetStatus (
						int flags, 
						int hResult, 
						String message, 
						IntPtr pErrObj)
		{
            IWbemClassObjectFreeThreaded errObj = null;
            if(pErrObj != IntPtr.Zero)
            {
                Marshal.AddRef(pErrObj);
                errObj = new IWbemClassObjectFreeThreaded(pErrObj);
            }
            // TODO: errObj never used

			try {
				if (null != eventWatcher)
				{
                    // Fire Stopped event
					eventWatcher.FireStopped (new StoppedEventArgs (context, hResult));

					// Unhook the parent watcher
					eventWatcher = null;
				}

				ReleaseStub ();
			} catch {}
		}

		internal void Cancel () 
		{
			int status = (int)ManagementStatus.NoError;

			try {
				status = services.CancelAsyncCall_(stub);
			} 
			catch (Exception e) {
				ManagementException.ThrowWithExtendedInfo(e);
			}

			if ((status & 0xfffff000) == 0x80041000)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
			}
			else if ((status & 0x80000000) != 0)
			{
				Marshal.ThrowExceptionForHR(status);
			}
		}

		internal void ReleaseStub ()
		{
			try {
				/*
				 * We force a release of the stub here so as to allow
				 * unsecapp.exe to die as soon as possible.
				 */
				if (null != stub)
				{
					System.Runtime.InteropServices.Marshal.ReleaseComObject(stub);
					stub = null;
				}
			} catch {}
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\managementobject.cs ===
using System.Collections;
using System.Runtime.InteropServices;
using WbemClient_v1;
using System.ComponentModel;
using System.Runtime.Serialization;


namespace System.Management
{
	/// <summary>
	/// Delegate definition for the IdentifierChanged event.
	/// This event is used to signal the ManagementObject that an identifying property
	/// has been changed. Identifying properties are the ones that identify the object, 
	/// namely the scope, path and options.
	/// </summary>
	internal delegate void IdentifierChangedEventHandler(object sender, 
					IdentifierChangedEventArgs e);
    
	/// <summary>
	/// Delegate definition for InternalObjectPut event. This is used so that
	/// the WmiEventSink can signal to this object that the async Put call has
	/// completed.
	/// </summary>
	internal delegate void InternalObjectPutEventHandler(object sender,
		InternalObjectPutEventArgs e);
    

	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	/// This class represents a data management object
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class ManagementObject : ManagementBaseObject, ICloneable
	{
		// constants
		internal const string ID = "ID";
		internal const string RETURNVALUE = "RETURNVALUE";

		//Fields
		private ManagementScope scope;
		private IWbemClassObjectFreeThreaded wmiClass;
		private ManagementPath path;
		private ObjectGetOptions options;

		//Used to represent whether this managementObject is currently bound to a wbemObject
		//or not - whenever an "identifying" property is changed (Path, Scope...) the object
		//is "detached" (isBound becomes false) so that we refresh the wbemObject next time
		//it's used, in conformance with the new property values.
		private bool isBound;
		
		//This is used to identify a state in which a Put() operation was performed, but the
		//object was not retrieved again, so the WMI object that's available at this point
		//cannot be used for certain operations, namely CreateInstance, GetSubclasses, Derive,
		//Clone & ClassPath. 
		//When these operations are invoked, if we are in this state we need to implicitly
		//get the object...
		private bool putButNotGot;
		
		//Event fired when any "identifying" property changes.
		internal event IdentifierChangedEventHandler IdentifierChanged;

		//Fires IdentifierChanged event
		internal void FireIdentifierChanged()
		{
			if (IdentifierChanged != null)
				IdentifierChanged(this, null);
		}

		internal bool PutButNotGot 
		{
			get 
			{ return putButNotGot; }
			set 
			{ putButNotGot = value; }
		}

		//Called when IdentifierChanged() event fires
		private void HandleIdentifierChange(object sender, 
			IdentifierChangedEventArgs e)
		{
			//Detach the object from the WMI object underneath
			isBound = false;
		}

		internal bool IsBound 
		{
			get 
			{ return isBound; }
			set 
			{ isBound = value; }
		}

		//internal constructor
		internal static ManagementObject GetManagementObject(
			IWbemClassObjectFreeThreaded wbemObject,
			ManagementObject mgObj) 
		{
			ManagementObject newObject = new ManagementObject();
			newObject.wbemObject = wbemObject;

			if (null != mgObj)
			{
				newObject.Scope = mgObj.Scope;

				if (null != mgObj.path)
					newObject.Path = mgObj.Path;

				if (null != mgObj.options)
					newObject.Options = mgObj.Options;

				// We set isBound last since assigning to Scope, Path
				// or Options can trigger isBound to be set false.
				newObject.isBound = mgObj.isBound;
			}

			return newObject;
		}

		internal static ManagementObject GetManagementObject(
			IWbemClassObjectFreeThreaded wbemObject,
			ManagementScope scope) 
		{
			ManagementObject newObject = new ManagementObject();
			newObject.wbemObject = wbemObject;

			newObject.Path = ManagementPath.GetManagementPath(wbemObject);
			
			if (null != scope)
				newObject.Scope = scope;

			// Since we have an object, we should mark it as bound. Note
			// that we do this AFTER setting Scope and Path, since those
			// have side-effects of setting isBound=false.
			newObject.isBound = true;

			return newObject;
		}


		//default constructor
		/// <summary>
		///    Default constructor, creates an uninitialized
		///    management object.
		/// </summary>
		/// <example>
		///    ManagementObject o = new ManagementObject();
		///    //Now set the path on this object to bind it to a 'real' manageable
		///    entity
		///    o.Path = "Win32_LogicalDisk='c:'";
		///    //Now it can be used
		///    Console.WriteLine(o["FreeSpace"]);
		/// </example>
		public ManagementObject() : this ((ManagementScope)null, null, null) {}

		//parameterized constructors
		/// <summary>
		///    <para>Creates a new management object for the specified WMI object path. The path is provided as a
		///       ManagementPath object.</para>
		/// </summary>
		/// <param name='path'>a ManagementPath that contains a path to a WMI object</param>
		/// <example>
		///    <para>ManagementPath p = new ManagementPath("Win32_Service.Name='Alerter'");</para>
		///    ManagementObject o = new ManagementObject(p);
		/// </example>
		public ManagementObject(ManagementPath path) : this(null, path, null) {}
		/// <summary>
		///    <para>Creates a new management object for the specified WMI object path. The path 
		///       is provided as a string.</para>
		/// </summary>
		/// <param name='path'>a string representing a WMI path</param>
		/// <remarks>
		///    <para>If the path specified is a relative path only (does not specify a server or
		///       namespace), the default is the local machine, and the default namespace is the
		///       ManagementPath.DefaultPath path (by default root\cimv2). If the user specifies a
		///       full path, this overrides the defaults. The path specified for the ManagementObject class
		///       must be an instance path. For classes the ManagementClass class should be used.</para>
		/// </remarks>
		/// <example>
		///    <para>ManagementObject o = new
		///       ManagementObject("Win32_Service.Name='Alerter'");</para>
		///    <para>or with a full path :</para>
		///    <para>ManagementObject o = new
		///       ManagementObject(\\\\MyServer\\root\\MyApp:MyClass.Key='foo');</para>
		/// </example>
		public ManagementObject(string path) : this(null, new ManagementPath(path), null) {}
		/// <summary>
		///    <para>Creates a new management object bound to the specified 
		///       WMI path, with the specified additional options. The path must be a WMI instance path.</para>
		/// </summary>
		/// <param name='path'>a ManagementPath object containing the WMI path</param>
		/// <param name=' options'>an ObjectGetOptions object containing additional options for binding to the WMI object. Could be null if default options are to be used.</param>
		/// <example>
		///    <para>ManagementPath p = new
		///       ManagementPath("Win32_ComputerSystem.Name='MyMachine'");</para>
		///    <para>ObjectGetOptions opt = new ObjectGetOptions(null, true); //specifies no
		///       context info, but requests amended qualifiers to be contained in the
		///       object</para>
		///    <para>ManagementObject o = new ManagementObject(p, opt);</para>
		///    <para>Console.WriteLine(o.GetQualifierValue("Description"));</para>
		/// </example>
		public ManagementObject(ManagementPath path, ObjectGetOptions options) : this(null, path, options) {}
		/// <summary>
		///    <para>Creates a new management object bound to the specified WMI path, with the 
		///       specified additional options. In this variant the path can be specified as a
		///       string. The path must be a WMI instance path.</para>
		/// </summary>
		/// <param name='path'>string representing the WMI path to the object</param>
		/// <param name=' options'>an ObjectGetOptions object representing options to be used to get the specified WMI object.</param>
		/// <example>
		///    <para>ObjectGetOptions opt = new ObjectGetOptions(null, true); //specifies no 
		///       context info, but requests amended qualifiers to be contained in the object</para>
		///    <para>ManagementObject o = new 
		///       ManagementObject("Win32_ComputerSystem.Name='MyMachine'", opt);</para>
		///    <para>Console.WriteLine(o.GetQualifierValue("Description"));</para>
		/// </example>
		public ManagementObject(string path, ObjectGetOptions options) : 
			this(new ManagementPath(path), options) {}
		/// <summary>
		///    <para>Creates a new management object bound to the specified 
		///       WMI path in the specified WMI scope, with the specified options. The path must be a WMI instance path.</para>
		/// </summary>
		/// <param name='scope'>a ManagementScope object representing the scope in which the WMI object resides. In this version, scopes can only be WMI namespaces.</param>
		/// <param name=' path'>a ManagementPath object representing the WMI path to the manageable object.</param>
		/// <param name=' options'>an ObjectGetOptions object specifying additional options for getting the object.</param>
		/// <remarks>
		///    <para>Since WMI paths can be relative or full, there may be a 
		///       conflict between the scope and the path specified. The resolution of conflict
		///       will be as follows : </para>
		///    <para>If a scope is specified and a relative WMI path is
		///       specified, there is no conflict.</para>
		///    <para>If a scope is not specified and a relative WMI
		///       path is specified, the scope will be defaulted to the local machine's
		///       ManagementPath.DefaultPath. </para>
		///    <para>If a scope is not specified and a full WMI path is
		///       specified, the scope will be inferred from the scope portion of the full path.
		///       E.g., the full WMI path : \\MyMachine\root\MyNamespace:MyClass.Name='foo' will
		///       represent the WMI object 'MyClass.Name='foo'" in the scope
		///       '\\MyMachine\root\MyNamespace'. </para>
		///    If a scope is specified AND a full WMI path is
		///    specified, the scope will override the scope portion of the full path, e.g. if a
		///    scope was specified : <p> \\MyMachine\root\MyScope, and a full
		///    path was specified : \\MyMachine\root\MyNamespace:MyClass.Name='foo',</p>
		/// <p> the object we will be looking for will be : \\MyMachine\root\MyScope:MyClass.Name='foo'
		///    (the scope part of the
		///    full path will be ignored).</p>
		/// </remarks>
		/// <example>
		///    <p>ManagementScope s = new
		///       ManagementScope(\\\\MyMachine\root\cimv2);</p>
		///    <p>ManagementPath p = new
		///       ManagementPath("Win32_LogicalDisk.Name='c:'");</p>
		///    <p>ManagementObject o = new ManagementObject(s,p);</p>
		/// </example>
        public ManagementObject(ManagementScope scope, ManagementPath path, ObjectGetOptions options)
            : base (null)
        {
            ManagementObjectCTOR(scope, path, options);
        }


        void ManagementObjectCTOR(ManagementScope scope, ManagementPath path, ObjectGetOptions options)
        {
			// We may use this to set the scope path
			string nsPath = String.Empty;

			if ((null != path) && !path.IsEmpty)
			{
				//If this is a ManagementObject then the path has to be an instance,
				// and if this is a ManagementClass the path has to be a class.
				if (GetType() == typeof(ManagementObject) && path.IsClass)
					throw new ArgumentOutOfRangeException("path");
				else if (GetType() == typeof(ManagementClass) && path.IsInstance)
					throw new ArgumentOutOfRangeException("path");

				// Save the namespace path portion of the path (if any) in case
				// we don't have a scope
				nsPath = path.NamespacePath;

				if ((null != scope) && (0 != scope.Path.NamespacePath.CompareTo(String.Empty)))
				{
					// If the scope has a path too, the namespace portion of
					// scope.path takes precedence over what is specified in path
					path = new ManagementPath(path.RelativePath);
					path.NamespacePath = scope.Path.NamespacePath;
				}

				// If the supplied path is a class or instance use it, otherwise
				// leave it empty
				if (path.IsClass || path.IsInstance)
					Path = path;
				else
					Path = new ManagementPath();
			}
			else
				Path = new ManagementPath();

			if (null != options)
				Options = options;
			else
				Options = new ObjectGetOptions();

			if (null != scope)
				Scope = scope;
			else
			{
				// Use the path if possible, otherwise let it default
				if (0 != nsPath.CompareTo(String.Empty))
					Scope = new ManagementScope(nsPath);
				else
					Scope = new ManagementScope();
			}

			//register for identifier change events
			IdentifierChanged += new IdentifierChangedEventHandler(HandleIdentifierChange);
			isBound = false;
			putButNotGot = false;

		}
		/// <summary>
		///    <para>Creates a new management object bound to the specified
		///       WMI path in the specified WMI scope, with the specified options. The scope and
		///       the path are specified as strings. The path must be a WMI instance path.</para>
		/// </summary>
		/// <param name='scopeString'>A string representing the scope for the WMI object</param>
		/// <param name=' pathString'>A string representing the WMI object path</param>
		/// <param name=' options'>An ObjectGetOptions object representing additional options for getting the WMI object.</param>
		/// <remarks>
		///    <para>See equivalent overload for details.</para>
		/// </remarks>
		/// <example>
		///    <para>GetObjectOptions opt = new GetObjectOptions(null, true);</para>
		///    ManagementObject o = new ManagementObject("root\MyNamespace",
		///    "MyClass.Name='foo'", opt);
		/// </example>
		public ManagementObject(string scopeString, string pathString, ObjectGetOptions options)
			: this(new ManagementScope(scopeString), new ManagementPath(pathString), options) {}

        public ManagementObject(SerializationInfo info, StreamingContext context) : base(info, context)
        {
            ManagementObjectCTOR(null, null, null);
        }

		/// <summary>
		///    <para>The scope used for binding this object</para>
		/// </summary>
		/// <value>
		///    <para> A ManagementScope object.</para>
		/// </value>
		/// <remarks>
		///    <para>Changing this property after the management
		///       object has already been bound to a WMI object in a particular namespace causes
		///       the original WMI object to be released and the management object to be re-bound
		///       to the new object specified by the new values of the scope and path properties.
		///       The re-binding is performed in a 'lazy' manner, i.e. only when a value is
		///       requested by the user of this object which requires the management object to be
		///       bound to the WMI object. This allows changing more than just this property
		///       before a rebind attempt occurs (e.g. one might want to modify both the scope and
		///       path properties at once).</para>
		/// </remarks>
		/// <example>
		///    <p>ManagementObject o = new ManagementObject(); //creates the object with
		///       the default namespace (root\cimv2)</p>
		///    <p>o.Scope = new ManagementScope("root\MyAppNamespace"); //changes the scope
		///       of this object to the one specified.</p>
		/// </example>

		public ManagementScope Scope 
		{
			get 
			{ return scope; }
			set 
			{
				if (null != value)
				{
					ManagementScope oldScope = scope;
					scope = (ManagementScope)value.Clone();

					if (null != oldScope)
						oldScope.IdentifierChanged -= new IdentifierChangedEventHandler(HandleIdentifierChange);

					//register for change events in this object
					scope.IdentifierChanged += new IdentifierChangedEventHandler(HandleIdentifierChange);
					//the scope property has changed so fire event
					FireIdentifierChanged();
				}
				else 
					throw new ArgumentNullException();
			}
		}
		
		
		/// <summary>
		///    <para>The WMI path representing this object</para>
		/// </summary>
		/// <value>
		///    <para>A ManagementPath object representing the object's path.</para>
		/// </value>
		/// <remarks>
		///    <para>Changing this property after the management object has already been bound to 
		///       a WMI object in a particular namespace causes the original WMI object to be
		///       released and the management object to be re-bound to the new object specified by
		///       the new values of the scope and path properties. The re-binding is performed in
		///       a 'lazy' manner, i.e. only when a value is requested by the user of this object
		///       which requires the management object to be bound to the WMI object. This allows
		///       changing more than just this property before a rebind attempt occurs (e.g. one
		///       might want to modify both the scope and path properties at once).</para>
		/// </remarks>
		/// <example>
		///    <para>ManagementObject o = new ManagementObject(); </para>
		///    o.Path = new ManagementPath("MyClass.Name='foo'"); //specifies the WMI path
		///    this object should be bound to
		/// </example>
		public virtual ManagementPath Path 
		{ 
			get 
			{ return path; } 
			set 
			{
				ManagementPath newPath = (null != value) ? value : new ManagementPath();

				//If the new path contains a namespace path and the scope is currently defaulted,
				//we want to set the scope to the new namespace path provided
				if ((newPath.NamespacePath.Length > 0) && (scope != null) && (scope.IsDefaulted))
					Scope = new ManagementScope(newPath.NamespacePath);

				// This must be a class for a ManagementClass object or an instance for a ManagementObject, or empty
				if ((GetType() == typeof(ManagementObject) && newPath.IsInstance) || 
					(GetType() == typeof(ManagementClass) && newPath.IsClass) || 
					newPath.IsEmpty)
				{
					ManagementPath oldPath = path;
					path = (ManagementPath)newPath.Clone();

					if (null != oldPath)
						oldPath.IdentifierChanged -=  new IdentifierChangedEventHandler(HandleIdentifierChange);

					//register for change events in this object
					path.IdentifierChanged += new IdentifierChangedEventHandler(HandleIdentifierChange);
					//the path property has changed so fire event
					FireIdentifierChanged();
				}
				else
					throw new ArgumentOutOfRangeException();
			}
		}

		/// <summary>
		///    Options specifying additional
		///    information to be used when getting this object
		/// </summary>
		/// <value>
		///    An ObjectGetOptions object.
		/// </value>
		/// <remarks>
		///    When this property is changed after the
		///    management object has been bound to a WMI object, the change will cause a
		///    disconnect from the original WMI object and a later re-bind using the new
		///    options.
		/// </remarks>
		/// <example>
		///    ManagementObject o = new ManagementObject("MyClass.Name='foo'"); //creates
		///    a default options object
		///    o.Options = new ObjectGetOptions(null, true); //replaces the default with a
		///    custom options object, which in this case requests retrieving amended qualifiers
		///    along with the WMI object.
		/// </example>
		/// <value>
		/// Options specifying how to get this object
		/// </value>
		public ObjectGetOptions Options 
		{
			get 
			{ return options; } 
			set 
			{
				if (null != value)
				{
					ObjectGetOptions oldOptions = options;
					options = (ObjectGetOptions)value.Clone();

					if (null != oldOptions)
						oldOptions.IdentifierChanged -= new IdentifierChangedEventHandler(HandleIdentifierChange);

					//register for change events in this object
					options.IdentifierChanged += new IdentifierChangedEventHandler(HandleIdentifierChange);
					//the options property has changed so fire event
					FireIdentifierChanged();
				}
				else
					throw new ArgumentNullException();
			}
		}

		/// <summary>
		///    The path to this object's class
		/// </summary>
		/// <value>
		///    A ManagementPath object.
		/// </value>
		/// <remarks>
		///    This property is read-only.
		/// </remarks>
		/// <example>
		///    ManagementObject o = new
		///    ManagementObject("MyClass.Name='foo'"); ManagementClass c = new ManagementClass(o.ClassPath);
		///    //gets the class definition for the object above.
		/// </example>
		/// <value>
		/// The path to this object's class
		/// </value>
		public override ManagementPath ClassPath 
		{ 
			get 
			{ 
				Object serverName = null;
				Object scopeName = null;
				Object className = null;
				int propertyType = 0;
				int propertyFlavor = 0;

				if (PutButNotGot)
				{
					Get();
					PutButNotGot = false;
				}
			
				Initialize();

				int status = (int)ManagementStatus.NoError;

				status = wbemObject.Get_("__SERVER", 0, ref serverName, ref propertyType, ref propertyFlavor);
				
				if (status >= 0)
				{
					status = wbemObject.Get_("__NAMESPACE", 0, ref scopeName, ref propertyType, ref propertyFlavor);
					
					if (status >= 0)
					{
						status = wbemObject.Get_("__CLASS", 0, ref className, ref propertyType, ref propertyFlavor);
					}
				}

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				ManagementPath classPath = new ManagementPath();

				// Some of these may throw if they are NULL
				try 
				{
					classPath.Server = (string)serverName;
					classPath.NamespacePath = (string)scopeName;
					classPath.ClassName = (string)className;
				} 
				catch (Exception) {}

				return classPath;
			} 
		}

		//
		//Methods
		//

		//******************************************************
		//Get
		//******************************************************
		/// <summary>
		///    <para>Used to bind to the management object</para>
		/// </summary>
		/// <remarks>
		///    <para>This method is invoked implicitly at the
		///       first attempt to get or set information to the WMI object. It can also be
		///       invoked explicitly by the user at their discretion to better control the timing
		///       and manner of the retrieval.</para>
		/// </remarks>
		/// <example>
		///    <p>ManagementObject o = new 
		///       ManagementObject("MyClass.Name='foo'"); </p>
		///    <p>string s = o["SomeProperty"]; //this
		///       causes an implicit Get(). </p>
		///    <p>or :</p>
		///    <p>ManagementObject o= new ManagementObject("MyClass.Name=
		///       'foo'");</p>
		///    <p>o.Get(); //explicitly </p>
		///    <p>string s = o["SomeProperty"]; //now it's faster because we already got the
		///       object.</p>
		/// </example>
		public void Get()
		{
			IWbemClassObjectFreeThreaded tempObj = null;

			Initialize(); // this may throw

			if ((null == path) || (String.Empty == path.Path))
				throw new InvalidOperationException();
			else
			{
				ObjectGetOptions gOptions = 
					(null == options) ? new ObjectGetOptions() : options;
				
				SecurityHandler securityHandler = null;
				int status						= (int)ManagementStatus.NoError;

				try
				{
					securityHandler = scope.GetSecurityHandler();

					status = scope.GetIWbemServices().GetObject_(
															path.RelativePath, 
															gOptions.Flags, 
															gOptions.GetContext(),
															out tempObj,
															IntPtr.Zero);
				
					if (status < 0)
					{
						if ((status & 0xfffff000) == 0x80041000)
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
						else
							Marshal.ThrowExceptionForHR(status);
					}
				} 
				finally
				{
					if (securityHandler != null)
						securityHandler.Reset();
				}

				wbemObject = tempObj;
			}
		}

		//******************************************************
		//Get
		//******************************************************
		/// <summary>
		///    <para>Used to bind to the management object asynchronously</para>
		/// </summary>
		/// <param name='watcher'>The object to receive the results of this operation as events</param>
		/// <remarks>
		///    <para>This method will issue the request to get
		///       the object and return immediately. The results of the operation will then be
		///       delivered through events being fired on the watcher object provided.</para>
		/// </remarks>
		/// <example>
		///    <p>ManagementObject o = new ManagementObject("MyClass.Name='foo'");</p>
		///    <p>MyHandler h = new MyHandler();</p>
		///    <p>ManagementOperationObserver ob = new ManagementOperationObserver();</p>
		///    <p>ob.Completed += new CompletedEventHandler (h.Done);</p>
		///    <p>o.Get(ob);</p>
		///    <p>while (!h.Completed)</p>
		///    <p> System.Threading.Thread.Sleep (1000);</p>
		///    <p>//Here we can use the object</p>
		///    <p>Console.WriteLine(o["SomeProperty"]);</p>
		///    <p>public class MyHandler</p>
		///    <p>{</p>
		///    <p> private bool completed = false;</p>
		///    <p> public void Done(object sender, CompletedEventArgs e)</p>
		///    <p> {</p>
		///    <p> Console.WriteLine("async Get 
		///       completed !");</p>
		///    <p> completed = true;</p>
		///    <p> }</p>
		///    <p> public bool Completed { </p>
		///    <p> get {return 
		///       completed;}</p>
		///    <p> }</p>
		/// </example>
		public void Get(ManagementOperationObserver watcher)
		{
			Initialize(); // this may throw

			if ((null == path) || (String.Empty == path.Path))
				throw new InvalidOperationException();
			else if (null == watcher)
				throw new ArgumentNullException("watcher");
			else
			{
				IWbemServices wbemServices = scope.GetIWbemServices();

				WmiGetEventSink sink = watcher.GetNewGetSink(
					scope, 
					null, 
					this);

				ObjectGetOptions o = (null == options) 
					? new ObjectGetOptions() : (ObjectGetOptions)options.Clone();

				// If someone has registered for progress, make sure we flag it
				if (watcher.HaveListenersForProgress)
					o.SendStatus = true;

				SecurityHandler securityHandler = null;
				int status						= (int)ManagementStatus.NoError;

				try
				{
					securityHandler = scope.GetSecurityHandler();

					status = wbemServices.GetObjectAsync_(
												path.RelativePath,
												o.Flags,
												o.GetContext(),
												sink.Stub);
				
					if (status < 0)
					{
						if ((status & 0xfffff000) == 0x80041000)
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
						else
							Marshal.ThrowExceptionForHR(status);
					}
				} 
				finally
				{
					watcher.RemoveSink(sink);
					if (securityHandler != null)
						securityHandler.Reset();
				}
			}
		}

		//******************************************************
		//GetRelated 
		//****************************************************
		/// <summary>
		///    <para>Gets a collection of objects related (associators) to this object</para>
		/// </summary>
		/// <remarks>
		///    <para>This operation is equivalent to an "associators of" query where the ResultClass = relatedClass</para>
		/// </remarks>
		/// <example>
		///    ManagementObject o = new ManagementObject("Win32_Service='Alerter'");
		///    foreach(ManagementBaseObject b in o.GetRelated())
		///    Console.WriteLine("Object related to Alerter service :
		///    ",b.Path);
		/// </example>
		public ManagementObjectCollection GetRelated()
		{
			return GetRelated((string)null);
		}

		//******************************************************
		//GetRelated 
		//****************************************************
		/// <summary>
		///    <para>Gets a collection of objects related (associators) to this object</para>
		/// </summary>
		/// <param name='relatedClass'>Class of related objects </param>
		/// <remarks>
		///    <para>This operation is equivalent to an "associators of" query where the ResultClass = relatedClass</para>
		/// </remarks>
		/// <example>
		///    ManagementObject o = new ManagementObject("Win32_Service='Alerter'");
		///    foreach(ManagementBaseObject b in o.GetRelated("Win32_Service")
		///    Console.WriteLine("Service related to the Alerter
		///    service {0} is {1}", b["Name"], b["State"]);
		/// </example>
		public ManagementObjectCollection GetRelated(
			string relatedClass) 
		{ 
			return GetRelated(relatedClass, null, null, null, null, null, false, null); 
		}


		//******************************************************
		//GetRelated 
		//****************************************************
		/// <summary>
		/// Gets a collection of objects related (associators) to this object
		/// </summary>
		/// <param name="relatedClass"> The class of the related objects </param>
		/// <param name="relationshipClass"> The relationship class of interest </param>
		/// <param name="relationshipQualifier"> The qualifier required to be present on the relationship class </param>
		/// <param name="relatedQualifier"> The qualifier required to be present on the related class </param>
		/// <param name="relatedRole"> The role that the related class is playing in the relationship </param>
		/// <param name="thisRole"> The role that this class is playing in the relationship </param>
		/// <param name="classDefinitionsOnly"> Return only class definitions for the instances that match the query </param>
		/// <param name="options"> Extended options for how to execute the query </param>
		/// <remarks> 
		/// This operation is equivalent to an "associators of" query where the ResultClass = relatedClass
		/// </remarks>
		public ManagementObjectCollection GetRelated(
			string relatedClass,
			string relationshipClass,
			string relationshipQualifier,
			string relatedQualifier,
			string relatedRole,
			string thisRole,
			bool classDefinitionsOnly,
			EnumerationOptions options)
		{

			if ((null == path) || (String.Empty == path.Path))
				throw new InvalidOperationException();
			
			Initialize(); // this may throw

			IEnumWbemClassObject enumWbem = null;
			EnumerationOptions o = (null != options) ? options : new EnumerationOptions();
			RelatedObjectQuery q = new RelatedObjectQuery(
				path.Path, 
				relatedClass,
				relationshipClass, 
				relationshipQualifier,
				relatedQualifier, relatedRole, 
				thisRole, classDefinitionsOnly);
            

			//Make sure the EnumerateDeep flag bit is turned off because it's invalid for queries
			o.EnumerateDeep = true; //note this turns the FLAG to 0 !!

			SecurityHandler securityHandler = null;
			int status						= (int)ManagementStatus.NoError;

			try
			{
				securityHandler = scope.GetSecurityHandler();

				status = scope.GetIWbemServices().ExecQuery_(
														q.QueryLanguage, 
														q.QueryString, 
														o.Flags, 
														o.GetContext(), 
														out enumWbem);

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				securityHandler.Secure(enumWbem);
			}
			finally
			{
				if (securityHandler != null)
					securityHandler.Reset();
			}

			//Create collection object
			return new ManagementObjectCollection(scope, o, enumWbem);
		}


		//******************************************************
		//GetRelated 
		//****************************************************
		/// <summary>
		/// Gets a collection of objects related (associators) to this object
		/// This is done in an asynchronous fashion. This call returns immediately, and
		/// a delegate is called when results are available.
		/// </summary>
		/// <param name="watcher"> The object to use to return results </param>
		/// <remarks> 
		/// This operation is equivalent to an "associators of" query where the ResultClass = relatedClass
		/// </remarks>
		public void GetRelated(
			ManagementOperationObserver watcher)
		{
			GetRelated(watcher, (string)null);
		}

		//******************************************************
		//GetRelated 
		//****************************************************
		/// <summary>
		/// Gets a collection of objects related (associators) to this object
		/// </summary>
		/// <param name="watcher"> The object to use to return results </param>
		/// <param name="relatedClass"> Class of related objects </param>
		/// <remarks> 
		/// This operation is equivalent to an "associators of" query where the ResultClass = relatedClass
		/// </remarks>
		public void GetRelated(
			ManagementOperationObserver watcher, 
			string relatedClass) 
		{
			GetRelated(watcher, relatedClass, null, null, null, null, null, false, null);
		}

			
		//******************************************************
		//GetRelated 
		//****************************************************
		/// <summary>
		/// Gets a collection of objects related (associators) to this object
		/// </summary>
		/// <param name="watcher"> The object to use to return results </param>
		/// <param name="relatedClass"> The class of the related objects </param>
		/// <param name="relationshipClass"> The relationship class of interest </param>
		/// <param name="relationshipQualifier"> The qualifier required to be present on the relationship class </param>
		/// <param name="relatedQualifier"> The qualifier required to be present on the related class </param>
		/// <param name="relatedRole"> The role that the related class is playing in the relationship </param>
		/// <param name="thisRole"> The role that this class is playing in the relationship </param>
		/// <param name="classDefinitionsOnly"> Return only class definitions for the instances that match the query </param>
		/// <param name="options"> Extended options for how to execute the query </param>
		/// <remarks> 
		/// This operation is equivalent to an "associators of" query where the ResultClass = relatedClass
		/// </remarks>
		public void GetRelated(
			ManagementOperationObserver watcher, 
			string relatedClass,
			string relationshipClass,
			string relationshipQualifier,
			string relatedQualifier,
			string relatedRole,
			string thisRole,
			bool classDefinitionsOnly,
			EnumerationOptions options)
		{
			if ((null == path) || (String.Empty == path.Path))
				throw new InvalidOperationException();

			Initialize(); // this may throw

			if (null == watcher)
				throw new ArgumentNullException("watcher");
			else
			{
				WmiEventSink sink = watcher.GetNewSink(
					scope, 
					null);
			
				// Ensure we switch off ReturnImmediately as this is invalid for async calls
				EnumerationOptions o = (null != options) 
					? (EnumerationOptions)options.Clone() : new EnumerationOptions();
				o.ReturnImmediately = false;

				// If someone has registered for progress, make sure we flag it
				if (watcher.HaveListenersForProgress)
					o.SendStatus = true;

				RelatedObjectQuery q = new RelatedObjectQuery(path.Path, relatedClass,
					relationshipClass, relationshipQualifier,
					relatedQualifier, relatedRole, 
					thisRole, classDefinitionsOnly);
            

				//Make sure the EnumerateDeep flag bit is turned off because it's invalid for queries
				o.EnumerateDeep = true; //note this turns the FLAG to 0 !!
				
				SecurityHandler securityHandler	= null;
				int status						= (int)ManagementStatus.NoError;

				try
				{
					securityHandler = scope.GetSecurityHandler();

					status = scope.GetIWbemServices().ExecQueryAsync_(
															q.QueryLanguage, 
															q.QueryString, 
															o.Flags, 
															o.GetContext(), 
															sink.Stub);

					if (status < 0)
					{
						if ((status & 0xfffff000) == 0x80041000)
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
						else
							Marshal.ThrowExceptionForHR(status);
					}
				} 
				finally
				{
					watcher.RemoveSink(sink);
					securityHandler.Reset();
				}
			}
		}

		//*******************************************************************
		//GetRelationships
		//*******************************************************************
		/// <summary>
		///	Gets a collection of associations to this object 
		/// </summary>
		/// <remarks> 
		/// This operation is equivalent to a "references of" query
		/// </remarks>
		public ManagementObjectCollection GetRelationships()
		{
			return GetRelationships((string)null);
		}

		//*******************************************************************
		//GetRelationships
		//*******************************************************************
		/// <summary>
		///	Gets a collection of associations to this object 
		/// </summary>
		/// <param name="relationshipClass"> Selects which associations to include </param>
		/// <remarks> 
		/// This operation is equivalent to a "references of" query where the AssocClass = relationshipClass
		/// </remarks>
		public ManagementObjectCollection GetRelationships(
			string relationshipClass)
		{ 
			return GetRelationships(relationshipClass, null, null, false, null); 
		}

			
		//*******************************************************************
		//GetRelationships
		//*******************************************************************
		/// <summary>
		///	Gets a collection of associations to this object 
		/// </summary>
		/// <param name="relationshipClass"> The type of relationship of interest </param>
		/// <param name="relationshipQualifier"> The qualifier to be present on the relationship </param>
		/// <param name="thisRole"> The role of this object in the relationship </param>
		/// <param name="classDefinitionsOnly"> Return only the class definitions for the result set </param>
		/// <param name="options"> Extended options for the query execution </param>
		/// <remarks> 
		/// This operation is equivalent to a "references of" query with possibly all the extensions.
		/// </remarks>
		public ManagementObjectCollection GetRelationships(		
			string relationshipClass,
			string relationshipQualifier,
			string thisRole,
			bool classDefinitionsOnly,
			EnumerationOptions options)
		{
			if ((null == path) || (String.Empty == path.Path))
				throw new InvalidOperationException();
			
			Initialize(); // this may throw

			IEnumWbemClassObject enumWbem = null;
			EnumerationOptions o = 
				(null != options) ? options : new EnumerationOptions();
			RelationshipQuery q = new RelationshipQuery(path.Path, relationshipClass,  
				relationshipQualifier, thisRole, classDefinitionsOnly);
            

			//Make sure the EnumerateDeep flag bit is turned off because it's invalid for queries
			o.EnumerateDeep = true; //note this turns the FLAG to 0 !!

			SecurityHandler securityHandler = null;
			int status						= (int)ManagementStatus.NoError;

			try
			{
				securityHandler = scope.GetSecurityHandler();

				status = scope.GetIWbemServices().ExecQuery_(
													q.QueryLanguage, 
													q.QueryString, 
													o.Flags, 
													o.GetContext(), 
													out enumWbem);

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				securityHandler.Secure(enumWbem);
			}
			finally
			{
				if (securityHandler != null)
					securityHandler.Reset();
			}

			//Create collection object
			return new ManagementObjectCollection(scope, o, enumWbem);
		}


		//*******************************************************************
		//GetRelationships
		//*******************************************************************
		/// <summary>
		///	Gets a collection of associations to this object 
		/// </summary>
		/// <param name="watcher"> The object to use to return results </param>
		/// <remarks> 
		/// This operation is equivalent to a "references of" query
		/// </remarks>
		public void GetRelationships(
			ManagementOperationObserver watcher)
		{
			GetRelationships(watcher, (string)null);
		}

		//*******************************************************************
		//GetRelationships
		//*******************************************************************
		/// <summary>
		///	Gets a collection of associations to this object 
		/// </summary>
		/// <param name="watcher"> The object to use to return results </param>
		/// <param name="relationshipClass"> Selects which associations to include </param>
		/// <remarks> 
		/// This operation is equivalent to a "references of" query where the AssocClass = relationshipClass
		/// </remarks>
		public void GetRelationships(
			ManagementOperationObserver watcher, 
			string relationshipClass)
		{
			GetRelationships(watcher, relationshipClass, null, null, false, null);
		}
		
		
		//*******************************************************************
		//GetRelationships
		//*******************************************************************
		/// <summary>
		///	Gets a collection of associations to this object 
		/// </summary>
		/// <param name="watcher"> The object to use to return results </param>
		/// <param name="relationshipClass"> The type of relationship of interest </param>
		/// <param name="relationshipQualifier"> The qualifier to be present on the relationship </param>
		/// <param name="thisRole"> The role of this object in the relationship </param>
		/// <param name="classDefinitionsOnly"> Return only the class definitions for the result set </param>
		/// <param name="options"> Extended options for the query execution </param>
		/// <remarks> 
		/// This operation is equivalent to a "references of" query with possibly all the extensions.
		/// </remarks>
		public void GetRelationships(
			ManagementOperationObserver watcher, 
			string relationshipClass,
			string relationshipQualifier,
			string thisRole,
			bool classDefinitionsOnly,
			EnumerationOptions options)
		{
			if ((null == path)  || (String.Empty == path.Path))
				throw new InvalidOperationException();
			if (null == watcher)
				throw new ArgumentNullException("watcher");
			else
			{
				Initialize(); // this may throw
				WmiEventSink sink = watcher.GetNewSink(scope, null);
			
				// Ensure we switch off ReturnImmediately as this is invalid for async calls
				EnumerationOptions o = 
					(null != options) ? (EnumerationOptions)options.Clone() : 
					new EnumerationOptions();
				o.ReturnImmediately = false;
				
				// If someone has registered for progress, make sure we flag it
				if (watcher.HaveListenersForProgress)
					o.SendStatus = true;

				RelationshipQuery q = new RelationshipQuery(path.Path, relationshipClass,
					relationshipQualifier, thisRole, classDefinitionsOnly);
				
				
				//Make sure the EnumerateDeep flag bit is turned off because it's invalid for queries
				o.EnumerateDeep = true; //note this turns the FLAG to 0 !!

				SecurityHandler securityHandler = null;
				int status						= (int)ManagementStatus.NoError;

				try
				{
					securityHandler = scope.GetSecurityHandler();

					status = scope.GetIWbemServices().ExecQueryAsync_(
															q.QueryLanguage, 
															q.QueryString, 
															o.Flags, 
															o.GetContext(), 
															sink.Stub);
				
					if (status < 0)
					{
						if ((status & 0xfffff000) == 0x80041000)
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
						else
							Marshal.ThrowExceptionForHR(status);
					}
				}
				finally
				{
					watcher.RemoveSink(sink);
					if (securityHandler != null)
						securityHandler.Reset();
				}
			}
		}

		//******************************************************
		//Put
		//******************************************************
		/// <summary>
		/// Commits the changes to this object
		/// </summary>
		public ManagementPath Put()
		{ 
			return Put((PutOptions) null); 
		}


		//******************************************************
		//Put
		//******************************************************
		/// <summary>
		/// Commits the changes to this object
		/// </summary>
		/// <param name="options"> Options for how to commit the changes </param>
		public ManagementPath Put(PutOptions options)
		{
			ManagementPath newPath = null;
			Initialize();
			PutOptions o = (null != options) ? options : new PutOptions();

			IWbemServices wbemServices = scope.GetIWbemServices();

			//
			// Must do this convoluted allocation since the IWbemServices ref IWbemCallResult
			// has been redefined to be an IntPtr.  Due to the fact that it wasn't possible to
			// pass NULL for the optional argument.
			//
			IntPtr ppwbemCallResult			= IntPtr.Zero;
			IntPtr pwbemCallResult			= IntPtr.Zero;
			IWbemCallResult wbemCallResult	= null;
			SecurityHandler securityHandler	= null;
			int status						= (int)ManagementStatus.NoError;

			try
			{
				securityHandler = scope.GetSecurityHandler();
				
				ppwbemCallResult = Marshal.AllocHGlobal(IntPtr.Size);
				Marshal.WriteIntPtr(ppwbemCallResult, IntPtr.Zero);		// Init to NULL.

				if (IsClass)
					status = wbemServices.PutClass_(
						wbemObject, 
						o.Flags | (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_RETURN_IMMEDIATELY, 
						o.GetContext(), 
						ppwbemCallResult);
				else
					status = wbemServices.PutInstance_(
						wbemObject, 
						o.Flags | (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_RETURN_IMMEDIATELY, 
						o.GetContext(), 
						ppwbemCallResult);
					
				// Keep this statement here; otherwise, there'll be a leak in error cases.
				pwbemCallResult = Marshal.ReadIntPtr(ppwbemCallResult);

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				wbemCallResult = (IWbemCallResult)Marshal.GetObjectForIUnknown(pwbemCallResult);
				securityHandler.Secure(wbemCallResult);
				newPath = GetPath(wbemCallResult);

				if (IsClass)
					newPath.RelativePath = ClassName;
			} 
			finally
			{
				if (securityHandler != null)
					securityHandler.Reset();
				
				if (ppwbemCallResult != IntPtr.Zero)					// Cleanup from allocations above.
					Marshal.FreeHGlobal(ppwbemCallResult);
				
				if (pwbemCallResult != IntPtr.Zero)
					Marshal.Release(pwbemCallResult);
				
				if (wbemCallResult != null)
					Marshal.ReleaseComObject(wbemCallResult);
			}

			//Set the flag that tells the object that we've put it, so that a refresh is 
			//triggered when an operation that needs this is invoked (CreateInstance, Derive).
			putButNotGot = true;
			
			// Update our path to address the object just put. Note that
			// we do this in such a way as to NOT trigger the setting of this
			// ManagementObject into an unbound state
			path.SetRelativePath(newPath.RelativePath);

			return newPath;
		}

		private ManagementPath GetPath(IWbemCallResult callResult)
		{
			ManagementPath newPath = null;
			int status = (int)ManagementStatus.NoError;

			try
			{
				//
				// Obtain the path from the call result.
				//
				string resultPath = null;

				status = callResult.GetResultString_(
					(int)tag_WBEM_TIMEOUT_TYPE.WBEM_INFINITE, 
					out resultPath);
						
				if (status >= 0)
				{
					newPath = new ManagementPath(path.Path);
					newPath.RelativePath = resultPath;
				}
				else
				{
					//
					// That didn't work. Use the path in the object instead.
					//
					object pathValue = GetPropertyValue("__PATH");

					// No path? Try Relpath?
					if (pathValue != null)
						newPath = new ManagementPath((string)pathValue);
					else
					{
						pathValue = GetPropertyValue("__RELPATH");

						if (pathValue != null)
						{
							newPath = new ManagementPath(path.Path);
							newPath.RelativePath = (string)pathValue;
						}
					}
				}

			} 
			catch {}

			if (newPath == null)
				newPath = new ManagementPath();

			return newPath;
		}

		/// <summary>
		///    <para>Commits the changes to this object, asynchronously.</para>
		/// </summary>
		/// <param name='watcher'>a ManagementOperationObserver object used to handle the progress and results of the asynchronous operation</param>
		public void Put(ManagementOperationObserver watcher)
		{
			Put(watcher, null);
		}

		/// <summary>
		///    <para>Commits the changes to this object asynchronously and
		///       using the specified options</para>
		/// </summary>
		/// <param name='watcher'>a ManagementOperationObserver object used to handle the progress and results of the asynchronous operation</param>
		/// <param name=' options'>a PutOptions object used to specify additional options for the commit operation</param>
		public void Put(ManagementOperationObserver watcher, PutOptions options)
		{
			if (null == watcher)
				throw new ArgumentNullException("watcher");
			else
			{
				Initialize();

				PutOptions o = (null == options) ?
					new PutOptions() : (PutOptions)options.Clone();
				
				// If someone has registered for progress, make sure we flag it
				if (watcher.HaveListenersForProgress)
					o.SendStatus = true;

				IWbemServices wbemServices = scope.GetIWbemServices();
				WmiEventSink sink = watcher.GetNewPutSink(scope, 
					o.Context, scope.Path.NamespacePath, ClassName);

				// Add ourselves to the watcher so we can update our state
				sink.InternalObjectPut += 
					new InternalObjectPutEventHandler(this.HandleObjectPut);

				SecurityHandler securityHandler	= null;
				// Assign to error initially to insure internal event handler cleanup
				// on non-management exception.
				int status						= (int)ManagementStatus.Failed;

				try
				{
					securityHandler = scope.GetSecurityHandler();

					if (IsClass)
						status = wbemServices.PutClassAsync_(	
							wbemObject, 
							o.Flags, 
							o.GetContext(),
							sink.Stub);
					else
						status = wbemServices.PutInstanceAsync_(
							wbemObject, 
							o.Flags, 
							o.GetContext(),
							sink.Stub);
				
					if (status < 0)
					{
						if ((status & 0xfffff000) == 0x80041000)
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
						else
							Marshal.ThrowExceptionForHR(status);
					}
				}
				finally
				{
					if (status < 0)
						sink.InternalObjectPut -= new InternalObjectPutEventHandler(this.HandleObjectPut);
					watcher.RemoveSink(sink);
					if (securityHandler != null)
						securityHandler.Reset();
				}
			}
		}

		internal void HandleObjectPut(object sender, InternalObjectPutEventArgs e)
		{
			try 
			{
				if (sender is WmiEventSink) 
				{
					((WmiEventSink)sender).InternalObjectPut -= new InternalObjectPutEventHandler(this.HandleObjectPut);
					putButNotGot = true;
					path.SetRelativePath(e.Path.RelativePath);
				}
			} 
			catch {}
		}

		//******************************************************
		//CopyTo
		//******************************************************
		/// <summary>
		/// Copies this object to a different location
		/// </summary>
		/// <param name="path"> The path to which the object should be copied </param>
		public ManagementPath CopyTo(ManagementPath path)
		{
			return CopyTo(path,(PutOptions)null);
		}

		/// <summary>
		/// Copies this object to a different location
		/// </summary>
		/// <param name="path"> The path to which the object should be copied </param>
		public ManagementPath CopyTo(string path)
		{
			return CopyTo(new ManagementPath(path), (PutOptions)null);
		}
		
		/// <summary>
		/// Copies this object to a different location
		/// </summary>
		/// <param name="path">The path to which the object should be copied</param>
		/// <param name="options">Options for how the object should be put</param>
		public ManagementPath CopyTo(string path, PutOptions options)
		{
			return CopyTo(new ManagementPath(path), options);
		}

		/// <summary>
		/// Copies this object to a different location
		/// </summary>
		/// <param name="path">The path to which the object should be copied</param>
		/// <param name="options">Options for how the object should be put</param>
		public ManagementPath CopyTo(ManagementPath path, PutOptions options)
		{
			Initialize();

			ManagementScope destinationScope = null;
			
			// Build a scope for our target destination
			destinationScope = new ManagementScope(path, scope);
			destinationScope.Initialize();

			PutOptions o = (null != options) ? options : new PutOptions();
			IWbemServices wbemServices = destinationScope.GetIWbemServices();
			ManagementPath newPath = null;

			//
			// TO-DO : This code is almost identical to Put - should consolidate.
			//
			// Must do this convoluted allocation since the IWbemServices ref IWbemCallResult
			// has been redefined to be an IntPtr.  Due to the fact that it wasn't possible to
			// pass NULL for the optional argument.
			//
			IntPtr ppwbemCallResult			= IntPtr.Zero;
			IntPtr pwbemCallResult			= IntPtr.Zero;
			IWbemCallResult wbemCallResult	= null;
			SecurityHandler securityHandler	= null;
			int status						= (int)ManagementStatus.NoError;

			try 
			{
				securityHandler = destinationScope.GetSecurityHandler();

				ppwbemCallResult = Marshal.AllocHGlobal(IntPtr.Size);
				Marshal.WriteIntPtr(ppwbemCallResult, IntPtr.Zero);		// Init to NULL.

				if (IsClass)
					status = wbemServices.PutClass_(
						wbemObject, 
						o.Flags | (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_RETURN_IMMEDIATELY, 
						o.GetContext(), 
						ppwbemCallResult);
				else
					status = wbemServices.PutInstance_(
						wbemObject, 
						o.Flags | (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_RETURN_IMMEDIATELY, 
						o.GetContext(), 
						ppwbemCallResult);

				// Keep this statement here; otherwise, there'll be a leak in error cases.
				pwbemCallResult = Marshal.ReadIntPtr(ppwbemCallResult);

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				//Use the CallResult to retrieve the resulting object path
				wbemCallResult = (IWbemCallResult)Marshal.GetObjectForIUnknown(pwbemCallResult);
				securityHandler.Secure(wbemCallResult);
				newPath = GetPath(wbemCallResult);
				newPath.NamespacePath = path.NamespacePath;
			} 
			finally
			{
				if (securityHandler != null)
					securityHandler.Reset();
				
				if (ppwbemCallResult != IntPtr.Zero)					// Cleanup from allocations above.
					Marshal.FreeHGlobal(ppwbemCallResult);
				
				if (pwbemCallResult != IntPtr.Zero)
					Marshal.Release(pwbemCallResult);
				
				if (wbemCallResult != null)
					Marshal.ReleaseComObject(wbemCallResult);
			}

			return newPath;
		}

		/// <summary>
		///    <para>Copies this object to a different location asynchronously</para>
		/// </summary>
		/// <param name='watcher'>The object that will receive the results of this operation</param>
		/// <param name='path'>A ManagementPath object specifying the path to which the object should be copied</param>
		public void CopyTo(ManagementOperationObserver watcher, ManagementPath path)
		{
			CopyTo(watcher, path, null);
		}

		/// <summary>
		///    <para>Copies this object to a different location asynchronously</para>
		/// </summary>
		/// <param name='watcher'>The object that will receive the results of this operation</param>
		/// <param name='path'>a string representing the path to which the object should be copied</param>
		public void CopyTo(ManagementOperationObserver watcher, string path)
		{
			CopyTo(watcher, new ManagementPath(path), null);
		}

		/// <summary>
		/// Copies this object to a different location asynchronously
		/// </summary>
		/// <param name="watcher">The object that will receive the results of this operation</param>
		/// <param name="path">The path to which the object should be copied</param>
		/// <param name="options">Options for how the object should be put</param>
		public void CopyTo(ManagementOperationObserver watcher, string path, PutOptions options)
		{
			CopyTo(watcher, new ManagementPath(path), options);
		}

		/// <summary>
		/// Copies this object to a different location asynchronously
		/// </summary>
		/// <param name="watcher">The object that will receive the results of this operation</param>
		/// <param name="path">The path to which the object should be copied</param>
		/// <param name="options">Options for how the object should be put</param>
		public void CopyTo(ManagementOperationObserver watcher, ManagementPath path, PutOptions options)
		{
			if (null == watcher)
				throw new ArgumentNullException("watcher");
			else
			{
				Initialize();
				ManagementScope destinationScope = null;

				destinationScope = new ManagementScope(path, scope);
				destinationScope.Initialize();

				PutOptions o = (null != options) ? (PutOptions) options.Clone() : new PutOptions();

				// If someone has registered for progress, make sure we flag it
				if (watcher.HaveListenersForProgress)
					o.SendStatus = true;

				WmiEventSink sink = watcher.GetNewPutSink(destinationScope, o.Context, 
					path.NamespacePath, ClassName);
				IWbemServices destWbemServices = destinationScope.GetIWbemServices();

				SecurityHandler securityHandler = null;
				int status						= (int)ManagementStatus.NoError;

				try
				{
					securityHandler = destinationScope.GetSecurityHandler();

					if (IsClass)
						status = destWbemServices.PutClassAsync_(
														wbemObject, 
														o.Flags, 
														o.GetContext(), 
														sink.Stub);
					else
						status = destWbemServices.PutInstanceAsync_(
														wbemObject, 
														o.Flags, 
														o.GetContext(), 
														sink.Stub);

					if (status < 0)
					{
						if ((status & 0xfffff000) == 0x80041000)
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
						else
							Marshal.ThrowExceptionForHR(status);
					}
				} 
				finally
				{
					watcher.RemoveSink(sink);
					if (securityHandler != null)
						securityHandler.Reset();
				}
			}
		}

		//******************************************************
		//Delete
		//******************************************************
		/// <summary>
		/// Deletes this object
		/// </summary>
		public void Delete()
		{ 
			Delete((DeleteOptions) null); 
		}
		
		/// <summary>
		/// Deletes this object
		/// </summary>
		/// <param name="options"> Options for how to delete the object </param>
		public void Delete(DeleteOptions options)
		{
			if ((null == path) || (String.Empty == path.Path))
				throw new InvalidOperationException();
			
			Initialize();
			DeleteOptions o = (null != options) ? options : new DeleteOptions();
			IWbemServices wbemServices = scope.GetIWbemServices();

			SecurityHandler securityHandler = null;
			int status						= (int)ManagementStatus.NoError;

			try
			{
				securityHandler = scope.GetSecurityHandler();

				if (IsClass)
					status = wbemServices.DeleteClass_(
						path.RelativePath, 
						o.Flags, 
						o.GetContext(), 
						IntPtr.Zero);
				else
					status = wbemServices.DeleteInstance_(
						path.RelativePath, 
						o.Flags,
						o.GetContext(), 
						IntPtr.Zero);
			
				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
			}
			finally
			{
				if (securityHandler != null)
					securityHandler.Reset();
			}
		}


		/// <summary>
		/// Deletes this object
		/// </summary>
		/// <param name="watcher">The object that will receive the results of this operation</param>
		public void Delete(ManagementOperationObserver watcher)
		{
			Delete(watcher, null);
		}

		/// <summary>
		/// Deletes this object
		/// </summary>
		/// <param name="watcher">The object that will receive the results of this operation</param>
		/// <param name="options">Options for how to delete the object</param>
		public void Delete(ManagementOperationObserver watcher, DeleteOptions options)
		{
			if ((null == path) || (String.Empty == path.Path))
				throw new InvalidOperationException();
			else if (null == watcher)
				throw new ArgumentNullException("watcher");
			else
			{
				Initialize();
				DeleteOptions o = (null != options) ? (DeleteOptions) options.Clone() : new DeleteOptions();

				// If someone has registered for progress, make sure we flag it
				if (watcher.HaveListenersForProgress)
					o.SendStatus = true;

				IWbemServices wbemServices = scope.GetIWbemServices();
				WmiEventSink sink = watcher.GetNewSink(scope, null);

				SecurityHandler securityHandler = null;
				int status						= (int)ManagementStatus.NoError;

				try
				{
					securityHandler = scope.GetSecurityHandler();

					if (IsClass)
						status = wbemServices.DeleteClassAsync_(
							path.RelativePath, 
							o.Flags, 
							o.GetContext(),
							sink.Stub);
					else
						status = wbemServices.DeleteInstanceAsync_(
							path.RelativePath, 
							o.Flags, 
							o.GetContext(),
							sink.Stub);

					if (status < 0)
					{
						if ((status & 0xfffff000) == 0x80041000)
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
						else
							Marshal.ThrowExceptionForHR(status);
					} 
				}
				finally
				{
					watcher.RemoveSink(sink);
					if (securityHandler != null)
						securityHandler.Reset();
				}
			}
		}

		//******************************************************
		//InvokeMethod
		//******************************************************
		/// <summary>
		///    <para> 
		///       Invokes a method on this object.</para>
		/// </summary>
		/// <param name='methodName'>Name of the method to execute </param>
		/// <param name='args'>Array containing parameter values </param>
		/// <returns>
		///    The value returned by the method.
		/// </returns>
		/// <remarks>
		///    <para>If the method is static, the execution
		///       should still succeed.</para>
		/// </remarks>
		public Object InvokeMethod(string methodName, Object[] args) 
		{ 
			object result = null;

			if ((null == path) || (String.Empty == path.Path))
				throw new InvalidOperationException();
			else if (null == methodName)
				throw new ArgumentNullException("methodName");
			else
			{
				Initialize();
			
				// Map args into a inparams structure
				ManagementBaseObject inParameters;
				IWbemClassObjectFreeThreaded inParametersClass, outParametersClass;
				GetMethodParameters(methodName, out inParameters, 
					out inParametersClass, out outParametersClass);

				MapInParameters(args, inParameters, inParametersClass);

				// Call ExecMethod
				ManagementBaseObject outParameters = 
					InvokeMethod(methodName, inParameters, null);

				// Map outparams to args
				result = MapOutParameters(args, outParameters, outParametersClass);
			}

			return result;
		}

		//******************************************************
		//InvokeMethod
		//******************************************************
		/// <summary>
		///    Invokes a method asynchronously on this object.
		/// </summary>
		/// <param name='watcher'>The object to receive the results of the operation</param>
		/// <param name='methodName'>Name of the method to execute </param>
		/// <param name='args'>Array containing parameter values </param>
		/// <remarks>
		///    If the method is static, the execution
		///    should still succeed
		/// </remarks>
		public void InvokeMethod(
			ManagementOperationObserver watcher, 
			string methodName, 
			Object[] args) 
		{ 
			if ((null == path) || (String.Empty == path.Path))
				throw new InvalidOperationException();
			else if (null == watcher)
				throw new ArgumentNullException("watcher");
			else if (null == methodName)
				throw new ArgumentNullException("methodName");
			else
			{
				Initialize();
			
				// Map args into a inparams structure
				ManagementBaseObject inParameters;
				IWbemClassObjectFreeThreaded inParametersClass, outParametersClass;
				GetMethodParameters(methodName, out inParameters, 
					out inParametersClass,	out outParametersClass);

				MapInParameters(args, inParameters, inParametersClass);

				// Call the method
				InvokeMethod(watcher, methodName, inParameters, null);
			}
		}

		/// <summary>
		///    Invokes a method on the WMI object. The input and output
		///    parameters are represented as ManagementBaseObject objects.
		/// </summary>
		/// <param name='methodName'>The name of the method to execute</param>
		/// <param name=' inParameters'>a ManagementBaseObject holding the input parameters to the method</param>
		/// <param name=' options'>an InvokeMethodOptions object containing additional options for the execution of the method</param>
		/// <returns>
		///    A ManagementBaseObject containing the
		///    output parameters and return value of the executed method.
		/// </returns>
		public ManagementBaseObject InvokeMethod(
			string methodName, 
			ManagementBaseObject inParameters, 
			InvokeMethodOptions options)
		{
			ManagementBaseObject outParameters = null;
			
			if ((null == path) || (String.Empty == path.Path))
				throw new InvalidOperationException();
			else if (null == methodName)
				throw new ArgumentNullException("methodName");
			else
			{
				Initialize();
				InvokeMethodOptions o = (null != options) ? options : new InvokeMethodOptions();
				IWbemServices wbemServices = scope.GetIWbemServices();

				SecurityHandler securityHandler = null;
				int status						= (int)ManagementStatus.NoError;

				try
				{
					securityHandler = scope.GetSecurityHandler();

					IWbemClassObjectFreeThreaded inParams = (null == inParameters) ? null : inParameters.wbemObject;
					IWbemClassObjectFreeThreaded outParams = null;

					status = scope.GetIWbemServices().ExecMethod_(
						path.RelativePath, 
						methodName,
						o.Flags, 
						o.GetContext(),
						inParams,
						out outParams,
						IntPtr.Zero);

					if (status < 0)
					{
						if ((status & 0xfffff000) == 0x80041000)
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
						else
							Marshal.ThrowExceptionForHR(status);
					}

					outParameters = new ManagementBaseObject(outParams);
				} 
				finally
				{
					if (securityHandler != null)
						securityHandler.Reset();
				}
			}

			return outParameters;
		}

		/// <summary>
		///    <para>Invokes a method on this object asynchronously.</para>
		/// </summary>
		/// <param name='watcher'>a ManagementOperationObserver object used to handle the asynchronous execution's progress and results</param>
		/// <param name=' methodName'>the name of the method to be executed</param>
		/// <param name=' inParameters'><para>a ManagementBaseObject object containing the input parameters for the method</para></param>
		/// <param name=' options'>an InvokeMethodOptions object containing additional options used to execute the method</param>
		/// <remarks>
		///    This function invokes the method execution
		///    and returns. Progress and results are reported through events on the
		///    ManagementOperationObserver object.
		/// </remarks>
		public void InvokeMethod(
			ManagementOperationObserver watcher, 
			string methodName, 
			ManagementBaseObject inParameters, 
			InvokeMethodOptions options)
		{
			if ((null == path) || (String.Empty == path.Path))
				throw new InvalidOperationException();
			else if (null == watcher)
				throw new ArgumentNullException("watcher");
			else if (null == methodName)
				throw new ArgumentNullException("methodName");
			else
			{
				Initialize();
				InvokeMethodOptions o = (null != options) ? 
					(InvokeMethodOptions) options.Clone() : new InvokeMethodOptions();

				// If someone has registered for progress, make sure we flag it
				if (watcher.HaveListenersForProgress)
					o.SendStatus = true;
	
				WmiEventSink sink = watcher.GetNewSink(scope, null);

				SecurityHandler securityHandler = null;
				int status						= (int)ManagementStatus.NoError;

				try
				{
					securityHandler = scope.GetSecurityHandler();

					IWbemClassObjectFreeThreaded inParams = null;

					if (null != inParameters)
						inParams = inParameters.wbemObject;

					status = scope.GetIWbemServices().ExecMethodAsync_(
						path.RelativePath, 
						methodName,
						o.Flags, 
						o.GetContext(),
						inParams,
						sink.Stub);

					if (status < 0)
					{
						if ((status & 0xfffff000) == 0x80041000)
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
						else
							Marshal.ThrowExceptionForHR(status);
					} 
				}
				finally 
				{
					watcher.RemoveSink(sink);
					if (securityHandler != null)
						securityHandler.Reset();
				}
			}
		}
        
		//******************************************************
		//GetMethodParameters
		//******************************************************
		/// <summary>
		///    <para>Returns a ManagementBaseObject representing the list of input parameters for a method</para>
		/// </summary>
		/// <param name='methodName'>Name of the method </param>
		/// <returns>
		///    A ManagementBasedObject containing the
		///    input parameters to the method.
		/// </returns>
		/// <remarks>
		///    This function can be used to get the object
		///    containing the input parameters to a method, then fill the values in and pass
		///    this object to the InvokeMethod() call.
		/// </remarks>
		public ManagementBaseObject GetMethodParameters(
			string methodName)
		{
			ManagementBaseObject inParameters;
			IWbemClassObjectFreeThreaded dummy1, dummy2;
				
			GetMethodParameters(methodName, out inParameters, out dummy1, out dummy2);
			return inParameters;
		}

		private void GetMethodParameters(
			string methodName,
			out ManagementBaseObject inParameters,
			out IWbemClassObjectFreeThreaded inParametersClass,
			out IWbemClassObjectFreeThreaded outParametersClass)
		{
			inParameters = null;
			inParametersClass = null;
			outParametersClass = null;

			if (null == methodName)
				throw new ArgumentNullException("methodName");
			else
			{
				Initialize();

				// Do we have the class?
				if (null == wmiClass)
				{
					ManagementPath classPath = ClassPath;

					if ((null == classPath) || !(classPath.IsClass))
						throw new InvalidOperationException();
					else 
					{
						ManagementClass classObject = 
							new ManagementClass(scope, classPath, null);
						classObject.Get();
						wmiClass = classObject.wbemObject;
					}
				}

				int status = (int)ManagementStatus.NoError;

				// Ask it for the method parameters
				status = wmiClass.GetMethod_(methodName, 0, out inParametersClass, out outParametersClass);

				if (status >= 0)
				{
					// Hand out instances
					if (inParametersClass != null)
					{
						IWbemClassObjectFreeThreaded inParamsInstance = null;
						status = inParametersClass.SpawnInstance_(0, out inParamsInstance);

						if (status >= 0)
						{
							inParameters = new ManagementBaseObject(inParamsInstance);
						}
					}
				} 

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
			}
		}

		/// <summary>
		///    Creates a copy of this object.
		/// </summary>
		/// <returns>
		///    The copied object.
		/// </returns>
		public override Object Clone()
		{
			if (PutButNotGot)
			{
				Get();
				PutButNotGot = false;
			}

			Initialize();

			IWbemClassObjectFreeThreaded theClone	= null;
			int status					= (int)ManagementStatus.NoError;

			status = wbemObject.Clone_(out theClone);

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}

			return ManagementObject.GetManagementObject(theClone, this);
		}

		//******************************************************
		//ToString
		//******************************************************
		/// <summary>
		///    <para>Override of the default Object implementation.
		///       Returns the full path of the object</para>
		/// </summary>
		/// <returns>
		///    A string representing the fill path of
		///    the object.
		/// </returns>
		public override string ToString()
		{
			if (null != path)
				return path.Path;
			else
				return null;
		}

		internal override void Initialize()
		{
			bool needToGetObject = false;

			//If we're not connected yet, this is the time to do it... We lock
			//the state to prevent 2 threads simultaneously doing the same
			//connection
			lock (this)
			{
				// Make sure we have some kind of path if we get here. Note that
				// we don't use a set to the Path property since that would trigger
				// an IdentifierChanged event
				if (null == path)
				{
					path = new ManagementPath();
					path.IdentifierChanged += new IdentifierChangedEventHandler(HandleIdentifierChange);
				}

				//Have we already got this object
				if (!isBound)
					needToGetObject = true;

				if (null == scope)
				{
					// If our object has a valid namespace path, use that
					string nsPath = path.NamespacePath;

					// Set the scope - note that we do not set through
					// the Scope property since that would trigger an IdentifierChanged
					// event and reset isBound to false.
					if (0 < nsPath.Length)
						scope = new ManagementScope(nsPath);
					else
					{
						// Use the default constructor
						scope = new ManagementScope();
					}

					// Hook ourselves up to this scope for future change notifications
					scope.IdentifierChanged += new IdentifierChangedEventHandler(HandleIdentifierChange);
				}
				else if ((null == scope.Path) || scope.Path.IsEmpty)
				{
					// We have a scope but an empty path - use the object's path or the default
					string nsPath = path.NamespacePath;

					if (0 < nsPath.Length)
						scope.Path = new ManagementPath(nsPath);
					else
						scope.Path = ManagementPath.DefaultPath;
				}
			
				lock (scope)
				{
					if (!scope.IsConnected)
					{
						scope.Initialize(); 

						// If we have just connected, make sure we get the object
						needToGetObject = true;
					}

					if (needToGetObject)
					{
						// If we haven't set up any options yet, now is the time.
						// Again we don't use the set to the Options property
						// since that would trigger an IdentifierChangedEvent and
						// force isBound=false.
						if (null == options)
						{
							options = new ObjectGetOptions();
							options.IdentifierChanged += new IdentifierChangedEventHandler(HandleIdentifierChange);
						}

						IWbemClassObjectFreeThreaded tempObj = null;
						IWbemServices wbemServices = scope.GetIWbemServices();

						SecurityHandler securityHandler = null;
						int status						= (int)ManagementStatus.NoError;

						try
						{
							securityHandler = scope.GetSecurityHandler();

							string objectPath = null;
							string curPath = path.RelativePath;

							if (0 != curPath.CompareTo(String.Empty))
								objectPath = curPath;
							status = wbemServices.GetObject_(objectPath, options.Flags, options.GetContext(), out tempObj, IntPtr.Zero);

							if (status >= 0)
							{
								wbemObject = tempObj;

								//Getting the object succeeded, we are bound
								isBound = true;

								// now set the path from the "real" object
								object val = null;
								int dummy1 = 0, dummy2 = 0;

								status = wbemObject.Get_("__PATH", 0, ref val, ref dummy1, ref dummy2);

								if (status >= 0)
								{
									path = (System.DBNull.Value != val) ? (new ManagementPath((string)val)) : (new ManagementPath ());
									path.IdentifierChanged += new IdentifierChangedEventHandler(HandleIdentifierChange);
								}
							}

							if (status < 0)
							{
								if ((status & 0xfffff000) == 0x80041000)
									ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
								else
									Marshal.ThrowExceptionForHR(status);
							}
						}
						finally
						{
							if (securityHandler != null)
								securityHandler.Reset();
						}
					}
				}
			}
		}

		private void MapInParameters(
			object [] args, 
			ManagementBaseObject inParams,
			IWbemClassObjectFreeThreaded inParamsClass)
		{
			int status = (int)ManagementStatus.NoError;

			if (null != inParamsClass)
			{
				if ((null != args) && (0 < args.Length))
				{
					int maxIndex = args.GetUpperBound(0);
					int minIndex = args.GetLowerBound(0);
					int topId = maxIndex - minIndex;

					/*
					 * Iterate through the [in] parameters of the class to find
					 * the ID positional qualifier. We do this in the class because
					 * we cannot be sure that the qualifier will be propagated to
					 * the instance.
					 */

					status = inParamsClass.BeginEnumeration_
							((int)tag_WBEM_CONDITION_FLAG_TYPE.WBEM_FLAG_NONSYSTEM_ONLY);

					if (status >= 0)
					{
						object val = null;
						int dummy = 0;

						while (true) 
						{
							string propertyName = null;
							status = inParamsClass.Next_(0, ref propertyName, ref val, ref dummy, ref dummy);

							IWbemQualifierSetFreeThreaded qualifierSet = null;

							if (status >= 0)
							{
								if (null == propertyName)
									break;

								status = inParamsClass.GetPropertyQualifierSet_(propertyName, out qualifierSet);

								if (status >= 0)
								{
									object id = 0;
									qualifierSet.Get_(ID, 0, ref id, ref dummy);	// Errors intentionally ignored.
					
									// If the id is in range, map the value into the args array
									int idIndex = (int)id;
									if ((0 <= idIndex) && (topId >= idIndex))
										inParams[propertyName] = args [minIndex + idIndex];
								}
							}

							if (status < 0)
							{
								break;
							}
						}
					}

					if (status < 0)
					{
						if ((status & 0xfffff000) == 0x80041000)
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
						else
							Marshal.ThrowExceptionForHR(status);
					}
				}
			}
		}

		private object MapOutParameters(
			object [] args, 
			ManagementBaseObject outParams,
			IWbemClassObjectFreeThreaded outParamsClass)
		{
			object result = null;
			int maxIndex = 0, minIndex = 0, topId = 0;

			int status = (int)ManagementStatus.NoError;

			if (null != outParamsClass)
			{
				if ((null != args) && (0 < args.Length))
				{
					maxIndex = args.GetUpperBound(0);
					minIndex = args.GetLowerBound(0);
					topId = maxIndex - minIndex;
				}
				/*
					* Iterate through the [out] parameters of the class to find
					* the ID positional qualifier. We do this in the class because
					* we cannot be sure that the qualifier will be propagated to
					* the instance.
				*/

				status = outParamsClass.BeginEnumeration_ 
					((int)tag_WBEM_CONDITION_FLAG_TYPE.WBEM_FLAG_NONSYSTEM_ONLY);

				if (status >= 0)
				{
					object val = null;
					int dummy = 0;

					while (true) 
					{
						string propertyName = null;
						IWbemQualifierSetFreeThreaded qualifierSet = null;

						status = outParamsClass.Next_(0, ref propertyName, ref val, ref dummy, ref dummy);

						if (status >= 0)
						{
							if (null == propertyName)
								break;

							// Handle the result parameter separately
							if (propertyName.ToUpper() == RETURNVALUE)
							{
								result = outParams[RETURNVALUE];
							}
							else  // Shouldn't get here if no args!
							{
								status = outParamsClass.GetPropertyQualifierSet_(propertyName, out qualifierSet);

								if (status >= 0)
								{
									object id = 0;
									qualifierSet.Get_(ID, 0, ref id, ref dummy);	// Errors intentionally ignored.
				
									// If the id is in range, map the value into the args array
									int idIndex = (int)id;
									if ((0 <= idIndex) && (topId >= idIndex))
										args [minIndex + idIndex] = outParams[propertyName];
								}
							}
						}

						if (status < 0)
						{
							break;
						}
					}
				}

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
			}

			return result; 
		}

	}//ManagementObject
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\managementnamedvaluecollection.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using WbemClient_v1;
using System.Runtime.Serialization;

namespace System.Management 
{
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	/// This class is used to represent a collection of named values
	/// suitable for use as context information to WMI operations. The
	/// names are case-insensitive.
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class ManagementNamedValueCollection : NameObjectCollectionBase 
	{
		// Notification of when the content of this collection changes
		internal event IdentifierChangedEventHandler IdentifierChanged;

		//Fires IdentifierChanged event
		private void FireIdentifierChanged()
		{
			if (IdentifierChanged != null)
				IdentifierChanged(this, null);
		}

		//default constructor
		/// <summary>
		///    <para>Default constructor for a named value collection. Creates 
		///       an empty collection.</para>
		/// </summary>
		public ManagementNamedValueCollection() {
        }


        public ManagementNamedValueCollection(SerializationInfo info, StreamingContext context) : base(info, context)
        {
        }

		/// <summary>
		///    <para>Internal method to return an IWbemContext representation
		///    of the named value collection.</para>
		/// </summary>
		internal IWbemContext GetContext() 
		{
			IWbemContext wbemContext = null;

			// Only build a context if we have something to put in it
			if (0 < Count)
			{
				int status = (int)ManagementStatus.NoError;

				try {
					wbemContext = (IWbemContext) new WbemContext ();

					foreach (string name in this)
					{
						object val = base.BaseGet(name);
						status = wbemContext.SetValue_ (name, 0, ref val);
						if ((status & 0x80000000) != 0)
						{
							break;
						}
					}
				} catch {}	// BUGBUG : why ignore error?
			}
			
			return wbemContext;
		}

		/// <summary>
		///    <para>Adds a single named value to the collection.</para>
		/// </summary>
		/// <param name=' name'>The name of the new value.</param>
		/// <param name=' value'>The value to be associated with the name.</param>
		public void Add (string name, object value) 
		{
			// Remove any old entry
			try 
			{
				base.BaseRemove (name);
			} catch {}

			base.BaseAdd (name, value);
			FireIdentifierChanged ();
		}

		/// <summary>
		///    <para>Removes a single named value from the collection.  
		///    If the collection does not contain an element with the 
		///    specified name, the collection remains unchanged and no 
		///    exception is thrown.</para>
		/// </summary>
		/// <param name=' name'>The name of the value to be removed.</param>
		public void Remove (string name)
		{
			base.BaseRemove (name);
			FireIdentifierChanged ();
		}

        /// <summary>
		///    <para>Removes all entries from the collection.</para>
		/// </summary>
		public void RemoveAll () 
		{
			base.BaseClear ();
			FireIdentifierChanged ();
		}

		/// <summary>
		///    <para>Creates a clone of this collection. Individual values are
		///    cloned. If a value does not support cloning then a NotSupportedException
		///    is thrown. </para>
		/// </summary>
		public ManagementNamedValueCollection Clone ()
		{
			ManagementNamedValueCollection nvc = new ManagementNamedValueCollection();

			foreach (string name in this)
			{
				// If we can clone the value, do so. Otherwise throw.
				object val = base.BaseGet (name);

				if (null != val)
				{
					Type valueType = val.GetType ();
					
					if (valueType.IsByRef)
					{
						try 
						{
							object clonedValue = ((ICloneable)val).Clone ();
							nvc.Add (name, clonedValue);
						}
						catch 
						{
							throw new NotSupportedException ();
						}
					}
					else
					{
						nvc.Add (name, val);
					}
				}
				else
					nvc.Add (name, null);
			}

			return nvc;
		}

		/// <summary>
		///    <para>Returns the value associated with the specified name from this collection.</para>
		/// </summary>
		/// <param name=' name'>The name of the value to be returned.</param>
		public object this[string name] {
			get { 
				return base.BaseGet(name);
            }
		}        
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\generator\wmigenerator\wmigenerator.cs ===
namespace System.Management
{
using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.IO;
using System.Reflection;
using System.Management;
using System.Collections;
using Microsoft.CSharp;
using Microsoft.VisualBasic;


/// <summary>
///    <para>An enum to list the languages the code generator 
///       generates the code</para>
/// </summary>
public enum CodeLanguage
{
	/// <summary>
	///    <para>Enum value for generating C# code</para>
	/// </summary>
	CSharp,
	/// <summary>
	///    <para>Enum value for generating Java script code</para>
	/// </summary>
	JScript,
	/// <summary>
	///    <para>Enum value for generating VB code</para>
	/// </summary>
	VB
};


/// <summary>
///    This class is used for the automatic generation of 
///    early bound managed code class for a given WMI class
/// </summary>
internal class ManagementClassGenerator
{
	private string	OriginalServer		= string.Empty;
	private string	OriginalNamespace	= string.Empty;
	private string	OriginalClassName	= string.Empty;
	private string	OriginalPath		= string.Empty;
	private bool	bSingletonClass		= false;
	private string	ExceptionString		= "Class name doesn't match.";
	private	bool	bUnsignedSupported	= true;
	private bool	bValueMapInt64		= false;
	private string	NETNamespace		= string.Empty;
	private const	int		DMTF_DATETIME_STR_LENGTH = 25;
	private	bool	bDateConversionFunctionsAdded = false;




	private ManagementClass classobj;
	private ICodeGenerator cg;
	private TextWriter tw = null;
	private string genFileName = string.Empty;
	private CodeTypeDeclaration cc;
	private CodeTypeDeclaration ccc;
	private CodeTypeDeclaration ecc;
	private CodeTypeDeclaration EnumObj;
	private CodeCommentStatement ccs;
	private CodeNamespace cn;
	private CodeMemberProperty  cmp;
	private CodeConstructor cctor;
	private CodeMemberField cf;
	private CodeObjectCreateExpression coce;
	private CodeSnippetExpression cle;
	private CodeParameterDeclarationExpression cpde;
	private CodeIndexerExpression cie;
	private CodeMemberField cmf;
	private CodeMemberMethod cmm;
	private CodePropertyReferenceExpression cpre;
	private CodeMethodInvokeExpression cmie;
	private CodeExpressionStatement cmis;
	private CodeConditionStatement cis;
	private CodeBinaryOperatorExpression cboe;
	private CodeIterationStatement cfls;
	private CodeAttributeArgument caa;
	private CodeAttributeDeclaration cad;
	private ConnectionOptions		cop;

	private ArrayList arrKeyType	= new ArrayList(5);
	private ArrayList arrKeys		= new ArrayList(5);
	private ArrayList BitMap		= new ArrayList(5);
	private ArrayList BitValues		= new ArrayList(5);
	private ArrayList ValueMap		= new ArrayList(5);
	private ArrayList Values		= new ArrayList(5);

	private SortedList PublicProperties = new SortedList(new CaseInsensitiveComparer());
	private SortedList PublicMethods	= new SortedList (new CaseInsensitiveComparer());
	private SortedList PublicNamesUsed	= new SortedList(new CaseInsensitiveComparer());
	private SortedList PrivateNamesUsed = new SortedList(new CaseInsensitiveComparer());

	/// <summary>
	///    <para>Constructor to construct a empty object</para>
	/// </summary>
	public ManagementClassGenerator()
	{
	}

	/// <summary>
	///    <para>OverLoaded consturctor. This constructor initializes the
	///       generator with the Managementclass passed</para>
	/// </summary>
	/// <param name='cls'>ManagementClass object for which the code is to be generated</param>
	public ManagementClassGenerator(ManagementClass cls)
	{
		classobj = cls;
	}

	/// <summary>
	///    <para> 
	///       Function which returns CodeTypeDeclaration for
	///       the given class.</para>
	/// </summary>
	/// <param name='bIncludeSystemClassinClassDef'>Boolean value to indicate if class to managing system properties has to be include</param>
	/// <param name='bSystemPropertyClass'>Boolean value to indicate if the code to be genereated is for class to manage System properties</param>
	/// <returns>
	///    <para>Returns the CodeTypeDeclaration for the WMI class</para>
	/// </returns>
	/// <remarks>
	///    <para>If bIncludeSystemClassinClassDef parameter is true
	///       then it adds the ManagementSystemProperties class inside the class defination of
	///       the class for the WMI class. This parameter is ignored if bSystemPropertyClass
	///       is true</para>
	/// </remarks>
	public CodeTypeDeclaration GenerateCode(bool includeSystemProperties ,bool systemPropertyClass)
	{
		CodeTypeDeclaration retType;

		if (systemPropertyClass == true)
		{
			//Initialize the public attributes . private variables
			InitilializePublicPrivateMembers();
			retType = GenerateSystemPropertiesClass();
		}
		else
		{
			CheckIfClassIsProperlyInitialized();
			InitializeCodeGeneration();
			retType = GetCodeTypeDeclarationForClass(includeSystemProperties);
		}

		return retType;
	}

	/// <summary>
	/// Function which Generates code for known type of providers ( ie C#, VB and JScript)
	/// and writes them to a file
	/// </summary>
	public bool GenerateCode(CodeLanguage lang ,String FilePath,String Namespace)
	{
		// check for proper arguments
		if (FilePath == null )
		{
			throw new ArgumentOutOfRangeException ("FilePath or codegenerator is null");
		}

		if (FilePath == string.Empty)
		{
			throw new ArgumentOutOfRangeException ("FilePath cannot be empty");
		}

		NETNamespace = Namespace;
		CheckIfClassIsProperlyInitialized();
		// Initialize Code Generator
		InitializeCodeGeneration();
	
		//Now create the filestream (output file)
		tw = new StreamWriter(new FileStream (FilePath,FileMode.Create));

		return GenerateAndWriteCode(lang);

	}

	/// <summary>
	/// Checks if mandatory properties are properly initializzed
	/// </summary>
	/// <returns>boolean value indicating the success of the method</returns>
	void CheckIfClassIsProperlyInitialized()
	{
		if (classobj == null)
		{
			if (OriginalNamespace == null || ( OriginalNamespace != null && OriginalNamespace == string.Empty))
			{
				throw new ArgumentOutOfRangeException ("Namespace not initialized");
			}
			
			if (OriginalClassName == null || ( OriginalClassName != null && OriginalClassName == string.Empty))
			{
				throw new ArgumentOutOfRangeException ("ClassName not initialized");
			}
		}
	}

	// Functions to set and get properties
	/// <summary>
	///    <para>Server</para>
	/// </summary>
	public string Server
	{
		get
		{
			return OriginalServer;
		}
		set
		{
			OriginalServer = value.ToUpper();
		}
	}

	/// <summary>
	///    <para>WMI Namespace</para>
	/// </summary>
	public string WMINamespace
	{
		get
		{
			return OriginalNamespace;
		}
		set
		{
			OriginalNamespace = value.ToUpper();
		}
	}

	/// <summary>
	///    <para>WMI class Name</para>
	/// </summary>
	public string ClassName
	{
		get
		{
			return OriginalClassName;
		}
		set
		{
			OriginalClassName = value.ToUpper();
			// set the object to null
			classobj = null;
		}
	}

	/// <summary>
	///    <para>Path of the WMI class</para>
	/// </summary>
	public string WMIPath
	{
		get
		{
			return OriginalPath;
		}
		set
		{
			OriginalPath = value.ToUpper();
		}
	}

	/// <summary>
	///    <para>Check if the language supports Unsigned</para>
	/// </summary>
	public bool UnsignedSupported
	{
		get
		{
			return bUnsignedSupported;
		}
		set
		{
			bUnsignedSupported = value;
		}
	}

	/// <summary>
	///    <para>[To be supplied.]</para>
	/// </summary>
	public string Username
	{
		get
		{
			if (cop != null)
			{
				return cop.Username;
			}
			else
				return null;
		}
		set
		{
			if (cop == null)
			{
				cop = new ConnectionOptions();
			}
			cop.Username = value;
		}
	}

	/// <summary>
	///    <para>[To be supplied.]</para>
	/// </summary>
	public string Password
	{
		set
		{
			if (cop == null)
			{
				cop = new ConnectionOptions();
			}
			cop.Password = value;
		}
	}
	
	/// <summary>
	///    <para>[To be supplied.]</para>
	/// </summary>
	public string Authority
	{
		get
		{
			if (cop != null)
			{
				return cop.Authority;
			}
			else
				return null;
		}
		set
		{
			if (cop == null)
			{
				cop = new ConnectionOptions();
			}
			cop.Authority = value;
		}
	}

	private void InitializeCodeGeneration()
	{

		//First try to get the class object for the given WMI Class.
		//If we cannot get it then there is no point in continuing 
		//as we won't have any information for the code generation.
		InitializeClassObject();

		//Initialize the public attributes . private variables
		InitilializePublicPrivateMembers();

		//First form the namespace for the generated class.
		//The namespace will look like System.Wmi.Root.Cimv2.Win32
		//for the path \\root\cimv2:Win32_Service and the class name will be
		//Service.
		ProcessNamespaceAndClassName();

		//First we will sort out the different naming collision that might occur 
		//in the generated code.
		ProcessNamingCollisions();
	}

	/// <summary>
 	/// This function will generate the code. This is the function which 
	/// should be called for generating the code.
	/// </summary>
	/// <param name="Language"> The target language for the generated code.
	///		The supported Values as of now are 
	///				"VB" - Visual Basic
	///				"JS" - JavaScript
	///				"CS" - CSharp
	///		If you pass an invalid parameter, it will be defaulted to CSharp </param>
	/// <param name="FilePath"> This is the path where you want the 
	///		generated code to reside</param>
    CodeTypeDeclaration GetCodeTypeDeclarationForClass(bool bIncludeSystemClassinClassDef)
    {
		try
		{
			//Create type defination for the class
			cc = new CodeTypeDeclaration (PrivateNamesUsed["GeneratedClassName"].ToString());
			// Adding Component as base class so as to enable drag and drop
			cc.BaseTypes.Add(new CodeTypeReference(PrivateNamesUsed["ComponentClass"].ToString()));

			//Generate the code for defaultNamespace
			//public string defNamespace {
			//	get {
			//			return (<defNamespace>);
			//		}
			//}
			GeneratePublicReadOnlyProperty(PublicNamesUsed["NamespaceProperty"].ToString(),"String",
				OriginalNamespace,false,true);

			//Generate the code for defaultClassName
			//public string defClassName {
			//	get {
			//			return (<defClassName>);
			//		}
			//}
			GeneratePublicReadOnlyProperty(PublicNamesUsed["ClassNameProperty"].ToString(),"String",
				OriginalClassName,false,true);

			//public SystemPropertiesClass _SystemProps{
			//	get {
			//			return (privSysProps);
			//		}
			//}
			GeneratePublicReadOnlyProperty(PublicNamesUsed["SystemPropertiesProperty"].ToString(),PublicNamesUsed["SystemPropertiesClass"].ToString(),
				PrivateNamesUsed["SystemPropertiesObject"].ToString(),true,true);

			//public wmiObjectClass _Object{
			//	get {
			//			return (privWmiObject);
			//		}
			//}
			GeneratePublicReadOnlyProperty(PublicNamesUsed["LateBoundObjectProperty"].ToString(),PublicNamesUsed["LateBoundClass"].ToString(),
				PrivateNamesUsed["LateBoundObject"].ToString(),true,false);

			//public ManagementScope Scope {
			//	get {
			//			return privScope;
			//		}
			//	set {
			//			privScope = value;
			//		}
			//}
			GeneratePublicProperty(PublicNamesUsed["ScopeProperty"].ToString(),PublicNamesUsed["ScopeClass"].ToString(),
				new CodePropertyReferenceExpression(
				new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString())
				,"Scope"),true);


			//public bool AutoCommit {
			//	get {
			//			return AutoCommitProp;;
			//		}
			//	set {
			//			AutoCommitProp; = value;
			//		}
			//}

			GeneratePublicProperty(PublicNamesUsed["AutoCommitProperty"].ToString(),"Boolean",
				new CodeSnippetExpression(PrivateNamesUsed["AutoCommitProperty"].ToString()),true);

			//public ManagementPath Path {
			//	get {
			//			return privWmiObject.Path;
			//		}
			//	set {
			//			if (String.Compare(value.ClassName,className,true) != 0)
			//				throw new ArgumentException("Class name doesn\'t match.");
			//			privWmiObject.Path = value;
			//		}
			//}
			GeneratePathProperty();

			//Now generate properties of the WMI Class
			GenerateProperties();

			//Now Generate static ConstructPath()
			GenerateConstructPath();
			
			//Now create the default constructor
			GenerateDefaultConstructor();

			if (bSingletonClass == true)
			{
				//Now Generate a constructor which accepts only the scope
				GenerateConstructorWithScope();

				//Now Generate a constructor which accepts only the get options
				GenerateConstructorWithOptions();

				//Now generate a constructor which accepts both scope and options
				GenerateConstructorWithScopeOptions();
			}
			else
			{
				//Now create the constuctor which accepts the key values
				GenerateConstructorWithKeys();

				//Also generate a constructor which accepts a scope and keys
				GenerateConstructorWithScopeKeys();

				//Now create constructor with path object
				GenerateConstructorWithPath();

				//Now generate constructor with Path & Options
				GenerateConstructorWithPathOptions();

				//Now Generate a constructor with scope & path
				GenerateConstructorWithScopePath();

				//Now Generate the GetInstances()
				GenerateGetInstancesWithNoParameters();

				//Now Generate the GetInstances(condition)
				GenerateGetInstancesWithCondition();

				//Now Generate the GetInstances(propertylist)
				GenerateGetInstancesWithProperties();

				//Now Generate the GetInstances(condition,propertylist)
				GenerateGetInstancesWithWhereProperties();

				//Now Generate the GetInstances(scope)
				GenerateGetInstancesWithScope();

				//Now Generate the GetInstances(scope,condition)
				GenerateGetInstancesWithScopeCondition();

				//Now Generate the GetInstances(scope,propertylist)
				GenerateGetInstancesWithScopeProperties();

				//Now Generate the GetInstances(scope,condition,propertylist)
				GenerateGetInstancesWithScopeWhereProperties();

				//Generate the Collection Class
				GenerateCollectionClass();
			}

			//Now Generate the constructor with path,scope,options
			GenerateConstructorWithScopePathOptions();

			//Now generate Constructor with latebound Object
			GenarateConstructorWithLateBound();

			//Now Enumerate all the methods
			GenerateMethods();

			//Now declare the private class variables
			//private Wmi_SystemProps SystemProps
			GeneratePrivateMember(PrivateNamesUsed["SystemPropertiesObject"].ToString(),PublicNamesUsed["SystemPropertiesClass"].ToString());

			//private WmiObject privObject
			GeneratePrivateMember(PrivateNamesUsed["LateBoundObject"].ToString(),PublicNamesUsed["LateBoundClass"].ToString());

			//private Internal AutoCommitProperty
			GeneratePrivateMember(PrivateNamesUsed["AutoCommitProperty"].ToString(),"Boolean" ,new CodePrimitiveExpression(true));

			//Also add the custom attribute to the generated class

			//ZINA: commenting this out since all persistence description mechanism
			//has completely changed in Beta2 (see http://net/change_details.aspx?change%5Fid=512)
			//Uncomment the lines below once the method implementation is fixed.

/*			caa = new CodeAttributeArgument();
			caa.Value = new CodeTypeOfExpression(PrivateNamesUsed["ConverterClass"].ToString());
			cad = new CodeAttributeDeclaration();
			cad.Name = PublicNamesUsed["TypeConverter"].ToString();
			cad.Arguments.Add(caa);
			cc.CustomAttributes = new CodeAttributeDeclarationCollection();
			cc.CustomAttributes.Add(cad);
*/
			if (bIncludeSystemClassinClassDef)
			{
				cc.Members.Add(GenerateSystemPropertiesClass());
			}
			return cc;
		}
		catch (Exception exc)
		{
			throw (exc);
		}
    }

	bool GenerateAndWriteCode(CodeLanguage lang)
	{

		if (InitializeCodeGenerator(lang) == false)
		{
			return false;
		}

		//Now Initialize the code class for generation
		InitializeCodeTypeDeclaration();

		// Call this function to create CodeTypeDeclaration for the WMI class
		GetCodeTypeDeclarationForClass(true);

		//As we have finished the class definition, generate the class code NOW!!!!!
		cn.Types.Add (cc);

		//Now generate the Type Converter class also
//		cn.Types.Add(GenerateTypeConverterClass());

		//throw new Exception("about to call GenerateCodeFromNamespace");

		cg.GenerateCodeFromNamespace (cn, tw, new CodeGeneratorOptions());

		//tw.Flush();
		tw.Close();

		return true;

	}

/// <summary>
/// Function for initializing the class object that will be used to get all the 
/// method and properties of the WMI Class for generating the code.
/// </summary>
	private void InitializeClassObject()
	{
		//First try to connect to WMI and get the class object.
		// If it fails then no point in continuing
		try
		{
			// If object is not initialized by the constructor
			if (classobj == null)
			{
				ManagementPath thePath;
				if (OriginalPath != string.Empty)
				{
					thePath = new ManagementPath(OriginalPath);
					//				classobj = new ManagementClass (OriginalPath);
				}
				else
				{
					thePath = new ManagementPath();
					if (OriginalServer != String.Empty)
						thePath.Server = OriginalServer;
					thePath.ClassName = OriginalClassName;
					thePath.NamespacePath = OriginalNamespace;
					//				classobj = new ManagementClass (thePath);

					/*
					throw new Exception("OriginalServer is " + OriginalServer +
						" OriginalNamespace is " + OriginalNamespace +
						" OriginalClassName is " + OriginalClassName +
						" results in " + thePath.Path);
						*/
				}

				if (cop != null && cop.Username != string.Empty)
				{
					ManagementScope MgScope = new ManagementScope(thePath,cop);
					classobj = new ManagementClass(MgScope,thePath,null);
				}
				else
				{
					classobj = new ManagementClass (thePath);
				}
			}
			else
			{
				// Get the common properties
				ManagementPath thePath = classobj.Path;
				OriginalServer = thePath.Server;//.ToUpper();
				OriginalClassName = thePath.ClassName;//.ToUpper();
				OriginalNamespace = thePath.NamespacePath;//.ToUpper();

				char[] arrString = OriginalNamespace.ToCharArray();

				// Remove the server from the namespace
				if (arrString.Length >= 2 && arrString[0] == '\\' && arrString[1] == '\\')
				{
					bool bStart = false;
					int Len = OriginalNamespace.Length;
					OriginalNamespace = string.Empty;
					for (int i = 2 ; i < Len ; i++)
					{
						if (bStart == true)
						{
							OriginalNamespace = OriginalNamespace + arrString[i];
						}
						else
						if (arrString[i] == '\\')
						{
							bStart = true;
						}
					}
				}

			}
				//throw new Exception("classobj's path is " + classobj.Path.Path);				
			
			try
			{
				classobj.Get();
			}
			catch(ManagementException)
			{
				throw ;
			}
			//By default all classes are non-singleton(???)
			bSingletonClass = false;			
			foreach (QualifierData q in classobj.Qualifiers)
			{
				if (String.Compare(q.Name,"singleton",true) == 0)
				{
					//This is a singleton class
					bSingletonClass = true;
					break;
				}
			}
		}
		catch(Exception e)
		{
			//TODO: Decide what to do here???????
			Console.WriteLine("Exception Occured on Create.Reason [{0}]\n\nStack Trace : \n{1}",e.Message,e.StackTrace);
			throw e;
		}
	}
	/// <summary>
	/// This functrion initializes the public attributes and private variables 
	/// list that will be used in the generated code. 
	/// </summary>
	void InitilializePublicPrivateMembers()
	{
		//Initialize the public members
		PublicNamesUsed.Add("SystemPropertiesProperty","SystemProperties");
		PublicNamesUsed.Add("LateBoundObjectProperty","LateBoundObject");
		PublicNamesUsed.Add("NamespaceProperty","OriginatingNamespace");
		PublicNamesUsed.Add("ClassNameProperty","ManagementClassName");
		PublicNamesUsed.Add("ScopeProperty","Scope");
		PublicNamesUsed.Add("PathProperty","Path");
		PublicNamesUsed.Add("SystemPropertiesClass","ManagementSystemProperties");
		PublicNamesUsed.Add("LateBoundClass","ManagementObject");
		PublicNamesUsed.Add("PathClass","ManagementPath");
		PublicNamesUsed.Add("ScopeClass","ManagementScope");
		PublicNamesUsed.Add("QueryOptionsClass","EnumerationOptions");
		PublicNamesUsed.Add("GetOptionsClass","ObjectGetOptions");
		PublicNamesUsed.Add("ArgumentExceptionClass","ArgumentException");
		PublicNamesUsed.Add("QueryClass","SelectQuery");
		PublicNamesUsed.Add("ObjectSearcherClass","ManagementObjectSearcher");
		PublicNamesUsed.Add("FilterFunction","GetInstances");
		PublicNamesUsed.Add("ConstructPathFunction","ConstructPath");
		PublicNamesUsed.Add("TypeConverter","TypeConverter");
		PublicNamesUsed.Add("AutoCommitProperty","AutoCommit");
		PublicNamesUsed.Add("CommitMethod","CommitObject");
		PublicNamesUsed.Add("ManagementClass","ManagementClass");
		PublicNamesUsed.Add("NotSupportedExceptClass","NotSupportedException");

		//Initialize the Private Members
		PrivateNamesUsed.Add("SystemPropertiesObject","PrivateSystemProperties");	
		PrivateNamesUsed.Add("LateBoundObject","PrivateLateBoundObject");			
		PrivateNamesUsed.Add("AutoCommitProperty","AutoCommitProp");
		PrivateNamesUsed.Add("Privileges","EnablePrivileges");
		PrivateNamesUsed.Add("ComponentClass","Component");
		PrivateNamesUsed.Add("ScopeParam","mgmtScope");
		PrivateNamesUsed.Add("ToDateTimeMethod","ToDateTime");
		PrivateNamesUsed.Add("ToDMTFTimeMethod","ToDMTFTime");
		PrivateNamesUsed.Add("NullRefExcep","NullReferenceException");
		
		
	}

/// <summary>
/// This function will solve the naming collisions that might occur
/// due to the collision between the local objects of the generated
/// class and the properties/methos of the original WMI Class.
/// </summary>
	void ProcessNamingCollisions()
	{
		if (classobj.Properties != null)
		{
			foreach(PropertyData prop in classobj.Properties)
			{
				PublicProperties.Add(prop.Name,prop.Name);
			}
		}

		if (classobj.Methods != null)
		{
			foreach(MethodData meth in classobj.Methods)
			{
				PublicMethods.Add(meth.Name,meth.Name);
			}
		}

		int nIndex;

		//Process the collisions here
		//We will check each public names with the property names here.
		foreach(String s in PublicNamesUsed.Values)
		{
			nIndex = IsContainedIn(s,ref PublicProperties);
			if ( nIndex != -1)
			{
				//We had found a collision with a public property
				//So we will resolve the collision by changing the property name 
				//and continue
				PublicProperties.SetByIndex(nIndex,ResolveCollision(s,false));
				continue;
			}
			
			nIndex = IsContainedIn(s,ref PublicMethods);
			if (nIndex != -1)
			{
				//We had found a collision with a public method
				//So we will resolve the collision by changing the method name 
				//and continue
				PublicMethods.SetByIndex(nIndex,ResolveCollision(s,false));
				continue;
			}
		}

		//Now we will check for collision against private variables
		foreach(String s in PublicProperties.Values)
		{
			nIndex = IsContainedIn(s,ref PrivateNamesUsed);
			if (nIndex != -1)
			{
				//We had found a collision with a public property
				//So we will resolve the collision by changing the private name 
				//and continue
				PrivateNamesUsed.SetByIndex(nIndex,ResolveCollision(s,false));
			}
		}
		
		foreach(String s in PublicMethods.Values)
		{
			nIndex = IsContainedIn(s,ref PrivateNamesUsed);
			if (nIndex != -1)
			{
				//We had found a collision with a public method
				//So we will resolve the collision by changing the private name 
				//and continue
				PrivateNamesUsed.SetByIndex(nIndex,ResolveCollision(s,false));
			}
		}

		//Now we will create the CollectionClass and Enumerator Class names as they are dependent on the
		//generated class name and the generated class name might have changed due to collision
		string strTemp = PrivateNamesUsed["GeneratedClassName"].ToString()+"Collection";
		PrivateNamesUsed.Add("CollectionClass",ResolveCollision(strTemp,true));

		strTemp = PrivateNamesUsed["GeneratedClassName"].ToString()+"Enumerator";
		PrivateNamesUsed.Add("EnumeratorClass",ResolveCollision(strTemp,true));
}

	/// <summary>
	/// This function is used to resolve (actually generate a new name) collision
	/// between the generated class properties/variables with WMI methods/properties.
	/// This function safely assumes that there will be atleast one string left 
	/// in the series prop0, prop1 ...prop(maxInt) . Otherwise this function will
	/// enter an infinite loop. May be we can avoid this through something, which 
	/// i will think about it later
	/// </summary>
	/// <param name="inString"> </param>
	private String ResolveCollision(string inString,bool bCheckthisFirst)
	{
		string strTemp = inString;
		bool bCollision = true;
		int k = -1;
		if (bCheckthisFirst == false)
		{
			k++;
			strTemp = strTemp + k.ToString();
		}

		while(bCollision == true)
		{
			if (IsContainedIn(strTemp,ref PublicProperties) == -1)
			{
				if (IsContainedIn(strTemp,ref PublicMethods) == -1)
				{
					if (IsContainedIn(strTemp,ref PublicNamesUsed) == -1)
					{
						if (IsContainedIn(strTemp,ref PrivateNamesUsed) == -1)
						{
							//So this is not colliding with anything.
							bCollision = false;
							break;
						}
					}
				}
			}
			
			k++;
			strTemp = strTemp + k.ToString();
		}
		return strTemp;
	}

/// <summary>
/// This function processes the WMI namespace and WMI classname and converts them to
/// the namespace used to generate the class and the classname.
/// </summary>
/// <param name="strNs"> </param>
/// <param name="strClass"> </param>
	private void ProcessNamespaceAndClassName()
	{
		string strClass = string.Empty;
		string strNs = string.Empty;

		// if Namespace is not alread set then construct the namespace
		if (NETNamespace == String.Empty)
		{
			strNs = OriginalNamespace;
			strNs = strNs.Replace ('\\','.');
			strNs = "System.Management." + strNs;
		}
		else
		{
			strNs = NETNamespace;
		}

		if (OriginalClassName.IndexOf('_') > 0)
		{
			strClass = OriginalClassName.Substring(0,OriginalClassName.IndexOf('_'));
			// if Namespace is not alread set then construct the namespace
			if (NETNamespace == String.Empty)
			{
				strNs += ".";
				strNs += strClass;
			}
			//Now trim the class name without the first '_'
			strClass = OriginalClassName.Substring(OriginalClassName.IndexOf('_')+1);
		}
		else
		{
			strClass = OriginalClassName;
		}

		PrivateNamesUsed.Add("GeneratedClassName",strClass);
		PrivateNamesUsed.Add("GeneratedNamespace",strNs);
		PrivateNamesUsed.Add("ConverterClass",strClass+"Converter");
	}


	
	private void InitializeCodeTypeDeclaration()
	{
		//Comment statement //Early Bound Managed Code Wrapper for WMI class <WMiClass>  
		ccs = new CodeCommentStatement (String.Format ("Early Bound Managed Code Wrapper for WMI class {0}",OriginalClassName));
		cg.GenerateCodeFromStatement (ccs, tw, new CodeGeneratorOptions());

		//Now add the import statements
		cn = new CodeNamespace(PrivateNamesUsed["GeneratedNamespace"].ToString());
		cn.Imports.Add (new CodeNamespaceImport("System"));
		cn.Imports.Add (new CodeNamespaceImport("System.ComponentModel"));
		cn.Imports.Add (new CodeNamespaceImport("System.Management"));
		cn.Imports.Add(new CodeNamespaceImport("System.Collections"));

	}
/// <summary>
/// This function generates the code for the read only property.
/// The generated code will be of the form
///		public &lt;propType&gt; &lt;propName&gt;{
///			get {
///					return (&lt;propValue&gt;);
///				}
///		}
/// </summary>
/// <param name="propName"> </param>
/// <param name="propType"> </param>
/// <param name="propValue"> </param>
	private void GeneratePublicReadOnlyProperty(string propName, string propType, object propValue,bool isLiteral,bool isBrowsable)
	{
		cmp = new CodeMemberProperty ();
		cmp.Name = propName;
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final ;
		cmp.Type = new CodeTypeReference(propType);

		caa = new CodeAttributeArgument();
		caa.Value = new CodePrimitiveExpression(isBrowsable);
		cad = new CodeAttributeDeclaration();
		cad.Name = "Browsable";
		cad.Arguments.Add(caa);
		cmp.CustomAttributes = new CodeAttributeDeclarationCollection();
		cmp.CustomAttributes.Add(cad);

		caa = new CodeAttributeArgument();
		caa.Value = new CodeSnippetExpression("DesignerSerializationVisibility.Hidden");
		cad = new CodeAttributeDeclaration();
		cad.Name = "DesignerSerializationVisibility";
		cad.Arguments.Add(caa);
		cmp.CustomAttributes.Add(cad);

		if (isLiteral == true)
		{
			cmp.GetStatements.Add (new CodeMethodReturnStatement (new CodeSnippetExpression(propValue.ToString())));
		}
		else
		{
			cmp.GetStatements.Add (new CodeMethodReturnStatement (new CodePrimitiveExpression(propValue)));
		}
		cc.Members.Add (cmp);
	}

	private void GeneratePublicProperty(string propName,string propType, CodeExpression Value,bool isBrowsable)
	{
		cmp = new CodeMemberProperty();
		cmp.Name = propName;
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmp.Type = new CodeTypeReference(propType);

		caa = new CodeAttributeArgument();
		caa.Value = new CodePrimitiveExpression(isBrowsable);
		cad = new CodeAttributeDeclaration();
		cad.Name = "Browsable";
		cad.Arguments.Add(caa);
		cmp.CustomAttributes = new CodeAttributeDeclarationCollection();
		cmp.CustomAttributes.Add(cad);

		// If the property is not Path then add an attribb DesignerSerializationVisibility
		// to indicate that the property is to be hidden for designer serilization.
		if (IsDesignerSerializationVisibilityToBeSet(propName))
		{
			caa = new CodeAttributeArgument();
			caa.Value = new CodeSnippetExpression("DesignerSerializationVisibility.Hidden");
			cad = new CodeAttributeDeclaration();
			cad.Name = "DesignerSerializationVisibility";
			cad.Arguments.Add(caa);
			cmp.CustomAttributes.Add(cad);
		}

		cmp.GetStatements.Add(new CodeMethodReturnStatement(Value));

		cmp.SetStatements.Add(new CodeAssignStatement(Value,
														new CodeSnippetExpression("value")));
		cc.Members.Add(cmp);

	}

	void GeneratePathProperty()
	{
		cmp = new CodeMemberProperty();
		cmp.Name = PublicNamesUsed["PathProperty"].ToString();
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmp.Type = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());

		caa = new CodeAttributeArgument();
		caa.Value = new CodePrimitiveExpression(true);
		cad = new CodeAttributeDeclaration();
		cad.Name = "Browsable";
		cad.Arguments.Add(caa);
		cmp.CustomAttributes = new CodeAttributeDeclarationCollection();
		cmp.CustomAttributes.Add(cad);

		cpre = new CodePropertyReferenceExpression(new CodeSnippetExpression(
														PrivateNamesUsed["LateBoundObject"].ToString()),
														"Path");

		cmp.GetStatements.Add(new CodeMethodReturnStatement(cpre));

		cis = new CodeConditionStatement();

		CodeExpression[] parms = new CodeExpression[]
			{
				new CodePropertyReferenceExpression(new CodeSnippetExpression("value"),"ClassName"),
				new CodeSnippetExpression(PublicNamesUsed["ClassNameProperty"].ToString()),
				new CodePrimitiveExpression(true)
			};

		cmie = new CodeMethodInvokeExpression(
						new CodeSnippetExpression("String"),
						"Compare",
						parms
						);

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = cmie;
		cboe.Right = new CodePrimitiveExpression(0);
		cboe.Operator = CodeBinaryOperatorType.IdentityInequality;
		cis.Condition = cboe;
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["ArgumentExceptionClass"].ToString());
		coce.Parameters.Add(new CodePrimitiveExpression(ExceptionString));
		cis.TrueStatements.Add(new CodeThrowExceptionStatement(coce));
		cmp.SetStatements.Add(cis);	
	
		cmp.SetStatements.Add(new CodeAssignStatement(cpre,
														new CodeSnippetExpression("value")));
		cc.Members.Add(cmp);
	}

/// <summary>
/// Function for generating the helper class "ManagementSystemProperties" which is 
/// used for seperating the system properties from the other properties. This is used 
/// just to make the drop down list in the editor to look good.
/// </summary>
	CodeTypeDeclaration GenerateSystemPropertiesClass()
	{
		CodeTypeDeclaration SysPropsClass = new CodeTypeDeclaration(PublicNamesUsed["SystemPropertiesClass"].ToString());

		//First create the constructor
		//	public ManagementSystemProperties(ManagementObject obj)

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cpde = new CodeParameterDeclarationExpression();
		cpde.Type = new CodeTypeReference(PublicNamesUsed["LateBoundClass"].ToString());
		cpde.Name = "ManagedObject";
		cctor.Parameters.Add(cpde);
		cctor.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString()),new CodeSnippetExpression("ManagedObject")));
		SysPropsClass.Members.Add(cctor);

		caa = new CodeAttributeArgument();
		caa.Value = new CodeTypeOfExpression (typeof(System.ComponentModel.ExpandableObjectConverter)) ;
		cad = new CodeAttributeDeclaration();
		cad.Name = PublicNamesUsed["TypeConverter"].ToString();
		cad.Arguments.Add(caa);
		SysPropsClass.CustomAttributes.Add(cad);

		char [] strPropTemp;
		char [] strPropName;
		int i = 0;

		foreach (PropertyData prop in classobj.SystemProperties)
		{
			cmp = new CodeMemberProperty ();
			//All properties are browsable by default.
			caa = new CodeAttributeArgument();
			caa.Value = new CodePrimitiveExpression(true);
			cad = new CodeAttributeDeclaration();
			cad.Name = "Browsable";
			cad.Arguments.Add(caa);
			cmp.CustomAttributes = new CodeAttributeDeclarationCollection();
			cmp.CustomAttributes.Add(cad);

			//Now we will have to find the occurance of the first character and trim all the characters before that
			strPropTemp = prop.Name.ToCharArray();
			for(i=0;i < strPropTemp.Length;i++)
			{
				if (Char.IsLetterOrDigit(strPropTemp[i]) == true)
				{
					break;
				}
			}
			if (i == strPropTemp.Length)
			{
				i = 0;
			}
			strPropName = new char[strPropTemp.Length - i];
			for(int j=i;j < strPropTemp.Length;j++)
			{
				strPropName[j - i] = strPropTemp[j];
			}
                        			
			cmp.Name = (new string(strPropName)).ToUpper(); //ConvertToTitleCase(new string(strPropName));
			cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
			cmp.Type = new CodeTypeReference(ConvertCIMType(prop.Type,prop.IsArray));

			cie = new CodeIndexerExpression(
				new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString()),
				new CodeExpression[] {new CodePrimitiveExpression(prop.Name)});

			cmp.GetStatements.Add (new CodeMethodReturnStatement (new CodeCastExpression(cmp.Type,cie)));
			SysPropsClass.Members.Add(cmp);
		}
		//private WmiObject _privObject
		cf = new CodeMemberField();
		cf.Name = PrivateNamesUsed["LateBoundObject"].ToString();
		cf.Attributes = MemberAttributes.Private | MemberAttributes.Final ;
		cf.Type = new CodeTypeReference(PublicNamesUsed["LateBoundClass"].ToString());
		SysPropsClass.Members.Add(cf);

		return SysPropsClass;

	}
/// <summary>
/// This function will enumerate all the properties (except systemproperties)
/// of the WMI class and will generate them as properties of the managed code
/// wrapper class.
/// </summary>
	void GenerateProperties()
	{
		bool bRead;
		bool bWrite;
		bool bStatic;
		bool bDynamicClass = IsDynamicClass();

		for(int i=0;i< PublicProperties.Count;i++)
		{
			PropertyData prop = classobj.Properties[PublicProperties.GetKey(i).ToString()];
			bRead = true;		//All properties are readable by default
			bWrite = true;		//All properties are writeable by default
			bStatic = false;	//By default all properties are non static

			cmp = new CodeMemberProperty ();
			cmp.Name = PublicProperties[prop.Name].ToString();
			cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
			cmp.Type = new CodeTypeReference(ConvertCIMType(prop.Type,prop.IsArray));

			//All properties are browsable, by default
			caa = new CodeAttributeArgument();
			caa.Value = new CodePrimitiveExpression(true);
			cad = new CodeAttributeDeclaration();
			cad.Name = "Browsable";
			cad.Arguments.Add(caa);
			cmp.CustomAttributes = new CodeAttributeDeclarationCollection();
			cmp.CustomAttributes.Add(cad);

			// None of the properties are seriazable thru designer
			caa = new CodeAttributeArgument();
			caa.Value = new CodeSnippetExpression("DesignerSerializationVisibility.Hidden");
			cad = new CodeAttributeDeclaration();
			cad.Name = "DesignerSerializationVisibility";
			cad.Arguments.Add(caa);
			cmp.CustomAttributes.Add(cad);

			cie = new CodeIndexerExpression(
				new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString()),
				new CodeExpression[] {new CodePrimitiveExpression(prop.Name)});


			// If the property is of Type reference then construct a ManagementPath
			if (prop.Type == CimType.Reference)
			{
				CodeMethodReferenceExpression cmre = new CodeMethodReferenceExpression();
				cmre.MethodName = "ToString";
				cmre.TargetObject = cie;
				cmie = new CodeMethodInvokeExpression();
				cmie.Method = cmre;

				coce = new CodeObjectCreateExpression();
				coce.CreateType = new CodeTypeReference("ManagementPath");
				coce.Parameters.Add(cmie);

			}

			String description = ProcessPropertyQualifiers(prop,ref bRead,ref bWrite,ref bStatic,bDynamicClass);

			if(description != String.Empty)
			{
				//All properties are Description, by default
				caa = new CodeAttributeArgument();
				caa.Value = new CodePrimitiveExpression(description);
				cad = new CodeAttributeDeclaration();
				cad.Name = "Description";
				cad.Arguments.Add(caa);
				cmp.CustomAttributes.Add(cad);
			}

			//BUGBUG: WMI Values qualifier values cannot be used as
			//enumerator constants: they contain spaces, dots, dashes, etc.
			//These need to be modified, otherwise the generated file won't compile.
			//Uncomment the line below when that is fixed.
			bool isPropertyEnum = GeneratePropertyHelperEnums(prop,PublicProperties[prop.Name].ToString());

			if (bRead == true)
			{
				if(IsPropertyValueType(prop.Type))
				{
					// Throwing NullReferenceException with empty string, so that this property is shown empty in property browser
					cis = new CodeConditionStatement();
					cis.Condition = new CodeBinaryOperatorExpression(cie,
						CodeBinaryOperatorType.IdentityEquality,
						new CodePrimitiveExpression(null));


					coce = new CodeObjectCreateExpression();
					coce.CreateType = new CodeTypeReference(PrivateNamesUsed["NullRefExcep"].ToString());
					coce.Parameters.Add(new CodePrimitiveExpression(""));

					CodeThrowExceptionStatement cte = new CodeThrowExceptionStatement(coce);
					cis.TrueStatements.Add(cte);
					cmp.GetStatements.Add (cis);
				}

				if (prop.Type == CimType.Reference)
				{
					cmp.GetStatements.Add (new CodeMethodReturnStatement(coce));
				}
				else
				if (prop.Type == CimType.DateTime)
				{
					cmie = new CodeMethodInvokeExpression();
					cmie.Parameters.Add(new CodeCastExpression(new CodeTypeReference("String"),cie));
					cmie.Method.MethodName = PrivateNamesUsed["ToDateTimeMethod"].ToString();
					cmp.GetStatements.Add (new CodeMethodReturnStatement(cmie));			
				}
				else
				{
					if (isPropertyEnum)
					{
						cmie = new CodeMethodInvokeExpression();
						cmie.Method.TargetObject = new CodeSnippetExpression("Convert");
						cmie.Parameters.Add(cie);
						cmie.Method.MethodName = GetNumericConversionFunction(prop);

						cmp.GetStatements.Add (new CodeMethodReturnStatement (new CodeCastExpression(cmp.Type,cmie )));
					}
					else
					{
						cmp.GetStatements.Add (new CodeMethodReturnStatement (new CodeCastExpression(cmp.Type,cie)));
					}
				}

			}


			if (bWrite == true)
			{
				// if the type of the property is CIM_REFERENCE then just get the
				// path as string and update the property
				if (prop.Type == CimType.Reference)
				{
					CodeMethodReferenceExpression cmre = new CodeMethodReferenceExpression();
					cmre.MethodName = "ToString";
					cmre.TargetObject = new CodeSnippetExpression("value");
					cmie = new CodeMethodInvokeExpression();
					cmie.Method = cmre;
					cmp.SetStatements.Add(new CodeAssignStatement(cie,cmie));
				}
				else
				if (prop.Type == CimType.DateTime)
				{
					cmie = new CodeMethodInvokeExpression();
					cmie.Parameters.Add(new CodeCastExpression(new CodeTypeReference("DateTime"),new CodeSnippetExpression("value")));
					cmie.Method.MethodName = PrivateNamesUsed["ToDMTFTimeMethod"].ToString();
					cmp.SetStatements.Add (new CodeAssignStatement(cie,cmie));			
				}
				else
				{
					cmp.SetStatements.Add(new CodeAssignStatement(cie,new CodeSnippetExpression("value"))); 
				}
				cmie = new CodeMethodInvokeExpression();
				cmie.Method.TargetObject = new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString());
				cmie.Method.MethodName = "Put";

				cis = new CodeConditionStatement();
				cis.Condition = new CodeBinaryOperatorExpression(new CodeSnippetExpression(PrivateNamesUsed["AutoCommitProperty"].ToString()),
					CodeBinaryOperatorType.ValueEquality,
					new CodePrimitiveExpression(true));

				cis.TrueStatements.Add(new CodeExpressionStatement(cmie));

				cmp.SetStatements.Add(cis);
			}
			cc.Members.Add (cmp);
		}
		// Add a function to commit the changes of the objects to WMI
		GenerateCommitMethod();
	}
/// <summary>
/// This function will process the qualifiers for a given WMI property and set the 
/// attributes of the generated property accordingly.
/// </summary>
	string ProcessPropertyQualifiers(PropertyData prop,ref bool bRead, ref bool bWrite, ref bool bStatic,bool bDynamicClass)
	{
		bool hasWrite = false;
		bool writeValue = false;
		bool hasRead = false;

		// property is always readable
		bRead = true;
		bWrite = false;
			
		string description = String.Empty;
		foreach (QualifierData q in prop.Qualifiers)
		{
			if (String.Compare(q.Name,"description",true) == 0)
			{
				description = q.Value.ToString();
			}
			else
			if (String.Compare(q.Name,"key",true) == 0)
			{
				//This is a key. So push it in to the key array
				arrKeyType.Add(cmp.Type);
				arrKeys.Add(prop.Name);
				break;
			}
			else if (string.Compare(q.Name,"static",true) == 0)
			{
				//This property is static. So add static to the Type of the object
				bStatic = true;
				cmp.Attributes |= MemberAttributes.Static;
			}
			else if (string.Compare(q.Name,"read",true) == 0)
			{
				hasRead = true;
				if ((bool)q.Value == false)
				{
					bRead = false;
				}
				else
				{
					bRead = true;
				}
			}
			else if (string.Compare(q.Name,"write",true) == 0)
			{
				hasWrite = true;
				if ((bool)q.Value == true)
				{
					writeValue = true;
				}
				else
				{
					writeValue = false;
				}
			}
				// check for ValueMap/Values and BitMap/BitValues pair and create
				// Enum Accordingly
			else if (string.Compare(q.Name,"ValueMap",true) == 0)
			{
				ValueMap.Clear();
				//Now check whether the type of the property is int
				if (isTypeInt(prop.Type) == true)
				{
					if (q.Value != null)
					{
						bValueMapInt64 = false;
						string [] strArray = (string [])q.Value;
						for(int i=0;i < strArray.Length ;i++)
						{
							try
							{
								ValueMap.Add(Convert.ToInt32(strArray[i]));
							}
							catch(OverflowException)
							{
								ValueMap.Add(Convert.ToInt64(strArray[i]));
								bValueMapInt64 = true;
							}
						}
					}
				}
			}
			else if (string.Compare(q.Name,"Values",true) == 0)
			{
				Values.Clear();
				if (isTypeInt(prop.Type) == true)
				{
					if (q.Value != null)
					{
						ArrayList arTemp = new ArrayList(5);
						string [] strArray = (string[])q.Value;
						for(int i=0;i < strArray.Length;i++)
						{
							string strName = ConvertValuesToName(strArray[i]);
							arTemp.Add(strName);
						}
						ResolveEnumNameValues(arTemp,ref Values);
					}
				}

			}
			else if (string.Compare(q.Name,"BitMap",true) == 0)
			{
				BitMap.Clear();
				if (isTypeInt(prop.Type) == true)
				{
					if (q.Value != null)
					{
						string [] strArray = (string [])q.Value;
						for(int i=0;i < strArray.Length;i++)
						{
							
							BitMap.Add(ConvertBitMapValueToInt32(strArray[i]));
						}
					}
				}
			}
			else if (string.Compare(q.Name,"BitValues",true) == 0)
			{
				BitValues.Clear();
				if (isTypeInt(prop.Type) == true)
				{
					if (q.Value != null)
					{
						ArrayList arTemp = new ArrayList(5);
						string [] strArray = (string [])q.Value;
						for(int i=0;i < strArray.Length;i++)
						{
							string strName = ConvertValuesToName(strArray[i]);
							arTemp.Add(strName);
						}
						ResolveEnumNameValues(arTemp,ref BitValues);
					}
				}
			}
		}
		
		/// Property is not writeable only if "read" qualifier is present and its value is "true"
		/// Also, for dynamic classes, absence of "write" qualifier means that the property is read-only.
		if ((!bDynamicClass && !hasWrite && !hasRead)||
			(!bDynamicClass && hasWrite && writeValue)||
			(bDynamicClass && hasWrite && writeValue))
		{
			bWrite = true;
		}
			
		return description;
	}
/// <summary>
/// This function will generate enums corresponding to the Values/Valuemap pair
/// and for the BitValues/Bitmap pair.
/// </summary>
/// <returns>
/// returns if the property is an enum. This is checked by if enum is added or not
/// </returns>
bool GeneratePropertyHelperEnums(PropertyData prop,string strPropertyName)
{
	bool isEnumAdded = false;
	//Only if the property is of type int and there is atleast values qualifier on it
	//then we will generate an enum for the values/valuemap(if available)
	//Here we don't have to check explicitly for type of the property as the size of 
	//values array will be zero if the type is not int.
	string strEnum = ResolveCollision(strPropertyName+"Values",true);

	if (Values.Count > 0)
	{
		//Now we will have to create an enum.
		EnumObj = new CodeTypeDeclaration(strEnum);
	    cc.Members.Add(EnumObj);

		isEnumAdded = true;
		if (bValueMapInt64 == true)
		{
			EnumObj.BaseTypes.Add(new CodeTypeReference("long"));
		}
		//Now convert the type to the generated enum type
		cmp.Type = new CodeTypeReference(strEnum);

		EnumObj.IsEnum = true;
		EnumObj.TypeAttributes = TypeAttributes.Public; // | TypeAttributes.ValueType | TypeAttributes.Enum;
		for(int i=0; i < Values.Count;i++)
		{
			cmf = new CodeMemberField ();
			cmf.Name = Values[i].ToString();
			if (ValueMap.Count > 0)
			{
				cmf.InitExpression = new CodePrimitiveExpression(ValueMap[i]);
			}
			EnumObj.Members.Add(cmf);
		}
		//Now clear the Values & ValueMap Array
		Values.Clear();
		ValueMap.Clear();
	}
	//Only if the property is of type int and there is atleast values qualifier on it
	//then we will generate an enum for the values/valuemap(if available)
	//Here we don't have to check explicitly for type of the property as the size of 
	//values array will be zero if the type is not int.
	if (BitValues.Count > 0)
	{
		//Now we will create the enum
		EnumObj = new CodeTypeDeclaration(strEnum);
	    cc.Members.Add(EnumObj);

		isEnumAdded = true;

		//Now convert the type to the generated enum type
		cmp.Type = new CodeTypeReference(strEnum);

		EnumObj.IsEnum = true;
		EnumObj.TypeAttributes = TypeAttributes.Public; // | TypeAttributes.ValueType | TypeAttributes.Enum;
		Int32 bitValue = 1;
		for(int i=0; i < BitValues.Count;i++)
		{
			cmf = new CodeMemberField ();
			cmf.Name = BitValues[i].ToString();
			if (ValueMap.Count > 0)
			{
				cmf.InitExpression = new CodePrimitiveExpression(BitMap[i]);
			}
			else
			{
				cmf.InitExpression = new CodePrimitiveExpression(bitValue);
				//Now shift 1 more bit so that we can put it for the next element in the enum
				bitValue = bitValue << 1;
			}
			EnumObj.Members.Add(cmf);
		}

		//Now clear the Bitmap and BitValues Array
		BitValues.Clear();
		BitMap.Clear();
	}
	return isEnumAdded;

}
/// <summary>
/// This function generated the static function which s used to construct the path
/// 	private static String ConstructPath(String keyName)
///		{
///			//FOR NON SINGLETON CLASSES
///			String strPath;
///		    strPath = ((("\\&lt;defNamespace&gt;:&lt;defClassName&gt;";
///		    strPath = ((_strPath) + (((".Key1=") + (key_Key1))));
///		    strPath = ((_strPath) + (((",Key2=") + ((("\"") + (((key_Key2) + ("\""))))))));
///			return strPath;
///			
///			//FOR SINGLETON CLASS
///			return "\\&lt;defNameSpace&gt;:&lt;defClassName&gt;=@";
///		}
/// </summary>
	void GenerateConstructPath()
	{
		string strType;
		cmm = new CodeMemberMethod();
        cmm.Name = PublicNamesUsed["ConstructPathFunction"].ToString();
		cmm.Attributes = MemberAttributes.Private | MemberAttributes.Static | MemberAttributes.Final;
		cmm.ReturnType = new CodeTypeReference("String");

		for(int i=0; i < arrKeys.Count;i++)
		{
			strType = ((CodeTypeReference)arrKeyType[i]).BaseType;
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(strType,
																		"key"+arrKeys[i].ToString()));
		}

		string strPath = OriginalNamespace + ":" + OriginalClassName;
		if (bSingletonClass == true)
		{
			strPath = strPath + "=@";
			cmm.Statements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(strPath)));
		}
		else
		{
			string strPathObject = "strPath";
			//Declare the String strPath;
			cmm.Statements.Add(new CodeVariableDeclarationStatement("String",strPathObject,new CodePrimitiveExpression(strPath)));

			for(int i=0; i < arrKeys.Count;i++)
			{
				if (((CodeTypeReference)arrKeyType[i]).BaseType == "String")
				{
					cboe = new CodeBinaryOperatorExpression(new CodeSnippetExpression("key"+arrKeys[i]),
															CodeBinaryOperatorType.Add,
															new CodePrimitiveExpression("\""));

					cboe = new CodeBinaryOperatorExpression(new CodePrimitiveExpression("\""),
															CodeBinaryOperatorType.Add,
															cboe);

					cboe = new CodeBinaryOperatorExpression(new CodePrimitiveExpression(
														((i==0)?("."+arrKeys[i]+"="):(","+arrKeys[i]+"="))),
														CodeBinaryOperatorType.Add,
														cboe);
					cboe = new CodeBinaryOperatorExpression(new CodeSnippetExpression(strPathObject),
															CodeBinaryOperatorType.Add,
															cboe);
				}
				else
				{
					cmie = new CodeMethodInvokeExpression();
					cmie.Method.TargetObject = new CodeSnippetExpression("key"+arrKeys[i]);
					cmie.Method.MethodName = "ToString";

					cboe = new CodeBinaryOperatorExpression(new CodePrimitiveExpression(
														((i==0)?("."+arrKeys[i]+"="):(","+arrKeys[i]+"="))),
															CodeBinaryOperatorType.Add,
															cmie);
					cboe = new CodeBinaryOperatorExpression(new CodeSnippetExpression(strPathObject),
															CodeBinaryOperatorType.Add,
															cboe);
				}
				cmm.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(strPathObject),cboe));
			}
			cmm.Statements.Add(new CodeMethodReturnStatement(new CodeSnippetExpression(strPathObject)));
		}
		cc.Members.Add(cmm);
	}
/// <summary>
/// This function generates the default constructor.
/// public Cons() {
///		_privObject = new ManagementObject();
///     _privSystemProps = new ManagementSystemProperties(_privObject);
/// }
/// </summary>
	void GenerateDefaultConstructor()
	{
		cctor = new CodeConstructor();
		cctor.Attributes = MemberAttributes.Public;

		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
			new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()),
			new CodePrimitiveExpression(null)));
		//If it is a singleton class, then we will make the default constructor to point to the
		//only object available
		if (bSingletonClass == true)
		{
			cmie = new CodeMethodInvokeExpression();
			cmie.Method.TargetObject = new CodeSnippetExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
			cmie.Method.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();

			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
			coce.Parameters.Add(cmie);
					
			cctor.ChainedConstructorArgs.Add(coce);
		}
		else
		{
			cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
				new CodeTypeReference(PublicNamesUsed["PathClass"].ToString()),
				new CodePrimitiveExpression(null)));
		}
		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
			new CodeTypeReference(PublicNamesUsed["GetOptionsClass"].ToString()),
			new CodePrimitiveExpression(null)));
		cc.Members.Add(cctor);
	}
/// <summary>
///This function create the constuctor which accepts the key values.
///public cons(UInt32 key_Key1, String key_Key2) :this(null,&lt;ClassName&gt;.ConstructPath(&lt;key1,key2&gt;),null) {
/// }
///</summary>
	void GenerateConstructorWithKeys()
	{
		if (arrKeyType.Count > 0)
		{
			cctor = new CodeConstructor();		
			cctor.Attributes = MemberAttributes.Public;
			for(int i=0; i < arrKeys.Count;i++)
			{
				cpde = new CodeParameterDeclarationExpression();
				cpde.Type = new CodeTypeReference(((CodeTypeReference)arrKeyType[i]).BaseType);
				cpde.Name = "key"+arrKeys[i].ToString();
				cctor.Parameters.Add(cpde);
			}

			cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
				new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()),
				new CodePrimitiveExpression(null)));

			cmie = new CodeMethodInvokeExpression();
			cmie.Method.TargetObject = new CodeSnippetExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
			cmie.Method.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString(); 

			for(int i=0; i < arrKeys.Count;i++)
			{
				cmie.Parameters.Add(new CodeSnippetExpression("key"+arrKeys[i]));
			}

			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
			coce.Parameters.Add(cmie);

			cctor.ChainedConstructorArgs.Add(new CodeCastExpression(new CodeTypeReference(
				PublicNamesUsed["PathClass"].ToString()),
				coce));
			cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
				new CodeTypeReference(PublicNamesUsed["GetOptionsClass"].ToString()),
				new CodePrimitiveExpression(null)));
			cc.Members.Add(cctor);
		}		
	}

/// <summary>
///This function create the constuctor which accepts a scope and key values.
///public cons(ManagementScope scope,UInt32 key_Key1, String key_Key2) :this(scope,&lt;ClassName&gt;.ConstructPath(&lt;key1,key2&gt;),null) {
/// }
///</summary>
	void GenerateConstructorWithScopeKeys()
	{
		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),PrivateNamesUsed["ScopeParam"].ToString()));

		if (arrKeyType.Count > 0)
		{
			for(int i=0; i < arrKeys.Count;i++)
			{
				cpde = new CodeParameterDeclarationExpression();
				cpde.Type = new CodeTypeReference(((CodeTypeReference)arrKeyType[i]).BaseType);
				cpde.Name = "key"+arrKeys[i].ToString();
				cctor.Parameters.Add(cpde);
			}

			cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
									new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()),
									new CodeSnippetExpression(PrivateNamesUsed["ScopeParam"].ToString())));

			cmie = new CodeMethodInvokeExpression();
			cmie.Method.TargetObject = new CodeSnippetExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
			cmie.Method.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();				

			for(int i=0; i < arrKeys.Count;i++)
			{
				cmie.Parameters.Add(new CodeSnippetExpression("key"+arrKeys[i]));
			}

			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
			coce.Parameters.Add(cmie);
			cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
									new CodeTypeReference(PublicNamesUsed["PathClass"].ToString()),
									coce));
			cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
									new CodeTypeReference(PublicNamesUsed["GetOptionsClass"].ToString()),
									new CodePrimitiveExpression(null)));
			cc.Members.Add(cctor);
		}		
	}


	/// <summary>
	/// This function generates code for the constructor which accepts ManagementPath as the parameter.
	/// The generated code will look something like this
	///		public Cons(ManagementPath path) : this (null, path,null){
	///		}
	/// </summary>
	void GenerateConstructorWithPath()
	{
		string strPathObject = "path";
		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cpde = new CodeParameterDeclarationExpression();
		cpde.Type = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
		cpde.Name = strPathObject;
		cctor.Parameters.Add(cpde);

		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
								new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()),
								new CodePrimitiveExpression(null)));
		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
								new CodeTypeReference(PublicNamesUsed["PathClass"].ToString()),
								new CodeSnippetExpression(strPathObject)));
		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
								new CodeTypeReference(PublicNamesUsed["GetOptionsClass"].ToString()),
								new CodePrimitiveExpression(null)));
		cc.Members.Add(cctor);
	}
	/// <summary>
	/// This function generates code for the constructor which accepts ManagementPath and GetOptions
	/// as parameters.
	/// The generated code will look something like this
	///		public Cons(ManagementPath path, ObjectGetOptions options) : this (null, path,options){
	///		}
	/// </summary>
	void GenerateConstructorWithPathOptions()
	{
		string strPathObject = "path";
		string strGetOptions = "getOptions";

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["PathClass"].ToString(),
																	strPathObject));
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["GetOptionsClass"].ToString(),
																	strGetOptions));

		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
									new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()),
									new CodePrimitiveExpression(null)));
		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
									new CodeTypeReference(PublicNamesUsed["PathClass"].ToString()),
									new CodeSnippetExpression(strPathObject)));
		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
									new CodeTypeReference(PublicNamesUsed["GetOptionsClass"].ToString()),
									new CodeSnippetExpression(strGetOptions)));
		cc.Members.Add(cctor);
	}
	/// <summary>
	/// This function generates code for the constructor which accepts Scope as a string, path as a 
	/// string and GetOptions().
	/// The generated code will look something like this
	///		public Cons(String scope, String path, ObjectGetOptions options) : 
	///							this (new ManagementScope(scope), new ManagementPath(path),options){
	///		}
	/// </summary>
	void GenerateConstructorWithScopePath()
	{
		string strPathObject = "path";

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),PrivateNamesUsed["ScopeParam"].ToString()));
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["PathClass"].ToString(),strPathObject));
		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
									new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()),
									new CodeSnippetExpression(PrivateNamesUsed["ScopeParam"].ToString())));
		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
									new CodeTypeReference(PublicNamesUsed["PathClass"].ToString()),
									new CodeSnippetExpression(strPathObject)));
		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
									new CodeTypeReference(PublicNamesUsed["GetOptionsClass"].ToString()),
									new CodePrimitiveExpression(null)));
		cc.Members.Add(cctor);
	}
	/// <summary>
	/// This function generates code for the constructor which accepts ManagementScope as parameters.
	/// The generated code will look something like this
	///		public Cons(ManagementScope scope, ObjectGetOptions options) : this (scope, &lt;ClassName&gt;.ConstructPath(),null){
	///		}
	/// </summary>
	void GenerateConstructorWithScope()
	{

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),
																	PrivateNamesUsed["ScopeParam"].ToString()));
		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
									new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()),
									new CodeSnippetExpression(PrivateNamesUsed["ScopeParam"].ToString())));
		cmie = new CodeMethodInvokeExpression();
		cmie.Method.TargetObject =new CodeSnippetExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
		cmie.Method.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();					
					
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
		coce.Parameters.Add(cmie);

		cctor.ChainedConstructorArgs.Add(coce);

		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
									new CodeTypeReference(PublicNamesUsed["GetOptionsClass"].ToString()),
									new CodePrimitiveExpression(null)));
		cc.Members.Add(cctor);
	}

	/// <summary>
	/// This function generates code for the constructor which accepts GetOptions
	/// as parameters.
	/// The generated code will look something like this
	///		public Cons(ObjectGetOptions options) : this (null, &lt;ClassName&gt;.ConstructPath(),options){
	///		}
	/// </summary>
	void GenerateConstructorWithOptions()
	{
		string strGetOptions = "getOptions";

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["GetOptionsClass"].ToString(),
																	strGetOptions));

		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
									new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()),
									new CodePrimitiveExpression(null)));
		cmie = new CodeMethodInvokeExpression();
		cmie.Method.TargetObject = new CodeSnippetExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
		cmie.Method.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();
				
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
		coce.Parameters.Add(cmie);

		cctor.ChainedConstructorArgs.Add(coce);
		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
									new CodeTypeReference(PublicNamesUsed["GetOptionsClass"].ToString()),
									new CodeSnippetExpression(strGetOptions)));
		cc.Members.Add(cctor);
	}

	/// <summary>
	/// This function generates code for the constructor which accepts ManagementScope and GetOptions
	/// as parameters.
	/// The generated code will look something like this
	///		public Cons(ManagementScope scope, ObjectGetOptions options) : this (scope, &lt;ClassName&gt;.ConstructPath(),options){
	///		}
	/// </summary>
	void GenerateConstructorWithScopeOptions()
	{
		string strGetOptions = "getOptions";

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),
																	PrivateNamesUsed["ScopeParam"].ToString()));
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["GetOptionsClass"].ToString(),
																	strGetOptions));

		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
									new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()),
									new CodeSnippetExpression(PrivateNamesUsed["ScopeParam"].ToString())));
		
		cmie = new CodeMethodInvokeExpression();
		cmie.Method.TargetObject = new CodeSnippetExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
		cmie.Method.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();				

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
		coce.Parameters.Add(cmie);

		cctor.ChainedConstructorArgs.Add(coce);

		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
									new CodeTypeReference(PublicNamesUsed["GetOptionsClass"].ToString()),
									new CodeSnippetExpression(strGetOptions)));
		cc.Members.Add(cctor);
	}


	/// <summary>
	/// This function generated the constructor like
	///		public cons(ManagementScope scope, ManagamentPath path,ObjectGetOptions getOptions)
	///		{
	///			PrivateObject = new ManagementObject(scope,path,getOptions);
	///			PrivateSystemProperties = new ManagementSystemProperties(PrivateObject);
	///		}
	/// </summary>
	void GenerateConstructorWithScopePathOptions()
	{
		string strPathObject = "path";
		string strGetOptions = "getOptions";
		bool bPrivileges = true;
		
		try
		{
			classobj.Qualifiers["priveleges"].ToString();
		}
		catch(ManagementException e)
		{
			if (e.ErrorCode == ManagementStatus.NotFound)
			{
				bPrivileges = false;
			}
			else
			{
				throw;
			}
		}

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),PrivateNamesUsed["ScopeParam"].ToString()));
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["PathClass"].ToString(),strPathObject));
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["GetOptionsClass"].ToString(),strGetOptions));

		//First if path is not null, then we will check whether the class name is the same.
		//if it is not the same, then we will throw an exception
		cis = new CodeConditionStatement();
		cis.Condition = new CodeBinaryOperatorExpression(new CodeSnippetExpression(strPathObject),
															CodeBinaryOperatorType.IdentityInequality,
															new CodePrimitiveExpression(null));
		CodeConditionStatement cis1 = new CodeConditionStatement();

		cmie = new CodeMethodInvokeExpression();
		cmie.Method.TargetObject = new CodeSnippetExpression("String");
		cmie.Method.MethodName = "Compare";
						

		cmie.Parameters.Add(new CodePropertyReferenceExpression(new CodeSnippetExpression(strPathObject),"ClassName"));
		cmie.Parameters.Add(new CodeSnippetExpression(PublicNamesUsed["ClassNameProperty"].ToString()));
		cmie.Parameters.Add(new CodePrimitiveExpression(true));
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = cmie;
		cboe.Right = new CodePrimitiveExpression(0);
		cboe.Operator = CodeBinaryOperatorType.IdentityInequality;
		cis1.Condition = cboe;
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["ArgumentExceptionClass"].ToString());
		coce.Parameters.Add(new CodePrimitiveExpression(ExceptionString));
		cis1.TrueStatements.Add(new CodeThrowExceptionStatement(coce));

		cis.TrueStatements.Add(cis1);
		cctor.Statements.Add(cis);

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["LateBoundClass"].ToString());
		coce.Parameters.Add(new CodeSnippetExpression(PrivateNamesUsed["ScopeParam"].ToString()));
		coce.Parameters.Add(new CodeSnippetExpression(strPathObject));
		coce.Parameters.Add(new CodeSnippetExpression(strGetOptions));
		cctor.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(
																	PrivateNamesUsed["LateBoundObject"].ToString()),
													  coce));
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["SystemPropertiesClass"].ToString());
		cle = new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString());
		coce.Parameters.Add(cle);
		cctor.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(
																	PrivateNamesUsed["SystemPropertiesObject"].ToString()),
													  coce));
		cc.Members.Add(cctor);
		// Enable the privileges if the class has privileges qualifier
		if (bPrivileges == true)
		{
			//Generate the statement 
			//	Boolean bPriveleges = PrivateLateBoundObject.Scope.Options.EnablePrivileges;
			cpre = new CodePropertyReferenceExpression(new CodePropertyReferenceExpression(
				new CodePropertyReferenceExpression(
				new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString()),
				PublicNamesUsed["ScopeProperty"].ToString()),
				"Options"),
				"EnablePrivileges");

			cctor.Statements.Add(new CodeAssignStatement(cpre, new CodePrimitiveExpression(true)));
			
		}
		
	}
	/// <summary>
	/// This function generates code for the constructor which accepts ManagementObject as the parameter.
	/// The generated code will look something like this
	///		public Cons(ManagementObject theObject) {
	///		if (String.Compare(theObject.SystemProperties["__CLASS"].Value.ToString(),ClassName,true) == 0) {
	///				privObject = theObject;
	///				privSystemProps = new WmiSystemProps(privObject);
	///			}
	///			else {
	///				throw new ArgumentException("Class name doesn't match");
	///			}
	///		}
	/// </summary>
	void GenarateConstructorWithLateBound()
	{
		string strLateBoundObject = "theObject";
		string LateBoundSystemProperties = "SystemProperties";

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cpde = new CodeParameterDeclarationExpression();
		cpde.Type = new CodeTypeReference(PublicNamesUsed["LateBoundClass"].ToString());
		cpde.Name = strLateBoundObject;
		cctor.Parameters.Add(cpde);

		cis = new CodeConditionStatement();
        cpre = new CodePropertyReferenceExpression(new CodeSnippetExpression(strLateBoundObject),LateBoundSystemProperties);
		cie = new CodeIndexerExpression(cpre,new CodePrimitiveExpression("__CLASS"));
        cpre = new CodePropertyReferenceExpression(cie,"Value");
        cmie = new CodeMethodInvokeExpression();
		cmie.Method.TargetObject = new CodeSnippetExpression("String");
		cmie.Method.MethodName = "Compare";
					
		cmie.Parameters.Add(new CodeMethodInvokeExpression(cpre,"ToString"));
		cmie.Parameters.Add(new CodeSnippetExpression(PublicNamesUsed["ClassNameProperty"].ToString()));
		cmie.Parameters.Add(new CodePrimitiveExpression(true));
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = cmie;
		cboe.Right = new CodePrimitiveExpression(0);
		cboe.Operator = CodeBinaryOperatorType.ValueEquality;
		cis.Condition = cboe;

		cis.TrueStatements.Add(new CodeAssignStatement(
								new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString()),
								new CodeSnippetExpression(strLateBoundObject)));

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["SystemPropertiesClass"].ToString());
		cle = new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString());
		coce.Parameters.Add(cle);
		cis.TrueStatements.Add(new CodeAssignStatement(new CodeSnippetExpression(PrivateNamesUsed["SystemPropertiesObject"].ToString()),coce));

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["ArgumentExceptionClass"].ToString());
		coce.Parameters.Add(new CodePrimitiveExpression(ExceptionString));
		cis.FalseStatements.Add(new CodeThrowExceptionStatement(coce));

		cctor.Statements.Add(cis);
		cc.Members.Add(cctor);
	}
/// <summary>
/// This function generates the WMI methods as the methods in the generated class.
/// The generated code will look something like this
///		public &lt;retType&gt; Method1(&lt;type&gt; param1, &lt;type&gt; param2,...) {
///            ManagementBaseObject inParams = null;
///            inParams = _privObject.GetMethodParameters("ChangeStartMode");
///            inParams["&lt;inparam1&gt;"] = &lt;Value&gt;;
///            inParams["&lt;inoutparam2&gt;"] = &lt;Value&gt;;
///            ................................
///            ManagementBaseObject outParams = _privObject.InvokeMethod("ChangeStartMode", inParams, null);
///            inoutParam3 = (&lt;type&gt;)(outParams.Properties["&lt;inoutParam3&gt;"]);
///            outParam4 = (String)(outParams.Properties["&lt;outParam4&gt;"]);
///            ................................
///            return (&lt;retType&gt;)(outParams.Properties["ReturnValue"].Value);
///     }
///     
///     The code generated changes if the method is static function
///		public &lt;retType&gt; Method1(&lt;type&gt; param1, &lt;type&gt; param2,...) {
///            ManagementBaseObject inParams = null;
///			   ManagementObject classObj = new ManagementObject(null, "WIN32_SHARE", null); // the clasname
///            inParams = classObj.GetMethodParameters("Create");
///            inParams["&lt;inparam1&gt;"] = &lt;Value&gt;;
///            inParams["&lt;inoutparam2&gt;"] = &lt;Value&gt;;
///            ................................
///            ManagementBaseObject outParams = classObj.InvokeMethod("ChangeStartMode", inParams, null);
///            inoutParam3 = (&lt;type&gt;)(outParams.Properties["&lt;inoutParam3&gt;"]);
///            outParam4 = (String)(outParams.Properties["&lt;outParam4&gt;"]);
///            ................................
///            return (&lt;retType&gt;)(outParams.Properties["ReturnValue"].Value);
///     }
///     
/// </summary>
	void GenerateMethods()
	{
		string strInParams = "inParams";
		string strOutParams = "outParams";
		string strClassObj	= "classObj";
		bool	bStatic		= false;
		bool	bPrivileges = false;
		CodePropertyReferenceExpression cprePriveleges = null;

		ArrayList outParamsName = new ArrayList(5);
		ArrayList inoutParams = new ArrayList(5);
		ArrayList inoutParamsType = new ArrayList(5);
		for(int k=0;k< PublicMethods.Count;k++)
		{
			bStatic = false;
			MethodData meth = classobj.Methods[PublicMethods.GetKey(k).ToString()];
			string strTemp = PrivateNamesUsed["LateBoundObject"].ToString();
			if (meth.OutParameters.Properties != null)
			{
				//First Populate the out Params name so that we can find in/out parameters
				foreach (PropertyData prop in meth.OutParameters.Properties)
				{
					outParamsName.Add(prop.Name);
				}
			}

			cmm = new CodeMemberMethod();
			cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final;
			cmm.Name = PublicMethods[meth.Name].ToString();			

			//Check if the method is static
			foreach (QualifierData q in meth.Qualifiers)
			{
				if (string.Compare(q.Name,"static",true) == 0)
				{
					//It is a static function
					cmm.Attributes |= MemberAttributes.Static;
					bStatic = true;
					break;
				}
				else
				if (string.Compare(q.Name,"privileges",true) == 0)
				{
					//It is a function which needs privileges to be set
					bPrivileges = true;
				}
			}

			bool bfirst = true;
			//Generate the statement 
			//	ManagementBaseObject inParams = null;
			cmm.Statements.Add(new CodeVariableDeclarationStatement("ManagementBaseObject",
											strInParams,new CodePrimitiveExpression(null)));


			if (bStatic == true)
			{
				CodeObjectCreateExpression coce1 = new CodeObjectCreateExpression();
				coce1.CreateType = new CodeTypeReference(PublicNamesUsed["ManagementClass"].ToString());
				coce1.Parameters.Add(new CodePrimitiveExpression(null));
				coce1.Parameters.Add(new CodePrimitiveExpression(OriginalClassName));
				coce1.Parameters.Add(new CodePrimitiveExpression(null));

				coce = new CodeObjectCreateExpression();
				coce.CreateType = new CodeTypeReference(PublicNamesUsed["ManagementClass"].ToString());
				coce.Parameters.Add(coce1);	
				cmm.Statements.Add(new CodeVariableDeclarationStatement(PublicNamesUsed["ManagementClass"].ToString(),strClassObj,coce1));
				strTemp = strClassObj;
			}

			if (bPrivileges == true)
			{
				//Generate the statement 
				//	Boolean bPriveleges = PrivateLateBoundObject.Scope.Options.EnablePrivileges;
				cprePriveleges = new CodePropertyReferenceExpression(new CodePropertyReferenceExpression(
					new CodePropertyReferenceExpression(
					new CodeSnippetExpression(bStatic ? strClassObj : PrivateNamesUsed["LateBoundObject"].ToString()),
					PublicNamesUsed["ScopeProperty"].ToString()),
					"Options"),
					"EnablePrivileges");

				cmm.Statements.Add(new CodeVariableDeclarationStatement("Boolean",
					PrivateNamesUsed["Privileges"].ToString(),cprePriveleges));

				cmm.Statements.Add(new CodeAssignStatement(cprePriveleges, new CodePrimitiveExpression(true)));
			
			}

			//Do these things only when there is a valid InParameters
			if (meth.InParameters != null)
			{
				//Now put the in parameters
				if (meth.InParameters.Properties != null)
				{
					foreach (PropertyData prop in meth.InParameters.Properties)
					{
						if (bfirst == true)
						{
							//Now Generate the statement
							//	inParams = privObject.GetMethodParameters(<MethodName>);
							cmie = new CodeMethodInvokeExpression(
																	new CodeSnippetExpression(strTemp),
																	"GetMethodParameters",
																	new CodePrimitiveExpression(meth.Name));
							//cmie.MethodName = "GetMethodParameters";
							//cmie.TargetObject = new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString());
							//cmie.Parameters.Add(new CodePrimitiveExpression(meth.Name));
							cmm.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(strInParams),cmie));
							bfirst = false;
						}

						cpde = new CodeParameterDeclarationExpression();
						cpde.Name = prop.Name;
						cpde.Type = new CodeTypeReference(ConvertCIMType(prop.Type,prop.IsArray));
						cpde.Direction = FieldDirection.In;
						//Find out whether it is a in/out Parameter
						for(int i=0; i < outParamsName.Count;i++)
						{
							if (string.Compare(prop.Name,outParamsName[i].ToString(),true) == 0)
							{
								//It is an in/out Parameter
								cpde.Direction = FieldDirection.Ref;
								inoutParams.Add(prop.Name);
								inoutParamsType.Add(cpde.Type);
							}
						}
						
						cmm.Parameters.Add(cpde);
						//Also generate the statement
						//inParams["PropName"] = Value;
						cie = new CodeIndexerExpression(new CodeSnippetExpression(strInParams),new CodePrimitiveExpression(prop.Name));
						
						cmm.Statements.Add(new CodeAssignStatement(cie,new CodeSnippetExpression(cpde.Name)));
					}
				}
			}
			//Now clear the outParamsName array
			outParamsName.Clear();
			bool bInOut;
			bool bRetVal = false;
			bfirst = true;
			bool bInvoke = false;
			//Do these only when the outParams is Valid
			if (meth.OutParameters != null)
			{
				if (meth.OutParameters.Properties != null)
				{
					foreach (PropertyData prop in meth.OutParameters.Properties)
					{
						if (bfirst == true)
						{
							//Now generate the statement
							//	ManagementBaseObject outParams = privObject.InvokeMethod(<methodName>,inParams,options);
							cmie = new CodeMethodInvokeExpression(
										new CodeSnippetExpression(strTemp),
										"InvokeMethod");

							cmie.Parameters.Add(new CodePrimitiveExpression(meth.Name));
							cmie.Parameters.Add(new CodeSnippetExpression(strInParams));
							cmie.Parameters.Add(new CodePrimitiveExpression(null));
							cmm.Statements.Add(new CodeVariableDeclarationStatement("ManagementBaseObject",strOutParams,cmie));
							bfirst = false;
							bInvoke = true;
						}

						bInOut = false;
						for(int i=0; i < inoutParams.Count;i++)
						{
							if (string.Compare(prop.Name,inoutParams[i].ToString(),true) == 0)
							{
								bInOut = true;
							}
						}
						if (bInOut == true)
							continue;

						if (string.Compare(prop.Name,"ReturnValue",true) == 0)
						{
							cmm.ReturnType = new CodeTypeReference(
								ConvertCIMType(prop.Type,prop.IsArray));
							bRetVal = true;
						}
						else
						{
							cpde = new CodeParameterDeclarationExpression();
							cpde.Name = prop.Name;
							cpde.Type = new CodeTypeReference(ConvertCIMType(prop.Type,prop.IsArray));
							cpde.Direction = FieldDirection.Out;
							cmm.Parameters.Add(cpde);

							//Now for each out params generate the statement
							//	<outParam> = outParams.Properties["<outParam>"];
							cpre = new CodePropertyReferenceExpression(new CodeSnippetExpression(strOutParams),"Properties");
							cie = new CodeIndexerExpression(cpre,new CodePrimitiveExpression(prop.Name));
							cmm.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(prop.Name),
												new CodeCastExpression(cpde.Type,new CodePropertyReferenceExpression(cie,"Value"))));
						}
					}
				}
			}

			if (bInvoke == false)
			{
				//Now there is no out parameters to invoke the function
				//So just call Invoke.
				cmie = new CodeMethodInvokeExpression(
								new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString()),
								"InvokeMethod"
								);

				cmie.Parameters.Add(new CodePrimitiveExpression(meth.Name));
				cmie.Parameters.Add(new CodeSnippetExpression(strInParams));

				cmis = new CodeExpressionStatement(cmie);
				cmm.Statements.Add(cmis);
			}

			//Now for each in/out params generate the statement
			//	<inoutParam> = outParams.Properties["<inoutParam>"];
			for(int i=0;i < inoutParams.Count;i++)
			{
				cpre = new CodePropertyReferenceExpression(new CodeSnippetExpression(strOutParams),"Properties");
				cie = new CodeIndexerExpression(cpre,new CodePrimitiveExpression(inoutParams[i].ToString()));
				cmm.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(inoutParams[i].ToString()),
									new CodeCastExpression(inoutParamsType[i].ToString(),
									new CodePropertyReferenceExpression(cie,"Value"))));
			}
			inoutParams.Clear();

			// Assign the privileges back
			if (bPrivileges == true)
			{
				cmm.Statements.Add(new CodeAssignStatement(cprePriveleges, new CodeVariableReferenceExpression(PrivateNamesUsed["Privileges"].ToString())));
			}

			//Now check if there is a return value. If there is one then return it from the function
			if (bRetVal == true)
			{
				cpre = new CodePropertyReferenceExpression(new CodeSnippetExpression(strOutParams),"Properties");
				cie = new CodeIndexerExpression(cpre,new CodePrimitiveExpression("ReturnValue"));
				cmm.Statements.Add(new CodeMethodReturnStatement(new CodeCastExpression(cmm.ReturnType,
									new CodePropertyReferenceExpression(cie,"Value"))));
			}

			cc.Members.Add(cmm);
		}
	}
	/// <summary>
	/// This function returns a Collectionclass for the query 
	///		"Select * from &lt;ClassName&gt;"
	///	This is a static method. The output is like this
	///		public static ServiceCollection All()
	///		{
	///			return GetInstances(null,null,null);
	///		}        
	/// </summary>
	void GenerateGetInstancesWithNoParameters()
	{
		cmm = new CodeMemberMethod();
        	
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());

		cmie = new CodeMethodInvokeExpression();
		cmie.Method.MethodName = PublicNamesUsed["FilterFunction"].ToString();
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
	}

/// <summary>
/// This function will accept the condition and will return collection for the query
///		"select * from &lt;ClassName&gt; where &lt;condition&gt;"
///	The generated code will be like
///		public static ServiceCollection GetInstances(String Condition) {
///			return GetInstances(null,Condition,null);
///     }
/// </summary>
	void GenerateGetInstancesWithCondition()
	{
		string strCondition = "condition";
		cmm = new CodeMemberMethod();
        	
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("String",strCondition));

		cmie = new CodeMethodInvokeExpression(
					null, //no TargetObject?
					PublicNamesUsed["FilterFunction"].ToString()
					);

		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodeSnippetExpression(strCondition));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
	}

	/// <summary>
	/// This function returns the collection for the query 
	///		"select &lt;parameterList&gt; from &lt;ClassName&gt;"
	///	The generated output is like
	///		public static ServiceCollection GetInstances(String []selectedProperties) {
	///			return GetInstances(null,null,selectedProperties);
    ///		}
	/// </summary>
	void GenerateGetInstancesWithProperties()
	{
		string strSelectedProperties = "selectedProperties";
		cmm = new CodeMemberMethod();
        	
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("String []",strSelectedProperties));

		cmie = new CodeMethodInvokeExpression(
						null,
						PublicNamesUsed["FilterFunction"].ToString()
						);
		//cmie.MethodName = PublicNamesUsed["FilterFunction"].ToString();
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodeSnippetExpression(strSelectedProperties));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
	}

	/// <summary>
	/// This function returns the collection for the query 
	///		"select &lt;parameterList> from &lt;ClassName&gt; where &lt;WhereClause&gt;"
	///	The generated output is like
	///		public static ServiceCollection GetInstances(String condition, String []selectedProperties) {
	///			return GetInstances(null,condition,selectedProperties);
    ///		}
	/// </summary>
	void GenerateGetInstancesWithWhereProperties()
	{
		string strSelectedProperties = "selectedProperties";
		string strCondition = "condition";
		cmm = new CodeMemberMethod();
        	
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("String",strCondition));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("String []",strSelectedProperties));

		cmie = new CodeMethodInvokeExpression(
						null, //no TargetObject?
						PublicNamesUsed["FilterFunction"].ToString()
						);

		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodeSnippetExpression(strCondition));
		cmie.Parameters.Add(new CodeSnippetExpression(strSelectedProperties));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
	}

	/// <summary>
	/// This function returns a Collectionclass for the query 
	///		"Select * from &lt;ClassName&gt;"
	///	This is a static method. The output is like this
	///		public static ServiceCollection All()
	///		{
	///			return GetInstances(scope,null,null);
	///		}        
	///	This method takes the scope which is useful for connection to remote machine
	/// </summary>
	void GenerateGetInstancesWithScope()
	{
		cmm = new CodeMemberMethod();
        	
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),PrivateNamesUsed["ScopeParam"].ToString()));

		cmie = new CodeMethodInvokeExpression(
						null, //no TargetObject?
						PublicNamesUsed["FilterFunction"].ToString()
						);

		cmie.Parameters.Add(new CodeSnippetExpression(PrivateNamesUsed["ScopeParam"].ToString()));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
	}

/// <summary>
/// This function will accept the condition and will return collection for the query
///		"select * from &lt;ClassName&gt; where &lt;condition&gt;"
///	The generated code will be like
///		public static ServiceCollection GetInstances(String Condition) {
///			return GetInstances(scope,Condition,null);
///     }
/// </summary>
	void GenerateGetInstancesWithScopeCondition()
	{
		string strCondition = "condition";
		cmm = new CodeMemberMethod();
        	
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),PrivateNamesUsed["ScopeParam"].ToString()));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("String",strCondition));

		cmie = new CodeMethodInvokeExpression(
					null,
					PublicNamesUsed["FilterFunction"].ToString()
					);
		//cmie.MethodName = PublicNamesUsed["FilterFunction"].ToString();
		cmie.Parameters.Add(new CodeSnippetExpression(PrivateNamesUsed["ScopeParam"].ToString()));
		cmie.Parameters.Add(new CodeSnippetExpression(strCondition));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
	}

	/// <summary>
	/// This function returns the collection for the query 
	///		"select &lt;parameterList&gt; from &lt;ClassName&gt;"
	///	The generated output is like
	///		public static ServiceCollection GetInstances(String []selectedProperties) {
	///			return GetInstances(scope,null,selectedProperties);
    ///		}
	/// </summary>
	void GenerateGetInstancesWithScopeProperties()
	{
		string strSelectedProperties = "selectedProperties";
		cmm = new CodeMemberMethod();
        	
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),PrivateNamesUsed["ScopeParam"].ToString()));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("String []",strSelectedProperties));

		cmie = new CodeMethodInvokeExpression(
					null, //no TargetObject?
					PublicNamesUsed["FilterFunction"].ToString()
					);

		cmie.Parameters.Add(new CodeSnippetExpression(PrivateNamesUsed["ScopeParam"].ToString()));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodeSnippetExpression(strSelectedProperties));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
	}

	/// <summary>
	/// This function generates the code like 
	/// 	public static ServiceCollection GetInstances(ManagementScope scope,String Condition, String[] selectedProperties)	{
	///			if (scope == null)
	///			{
	///				scope = new ManagementScope();
	///				scope.Path.NamespacePath = WMINamespace;
	///			}
	/// 		ManagementObjectSearcher ObjectSearcher = new ManagementObjectSearcher(scope,new SelectQuery("Win32_Service",Condition,selectedProperties));
	///			QueryOptions query = new QueryOptions();
	///			query.EnsureLocatable = true;
	///			ObjectSearcher.Options = query;
    ///	        return new ServiceCollection(ObjectSearcher.Get());
	///		}
	/// </summary>
	void GenerateGetInstancesWithScopeWhereProperties()
	{
		string strCondition = "condition";
		string strSelectedProperties = "selectedProperties";
		string strObjectSearcher = "ObjectSearcher";
		string strQuery = "query";

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());

		cmm.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),PrivateNamesUsed["ScopeParam"].ToString()));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("String",strCondition));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("String []",strSelectedProperties));

		cis = new CodeConditionStatement();
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeSnippetExpression(PrivateNamesUsed["ScopeParam"].ToString());
		cboe.Right = new CodePrimitiveExpression(null);
		cboe.Operator = CodeBinaryOperatorType.IdentityEquality;
		cis.Condition = cboe;


		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference("ManagementScope");
		cis.TrueStatements.Add(new CodeAssignStatement(new CodeSnippetExpression(PrivateNamesUsed["ScopeParam"].ToString()),coce));	

		cis.TrueStatements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(
			new CodePropertyReferenceExpression(new CodeSnippetExpression(PrivateNamesUsed["ScopeParam"].ToString()),
			"Path"),"NamespacePath"),
			new CodePrimitiveExpression(classobj.Scope.Path.NamespacePath)));

		
		cmm.Statements.Add(cis);
		CodeObjectCreateExpression coce1 = new CodeObjectCreateExpression();
		coce1.CreateType = new CodeTypeReference(PublicNamesUsed["QueryClass"].ToString());
		coce1.Parameters.Add(new CodePrimitiveExpression(OriginalClassName));
		coce1.Parameters.Add(new CodeSnippetExpression(strCondition));
		coce1.Parameters.Add(new CodeSnippetExpression(strSelectedProperties));

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["ObjectSearcherClass"].ToString());
		coce.Parameters.Add(new CodeSnippetExpression(PrivateNamesUsed["ScopeParam"].ToString()));
		coce.Parameters.Add(coce1);
	
		cmm.Statements.Add(new CodeVariableDeclarationStatement(PublicNamesUsed["ObjectSearcherClass"].ToString(),
																strObjectSearcher,coce));

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["QueryOptionsClass"].ToString());
		cmm.Statements.Add(new CodeVariableDeclarationStatement(PublicNamesUsed["QueryOptionsClass"].ToString(),strQuery,coce));

		cmm.Statements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(
														new CodeSnippetExpression(strQuery),
														"EnsureLocatable"),
													new CodePrimitiveExpression(true)));


		cmm.Statements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(
														new CodeSnippetExpression(strObjectSearcher),
														"Options"),
													new CodeSnippetExpression(strQuery)));
	
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
		coce.Parameters.Add(new CodeMethodInvokeExpression(new CodeSnippetExpression(strObjectSearcher),
															"Get"));
		cmm.Statements.Add(new CodeMethodReturnStatement(coce));

		cc.Members.Add(cmm);
	}

	/// <summary>
	/// This function will add the variable as a private member to the class.
	/// The generated code will look like this
	///         private &lt;MemberType&gt; &lt;MemberName&gt;;
	/// </summary>
	void GeneratePrivateMember(string memberName,string MemberType)
	{
		GeneratePrivateMember(memberName,MemberType,null);
	}

	/// <summary>
	/// This function will add the variable as a private member to the class.
	/// The generated code will look like this
	///         private &lt;MemberType&gt; &lt;MemberName&gt; = &lt;initValue&gt;;
	/// </summary>
	void GeneratePrivateMember(string memberName,string MemberType,CodeExpression initExpression)
	{
		cf = new CodeMemberField();
		cf.Name = memberName;
		cf.Attributes = MemberAttributes.Private | MemberAttributes.Final ;
		cf.Type = new CodeTypeReference(MemberType);
		if (initExpression != null)
		{
			cf.InitExpression = initExpression;
		}
		cc.Members.Add(cf);
	}
/// <summary>
/// This is a simple helper function used to convert a given string to title case.
/// </summary>
/// <param name="str"> </param>
	private string ConvertToTitleCase(string str)
	{
		if (str.Length == 0)
		{
			return string.Copy("");
		}

		char[] arrString = str.ToLower().ToCharArray();
		//Convert the first character to uppercase
		arrString[0] = Char.ToUpper(arrString[0]);

		for(int i=0;i < str.Length;i++)
		{
			if (Char.IsLetterOrDigit(arrString[i]) == false)
			{
				//Some other character. So convert the next character to Upper case
				arrString[i+1] = Char.ToUpper(arrString[i+1]);
			}
		}
		return new string(arrString);
	}

	CodeTypeDeclaration GenerateTypeConverterClass()
	{
		string TypeDescriptorContextClass = "ITypeDescriptorContext";
		string contextObject = "context";
		string TypeSrcObject = "sourceType";
		string TypeDstObject = "destinationType";
		string ActualObject = "object";
		string InstanceDescriptorClass = "InstanceDescriptor";
		string ValueVar = "value";
		string CultureInfoClass	= "CultureInfo";
		string CultureInfoVar = "culture";
		string ObjectVar	= "obj";
		string ConstructorInfoCls = "ConstructorInfo";
		string ctorVar	= "ctor";
		string DictionaryInterface = "IDictionary";
		string dictVar	= "propertyValues";
		
		
		CodeTypeDeclaration CodeConvertorClass = new CodeTypeDeclaration(PrivateNamesUsed["ConverterClass"].ToString());
		CodeConvertorClass.BaseTypes.Add(PublicNamesUsed["TypeConverter"].ToString());

		/*
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) 
		{
			if (sourceType == typeof(LogicalDisk)) 
			{
				return true;
			}
			throw new NotSupportedException();
		}*/
	
		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Override ;
		cmm.Name = "CanConvertFrom";

		cmm.Parameters.Add(new CodeParameterDeclarationExpression(TypeDescriptorContextClass,contextObject));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("Type",TypeSrcObject));
		cmm.ReturnType = new CodeTypeReference("Boolean");

		cis = new CodeConditionStatement();

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeSnippetExpression(TypeSrcObject);
		cboe.Right = new CodeTypeOfExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
		cboe.Operator = CodeBinaryOperatorType.IdentityEquality;
		cis.Condition = cboe;

		// return true
		cis.TrueStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(true)));

		cmm.Statements.Add(cis);

		/*
		// Throw Exception
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["NotSupportedExceptClass"].ToString());
		cmm.Statements.Add(new CodeThrowExceptionStatement(coce));
*/
		cmm.Statements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(false)));

		CodeConvertorClass.Members.Add(cmm);


		/*
				public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) 
				{

					if (destinationType == typeof(InstanceDescriptor)) 
					{
						return true;
					}
					return false;
				}

			*/
		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Override ;
		cmm.Name = "CanConvertTo";

		cmm.Parameters.Add(new CodeParameterDeclarationExpression(TypeDescriptorContextClass,contextObject));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("Type",TypeDstObject));
		cmm.ReturnType = new CodeTypeReference("Boolean");
/*
		cis = new CodeConditionStatement();
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeSnippetExpression(TypeDstObject);
		cboe.Right = new CodePrimitiveExpression(null);
		cboe.Operator = CodeBinaryOperatorType.IdentityEquality;
		cis.Condition = cboe;


		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["ArgumentExceptionClass"].ToString());
		coce.Parameters.Add(new CodePrimitiveExpression(TypeDstObject));
		cis.TrueStatements.Add(new CodeThrowExceptionStatement(coce));

		
		cmm.Statements.Add(cis);

*/
		cis = new CodeConditionStatement();
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeSnippetExpression(TypeDstObject);
		cboe.Right = new CodeTypeOfExpression(InstanceDescriptorClass);
		cboe.Operator = CodeBinaryOperatorType.IdentityEquality;
		cis.Condition = cboe;

		// return true
		cis.TrueStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(true)));
		cmm.Statements.Add(cis);
	
		cmm.Statements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(false)));
	/*
		// Throw Exception
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["NotSupportedExceptClass"].ToString());
		cmm.Statements.Add(new CodeThrowExceptionStatement(coce));

*/
		CodeConvertorClass.Members.Add(cmm);

		/*

		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) 
		{

			if (destinationType == typeof(InstanceDescriptor) && value is LogicalDisk) 
			{
				LogicalDisk obj = (LogicalDisk)value;
				ConstructorInfo ctor = typeof(LogicalDisk).GetConstructor(new Type[] {typeof(ManagementPath)});
                    
				if (ctor != null) 
				{
					return new InstanceDescriptor(ctor, new object[] {disk.Path});
				}
			}
            
			return null;
		}
		*/

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Override  ;
		cmm.Name = "ConvertTo";

		cmm.Parameters.Add(new CodeParameterDeclarationExpression(TypeDescriptorContextClass,contextObject));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(CultureInfoClass,CultureInfoVar));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(ActualObject,ValueVar));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("Type",TypeDstObject));
		cmm.ReturnType = new CodeTypeReference(ActualObject);

/*		cis = new CodeConditionStatement();

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeSnippetExpression(TypeDstObject);
		cboe.Right = new CodePrimitiveExpression(null);
		cboe.Operator = CodeBinaryOperatorType.IdentityEquality;
		cis.Condition = cboe;

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["ArgumentExceptionClass"].ToString());
		coce.Parameters.Add(new CodePrimitiveExpression(TypeDstObject));
		cis.TrueStatements.Add(new CodeThrowExceptionStatement(coce));

		// Throw Exception
		cmm.Statements.Add(cis);
*/

		CodeBinaryOperatorExpression cboe1 = new CodeBinaryOperatorExpression();
		cboe1.Left = new CodeMethodInvokeExpression(new CodeSnippetExpression(ValueVar),"GetType");
		cboe1.Right = new CodeTypeOfExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
		cboe1.Operator = CodeBinaryOperatorType.IdentityEquality;

		CodeBinaryOperatorExpression cboe2 = new CodeBinaryOperatorExpression();
		cboe2.Left = new CodeSnippetExpression(TypeDstObject);
		cboe2.Right = new CodeTypeOfExpression(InstanceDescriptorClass);
		cboe2.Operator = CodeBinaryOperatorType.IdentityEquality;

		cis = new CodeConditionStatement();
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = cboe1;
		cboe.Right = cboe2;
		cboe.Operator = CodeBinaryOperatorType.BooleanAnd;

		cis.Condition = cboe;
		
		//LogicalDisk disk = (LogicalDisk)value;
		CodeVariableDeclarationStatement cvds = new CodeVariableDeclarationStatement(
			new CodeTypeReference(PrivateNamesUsed["GeneratedClassName"].ToString()),
			ObjectVar);

		cvds.InitExpression = new CodeCastExpression(new CodeTypeReference(PrivateNamesUsed["GeneratedClassName"].ToString()),
			new CodeSnippetExpression(ValueVar));

		
		cis.TrueStatements.Add(cvds);
		
		//ConstructorInfo ctor = typeof(LogicalDisk).GetConstructor(new Type[] {typeof(ManagementPath)});
		cvds = new CodeVariableDeclarationStatement(new CodeTypeReference(ConstructorInfoCls),ctorVar);

		CodeArrayCreateExpression cace = new CodeArrayCreateExpression();
		cace.CreateType = new CodeTypeReference("Type");
		cace.Initializers.Add(new CodeTypeOfExpression(new CodeTypeReference(PublicNamesUsed["PathClass"].ToString())));

		cmie = new CodeMethodInvokeExpression(new CodeTypeOfExpression(
			new CodeTypeReference(PrivateNamesUsed["GeneratedClassName"].ToString())),
			"GetConstructor");

		cmie.Parameters.Add(cace);

		cvds.InitExpression = cmie;
		cis.TrueStatements.Add(cvds);

		//	return new InstanceDescriptor(ctor, new object[] {disk.Path});
		

		cace = new CodeArrayCreateExpression();
		cace.CreateType = new CodeTypeReference(ActualObject);
		cace.Initializers.Add(new CodePropertyReferenceExpression(new CodeSnippetExpression(ObjectVar),
			PublicNamesUsed["PathProperty"].ToString()));
		
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(InstanceDescriptorClass);
		coce.Parameters.Add(new CodeSnippetExpression(ctorVar));
		coce.Parameters.Add(cace);
										

		cis.TrueStatements.Add(new CodeMethodReturnStatement(coce));

		cmm.Statements.Add(cis);

		// return null;
		cmm.Statements.Add(new	CodeMethodReturnStatement(new CodePrimitiveExpression(null)));

		CodeConvertorClass.Members.Add(cmm);


		/*
		public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes) 
		{
			return TypeDescriptor.GetProperties(typeof(LogicalDisk), attributes);
		}

		*/

		//For GetProperties Function

		string AttribiutesArrayClass = "Attribute[]";
		string AttributesObject = "attributes";
		string PropertyDescriptorCollectionClass = "PropertyDescriptorCollection";

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Override ;
		cmm.Name = "GetProperties";
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(TypeDescriptorContextClass,contextObject));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("Object",ObjectVar));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(AttribiutesArrayClass,AttributesObject));
		cmm.ReturnType = new CodeTypeReference(PropertyDescriptorCollectionClass);

		cmie = new CodeMethodInvokeExpression(
			new CodeSnippetExpression("TypeDescriptor"),
			"GetProperties"
			);
		cmie.Parameters.Add(new CodeTypeOfExpression(PrivateNamesUsed["GeneratedClassName"].ToString()));
		cmie.Parameters.Add(new CodeSnippetExpression(AttributesObject));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		CodeConvertorClass.Members.Add(cmm);

		/*
		public override Boolean GetPropertiesSupported(ITypeDescriptorContext context) 
		{
			return true;
		}*/
		
		//For GetPropertiesSupported Function
		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Override;
		cmm.Name = "GetPropertiesSupported";
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(TypeDescriptorContextClass,contextObject));
		cmm.ReturnType = new CodeTypeReference("Boolean");

		cmm.Statements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(true)));
		CodeConvertorClass.Members.Add(cmm);
	
		/*
		public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues) 
		{
			return new LogicalDisk((ManagementPath)propertyValues["Path"]);
		}
		*/
	
		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Override;
		cmm.Name = "CreateInstance";
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(TypeDescriptorContextClass,contextObject));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(DictionaryInterface,dictVar));
		cmm.ReturnType = new CodeTypeReference(ActualObject);

		cmm.Statements.Add(new CodeMethodReturnStatement(new CodeObjectCreateExpression(
			new CodeTypeReference(PrivateNamesUsed["GeneratedClassName"].ToString()),
			new CodeCastExpression(new CodeTypeReference(PublicNamesUsed["PathClass"].ToString()),
			new CodeIndexerExpression(new CodeSnippetExpression(dictVar),
			new CodePrimitiveExpression(PublicNamesUsed["PathProperty"].ToString()))))));

		CodeConvertorClass.Members.Add(cmm);

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Override;
		cmm.Name = "GetCreateInstanceSupported";
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(TypeDescriptorContextClass,contextObject));
		cmm.ReturnType = new CodeTypeReference("Boolean");
		cmm.Statements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(true)));

		CodeConvertorClass.Members.Add(cmm);

		return CodeConvertorClass;
	
	}



		private void GenerateCollectionClass()
	{
		string strManagementObjectCollectionType = "ManagementObjectCollection";
		string strObjectCollection = "ObjectCollection";
		string strobjCollection = "objCollection";

		//public class ServiceCollection : ICollection, IEnumerable
		ccc = new CodeTypeDeclaration(PrivateNamesUsed["CollectionClass"].ToString());

		ccc.BaseTypes.Add("System.Object");
		ccc.BaseTypes.Add("ICollection");

		//private ManagementObjectCollection objCollection;
		cf = new CodeMemberField();
		cf.Name = strObjectCollection;
		cf.Attributes = MemberAttributes.Private | MemberAttributes.Final ;
		cf.Type = new CodeTypeReference(strManagementObjectCollectionType);
		ccc.Members.Add(cf);

		//internal ServiceCollection(ManagementObjectCollection obj)
		//{
		//	objCollection = obj;
		//}

		cctor = new CodeConstructor();
		//		cctor.Attributes = MemberAttributes.Assembly;
		cctor.Attributes = MemberAttributes.Public;
		cpde = new CodeParameterDeclarationExpression();
		cpde.Name = strobjCollection;
		cpde.Type = new CodeTypeReference(strManagementObjectCollectionType);
		cctor.Parameters.Add(cpde);

		cctor.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(strObjectCollection),
			new CodeSnippetExpression(strobjCollection)));
		ccc.Members.Add(cctor);
	
	
		//public Int32 Count {
		//	get { 
		//			return objCollection.Count; 
		//		}
		//}

		cmp = new CodeMemberProperty();
		cmp.Type = new CodeTypeReference("System.Int32");
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmp.Name = "Count";
		cmp.ImplementationTypes.Add("ICollection");
		//cmp.ImplementsType = "ICollection";
		cmp.GetStatements.Add(new CodeMethodReturnStatement(new CodePropertyReferenceExpression(
			new CodeSnippetExpression(strObjectCollection),
			"Count")));
		ccc.Members.Add(cmp);
	

		//public bool IsSynchronized {
		//	get {
		//		return objCollection.IsSynchronized;
		//	}
		//}

		cmp = new CodeMemberProperty();
		cmp.Type = new CodeTypeReference("System.Boolean");
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmp.Name = "IsSynchronized";
		cmp.ImplementationTypes.Add("ICollection");
		//cmp.ImplementsType = "ICollection";
		cmp.GetStatements.Add(new CodeMethodReturnStatement(new CodePropertyReferenceExpression(
			new CodeSnippetExpression(strObjectCollection),
			"IsSynchronized")));
		ccc.Members.Add(cmp);

		//public Object SyncRoot { 
		//	get { 
		//		return this; 
		//	} 
		//}

		cmp = new CodeMemberProperty();
		cmp.Type = new CodeTypeReference("Object");
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmp.Name = "SyncRoot";
		cmp.ImplementationTypes.Add("ICollection");
		//cmp.ImplementsType = "ICollection";
		cmp.GetStatements.Add(new CodeMethodReturnStatement(new CodeThisReferenceExpression()));
		ccc.Members.Add(cmp);

		//public void CopyTo (Array array, Int32 index) 
		//{
		//	objCollection.CopyTo(array,index);
		//	for(int iCtr=0;iCtr < array.Length ;iCtr++)
		//	{
		//		array.SetValue(new Service((ManagementObject)array.GetValue(iCtr)),iCtr);
		//	}
		//}

		string strArray = "array";
		string strIndex = "index";
		string strnCtr = "nCtr";

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmm.Name = "CopyTo";
		cmm.ImplementationTypes.Add("ICollection");

		cpde = new CodeParameterDeclarationExpression();
		cpde.Name = strArray;
		cpde.Type = new CodeTypeReference("System.Array");
		cmm.Parameters.Add(cpde);

		cpde = new CodeParameterDeclarationExpression();
		cpde.Name = strIndex;
		cpde.Type = new CodeTypeReference("System.Int32");
		cmm.Parameters.Add(cpde);

		cmie = new CodeMethodInvokeExpression(
			new CodeSnippetExpression(strObjectCollection),
			"CopyTo"
			);

		cmie.Parameters.Add(new CodeSnippetExpression(strArray));
		cmie.Parameters.Add(new CodeSnippetExpression(strIndex));
		cmm.Statements.Add(new CodeExpressionStatement(cmie));

		cmm.Statements.Add(new CodeVariableDeclarationStatement("Int32",strnCtr));
		cfls = new CodeIterationStatement();

		//		cfls.InitStatement = new CodeVariableDeclarationStatement("Int32",strnCtr,new CodePrimitiveExpression(0));
		cfls.InitStatement = new CodeAssignStatement(new CodeSnippetExpression(strnCtr),new CodePrimitiveExpression(0));
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeSnippetExpression(strnCtr);
		cboe.Operator = CodeBinaryOperatorType.LessThan;
		cboe.Right = new CodePropertyReferenceExpression(new CodeSnippetExpression(strArray),"Length");
		cfls.TestExpression = cboe;
		cfls.IncrementStatement = new CodeAssignStatement(new CodeSnippetExpression(strnCtr),
			new CodeBinaryOperatorExpression(
			new CodeSnippetExpression(strnCtr),
			CodeBinaryOperatorType.Add,
			new CodePrimitiveExpression(1)));

		cmie = new CodeMethodInvokeExpression(
			new CodeSnippetExpression(strArray),
			"SetValue");
	
		CodeMethodInvokeExpression cmie1 = new CodeMethodInvokeExpression(
			new CodeSnippetExpression(strArray),
			"GetValue",
			new CodeSnippetExpression(strnCtr));
		//cmie1.MethodName = "GetValue";
		//cmie1.TargetObject = new CodeSnippetExpression(strArray);
		//cmie1.Parameters.Add(new CodeSnippetExpression(strnCtr));

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PrivateNamesUsed["GeneratedClassName"].ToString());
		coce.Parameters.Add(new CodeCastExpression(PublicNamesUsed["LateBoundClass"].ToString(),cmie1));

		cmie.Parameters.Add(coce);
		cmie.Parameters.Add(new CodeSnippetExpression(strnCtr));
		cfls.Statements.Add(new CodeExpressionStatement(cmie));

		cmm.Statements.Add(cfls);
		ccc.Members.Add(cmm);

		//ServiceEnumerator GetEnumerator()
		//{
		//	return new ServiceEnumerator (objCollection.GetEnumerator());
		//}

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmm.Name = "GetEnumerator";
		cmm.ImplementationTypes.Add("IEnumerable");
		//		cmm.ReturnType = PrivateNamesUsed["EnumeratorClass"].ToString();
		cmm.ReturnType = new CodeTypeReference("IEnumerator");
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PrivateNamesUsed["EnumeratorClass"].ToString());
		coce.Parameters.Add(new CodeMethodInvokeExpression(new CodeSnippetExpression(strObjectCollection),"GetEnumerator"));
		cmm.Statements.Add(new CodeMethodReturnStatement(coce));
		ccc.Members.Add(cmm);

		/*
		//ZINA: commenting this out for now, since 
		//"cmm.ImplementationTypes.Add("IEnumerable");"
		//does not work, and therefore the function is ambiguous and
		//does not compile.
	
		//IEnumerator IEnumerable.GetEnumerator()
		//{
		//	return GetEnumerator ();
		//}

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.VTableMask;
		cmm.Name = "GetEnumerator";
		cmm.ReturnType = new CodeTypeReference("IEnumerator");
		cmm.ImplementationTypes.Add("IEnumerable");
		//cmm.ImplementsType = "IEnumerable";
		cmie = new CodeMethodInvokeExpression(
					null,	//no TargetObject?
					"GetEnumerator"
					);

		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
		ccc.Members.Add(cmm);
	*/	
	
		//Now generate the Enumerator Class
		GenerateEnumeratorClass();
	
		cc.Members.Add(ccc);
	}

	private void GenerateEnumeratorClass()
	{
		string strObjectEnumerator = "ObjectEnumerator";
		string strManagementObjectEnumeratorType = "ManagementObjectEnumerator";
		string strManagementObjectCollectionType = "ManagementObjectCollection";
		string strobjEnum = "objEnum";

		//public class ServiceEnumerator : IEnumerator
		ecc = new CodeTypeDeclaration(PrivateNamesUsed["EnumeratorClass"].ToString());

		ecc.BaseTypes.Add("System.Object");
		ecc.BaseTypes.Add("IEnumerator");

		//private ManagementObjectCollection.ManagementObjectEnumerator ObjectEnumerator;
		cf = new CodeMemberField();
		cf.Name = strObjectEnumerator;
		cf.Attributes = MemberAttributes.Private | MemberAttributes.Final ;
		cf.Type = new CodeTypeReference(strManagementObjectCollectionType+"."+ 
										strManagementObjectEnumeratorType);
		ecc.Members.Add(cf);

		//constructor
		//internal ServiceEnumerator(ManagementObjectCollection.ManagementObjectEnumerator objEnum)
		//{
		//	ObjectEnumerator = objEnum;
		//}
		cctor = new CodeConstructor();
//		cctor.Attributes = MemberAttributes.Assembly;
		cctor.Attributes = MemberAttributes.Public;
		cpde = new CodeParameterDeclarationExpression();
		cpde.Name = strobjEnum;
		cpde.Type = new CodeTypeReference(strManagementObjectCollectionType + "." + 
											strManagementObjectEnumeratorType);
		cctor.Parameters.Add(cpde);

		cctor.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(strObjectEnumerator),
													new CodeSnippetExpression(strobjEnum)));
		ecc.Members.Add(cctor);

		//public Service Current {
		//get {
		//		return new Service((ManagementObject)ObjectEnumerator.Current);
		//	}
		//}

		cmp = new CodeMemberProperty();
//		cmp.Type = PrivateNamesUsed["GeneratedClassName"].ToString();
		cmp.Type = new CodeTypeReference("Object");
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmp.Name = "Current";
		cmp.ImplementationTypes.Add("IEnumerator");
		//cmp.ImplementsType = "IEnumerator";
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PrivateNamesUsed["GeneratedClassName"].ToString());
		coce.Parameters.Add(new CodeCastExpression(PublicNamesUsed["LateBoundClass"].ToString(),
													new CodePropertyReferenceExpression(
														new CodeSnippetExpression(strObjectEnumerator),
														"Current")));
		cmp.GetStatements.Add(new CodeMethodReturnStatement(coce));
		ecc.Members.Add(cmp);

/*		//object IEnumerator.Current {
		//get {
		//		return Current;
		//	}
		//}

		cmp = new CodeMemberProperty();
		cmp.Attributes = MemberAttributes.VTableMask;
		cmp.Type = "object";
		cmp.Name = "IEnumerator.Current";
		cmp.GetStatements.Add(new CodeMethodReturnStatement(new CodeSnippetExpression("Current")));
		ecc.Members.Add(cmp);
*/
		//public bool MoveNext ()
		//{
		//	return ObjectEnumerator.MoveNext();
		//}

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmm.Name = "MoveNext";
		cmm.ImplementationTypes.Add("IEnumerator");
		//cmm.ImplementsType = "IEnumerator";
		cmm.ReturnType = new CodeTypeReference("Boolean");
		cmie = new CodeMethodInvokeExpression(
					new CodeSnippetExpression(strObjectEnumerator),
					"MoveNext"
					);

		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
		ecc.Members.Add(cmm);

		//public void Reset ()
		//{
		//	ObjectEnumerator.Reset();
		//}

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmm.Name = "Reset";
		cmm.ImplementationTypes.Add("IEnumerator");
		//cmm.ImplementsType = "IEnumerator";
		cmie = new CodeMethodInvokeExpression(
			new CodeSnippetExpression(strObjectEnumerator),
			"Reset"
			);
		cmm.Statements.Add(new CodeExpressionStatement (cmie));
		ecc.Members.Add(cmm);

		ccc.Members.Add(ecc);
	}

/// <summary>
/// This function will find a given string in the passed 
/// in a case insensitive manner and will return true if the string is found.
/// </summary>
	int IsContainedIn(String strToFind, ref SortedList sortedList)
	{
		int nIndex = -1;
		for (int i=0; i < sortedList.Count; i++)
		{
			if (String.Compare(sortedList.GetByIndex(i).ToString(),strToFind,true) == 0)
			{
				//The string is found. This is the index
				nIndex = i;
				break;
			}
		}
		return nIndex;
	}
/// <summary>
/// This function will convert the given CIMTYPE to an acceptable .NET type.
/// Since CLS doen't support lotz of the basic types, we are using .NET helper 
/// classes here. We safely assume that there won't be any problem using them
/// since .NET has to be there for the System.Management.Dll to work.
/// </summary>
/// <param name="cType"> </param>
/// <param name="Name"> </param>
	private string ConvertCIMType(CimType cType,bool isArray)
	{
		string retVal;
		switch(cType)
		{
			case CimType.SInt8:
			{
				retVal = "SByte";
				break;
			}
			case CimType.UInt8: //TODO : is this fine???
			{
				retVal = "Byte";
				break;
			}
			case CimType.SInt16:
			{
				retVal = "Int16";
				break;
			}
			case CimType.UInt16:
			{
				if (bUnsignedSupported == false)
				{
					retVal = "Int16";
				}
				else
				{
					retVal = "UInt16";
				}
				break;
			}
			case CimType.SInt32:
			{
				retVal = "Int32";
				break;
			}
			case CimType.UInt32:
			{
				if (bUnsignedSupported == false)
				{
					retVal = "Int32";
				}
				else
				{
					retVal = "UInt32";
				}
				break;
			}
			case CimType.SInt64:
			{
				retVal = "Int64";
				break;
			}
			case CimType.UInt64:
			{
				if (bUnsignedSupported == false)
				{
					retVal = "Int64";
				}
				else
				{
					retVal = "UInt64";
				}
				break;
			}
			case CimType.Real32:
			{
				retVal = "Single";
				break;
			}
			case CimType.Real64:
			{
				retVal = "Double";
				break;
			}
			case CimType.Boolean:
			{
				retVal = "Boolean";
				break;
			}
			case CimType.String:
			{
				retVal = "String";
				break;
			}
			case CimType.DateTime:
			{
				retVal = "DateTime";
				// Call this function to generate conversion function
				GenerateDateTimeConversionFunction();
				break;
			}
			case CimType.Reference:
			{
				retVal = "ManagementPath";
				break;
			}
			case CimType.Char16:
			{
				retVal = "Char";
				break;
			}
			case CimType.Object:
			default:
				retVal = "ManagementObject";
				break;
		}

		if (isArray == true)
		{
			retVal += " []";
		}
		return retVal;
	}
/// <summary>
/// This function is used to determine whether the given CIMTYPE can be represented as an integer.
/// This helper function is mainly used to determine whether this type will be support by enums.
/// </summary>
/// <param name="cType"> </param>
	private bool isTypeInt(CimType cType)
	{
		bool retVal;
		switch(cType)
		{
			case CimType.UInt8: //TODO : is this fine???
			case CimType.UInt16:
			case CimType.UInt32:
			case CimType.SInt8:
			case CimType.SInt16:
			case CimType.SInt32:
			{
				retVal = true;
				break;
			}
			case CimType.SInt64:
			case CimType.UInt64:
			case CimType.Real32:
			case CimType.Real64:
			case CimType.Boolean:
			case CimType.String:
			case CimType.DateTime:
			case CimType.Reference:
			case CimType.Char16:
			case CimType.Object:
			default:
				retVal = false;
				break;
		}

		return retVal;

	}

	/// <summary>
	///    <para>[To be supplied.]</para>
	/// </summary>
	public string GeneratedFileName
	{
		get
		{
			return genFileName;
		}
	}

	/// <summary>
	///    <para>[To be supplied.]</para>
	/// </summary>
	public string GeneratedTypeName
	{
		get
		{
			return PrivateNamesUsed["GeneratedNamespace"].ToString() + "." +
					PrivateNamesUsed["GeneratedClassName"].ToString();
		}
	}

	/// <summary>
	/// Function to convert a given ValueMap or BitMap name to propert enum name
	/// </summary>
	string ConvertValuesToName(string str)
	{
		string strRet = String.Empty;
		string strToReplace = "_";
		string strToAdd = String.Empty;
		bool  bAdd = true;
		if (str.Length == 0)
		{
			return string.Copy("");
		}

		char[] arrString = str.ToCharArray();
		// First character
		if (Char.IsLetter(arrString[0]) == false)
		{
			strRet = "Val_";
			strToAdd = "l";
		}

		for(int i=0;i < str.Length;i++)
		{
			bAdd = true;
			if (Char.IsLetterOrDigit(arrString[i]) == false)
			{
				// if the previous character added is "_" then
				// don't add that to the output string again
				if (strToAdd == strToReplace)
				{
					bAdd = false;
				}
				else
				{
					strToAdd = strToReplace;
				}
			}
			else
			{
				strToAdd = new string(arrString[i],1);
			}

			if (bAdd == true)
			{
				strRet = String.Concat(strRet,strToAdd);
			}
		}
		return strRet;
	}

	/// <summary>
	/// This function goes thru the names in array list and resolves any duplicates
	/// if any so that these names can be added as values of enum
	/// </summary>
	void ResolveEnumNameValues(ArrayList arrIn,ref ArrayList arrayOut)
	{
		arrayOut.Clear();
		int		nCurIndex = 0;
		string strToAdd = String.Empty;

		for( int i = 0 ; i < arrIn.Count ; i++)
		{
			strToAdd = arrIn[i].ToString();
			if (true == IsContainedInArray(strToAdd,arrayOut))
			{
				nCurIndex = 0;
				strToAdd = arrIn[i].ToString() + nCurIndex.ToString();
				while(true == IsContainedInArray(strToAdd,arrayOut))
				{
					nCurIndex++;
					strToAdd = arrIn[i].ToString() + nCurIndex.ToString();
				}

			}
			arrayOut.Add(strToAdd);
		}

	}

	/// <summary>
	/// This function will find a given string in the passed 
	/// array list.
	/// </summary>
	bool IsContainedInArray(String strToFind, ArrayList arrToSearch)
	{
		for (int i=0; i < arrToSearch.Count; i++)
		{
			if (String.Compare(arrToSearch[i].ToString(),strToFind) == 0)
			{
				return true;
			}
		}
		return false;
	}

	/// <summary>
	/// Function to create a appropriate generator
	/// </summary>
	bool InitializeCodeGenerator(CodeLanguage lang)
	{
		switch(lang)
		{
			case CodeLanguage.VB:
				cg = (new VBCodeProvider()).CreateGenerator ();
				break;
			
			case CodeLanguage.JScript:
				Type JScriptCodeProviderType = Type.GetType("Microsoft.JScript.JScriptCodeProvider,Microsoft.JScript"); 
				CodeDomProvider cp = (CodeDomProvider)Activator.CreateInstance(JScriptCodeProviderType);
				cg = cp.CreateGenerator();   
				break;

			case CodeLanguage.CSharp:
				cg = (new CSharpCodeProvider()).CreateGenerator ();
				break;

		}
		GetUnsignedSupport(lang);
		return true;

	}

	/// <summary>
	/// Function which checks if the language supports Unsigned numbers
	/// </summary>
	/// <param name="Language">Language</param>
	/// <returns>true - if unsigned is supported</returns>
	void GetUnsignedSupport(CodeLanguage Language)
	{
		switch(Language)
		{
			case CodeLanguage.CSharp:
				bUnsignedSupported = true;
				break;

			case CodeLanguage.VB:
			case CodeLanguage.JScript:
				bUnsignedSupported = false;
				break;

			default:
				break;
		}	
	}

	/// <summary>
	/// Function which adds commit function to commit all the changes
	/// to the object to WMI
	/// </summary>
	void GenerateCommitMethod()
	{
		cmm = new CodeMemberMethod();
		cmm.Name = PublicNamesUsed["CommitMethod"].ToString();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final;

		caa = new CodeAttributeArgument();
		caa.Value = new CodePrimitiveExpression(true);
		cad = new CodeAttributeDeclaration();
		cad.Name = "Browsable";
		cad.Arguments.Add(caa);
		cmm.CustomAttributes = new CodeAttributeDeclarationCollection();
		cmm.CustomAttributes.Add(cad);

		cmie = new CodeMethodInvokeExpression();
		cmie.Method.TargetObject = new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString());
		cmie.Method.MethodName = "Put";

		cmm.Statements.Add(new CodeExpressionStatement(cmie));
		cc.Members.Add(cmm);

	}

	/// <summary>
	/// Function to convert a value in format "0x..." to a integer
	/// to the object to WMI
	/// </summary>
	Int32 ConvertBitMapValueToInt32(String bitMap)
	{
		String strTemp = "0x";
		Int32 ret = 0;

		if (bitMap.StartsWith(strTemp) || bitMap.StartsWith(strTemp.ToUpper()))
		{
			strTemp = String.Empty;
			char[] arrString = bitMap.ToCharArray();
			int Len = bitMap.Length;
			for (int i = 2 ; i < Len ; i++)
			{
				strTemp = strTemp + arrString[i];
			}
			ret = Convert.ToInt32(strTemp);
		}
		else
		{
			ret = Convert.ToInt32(bitMap);
		}

		return ret;
	}

	/// <summary>
	/// Function to get the Converstion function to be used for Numeric datatypes
	/// </summary>
	String GetNumericConversionFunction(PropertyData prop)
	{
		String retFunctionName = String.Empty;

		switch(prop.Type)
		{
			case CimType.UInt8:  
			case CimType.UInt16: 						
			case CimType.UInt32:
			case CimType.SInt8:
			case CimType.SInt16:
			case CimType.SInt32:
				retFunctionName = "ToInt32";
				break;

		}
		return retFunctionName;
	}

	/// <summary>
	/// Function to genreate helper function for DMTF to DateTime and DateTime to DMTF 
	/// </summary>
	void GenerateDateTimeConversionFunction()
	{

		if (bDateConversionFunctionsAdded)
		{
			return;
		}

		AddToDateTimeFunction();
		AddToDMTFFunction();

		bDateConversionFunctionsAdded = true;

	}



	/// <summary>
	// Generated code for function to do conversion of date from DMTF format to DateTime format
	/// </summary>
	void AddToDateTimeFunction()
	{
		String dmtfParam = "dmtfDate";
		String year	= "year";
		String month = "month";
		String day = "day";
		String hour = "hour";
		String minute = "minute";
		String second = "second";
		String millisec = "millisec";
		String dmtf = "dmtf";
		String tempStr = "tempString";

		cmm = new CodeMemberMethod();
		cmm.Name = PrivateNamesUsed["ToDateTimeMethod"].ToString();
		cmm.Attributes = MemberAttributes.Final;
		cmm.ReturnType = new CodeTypeReference("DateTime");

		cmm.Parameters.Add(new CodeParameterDeclarationExpression("String",dmtfParam));

		//Int32 year = DateTime.Now.Year;
		cpre = new CodePropertyReferenceExpression(new CodeSnippetExpression("DateTime"),"Now");
		cmm.Statements.Add(new CodeVariableDeclarationStatement("Int32",year,
			new CodePropertyReferenceExpression(cpre,"Year")));
		//Int32 month = 1;
		cmm.Statements.Add(new CodeVariableDeclarationStatement("Int32",month,new CodePrimitiveExpression(1)));
		//Int32 day = 1;
		cmm.Statements.Add(new CodeVariableDeclarationStatement("Int32",day,new CodePrimitiveExpression(1)));
		//Int32 hour = 0;
		cmm.Statements.Add(new CodeVariableDeclarationStatement("Int32",hour,new CodePrimitiveExpression(0)));
		//Int32 minute = 0;
		cmm.Statements.Add(new CodeVariableDeclarationStatement("Int32",minute,new CodePrimitiveExpression(0)));
		//Int32 second = 0;
		cmm.Statements.Add(new CodeVariableDeclarationStatement("Int32",second,new CodePrimitiveExpression(0)));
		//Int32 millisec = 0;
		cmm.Statements.Add(new CodeVariableDeclarationStatement("Int32",millisec,new CodePrimitiveExpression(0)));
		//String dmtf = dmtfDate ;
		cmm.Statements.Add(new CodeVariableDeclarationStatement("String",dmtf,new CodeSnippetExpression(dmtfParam)));
		//String tempString = String.Empty ;
		cmm.Statements.Add(new CodeVariableDeclarationStatement("String",tempStr,new CodePropertyReferenceExpression(
			new CodeSnippetExpression("String"),"Empty")));


		/*		if (str == String.Empty || 
					str.Length != DMTF_DATETIME_STR_LENGTH )
					//|| str.IndexOf("*") >= 0 )
				{
					return DateTime.MinValue;
				}
		*/
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodePropertyReferenceExpression(new CodeSnippetExpression("String"),"Empty");
		cboe.Right = new CodeSnippetExpression(dmtf);
		cboe.Operator = CodeBinaryOperatorType.IdentityEquality;
		
		CodeBinaryOperatorExpression cboe1 = new CodeBinaryOperatorExpression();
		cboe1.Left = new CodePropertyReferenceExpression(new CodeSnippetExpression(dmtf),"Length");
		cboe1.Right = new CodePrimitiveExpression(DMTF_DATETIME_STR_LENGTH);
		cboe1.Operator = CodeBinaryOperatorType.IdentityInequality;

		CodeBinaryOperatorExpression cboe2 = new CodeBinaryOperatorExpression();
		cboe2.Left = cboe;
		cboe2.Right = cboe1;
		cboe2.Operator = CodeBinaryOperatorType.BooleanOr;

		cis = new CodeConditionStatement();
		cis.Condition = cboe2;
		cis.TrueStatements.Add(new CodeMethodReturnStatement(new CodePropertyReferenceExpression(
			new CodeSnippetExpression("DateTime"),"MinValue")));

		cmm.Statements.Add(cis);

		DateTimeConversionFunctionHelper("****",tempStr,dmtf,year,0,4);
		DateTimeConversionFunctionHelper("**",tempStr,dmtf,month,4,2);
		DateTimeConversionFunctionHelper("**",tempStr,dmtf,day,6,2);
		DateTimeConversionFunctionHelper("**",tempStr,dmtf,hour,8,2);
		DateTimeConversionFunctionHelper("**",tempStr,dmtf,minute,10,2);
		DateTimeConversionFunctionHelper("**",tempStr,dmtf,second,12,2);
		DateTimeConversionFunctionHelper("***",tempStr,dmtf,millisec,15,3);

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference("DateTime");
		coce.Parameters.Add(new CodeSnippetExpression(year));
		coce.Parameters.Add(new CodeSnippetExpression(month));
		coce.Parameters.Add(new CodeSnippetExpression(day));
		coce.Parameters.Add(new CodeSnippetExpression(hour));
		coce.Parameters.Add(new CodeSnippetExpression(minute));
		coce.Parameters.Add(new CodeSnippetExpression(second));
		coce.Parameters.Add(new CodeSnippetExpression(millisec));

		String retDateVar = "dateRet";
		cmm.Statements.Add(new CodeVariableDeclarationStatement("DateTime",retDateVar,coce));

		cmm.Statements.Add(new CodeMethodReturnStatement(new CodeSnippetExpression(retDateVar)));
		cc.Members.Add(cmm);
	}

	/// <summary>
	// Generated code for function to do conversion of date from DateTime format to DMTF format
	/// </summary>
	void AddToDMTFFunction()
	{
		String tempStr = "tempString";
		String dateParam = "dateParam";
		String currentZone = "curZone";
		String timeOffset = "tickOffset";

		cmm = new CodeMemberMethod();
		cmm.Name = PrivateNamesUsed["ToDMTFTimeMethod"].ToString();
		cmm.Attributes = MemberAttributes.Final;
		cmm.ReturnType = new CodeTypeReference("String");
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("DateTime",dateParam));

		// tempString = dateParam.Year.ToString();
		cmie = new CodeMethodInvokeExpression();
		cpre = new CodePropertyReferenceExpression(new CodeSnippetExpression(dateParam),"Year");
		cmie.Method = new CodeMethodReferenceExpression(cpre,"ToString");

		//String tempString = dateParam.Year.ToString() ;
		cmm.Statements.Add(new CodeVariableDeclarationStatement("String",tempStr,cmie));


		//tempString = tempString + dateParam.Month.ToString().PadLeft(2, '0');
		cmie = new CodeMethodInvokeExpression();
		cpre = new CodePropertyReferenceExpression(new CodeSnippetExpression(dateParam),"Month");
		cmie.Method = new CodeMethodReferenceExpression(cpre,"ToString");
		CodeMethodInvokeExpression cmie2 = new CodeMethodInvokeExpression();
		cmie2.Method = new CodeMethodReferenceExpression(cmie,"PadLeft");
		cmie2.Parameters.Add(new CodePrimitiveExpression(2));
		cmie2.Parameters.Add(new CodePrimitiveExpression('0'));

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeSnippetExpression(tempStr);
		cboe.Right = cmie2;
		cboe.Operator = CodeBinaryOperatorType.Add;
		cmm.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(tempStr),cboe));


		//tempString = tempString + dateParam.Day.ToString().PadLeft(2, '0');
		cmie = new CodeMethodInvokeExpression();
		cpre = new CodePropertyReferenceExpression(new CodeSnippetExpression(dateParam),"Day");
		cmie.Method = new CodeMethodReferenceExpression(cpre,"ToString");
		cmie2 = new CodeMethodInvokeExpression();
		cmie2.Method = new CodeMethodReferenceExpression(cmie,"PadLeft");
		cmie2.Parameters.Add(new CodePrimitiveExpression(2));
		cmie2.Parameters.Add(new CodePrimitiveExpression('0'));

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeSnippetExpression(tempStr);
		cboe.Right = cmie2;
		cboe.Operator = CodeBinaryOperatorType.Add;
		cmm.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(tempStr),cboe));


		//tempString = tempString + dateParam.Hour.ToString().PadLeft(2, '0');
		cmie = new CodeMethodInvokeExpression();
		cpre = new CodePropertyReferenceExpression(new CodeSnippetExpression(dateParam),"Hour");
		cmie.Method = new CodeMethodReferenceExpression(cpre,"ToString");
		cmie2 = new CodeMethodInvokeExpression();
		cmie2.Method = new CodeMethodReferenceExpression(cmie,"PadLeft");
		cmie2.Parameters.Add(new CodePrimitiveExpression(2));
		cmie2.Parameters.Add(new CodePrimitiveExpression('0'));

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeSnippetExpression(tempStr);
		cboe.Right = cmie2;
		cboe.Operator = CodeBinaryOperatorType.Add;
		cmm.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(tempStr),cboe));

		//tempString = tempString + dateParam.Minute.ToString().PadLeft(2, '0');
		cmie = new CodeMethodInvokeExpression();
		cpre = new CodePropertyReferenceExpression(new CodeSnippetExpression(dateParam),"Minute");
		cmie.Method = new CodeMethodReferenceExpression(cpre,"ToString");
		cmie2 = new CodeMethodInvokeExpression();
		cmie2.Method = new CodeMethodReferenceExpression(cmie,"PadLeft");
		cmie2.Parameters.Add(new CodePrimitiveExpression(2));
		cmie2.Parameters.Add(new CodePrimitiveExpression('0'));

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeSnippetExpression(tempStr);
		cboe.Right = cmie2;
		cboe.Operator = CodeBinaryOperatorType.Add;
		cmm.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(tempStr),cboe));

		//tempString = tempString + dateParam.Second.ToString().PadLeft(2, '0');
		cmie = new CodeMethodInvokeExpression();
		cpre = new CodePropertyReferenceExpression(new CodeSnippetExpression(dateParam),"Second");
		cmie.Method = new CodeMethodReferenceExpression(cpre,"ToString");
		cmie2 = new CodeMethodInvokeExpression();
		cmie2.Method = new CodeMethodReferenceExpression(cmie,"PadLeft");
		cmie2.Parameters.Add(new CodePrimitiveExpression(2));
		cmie2.Parameters.Add(new CodePrimitiveExpression('0'));

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeSnippetExpression(tempStr);
		cboe.Right = cmie2;
		cboe.Operator = CodeBinaryOperatorType.Add;
		cmm.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(tempStr),cboe));

		//tempString = tempString + ".";
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeSnippetExpression(tempStr);
		cboe.Right = new CodePrimitiveExpression(".");
		cboe.Operator = CodeBinaryOperatorType.Add;
		cmm.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(tempStr),cboe));

		//tempString = tempString + dateParam.Millisecond.ToString().PadLeft(3, '0');
		cmie = new CodeMethodInvokeExpression();
		cpre = new CodePropertyReferenceExpression(new CodeSnippetExpression(dateParam),"Millisecond");
		cmie.Method = new CodeMethodReferenceExpression(cpre,"ToString");
		cmie2 = new CodeMethodInvokeExpression();
		cmie2.Method = new CodeMethodReferenceExpression(cmie,"PadLeft");
		cmie2.Parameters.Add(new CodePrimitiveExpression(3));
		cmie2.Parameters.Add(new CodePrimitiveExpression('0'));

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeSnippetExpression(tempStr);
		cboe.Right = cmie2;
		cboe.Operator = CodeBinaryOperatorType.Add;
		cmm.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(tempStr),cboe));

		//tempString = tempString + "000";  
		//this is to compensate for lack of microseconds in DateTime
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeSnippetExpression(tempStr);
		cboe.Right = new CodeSnippetExpression("000");
		cboe.Operator = CodeBinaryOperatorType.Add;
		cmm.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(tempStr),cboe));

		// TimeZone curZone = TimeZone.CurrentTimeZone;
		cmm.Statements.Add(new CodeVariableDeclarationStatement("TimeZone",currentZone,
														new CodePropertyReferenceExpression(
														new CodeSnippetExpression("TimeZone"),
														"CurrentTimeZone")));


		// TimeSpan tickOffset = curZone.GetUtcOffset(wfcTime);
		cmm.Statements.Add(new CodeVariableDeclarationStatement("TimeSpan",timeOffset,
							new CodeMethodInvokeExpression(
							new CodeSnippetExpression(currentZone),
							"GetUtcOffset",
							new CodeSnippetExpression((dateParam)))));



		//	if (tickOffset.Ticks >= 0)
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodePropertyReferenceExpression(new CodeSnippetExpression(timeOffset),"Ticks");
		cboe.Right = new CodePrimitiveExpression(0);
		cboe.Operator = CodeBinaryOperatorType.GreaterThanOrEqual;

		cis = new CodeConditionStatement();
		cis.Condition = cboe;

		//tempString = tempString + "+";
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeSnippetExpression(tempStr);
		cboe.Right = new CodePrimitiveExpression("+");
		cboe.Operator = CodeBinaryOperatorType.Add;
		cis.TrueStatements.Add(new CodeAssignStatement(new CodeSnippetExpression(tempStr),cboe));


		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodePropertyReferenceExpression(new CodeSnippetExpression(timeOffset),"Ticks");
		cboe.Right = new CodePropertyReferenceExpression(new CodeSnippetExpression("TimeSpan"),"TicksPerMinute");
		cboe.Operator = CodeBinaryOperatorType.Divide;
		cmie = new CodeMethodInvokeExpression();
		cmie.Method = new CodeMethodReferenceExpression(cboe,"ToString");

		CodeBinaryOperatorExpression cboe1 = new CodeBinaryOperatorExpression();
		cboe1 = new CodeBinaryOperatorExpression();
		cboe1.Left = new CodeSnippetExpression(tempStr);
		cboe1.Right = cmie;
		cboe1.Operator = CodeBinaryOperatorType.Add;
		cis.TrueStatements.Add(new CodeAssignStatement(new CodeSnippetExpression(tempStr),cboe1));
		

		
		//tempString = tempString + "-";
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeSnippetExpression(tempStr);
		cboe.Right = new CodePrimitiveExpression("-");
		cboe.Operator = CodeBinaryOperatorType.Add;
		cis.FalseStatements.Add(new CodeAssignStatement(new CodeSnippetExpression(tempStr),cboe));


		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodePropertyReferenceExpression(new CodeSnippetExpression(timeOffset),"Ticks");
		cboe.Right = new CodePropertyReferenceExpression(new CodeSnippetExpression("TimeSpan"),"TicksPerMinute");
		cboe.Operator = CodeBinaryOperatorType.Divide;
		cmie = new CodeMethodInvokeExpression();
		cmie.Method = new CodeMethodReferenceExpression(cboe,"ToString");

		cmie2 = new CodeMethodInvokeExpression();
		cmie2.Method = new CodeMethodReferenceExpression(cmie,"Substring");
		cmie2.Parameters.Add(new CodePrimitiveExpression(1));
		cmie2.Parameters.Add(new CodePrimitiveExpression(3));

		cboe1 = new CodeBinaryOperatorExpression();
		cboe1 = new CodeBinaryOperatorExpression();
		cboe1.Left = new CodeSnippetExpression(tempStr);
		cboe1.Right = cmie2;
		cboe1.Operator = CodeBinaryOperatorType.Add;
		cis.FalseStatements.Add(new CodeAssignStatement(new CodeSnippetExpression(tempStr),cboe1));

		cmm.Statements.Add(cis);
		cmm.Statements.Add(new CodeMethodReturnStatement(new CodeSnippetExpression(tempStr)));

		cc.Members.Add(cmm);

	}
	/// <summary>
	// Generates some common code used in conversion function for DateTime
	/// </summary>
	void DateTimeConversionFunctionHelper(String toCompare,
		String tempVarName,
		String dmtfVarName,
		String toAssign,
		Int32 SubStringParam1, 
		Int32 SubStringParam2)
	{
		CodeMethodReferenceExpression  cmre = new CodeMethodReferenceExpression(new CodeSnippetExpression(dmtfVarName),"Substring");
		cmie = new CodeMethodInvokeExpression();
		cmie.Method = cmre;
		cmie.Parameters.Add(new CodePrimitiveExpression(SubStringParam1));
		cmie.Parameters.Add(new CodePrimitiveExpression(SubStringParam2));
		cmm.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(tempVarName), cmie));

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodePrimitiveExpression(toCompare);
		cboe.Right = new CodeSnippetExpression(tempVarName);
		cboe.Operator = CodeBinaryOperatorType.IdentityInequality;

		cis = new CodeConditionStatement();
		cis.Condition = cboe;
		cmre = new CodeMethodReferenceExpression(new CodeSnippetExpression("Int32"),"Parse");
		cmie = new CodeMethodInvokeExpression();
		cmie.Method = cmre;
		cmie.Parameters.Add(new CodeSnippetExpression(tempVarName));

		cis.TrueStatements.Add( new CodeAssignStatement(new CodeSnippetExpression(toAssign),cmie));

		cmm.Statements.Add(cis);
	}

	/// <summary>
	// Checks if a given property is to be visible for Designer seriliazation
	/// </summary>
	bool IsDesignerSerializationVisibilityToBeSet(String propName)
	{
		if (String.Compare(propName,"Path",true) != 0)
		{
			return true;
		}
		return false;
	}
	

	/// <summary>
	/// Checks if the given property type is represented as ValueType
	/// </summary>
	private bool IsPropertyValueType(CimType cType)
	{
		bool ret = true;
		switch(cType)
		{
			case CimType.String:
			case CimType.Reference:
			case CimType.Object:
				ret = false;
				break;

		}
		return ret;
	}

	/// <summary>
	/// Gets the dynamic qualifier on the class to find if the 
	/// class is a dynamic class
	/// </summary>
	private bool  IsDynamicClass()
	{
		bool ret = false;
		try
		{
			ret = Convert.ToBoolean(classobj.Qualifiers["dynamic"].Value);
		}
		catch(ManagementException)
		{
			// do nothing. THis may be due to dynamic qualifer not presen which is equivalent
			// dynamic qualifier absent
		}
		return ret;
	}
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\managementexception.cs ===
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using WbemClient_v1;

namespace System.Management
{

	/// <summary>
	/// Enumeration of all currently defined WMI error codes
	/// </summary>
	public enum ManagementStatus
	{
		/// <summary>
		///    The operation was successful.
		/// </summary>
		NoError							= 0,
		/// <summary>
		///    This will be returned when no more objects are available, the number of
		///    objects returned is less than the number requested, or at the end of an
		///    enumeration. It is also returned when this method is called with a value of zero
		///    for the <paramref name="uCount"/> parameter.
		/// </summary>
		False							= 1,
		/// <summary>
		///    An overridden property was deleted.This value is
		///    returned to signal that the original non-overridden value has been restored as a
		///    result of the deletion.
		/// </summary>
		ResetToDefault					= 0x40002,
		/// <summary>
		///    The items (objects, classes, and so on) being compared
		///    are not identical.
		/// </summary>
		Different		                = 0x40003,
		/// <summary>
		///    A call timed out.This is not an error condition.
		///    Therefore, some results may have also been returned.
		/// </summary>
		Timedout						= 0x40004,
		/// <summary>
		///    <para> No more data is available from the enumeration, and the 
		///       user should terminate the enumeration. </para>
		/// </summary>
		NoMoreData						= 0x40005,
		/// <summary>
		///    The operation was intentionally or unintentionally
		///    canceled.
		/// </summary>
		OperationCanceled				= 0x40006,
		/// <summary>
		///    A request is still in progress, and the results are not
		///    yet available.
		/// </summary>
		Pending			                = 0x40007,
		/// <summary>
		///    <para> More that one copy of the same object was detected in 
		///       the result set of an enumeration. </para>
		/// </summary>
		DuplicateObjects				= 0x40008,
		/// <summary>
		///    The user did not receive all of the objects requested
		///    due to inaccessible resources (other than security violations).
		/// </summary>
		PartialResults					= 0x40010,
		/// <summary>
		///    <para>The call failed.</para>
		/// </summary>
		Failed                          = unchecked((int)0x80041001),
		/// <summary>
		///    <para> The object could not be found. </para>
		/// </summary>
		NotFound                        = unchecked((int)0x80041002),
		/// <summary>
		///    The current user does not have permission to perform the
		///    action.
		/// </summary>
		AccessDenied                    = unchecked((int)0x80041003),
		/// <summary>
		///    <para> The provider has failed at some time other than during 
		///       initialization. </para>
		/// </summary>
		ProviderFailure                 = unchecked((int)0x80041004),
		/// <summary>
		///    A type mismatch occurred.
		/// </summary>
		TypeMismatch                    = unchecked((int)0x80041005),
		/// <summary>
		///    There was not enough memory for the operation.
		/// </summary>
		OutOfMemory                     = unchecked((int)0x80041006),
		/// <summary>
		/// <para>The <see langword='context object '/> is not valid.</para>
		/// </summary>
		InvalidContext                  = unchecked((int)0x80041007),
		/// <summary>
		///    <para> One of the parameters to the call is not correct. 
		///    </para>
		/// </summary>
		InvalidParameter                = unchecked((int)0x80041008),
		/// <summary>
		///    <para> The resource, typically a remote server, is not 
		///       currently available. </para>
		/// </summary>
		NotAvailable                    = unchecked((int)0x80041009),
		/// <summary>
		///    <para>An internal, critical, and unexpected error occurred. 
		///       Report this error to Microsoft Technical Support.</para>
		/// </summary>
		CriticalError                   = unchecked((int)0x8004100A),
		/// <summary>
		///    <para>One or more network packets were corrupted during a remote session.</para>
		/// </summary>
		InvalidStream                   = unchecked((int)0x8004100B),
		/// <summary>
		///    <para> The feature or operation is not supported. </para>
		/// </summary>
		NotSupported                    = unchecked((int)0x8004100C),
		/// <summary>
		///    The superclass specified is not valid.
		/// </summary>
		InvalidSuperclass               = unchecked((int)0x8004100D),
		/// <summary>
		///    <para> The namespace specified could not be found. </para>
		/// </summary>
		InvalidNamespace                = unchecked((int)0x8004100E),
		/// <summary>
		///    The specified instance is not valid.
		/// </summary>
		InvalidObject                   = unchecked((int)0x8004100F),
		/// <summary>
		///    The specified class is not valid.
		/// </summary>
		InvalidClass                    = unchecked((int)0x80041010),
		/// <summary>
		///    A provider referenced in the schema does not have a
		///    corresponding registration.
		/// </summary>
		ProviderNotFound				= unchecked((int)0x80041011),
		/// <summary>
		///    A provider referenced in the schema has an incorrect or
		///    incomplete registration.
		/// </summary>
		InvalidProviderRegistration		= unchecked((int)0x80041012),
		/// <summary>
		///    COM cannot locate a provider referenced in the schema.
		/// </summary>
		ProviderLoadFailure				= unchecked((int)0x80041013),
		/// <summary>
		///    <DD>A component, such as a provider, failed to initialize for internal reasons. 
		///    </DD>
		/// </summary>
		InitializationFailure           = unchecked((int)0x80041014),
		/// <summary>
		///    A networking error that prevents normal operation has
		///    occurred.
		/// </summary>
		TransportFailure                = unchecked((int)0x80041015),
		/// <summary>
		///    <para> The requested operation is not valid. This error usually 
		///       applies to invalid attempts to delete classes or properties. </para>
		/// </summary>
		InvalidOperation                = unchecked((int)0x80041016),
		/// <summary>
		///    The query was not syntactically valid.
		/// </summary>
		InvalidQuery                    = unchecked((int)0x80041017),
		/// <summary>
		///    <para>The requested query language is not supported</para>
		/// </summary>
		InvalidQueryType				= unchecked((int)0x80041018),
		/// <summary>
		///    In a put operation, the <see langword='wbemChangeFlagCreateOnly'/>
		///    flag was specified, but the instance already exists.
		/// </summary>
		AlreadyExists                   = unchecked((int)0x80041019),
		/// <summary>
		///    <DD>It is not possible to perform the add operation on this qualifier because 
		///       the owning object does not permit overrides. </DD>
		/// </summary>
		OverrideNotAllowed				= unchecked((int)0x8004101A),
		/// <summary>
		///    <para> The user attempted to delete a qualifier that was not 
		///       owned. The qualifier was inherited from a parent class. </para>
		/// </summary>
		PropagatedQualifier             = unchecked((int)0x8004101B),
		/// <summary>
		///    <para> The user attempted to delete a property that was not 
		///       owned. The property was inherited from a parent class. </para>
		/// </summary>
		PropagatedProperty              = unchecked((int)0x8004101C),
		/// <summary>
		///    The client made an unexpected and illegal sequence of
		///    calls.
		/// </summary>
		Unexpected                      = unchecked((int)0x8004101D),
		/// <summary>
		///    <para>The user requested an illegal operation, such as 
		///       spawning a class from an instance.</para>
		/// </summary>
		IllegalOperation                = unchecked((int)0x8004101E),
		/// <summary>
		///    <para> There was an illegal attempt to specify a key qualifier 
		///       on a property that cannot be a key. The keys are specified in the class
		///       definition for an object, and cannot be altered on a per-instance basis.
		///    </para>
		/// </summary>
		CannotBeKey						= unchecked((int)0x8004101F),
		/// <summary>
		///    The current object is not a valid class definition.
		///    Either it is incomplete, or it has not been registered with WMI using
		/// <see langword='Put().'/>
		/// </summary>
		IncompleteClass                 = unchecked((int)0x80041020),
		/// <summary>
		///    Reserved for future use.
		/// </summary>
		InvalidSyntax                   = unchecked((int)0x80041021),
		/// <summary>
		///    Reserved for future use.
		/// </summary>
		NondecoratedObject              = unchecked((int)0x80041022),
		/// <summary>
		///    <para>The property that you are attempting to modify is read-only.</para>
		/// </summary>
		ReadOnly                        = unchecked((int)0x80041023),
		/// <summary>
		///    <para> The provider cannot perform the requested operation. This 
		///       would include a query that is too complex, retrieving an instance, creating or
		///       updating a class, deleting a class, or enumerating a class. </para>
		/// </summary>
		ProviderNotCapable				= unchecked((int)0x80041024),
		/// <summary>
		///    An attempt was made to make a change that would
		///    invalidate a subclass.
		/// </summary>
		ClassHasChildren				= unchecked((int)0x80041025),
		/// <summary>
		///    <para> An attempt has been made to delete or modify a class that 
		///       has instances. </para>
		/// </summary>
		ClassHasInstances				= unchecked((int)0x80041026),
		/// <summary>
		///    Reserved for future use.
		/// </summary>
		QueryNotImplemented				= unchecked((int)0x80041027),
		/// <summary>
		///    A value of Nothing was specified for a property that may
		///    not be Nothing, such as one that is marked by a <see langword='Key'/>, <see langword='Indexed'/>, or
		/// <see langword='Not_Null'/> qualifier.
		/// </summary>
		IllegalNull                     = unchecked((int)0x80041028),
		/// <summary>
		///    <para>The value for a qualifier was provided that is not of a 
		///       legal qualifier type.</para>
		/// </summary>
		InvalidQualifierType			= unchecked((int)0x80041029),
		/// <summary>
		///    The CIM type specified for a property is not valid.
		/// </summary>
		InvalidPropertyType				= unchecked((int)0x8004102A),
		/// <summary>
		///    <para> The request was made with an out-of-range value, or is 
		///       incompatible with the type. </para>
		/// </summary>
		ValueOutOfRange					= unchecked((int)0x8004102B),
		/// <summary>
		///    <para>An illegal attempt was made to make a class singleton, 
		///       such as when the class is derived from a non-singleton class.</para>
		/// </summary>
		CannotBeSingleton				= unchecked((int)0x8004102C),
		/// <summary>
		///    The CIM type specified is not valid.
		/// </summary>
		InvalidCimType					= unchecked((int)0x8004102D),
		/// <summary>
		///    The requested method is not available.
		/// </summary>
		InvalidMethod                   = unchecked((int)0x8004102E),
		/// <summary>
		///    <para> The parameters provided for the method are not valid. 
		///    </para>
		/// </summary>
		InvalidMethodParameters			= unchecked((int)0x8004102F),
		/// <summary>
		///    There was an attempt to get qualifiers on a system
		///    property.
		/// </summary>
		SystemProperty                  = unchecked((int)0x80041030),
		/// <summary>
		///    The property type is not recognized.
		/// </summary>
		InvalidProperty                 = unchecked((int)0x80041031),
		/// <summary>
		///    <para> An asynchronous process has been canceled internally or 
		///       by the user. Note that due to the timing and nature of the asynchronous
		///       operation the operation may not have been truly canceled. </para>
		/// </summary>
		CallCanceled                   = unchecked((int)0x80041032),
		/// <summary>
		///    <para>The user has requested an operation while WMI is in the 
		///       process of shutting down.</para>
		/// </summary>
		ShuttingDown                    = unchecked((int)0x80041033),
		/// <summary>
		///    <para> An attempt was made to reuse an existing method name from 
		///       a superclass, and the signatures did not match. </para>
		/// </summary>
		PropagatedMethod                = unchecked((int)0x80041034),
		/// <summary>
		///    <para> One or more parameter values, such as a query text, is 
		///       too complex or unsupported. WMI is therefore requested to retry the operation
		///       with simpler parameters. </para>
		/// </summary>
		UnsupportedParameter            = unchecked((int)0x80041035),
		/// <summary>
		///    A parameter was missing from the method call.
		/// </summary>
		MissingParameterID		        = unchecked((int)0x80041036),
		/// <summary>
		///    A method parameter has an invalid <see langword='ID'/> qualifier.
		/// </summary>
		InvalidParameterID				= unchecked((int)0x80041037),
		/// <summary>
		/// <para> One or more of the method parameters have <see langword='ID'/> 
		/// qualifiers that are out of sequence. </para>
		/// </summary>
		NonconsecutiveParameterIDs		= unchecked((int)0x80041038),
		/// <summary>
		/// <para> The return value for a method has an <see langword='ID'/> qualifier. 
		/// </para>
		/// </summary>
		ParameterIDOnRetval				= unchecked((int)0x80041039),
		/// <summary>
		///    The specified object path was invalid.
		/// </summary>
		InvalidObjectPath				= unchecked((int)0x8004103A),
		/// <summary>
		///    <para> There is not enough free disk space to continue the 
		///       operation. </para>
		/// </summary>
		OutOfDiskSpace					= unchecked((int)0x8004103B),
		/// <summary>
		///    <para> The supplied buffer was too small to hold all the objects 
		///       in the enumerator or to read a string property. </para>
		/// </summary>
		BufferTooSmall					= unchecked((int)0x8004103C),
		/// <summary>
		///    The provider does not support the requested put
		///    operation.
		/// </summary>
		UnsupportedPutExtension			= unchecked((int)0x8004103D),
		/// <summary>
		///    <para> An object with an incorrect type or version was 
		///       encountered during marshaling. </para>
		/// </summary>
		UnknownObjectType				= unchecked((int)0x8004103E),
		/// <summary>
		///    <para> A packet with an incorrect type or version was 
		///       encountered during marshaling. </para>
		/// </summary>
		UnknownPacketType				= unchecked((int)0x8004103F),
		/// <summary>
		///    The packet has an unsupported version.
		/// </summary>
		MarshalVersionMismatch			= unchecked((int)0x80041040),
		/// <summary>
		///    <para>The packet appears to be corrupted.</para>
		/// </summary>
		MarshalInvalidSignature			= unchecked((int)0x80041041),
		/// <summary>
		///    An attempt has been made to mismatch qualifiers, such as
		///    putting [key] on an object instead of a property.
		/// </summary>
		InvalidQualifier				= unchecked((int)0x80041042),
		/// <summary>
		///    A duplicate parameter has been declared in a CIM method.
		/// </summary>
		InvalidDuplicateParameter		= unchecked((int)0x80041043),
		/// <summary>
		///    <para> Reserved for future use. </para>
		/// </summary>
		TooMuchData						= unchecked((int)0x80041044),
		/// <summary>
		///    <para>The delivery of an event has failed. The provider may 
		///       choose to refire the event.</para>
		/// </summary>
		ServerTooBusy					= unchecked((int)0x80041045),
		/// <summary>
		///    The specified flavor was invalid.
		/// </summary>
		InvalidFlavor					= unchecked((int)0x80041046),
		/// <summary>
		///    <para> An attempt has been made to create a reference that is 
		///       circular (for example, deriving a class from itself). </para>
		/// </summary>
		CircularReference				= unchecked((int)0x80041047),
		/// <summary>
		///    The specified class is not supported.
		/// </summary>
		UnsupportedClassUpdate			= unchecked((int)0x80041048),
		/// <summary>
		///    <para> An attempt was made to change a key when instances or 
		///       subclasses are already using the key. </para>
		/// </summary>
		CannotChangeKeyInheritance		= unchecked((int)0x80041049),
		/// <summary>
		///    <para> An attempt was made to change an index when instances or 
		///       subclasses are already using the index. </para>
		/// </summary>
		CannotChangeIndexInheritance	= unchecked((int)0x80041050),
		/// <summary>
		///    <para> An attempt was made to create more properties than the 
		///       current version of the class supports. </para>
		/// </summary>
		TooManyProperties				= unchecked((int)0x80041051),
		/// <summary>
		///    <para> A property was redefined with a conflicting type in a 
		///       derived class. </para>
		/// </summary>
		UpdateTypeMismatch				= unchecked((int)0x80041052),
		/// <summary>
		///    <para> An attempt was made in a derived class to override a 
		///       non-overrideable qualifier. </para>
		/// </summary>
		UpdateOverrideNotAllowed		= unchecked((int)0x80041053),
		/// <summary>
		///    <para> A method was redeclared with a conflicting signature in a 
		///       derived class. </para>
		/// </summary>
		UpdatePropagatedMethod			= unchecked((int)0x80041054),
		/// <summary>
		///    An attempt was made to execute a method not marked with
		///    [implemented] in any relevant class.
		/// </summary>
		MethodNotImplemented			= unchecked((int)0x80041055),
		/// <summary>
		///    <para> An attempt was made to execute a method marked with 
		///       [disabled]. </para>
		/// </summary>
		MethodDisabled      			= unchecked((int)0x80041056),
		/// <summary>
		///    <para> The refresher is busy with another operation. </para>
		/// </summary>
		RefresherBusy					= unchecked((int)0x80041057),
		/// <summary>
		///    <para> The filtering query is syntactically invalid. </para>
		/// </summary>
		UnparsableQuery                 = unchecked((int)0x80041058),
		/// <summary>
		///    The FROM clause of a filtering query references a class
		///    that is not an event class.
		/// </summary>
		NotEventClass					= unchecked((int)0x80041059),
		/// <summary>
		///    A GROUP BY clause was used without the corresponding
		///    GROUP WITHIN clause.
		/// </summary>
		MissingGroupWithin				= unchecked((int)0x8004105A),
		/// <summary>
		///    A GROUP BY clause was used. Aggregation on all properties
		///    is not supported.
		/// </summary>
		MissingAggregationList			= unchecked((int)0x8004105B),
		/// <summary>
		///    <para> Dot notation was used on a property that is not an 
		///       embedded object. </para>
		/// </summary>
		PropertyNotAnObject				= unchecked((int)0x8004105C),
		/// <summary>
		///    A GROUP BY clause references a property that is an
		///    embedded object without using dot notation.
		/// </summary>
		AggregatingByObject				= unchecked((int)0x8004105D),
		/// <summary>
		///    An event provider registration query
		///    (<see langword='__EventProviderRegistration'/>) did not specify the classes for which
		///    events were provided.
		/// </summary>
		UninterpretableProviderQuery	= unchecked((int)0x8004105F),
		/// <summary>
		///    <para> An request was made to back up or restore the repository 
		///       while WinMgmt.exe was using it. </para>
		/// </summary>
		BackupRestoreWinmgmtRunning		= unchecked((int)0x80041060),
		/// <summary>
		///    <para> The asynchronous delivery queue overflowed due to the 
		///       event consumer being too slow. </para>
		/// </summary>
		QueueOverflow                   = unchecked((int)0x80041061),
		/// <summary>
		///    The operation failed because the client did not have the
		///    necessary security privilege.
		/// </summary>
		PrivilegeNotHeld				= unchecked((int)0x80041062),
		/// <summary>
		///    <para>The operator is not valid for this property type.</para>
		/// </summary>
		InvalidOperator                 = unchecked((int)0x80041063),
		/// <summary>
		///    <para> The user specified a username/password/authority on a 
		///       local connection. The user must use a blank username/password and rely on
		///       default security. </para>
		/// </summary>
		LocalCredentials                = unchecked((int)0x80041064),
		/// <summary>
		///    <para> The class was made abstract when its superclass is not 
		///       abstract. </para>
		/// </summary>
		CannotBeAbstract				= unchecked((int)0x80041065),
		/// <summary>
		///    <para> An amended object was PUT without the 
		///       WBEM_FLAG_USE_AMENDED_QUALIFIERS flag being specified. </para>
		/// </summary>
		AmendedObject					= unchecked((int)0x80041066),
		/// <summary>
		///    The client was not retrieving objects quickly enough from
		///    an enumeration.
		/// </summary>
		ClientTooSlow					= unchecked((int)0x80041067),

		/// <summary>
		///    <para> The provider registration overlaps with the system event 
		///       domain. </para>
		/// </summary>
		RegistrationTooBroad			= unchecked((int)0x80042001),
		/// <summary>
		///    <para> A WITHIN clause was not used in this query. </para>
		/// </summary>
		RegistrationTooPrecise			= unchecked((int)0x80042002)
	}

	/// <summary>
	/// This class represents management exceptions
	/// </summary>
    [Serializable]
	public class ManagementException : SystemException 
	{
		private ManagementBaseObject	errorObject = null;
		private ManagementStatus		errorCode = 0;

        internal static void ThrowIfFailed(int hresult, bool supportsErrorInfo)
        {
/*
            if (hresult < 0)
            {
                if ((hresult & 0xfffff000) == 0x80041000)
                    ManagementException.ThrowWithExtendedInfo((ManagementStatus)hresult);
                else
                    Marshal.ThrowExceptionForHR(hresult);
            }
*/
            ManagementBaseObject errObj = null;
            string msg = null;

            if (supportsErrorInfo)
            {
                //Try to get extended error info first, and save in errorObject member
                IWbemClassObjectFreeThreaded obj = WbemErrorInfo.GetErrorInfo();
                if (obj != null)
                    errObj = new ManagementBaseObject(obj);
            }

            //If the error code is not a WMI one and there's an extended error object available, stick the message
            //from the extended error object in.
            if (((msg = GetMessage((ManagementStatus)hresult)) == null) && (errObj != null))
                try 
                {
                    msg = (string)errObj["Description"];
                } 
                catch {}

            throw new ManagementException((ManagementStatus)hresult, msg, errObj);
        }

		internal static void ThrowWithExtendedInfo(ManagementStatus errorCode)
		{
			ManagementBaseObject errObj = null;
			string msg = null;

			//Try to get extended error info first, and save in errorObject member
			IWbemClassObjectFreeThreaded obj = WbemErrorInfo.GetErrorInfo();
			if (obj != null)
				errObj = new ManagementBaseObject(obj);

			//If the error code is not a WMI one and there's an extended error object available, stick the message
			//from the extended error object in.
			if (((msg = GetMessage(errorCode)) == null) && (errObj != null))
				try 
				{
					msg = (string)errObj["Description"];
				} 
				catch {}

			throw new ManagementException(errorCode, msg, errObj);
		}
		

		internal static void ThrowWithExtendedInfo(Exception e)
		{
			ManagementBaseObject errObj = null;
			string msg = null;

			//Try to get extended error info first, and save in errorObject member
			IWbemClassObjectFreeThreaded obj = WbemErrorInfo.GetErrorInfo();
			if (obj != null)
				errObj = new ManagementBaseObject(obj);

			//If the error code is not a WMI one and there's an extended error object available, stick the message
			//from the extended error object in.
			if (((msg = GetMessage(e)) == null) && (errObj != null))
				try 
				{
					msg = (string)errObj["Description"];
				} 
				catch {}

			throw new ManagementException(e, msg, errObj);
		}


		internal ManagementException(ManagementStatus errorCode, string msg, ManagementBaseObject errObj) : base (msg)
		{
			this.errorCode = errorCode;
			this.errorObject = errObj;
		}
	
		internal ManagementException(Exception e, string msg, ManagementBaseObject errObj) : base (msg, e)
		{
			try 
			{
				if (e is ManagementException)
				{
					errorCode = ((ManagementException)e).ErrorCode;

					// May/may not have extended error info.
					//
					if (errorObject != null)
						errorObject = (ManagementBaseObject)((ManagementException)e).errorObject.Clone();
					else
						errorObject = null;
				}
				else if (e is COMException)
					errorCode = (ManagementStatus)((COMException)e).ErrorCode;
				else
					errorCode = (ManagementStatus)this.HResult;
			}
			catch {}
		}

        protected ManagementException(SerializationInfo info, StreamingContext context) : base(info, context)
        {
            errorCode = (ManagementStatus)info.GetValue("errorCode", typeof(ManagementStatus));
            errorObject = info.GetValue("errorObject", typeof(ManagementBaseObject)) as ManagementBaseObject;
        }

        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);
            info.AddValue("errorCode", errorCode);
            info.AddValue("errorObject", errorObject);
        }

		private static string GetMessage(Exception e)
		{
			string msg = null;

			if (e is COMException)
			{
				// Try and get WMI error message. If not use the one in 
				// the exception
				msg = GetMessage ((ManagementStatus)((COMException)e).ErrorCode);
			}

			if (null == msg)
				msg = e.Message;

			return msg;
		}

		private static string GetMessage(ManagementStatus errorCode)
		{
			string msg = null;
			IWbemStatusCodeText statusCode = null;
			int hr;

			statusCode = (IWbemStatusCodeText) new WbemStatusCodeText();
			if (statusCode != null)
			{
				try {
					hr = statusCode.GetErrorCodeText_((int)errorCode, 0, 1, out msg);

					// Just in case it didn't like the flag=1, try it again
					// with flag=0.
					if (hr != 0)
						hr = statusCode.GetErrorCodeText_((int)errorCode, 0, 0, out msg);
				}
				catch {}
			}

			return msg;
		}

		/// <summary>
		/// Returns the extended error object provided by WMI
		/// </summary>
		public ManagementBaseObject ErrorInformation 
		{
			get 
			{ return errorObject; }
		}

		/// <summary>
		/// Returns the error code reported by WMI which caused this exception
		/// </summary>
		public ManagementStatus ErrorCode 
		{
			get 
			{ return errorCode; }
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\managementobjectcollection.cs ===
using System;
using System.Collections;
using System.Runtime.InteropServices;
using WbemClient_v1;
using System.ComponentModel;

namespace System.Management
{
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	/// This class is used for different collections of WMI instances 
	/// 	(namespaces, scopes, query watcher)
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class ManagementObjectCollection : ICollection, IEnumerable, IDisposable
	{
		// lockable wrapper around a boolean flag
		private class FirstEnum {
			public bool firstEnum = true;
		}

		//fields
		private	FirstEnum firstEnum;
		internal ManagementScope scope;
		internal EnumerationOptions options;
		private IEnumWbemClassObject enumWbem; //holds WMI enumerator for this collection
		internal IWbemClassObjectFreeThreaded current; //points to current object in enumeration
		private bool isDisposed = false;

		internal IWbemServices GetIWbemServices () {
			return scope.GetIWbemServices ();
		}

		//internal ConnectionOptions Connection {
		//	get { return scope.Connection; }
		//}

		//Constructor
		internal ManagementObjectCollection(
			ManagementScope scope,
			EnumerationOptions options, 
			IEnumWbemClassObject enumWbem)
		{
			if (null != options)
				this.options = (EnumerationOptions) options.Clone();
			else
				this.options = new EnumerationOptions ();

			if (null != scope)
				this.scope = (ManagementScope) scope.Clone ();

			this.enumWbem = enumWbem;
			current = null;
			firstEnum = new FirstEnum ();
		}

		~ManagementObjectCollection ()
		{
			try 
			{
				Dispose ();
			}
			finally 
			{
				// Here one would call base.Finalize() if this class had a superclass
			}
		}

		/// <summary>
		/// Release resources associated with this object. After this
		/// method has been called any attempt to use this object will
		/// result in an ObjectDisposedException being thrown.
		/// </summary>
		public void Dispose ()
		{
			if (!isDisposed)
			{
				firstEnum.firstEnum = true;
					
				if (null != enumWbem)
				{
					Marshal.ReleaseComObject (enumWbem);
					enumWbem = null;
				}

//				if (null != scope)
//					scope.Dispose();

				isDisposed = true;

				// Here one would call base.Dispose() if this class had a superclass

				GC.SuppressFinalize (this);
			}
		}

		
		//
		//ICollection properties & methods
		//

		/// <summary>
		///    The number of objects in the collection
		/// </summary>
		/// <value>
		///    Currently not implemented.
		/// </value>
		/// <remarks>
		///    Since this is very expensive to return
		///    (have to enumerate all members) it is not currently supported.
		/// </remarks>
		/// <value>
		///  The number of objects in the collection
		///  Since this is very expensive to return (have to enumerate all members) we don't support it for now.
		/// </value>
		public int Count {
			get { throw new NotSupportedException (); }
		}

 		/// <summary>
 		///    Whether the object is synchronized
 		/// </summary>
 		/// <value>
 		///    <para>True if the object is synchronized, false otherwise.</para>
 		/// </value>
		/// <value>
		/// Whether the object is synchronized
		/// </value>
 		public bool IsSynchronized {
			get {
				return false;
			}
		}

 		/// <summary>
 		///    Object to be used for synchronization
 		/// </summary>
		/// <value>
		/// Object to be used for synchronization
		/// </value>
 		public Object SyncRoot { 
			get { 
				return this; 
			} 
		}

		/// <summary>
		///    <para> Copies the collection into an array</para>
		/// </summary>
		/// <param name='array'>Array to copy to </param>
		/// <param name='index'>Index to start from </param>
		public void CopyTo (Array array, Int32 index) 
		{
			if (isDisposed)
				throw new ObjectDisposedException ("ManagementObjectCollection");

			if (null == array)
				throw new ArgumentNullException ("array");

			if ((index < array.GetLowerBound (0)) || (index > array.GetUpperBound(0)))
				throw new ArgumentOutOfRangeException ("index");

			// Since we don't know the size until we've enumerated
			// we'll have to dump the objects in a list first then
			// try to copy them in.

			int capacity = array.Length - index;
			int numObjects = 0;
			ArrayList arrList = new ArrayList ();

			foreach (ManagementObject obj in this)
			{
				arrList.Add (obj);
				numObjects++;

				if (numObjects > capacity)
					throw new ArgumentException ("index");
			}

			// If we get here we are OK. Now copy the list to the array
			arrList.CopyTo (array, index);

			return;
		}

		/// <summary>
		///    <para>Copies the items in the collection to a
		///       ManagementBaseObject array.</para>
		/// </summary>
		/// <param name='objectCollection'>The target array</param>
		/// <param name=' index'>Index to start from</param>
		public void CopyTo (ManagementBaseObject[] objectCollection, Int32 index)
		{
			CopyTo ((Array)objectCollection, index);
		}

		//
		//IEnumerable methods
		//

 		//****************************************
		//GetEnumerator
		//****************************************
		/// <summary>
		/// Returns the enumerator for this collection.
		/// </summary>
		public ManagementObjectEnumerator GetEnumerator()
		{
			if (isDisposed)
				throw new ObjectDisposedException ("ManagementObjectCollection");

			// Unless this is the first enumerator, we have
			// to clone. This may throw if we are non-rewindable.
			lock (firstEnum)
			{
				if (firstEnum.firstEnum)
				{
					firstEnum.firstEnum = false;
					return new ManagementObjectEnumerator(this, enumWbem);
				}
				else
				{
					IEnumWbemClassObject enumWbemClone = null;
					int status = (int)ManagementStatus.NoError;

					try {
						status = enumWbem.Clone_(out enumWbemClone);
						scope.Secure (enumWbemClone);

						if ((status & 0x80000000) == 0)
						{
							//since the original enumerator might not be reset, we need
							//to reset the new one.
							status = enumWbemClone.Reset_();
						}
					} catch (Exception e) {
						ManagementException.ThrowWithExtendedInfo (e);
					}

					if ((status & 0xfffff000) == 0x80041000)
					{
						// BUGBUG : release callResult.
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					}
					else if ((status & 0x80000000) != 0)
					{
						// BUGBUG : release callResult.
						Marshal.ThrowExceptionForHR(status);
					}

					return new ManagementObjectEnumerator (this, enumWbemClone);
				}
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator ();
		}

		

		//
		// ManagementObjectCollection methods
		//

		//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
		/// <summary>
		/// Class implementing the enumerator on the collection
		/// </summary>
		//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
		public class ManagementObjectEnumerator : IEnumerator
		{
			private IEnumWbemClassObject enumWbem;
			private ManagementObjectCollection collectionObject;
			private uint cachedCount; //says how many objects are in the enumeration cache (when using BlockSize option)
			private int cacheIndex; //used to walk the enumeration cache
			private IWbemClassObjectFreeThreaded[] cachedObjects; //points to objects currently available in enumeration cache
			private bool atEndOfCollection;
			private bool isDisposed = false;

			//constructor
			internal ManagementObjectEnumerator(
				ManagementObjectCollection collectionObject,
				IEnumWbemClassObject enumWbem)
			{
				this.enumWbem = enumWbem;
				this.collectionObject = collectionObject;
				cachedObjects = new IWbemClassObjectFreeThreaded[collectionObject.options.BlockSize];
				cachedCount = 0; 
				cacheIndex = -1; // Reset position
				atEndOfCollection = false;
			}

			~ManagementObjectEnumerator ()
			{
				try 
				{
					Dispose ();
				}
				finally 
				{
					// Here one would call base.Finalize() if this class had a superclass
				}
			}


			/// <summary>
			/// Release resources associated with this object. After this
			/// method has been called any attempt to use this object will
			/// result in an ObjectDisposedException being thrown.
			/// </summary>
			public void Dispose ()
			{
				if (!isDisposed)
				{
					if (null != enumWbem)
					{
						Marshal.ReleaseComObject (enumWbem);
						enumWbem = null;
					}

					isDisposed = true;

					// Here one would call base.Dispose() if this class had a superclass

					GC.SuppressFinalize (this);
				}
			}

			
			/// <summary>
			///    Returns the current object in the
			///    enumeration
			/// </summary>
			/// <value>
			/// The current object in the collection
			/// </value>
			public ManagementBaseObject Current 
			{
				get {
					if (isDisposed)
						throw new ObjectDisposedException ("ManagementObjectEnumerator");

					return ManagementBaseObject.GetBaseObject (cachedObjects[cacheIndex],
						collectionObject.scope);
				}
			}

			object IEnumerator.Current {
				get {
					return Current;
				}
			}

 			//****************************************
			//MoveNext
			//****************************************
			/// <summary>
			///    Moves to the next object in the enumeration
			/// </summary>
			public bool MoveNext ()
			{
				if (isDisposed)
					throw new ObjectDisposedException ("ManagementObjectEnumerator");
				
				//If there are no more objects in the collection return false
				if (atEndOfCollection) 
					return false;

				//Look for the next object
				cacheIndex++;

				if ((cachedCount - cacheIndex) == 0) //cache is empty - need to get more objects
				{

					//If the timeout is set to infinite, need to use the WMI infinite constant
					int timeout = (collectionObject.options.Timeout.Ticks == Int64.MaxValue) ? 
						(int)tag_WBEM_TIMEOUT_TYPE.WBEM_INFINITE : (int)collectionObject.options.Timeout.TotalMilliseconds;

					//Get the next [BLockSize] objects within the specified timeout
					// TODO - cannot use arrays of IWbemClassObject with a TLBIMP
					// generated wrapper
					SecurityHandler securityHandler = collectionObject.scope.GetSecurityHandler();

					int status = (int)ManagementStatus.NoError;
#if false
					status = enumWbem.Next(timeout, collectionObject.options.BlockSize, out cachedObjects, out cachedCount);
#else
					IWbemClassObjectFreeThreaded obj = null;

					try {
						status = enumWbem.Next_(timeout, 1, out obj, out cachedCount);
					}
					catch (Exception e) {
						ManagementException.ThrowWithExtendedInfo(e);
					}

					if ((status & 0xfffff000) == 0x80041000)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					}
					else if ((status & 0x80000000) != 0)
					{
						Marshal.ThrowExceptionForHR(status);
					}

					cachedObjects[0] = obj;
#endif
					// BUGBUG : Review this
					//Check the return code - might be failure, timeout or WBEM_S_FALSE...
					if (status != 0)	//not success
					{
						//If it's anything but WBEM_S_FALSE (which means end of collection) - we need to throw
						if (status != (int)tag_WBEMSTATUS.WBEM_S_FALSE)
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);

                        //if we got less objects than we wanted, need to check why...
						if (cachedCount < collectionObject.options.BlockSize)
						{
								//If no objects were returned we're at the very end
								if (cachedCount == 0)
							{
								atEndOfCollection = true;
								cacheIndex--; //back to last object

								//Release the COM object (so that the user doesn't have to)
								Dispose();

								return false;
							}
						}
					}

					cacheIndex = 0;
					securityHandler.Reset ();
				}
				else
				{
					//Advance the index to the next
					cacheIndex++;
				}

				return true;
			}

 			//****************************************
			//Reset
			//****************************************
			/// <summary>
			///    <para>Resets the enumerator to the beginning of the collection</para>
			/// </summary>
			public void Reset ()
			{
				if (isDisposed)
					throw new ObjectDisposedException ("ManagementObjectEnumerator");

				//If the collection is not rewindable you can't do this
				if (!collectionObject.options.Rewindable)
					throw new InvalidOperationException();
				else
				{
					//Reset the WMI enumerator
					SecurityHandler securityHandler = collectionObject.scope.GetSecurityHandler();
					int status = (int)ManagementStatus.NoError;

					try {
						status = enumWbem.Reset_();
					} catch (Exception e) {
						// BUGBUG : securityHandler.Reset()?
						ManagementException.ThrowWithExtendedInfo (e);
					} finally {
						securityHandler.Reset ();
					}

					if ((status & 0xfffff000) == 0x80041000)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					}
					else if ((status & 0x80000000) != 0)
					{
						Marshal.ThrowExceptionForHR(status);
					}

					//Flush the current enumeration cache
					for (int i=cacheIndex; i<cachedCount; i++)
						Marshal.ReleaseComObject(cachedObjects[i]); 

					cachedCount = 0; 
					cacheIndex = -1; 
					atEndOfCollection = false;
				}
			}

		} //ManagementObjectEnumerator class

	} //ManagementObjectCollection class



	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	/// This class is used for collections of WMI relationship (=association)
	/// 	collections. We subclass to add Add/Remove functionality
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	internal class RelationshipCollection : ManagementObjectCollection
	{
		internal RelationshipCollection (
			ManagementScope scope,
			ObjectQuery query, 
			EnumerationOptions options, 
			IEnumWbemClassObject enumWbem) : base (scope, options, enumWbem) {}

		//****************************************
		//Add
		//****************************************
		/// <summary>
		/// Adds a relationship to the specified object
		/// </summary>
		public void Add (ManagementPath relatedObjectPath)
		{
		}

 		//****************************************
		//Reset
		//****************************************
		/// <summary>
		/// Removes the relationship to the specified object
		/// </summary>
		public void Remove (ManagementPath relatedObjectPath)
		{
		}

	}		
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\managementoperationwatcher.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using WbemClient_v1;

namespace System.Management
{

/// <summary>
/// Delegate definition for the ObjectReady event.
/// </summary>
public delegate void ObjectReadyEventHandler(object sender, ObjectReadyEventArgs e);

/// <summary>
/// Delegate definition for the Completed event.
/// </summary>
public delegate void CompletedEventHandler (object sender, CompletedEventArgs e);

/// <summary>
/// Delegate definition for the Progress event.
/// </summary>
public delegate void ProgressEventHandler (object sender, ProgressEventArgs e);

/// <summary>
/// Delegate definition for the ObjectPut event.
/// </summary>
public delegate void ObjectPutEventHandler(object sender, ObjectPutEventArgs e);

/// <summary>
/// The WMI event adapter/source
/// </summary>
public class ManagementOperationObserver 
{
	private Hashtable m_sinkCollection;
	private WmiDelegateInvoker delegateInvoker;
	
	/// <summary>
	/// The event fired when a new object is available.
	/// </summary>
	public event ObjectReadyEventHandler		ObjectReady;

	/// <summary>
	/// The event fired when an operation has completed.
	/// </summary>
	public event CompletedEventHandler			Completed;

	/// <summary>
	/// The event fired to indicate progress of an ongoing operation.
	/// </summary>
	public event ProgressEventHandler			Progress;

	/// <summary>
	/// The event fired when an object has been successfully committed.
	/// </summary>
	public event ObjectPutEventHandler			ObjectPut;

	/// <summary>
	/// Constructor.
	/// </summary>
	public ManagementOperationObserver () {
		// We make our sink collection synchronized
		m_sinkCollection = new Hashtable ();
		delegateInvoker = new WmiDelegateInvoker (this);
	}

	/// <summary>
	/// Cancel all outstanding operations using this event source.
	/// </summary>
	public void Cancel () {
		// Cancel all the sinks we have - make a copy to avoid things
		// changing under our feet
		Hashtable copiedSinkTable =  new Hashtable ();

		lock (m_sinkCollection) {
			// TODO - the MemberwiseClone method should be used here
			IDictionaryEnumerator sinkEnum = m_sinkCollection.GetEnumerator();

			try {
				sinkEnum.Reset ();
				
				while (sinkEnum.MoveNext ()) {
					DictionaryEntry entry = (DictionaryEntry) sinkEnum.Current;
					copiedSinkTable.Add (entry.Key, entry.Value);
				}
			} catch {}
		}

		// Now step through the copy and cancel everything
		try {
			IDictionaryEnumerator copiedSinkEnum = copiedSinkTable.GetEnumerator();
			copiedSinkEnum.Reset ();

			while (copiedSinkEnum.MoveNext ())
			{
				DictionaryEntry entry = (DictionaryEntry) copiedSinkEnum.Current;
				WmiEventSink eventSink = (WmiEventSink) entry.Value;

				try {
					eventSink.Cancel ();
				} catch {}
			}
		} catch {}
	}

	internal WmiEventSink GetNewSink (
					ManagementScope scope, 
					object context) 
	{
		try {
			WmiEventSink eventSink = new WmiEventSink (this, context, scope);
	
			// Add it to our collection
			lock (m_sinkCollection) {
				m_sinkCollection.Add (eventSink.GetHashCode(), eventSink);
			}

			return eventSink;
		} catch {
			return null;
		}
	}

	internal bool HaveListenersForProgress 
	{
		get 
		{
			bool result = false;

			try {
				result = ((Progress.GetInvocationList ()).Length > 0);
			} catch (Exception) { }

			return result;
		}
	}
	internal WmiEventSink GetNewPutSink (
					ManagementScope scope, 
					object context,
					string path,
					string className) 
	{
		try {
			WmiEventSink eventSink = new WmiEventSink (this, context, scope, path, className);
	
			// Add it to our collection
			lock (m_sinkCollection) {
				m_sinkCollection.Add (eventSink.GetHashCode(), eventSink);
			}

			return eventSink;
		} catch {
			return null;
		}
	}

	internal WmiGetEventSink GetNewGetSink (
						ManagementScope scope,
						object context,
						ManagementObject managementObject)
	{
		try {
			WmiGetEventSink eventSink = new WmiGetEventSink (this, 
								context, scope, managementObject);
	
			// Add it to our collection
			lock (m_sinkCollection) {
				m_sinkCollection.Add (eventSink.GetHashCode(), eventSink);
			}

			return eventSink;
		} catch {
			return null;
		}
	}

	internal void RemoveSink (WmiEventSink eventSink)
	{
		try {
			lock (m_sinkCollection) {
				m_sinkCollection.Remove (eventSink.GetHashCode ());
			}

			// Release the stub as we are now disconnected
			eventSink.ReleaseStub ();
		} catch {}
	}

	/// <summary>
	/// Fires the ObjectReady event to whomsoever is listening
	/// </summary>
	/// <param name="args"> </param>
	internal void FireObjectReady (ObjectReadyEventArgs args)
	{
		try {
			delegateInvoker.FireEventToDelegates (ObjectReady, args);
		} catch {}
	}

	internal void FireCompleted (CompletedEventArgs args)
	{
		try {
			delegateInvoker.FireEventToDelegates (Completed, args);
		} catch {}
	}

	internal void FireProgress (ProgressEventArgs args)
	{
		try {
			delegateInvoker.FireEventToDelegates (Progress, args);
		} catch {}
	}

	internal void FireObjectPut (ObjectPutEventArgs args)
	{
		try {
			delegateInvoker.FireEventToDelegates (ObjectPut, args);
		} catch {}
	}
}

internal class WmiEventState 
{
	private Delegate d;
	private ManagementEventArgs args;
	private AutoResetEvent h;

	internal WmiEventState (Delegate d, ManagementEventArgs args, AutoResetEvent h)
	{
		this.d = d;
		this.args = args;
		this.h = h;
	}

	public Delegate Delegate {
		get { return d; }
	}

	public ManagementEventArgs Args {
		get { return args; }
	}

	public AutoResetEvent AutoResetEvent {
		get { return h; }
	}
}

/// <summary>
/// This class handles the posting of events to delegates. For each event
/// it queues a set of requests (one per target delegate) to the thread pool
/// to handle the event. It ensures that no single delegate can throw
/// an exception that prevents the event from reaching any other delegates.
/// It also ensures that the sender does not signal the processing of the
/// WMI event as "done" until all target delegates have signalled that they are
/// done.
/// </summary>
internal class WmiDelegateInvoker
{
	internal object sender;

	internal WmiDelegateInvoker (object sender)
	{
		this.sender = sender;
	}

	/// <summary>
	/// Custom handler for firing a WMI event to a list of delegates. We use
	/// the process thread pool to handle the firing.
	/// </summary>
	/// <param name="md">The MulticastDelegate representing the collection
	/// of targets for the event</param>
	/// <param name="args">The accompanying event arguments</param>
	internal void FireEventToDelegates (MulticastDelegate md, ManagementEventArgs args)
	{
		try 
		{
			if (null != md)
			{
#if USEPOOL
				Delegate[] delegateList = md.GetInvocationList ();

				if (null != delegateList)
				{
					int numDelegates = delegateList.Length;
					AutoResetEvent[] waitHandles = new AutoResetEvent [numDelegates];

					/*
					 * For each target delegate, queue a request to the 
					 * thread pool to handle the POST. We pass as state the 
					 *  1) Target delegate
					 *  2) Event args
					 *  3) AutoResetEvent that the thread should signal to 
					 *     indicate that it is done.
					 */
					for (int i = 0; i < numDelegates; i++)
					{
						waitHandles [i] = new AutoResetEvent (false);
						ThreadPool.QueueUserWorkItem (
								new WaitCallback (this.FireEventToDelegate),
								new WmiEventState (delegateList[i], args, waitHandles[i]));
					}

					/*
					 * We wait for all the delegates to signal that they are done.
					 * This is because if we return from the IWbemObjectSink callback
					 * before they are all done, it is possible that a delegate will
					 * begin to process the next callback before the current callback
					 * processing is done.
					 */
					WaitHandle.WaitAll (waitHandles, 10000, true);
					}
				}
#endif
				foreach (Delegate d in md.GetInvocationList())
				{
					try {
						d.DynamicInvoke (new object [] {this.sender, args});	
					} catch {}
				}
			}
		}
		catch {}
	}

#if USE_POOL
	/// <summary>
	/// This is the WaitCallback for firing an event from the thread pool
	/// </summary>
	/// <param name="state">Represents a WmiEventState object</param>
	internal void FireEventToDelegate (object state)
	{
		if (state is WmiEventState)
		{
			WmiEventState oState = (WmiEventState) state;

			try {
				oState.Delegate.DynamicInvoke (new object [] {this.sender, oState.Args});	
			} catch {}
			finally {
				// Signal that we are done
				oState.AutoResetEvent.Set();
			}
		}
	}
#endif
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\managementobjectsearcher.cs ===
using System;
using System.Collections;
using System.Runtime.InteropServices;
using WbemClient_v1;
using System.Diagnostics;
using System.ComponentModel;

namespace System.Management
{

	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	/// This class is used to retrieve a collection of WMI objects based
	/// on a specified query
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class ManagementObjectSearcher : Component
	{
		//fields
		private ManagementScope scope;
		private ObjectQuery query;
		private EnumerationOptions options;
		
		//default constructor
		/// <summary>
		///    <para>Default constructor creates an uninitialized searcher 
		///       object. After some properties on this object are set, the object can be used to invoke a query for management
		///       information.</para>
		/// </summary>
		/// <example>
		///    <para>ManagementObjectSearcher s = new ManagementObjectSearcher();</para>
		/// </example>
		public ManagementObjectSearcher() : this((ManagementScope)null, null, null) {}
		
		//parameterized constructors
		/// <summary>
		///    <para>Creates a new ManagementObject Searcher object, to be used 
		///       to invoke the specified query for management information.</para>
		/// </summary>
		/// <param name='queryString'>string representing the WMI query to be invoked by this object.</param>
		/// <example>
		///    ManagementObjectSearcher s = new ManagementObjectSearcher("select * from
		///    Win32_Process");
		/// </example>
		public ManagementObjectSearcher(string queryString) : this(null, new ObjectQuery(queryString), null) {}
		/// <summary>
		///    <para>Creates a new ManagementObject Searcher object, to be used to invoke the 
		///       specified query for management information.</para>
		/// </summary>
		/// <param name='query'>an ObjectQuery-derived object representing the query to be invoked by this searcher.</param>
		/// <example>
		///    SelectQuery q = new SelectQuery("Win32_Service", "State =
		///    'Running'");
		///    ManagementObjectSearcher s = new ManagementObjectSearcher(q);
		/// </example>
		public ManagementObjectSearcher(ObjectQuery query) : this (null, query, null) {} 
		/// <summary>
		///    <para>Creates a new ManagementObject Searcher object, to be used to invoke the
		///       specified query in the specified scope.</para>
		/// </summary>
		/// <param name='scope'>string represents the scope to be querying in.</param>
		/// <param name=' queryString'>string representing the query to be invoked.</param>
		/// <remarks>
		///    <para>If no scope is specified, the default scope
		///       (ManagementPath.DefaultPath) is used.</para>
		/// </remarks>
		/// <example>
		///    <para>ManagementObjectSearcher s = new
		///       ManagementObjectSearcher("root\\MyApp", "select * from MyClass where MyProp=5");</para>
		/// </example>
		public ManagementObjectSearcher(string scope, string queryString) : 
										this(new ManagementScope(scope), new ObjectQuery(queryString), null) {}
		/// <summary>
		///    <para>Creates a new ManagementObject Searcher object, to be used to invoke the 
		///       specified query in the specified scope.</para>
		/// </summary>
		/// <param name='scope'>a ManagementScope object representing the scope in which to invoke the query</param>
		/// <param name=' query'>an ObjectQuery-derived object representing the query to be invoked</param>
		/// <remarks>
		///    <para>If no scope is specified, the default scope (ManagementPath.DefaultPath) is 
		///       used.</para>
		/// </remarks>
		/// <example>
		///    <para>ManagementScope myScope = new ManagementScope("root\\MyApp");
		///       SelectQuery q = new SelectQuery("Win32_Environment",
		///       "User=&lt;system&gt;");
		///       ManagementObjectSearcher s = new ManagementObjectSearcher(myScope,q);</para>
		/// </example>
		public ManagementObjectSearcher(ManagementScope scope, ObjectQuery query) : this(scope, query, null) {}
		/// <summary>
		///    Creates a new ManagementObject Searcher object, to be used to invoke the
		///    specified query in the specified scope, with the specified options.
		/// </summary>
		/// <param name='scope'>A string representing the scope in which the query should be invoked.</param>
		/// <param name=' queryString'>A string representing the query to be invoked.</param>
		/// <param name=' options'>An EnumerationOptions object specifying additional options for the query.</param>
		/// <example>
		///    ManagementObjectSearcher s = new
		///    ManagementObjectSearcher("root\\MyApp", "select * from MyClass", new
		///    EnumerationOptions(null, InfiniteTimeout, 1, true, false, true);
		/// </example>
		public ManagementObjectSearcher(string scope, string queryString, EnumerationOptions options) :
										this(new ManagementScope(scope), new ObjectQuery(queryString), options) {}
		/// <summary>
		///    Creates a new ManagementObject Searcher object, to be
		///    used to invoke the specified query in the specified scope, with the specified
		///    options.
		/// </summary>
		/// <param name='scope'>A ManagementScope object specifying the scope of the query</param>
		/// <param name=' query'>An ObjectQuery-derived object specifying the query to be invoked</param>
		/// <param name=' options'>An EnumerationOptions object specifying additional options to be used for the query.</param>
		public ManagementObjectSearcher(ManagementScope scope, ObjectQuery query, EnumerationOptions options) 
		{
			if (null != scope)
				Scope = scope;
			else 
				Scope = new ManagementScope ();

			if (null != query)
				Query = query;
			else
				Query = new ObjectQuery();

			if (null != options)
				Options = options;
			else
				Options = new EnumerationOptions ();
		}

	
		//
		//Public Properties
		//

		/// <summary>
		///    The scope in which we want to look for objects (currently a WMI namespace)
		/// </summary>
		/// <remarks>
		///    When the value of this property is changed,
		///    the ManagementObjectSearcher is re-bound to the new scope.
		/// </remarks>
		/// <example>
		///    ManagementObjectSearcher s = new ManagementObjectSearcher();
		///    s.Scope = "root\\MyApp";
		/// </example>
		/// <value>
		///  The scope in which we want to look for objects (namespace or scope)
		/// </value>
		public ManagementScope Scope {
			get { 
				return scope; 
			} 
			set {
				if (null != value)
					scope = (ManagementScope) value.Clone ();
				else
					throw new ArgumentNullException ();
			}
		}

		/// <summary>
		///    The query to be invoked in this searcher,
		///    i.e. the criteria to be applied to the search for management objects.
		/// </summary>
		/// <remarks>
		///    When the value of this property is changed,
		///    the ManagementObjectSearcher is reset to use the new query.
		/// </remarks>
		/// <value>
		/// The criteria to apply to the search (= the query)
		/// </value>
		public ObjectQuery Query {
			get { 
				return query; 
			} 
			set { 
				if (null != value)
					query = (ObjectQuery)value.Clone ();
				else
					throw new ArgumentNullException ();
			}
		}

		/// <summary>
		///    Options for how to search for objects
		/// </summary>
		/// <value>
		/// Options for how to search for objects
		/// </value>
		public EnumerationOptions Options { 
			get { 
				return options; 
			} 
			set { 
				if (null != value)
					options = (EnumerationOptions) value.Clone ();
				else
					throw new ArgumentNullException();
			} 
		}

		//********************************************
		//Get()
		//********************************************
		/// <summary>
		/// Invokes the WMI query specified and returns the resulting collection. Note : each invokation of this
		/// method re-executes the query and returns a new collection.
		/// </summary>
		public ManagementObjectCollection Get()
		{
			Trace.WriteLine("Entering Get...");
			Initialize ();
			IEnumWbemClassObject ew = null;
			SecurityHandler securityHandler = scope.GetSecurityHandler();
			EnumerationOptions enumOptions = (EnumerationOptions)options.Clone();

			int status = (int)ManagementStatus.NoError;

			try {
				//If this is a simple SelectQuery (className only), and the enumerateDeep is set, we have
				//to find out whether this is a class enumeration or instance enumeration and call CreateInstanceEnum/
				//CreateClassEnum appropriately, because with ExecQuery we can't do a deep enumeration.
				if ((query.GetType() == typeof(SelectQuery)) && 
					(((SelectQuery)query).Condition == null) && 
					(((SelectQuery)query).SelectedProperties == null) &&
					(options.EnumerateDeep == true))
				{
					//Need to make sure that we're not passing invalid flags to enumeration APIs.
					//The only flags not valid for enumerations are EnsureLocatable & PrototypeOnly.
					enumOptions.EnsureLocatable = false; enumOptions.PrototypeOnly = false;
					
					if (((SelectQuery)query).IsSchemaQuery == false) //deep instance enumeration
						status = scope.GetIWbemServices().CreateInstanceEnum_(
								((SelectQuery)query).ClassName,
								enumOptions.Flags,
								enumOptions.GetContext(),
								out ew);
					else //deep class enumeration
						status = scope.GetIWbemServices().CreateClassEnum_(
								((SelectQuery)query).ClassName,
								enumOptions.Flags,
								enumOptions.GetContext(),
								out ew);
				}
				else //we can use ExecQuery
				{
					//Make sure the EnumerateDeep flag bit is turned off because it's invalid for queries
					enumOptions.EnumerateDeep = true;
					status = scope.GetIWbemServices().ExecQuery_(
														query.QueryLanguage,
														query.QueryString,
														enumOptions.Flags, 
														enumOptions.GetContext(),
														out ew);
				}

				//Set security on the enumerator
				if ((status & 0x80000000) == 0)
				{
					securityHandler.Secure (ew);
				}
			}	catch (Exception e) {
				// BUGBUG : securityHandler.Reset()?
				ManagementException.ThrowWithExtendedInfo(e);
			} finally {
				securityHandler.Reset();
			}

			if ((status & 0xfffff000) == 0x80041000)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
			}
			else if ((status & 0x80000000) != 0)
			{
				Marshal.ThrowExceptionForHR(status);
			}

			//Create a new collection object for the results
			return new ManagementObjectCollection(scope, options, ew); 
		}//Get()


		//********************************************
		//Get() asynchronous
		//********************************************
		/// <summary>
		/// Invokes the WMI query asynchronously and binds to a watcher to deliver the results
		/// </summary>
		/// <param name="watcher"> The watcher that raises events trigerred by the operation </param>
		public void Get(ManagementOperationObserver watcher)
		{
			if (null == watcher)
				throw new ArgumentNullException ("watcher");

			Initialize ();
			IWbemServices wbemServices = scope.GetIWbemServices ();
			WmiEventSink sink = watcher.GetNewSink (scope, null);
			SecurityHandler securityHandler = scope.GetSecurityHandler();

			EnumerationOptions enumOptions = (EnumerationOptions)options.Clone();
			// Ensure we switch off ReturnImmediately as this is invalid for async calls
			enumOptions.ReturnImmediately = false;
			// If someone has registered for progress, make sure we flag it
			if (watcher.HaveListenersForProgress)
				enumOptions.SendStatus = true;

			int status = (int)ManagementStatus.NoError;

			try {
				//If this is a simple SelectQuery (className only), and the enumerateDeep is set, we have
				//to find out whether this is a class enumeration or instance enumeration and call CreateInstanceEnum/
				//CreateClassEnum appropriately, because with ExecQuery we can't do a deep enumeration.
				if ((query.GetType() == typeof(SelectQuery)) && 
					(((SelectQuery)query).Condition == null) && 
					(((SelectQuery)query).SelectedProperties == null) &&
					(options.EnumerateDeep == true))
				{
					//Need to make sure that we're not passing invalid flags to enumeration APIs.
					//The only flags not valid for enumerations are EnsureLocatable & PrototypeOnly.
					enumOptions.EnsureLocatable = false; enumOptions.PrototypeOnly = false;
					
					if (((SelectQuery)query).IsSchemaQuery == false) //deep instance enumeration
						status = wbemServices.CreateInstanceEnumAsync_(
							((SelectQuery)query).ClassName, 
							enumOptions.Flags, 
							enumOptions.GetContext(), 
							sink.Stub);
					else	
						status = wbemServices.CreateClassEnumAsync_(
							((SelectQuery)query).ClassName, 
							enumOptions.Flags, 
							enumOptions.GetContext(), 
							sink.Stub);
				}
				else //we can use ExecQuery
				{
					//Make sure the EnumerateDeep flag bit is turned off because it's invalid for queries
					enumOptions.EnumerateDeep = true;

					status = wbemServices.ExecQueryAsync_(
							query.QueryLanguage, 
							query.QueryString, 
							enumOptions.Flags, 
							enumOptions.GetContext(), 
							sink.Stub);
				}
			} catch (Exception e) {
				// BUGBUG : securityHandler.Reset()?
				watcher.RemoveSink (sink);
				ManagementException.ThrowWithExtendedInfo (e);
			} finally {
				securityHandler.Reset();
			}

			if ((status & 0xfffff000) == 0x80041000)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
			}
			else if ((status & 0x80000000) != 0)
			{
				Marshal.ThrowExceptionForHR(status);
			}
		}


		private void Initialize ()
		{
			//If the query is not set yet we can't do it
			if (null == query)
				throw new InvalidOperationException();

			//If we're not connected yet, this is the time to do it...
			lock (this)
			{
				if (null == scope)
					Scope = new ManagementScope ();
			}

			lock (scope)
			{
				scope.Initialize ();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\method.cs ===
using System;
using System.Runtime.InteropServices;
using WbemClient_v1;

namespace System.Management
{
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	/// This class contains information about a WMI method
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class MethodData
	{
		private ManagementObject parent; //needed to be able to get method qualifiers
		private string methodName;
		private IWbemClassObjectFreeThreaded wmiInParams;
		private IWbemClassObjectFreeThreaded wmiOutParams;
		private QualifierDataCollection qualifiers;

		internal MethodData(ManagementObject parent, string methodName)
		{
			this.parent = parent;
			this.methodName = methodName;
			RefreshMethodInfo();
			qualifiers = null;
		}


		//This private function is used to refresh the information from the Wmi object before returning the requested data
		private void RefreshMethodInfo()
		{
			int status = (int)ManagementStatus.Failed;

			try {
				status = parent.wbemObject.GetMethod_(methodName, 0, out wmiInParams, out wmiOutParams);
			} catch (Exception e) {
				ManagementException.ThrowWithExtendedInfo(e);
			}
			if ((status & 0xfffff000) == 0x80041000)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
			}
			else if ((status & 0x80000000) != 0)
			{
				Marshal.ThrowExceptionForHR(status);
			}
		}


		/// <summary>
		///    <para>The name of this method</para>
		/// </summary>
		/// <value>
		///    <para>The name of this method</para>
		/// </value>
		public string Name {
			get { return methodName; }
		}

		/// <summary>
		///    <para>An object containing all the input parameters to this method. Each parameter 
		///       is described as a property in this object. If a parameter is both in and out, it
		///       will appear in both the InParameters and OutParameters objects.</para>
		/// </summary>
		/// <remarks>
		///    <para>Each parameter in this object should have
		///       an "id" qualifier, identifying the order of the parameters in the method call.</para>
		/// </remarks>
		/// <value>
		///    <para>An object containing all the input parameters to this
		///       method. Each parameter is described as a property in this object. If a parameter
		///       is both in and out, it will appear in both the InParameters and OutParameters
		///       objects.</para>
		/// </value>
		/// <remarks>
		///    <para>Each parameter in this object should have
		///       an "id" qualifier, identifying the order of the parameters in the method call.</para>
		/// </remarks>
		public ManagementBaseObject InParameters {
			get { 
				RefreshMethodInfo();
				return (null == wmiInParams) ? null : new ManagementBaseObject(wmiInParams); }
		}

		/// <summary>
		///    <para>An object containing all the output parameters to this method. Each parameter 
		///       is described as a property in this object. If a parameter is both in and out, it
		///       will appear in both the InParameters and OutParameters objects.</para>
		/// </summary>
		/// <remarks>
		///    <para>Each parameter in this object should have an "id" qualifier, identifying the 
		///       order of the parameters in the method call.</para>
		///    <para>A special property of the OutParameters object is called "ReturnValue" and 
		///       holds the return value of the method.</para>
		/// </remarks>
		public ManagementBaseObject OutParameters {
			get { 
				RefreshMethodInfo();
				return (null == wmiOutParams) ? null : new ManagementBaseObject(wmiOutParams); }
		}

		/// <summary>
		///    <para>Returns the name of the management class in which this method was first 
		///       introduced in the class inheritance hierarchy.</para>
		/// </summary>
		public string Origin {
			get {
				string className = null;
				int status = (int)ManagementStatus.Failed;

				try {
					status = parent.wbemObject.GetMethodOrigin_(methodName, out className);
				}
				catch (Exception e) {
					ManagementException.ThrowWithExtendedInfo(e);
				}

				if ((status & 0xfffff000) == 0x80041000)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				}
				else if ((status & 0x80000000) != 0)
				{
					Marshal.ThrowExceptionForHR(status);
				}

				return className;
			}
		}

		/// <summary>
		///    <para>Returns a collection of qualifiers defined on this method. Each element is of 
		///       type QualifierData and contains information such as the qualifier name, value &amp;
		///       flavor.</para>
		/// </summary>
		/// <seealso cref='System.Management.QualifierData'/>
		public QualifierDataCollection Qualifiers {
			get {
				if (qualifiers == null)
					qualifiers = new QualifierDataCollection(parent, methodName, QualifierType.MethodQualifier);
				return qualifiers;
			}
		}

	}//MethodData
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\managementquery.cs ===
using System;
using System.Collections.Specialized;
using WbemUtilities_v1;
using WbemClient_v1;

namespace System.Management
{
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para>This class represents an arbitrary Management Query</para>
	/// </summary>
	/// <remarks>
	///    This class is abstract, thus only
	///    derivatives of it are actually used in the API.
	/// </remarks>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public abstract class ManagementQuery : ICloneable
	{
		internal const string DEFAULTQUERYLANGUAGE = "WQL";
		internal static readonly string tokenSelect = "select ";	// Keep trailing space char.

		//Used when any public property on this object is changed, to signal
		//to the containing object that it needs to be refreshed.
		internal event IdentifierChangedEventHandler IdentifierChanged;

		//Fires IdentifierChanged event
		internal void FireIdentifierChanged()
		{
			if (IdentifierChanged != null)
				IdentifierChanged(this, null);
		}

		private string queryLanguage;
		private string queryString;

		internal void SetQueryString (string qString)
		{
			queryString = qString;
		}

		//default constructor
		internal ManagementQuery() : this(DEFAULTQUERYLANGUAGE, null) {}

		//parameterized constructors
		internal ManagementQuery(string query) : this(DEFAULTQUERYLANGUAGE, query) {}
		internal ManagementQuery(string language, string query)
		{
			QueryLanguage = language;
			QueryString = query;
		}

		/// <summary>
		///    <para>Takes the query string and parses it into a set of parameters.</para>
		/// </summary>
		/// <param name='query'>The textual representation of the query</param>
		protected internal virtual void ParseQuery (string query) {}

		//
		//properties
		//
		/// <summary>
		///    The textual representation of the query
		/// </summary>
		/// <value>
		///    If the query object is constructed
		///    with no parameters, this property is null until specifically set. If the object
		///    was constructed with a specified query, this property will return the specified
		///    query string.
		/// </value>
		public virtual string QueryString
		{
			get {return (null != queryString) ? queryString : String.Empty;}
			set {
				if (queryString != value) {
					ParseQuery (value);	// this may throw
					queryString = value;
					FireIdentifierChanged ();
				}
			}
		}

		/// <summary>
		///    The query language used in the query string. This
		///    defines the format of the query string.
		/// </summary>
		/// <value>
		///    Can be set to any supported query
		///    language. The only value supported by WMI intrinsicly is WQL.
		/// </value>
		public virtual String QueryLanguage
		{
			get {return (null != queryLanguage) ? queryLanguage : String.Empty;}
			set {
				if (queryLanguage != value) {
					queryLanguage = value;
					FireIdentifierChanged ();
				}
			}
		}

		//ICloneable
		/// <summary>
		///    Returns a copy of this query object.
		/// </summary>
		public abstract object Clone();

		internal void ParseToken (ref string q, string token, string op, ref bool bTokenFound, ref string tokenValue)
		{
			if (bTokenFound)
				throw new ArgumentException ();	// Invalid query - duplicate token

			bTokenFound = true;
			q = q.Remove (0, token.Length).TrimStart (null);

			// Next character should be the operator if any
			if (op != null)
			{
				if (0 != q.IndexOf(op))
					throw new ArgumentException();	// Invalid query

				// Strip off the op and any leading WS
				q = q.Remove(0, op.Length).TrimStart(null);
			}

			if (0 == q.Length)
				throw new ArgumentException ();		// Invalid query - token has no value
			
			// Next token should be the token value - look for terminating WS 
			// or end of string
			int i;
			if (-1 == (i = q.IndexOf (' ')))
				i = q.Length;			// No WS => consume entire string
				
			tokenValue = q.Substring (0, i);
			q = q.Remove (0, tokenValue.Length).TrimStart(null);
		}

		internal void ParseToken (ref string q, string token, ref bool bTokenFound)
		{
			if (bTokenFound)
				throw new ArgumentException ();	// Invalid query - duplicate token

			bTokenFound = true;
			q = q.Remove (0, token.Length).TrimStart (null);
		}

		//Used for "keyword value" pairs in the query
		/// <summary>
		/// </summary>
		protected internal string GetValueOfKeyword(string query, string keyword, int keywordIndex)
		{
			if (query.Length < (keywordIndex + keyword.Length)) //keyword with no value - throw...
				throw new ArgumentException();
			
			string q = query.Remove(0, keywordIndex + keyword.Length);
			q = q.Trim();

			int nextSpace = q.IndexOf(" ", 0);
			return (nextSpace == -1 ? q : q.Substring(0, nextSpace));
		}
	
	}//ManagementQuery


	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para>This class represents a WMI query which returns instances or classes</para>
	/// </summary>
	/// <remarks>
	///    This class or it's derivatives are used to
	///    specify a query in the ManagementObjectSearcher object. It is recommended to use
	///    a more specific query class whenever possible.
	/// </remarks>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class ObjectQuery : ManagementQuery
	{
		/// <summary>
		///    Default constructor - creates an Object Query object
		///    with no initialized values.
		/// </summary>
		public ObjectQuery() : base() {}
		/// <summary>
		///    Overloaded constructor creates a new Object Query object
		///    for a specific query string.
		/// </summary>
		/// <param name='query'>The string representation of the query</param>
		public ObjectQuery(string query) : base(query) {}
		/// <summary>
		///    Constructs a new Object Query object for a specific
		///    query string &amp; language.
		/// </summary>
		/// <param name='language'>specifies the query language in which this query is specified</param>
		/// <param name=' query'>the string representation of the query</param>
		public ObjectQuery(string language, string query) : base(language, query) {}

		//ICloneable
		/// <summary>
		///    <para>Returns a copy of this object.</para>
		/// </summary>
		public override object Clone ()
		{
			return new ObjectQuery(QueryLanguage, QueryString);
		}
		
	}//ObjectQuery


	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para>This class represents a WMI event query</para>
	/// </summary>
	/// <remarks>
	///    Objects of this class or it's derivatives
	///    are used in the ManagementEventWatcher class, to subscribe to WMI events.
	///    Whenever possible more specific derivatives of this class should be used.
	/// </remarks>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class EventQuery : ManagementQuery
	{
		/// <summary>
		///    <para>Default constructor creates a new uninitialized Event
		///       Query object.</para>
		/// </summary>
		public EventQuery() : base() {}
		/// <summary>
		///    Creates a new Event Query object for the specified query
		/// </summary>
		/// <param name='query'>A textual representation of the event query</param>
		public EventQuery(string query) : base(query) {}
		/// <summary>
		///    Creates a new Event Query object for the specified
		///    language &amp; query
		/// </summary>
		/// <param name='language'>Specifies the language in which the query string is specified </param>
		/// <param name=' query'>the string representation of the query</param>
		public EventQuery(string language, string query) : base(language, query) {}

		//ICloneable
		/// <summary>
		///    Returns a copy of this object
		/// </summary>
		public override object Clone()
		{
			return new EventQuery(QueryLanguage, QueryString);
		}
	}//EventQuery


	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	/// This class represents all WQL-type WMI object queries
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class WqlObjectQuery : ObjectQuery
	{
		//constructors
		//Here we don't take a language argument but hard-code it to WQL in the base class
		/// <summary>
		///    Default constructor creates a new uninitialized WQL Data
		///    Query object.
		/// </summary>
		public WqlObjectQuery() : base(null) {}
	
		/// <summary>
		///    Creates a new WQL Data Query object initialized to the
		///    specified query
		/// </summary>
		/// <param name='query'><para>String representation of the data query</para></param>
		public WqlObjectQuery(string query) : base(query) {}

		//QueryLanguage property is read-only in this class (does this work ??)
		/// <summary>
		///    Specifies the language of the query
		/// </summary>
		/// <value>
		///    The value of this property in this
		///    object is always "WQL".
		/// </value>
		public override string QueryLanguage
		{
			get 
			{return base.QueryLanguage;}
		}

		//ICloneable
		/// <summary>
		///    <para>Returns a copy of this object</para>
		/// </summary>
		public override object Clone()
		{
			return new WqlObjectQuery(QueryString);
		}


	}//WqlObjectQuery



	
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	/// This class represents a WMI "select" data query
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class SelectQuery : WqlObjectQuery
	{
		private bool isSchemaQuery = false;
		private string className;
		private string condition;
		private StringCollection selectedProperties;

		//default constructor
		/// <summary>
		///    Default constructor creates an uninitialized Select
		///    Query object
		/// </summary>
		public SelectQuery() :this(null) {}
		
		//parameterized constructors
		//ISSUE : We have 2 possible constructors that take a single string :
		//  one that takes the full query string and the other that takes the class name.
		//  We resolve this by trying to parse the string, if it succeeds we assume it's the query, if
		//  not we assume it's the class name.
		/// <summary>
		///    <para>Creates a new Select Query object with the specified
		///       query, or for the specified classname. The query is assumed to be an instances query.</para>
		/// </summary>
		/// <param name='queryOrClassName'>Represents either the entire query or the class name to use in the query. The parser in this class will attempt to parse the string as a valid WQL select query, and if unsuccessful it will assume it is a class name.</param>
		/// <example>
		///    SelectQuery s = new SelectQuery("select * from Win32_Service where
		///    State='Stopped');
		///    or
		///    SelectQuery s = new SelectQuery("Win32_Service"); //which is
		///    equivalent to "select * from Win32_Service"
		/// </example>
		public SelectQuery(string queryOrClassName)
		{
			selectedProperties = new StringCollection ();

			if (null != queryOrClassName)
			{
				// Minimally determine if the string is a query or class name.
				//
				if (queryOrClassName.TrimStart().ToLower().StartsWith(tokenSelect))
				{
					// Looks to be a query - do further checking.
					//
					QueryString = queryOrClassName;		// Parse/validate; may throw.
				}
				else
				{
					// Do some basic sanity checking on whether it's a class name
					//
					try
					{
						ManagementPath p = new ManagementPath (queryOrClassName);

						if (p.IsClass && (0 == String.Empty.CompareTo (p.NamespacePath)))
							ClassName = queryOrClassName;
						else
							throw new ArgumentException ();
					}
					catch (Exception)
					{
						throw new ArgumentException ();
					}
				}
			}
		}

		/// <summary>
		///    <para>Creates a new Select Query object with the specified
		///       class name and condition. The query is assumed to be an instances query.</para>
		/// </summary>
		/// <param name='className'>The name of the class to select on in the query</param>
		/// <param name=' condition'>the condition to be applied in the query</param>
		/// <example>
		///    <para>SelectQuery s = new
		///       SelectQuery("Win32_Process", "HandleID=1234");</para>
		/// </example>
		public SelectQuery(string className, string condition) : this(className, condition, null) {}

		/// <summary>
		///    <para>Creates a new Select Query object with the specified 
		///       class name and condition, selecting only the specified properties. The query is assumed to be an instances query.</para>
		/// </summary>
		/// <param name='className'>The name of the class to select from</param>
		/// <param name=' condition'>The condition to be applied to the selected class's instances</param>
		/// <param name=' selectedProperties'>An array of property names that we want to be returned in the query results</param>
		/// <example>
		///    <para>String[] properties = {"VariableName", "VariableValue"};</para>
		///    SelectQuery s = new SelectQuery("Win32_Environment",
		///    "User='&lt;system&gt;'", properties);
		/// </example>
		public SelectQuery(string className, string condition, string[] selectedProperties) : base ()
		{
			this.isSchemaQuery = false;
			this.className = className;
			this.condition = condition;
			this.selectedProperties = new StringCollection ();

			if (null != selectedProperties)
				this.selectedProperties.AddRange (selectedProperties);

			BuildQuery();
		}

		/// <summary>
		///    <para>Creates a new Select Query object for a schema query, optionally 
		///       specifying a condition. For schema queries, only the condition parameter 
		///       is relevant - className and selectedProperties are not supported and ignored.</para>
		/// </summary>
		/// <param name='isSchemaQuery'>Specifies that this is a schema query. A false value is invalid in this constructor.</param>
		/// <param name=' condition'>The condition to be applied to the selected class's instances</param>
		/// <example>
		///    <para>SelectQuery s = new SelectQuery(true, "__CLASS = 'Win32_Service'");</para>
		/// </example>
		public SelectQuery(bool isSchemaQuery, string condition) : base ()
		{
			if (isSchemaQuery == false)
				throw new ArgumentException(null, "isSchemaQuery");
			
			this.isSchemaQuery = true;
			this.className = null;
			this.condition = condition;
			this.selectedProperties = null;

			BuildQuery();
		}
		
		
		/// <summary>
		///    The string representation of the query in this object.
		/// </summary>
		/// <remarks>
		///    When this property is set, it will override
		///    any previous query that was stored in this project. In addition, setting it will
		///    cause a re-parse of the string to update the other members of the object
		///    accordingly.
		/// </remarks>
		/// <example>
		///    SelectQuery s = new SelectQuery();
		///    s.QueryString = "select * from Win32_LogicalDisk";
		/// </example>
		public override string QueryString
		{
			get {
				// We need to force a rebuild as we may not have detected
				// a change to selected properties
				BuildQuery ();
				return base.QueryString;}
			set {
				base.QueryString = value;
			}
		}

		/// <summary>
		///    Specifies whether this query is a schema query or an instances query.
		/// </summary>
		/// <remarks>
		///    Setting this property value overrides any
		///    previous value stored in the object. As a side-effect, the QueryString is
		///    rebuilt to reflect the new query type.
		/// </remarks>
		public bool IsSchemaQuery
		{
			get 
			{ return isSchemaQuery; }
			set 
			{ isSchemaQuery = value; BuildQuery(); FireIdentifierChanged(); }
		}


		/// <summary>
		///    The class name to be selected from in this query.
		/// </summary>
		/// <remarks>
		///    Setting this property value overrides any
		///    previous value stored in the object. As a side-effect, the QueryString is
		///    rebuilt to reflect the new class name.
		/// </remarks>
		/// <example>
		///    SelectQuery s = new SelectQuery("select * from Win32_LogicalDisk");
		///    Console.WriteLine(s.QueryString); //output is : select * from
		///    Win32_LogicalDisk
		///    s.ClassName = "Win32_Process";
		///    Console.WriteLine(s.QueryString); //output is : select * from
		///    Win32_Process
		/// </example>
		public string ClassName
		{
			get { return (null != className) ? className : String.Empty; }
			set { className = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    <para>Represents the condition to be applied in this select
		///       query</para>
		/// </summary>
		/// <remarks>
		///    <para> Setting this property value overrides any previous value stored in 
		///       the object. As a side-effect, the QueryString is rebuilt to reflect the new
		///       condition.</para>
		/// </remarks>
		public string Condition
		{
			get { return (null != condition) ? condition : String.Empty; }
			set { condition = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    <para>Array of strings representing names of properties to be
		///       selected in this query.</para>
		/// </summary>
		/// <remarks>
		///    <para>Setting this property value overrides any previous value stored in the 
		///       object. As a side-effect, the QueryString is rebuilt to reflect the new
		///       properties.</para>
		/// </remarks>
		public StringCollection SelectedProperties
		{
			get { return selectedProperties; }
			set { 
				if (null != value)
				{
					// A tad painful since StringCollection doesn't support ICloneable
					StringCollection src = (StringCollection)value;
					StringCollection dst = new StringCollection ();

					foreach (String s in src)
						dst.Add (s);
						
					selectedProperties = dst; 
				}
				else
					selectedProperties = new StringCollection ();

				BuildQuery(); 
				FireIdentifierChanged(); 
			}
		}


		protected internal void BuildQuery()
		{
			string s;

			if (isSchemaQuery == false) //this is an instances query
			{
				//If the class name is not set we can't build a query
				//Shouldn't throw here because the user may be in the process of filling in the properties...
				if (className == null)
					SetQueryString (String.Empty);

				if ((className == null) || (className == String.Empty))
					return;

				//Select clause
				s = tokenSelect;

				//If properties are specified list them
				if ((null != selectedProperties) && (0 < selectedProperties.Count))
				{
					int count = selectedProperties.Count;

					for (int i = 0; i < count; i++)
						s = s + selectedProperties[i] + ((i == (count - 1)) ? " " : ",");
				}
				else
					s = s + "* ";

				//From clause
				s = s + "from " + className;

			}
			else //this is a schema query, ignore className or selectedProperties.
			{
				//Select clause
				s = "select * from meta_class";
			}

			//Where clause
			if ((!Condition.Equals(String.Empty)) && (Condition != null))
				s = s + " where " + condition;

			//Set the queryString member to the built query (NB: note we set
			//by accessing the internal helper function rather than the property,
			//since we do not want to force a parse of a query we just built).
			SetQueryString (s);
		}



		protected internal override void ParseQuery(string query)
		{
			//Trim whitespaces
			string q = query.Trim();
			bool bFound = false; string tempProp; int i;

			if (isSchemaQuery == false) //instances query
			{
				//Find "select" clause and get the property list if exists
				string keyword = tokenSelect;
				if ((q.Length >= keyword.Length) && (String.Compare(q, 0, keyword, 0, keyword.Length, true) == 0)) //select clause found
				{
					ParseToken (ref q, keyword, ref bFound);
					if (q[0] != '*') //we have properties
					{
						if (null != selectedProperties)
							selectedProperties.Clear ();
						else 
							selectedProperties = new StringCollection ();

						//get the property list
						while (true)
						{
							if ((i = q.IndexOf(',')) > 0)
							{
								tempProp = q.Substring(0, i);
								q = q.Remove(0, i+1).TrimStart(null);
								tempProp = tempProp.Trim();
								if (tempProp != String.Empty)
									selectedProperties.Add(tempProp);
							}
							else
							{ //last property in the list
								if ((i = q.IndexOf(' ')) > 0)
								{
									tempProp = q.Substring(0, i);
									q = q.Remove(0, i).TrimStart(null);
									selectedProperties.Add(tempProp);
									break;
								}
								else //bad query
									throw new ArgumentException();
							}
						} //while
					}
					else
						q = q.Remove(0, 1).TrimStart(null);
				}
				else //select clause has to be there, otherwise the parsing fails
					throw new ArgumentException();

				//Find "from" clause, get the class name and remove the clause
				keyword = "from "; bFound = false;
				if ((q.Length >= keyword.Length) && (String.Compare(q, 0, keyword, 0, keyword.Length, true) == 0)) //from clause found
					ParseToken(ref q, keyword, null, ref bFound, ref className);
				else //from clause has to be there, otherwise the parsing fails
					throw new ArgumentException(); 

				//Find "where" clause, get the condition out and remove the clause
				keyword = "where ";
				if ((q.Length >= keyword.Length) && (String.Compare(q, 0, keyword, 0, keyword.Length, true) == 0)) //where clause exists
				{
					condition = q.Substring(keyword.Length).Trim();
				}
			} //if isSchemaQuery == false
			else //this is a schema query
			{
				//Find "select" clause and make sure it's the right syntax
				string keyword = "select"; 

				// Should start with "select"
				if ((q.Length < keyword.Length) || 
					(0 != String.Compare (q, 0, keyword, 0, keyword.Length, true)))
					throw new ArgumentException ();

				q = q.Remove (0, keyword.Length).TrimStart (null);

				// Next should be a '*'
				if (0 != q.IndexOf ('*', 0))
					throw new ArgumentException ();

				q = q.Remove (0, 1).TrimStart (null);

				// Next should be "from"
				keyword = "from";

				if ((q.Length < keyword.Length) || 
					(0 != String.Compare (q, 0, keyword, 0, keyword.Length, true)))
					throw new ArgumentException ();

				q = q.Remove (0, keyword.Length).TrimStart (null);

				// Next should be "meta_class"
				keyword = "meta_class";

				if ((q.Length < keyword.Length) || 
					(0 != String.Compare (q, 0, keyword, 0, keyword.Length, true)))
					throw new ArgumentException ();

				q = q.Remove (0, keyword.Length).TrimStart (null);

				// There may be a where clause
				if (0 < q.Length)
				{
					//Find "where" clause, and get the condition out
					keyword = "where"; 
				
					if ((q.Length < keyword.Length) || 
						(0 != String.Compare (q, 0, keyword, 0, keyword.Length, true)))
						throw new ArgumentException ();

					q = q.Remove (0, keyword.Length);

					// Must be some white space next
					if ((0 == q.Length) || !Char.IsWhiteSpace (q[0]))
						throw new ArgumentException();	// Invalid query
				
					q = q.TrimStart(null);	// Remove the leading whitespace

					condition = q;
				}
				else
					condition = String.Empty;

				//Empty not-applicable properties
				className = null;
				selectedProperties = null;
			}//schema query
		}

		/// <summary>
		/// Returns a copy of this SelectQuery object
		/// </summary>
		public override Object Clone ()
		{
			string[] strArray = null;

			if (null != selectedProperties)
			{
				int count = selectedProperties.Count;

				if (0 < count)
				{
					strArray = new String [count];
					selectedProperties.CopyTo (strArray, 0);
				}
			}

			if (isSchemaQuery == false)
				return new SelectQuery(className, condition, strArray);
			else
				return new SelectQuery(true, condition);
		}

	}//SelectQuery

	
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	/// This class represents a WMI "associators of" query.
	/// It can be used for either instances or schema queries.
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class RelatedObjectQuery : WqlObjectQuery
	{
		private static readonly string tokenAssociators = "associators";
		private static readonly string tokenOf = "of";
		private static readonly string tokenWhere = "where";
		private static readonly string tokenResultClass = "resultclass";
		private static readonly string tokenAssocClass = "assocclass";
		private static readonly string tokenResultRole = "resultrole";
		private static readonly string tokenRole = "role";
		private static readonly string tokenRequiredQualifier = "requiredqualifier";
		private static readonly string tokenRequiredAssocQualifier = "requiredassocqualifier";
		private static readonly string tokenClassDefsOnly = "classdefsonly";
		private static readonly string tokenSchemaOnly = "schemaonly";

		private bool isSchemaQuery;
		private string sourceObject;
		private string relatedClass;
		private string relationshipClass;
		private string relatedQualifier;
		private string relationshipQualifier;
		private string relatedRole;
		private string thisRole;
		private bool classDefinitionsOnly;

		
		//default constructor
		/// <summary>
		///    <para>Default constructor creates an uninitialized query object.</para>
		/// </summary>
		public RelatedObjectQuery() :this(null) {}
		
		//parameterized constructor
		//ISSUE : We have 2 possible constructors that take a single string :
		//  one that takes the full query string and the other that takes the source object path.
		//  We resolve this by trying to parse the string, if it succeeds we assume it's the query, if
		//  not we assume it's the source object.
		/// <summary>
		///    <para>Creates a new related objects query object. If the specified string can be succesfully parsed as 
		///    a WQL query, it is considered to be the query string, otherwise it is assumed to be the path of the source 
		///    object for the query. In this case the query is assumed to be an instances query. </para>
		/// </summary>
		/// <example>
		///    <para>RelatedObjectQuery q = new RelatedObjectQuery("associators of {Win32_ComputerSystem.Name='mymachine'}");</para>
		///    <para> or </para>
		///    <para>RelatedObjectQuery q = new RelatedObjectQuery("Win32_Service.Name='Alerter'");
		/// </example>
		public RelatedObjectQuery(string queryOrSourceObject) 
		{
			if (null != queryOrSourceObject)
			{
				// Minimally determine if the string is a query or instance name.
				//
				if (queryOrSourceObject.TrimStart().ToLower().StartsWith(tokenAssociators))
				{
					// Looks to be a query - do further checking.
					//
					QueryString = queryOrSourceObject;	// Parse/validate; may throw.
				}
				else
				{
					// We'd like to treat it as the source object. Is it a valid
					// class or instance?
					//
					// Do some basic sanity checking on whether it's a class/instance name
					//
					try
					{
						ManagementPath p = new ManagementPath (queryOrSourceObject);

						if ((p.IsClass || p.IsInstance) && (0 == String.Empty.CompareTo (p.NamespacePath)))
						{
							SourceObject = queryOrSourceObject;
							isSchemaQuery = false;
						}
						else
							throw new ArgumentException ();
					}
					catch (Exception)
					{
						throw new ArgumentException ();
					}
				}
			}
		}

		/// <summary>
		///    <para>Creates a new related objects query for the given source object and related class.
		///    The query is assumed to be an instances query (as opposed to a schema query).</para>
		/// </summary>
		public RelatedObjectQuery(string sourceObject, string relatedClass) : this(sourceObject, relatedClass, 
																					null, null, null, null, null, false) {}
		
		//Do we need additional variants of constructors here ??
		/// <summary>
		///    <para>Creates a new related objects query for the given set of parameters.
		///    The query is assumed to be an instances query (as opposed to a schema query).</para>
		/// </summary>
		public RelatedObjectQuery(string sourceObject,
								   string relatedClass, 
							       string relationshipClass, 
								   string relatedQualifier, 
								   string relationshipQualifier, 
								   string relatedRole, 
								   string thisRole, 
								   bool classDefinitionsOnly) 
		{
			this.isSchemaQuery = false;
			this.sourceObject = sourceObject;
			this.relatedClass = relatedClass;
			this.relationshipClass = relationshipClass;
			this.relatedQualifier = relatedQualifier;
			this.relationshipQualifier = relationshipQualifier;
			this.relatedRole = relatedRole;
			this.thisRole = thisRole;
			this.classDefinitionsOnly = classDefinitionsOnly;
			BuildQuery();

		}

		/// <summary>
		///    <para>Creates a new related classes schema query for the given set of parameters.
		///    This constructor is used for schema queries only and so the first parameter has to be 'true'.</para>
		/// </summary>
		public RelatedObjectQuery(bool isSchemaQuery,
			string sourceObject,
			string relatedClass, 
			string relationshipClass, 
			string relatedQualifier, 
			string relationshipQualifier, 
			string relatedRole, 
			string thisRole) 
		{
			if (isSchemaQuery == false)
				throw new ArgumentException(null, "isSchemaQuery");

			this.isSchemaQuery = true;
			this.sourceObject = sourceObject;
			this.relatedClass = relatedClass;
			this.relationshipClass = relationshipClass;
			this.relatedQualifier = relatedQualifier;
			this.relationshipQualifier = relationshipQualifier;
			this.relatedRole = relatedRole;
			this.thisRole = thisRole;
			this.classDefinitionsOnly = false; //this parameter is not relevant for schema queries.
			BuildQuery();

		}

		/// <summary>
		///    Specifies whether this query is a schema query or an instances query.
		/// </summary>
		/// <remarks>
		///    Setting this property value overrides any
		///    previous value stored in the object. As a side-effect, the QueryString is
		///    rebuilt to reflect the new query type.
		/// </remarks>
		public bool IsSchemaQuery
		{
			get 
			{ return isSchemaQuery; }
			set 
			{ isSchemaQuery = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
        ///    <para>Represents the source object to be used for the query. For instances queries, this will
        ///    typically be an instance path. For schema queries, this will typically be a class name.</para>
        /// </summary>
        public string SourceObject
		{
			get { return (null != sourceObject) ? sourceObject : String.Empty; }
			set { sourceObject = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    <para>Specifies the class of the end point object(s).</para>
		/// </summary>
		/// <remarks>
		///    Setting this property value overrides any
		///    previous value stored in the object. As a side-effect, the QueryString is
		///    rebuilt to reflect the new query type.
		/// </remarks>
		/// <example>
		/// <para>For example, for finding all the Win32 services
		///    related to the source object (here the specified computer system), 
		///    this property should be set to "Win32_Service" : </para>
		/// <para>RelatedObjectQuery q = new RelatedObjectQuery("Win32_ComputerSystem='MySystem'");</para>
		/// <para>q.RelatedClass = "Win32_Service";</para>
		/// </example>
		public string RelatedClass
		{
			get { return (null != relatedClass) ? relatedClass : String.Empty; }
			set { relatedClass = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    <para>Specifies the class of the relationship (association).</para>
		/// </summary>
		/// <remarks>
		///    Setting this property value overrides any
		///    previous value stored in the object. As a side-effect, the QueryString is
		///    rebuilt to reflect the new query type.
		/// </remarks>
		/// <example>
		/// <para>For example, for finding all the Win32 services dependent on 
		///    a service, this property should be set to the "Win32_DependentService" association class : </para>
		/// <para>RelatedObjectQuery q = new RelatedObjectQuery("Win32_Service='TCP/IP'");</para>
		/// <para>q.RelationshipClass = "Win32_DependentService";</para>
		/// </example>
		public string RelationshipClass
		{
			get { return (null != relationshipClass) ? relationshipClass : String.Empty; }
			set { relationshipClass = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    <para>Specifies a qualifier required to be defined on the related objects.</para>
		/// </summary>
		/// <remarks>
		///    Setting this property value overrides any
		///    previous value stored in the object. As a side-effect, the QueryString is
		///    rebuilt to reflect the new query type.
		/// </remarks>
		public string RelatedQualifier
		{
			get { return (null != relatedQualifier) ? relatedQualifier : String.Empty; }
			set { relatedQualifier = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    <para>Specifies a qualifier required to be defined on the relationship objects.</para>
		/// </summary>
		/// <remarks>
		///    Setting this property value overrides any
		///    previous value stored in the object. As a side-effect, the QueryString is
		///    rebuilt to reflect the new query type.
		/// </remarks>
		public string RelationshipQualifier
		{
			get { return (null != relationshipQualifier) ? relationshipQualifier : String.Empty; }
			set { relationshipQualifier = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    <para>Specifies the role that the related objects returned should be playing in the relationship.</para>
		/// </summary>
		/// <remarks>
		///    Setting this property value overrides any
		///    previous value stored in the object. As a side-effect, the QueryString is
		///    rebuilt to reflect the new query type.
		/// </remarks>
		public string RelatedRole
		{
			get { return (null != relatedRole) ? relatedRole : String.Empty; }
			set { relatedRole = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    <para>Specifies the role that the source object should be playing in all relationships returned.</para>
		/// </summary>
		/// <remarks>
		///    Setting this property value overrides any
		///    previous value stored in the object. As a side-effect, the QueryString is
		///    rebuilt to reflect the new query type.
		/// </remarks>
		public string ThisRole
		{
			get { return (null != thisRole) ? thisRole : String.Empty; }
			set { thisRole = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    <para>Requests that for all instances that adhere to the query, only their class definitions be returned.
		///    This parameter is only valid for instance queries.</para>
		/// </summary>
		/// <remarks>
		///    Setting this property value overrides any
		///    previous value stored in the object. As a side-effect, the QueryString is
		///    rebuilt to reflect the new query type.
		/// </remarks>
		public bool ClassDefinitionsOnly
		{
			get { return classDefinitionsOnly; }
			set { classDefinitionsOnly = value; BuildQuery(); FireIdentifierChanged(); }
		}


		// Builds the query string out of the currently values of the properties.
		protected internal void BuildQuery()
		{
			//If the source object is not set we can't build a query
			//Shouldn't throw here because the user may be in the process of filling in the properties...
			if (sourceObject == null)
				SetQueryString (String.Empty);

			if ((sourceObject == null) || (sourceObject == String.Empty))
				return;

			//"associators" clause
			string s = tokenAssociators + " " + tokenOf + " {" + sourceObject + "}";

			//If any of the other parameters are set we need a "where" clause
			if (!RelatedClass.Equals (String.Empty) || 
				!RelationshipClass.Equals (String.Empty) || 
				!RelatedQualifier.Equals (String.Empty) || 
				!RelationshipQualifier.Equals (String.Empty) || 
				!RelatedRole.Equals (String.Empty) || 
				!ThisRole.Equals (String.Empty) || 
				classDefinitionsOnly ||
				isSchemaQuery)
			{
				s = s + " " + tokenWhere;

				//"ResultClass"
				if (!RelatedClass.Equals (String.Empty))
					s = s + " " + tokenResultClass + " = " + relatedClass;

				//"AssocClass"
				if (!RelationshipClass.Equals (String.Empty))
					s = s + " " + tokenAssocClass + " = " + relationshipClass;

				//"ResultRole"
				if (!RelatedRole.Equals (String.Empty))
					s = s + " " + tokenResultRole + " = " + relatedRole;

				//"Role"
				if (!ThisRole.Equals (String.Empty))
					s = s + " " + tokenRole + " = " + thisRole;

				//"RequiredQualifier"
				if (!RelatedQualifier.Equals (String.Empty))
					s = s + " " + tokenRequiredQualifier + " = " + relatedQualifier;

				//"RequiredAssocQualifier"
				if (!RelationshipQualifier.Equals (String.Empty))
					s = s + " " + tokenRequiredAssocQualifier + " = " + relationshipQualifier;

				//"SchemaOnly" and "ClassDefsOnly"
				if (!isSchemaQuery) //this is an instance query - classDefs allowed
				{
					if (classDefinitionsOnly)
						s = s + " " + tokenClassDefsOnly;
				}
				else //this is a schema query, schemaonly required
					s = s + " " + tokenSchemaOnly;
			}
	
			//Set the queryString member to the built query (NB: note we set
			//by accessing the internal helper function rather than the property,
			//since we do not want to force a parse of a query we just built).
			SetQueryString (s);

		}//BuildQuery()


		// Parses the query string and sets the property members of the class accordingly.
		protected internal override void ParseQuery(string query)
		{
			// Temporary variables to hold token values until we are sure query is valid
			string tempSourceObject = null;
			string tempRelatedClass = null;
			string tempRelationshipClass = null;
			string tempRelatedRole = null;
			string tempThisRole = null;
			string tempRelatedQualifier = null;
			string tempRelationshipQualifier = null;
			bool   tempClassDefsOnly = false;
			bool   tempIsSchemaQuery = false;

			//Trim whitespaces
			string q = query.Trim(); 
			int i;

			//Find "associators" clause
			if (0 != String.Compare(q, 0, tokenAssociators, 0, tokenAssociators.Length, true))
				throw new ArgumentException();	// Invalid query
			
			// Strip off the clause
			q = q.Remove(0, tokenAssociators.Length);

			// Must be some white space next
			if ((0 == q.Length) || !Char.IsWhiteSpace (q[0]))
				throw new ArgumentException();	// Invalid query
			
			q = q.TrimStart(null);	// Remove the leading whitespace

			// Next token should be "of"
			if (0 != String.Compare(q, 0, tokenOf, 0, tokenOf.Length, true))
				throw new ArgumentException();	// Invalid query
			
			// Strip off the clause and leading WS
			q = q.Remove(0, tokenOf.Length).TrimStart (null);

			// Next character should be "{"
			if (0 != q.IndexOf('{'))
				throw new ArgumentException();	// Invalid query

			// Strip off the "{" and any leading WS
			q = q.Remove(0, 1).TrimStart(null);

			// Next item should be the source object
			if (-1 == (i = q.IndexOf('}')))
				throw new ArgumentException();	// Invalid query

			tempSourceObject = q.Substring(0, i).TrimEnd(null);
			q = q.Remove(0, i+1).TrimStart(null);
				
			// At this point we may or may not have a "where" clause
			if (0 < q.Length)
			{
				// Next should be the "where" clause
				if (0 != String.Compare (q, 0, tokenWhere, 0, tokenWhere.Length, true))
					throw new ArgumentException();	// Invalid query
				
				q = q.Remove (0, tokenWhere.Length);

				// Must be some white space next
				if ((0 == q.Length) || !Char.IsWhiteSpace (q[0]))
					throw new ArgumentException();	// Invalid query
				
				q = q.TrimStart(null);	// Remove the leading whitespace

				// Remaining tokens can appear in any order
				bool bResultClassFound = false;
				bool bAssocClassFound = false;
				bool bResultRoleFound = false;
				bool bRoleFound = false;
				bool bRequiredQualifierFound = false;
				bool bRequiredAssocQualifierFound = false;
				bool bClassDefsOnlyFound = false;
				bool bSchemaOnlyFound = false;

				// Keep looking for tokens until we are done
				while (true)
				{
					if ((q.Length >= tokenResultClass.Length) && (0 == String.Compare (q, 0, tokenResultClass, 0, tokenResultClass.Length, true)))
						ParseToken (ref q, tokenResultClass, "=", ref bResultClassFound, ref tempRelatedClass);
					else if ((q.Length >= tokenAssocClass.Length) && (0 == String.Compare (q, 0, tokenAssocClass, 0, tokenAssocClass.Length, true)))
						ParseToken (ref q, tokenAssocClass, "=", ref bAssocClassFound, ref tempRelationshipClass);
					else if ((q.Length >= tokenResultRole.Length) && (0 == String.Compare (q, 0, tokenResultRole, 0, tokenResultRole.Length, true)))
						ParseToken (ref q, tokenResultRole, "=", ref bResultRoleFound, ref tempRelatedRole);
					else if ((q.Length >= tokenRole.Length) && (0 == String.Compare (q, 0, tokenRole, 0, tokenRole.Length, true)))
						ParseToken (ref q, tokenRole, "=", ref bRoleFound, ref tempThisRole);
					else if ((q.Length >= tokenRequiredQualifier.Length) && (0 == String.Compare (q, 0, tokenRequiredQualifier, 0, tokenRequiredQualifier.Length, true)))
						ParseToken (ref q, tokenRequiredQualifier, "=", ref bRequiredQualifierFound, ref tempRelatedQualifier);
					else if ((q.Length >= tokenRequiredAssocQualifier.Length) && (0 == String.Compare (q, 0, tokenRequiredAssocQualifier, 0, tokenRequiredAssocQualifier.Length, true)))
						ParseToken (ref q, tokenRequiredAssocQualifier, "=", ref bRequiredAssocQualifierFound, ref tempRelationshipQualifier);
					else if ((q.Length >= tokenSchemaOnly.Length) && (0 == String.Compare (q, 0, tokenSchemaOnly, 0, tokenSchemaOnly.Length, true)))
					{
						ParseToken (ref q, tokenSchemaOnly, ref bSchemaOnlyFound);
						tempIsSchemaQuery = true;
					}
					else if ((q.Length >= tokenClassDefsOnly.Length) && (0 == String.Compare (q, 0, tokenClassDefsOnly, 0, tokenClassDefsOnly.Length, true)))
					{
						ParseToken (ref q, tokenClassDefsOnly, ref bClassDefsOnlyFound);
						tempClassDefsOnly = true;
					}
					else if (0 == q.Length)
						break;		// done
					else 
						throw new ArgumentException();		// Unrecognized token
				}

				//Can't have both classDefsOnly and schemaOnly
				if (bSchemaOnlyFound && bClassDefsOnlyFound)
					throw new ArgumentException();
			}

			// Getting here means we parsed successfully. Assign the values.
			sourceObject = tempSourceObject;
			relatedClass = tempRelatedClass;
			relationshipClass = tempRelationshipClass;
			relatedRole = tempRelatedRole;
			thisRole = tempThisRole;
			relatedQualifier = tempRelatedQualifier;
			relationshipQualifier = tempRelationshipQualifier;
			classDefinitionsOnly = tempClassDefsOnly;
			isSchemaQuery = tempIsSchemaQuery;

		}//ParseQuery()


		//ICloneable
		/// <summary>
		///    <para>[To be supplied.]</para>
		/// </summary>
		public override object Clone()
		{
			if (isSchemaQuery == false)
				return new RelatedObjectQuery(sourceObject, relatedClass, relationshipClass, 
											relatedQualifier, relationshipQualifier, relatedRole, 
											thisRole, classDefinitionsOnly);
			else
				return new RelatedObjectQuery(true, sourceObject, relatedClass, relationshipClass, 
											relatedQualifier, relationshipQualifier, relatedRole, 
											thisRole);
				
		}

	}//RelatedObjectQuery


	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	/// This class represents a WMI "references of" query
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class RelationshipQuery : WqlObjectQuery
	{
		private static readonly string tokenReferences = "references";
		private static readonly string tokenOf = "of";
		private static readonly string tokenWhere = "where";
		private static readonly string tokenResultClass = "resultclass";
		private static readonly string tokenRole = "role";
		private static readonly string tokenRequiredQualifier = "requiredqualifier";
		private static readonly string tokenClassDefsOnly = "classdefsonly";
		private static readonly string tokenSchemaOnly = "schemaonly";

		private string sourceObject;
		private string relationshipClass;
		private string relationshipQualifier;
		private string thisRole;
		private bool classDefinitionsOnly;
		private bool isSchemaQuery;
		
		//default constructor
		/// <summary>
		///    <para>Default constructor creates an uninitialized query object.</para>
		/// </summary>
		public RelationshipQuery() :this(null) {}
		
		//parameterized constructor
		//ISSUE : We have 2 possible constructors that take a single string :
		//  one that takes the full query string and the other that takes the source object path.
		//  We resolve this by trying to parse the string, if it succeeds we assume it's the query, if
		//  not we assume it's the source object.
		/// <summary>
		///    <para>Creates a new relationship objects query object. If the specified string can be succesfully parsed as 
		///    a WQL query, it is considered to be the query string, otherwise it is assumed to be the path of the source 
		///    object for the query. In this case the query is assumed to be an instances query. </para>
		/// </summary>
		/// <example>
		///    <para>RelationshipQuery q = new RelationshipQuery("references of {Win32_ComputerSystem.Name='mymachine'}");</para>
		///    <para> or </para>
		///    <para>RelationshipQuery q = new RelationshipQuery("Win32_Service.Name='Alerter'");
		/// </example>
		public RelationshipQuery(string queryOrSourceObject)
		{
			if (null != queryOrSourceObject)
			{
				// Minimally determine if the string is a query or instance name.
				//
				if (queryOrSourceObject.TrimStart().ToLower().StartsWith(tokenReferences))
				{
					// Looks to be a query - do further checking.
					//
					QueryString = queryOrSourceObject;	// Parse/validate; may throw.
				}
				else
				{
					// We'd like to treat it as the source object. Is it a valid
					// class or instance?
					try 
					{
						// Do some basic sanity checking on whether it's a class/instance name
						//
						ManagementPath p = new ManagementPath (queryOrSourceObject);

						if ((p.IsClass || p.IsInstance) && (0 == String.Empty.CompareTo (p.NamespacePath)))
						{
							SourceObject = queryOrSourceObject;
							isSchemaQuery = false;
						}
						else
							throw new ArgumentException ();
					}
					catch (Exception)
					{
						throw new ArgumentException ();
					}
				}
			}
		}

		/// <summary>
		///    <para>Creates a new relationship objects query for the given source object and relationship class.
		///    The query is assumed to be an instances query (as opposed to a schema query).</para>
		/// </summary>
		public RelationshipQuery(string sourceObject, string relationshipClass) : this(sourceObject, relationshipClass, 
																					    null, null, false) {}
		//Do we need additional variants of constructors here ??
		/// <summary>
		///    <para>Creates a new relationship objects query for the given set of parameters.
		///    The query is assumed to be an instances query (as opposed to a schema query).</para>
		/// </summary>
		public RelationshipQuery(string sourceObject,
							      string relationshipClass, 
								  string relationshipQualifier, 
								  string thisRole, 
								  bool classDefinitionsOnly) 
		{
			this.isSchemaQuery = false;
			this.sourceObject = sourceObject;
			this.relationshipClass = relationshipClass;
			this.relationshipQualifier = relationshipQualifier;
			this.thisRole = thisRole;
			this.classDefinitionsOnly = classDefinitionsOnly;
			BuildQuery();
		}

		/// <summary>
		///    <para>Creates a new related classes schema query for the given set of parameters.
		///    This constructor is used for schema queries only and so the first parameter has to be 'true'.</para>
		/// </summary>
		public RelationshipQuery(bool isSchemaQuery,
			string sourceObject,
			string relationshipClass, 
			string relationshipQualifier, 
			string thisRole) 
		{
			if (isSchemaQuery == false)
				throw new ArgumentException(null, "isSchemaQuery");

			this.isSchemaQuery = true;
			this.sourceObject = sourceObject;
			this.relationshipClass = relationshipClass;
			this.relationshipQualifier = relationshipQualifier;
			this.thisRole = thisRole;
			this.classDefinitionsOnly = false; //this parameter is not relevant for schema queries.
			BuildQuery();

		}
		
		
		/// <summary>
		///    Specifies whether this query is a schema query or an instances query.
		/// </summary>
		/// <remarks>
		///    Setting this property value overrides any
		///    previous value stored in the object. As a side-effect, the QueryString is
		///    rebuilt to reflect the new query type.
		/// </remarks>
		public bool IsSchemaQuery
		{
			get 
			{ return isSchemaQuery; }
			set 
			{ isSchemaQuery = value; BuildQuery(); FireIdentifierChanged(); }
		}

		
		/// <summary>
		///    Specifies the source object for this query.
		/// </summary>
		/// <remarks>
		///    Setting this property value overrides any
		///    previous value stored in the object. As a side-effect, the QueryString is
		///    rebuilt to reflect the new query type.
		/// </remarks>
		public string SourceObject
		{
			get { return (null != sourceObject) ? sourceObject : String.Empty; }
			set { sourceObject = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    Specifies the class of the relationship objects that the query requests.
		/// </summary>
		/// <remarks>
		///    Setting this property value overrides any
		///    previous value stored in the object. As a side-effect, the QueryString is
		///    rebuilt to reflect the new query type.
		/// </remarks>
		public string RelationshipClass
		{
			get { return (null != relationshipClass) ? relationshipClass : String.Empty; }
			set { relationshipClass = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    Specifies a qualifier required on the relationship objects.
		/// </summary>
		/// <remarks>
		///    Setting this property value overrides any
		///    previous value stored in the object. As a side-effect, the QueryString is
		///    rebuilt to reflect the new query type.
		/// </remarks>
		public string RelationshipQualifier
		{
			get { return (null != relationshipQualifier) ? relationshipQualifier : String.Empty; }
			set { relationshipQualifier = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    Specifies the role of the source object in the relationship.
		/// </summary>
		/// <remarks>
		///    Setting this property value overrides any
		///    previous value stored in the object. As a side-effect, the QueryString is
		///    rebuilt to reflect the new query type.
		/// </remarks>
		public string ThisRole
		{
			get { return (null != thisRole) ? thisRole : String.Empty; }
			set { thisRole = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    Requests that only the class definitions of the relevant relationship objects be returned.
		/// </summary>
		/// <remarks>
		///    Setting this property value overrides any
		///    previous value stored in the object. As a side-effect, the QueryString is
		///    rebuilt to reflect the new query type.
		/// </remarks>
		public bool ClassDefinitionsOnly
		{
			get { return classDefinitionsOnly; }
			set { classDefinitionsOnly = value; BuildQuery(); FireIdentifierChanged(); }
		}


		//Builds the query string for the current values of the property members.
		protected internal void BuildQuery()
		{
			//If the source object is not set we can't build a query
			//Shouldn't throw here because the user may be in the process of filling in the properties...
			if (sourceObject == null)
				SetQueryString(String.Empty);

			if ((sourceObject == null) || (sourceObject == String.Empty))
				return;

			//"references" clause
			string s = tokenReferences + " " + tokenOf + " {" + sourceObject + "}";

			//If any of the other parameters are set we need a "where" clause
			if (!RelationshipClass.Equals(String.Empty) || 
				!RelationshipQualifier.Equals(String.Empty) || 
				!ThisRole.Equals(String.Empty) || 
				classDefinitionsOnly ||
				isSchemaQuery)
			{
				s = s + " " + tokenWhere;

				//"ResultClass"
				if (!RelationshipClass.Equals(String.Empty))
					s = s + " " + tokenResultClass + " = " + relationshipClass;

				//"Role"
				if (!ThisRole.Equals(String.Empty))
					s = s + " " + tokenRole + " = " + thisRole;

				//"RequiredQualifier"
				if (!RelationshipQualifier.Equals(String.Empty))
					s = s + " " + tokenRequiredQualifier + " = " + relationshipQualifier;

				//"SchemaOnly" and "ClassDefsOnly"
				if (!isSchemaQuery) //this is an instance query - classDefs allowed
				{
					if (classDefinitionsOnly)
						s = s + " " + tokenClassDefsOnly;
				}
				else //this is a schema query, schemaonly required
					s = s + " " + tokenSchemaOnly;
				
			}

			//Set the queryString member to the built query (NB: note we set
			//by accessing the internal helper function rather than the property,
			//since we do not want to force a parse of a query we just built).
			SetQueryString (s);
		} //BuildQuery()

		
		// Parse the query string and set the member properties accordingly
		protected internal override void ParseQuery(string query)
		{
			// Temporary variables to hold token values until we are sure query is valid
			string tempSourceObject = null;
			string tempRelationshipClass = null;
			string tempThisRole = null;
			string tempRelationshipQualifier = null;
			bool   tempClassDefsOnly = false;
			bool   tempSchemaOnly = false;

			//Trim whitespaces
			string q = query.Trim(); 
			int i;

			//Find "references" clause
			if (0 != String.Compare(q, 0, tokenReferences, 0, tokenReferences.Length, true))
				throw new ArgumentException();	// Invalid query
			
			// Strip off the clause
			q = q.Remove(0, tokenReferences.Length);

			// Must be some white space next
			if ((0 == q.Length) || !Char.IsWhiteSpace (q[0]))
				throw new ArgumentException();	// Invalid query
			
			q = q.TrimStart(null);	// Remove the leading whitespace

			// Next token should be "of"
			if (0 != String.Compare(q, 0, tokenOf, 0, tokenOf.Length, true))
				throw new ArgumentException();	// Invalid query
			
			// Strip off the clause and leading WS
			q = q.Remove(0, tokenOf.Length).TrimStart (null);

			// Next character should be "{"
			if (0 != q.IndexOf('{'))
				throw new ArgumentException();	// Invalid query

			// Strip off the "{" and any leading WS
			q = q.Remove(0, 1).TrimStart(null);

			// Next item should be the source object
			if (-1 == (i = q.IndexOf('}')))
				throw new ArgumentException();	// Invalid query

			tempSourceObject = q.Substring(0, i).TrimEnd(null);
			q = q.Remove(0, i+1).TrimStart(null);
				
			// At this point we may or may not have a "where" clause
			if (0 < q.Length)
			{
				// Next should be the "where" clause
				if (0 != String.Compare (q, 0, tokenWhere, 0, tokenWhere.Length, true))
					throw new ArgumentException();	// Invalid query
				
				q = q.Remove (0, tokenWhere.Length);

				// Must be some white space next
				if ((0 == q.Length) || !Char.IsWhiteSpace (q[0]))
					throw new ArgumentException();	// Invalid query
				
				q = q.TrimStart(null);	// Remove the leading whitespace

				// Remaining tokens can appear in any order
				bool bResultClassFound = false;
				bool bRoleFound = false;
				bool bRequiredQualifierFound = false;
				bool bClassDefsOnlyFound = false;
				bool bSchemaOnlyFound = false;

				// Keep looking for tokens until we are done
				while (true)
				{
					if ((q.Length >= tokenResultClass.Length) && (0 == String.Compare (q, 0, tokenResultClass, 0, tokenResultClass.Length, true)))
						ParseToken (ref q, tokenResultClass, "=", ref bResultClassFound, ref tempRelationshipClass);
					else if ((q.Length >= tokenRole.Length) && (0 == String.Compare (q, 0, tokenRole, 0, tokenRole.Length, true)))
						ParseToken (ref q, tokenRole, "=", ref bRoleFound, ref tempThisRole);
					else if ((q.Length >= tokenRequiredQualifier.Length) && (0 == String.Compare (q, 0, tokenRequiredQualifier, 0, tokenRequiredQualifier.Length, true)))
						ParseToken (ref q, tokenRequiredQualifier, "=", ref bRequiredQualifierFound, ref tempRelationshipQualifier);
					else if ((q.Length >= tokenClassDefsOnly.Length) && (0 == String.Compare (q, 0, tokenClassDefsOnly, 0, tokenClassDefsOnly.Length, true)))
					{
						ParseToken (ref q, tokenClassDefsOnly, ref bClassDefsOnlyFound);
						tempClassDefsOnly = true;
					}
					else if ((q.Length >= tokenSchemaOnly.Length) && (0 == String.Compare (q, 0, tokenSchemaOnly, 0, tokenSchemaOnly.Length, true)))
					{
						ParseToken (ref q, tokenSchemaOnly, ref bSchemaOnlyFound);
						tempSchemaOnly = true;
					}
					else if (0 == q.Length)
						break;		// done
					else 
						throw new ArgumentException();		// Unrecognized token
				}

				//Can't have both classDefsOnly and schemaOnly
				if (tempClassDefsOnly && tempSchemaOnly)
					throw new ArgumentException();

			}

			// Getting here means we parsed successfully. Assign the values.
			sourceObject = tempSourceObject;
			relationshipClass = tempRelationshipClass;
			thisRole = tempThisRole;
			relationshipQualifier = tempRelationshipQualifier;
			classDefinitionsOnly = tempClassDefsOnly;
			isSchemaQuery = tempSchemaOnly;

		}//ParseQuery()


		//ICloneable
		/// <summary>
		///    <para>[To be supplied.]</para>
		/// </summary>
		public override object Clone()
		{
			if (isSchemaQuery == false)
				return new RelationshipQuery(sourceObject, relationshipClass, 
											relationshipQualifier, thisRole, classDefinitionsOnly);
			else
				return new RelationshipQuery(true, sourceObject, relationshipClass, relationshipQualifier,
											thisRole);
		}

	}//RelationshipQuery


	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para>This class represents a WMI event query in the WQL format.</para>
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class WqlEventQuery : EventQuery
	{
		private static readonly string tokenSelectAll = "select * ";

		private string eventClassName;
		private TimeSpan withinInterval;
		private string condition;
		private TimeSpan groupWithinInterval;
		private StringCollection groupByPropertyList;
		private string havingCondition;

		//default constructor
		/// <summary>
		///    Default constructor creates an uninitialized event query
		///    object.
		/// </summary>
		public WqlEventQuery() : this(null, TimeSpan.Zero, null, TimeSpan.Zero, null, null) {}
        
		//parameterized constructors
		//ISSUE : We have 2 possible constructors that take a single string :
		//  one that takes the full query string and the other that takes the class name.
		//  We resolve this by trying to parse the string, if it succeeds we assume it's the query, if
		//  not we assume it's the class name.
		/// <summary>
		///    <para>Creates a WQL event query object, based on the given 
		///       query string or event class name.</para>
		/// </summary>
		/// <param name='queryOrEventClassName'>The string representing either the entire event query, or the name of the event class to query on. The object will try to parse the string as a valid event query, and if the parsing fails it will assume the parameter represents an event class name.</param>
		/// <example>
		///    <para>WqlEventQuery q = new WqlEventQuery("select * from 
		///       MyEvent");</para>
		///    <para>or</para>
		///    <para>WqlEventQuery q = new WqlEventQuery("MyEvent"); //results in the same query 
		///       as above.</para>
		/// </example>
		public WqlEventQuery(string queryOrEventClassName) 
		{
			groupByPropertyList = new StringCollection();

			if (null != queryOrEventClassName)
			{
				// Minimally determine if the string is a query or event class name.
				//
				if (queryOrEventClassName.TrimStart().ToLower().StartsWith(tokenSelectAll))
				{
					QueryString = queryOrEventClassName;	// Parse/validate; may throw.
				}
				else
				{
					try 
					{
						// Do some basic sanity checking on whether it's a class name
						//
						ManagementPath p = new ManagementPath (queryOrEventClassName);

						if (p.IsClass && (0 == String.Empty.CompareTo (p.NamespacePath)))
						{
							EventClassName = queryOrEventClassName;
						}
						else
							throw new ArgumentException ();
					}
					catch (Exception)
					{
						throw new ArgumentException ();
					}
				}
			}
		}

		/// <summary>
		///    Creates a new WQL event query object for the specified
		///    event class name and with the specified condition
		/// </summary>
		/// <param name='eventClassName'>The name of the event class to use in the query</param>
		/// <param name=' condition'>The condition to apply to events of the specified class</param>
		/// <example>
		///    WqlEventQuery q = new
		///    WqlEventQuery("MyEvent", "FirstProp &lt; 20 and SecondProp = 'red'");
		/// </example>
		public WqlEventQuery(string eventClassName, string condition) : this(eventClassName, TimeSpan.Zero, condition, TimeSpan.Zero, null, null) {}
		/// <summary>
		///    <para>Creates a new event query object for the specified event 
		///       class and with the specified latency time.</para>
		/// </summary>
		/// <param name='eventClassName'>The name of the event class to be queried on</param>
		/// <param name=' withinInterval'>A timespan value specifying the latency acceptable for receiving this event. This value is used in cases where there is no explicit event provider for the query requested and WMI is required to poll for the condition. This interval is the maximum amount of time that can pass before notification of an event must be delivered. </param>
		/// <example>
		///    <para>WqlEventQuery q = new WqlEventQuery("__InstanceCreationEvent", new
		///       TimeSpan(0,0,10));
		///       This creates the event query : "select * from __InstanceCreationEvent
		///       within 10"</para>
		/// </example>
		public WqlEventQuery(string eventClassName, TimeSpan withinInterval): 
										this(eventClassName, withinInterval, null, TimeSpan.Zero, null, null) {}
		/// <summary>
		///    <para>Creates a new event query object with the specified
		///       event class name, polling interval and condition.</para>
		/// </summary>
		/// <param name='eventClassName'>The name of the event class to be queried on</param>
		/// <param name=' withinInterval'>A timespan value specifying the latency acceptable for receiving this event. This value is used in cases where there is no explicit event provider for the query requested and WMI is required to poll for the condition. This interval is the maximum amount of time that can pass before notification of an event must be delivered. </param>
		/// <param name=' condition'>The condition to apply to events of the specified class</param>
		/// <example>
		///    <para>WqlEventQuery q = 
		///       new WqlEventQuery("__InstanceCreationEvent", new TimeSpan(0,0,10), "TargetInstance
		///       isa Win32_Service");</para>
		///    <para>This creates the event query : "select * from 
		///       __InstanceCreationEvent within 10 where TargetInstance isa Win32_Service", which means : I'm interested in events notifying of creation Win32_Service instances, with
		///       a 10 second polling interval.</para>
		/// </example>
		public WqlEventQuery(string eventClassName, TimeSpan withinInterval, string condition) : 
										this(eventClassName, withinInterval, condition, TimeSpan.Zero, null, null) {}
		/// <summary>
		///    <para>Creates a new event query object with the specified
		///       event class name, condition and grouping interval.</para>
		/// </summary>
		/// <param name='eventClassName'>The name of the event class to be queried on</param>
		/// <param name='condition'>The condition to apply to events of the specified class</param>
		/// <param name=' groupWithinInterval'>When this option is specified, WMI sends one aggregate event at the specified interval, rather than many events</param>
		/// <example>
		///    <para>WqlEventQuery q = new WqlEventQuery("FrequentEvent", "InterestingProperty = 
		///       5",
		///       new TimeSpan(0,0,10));</para>
		///    <para>This creates the event query : "select * from 
		///       FrequentEvent where InterestingProperty= 5 group within 10", which means : I'm
		///       interested in events of type FrequentEvent, in which the InterestingProperty is equal to 5, but I want an aggregate event
		///       in a 10 second timeframe.</para>
		/// </example>

		public WqlEventQuery(string eventClassName, string condition, TimeSpan groupWithinInterval) :
										this(eventClassName, TimeSpan.Zero, condition, groupWithinInterval, null, null) {}
		/// <summary>
		///    <para>Creates a new event query object with the specified event class
		///       name, condition, grouping interval &amp; grouping properties.</para>
		/// </summary>
		/// <param name='eventClassName'>The name of the event class to be queried on</param>
		/// <param name='condition'>The condition to apply to events of the specified class</param>
		/// <param name=' groupWithinInterval'>When this option is specified, WMI sends one aggregate event at the specified interval, rather than many events</param>
		/// <param name=' groupByPropertyList'>Specifies properties in the event class that the events should be grouped by.</param>
		/// <example>
		///    <para>String[] props = {"Importance"};</para>
		///    <para>WqlEventQuery q = new WqlEventQuery("EmailEvent", "Sender = 'MyBoss'", new TimeSpan(0,10,0), props);</para>
		///    <para>This creates the event query : "select * from 
		///       EmailEvent where Sender = 'MyBoss' group within 300 by Importance", which means : notify
		///       me when new email from a particular sender has arrived within the last 10 minutes,
		///       combined with other events that have the same value in the Importance property.</para>
		/// </example>
		public WqlEventQuery(string eventClassName, string condition, TimeSpan groupWithinInterval, string[] groupByPropertyList) : 
			this(eventClassName, TimeSpan.Zero, condition, groupWithinInterval, groupByPropertyList, null) {}
		/// <summary>
		///    <para>Creates a new event query object with the specified event class
		///       name, condition, grouping interval, grouping properties &amp; specified number of events.</para>
		/// </summary>
		/// <param name='eventClassName'>The name of the event class to be queried on</param>
		/// <param name='withinInterval'>A timespan value specifying the latency acceptable for receiving this event. This value is used in cases where there is no explicit event provider for the query requested and WMI is required to poll for the condition. This interval is the maximum amount of time that can pass before notification of an event must be delivered.</param>
		/// <param name=' condition'>The condition to apply to events of the specified class</param>
		/// <param name=' groupWithinInterval'>When this option is specified, WMI sends one aggregate event at the specified interval, rather than many events</param>
		/// <param name=' groupByPropertyList'>Specifies properties in the event class that the events should be grouped by.</param>
		/// <param name=' havingCondition'>Specifies the condition to apply to the number of events.</param>
		/// <example>
		///    <para>String[] props = {"TargetInstance.SourceName"};</para>
		///    <para>WqlEventQuery q = new WqlEventQuery("__InstanceCreationEvent", "TargetInstance isa Win32_NTLogEvent", new TimeSpan(0,10,0), props, "NumberOfEvents &gt;15");</para>
		///    <para>This creates the event query :</para>
		///    <para> "select * from 
		///       __InstanceCreationEvent where TargetInstance isa Win32_NTLogEvent </para>
		///    <para> 
		///       group within 300 by TargetInstance.SourceName having NumberOfEvents &gt; 15" </para>
		///    <para>which means : deliver aggregate events only if the number of Win32_NTLogEvent events
		///       received from the same source exceeds 15.</para>
		/// </example>
		public WqlEventQuery(string eventClassName, TimeSpan withinInterval, string condition, TimeSpan groupWithinInterval, 
						  string[] groupByPropertyList, string havingCondition)
		{
			this.eventClassName = eventClassName;
			this.withinInterval = withinInterval;
			this.condition = condition;
			this.groupWithinInterval = groupWithinInterval;
			this.groupByPropertyList = new StringCollection ();

			if (null != groupByPropertyList)
				this.groupByPropertyList.AddRange (groupByPropertyList);
			
			this.havingCondition = havingCondition;
			BuildQuery();
		}

		
		//QueryLanguage property is read-only in this class (does this work ??)
		/// <summary>
		///    Specifies the language of the query
		/// </summary>
		/// <value>
		///    The value of this property in this
		///    object is always "WQL".
		/// </value>
		public override string QueryLanguage
		{
			get 
			{return base.QueryLanguage;}
		}
		
		public override string QueryString
		{
			get 
			{
				// We need to force a rebuild as we may not have detected
				// a change to selected properties
				BuildQuery ();
				return base.QueryString;
			}
			set 
			{
				base.QueryString = value;
			}
		}
	
		/// <summary>
		///    <para>Represents the event class name that this query is about.</para>
		/// </summary>
		/// <remarks>
		///    <para>When this property is set, any previous
		///       value stored in this query object is erased, and the query string is rebuilt to
		///       reflect the new class name.</para>
		/// </remarks>
		/// <example>
		///    <para>WqlEventQuery q = new WqlEventQuery();</para>
		///    <para>EventClassName = "MyEvent";</para>
		///    <para>creates a new event query object that represents the query : "select * from 
		///       MyEvent".</para>
		/// </example>
		public string EventClassName
		{
			get { return (null != eventClassName) ? eventClassName : String.Empty; }
			set { eventClassName = value; BuildQuery(); }
		}
		/// <summary>
		///    <para>Specifies the condition to be applied to events of the
		///       specified class.</para>
		/// </summary>
		/// <value>
		///    <para>The condition is represented as a
		///       string, containing one or more clauses of the form : &lt;propName&gt;
		///       &lt;operator&gt; &lt;value&gt; combined with and/or operators. &lt;propName&gt;
		///       must represent a property defined on the event class specified in this query.</para>
		/// </value>
		/// <remarks>
		///    <para>When this property is set, any previous
		///       value stored in this query object is erased, and the query string is rebuilt to
		///       reflect the new condition.</para>
		/// </remarks>
		/// <example>
		///    <para>WqlEventQuery q = new WqlEventQuery();</para>
		///    <para>EventClassName = "MyEvent";</para>
		///    <para>Condition = "PropVal &gt; 8";</para>
		///    <para>creates a new event query object that represents the query : "select * from 
		///       MyEvent where PropVal &gt; 8".</para>
		/// </example>
		public string Condition 
		{
			get { return (null != condition) ? condition : String.Empty; }
			set { condition = value; BuildQuery(); }
		}

		/// <summary>
		///    <para>Specifies the polling interval to be used in this query.</para>
		/// </summary>
		/// <value>
		///    <para>Null if there is no polling
		///       involved, or a valid TimeSpan value if polling is required.</para>
		/// </value>
		/// <remarks>
		///    <para>This property should only be set in cases
		///       where there is no event provider for the event requested, and WMI is required to
		///       poll for the requested condition.</para>
		///    <para>When this property is set, any previous value stored in this query object is 
		///       erased, and the query string is rebuilt to reflect the new interval.</para>
		/// </remarks>
		/// <example>
		///    <para>WqlEventQuery q = new WqlEventQuery();</para>
		///    <para>EventClassName = "__InstanceModificationEvent";</para>
		///    <para>Condition = "PropVal &gt; 8";</para>
		///    <para>WithinInterval = new TimeSpan(0,0,10);</para>
		///    <para>creates a new event query object that represents the query : "select * from 
		///       __InstanceModificationEvent within 10 where PropVal &gt; 8".</para>
		/// </example>
		public TimeSpan WithinInterval
		{
			get { return withinInterval; }
			set { withinInterval = value; BuildQuery(); }
		}

		/// <summary>
		///    <para>Specifies the interval to be used for grouping events of
		///       the same kind.</para>
		/// </summary>
		/// <value>
		///    <para>Null if there is no grouping
		///       involved, otherwise specifies the interval in which WMI should group events of
		///       the same kind.</para>
		/// </value>
		/// <remarks>
		///    <para>When this property is set, any previous value stored in this query object is 
		///       erased, and the query string is rebuilt to reflect the new interval.</para>
		/// </remarks>
		/// <example>
		///    <para>WqlEventQuery q = new WqlEventQuery();</para>
		///    <para>EventClassName = "MyEvent";</para>
		///    <para>Condition = "PropVal &gt; 8";</para>
		///    <para>GroupWithinInterval = new TimeSpan(0,0,10);</para>
		///    <para>creates a new event query object that represents the 
		///       query : "select * from MyEvent where PropVal &gt; 8 group within 10", meaning :
		///       notify me of all MyEvent events where the PropVal property is greater than 8,
		///       and aggregate these events within 10 second intervals.</para>
		/// </example>
		public TimeSpan GroupWithinInterval
		{
			get { return groupWithinInterval; }
			set { groupWithinInterval = value; BuildQuery(); }
		}

		/// <summary>
		///    <para>Specifies properties in the event to be used for
		///       grouping events of the same kind.</para>
		/// </summary>
		/// <value>
		///    <para>Null if no grouping is required.
		///       Otherwise this is a collection of event property names to be used for
		///       aggregating events.</para>
		/// </value>
		/// <remarks>
		///    <para>When this property is set, any previous value stored in this query object is 
		///       erased, and the query string is rebuilt to reflect the new grouping.</para>
		/// </remarks>
		/// <example>
		///    <para>WqlEventQuery q = new WqlEventQuery();</para>
		///    <para>EventClassName = "EmailEvent";</para>
		///    <para>GroupWithinInterval = new TimeSpan(0,10,0);</para>
		///    <para>GroupByPropertyList = new StringCollection();</para>
		///    <para>GroupByPropertyList.Add("Sender");</para>
		///    <para> 
		///       creates a new event query object that represents the query : "select
		///       * from EmailEvent group within 300 by Sender", meaning : notify me of all
		///       EmailEvent events, aggregated by the Sender property within 10 minute intervals.</para>
		/// </example>
		public StringCollection GroupByPropertyList
		{
			get { return groupByPropertyList; }
			set { 
				// A tad painful since StringCollection doesn't support ICloneable
				StringCollection src = (StringCollection)value;
				StringCollection dst = new StringCollection ();

				foreach (String s in src)
					dst.Add (s);
					
				groupByPropertyList = dst; 
				BuildQuery();
			}
		}

		/// <summary>
		///    <para>Specifies the condition to be applied to aggregation of
		///       events based on the number of events received.</para>
		/// </summary>
		/// <value>
		///    <para>Null if no aggregation or no
		///       condition should be applied. Otherwise specifies a condition of the form
		///       "NumberOfEvents &lt;operator&gt; &lt;value&gt;" to be applied to the
		///       aggregation.</para>
		/// </value>
		/// <remarks>
		///    <para>When this property is set, any previous value stored in this query object is
		///       erased, and the query string is rebuilt to reflect the new grouping condition.</para>
		/// </remarks>
		/// <example>
		///    <para>WqlEventQuery q = new WqlEventQuery();</para>
		///    <para>EventClassName = "EmailEvent";</para>
		///    <para>GroupWithinInterval = new TimeSpan(0,10,0);</para>
		///    <para>HavingCondition = "NumberOfEvents &gt; 5";</para>
		///    <para> 
		///       creates a new event query object that
		///       represents the query : "select * from EmailEvent group within 300 having
		///       NumberOfEvents &gt; 5", meaning : notify me of all EmailEvent events, aggregated within 10
		///       minute intervals, if there are more than 5 occurences of them.</para>
		/// </example>
		public string HavingCondition
		{
			get { return (null != havingCondition) ? havingCondition : String.Empty; }
			set { havingCondition = value; BuildQuery(); }
		}

		
		/// <summary>
		///    <para>[To be supplied.]</para>
		/// </summary>
		protected internal void BuildQuery()
		{
			//If the event class name is not set we can't build a query
			//This shouldn't throw because the user may be in the process of setting properties...
			if ((eventClassName == null) || (eventClassName == String.Empty))
			{
				SetQueryString (String.Empty);
				return;
			}

			//Select clause
			string s = tokenSelectAll;	//no property list allowed here...

			//From clause
			s = s + "from " + eventClassName;

			//Within clause
			if (withinInterval != TimeSpan.Zero)
				s = s + " within " + withinInterval.TotalSeconds.ToString();

			//Where clause
			if (!Condition.Equals(String.Empty))
				s = s + " where " + condition;

			//Group within clause
			if (groupWithinInterval != TimeSpan.Zero)
			{
				s = s + " group within " + groupWithinInterval.TotalSeconds.ToString();

				//Group By clause
				if ((null != groupByPropertyList) && (0 < groupByPropertyList.Count))
				{
					int count = groupByPropertyList.Count;
					s = s + " by ";

					for (int i=0; i<count; i++)
						s = s + groupByPropertyList[i] + (i == (count - 1) ? "" : ",");
				}

				//Having clause
				if (!HavingCondition.Equals(String.Empty))
				{
					s = s + " having " + havingCondition;
				}
			}

			//Set the queryString member to the built query (NB: note we set
			//by accessing the internal helper function rather than the property,
			//since we do not want to force a parse of a query we just built).
			SetQueryString (s);

		}//BuildQuery

		//TODO : Need to solidify this parsing....
		/// <summary>
		///    <para>[To be supplied.]</para>
		/// </summary>
		protected internal override void ParseQuery(string query)
		{
			//Trim whitespaces
			string q = query.Trim(); 
			int i; 
			string w, tempProp;
			bool bFound = false;

            //Find "select" clause and make sure it's a select *
			string keyword = tokenSelect;
			if ((q.Length < keyword.Length) || (0 != String.Compare (q, 0, keyword, 0, keyword.Length, true)))
				throw new ArgumentException();
			q =	q.Remove(0, keyword.Length).TrimStart(null);

			if (!q.StartsWith("*")) 
					throw new ArgumentException();
			q = q.Remove(0, 1).TrimStart(null);

			//Find "from" clause
			keyword = "from ";
			if ((q.Length < keyword.Length) || (0 != String.Compare (q, 0, keyword, 0, keyword.Length, true)))
				throw new ArgumentException();
			ParseToken(ref q, keyword, null, ref bFound, ref eventClassName);

			//Find "within" clause
			keyword = "within ";
			if ((q.Length >= keyword.Length) && (0 == String.Compare (q, 0, keyword, 0, keyword.Length, true))) 
			{
				string intervalString = null; bFound = false;
				ParseToken(ref q, keyword, null, ref bFound, ref intervalString);
				withinInterval = TimeSpan.FromSeconds(((IConvertible)intervalString).ToDouble(null));
			}
            
			//Find "group within" clause
			keyword = "group within ";
			if ((q.Length >= keyword.Length) && ((i = q.ToLower().IndexOf(keyword)) != -1)) //found
			{
				//Separate the part of the string before this - that should be the "where" clause
				w = q.Substring(0, i).Trim();
				q = q.Remove(0, i);

				string intervalString = null; bFound=false;
				ParseToken(ref q, keyword, null, ref bFound, ref intervalString);
				groupWithinInterval = TimeSpan.FromSeconds(((IConvertible)intervalString).ToDouble(null));

				//Find "By" subclause
				keyword = "by ";
				if ((q.Length >= keyword.Length) && (0 == String.Compare (q, 0, keyword, 0, keyword.Length, true)))
				{
					q = q.Remove(0, keyword.Length);
					if (null != groupByPropertyList)
						groupByPropertyList.Clear ();
					else
						groupByPropertyList = new StringCollection ();

					//get the property list
					while (true)
					{
						if ((i = q.IndexOf(',')) > 0)
						{
							tempProp = q.Substring(0, i);
							q = q.Remove(0, i+1).TrimStart(null);
							tempProp = tempProp.Trim();
							if (tempProp != String.Empty)
								groupByPropertyList.Add(tempProp);
						}
						else
						{ //last property in the list
							if ((i = q.IndexOf(' ')) > 0)
							{
								tempProp = q.Substring(0, i);
								q = q.Remove(0, i).TrimStart(null);
								groupByPropertyList.Add(tempProp);
								break;
							}
							else //end of the query
							{
								groupByPropertyList.Add(q);
								return;
							}
						}
					} //while
				} //by

				//Find "Having" subclause
				keyword = "having "; bFound = false;
				if ((q.Length >= keyword.Length) && (0 == String.Compare (q, 0, keyword, 0, keyword.Length, true)))
				{   //the rest until the end is assumed to be the having condition
					q = q.Remove(0, keyword.Length);
					
					if (q.Length == 0) //bad query
						throw new ArgumentException();

					havingCondition = q;
				}
			}
			else
				//No "group within" then everything should be the "where" clause
				w = q.Trim();

			//Find "where" clause
			keyword = "where ";
			if ((w.Length >= keyword.Length) && (0 == String.Compare (w, 0, keyword, 0, keyword.Length, true))) //where clause exists
			{
				condition = w.Substring(keyword.Length);				
			}

		}//ParseQuery()


		//ICloneable
		/// <summary>
		///    Creates a copy of the current event query object.
		/// </summary>
		public override object Clone()
		{
			string[] strArray = null;

			if (null != groupByPropertyList)
			{
				int count = groupByPropertyList.Count;

				if (0 < count)
				{
					strArray = new String [count];
					groupByPropertyList.CopyTo (strArray, 0);
				}
			}

			return new WqlEventQuery(eventClassName, withinInterval, condition, groupWithinInterval, 
																			strArray, havingCondition);
		}

	}//WqlEventQuery
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\managementscope.cs ===
using System;
using System.ComponentModel;
using System.Runtime.InteropServices;
using WbemClient_v1;

namespace System.Management
{
	/// <summary>
	/// A scope for management operations
	/// </summary>
	[TypeConverter(typeof(ExpandableObjectConverter))]
	public class ManagementScope : ICloneable
	{
		private ManagementPath		path;
		private IWbemServices		wbemServices;
		private IWmiSec				securityHelper;
		private ConnectionOptions	options;
		internal event IdentifierChangedEventHandler IdentifierChanged;
		internal bool IsDefaulted; //used to tell whether the current scope has been created from the default
					  //scope or not - this information is used to tell whether it can be overridden
					  //when a new path is set or not.

		//Fires IdentifierChanged event
		private void FireIdentifierChanged()
		{
			if (IdentifierChanged != null)
				IdentifierChanged(this,null);
		}

		//Called when IdentifierChanged() event fires
		private void HandleIdentifierChange(object sender,
							IdentifierChangedEventArgs args)
		{
			// Since our object has changed we had better signal to ourself that
			// an connection needs to be established
			wbemServices = null;

			//Something inside ManagementScope changed, we need to fire an event
			//to the parent object
			FireIdentifierChanged();
		}

		internal IWbemServices GetIWbemServices () {
			return wbemServices;
		}

		/// <summary>
		///    Indicates whether this scope is currently bound to a WMI
		///    server &amp; namespace.
		/// </summary>
		/// <value>
		///    True if a connection is alive, i.e.
		///    the scope object is bound to a particular server &amp; WMI namespace, false
		///    otherwise.
		/// </value>
		/// <remarks>
		///    A scope is disconnected after it's been
		///    created until someone explicitly calls Connect() or uses the scope for any
		///    operation that requires a live connection. Also whenever the 'identifying'
		///    properties of the scope are changed, the scope is disconnected from the previous
		///    connection.
		/// </remarks>
		public bool IsConnected  {
			get { 
				return (null != wbemServices); 
			}
		}

		internal void Secure (IEnumWbemClassObject wbemEnum)
		{
			if (null == securityHelper)
				securityHelper = (IWmiSec)new WmiSec();

			securityHelper.BlessIEnumWbemClassObject(
				ref wbemEnum,
				options.Username,
				options.GetPassword (),
				options.Authority,
				(int)options.Impersonation,
				(int)options.Authentication);
		}

		internal void Secure (IWbemServices wbemServices)
		{
			if (null == securityHelper)
				securityHelper = (IWmiSec)new WmiSec();

			securityHelper.BlessIWbemServices(
				ref wbemServices,
				options.Username,
				options.GetPassword (),
				options.Authority,
				(int)options.Impersonation,
				(int)options.Authentication);
		}

		internal void Secure (IWbemCallResult wbemCallResult)
		{
			if (null == securityHelper)
				securityHelper = (IWmiSec)new WmiSec();

			securityHelper.BlessIWbemCallResult(
				ref wbemCallResult,
				options.Username,
				options.GetPassword (),
				options.Authority,
				(int)options.Impersonation,
				(int)options.Authentication);
		}

		internal bool SetSecurity (ref IntPtr handle)
		{
			bool needToReset = false;

			if (null == securityHelper)
				securityHelper = (IWmiSec)new WmiSec();

			securityHelper.SetSecurity (ref needToReset, ref handle);
			return needToReset;
		}

		internal void ResetSecurity (IntPtr handle)
		{
			if (null == securityHelper)
				securityHelper = (IWmiSec)new WmiSec();

			securityHelper.ResetSecurity (handle);
		}

		//Internal constructor
		internal ManagementScope (ManagementPath path, IWbemServices wbemServices, 
				IWmiSec securityHelper, ConnectionOptions options)
		{
			if (null != path)
				this.Path = path;

			if (null != options)
				this.Options = options;

			// We set this.wbemServices after setting Path and Options
			// because the latter operations can cause wbemServices to be NULLed.
			this.wbemServices = wbemServices;
			this.securityHelper = securityHelper;
		}

		internal ManagementScope (ManagementPath path, ManagementScope scope)
			: this (path, (null != scope) ? scope.options : null) {}


		//Default constructor
		/// <summary>
		///    Default constructor creates an uninitialized
		///    ManagementScope object.
		/// </summary>
		/// <remarks>
		///    If the object doesn't get any of it's
		///    properties set before it's connected, it will be initialized with default
		///    values, i.e. the local machine and the root\cimv2 namespace.
		/// </remarks>
		/// <example>
		///    ManagementScope s = new ManagementScope();
		/// </example>
		public ManagementScope () : 
			this (new ManagementPath (ManagementPath.DefaultPath.Path)) 
		{
			//Flag that this scope uses the default path
			IsDefaulted = true;
		}

		//Parameterized constructors
		/// <summary>
		///    <para>Creates a new ManagementScope object representing
		///       the specified scope path.</para>
		/// </summary>
		/// <param name='path'>A ManagementPath object representing the path to the server &amp; namespace this scope object represents.</param>
		/// <example>
		///    <para>ManagementScope s = new ManagementScope(new
		///       ManagementPath("\\\\MyServer\\root\\default"));</para>
		/// </example>
		public ManagementScope (ManagementPath path) : this(path, (ConnectionOptions)null) {}
		/// <summary>
		///    <para>Creates a new ManagementScope object representing the specified scope 
		///       path.</para>
		/// </summary>
		/// <param name='path'>String representing the server &amp; namespace path for this scope object.</param>
		/// <example>
		///    <para>ManagementScope s = new ManagementScope("\\\\MyServer\\root\\default");</para>
		/// </example>
		public ManagementScope (string path) : this(new ManagementPath(path), (ConnectionOptions)null) {}
		/// <summary>
		///    <para>Creates a new ManagementScope object representing the specified scope path, 
		///       with the specified options.</para>
		/// </summary>
		/// <param name='path'>A string representing the server &amp; namespace for this scope object.</param>
		/// <param name=' options'>A ConnectionOptions object containing options for the connection</param>
		/// <example>
		///    <para>ConnectionOptions opt = new ConnectionOptions();</para>
		///    <para>opt.Username = "Me";</para>
		///    <para> opt.Password = "MyPassword";</para>
		///    <para> ManagementScope = new
		///       ManagementScope(\\\\MyServer\\root\\default, opt);</para>
		/// </example>
		public ManagementScope (string path, ConnectionOptions options) : this (new ManagementPath(path), options) {}

		/// <summary>
		///    <para>Creates a new ManagementScope object representing the specified scope path, 
		///       with the specified options.</para>
		/// </summary>
		/// <param name='path'>A ManagementPath object containing the path to the server &amp; namespace that this scope represents.</param>
		/// <param name=' options'>A ConnectionOptions object containing options for the connection.</param>
		/// <example>
		///    <para>ConnectionOptions opt = new ConnectionOptions();</para>
		///    <para>opt.Username = "Me";</para>
		///    <para> opt.Password = "MyPassword";</para>
		///    <para> ManagementScope = new ManagementScope(new 
		///       ManagementPath("\\\\MyServer\\root\\default"), opt);</para>
		/// </example>
		public ManagementScope (ManagementPath path, ConnectionOptions options)
		{
			if (null != path)
				Path = path; 
			else
				Path = new ManagementPath ();

			if (null != options)
				Options = options;
			else
				Options = new ConnectionOptions ();

			IsDefaulted = false; //assume that this scope is not initialized by the default path
		}

		/// <summary>
		///    <para>This property specifies options for making the WMI connection</para>
		/// </summary>
		/// <value>
		///    <para>A valid ConnectionOptions object
		///       containing options for the WMI connection</para>
		/// </value>
		/// <example>
		///    <p>ManagementScope s = new ManagementScope("root\\MyApp"); //creates default
		///       options in the Options property</p>
		///    <p>s.Options.EnablePrivileges = true; //sets the system privileges to enabled
		///       for operations that require system privileges.</p>
		/// </example>
		/// <value>
		/// Specify options for making the WMI connection
		/// </value>
		public ConnectionOptions Options {
			get { return options; } 
			set {
				if (null != value)
				{
					ConnectionOptions oldOptions = options;
					options = (ConnectionOptions)value.Clone();

					if (null != oldOptions)
						oldOptions.IdentifierChanged -= new IdentifierChangedEventHandler(HandleIdentifierChange);

					//register for change events in this object
					options.IdentifierChanged += new IdentifierChangedEventHandler(HandleIdentifierChange);
					//the options property has changed so act like we fired the event
					HandleIdentifierChange(this,null);
				}
				else
					throw new ArgumentNullException ();
			}
		}
	
		/// <summary>
		///    The path representing this scope object
		/// </summary>
		/// <value>
		///    A ManagementPath object containing the path to the
		///    server &amp; namespace represented by this scope.
		/// </value>
		/// <remarks>
		///    <p>ManagementScope s = new ManagementScope();</p>
		///    <p>s.Path = new ManagementPath("root\\MyApp");</p>
		/// </remarks>
		public ManagementPath Path { 
			get { return path; } 
			set {
				if (null != value)
				{
					ManagementPath oldPath = path;
					path = (ManagementPath)value.Clone();
					IsDefaulted = false; //someone is specifically setting the scope path so it's not defaulted any more

					if (null != oldPath)
						oldPath.IdentifierChanged -= new IdentifierChangedEventHandler(HandleIdentifierChange);

					//register for change events in this object
					path.IdentifierChanged += new IdentifierChangedEventHandler(HandleIdentifierChange);
					//the path property has changed so act like we fired the event
					HandleIdentifierChange(this,null);
				}
				else
					throw new ArgumentNullException ();
			}
		}

		/// <summary>
		///    <para>Clone a copy of this object</para>
		/// </summary>
		/// <returns>
		///    A new copy of this ManagementScope
		///    object.
		/// </returns>
		public ManagementScope Clone()
		{
			return new ManagementScope (path, wbemServices, securityHelper, options);
		}

		/// <summary>
		///    <para>Clone a copy of this object</para>
		/// </summary>
		/// <returns>
		///    A new copy of this object.
		///    object.
		/// </returns>
		Object ICloneable.Clone()
		{
			return Clone();
		}

		/// <summary>
		///    <para>Connects this ManagementScope object to the actual WMI
		///       scope.</para>
		/// </summary>
		/// <remarks>
		///    <para>This method is called implicitly when the
		///       scope is used in an operation that requires it to be connected. Calling it
		///       explicitly allows the user to control the time of connection.</para>
		/// </remarks>
		/// <example>
		///    <p>ManagementScope s = new ManagementScope("root\\MyApp");</p>
		///    <p>s.Connect(); //connects the scope to the WMI namespace.</p>
		///    <p>ManagementObject o = new ManagementObject(s, "Win32_LogicalDisk='C:'",
		///       null); //doesn't do any implicit connections because s is already
		///       connected.</p>
		/// </example>
		public void Connect ()
		{
			Initialize ();
		}

		internal void Initialize ()
		{
			//If the path is not set yet we can't do it
			if (null == path)
				throw new InvalidOperationException();

			/*
			 * If we're not connected yet, this is the time to do it... We lock
			 * the state to prevent 2 threads simultaneously doing the same
			 * connection. To avoid taking the lock unnecessarily we examine
			 * isConnected first
			 */ 
			if (!IsConnected)
			{
				lock (this)
				{
					if (!IsConnected)
					{
						IWbemLocator loc = (IWbemLocator) new WbemLocator();
						
						if (null == options)
							Options = new ConnectionOptions ();

						string nsPath = path.NamespacePath;

						// If no namespace specified, fill in the default one
						if ((null == nsPath) || (0 == nsPath.Length))
						{
							// NB: we use a special method to set the namespace
							// path here as we do NOT want to trigger an
							// IdentifierChanged event as a result of this set
						
							path.SetNamespacePath(ManagementPath.DefaultPath.Path);
						}

						// If we have privileges to enable, now is the time
						SecurityHandler securityHandler = GetSecurityHandler ();
						
						int status = (int)ManagementStatus.NoError;

						try {
							status = loc.ConnectServer_(
								path.NamespacePath,
								options.Username, 
								options.GetPassword (), 
								options.Locale, 
								options.Flags, 
								options.Authority, 
								options.GetContext(), 
								out wbemServices);

							//Set security on services pointer
							Secure (wbemServices);
						} catch (Exception e) {
							// BUGBUG : securityHandler.Reset()?
							ManagementException.ThrowWithExtendedInfo (e);
						} finally {
							securityHandler.Reset ();
						}

						if ((status & 0xfffff000) == 0x80041000)
						{
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
						}
						else if ((status & 0x80000000) != 0)
						{
							Marshal.ThrowExceptionForHR(status);
						}
					}
				}
			}
		}

		internal SecurityHandler GetSecurityHandler ()
		{
			return new SecurityHandler (this);
		}
	}//ManagementScope	

	internal class SecurityHandler 
	{
		private bool needToReset = false;
		private IntPtr handle;
		private ManagementScope scope;

		internal SecurityHandler (ManagementScope theScope) {
			this.scope = theScope;

			if (null != scope)
			{
				if (scope.Options.EnablePrivileges)
				{
					try {
						needToReset = scope.SetSecurity (ref handle);
					} catch {}
				}
			}
		}

		internal void Reset ()
		{
			if (needToReset)
			{
				needToReset = false;
				
				if (null != scope)
				{
					try {
						scope.ResetSecurity (handle);
					} catch {}
				}
			}
		}

		internal void Secure (IWbemServices services)
		{
			if (null != scope)
				scope.Secure (services);
		}
		
		internal void Secure (IEnumWbemClassObject enumWbem)
		{
			if (null != scope)
				scope.Secure (enumWbem);
		}

		internal void Secure (IWbemCallResult callResult)
		{
			if (null != scope)
				scope.Secure (callResult);
		}

	} //SecurityHandler	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\methodset.cs ===
using System;
using System.Collections;
using System.Runtime.InteropServices;
using WbemClient_v1;

namespace System.Management
{
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	/// This class represents the set of methods available in this class
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class MethodDataCollection : ICollection, IEnumerable 
	{
		private ManagementObject parent;

		private class enumLock {} //used to lock usage of BeginMethodEnum/NextMethod

		internal MethodDataCollection(ManagementObject parent) : base()
		{
			this.parent = parent;
		}

		//
		//ICollection
		//

		/// <value>
		///  The number of objects in the collection
		/// </value>
		public int Count {
			get {
				int i = 0;
				IWbemClassObjectFreeThreaded inParams = null, outParams = null;
				string methodName = null;
				int status = (int)ManagementStatus.Failed;

				lock(typeof(enumLock))
				{
					try 
					{
						status = parent.wbemObject.BeginMethodEnumeration_(0);

						if ((status & 0x80000000) == 0)
						{
							status = parent.wbemObject.NextMethod_(0, out methodName, out inParams, out outParams);

							while (methodName != null && (status & 0x80000000) == 0)
							{
								i++;
								methodName = null; inParams = null; outParams = null;
								status = parent.wbemObject.NextMethod_(0, out methodName, out inParams, out outParams);
							}
							parent.wbemObject.EndMethodEnumeration_();	// Ignore status.
						}
					} 
					catch (Exception e) 
					{
						ManagementException.ThrowWithExtendedInfo(e);
					}
				} // lock

				if ((status & 0xfffff000) == 0x80041000)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				}
				else if ((status & 0x80000000) != 0)
				{
					Marshal.ThrowExceptionForHR(status);
				}

				return i;
			}
		}

		/// <value>
		/// Whether the object is synchronized
		/// </value>
 		public bool IsSynchronized { get { return false; } }

		/// <value>
		/// Object to be used for synchronization
		/// </value>
 		public object SyncRoot { get { return this; } }

		/// <summary>
		///    <para>ICollection method to copy collection into an array</para>
		/// </summary>
		/// <param name='array'>Array to copy to </param>
		/// <param name='index'>Index to start from </param>
		public void CopyTo(Array array, int index)
		{
			//Use an enumerator to get the MethodData objects and attach them into the target array
			foreach (MethodData m in this)
				array.SetValue(m, index++);
		}

		/// <summary>
		///    Copies the methods collection to a specialized MethodData
		///    objects array.
		/// </summary>
		/// <param name='methodArray'>The destination array to copy the MethodData objects to.</param>
		/// <param name=' index'>The index in the destination array from which to start the copy.</param>
		public void CopyTo(MethodData[] methodArray, int index)
		{
			CopyTo((Array)methodArray, index);
		}

		//
		// IEnumerable
		//
		IEnumerator IEnumerable.GetEnumerator()
		{
			return (IEnumerator)(new MethodDataEnumerator(parent));
		}

		/// <summary>
		///    <para>Returns an enumerator for this collection.</para>
		/// </summary>
		/// <remarks>
		///    Each call to this function returns a new
		///    enumerator on the collection. Multiple enumerators can be obtained for the same
		///    methods collection. However, each enumerator takes a snapshot of the collection,
		///    so changes made to the collection after the enumerator was obtained are not
		///    reflected by this enumerator.
		/// </remarks>
		public MethodDataEnumerator GetEnumerator()
		{
				return new MethodDataEnumerator(parent);
		}

		//Enumerator class
		/// <summary>
		///    The enumerator for methods in the methods collection.
		/// </summary>
		public class MethodDataEnumerator : IEnumerator
		{
			private ManagementObject parent;
			private ArrayList methodNames; //can't use simple array because we don't know the size...
			private IEnumerator en;

			//Internal constructor
			//Because WMI doesn't provide a "GetMethodNames" for methods similar to "GetNames" for properties,
			//We have to walk the methods list and cache the names here.
			//We lock to ensure that another thread doesn't interfere in the Begin/Next sequence.
			internal MethodDataEnumerator(ManagementObject parent)
			{
				this.parent = parent;
				methodNames = new ArrayList(); 
				IWbemClassObjectFreeThreaded inP = null, outP = null;
				string tempMethodName = null;
				int status = (int)ManagementStatus.Failed;

				lock(typeof(enumLock))
				{
					try 
					{
						status = parent.wbemObject.BeginMethodEnumeration_(0);

						if ((status & 0x80000000) == 0)
						{
							status = parent.wbemObject.NextMethod_(0, out tempMethodName, out inP, out outP);

							while (tempMethodName != null&& (status & 0x80000000) == 0)
							{
								methodNames.Add(tempMethodName);
								status = parent.wbemObject.NextMethod_(0, out tempMethodName, out inP, out outP);
							}
							parent.wbemObject.EndMethodEnumeration_();	// Ignore status.
						}
					} 
					catch (Exception e) 
					{
						ManagementException.ThrowWithExtendedInfo(e);
					}
					en = methodNames.GetEnumerator();
				}
				
				if ((status & 0xfffff000) == 0x80041000)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				}
				else if ((status & 0x80000000) != 0)
				{
					Marshal.ThrowExceptionForHR(status);
				}
			}
		
			object IEnumerator.Current { get { return (object)this.Current; } }

			/// <summary>
			///    <para>[To be supplied.]</para>
			/// </summary>
			/// <value>
			///    Returns the current method object in
			///    the collection enumeration.
			/// </value>
			public MethodData Current {
				get 
				{ return new MethodData(parent, (string)en.Current);
				}
			}

			/// <summary>
			///    Moves to the next element in the collection enumeration.
			/// </summary>
			public bool MoveNext ()
			{
				return en.MoveNext();			
			}

			/// <summary>
			///    <para>Resets the enumerator to the beginning of the collection.</para>
			/// </summary>
			public void Reset()
			{
				en.Reset();
			}
            
		}//MethodDataEnumerator


		//
		//Methods
		//

		/// <summary>
		///    <para>Returns the specified method from this collection.</para>
		/// </summary>
		/// <param name='methodName'>The name of the method who's information we want to get</param>
		public virtual MethodData this[string methodName] {
			get { 
				if (null == methodName)
					throw new ArgumentNullException ("methodName");

				return new MethodData(parent, methodName);
			}
		}
		

		/// <summary>
		///    <para>Removes a method from the methods collection</para>
		/// </summary>
		/// <param name='methodName'>The name of the method to remove from the collection</param>
		/// <remarks>
		///    <para>Removing methods from the methods
		///       collection can only be done on the methods of a class, when the class has no
		///       instances. Any other case will result in an exception.</para>
		/// </remarks>
		public virtual void Remove(string methodName)
		{
			if (parent.GetType() == typeof(ManagementObject)) //can't remove methods from instance
				throw new InvalidOperationException();

			int status = (int)ManagementStatus.Failed;

			try {
				status = parent.wbemObject.DeleteMethod_(methodName);
			} catch (Exception e) {
				ManagementException.ThrowWithExtendedInfo(e);
			}

			if ((status & 0xfffff000) == 0x80041000)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
			}
			else if ((status & 0x80000000) != 0)
			{
				Marshal.ThrowExceptionForHR(status);
			}
		}

		//This variant takes only a method name and assumes a void method with no in/out parameters
		/// <overload>
		///    <para>Add a method to the
		///       methods collection</para>
		/// </overload>
		/// <summary>
		///    <para>Adds a method to the methods collection. This overload will
		///       add a new method with no parameters to the collection.</para>
		/// </summary>
		/// <param name='methodName'>The name of the method to add</param>
		/// <remarks>
		///    <para>Adding methods to the methods collection can only be done on the methods of a 
		///       class, when the class has no instances. Any other case will result in an
		///       exception.</para>
		/// </remarks>
		public virtual void Add(string methodName)
		{
			Add(methodName, null, null);
		}



		//This variant takes the full information, i.e. the method name and in & out param objects
		/// <summary>
		///    <para>Adds a method to the methods collection. This overload 
		///       will add a new method with the specified InParameters and OutParameters objects
		///       to the collection.</para>
		/// </summary>
		/// <param name='methodName'>The name of the method to add</param>
		/// <param name=' inParams'>The object holding the input parameters to the method</param>
		/// <param name=' outParams'>The object holding the output parameters to the method</param>
		/// <remarks>
		///    <para>Adding methods to the methods collection can only be done on the methods of a 
		///       class, when the class has no instances. Any other case will result in an
		///       exception.</para>
		/// </remarks>
		public virtual void Add(string methodName, ManagementBaseObject inParams, ManagementBaseObject outParams)
		{
			IWbemClassObjectFreeThreaded wbemIn = null, wbemOut = null;

			if (parent.GetType() == typeof(ManagementObject)) //can't add methods to instance
				throw new InvalidOperationException();

			if (inParams != null)
				wbemIn = inParams.wbemObject;
			if (outParams != null)
				wbemOut = outParams.wbemObject;

			int status = (int)ManagementStatus.Failed;

			try {
				status = parent.wbemObject.PutMethod_(methodName, 0, wbemIn, wbemOut);
			} catch (Exception e) {
				ManagementException.ThrowWithExtendedInfo(e);
			}

			if ((status & 0xfffff000) == 0x80041000)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
			}
			else if ((status & 0x80000000) != 0)
			{
				Marshal.ThrowExceptionForHR(status);
			}
		}

	}//MethodDataCollection
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\managementoptions.cs ===
using System;
using System.Diagnostics;
using System.Text;
using System.Collections;
using System.ComponentModel;

using System.Security.Cryptography;
using WbemClient_v1;


namespace System.Management
{
	/// <summary>
	///    <para>Authentication level to be used to connect to WMI. This is used for the DCOM connection to WMI.</para>
	/// </summary>
	public enum AuthenticationLevel { 
		/// <summary>
		///    <para>Default DCOM authentication - WMI uses the default Windows Authentication setting.</para>
		/// </summary>
		Default=0, 
		/// <summary>
		///    <para>Use no DCOM authentication.</para>
		/// </summary>
		None=1, 
		/// <summary>
		///    <para> Connect-level DCOM authentication.</para>
		/// </summary>
		Connect=2, 
		/// <summary>
		///    <para> Call-level DCOM authentication</para>
		/// </summary>
		Call=3, 
		/// <summary>
		///    <para> Packet-level DCOM authentication</para>
		/// </summary>
		Packet=4, 
		/// <summary>
		///    <para>Packet Integrity-level DCOM authentication</para>
		/// </summary>
		PacketIntegrity=5,
		/// <summary>
		///    <para>Packet privacy-level DCOM authentication</para>
		/// </summary>
		PacketPrivacy=6,
		/// <summary>
		///    <para>Authentication level should remain as it was before.</para>
		/// </summary>
		Unchanged=-1
	}

	/// <summary>
	/// Impersonation level to be used to connect to WMI.
	/// </summary>
	public enum ImpersonationLevel { 
		/// <summary>
		///    <para>Default impersonation.</para>
		/// </summary>
		Default=0,
		/// <summary>
		///    <para>Anonymous DCOM impersonation level. This hides the 
		///       identity of the caller. Calls to WMI may fail
		///       with this impersonation level.</para>
		/// </summary>
		Anonymous=1, 
		/// <summary>
		///    <para>Identify-level DCOM impersonation level. Allows objects 
		///       to query the credentials of the caller. Calls to
		///       WMI may fail with this impersonation level.</para>
		/// </summary>
		Identify=2, 
		/// <summary>
		///    <para>Impersonate-level DCOM impersonation level. Allows 
		///       objects to use the credentials of the caller. This is the recommended impersonation level for WMI calls.</para>
		/// </summary>
		Impersonate=3, 
		/// <summary>
		///    Delegate-level DCOM impersonation level. Allows objects
		///    to permit other objects to use the credentials of the caller. This
		///    impersonation, which will work with WMI calls but may constitute an unnecessary
		///    security risk, is supported only under Windows 2000.
		/// </summary>
		Delegate=4 
	}
	
	/// <summary>
	/// Possible allowed effects of saving an object to WMI when using
	/// ManagementObject.Put
	/// </summary>
	public enum PutType { 
		/// <summary>
		///    Only update an object if it already exists, but do not
		///    create a new one if it doesn't.
		/// </summary>
		UpdateOnly=1, 
		/// <summary>
		///    Only create an object if it doesn't exist, but do not
		///    update it if it already exists.
		/// </summary>
		CreateOnly=2, 
		/// <summary>
		///    Save the object in any case, whether
		///    updating an existing one or creating a new one.
		/// </summary>
		UpdateOrCreate=3 
	}

	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	/// This class is a base class for all Options objects
	/// This class is not publicly instantiatable on it's own (essentially it's abstract)
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	[TypeConverter(typeof(ExpandableObjectConverter))]
	abstract public class ManagementOptions : ICloneable
	{
		/// <summary>
		///    Used to specify an infinite timeout.
		/// </summary>
		public static readonly TimeSpan InfiniteTimeout = TimeSpan.MaxValue;

		private int flags;
		private ManagementNamedValueCollection context;
		private TimeSpan timeout;

		//Used when any public property on this object is changed, to signal
		//to the containing object that it needs to be refreshed.
		internal event IdentifierChangedEventHandler IdentifierChanged;

		//Fires IdentifierChanged event
		internal void FireIdentifierChanged()
		{
			if (IdentifierChanged != null)
				IdentifierChanged(this, null);
		}

		//Called when IdentifierChanged() event fires
		private void HandleIdentifierChange(object sender,
							IdentifierChangedEventArgs args)
		{
			//Something inside ManagementOptions changed, we need to fire an event
			//to the parent object
			FireIdentifierChanged();
		}
		
		internal int Flags {
			get { return flags; }
			set { flags = value; }
		}

		/// <summary>
		///    Represents a WMI context object. This is a name-value
		///    pairs list that can be passed through to a WMI provider that supports
		///    context information for customized operation.
		/// </summary>
		public ManagementNamedValueCollection Context {
			get { return context; }
			set { 
				ManagementNamedValueCollection oldContext = context;

				if (null != value)
					context = (ManagementNamedValueCollection) value.Clone();
				else
					context = new ManagementNamedValueCollection ();

				if (null != oldContext)
					oldContext.IdentifierChanged -= new IdentifierChangedEventHandler(HandleIdentifierChange);

				//register for change events in this object
				context.IdentifierChanged += new IdentifierChangedEventHandler(HandleIdentifierChange);

				//the context property has changed so act like we fired the event
				HandleIdentifierChange(this,null);
			}
		}

		/// <summary>
		///    <para>Indicates the timeout to apply to the operation. 
		///    Note : in the case of operations that return collections, 
		///       this timeout applies to the enumeration through the resulting collection,
		///       not the operation itself (the ReturnImmediately property is used for the latter).</para>
		///       This property is used to indicate that the operation should be performed semi-synchronously.
		/// </summary>
		/// <value>
		///    The default value for this property is
		///    ManagementOptions.InfiniteTimeout, which means the operation will block.
		///    The value specified must be positive.
		/// </value>
		public TimeSpan Timeout 
		{
			get 
			{ return timeout; }
			set 
			{ 
				//Timespan allows for negative values, but we want to make sure it's positive here...
				if (value.Ticks < 0)
					throw new ArgumentOutOfRangeException();

				timeout = value;
				FireIdentifierChanged();
			}
		}


		internal ManagementOptions() : this(null, InfiniteTimeout) {}
		internal ManagementOptions(ManagementNamedValueCollection context, TimeSpan timeout) : this(context, timeout, 0) {}
		internal ManagementOptions(ManagementNamedValueCollection context, TimeSpan timeout, int flags)
		{
			this.flags = flags;
			this.Context = context;
			this.Timeout = timeout;
		}


		internal IWbemContext GetContext () {
			return context.GetContext ();
		}
		
		// We do not expose this publicly; instead the flag is set automatically
		// when making an async call if we detect that someone has requested to
		// listen for status messages.
		internal bool SendStatus 
		{
			get 
			{ return (((Flags & (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_SEND_STATUS) != 0) ? true : false); }
			set 
			{
				Flags = (value == false) ? (Flags & (int)~tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_SEND_STATUS) : 
					(Flags | (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_SEND_STATUS);
			}
		}

		/// <summary>
		///    Creates a clone of this options object
		/// </summary>
		/// <returns>
		///    The clone.
		/// </returns>
		public abstract object Clone();
	}


	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para>This class is a base class for enumeration-related options.
	///       This class is not publicly instantiatable on it's own (essentially it's abstract)</para>
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class EnumerationOptions : ManagementOptions
	{
		private int blockSize;

		/// <summary>
		///    Specifies whether the invoked operation should be
		///    performed in a synchronous or semi-synchronous fashion. If this property is set
		///    to true, the enumeration is invoked and the call returns immediately. The actual
		///    retrieval of the results will occur when the resulting collection is walked.
		/// </summary>
		/// <value>
		///    The default value is True.
		/// </value>
		public bool ReturnImmediately {
			get { return (((Flags & (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_RETURN_IMMEDIATELY) != 0) ? true : false); }
			set {
				Flags = (value == false) ? (Flags & (int)~tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_RETURN_IMMEDIATELY) : 
							(Flags | (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_RETURN_IMMEDIATELY);
			}
		}

		/// <summary>
		///    Specifies the block size for block-operations. This
		///    value is used when enumerating through a collection, WMI will return results in
		///    groups of the specified size.
		/// </summary>
		/// <value>
		///    Default value is 1.
		/// </value>
		public int BlockSize {
			get { return blockSize; }
			set { 
				blockSize = value;
			}
		}

		/// <summary>
		///    If true, the collection is assumed to be rewindable,
		///    which means the objects in the collection will be kept available for multiple
		///    enumerations. If false, the collection is assumed to be non-rewindable, meaning
		///    it can only be enumerated once.
		/// </summary>
		/// <value>
		///    The default value is True.
		/// </value>
		/// <remarks>
		///    <para>A rewindable collection will be more costly
		///       in memory consumption as all the objects need to be kept available at once.
		///       If defined as non-rewindable, the objects are discarded after being returned once
		///       in the enumeration.</para>
		/// </remarks>
		public bool Rewindable {
			get { return (((Flags & (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_FORWARD_ONLY) != 0) ? false : true); }
			set { 
				Flags = (value == true) ? (Flags & (int)~tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_FORWARD_ONLY) : 
											(Flags | (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_FORWARD_ONLY);
			}
		}	

		/// <summary>
		///    Specifies whether the objects returned from WMI should
		///    contain amended information or not. Amended information is typically localizable
		///    information attached to the WMI object, such as object and property
		///    descriptions.
		/// </summary>
		/// <value>
		///    The default value is false.
		/// </value>
		/// <remarks>
		///    <para>If descriptions and other amended
		///       information are not of interest, setting this property to false is more
		///       efficient.</para>
		/// </remarks>
		public bool UseAmendedQualifiers {
			get { return (((Flags & (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_USE_AMENDED_QUALIFIERS) != 0) ? true : false); }
			set { 
				Flags = (value == true) ? (Flags | (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_USE_AMENDED_QUALIFIERS) :
											(Flags & (int)~tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_USE_AMENDED_QUALIFIERS); 
			}
		}

		/// <summary>
		///    This flag ensures that any returned objects have enough
		///    information in them so that the system properties, such as
		/// <see langword='__PATH'/>, <see langword='__RELPATH'/>, and 
		/// <see langword='__SERVER'/>, are non-NULL. This flag can only be used in queries,
		/// and is ignored in enumerations.
		/// </summary>
		/// <value>
		///    Default value is False.
		/// </value>
		public bool EnsureLocatable 
		{
			get 
			{ return (((Flags & (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_ENSURE_LOCATABLE) != 0) ? true : false); }
			set 
			{ Flags = (value == true) ? (Flags | (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_ENSURE_LOCATABLE) :
					  (Flags & (int)~tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_ENSURE_LOCATABLE) ; }
		}


		/// <summary>
		///    This flag is used for prototyping. It does not execute
		///    the query and instead returns an object that looks like a typical result object.
		///    This flag can only be used in queries, and is ignored in enumerations.
		/// </summary>
		/// <value>
		///    Default value is False.
		/// </value>
		public bool PrototypeOnly 
		{
			get 
			{ return (((Flags & (int)tag_WBEM_QUERY_FLAG_TYPE.WBEM_FLAG_PROTOTYPE) != 0) ? true : false); }
			set 
			{ Flags = (value == true) ? (Flags | (int)tag_WBEM_QUERY_FLAG_TYPE.WBEM_FLAG_PROTOTYPE) :
					  (Flags & (int)~tag_WBEM_QUERY_FLAG_TYPE.WBEM_FLAG_PROTOTYPE) ; }
		}

		/// <summary>
		///    This flag causes direct access to the provider for the
		///    class specified without any regard to its superclass or subclasses.
		///    This flag can only be used in queries and is ignored in enumerations.
		/// </summary>
		/// <value>
		///    Default value is False.
		/// </value>
		public bool DirectRead 
		{
			get 
			{ return (((Flags & (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_DIRECT_READ) != 0) ? true : false); }
			set 
			{ Flags = (value == true) ? (Flags | (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_DIRECT_READ) :
					  (Flags & (int)~tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_DIRECT_READ) ; }
		}

		
		/// <summary>
		///    If True, requests recursive enumeration into all
		///    subclasses derived from the specified superclass. Otherwise only immediate
		///    subclass members are returned. This flag can only be used in enumerations and is ignored in queries.
		/// </summary>
		/// <value>
		///    Default value is False.
		/// </value>
		public bool EnumerateDeep 
		{
			get 
			{ return (((Flags & (int)tag_WBEM_QUERY_FLAG_TYPE.WBEM_FLAG_SHALLOW) != 0) ? false : true); }
			set 
			{ Flags = (value == false) ? (Flags | (int)tag_WBEM_QUERY_FLAG_TYPE.WBEM_FLAG_SHALLOW) :
					  (Flags & (int)~tag_WBEM_QUERY_FLAG_TYPE.WBEM_FLAG_SHALLOW); }
		}

		
		//default constructor
		/// <summary>
		///    <para>Default constructor for a query or enumeration options object. Creates 
		///       the options object with default values (see the individual property descriptions
		///       for what the default values are).</para>
		/// </summary>
		public EnumerationOptions() : this (null, InfiniteTimeout, 1, true, true, false, false, false, false, false) {}
		

		
		//Constructor that specifies flags as individual values - we need to set the flags acordingly !
		/// <summary>
		///    <para>Constructs an options object to be used for queries or enumerations, 
		///       allowing the user to specify values for the different options.</para>
		/// </summary>
		/// <param name='context'>Options context object containing provider-specific information that can be passed through to the provider.</param>
		/// <param name=' timeout'>The timeout value for enumerating through the results.</param>
		/// <param name=' blockSize'>The number of items to retrieve at once from WMI.</param>
		/// <param name=' rewindable'>Specifies whether the result set is rewindable (=allows multiple traversal or one-time).</param>
		/// <param name=' returnImmediately'>Specifies whether the operation should return immediately (semi-sync) as opposed to blocking until all the results are available.</param>
		/// <param name=' useAmendedQualifiers'>Specifies whether the returned objects should contain amended (locale-aware) qualifiers.</param>
		/// <param name=' ensureLocatable'>Specifies to WMI that it should ensure all returned objects have valid paths.</param>
		/// <param name=' prototypeOnly'>Causes the query to return a prototype of the result set instead of the actual results.</param>
		/// <param name=' directRead'>Defines whether to retrieve objects of the specifies class only or from derived classes as well.</param>
 		/// <param name=' enumerateDeep'>Specifies recursive enumeration in subclasses.</param>
		public EnumerationOptions(
			ManagementNamedValueCollection context, 
			TimeSpan timeout, 
			int blockSize,
			bool rewindable,
			bool returnImmediatley,
			bool useAmendedQualifiers,
			bool ensureLocatable,
			bool prototypeOnly,
			bool directRead,
			bool enumerateDeep) : base(context, timeout)
		{
			BlockSize = blockSize;
			Rewindable = rewindable;
			ReturnImmediately = returnImmediatley;
			UseAmendedQualifiers = useAmendedQualifiers;
			EnsureLocatable = ensureLocatable;
			PrototypeOnly = prototypeOnly;
			DirectRead = directRead;
			EnumerateDeep = enumerateDeep;
		}

		/// <summary>
		///    <para>Creates a copy of this options object.</para>
		/// </summary>
		/// <returns>
		///    The clone.
		/// </returns>
		public override object Clone ()
		{
			ManagementNamedValueCollection newContext = null;

			if (null != Context)
				newContext = (ManagementNamedValueCollection)Context.Clone();

			return new EnumerationOptions (newContext, Timeout, blockSize, Rewindable,
							ReturnImmediately, UseAmendedQualifiers, EnsureLocatable, PrototypeOnly, DirectRead, EnumerateDeep);
		}
		
	}//EnumerationOptions



	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	/// This class is used in the Event Watcher to specify options
	/// for watching for events
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class EventWatcherOptions : ManagementOptions
	{
		private int blockSize = 1;
		
		/// <summary>
		///    Specifies the block size for block-operations. When waiting for events, this
		///    value specifies how many events to wait for before returning.
		/// </summary>
		/// <value>
		///    Default value is 1.
		/// </value>
		public int BlockSize {
			get { return blockSize; }
			set 
			{ 
				blockSize = value; 
				FireIdentifierChanged ();
			}

		}

		/// <summary>
		///    Default constructor creates a new options object for
		///    event watching with default values.
		/// </summary>
		public EventWatcherOptions() 
			: this (null, InfiniteTimeout, 1) {}
		/// <summary>
		///    <para>Construct an event watcher options object with the given
		///       values.</para>
		/// </summary>
		/// <param name='context'>contains provider-specific information that can be passed through to the provider</param>
		/// <param name=' timeout'>specifies the timeout to wait for the next event(s)</param>
		/// <param name=' blockSize'>specifies the number of events to wait for in each wait.</param>
		public EventWatcherOptions(ManagementNamedValueCollection context, TimeSpan timeout, int blockSize) 
			: base(context, timeout) 
		{
			Flags = (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_RETURN_IMMEDIATELY|(int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_FORWARD_ONLY;
			BlockSize = blockSize;
		}

		/// <summary>
		///    Creates a copy of this options object.
		/// </summary>
		public override object Clone () {
			ManagementNamedValueCollection newContext = null;

			if (null != Context)
				newContext = (ManagementNamedValueCollection)Context.Clone();

			return new EventWatcherOptions (newContext, Timeout, blockSize);
		}
	}//EventWatcherOptions



	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	/// This class is used to specify options for getting a WMI object
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class ObjectGetOptions : ManagementOptions
	{
		/// <summary>
		///    <para>Specifies whether the objects returned from WMI should contain amended
		///       information or not. Amended information is typically localizable information
		///       attached to the WMI object, such as object and property descriptions.</para>
		/// </summary>
		/// <value>
		///    Default value is FALSE.
		/// </value>
		public bool UseAmendedQualifiers {
			get { return (((Flags & (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_USE_AMENDED_QUALIFIERS) != 0) ? true : false); }
			set { 
				Flags = (value == true) ? (Flags | (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_USE_AMENDED_QUALIFIERS) :
											(Flags & (int)~tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_USE_AMENDED_QUALIFIERS); 
				FireIdentifierChanged();
			}
		}

		/// <summary>
		///    Default constructor creates an options object for
		///    getting a WMI object, using default values.
		/// </summary>
		public ObjectGetOptions() : this(null, InfiniteTimeout, false) {}
		/// <summary>
		///    <para>[To be supplied.]</para>
		/// </summary>
		public ObjectGetOptions(ManagementNamedValueCollection context) : this(context, InfiniteTimeout, true) {}
		/// <summary>
		///    Constructs an options object for getting a WMI object,
		///    using the given options values.
		/// </summary>
		/// <param name='context'>A provider-specific named-value pairs object that can be passed through to the provider</param>
		/// <param name=' timeout'>If this is not InfiniteTimeout, it specifies how long to let the operation perform before it times out.
		/// Setting this parameter will invoke the operation semi-synchronously.</param>
		/// <param name=' useAmendedQualifiers'>Specifies whether to return amended qualifiers with the object.</param>
		public ObjectGetOptions(ManagementNamedValueCollection context, TimeSpan timeout, bool useAmendedQualifiers) : base(context, timeout)
		{
			UseAmendedQualifiers = useAmendedQualifiers;
		}

		/// <summary>
		///    Creates a copy of this options object.
		/// </summary>
		public override object Clone () {
			ManagementNamedValueCollection newContext = null;

			if (null != Context)
				newContext = (ManagementNamedValueCollection)Context.Clone();

			return new ObjectGetOptions (newContext, Timeout, UseAmendedQualifiers);
		}

	}

	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    This class is used to specify options for committing
	///    object changes.
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class PutOptions : ManagementOptions
	{

		/// <summary>
		///    <para>Specifies whether the objects returned from WMI should contain amended
		///       information or not. Amended information is typically localizable information
		///       attached to the WMI object, such as object and property descriptions.</para>
		/// </summary>
		/// <value>
		///    Default value is FALSE.
		/// </value>
		public bool UseAmendedQualifiers {
			get { return (((Flags & (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_USE_AMENDED_QUALIFIERS) != 0) ? true : false); }
			set { Flags = (value == true) ? (Flags | (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_USE_AMENDED_QUALIFIERS) :
											(Flags & (int)~tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_USE_AMENDED_QUALIFIERS); }
		}

		/// <summary>
		///    <para>Specifies the type of commit to be performed for this object.</para>
		/// </summary>
		/// <value>
		///    Default value is
		///    PutType.UpdateOrCreate.
		/// </value>
		public PutType Type {
			get { return (((Flags & (int)tag_WBEM_CHANGE_FLAG_TYPE.WBEM_FLAG_UPDATE_ONLY) != 0) ? PutType.UpdateOnly :
						  ((Flags & (int)tag_WBEM_CHANGE_FLAG_TYPE.WBEM_FLAG_CREATE_ONLY) != 0) ? PutType.CreateOnly : 
																				PutType.UpdateOrCreate);
			}
			set { 
				switch (value)
				{
					case PutType.UpdateOnly : Flags |= (int)tag_WBEM_CHANGE_FLAG_TYPE.WBEM_FLAG_UPDATE_ONLY; break;
					case PutType.CreateOnly : Flags |= (int)tag_WBEM_CHANGE_FLAG_TYPE.WBEM_FLAG_CREATE_ONLY; break;
					case PutType.UpdateOrCreate : Flags |= (int)tag_WBEM_CHANGE_FLAG_TYPE.WBEM_FLAG_CREATE_OR_UPDATE; break;
					default : throw new ArgumentException();
				}
			}
		}

		/// <summary>
		///    Default constructor creates a new options object for a
		///    Put operations with default values.
		/// </summary>
		public PutOptions() : this(null, InfiniteTimeout, false, PutType.UpdateOrCreate) {}
		/// <summary>
		///    <para>[To be supplied.]</para>
		/// </summary>
		public PutOptions(ManagementNamedValueCollection context) : this(context, InfiniteTimeout, true, PutType.UpdateOrCreate) {}
		/// <summary>
		///    <para>Creates a new options object for a Put operation with
		///       the specified option values.</para>
		/// </summary>
		/// <param name='context'>Provider-specific named value pairs to be passed through to the provider</param>
		/// <param name=' timeout'>If this is not InfiniteTimeout, it specifies how long to let the operation perform before it times out.
		/// Setting this parameter will invoke the operation semi-synchronously.</param>
		/// <param name=' useAmendedQualifiers'>Specifies whether the object to be committed contains amended qualifiers or not.</param>
		/// <param name=' putType'>Specifies the type of Put to be performed (update, create etc.)</param>
		public PutOptions(ManagementNamedValueCollection context, TimeSpan timeout, bool useAmendedQualifiers, PutType putType) : base(context, timeout)
		{
			UseAmendedQualifiers = useAmendedQualifiers;
			Type = putType;
		}

		/// <summary>
		///    Creates a copy of this options object.
		/// </summary>
		public override object Clone () {
			ManagementNamedValueCollection newContext = null;

			if (null != Context)
				newContext = (ManagementNamedValueCollection)Context.Clone();

			return new PutOptions (newContext, Timeout, UseAmendedQualifiers, Type);
		}
	}

	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    This class is used to specify options for deleting an
	///    object
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class DeleteOptions : ManagementOptions
	{
		/// <summary>
		///    <para>Default constructor creates an options object for the
		///       Delete operation with default values.</para>
		/// </summary>
		public DeleteOptions() : base () {}

		/// <summary>
		///    <para>Creates an options object for a Delete operation using
		///       the specified values.</para>
		/// </summary>
		/// <param name='context'>Provider-specific named value pairs object to be passed through to the provider</param>
		/// <param name='timeout'>If this is not InfiniteTimeout, it specifies how long to let the operation perform before it times out.
		/// Setting this parameter will invoke the operation semi-synchronously.</param>
		public DeleteOptions(ManagementNamedValueCollection context, TimeSpan timeout) : base(context, timeout) {}

		/// <summary>
		///    <para>Creates a copy of this options object.</para>
		/// </summary>
		public override object Clone () {
			ManagementNamedValueCollection newContext = null;

			if (null != Context)
				newContext = (ManagementNamedValueCollection)Context.Clone();

			return new DeleteOptions (newContext, Timeout);
		}
	}

	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	/// This class is used to specify options for invoking a WMI method
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class InvokeMethodOptions : ManagementOptions
	{
		/// <summary>
		///    <para>Default constructor creates an options object for the
		///       Delete operation with default values.</para>
		/// </summary>
		public InvokeMethodOptions() : base () {}

		/// <summary>
		///    <para>Creates an options object for a method invokation using 
		///       the specified values.</para>
		/// </summary>
		/// <param name=' context'>Provider-specific named value pairs object to be passed through to the provider</param>
		/// <param name='timeout'>If this is not InfiniteTimeout, it specifies how long to let the operation perform before it times out.
		/// Setting this parameter will invoke the operation semi-synchronously.</param>
		public InvokeMethodOptions(ManagementNamedValueCollection context, TimeSpan timeout) : base(context, timeout) {}

		/// <summary>
		///    <para>Creates a copy of this options object.</para>
		/// </summary>
		public override object Clone () {
			ManagementNamedValueCollection newContext = null;

			if (null != Context)
				newContext = (ManagementNamedValueCollection)Context.Clone();

			return new InvokeMethodOptions (newContext, Timeout);
		}
	}


	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	/// This class holds all settings required to make a WMI connection
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class ConnectionOptions : ManagementOptions
	{
		private class EncryptedData
		{
			private byte[] encryptedData = null;
			private ICryptoTransform decryptor;

			public EncryptedData(string data)
			{
				SetData(data);
			}

			// This encrypts the passed data

			public void SetData(string data)
			{
				if (data != null)
				{
					TripleDESCryptoServiceProvider provider = new TripleDESCryptoServiceProvider();
					ICryptoTransform encryptor = provider.CreateEncryptor();
					decryptor = provider.CreateDecryptor();

					encryptedData = encryptor.TransformFinalBlock(ToBytes(data), 0, (data.Length) * 2);
				}
				else
				{
					encryptedData = null;
				}
			}

			// This decrypts the stored string aray and returns it to the user

			public string GetData()
			{
				if (encryptedData != null)
				{
					return ToString(decryptor.TransformFinalBlock(encryptedData, 0, encryptedData.Length));
				}
				else
				{
					return null;
				}
			}

			static byte[] ToBytes(string str)
			{
				Debug.Assert(str != null);
		
				byte [] rg = new Byte[(str.Length) * 2];
				int i = 0;

				foreach(char c in str.ToCharArray())
				{
					rg[i++] = (byte)(c >> 8);
					rg[i++] = (byte)(c & 0x00FF);
				}

				return rg;
			}

			static string ToString(byte[] bytes)
			{
				Debug.Assert(bytes != null);

				int length = bytes.Length / 2;
				StringBuilder sb = new StringBuilder();
				sb.Length = length;

				for (int i = 0; i < length; i++)
				{
					sb[i] = (char)(bytes[i * 2] << 8 | (char)bytes[i * 2 + 1]);
				}

				return sb.ToString();
			}
		}
 
		internal const string DEFAULTLOCALE = null;
		internal const string DEFAULTAUTHORITY = null;
		internal const ImpersonationLevel DEFAULTIMPERSONATION = ImpersonationLevel.Impersonate;
		internal const AuthenticationLevel DEFAULTAUTHENTICATION = AuthenticationLevel.Unchanged;
		internal const bool DEFAULTENABLEPRIVILEGES = false;

		//Fields
		private string locale;
		private string username;
		private EncryptedData password;
		private string authority;
		private ImpersonationLevel impersonation;
		private AuthenticationLevel authentication;
		private bool enablePrivileges;
		

		//
		//Properties
		//

		/// <summary>
		///    <para>The Locale to be used for the operation</para>
		/// </summary>
		/// <value>
		///    <para>The default value is DEFAULTLOCALE.</para>
		/// </value>
		/// <value>
		/// The Locale to be used for the operation
		/// </value>
		public string Locale {
			get { return (null != locale) ? locale : String.Empty; } 
			set { 
				if (locale != value)
				{
					locale = value; 
					FireIdentifierChanged();
				}
			} 
		}

		/// <summary>
		///    <para>The username to be used for the operation</para>
		/// </summary>
		/// <value>
		///    <para>The default value is null, for which the connection will use the currently logged-on user.</para>
		/// </value>
		/// <remarks>
		///    If the user name is from a domain other
		///    than the current domain, the string may contain the domain name and user name,
		///    separated by a backslash:
		///    StrUserName = SysAllocString(L"Domain\\UserName");
		///    The <paramref name="strUser"/> parameter cannot be an empty string.
		/// </remarks>
		/// <value>
		/// The username to be used for the operation
		/// </value>
		public string Username {
			get { return username; } 
			set {
				if (username != value)
				{
					username = value; 
					FireIdentifierChanged();
				}
			} 
		}

		/// <summary>
		///    <para>The password for the specified user</para>
		/// </summary>
		/// <value>
		///    <para>The default value is null. If the username is also null,
		///       the credentials used will be those of the currently logged on user.</para>
		/// </value>
		/// <remarks>
		///    A blank string, "", specifies a valid zero
		///    length password
		/// </remarks>
		/// <value>
		/// The password for the specified user
		/// </value>
		public string Password { 
			set {
				if (password.GetData() != value)
				{
					password.SetData(value);
					FireIdentifierChanged();
				}
			} 
		} 

		/// <summary>
		///    <para>The authority to be used to authenticate the specified user</para>
		/// </summary>
		/// <value>
		///    <para>If not NULL, this parameter can contain the name of the
		///       Windows NT/Windows 2000 domain in which to obtain the user to
		///       authenticate.</para>
		/// </value>
		/// <remarks>
		///    <para>This parameter must be passed as follows:
		///       If it begins with the string "Kerberos:", Kerberos authentication will be used
		///       and this parameter should contain a Kerberos principal name. For example,
		///       Kerberos:&lt;principal name&gt;. If it begins with the string "NTLMDOMAIN:",
		///       NTLM authentication will be used and this parameter should contain a NTLM domain
		///       name. For example, NTLMDOMAIN:&lt;domain name&gt;. If you leave this parameter
		///       blank, NTLM authentication will be used and the NTLM domain of the current user
		///       will be used.</para>
		/// </remarks>
		/// <value>
		/// The authority to be used to authenticate the specified user
		/// </value>
		public string Authority {
			get { return (null != authority) ? authority : String.Empty; } 
			set {
				if (authority != value)
				{
					authority = value; 
					FireIdentifierChanged();
				}
			} 
		}

		/// <summary>
		///    <para>The DCOM impersonation level to be used for this operation</para>
		/// </summary>
		/// <value>
		/// The DCOM impersonation level to be used for this operation
		/// </value>
		public ImpersonationLevel Impersonation {
			get { return impersonation; } 
			set { 
				if (impersonation != value)
				{
					impersonation = value; 
					FireIdentifierChanged();
				}
			} 
		}

		/// <summary>
		///    The DCOM authentication level to be used for this operation
		/// </summary>
		/// <value>
		/// The DCOM authentication level to be used for this operation
		/// </value>
		public AuthenticationLevel Authentication {
			get { return authentication; } 
			set {
				if (authentication != value)
				{
					authentication = value; 
					FireIdentifierChanged();
				}
			} 
		}

		/// <summary>
		///    Indicates whether user privileges need to
		///    be enabled for this operation
		/// </summary>
		/// <value>
		///    Default value is false. This should only be used when
		///    the operation performed requires a certain user privilege to be enabled (e.g.
		///    machine reboot).
		/// </value>
		/// <value>
		/// Indicates whether user privileges need to be enabled for this operation
		/// This should only be used when the operation performed requires a certain user privilege to be 
		/// enabled (e.g. machine reboot).
		/// </value>
		public bool EnablePrivileges {
			get { return enablePrivileges; } 
			set {
				if (enablePrivileges != value)
				{
					enablePrivileges = value; 
					FireIdentifierChanged();
				}
			} 
		}

		//
		//Constructors
		//

		//default
		/// <summary>
		///    <para>Default constructor creates an options object for the Delete operation with 
		///       default values.</para>
		/// </summary>
		public ConnectionOptions () :
			this (DEFAULTLOCALE, null, null, DEFAULTAUTHORITY,
					DEFAULTIMPERSONATION, DEFAULTAUTHENTICATION,
					DEFAULTENABLEPRIVILEGES, null, InfiniteTimeout) {}

		
		//parameterized
		/// <summary>
		///    <para>Constructs a new options object to be used for a WMI
		///       connection with the specified values.</para>
		/// </summary>
		/// <param name='locale'>Indicates the locale to be used for this connection</param>
		/// <param name=' username'>Specifies the user name to be used for the connection. If null the currently logged on user's credentials are used.</param>
		/// <param name=' password'>Specifies the password for the given username. If null the currently logged on user's credentials are used.</param>
		/// <param name=' authority'><para>The authority to be used to authenticate the specified user</para></param>
		/// <param name=' impersonation'>The DCOM impersonation level to be used for this connection</param>
		/// <param name=' authentication'>The DCOM authentication level to be used for this connection</param>
		/// <param name=' enablePrivileges'>Specifies whether to enable special user privileges. This should only be used when performing an operation that requires special NT user privileges.</param>
		/// <param name=' context'>A provider-specific named value pairs object to be passed through to the provider.</param>
		/// <param name=' timeout'>Reserved for future use.</param>
		public ConnectionOptions (string locale,
				string username, string password, string authority,
				ImpersonationLevel impersonation, AuthenticationLevel authentication,
				bool enablePrivileges,
				ManagementNamedValueCollection context, TimeSpan timeout) : base (context, timeout)
		{
			if (locale != null) 
				this.locale = locale;

			this.username = username;
			this.enablePrivileges = enablePrivileges;

			this.password = new EncryptedData(password);

			if (authority != null) 
				this.authority = authority;

			if (impersonation != 0)
				this.impersonation = impersonation;

			if (authentication != 0)
				this.authentication = authentication;
		}

		/// <summary>
		///    Creates a copy of this options object.
		/// </summary>
		public override object Clone ()
		{
			ManagementNamedValueCollection newContext = null;

			if (null != Context)
				newContext = (ManagementNamedValueCollection)Context.Clone();
			
			return new ConnectionOptions (locale, username, GetPassword (),
				authority, impersonation, authentication, enablePrivileges, newContext, Timeout);
		}

		//
		//Methods
		//

		internal string GetPassword()
		{
			return password.GetData();
		}

	}//ConnectionOptions
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\propertyset.cs ===
using System.Collections;
using System.Diagnostics;
using System.Runtime.InteropServices;
using WbemClient_v1;
using System.ComponentModel;

namespace System.Management
{
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para>This class represents the set of properties of a WMI object</para>
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class PropertyDataCollection : ICollection, IEnumerable
	{
		private ManagementBaseObject parent;
		bool isSystem;

		internal PropertyDataCollection(ManagementBaseObject parent, bool isSystem) : base()
		{
			this.parent = parent;
			this.isSystem = isSystem;
		}

		//
		//ICollection
		//

		/// <summary>
		///    <para>The number of objects in the collection</para>
		/// </summary>
		/// <value>
		///  The number of objects in the collection
		/// </value>
		public int Count {
			get {
				string[] propertyNames = null; object qualVal = null;
				int flag;
				if (isSystem)
					flag = (int)tag_WBEM_CONDITION_FLAG_TYPE.WBEM_FLAG_SYSTEM_ONLY;
				else
					flag = (int)tag_WBEM_CONDITION_FLAG_TYPE.WBEM_FLAG_NONSYSTEM_ONLY;

				flag = flag | (int)tag_WBEM_CONDITION_FLAG_TYPE.WBEM_FLAG_ALWAYS;

				int status = parent.wbemObject.GetNames_(null, flag, ref qualVal, out propertyNames);

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				return propertyNames.Length;
			}
		}

 		/// <summary>
 		///    <para>Whether the object is synchronized</para>
 		/// </summary>
		/// <value>
		/// Whether the object is synchronized
		/// </value>
 		public bool IsSynchronized { get { return false; } }

 		/// <summary>
 		///    <para>Object to be used for synchronization</para>
 		/// </summary>
		/// <value>
		/// Object to be used for synchronization
		/// </value>
 		public object SyncRoot { get { return this; } }

		/// <summary>
		/// ICollection method to copy collection into array
		/// </summary>
		/// <param name="array"> Array to copy to </param>
		/// <param name="index"> Index to start from </param>
		public void CopyTo(Array array, Int32 index) 
		{
			if (null == array)
				throw new ArgumentNullException("array");

			if ((index < array.GetLowerBound(0)) || (index > array.GetUpperBound(0)))
				throw new ArgumentOutOfRangeException("index");

			// Get the names of the properties 
			string[] nameArray = null;
			IWbemClassObjectFreeThreaded wbemObject = this.parent.wbemObject;
			object dummy = null;
			int flag = 0;

			if (isSystem)
				flag |= (int)tag_WBEM_CONDITION_FLAG_TYPE.WBEM_FLAG_SYSTEM_ONLY;
			else
				flag |= (int)tag_WBEM_CONDITION_FLAG_TYPE.WBEM_FLAG_NONSYSTEM_ONLY;
				
			flag |= (int)tag_WBEM_CONDITION_FLAG_TYPE.WBEM_FLAG_ALWAYS;
				
			int status = wbemObject.GetNames_(null, flag, ref dummy, out nameArray);

			if (status >= 0)
			{
				if ((index + nameArray.Length) > array.Length)
					throw new ArgumentException("index");

				foreach (string propertyName in nameArray)
					array.SetValue(new PropertyData(parent, propertyName), index++);
			}

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}

			return;
		}

		/// <summary>
		///    Copies the collection to a typed array of PropertyData
		///    objects.
		/// </summary>
		/// <param name='propertyArray'>The destination array to contain the copied PropertyData objects</param>
		/// <param name=' index'>The index in the destination array to start copying from</param>
		public void CopyTo(PropertyData[] propertyArray, Int32 index)
		{
			CopyTo((Array)propertyArray, index);	
		}
		//
		// IEnumerable
		//
		IEnumerator IEnumerable.GetEnumerator()
		{
			return (IEnumerator)(new PropertyDataEnumerator(parent, isSystem));
		}

		/// <summary>
		///    Retrieves the enumerator for this collection
		/// </summary>
		public PropertyDataEnumerator GetEnumerator()
		{
			return new PropertyDataEnumerator(parent, isSystem);
		}

		//Enumerator class
		/// <summary>
		///    <para>The enumerator for the Properties collection</para>
		/// </summary>
		public class PropertyDataEnumerator : IEnumerator
		{
			private ManagementBaseObject parent;
			private string[] propertyNames;
			private int index;

			internal PropertyDataEnumerator(ManagementBaseObject parent, bool isSystem)
			{
				this.parent = parent;
				propertyNames = null; index = -1;
				int flag; object qualVal = null;

				if (isSystem)
					flag = (int)tag_WBEM_CONDITION_FLAG_TYPE.WBEM_FLAG_SYSTEM_ONLY;
				else
					flag = (int)tag_WBEM_CONDITION_FLAG_TYPE.WBEM_FLAG_NONSYSTEM_ONLY;
				flag = flag | (int)tag_WBEM_CONDITION_FLAG_TYPE.WBEM_FLAG_ALWAYS;

				int status = parent.wbemObject.GetNames_(null, flag, ref qualVal, out propertyNames);

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
			}
		
			object IEnumerator.Current { get { return (object)this.Current; } }

			/// <summary>
			///    Returns the current property object in the enumeration
			/// </summary>
			public PropertyData Current {
				get {
					if ((index == -1) || (index == propertyNames.Length))
						throw new InvalidOperationException();
					else
						return new PropertyData(parent, propertyNames[index]);
				}
			}

			/// <summary>
			///    Moves the enumerator to the next property object in the
			///    collection.
			/// </summary>
			public bool MoveNext()
			{
				if (index == propertyNames.Length) //passed the end of the array
					return false; //don't advance the index any more

				index++;
				return (index == propertyNames.Length) ? false : true;
			}

			/// <summary>
			///    Resets the enumerator to the first property object in
			///    the collection.
			/// </summary>
			public void Reset()
			{
				index = -1;
			}
            
		}//PropertyDataEnumerator



		//
		// Methods
		//

		/// <summary>
		///    <para>Indexer accessor, allows access to properties in the 
		///       collection using the [] syntax.</para>
		/// </summary>
		/// <param name='propertyName'>The name of the property we're interested in.</param>
		/// <value>
		///    <para>Returns a PropertyData object based on
		///       the name specified.</para>
		/// </value>
		/// <example>
		///    <p>ManagementObject o = new
		///       ManagementObject("Win32_LogicalDisk.Name='C:'");</p>
		///    <p>Console.WriteLine("Free space on C: drive is: ",
		///       c.Properties["FreeSpace"].Value);</p>
		/// </example>
		public virtual PropertyData this[string propertyName] {
			get { 
				if (null == propertyName)
					throw new ArgumentNullException("propertyName");

				return new PropertyData(parent, propertyName);
            }
		}

		/// <summary>
		///    <para>Removes a property from the properties collection.</para>
		/// </summary>
		/// <param name='propertyName'>Specifies the name of the property to be removed.</param>
		/// <remarks>
		///    <para>Properties can only be removed from class
		///       definitions, not from instances, thus this method is only valid when invoked on
		///       a Properties collection in a ManagementClass.</para>
		/// </remarks>
		/// <example>
		///    <p>ManagementClass c = new ManagementClass("MyClass");</p>
		///    <p>c.Properties.Remove("PropThatIDontWantOnThisClass");</p>
		/// </example>
		public virtual void Remove(string propertyName)
		{
			if (parent.GetType() == typeof(ManagementObject)) //can't remove properties to instance
				throw new InvalidOperationException();

			int status = parent.wbemObject.Delete_(propertyName);

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}
		}

		/// <summary>
		///    <para>Add a new property with the specified value. The value cannot
		///       be null and must be coercible to a CIM type.</para>
		/// </summary>
		/// <param name='propertyName'>The name of the new property</param>
		/// <param name='propertyValue'>The value of the property (cannot be null)</param>
		/// <remarks>
		///    <para>Properties can only be added to class definitions, not to 
		///       instances, thus this method is only valid when invoked on a Properties
		///       collection in a ManagementClass.</para>
		/// </remarks>
		public virtual void Add(string propertyName, Object propertyValue)
		{
			if (null == propertyValue)
				throw new ArgumentNullException("propertyValue");

			if (parent.GetType() == typeof(ManagementObject)) //can't add properties to instance
				throw new InvalidOperationException();

			CimType cimType = 0;
			bool isArray = false;
			object wmiValue = PropertyData.MapValueToWmiValue(propertyValue, out isArray, out cimType);
			int wmiCimType = (int)cimType;

			if (isArray)
				wmiCimType |= (int)tag_CIMTYPE_ENUMERATION.CIM_FLAG_ARRAY;

			int status = parent.wbemObject.Put_(propertyName, 0, ref wmiValue, wmiCimType);

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}
		}

		/// <summary>
		/// Add a new property with the specified value and CIM type.
		/// </summary>
		/// <param name="propertyName">Name of the property</param>
		/// <param name="propertyValue">Value of the property (which can be null)</param>
		/// <param name="propertyType">CIM type of the property</param>
		public void Add(string propertyName, Object propertyValue, CimType propertyType)
		{
			if (null == propertyName)
				throw new ArgumentNullException("propertyName");

			if (parent.GetType() == typeof(ManagementObject)) //can't add properties to instance
				throw new InvalidOperationException();

			int wmiCimType = (int)propertyType;
			bool isArray = false;

			if ((null != propertyValue) && propertyValue.GetType().IsArray)
			{
				isArray = true;
				wmiCimType = (wmiCimType | (int)tag_CIMTYPE_ENUMERATION.CIM_FLAG_ARRAY);
			}

			object wmiValue = PropertyData.MapValueToWmiValue(propertyValue, propertyType, isArray);

			int status = parent.wbemObject.Put_(propertyName, 0, ref wmiValue, wmiCimType);

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}
		}
		
		/// <summary>
		/// Add a new property with no assigned value 
		/// </summary>
		/// <param name="propertyName">Name of the property</param>
		/// <param name="propertyType">CIM type of the property</param>
		/// <param name="isArray">Whether the property is an array type</param>
		public void Add(string propertyName, CimType propertyType, bool isArray)
		{
			if (null == propertyName)
				throw new ArgumentNullException(propertyName);

			if (parent.GetType() == typeof(ManagementObject)) //can't add properties to instance
				throw new InvalidOperationException();

			int wmiCimType = (int)propertyType;  
			
			if (isArray)
				wmiCimType = (wmiCimType | (int)tag_CIMTYPE_ENUMERATION.CIM_FLAG_ARRAY);

			object dummyObj = System.DBNull.Value;

			int status = parent.wbemObject.Put_(propertyName, 0, ref dummyObj, wmiCimType);

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}
		}
		
	}//PropertyDataCollection
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\property.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Runtime.InteropServices;
using WbemClient_v1;

namespace System.Management
{
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	/// This class holds information about a WMI property
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class PropertyData
	{
		private ManagementBaseObject parent;  //need access to IWbemClassObject pointer to be able to refresh property info
									//and get property qualifiers
		private string propertyName;

		private Object propertyValue;
		private int propertyType;
		private int propertyFlavor;
		private QualifierDataCollection qualifiers;

		internal PropertyData(ManagementBaseObject parent, string propName)
		{
			this.parent = parent;
			this.propertyName = propName;
			qualifiers = null;
			RefreshPropertyInfo();
		}

		//This private function is used to refresh the information from the Wmi object before returning the requested data
		private void RefreshPropertyInfo()
		{
			propertyValue = null;	// Needed so we don't leak this in/out parameter...

			int status = parent.wbemObject.Get_(propertyName, 0, ref propertyValue, ref propertyType, ref propertyFlavor);

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}
		}

		/// <summary>
		/// The name of this Property.
		/// </summary>
		public string Name { //doesn't change for this object so we don't need to refresh
			get { return propertyName; }
		}

		/// <summary>
		/// The current value of this Property.
		/// </summary>
		public Object Value {
			get { 
				RefreshPropertyInfo(); 
				return MapWmiValueToValue(propertyValue,
						(CimType)(propertyType & ~(int)tag_CIMTYPE_ENUMERATION.CIM_FLAG_ARRAY),
						(0 != (propertyType & (int)tag_CIMTYPE_ENUMERATION.CIM_FLAG_ARRAY)));
			}
			set {
				RefreshPropertyInfo();

				object newValue = MapValueToWmiValue(value, 
							(CimType)(propertyType & ~(int)tag_CIMTYPE_ENUMERATION.CIM_FLAG_ARRAY),
							(0 != (propertyType & (int)tag_CIMTYPE_ENUMERATION.CIM_FLAG_ARRAY)));

				int status = parent.wbemObject.Put_(propertyName, 0, ref newValue, 0);

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
				//if succeeded and this object has a path, update the path to reflect the new key value
				//NOTE : we could only do this for key properties but since it's not trivial to find out
				//       whether this property is a key or not, we just do it for any property
				else 
					if (parent.GetType() == typeof(ManagementObject))
						((ManagementObject)parent).Path.UpdateRelativePath((string)parent["__RELPATH"]);
				
			}
		}

		/// <summary>
		/// The CIM type of this Property.
		/// </summary>
		public CimType Type {
			get { 
				RefreshPropertyInfo(); 
				return (CimType)(propertyType & ~(int)tag_CIMTYPE_ENUMERATION.CIM_FLAG_ARRAY); 
			}
		}

		/// <summary>
		/// Whether this Property has been modified by the current WMI class.
		/// </summary>
		public bool IsLocal {
			get { 
				RefreshPropertyInfo();
				return ((propertyFlavor & (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_ORIGIN_PROPAGATED) != 0) ? false : true ; }
		}

		/// <summary>
		/// Whether this Property has an array type.
		/// </summary>
		public bool IsArray {
			get { 
				RefreshPropertyInfo();
				return ((propertyType & (int)tag_CIMTYPE_ENUMERATION.CIM_FLAG_ARRAY) != 0);}
		}

		/// <summary>
		/// The name of the WMI class in the heirarchy in which this Property was introduced.
		/// </summary>
		public string Origin {
			get { 
				string className = null;

				int status = parent.wbemObject.GetPropertyOrigin_(propertyName, out className);

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				return className;
			}
		}

		
		/// <summary>
		/// The set of Qualifiers on this Property.
		/// </summary>
		public QualifierDataCollection Qualifiers {
			get {
				if (qualifiers == null)
					qualifiers = new QualifierDataCollection(parent, propertyName, QualifierType.PropertyQualifier);

				return qualifiers;
			}
		}

		/// <summary>
		/// Takes a property value returned from WMI and maps it to an
		/// appropriate managed code representation.
		/// </summary>
		/// <param name="wmiValue"> </param>
		/// <param name="type"> </param>
		/// <param name="isArray"> </param>
		internal static object MapWmiValueToValue(object wmiValue, CimType type, bool isArray)
		{
			object val = null;

			if ((System.DBNull.Value != wmiValue) && (null != wmiValue))
			{
				if (isArray)
				{
					Array wmiValueArray = (Array)wmiValue;
					int length = wmiValueArray.Length;

					switch (type)
					{
						case CimType.UInt16:
							val = new ushort [length];
							
							for (int i = 0; i < length; i++)
								((ushort[])val) [i] = ((IConvertible)((System.Int32)(wmiValueArray.GetValue(i)))).ToUInt16(null);
							break;
							
						case CimType.UInt32:
							val = new uint [length];
							
							for (int i = 0; i < length; i++)
							{
								// ToUint32 will raise an Overflow exception if
								// the top bit of the Int32 is set.
								((uint[])val) [i] = (System.UInt32)((System.Int32)wmiValueArray.GetValue(i));
							}
							break;
						
						case CimType.UInt64:
							val = new ulong [length];
							
							for (int i = 0; i < length; i++)
								((ulong[])val) [i] = ((IConvertible)((System.String)(wmiValueArray.GetValue(i)))).ToUInt64(null);
							break;

						case CimType.SInt8:
							val = new sbyte [length];
							
							for (int i = 0; i < length; i++)
								((sbyte[])val) [i] = ((IConvertible)((System.Int16)(wmiValueArray.GetValue(i)))).ToSByte(null);
							break;

						case CimType.SInt64:
							val = new long [length];
							
							for (int i = 0; i < length; i++)
								((long[])val) [i] = ((IConvertible)((System.String)(wmiValueArray.GetValue(i)))).ToInt64(null);
							break;

						case CimType.Char16:
							val = new char [length];
							
							for (int i = 0; i < length; i++)
								((char[])val) [i] = ((IConvertible)((System.Int16)(wmiValueArray.GetValue(i)))).ToChar(null);
							break;

						case CimType.Object:
							val = new ManagementBaseObject [length];

							for (int i = 0; i < length; i++)
								((ManagementBaseObject[])val) [i] = new ManagementBaseObject(new IWbemClassObjectFreeThreaded(Marshal.GetIUnknownForObject(wmiValueArray.GetValue(i))));
							break;
						
						default:
							val = wmiValue;
							break;
					}
				}
				else
				{
					switch (type)
					{
						case CimType.UInt16:
							val = ((IConvertible)((System.Int32)wmiValue)).ToUInt16(null);
							break;

						case CimType.UInt32:
							// ToUint32 will raise an Overflow exception if
							// the top bit of the Int32 is set.
							val = (System.UInt32)((System.Int32)wmiValue);
							break;
						
						case CimType.UInt64:
							val = ((IConvertible)((System.String)wmiValue)).ToUInt64(null);
							break;

						case CimType.SInt8:
							val = ((IConvertible)((System.Int16)wmiValue)).ToSByte(null);
							break;

						case CimType.SInt64:
							val = ((IConvertible)((System.String)wmiValue)).ToInt64(null);
							break;

						case CimType.Char16:
							val = ((IConvertible)((System.Int16)wmiValue)).ToChar(null);
							break;

						case CimType.Object:
							val = new ManagementBaseObject(new IWbemClassObjectFreeThreaded(Marshal.GetIUnknownForObject(wmiValue)));
							break;
						
						default:
							val = wmiValue;
							break;
					}
				}
			}

			return val; 
		}

		/// <summary>
		/// Takes a managed code value, together with a desired property 
		/// </summary>
		/// <param name="val"> </param>
		/// <param name="type"> </param>
		/// <param name="isArray"> </param>
		internal static object MapValueToWmiValue(object val, CimType type, bool isArray)
		{
			object wmiValue = System.DBNull.Value;

			if (null != val)
			{
				if (isArray)
				{
					Array valArray = (Array)val;
					int length = valArray.Length;

					switch (type)
					{
						case CimType.SInt8:
						case CimType.Char16:
							wmiValue = new short [length];

							for (int i = 0; i < length; i++)
								((short[])(wmiValue))[i] = Convert.ToInt16(valArray.GetValue(i));
							break;

						case CimType.Object:
							if (val is ManagementBaseObject[])
							{
								wmiValue = new IWbemClassObject_DoNotMarshal[length];

								for (int i = 0; i < length; i++)
								{
									((ManagementBaseObject)valArray.GetValue(i)).Initialize();
									((IWbemClassObject_DoNotMarshal[])(wmiValue))[i] = (IWbemClassObject_DoNotMarshal)(Marshal.GetObjectForIUnknown(((ManagementBaseObject)valArray.GetValue(i)).wbemObject));
								}
							}
							else
							{
								Debug.Assert(false, "Unhandled object type");
								wmiValue = val;
							}
							break;

						case CimType.UInt64:
						case CimType.SInt64:
							wmiValue = new string [length];

							for (int i = 0; i < length; i++)
								((string[])(wmiValue))[i] = Convert.ToString(valArray.GetValue(i));
							break;

						case CimType.UInt16:
						case CimType.UInt32:
							wmiValue = new int [length];

							for (int i = 0; i < length; i++)
								((int[])(wmiValue))[i] = Convert.ToInt32(valArray.GetValue(i));
							
							break;

						default:
							wmiValue = val;
							break;
					}
				}
				else
				{
					switch (type)
					{
						case CimType.SInt8:
						case CimType.Char16:
							wmiValue = Convert.ToInt16(val);
							break;

						case CimType.Object:
							if (val is ManagementBaseObject)
							{
								((ManagementBaseObject)val).Initialize();
								wmiValue = Marshal.GetObjectForIUnknown(((ManagementBaseObject) val).wbemObject);
							}
							else
							{
								Debug.Assert(false, "Unhandled object type");
								wmiValue = val;
							}
							break;

						case CimType.UInt64:
						case CimType.SInt64:
							wmiValue = Convert.ToString(val);
							break;

						case CimType.UInt16:
						case CimType.UInt32:
							wmiValue = Convert.ToInt32(val);
							break;

						default:
							wmiValue = val;
							break;
					}
				}
			}

			return wmiValue;
		}

		internal static object MapValueToWmiValue(object val, out bool isArray, out CimType type)
		{
			object wmiValue = System.DBNull.Value;
			isArray = false;
			type = 0;
			
			if (null != val)
			{
				isArray = val.GetType().IsArray;
				Type valueType = val.GetType();

				if (isArray)
				{
					Type elementType = valueType.GetElementType();

					// Casting primitive types to object[] is not allowed
					if (elementType.IsPrimitive)
					{
						if (elementType == typeof(System.Byte))
						{
							byte[] arrayValue = (byte[])val;
							int length = arrayValue.Length;
							type = CimType.UInt8;
							wmiValue = new short[length];

							for (int i = 0; i < length; i++)
								((short[])wmiValue) [i] = ((IConvertible)((System.Byte)(arrayValue[i]))).ToInt16(null);
						}
						else if (elementType == typeof(System.SByte))
						{
							sbyte[] arrayValue = (sbyte[])val;
							int length = arrayValue.Length;
							type = CimType.SInt8;
							wmiValue = new short[length];

							for (int i = 0; i < length; i++)
								((short[])wmiValue) [i] = ((IConvertible)((System.SByte)(arrayValue[i]))).ToInt16(null);
						}
						else if (elementType == typeof(System.Boolean))
						{
							type = CimType.Boolean;
							wmiValue = (bool[])val;
						}					
						else if (elementType == typeof(System.UInt16))
						{
							ushort[] arrayValue = (ushort[])val;
							int length = arrayValue.Length;
							type = CimType.UInt16;
							wmiValue = new int[length];

							for (int i = 0; i < length; i++)
								((int[])wmiValue) [i] = ((IConvertible)((System.UInt16)(arrayValue[i]))).ToInt32(null);
						}
						else if (elementType == typeof(System.Int16))
						{
							type = CimType.SInt16;
							wmiValue = (short[])val;
						}
						else if (elementType == typeof(System.Int32))
						{
							type = CimType.SInt32;
							wmiValue = (int[])val;
						}
						else if (elementType == typeof(System.UInt32))
						{
							uint[] arrayValue = (uint[])val;
							int length = arrayValue.Length;
							type = CimType.UInt32;
							wmiValue = new int[length];

							for (int i = 0; i < length; i++)
								((int[])wmiValue) [i] = ((IConvertible)((System.UInt32)(arrayValue[i]))).ToInt32(null);
						}
						else if (elementType == typeof(System.UInt64))
						{
							ulong[] arrayValue = (ulong[])val;
							int length = arrayValue.Length;
							type = CimType.UInt64;
							wmiValue = new string[length];

							for (int i = 0; i < length; i++)
								((string[])wmiValue) [i] = ((System.UInt64)(arrayValue[i])).ToString();
						}
						else if (elementType == typeof(System.Int64))
						{
							long[] arrayValue = (long[])val;
							int length = arrayValue.Length;
							type = CimType.SInt64;
							wmiValue = new string[length];

							for (int i = 0; i < length; i++)
								((string[])wmiValue) [i] = ((long)(arrayValue[i])).ToString();
						}
						else if (elementType == typeof(System.Single))
						{
							type = CimType.Real32;
							wmiValue = (System.Single[])val;
						}
						else if (elementType == typeof(System.Double))
						{
							type = CimType.Real64;
							wmiValue = (double[])val;
						}
						else if (elementType == typeof(System.Char))
						{
							char[] arrayValue = (char[])val;
							int length = arrayValue.Length;
							type = CimType.Char16;
							wmiValue = new short[length];

							for (int i = 0; i < length; i++)
								((short[])wmiValue) [i] = ((IConvertible)((System.Char)(arrayValue[i]))).ToInt16(null);
						}
					}
					else
					{
						// Non-primitive types
						if (elementType == typeof(System.String))
						{
							type = CimType.String;
							wmiValue = (string[])val;
						}
						else
						{
							// Check for an embedded object array
							if (val is ManagementBaseObject[])
							{
								Array valArray = (Array)val;
								int length = valArray.Length;
								type = CimType.Object;
								wmiValue = new IWbemClassObject_DoNotMarshal[length];

								for (int i = 0; i < length; i++)
								{
									((ManagementBaseObject)valArray.GetValue(i)).Initialize();
									((IWbemClassObject_DoNotMarshal[])(wmiValue))[i] = (IWbemClassObject_DoNotMarshal)(Marshal.GetObjectForIUnknown(((ManagementBaseObject)valArray.GetValue(i)).wbemObject));
								}
							}
							else
								// System.Decimal, System.IntPr, System.UIntPtr, unhandled object, or unknown.
								Debug.Assert(false, "Unhandled type");
						}
					}
				}
				else	// Non-array values
				{
					if (valueType == typeof(System.UInt16))
					{
						type = CimType.UInt16;
						wmiValue = ((IConvertible)((System.UInt16)val)).ToInt32(null);
					}
					else if (valueType == typeof(System.UInt32))
					{
						type = CimType.UInt32;
						wmiValue = ((IConvertible)((System.UInt32)val)).ToInt32(null);
					}
					else if (valueType == typeof(System.UInt64))
					{
						type = CimType.UInt64;
						wmiValue = ((System.UInt64)val).ToString();
					}
					else if (valueType == typeof(System.SByte))
					{
						type = CimType.SInt8;
						wmiValue = ((IConvertible)((System.SByte)val)).ToInt16(null);
					}
					else if (valueType == typeof(System.Byte))
					{
                        type = CimType.UInt8;
						wmiValue = val;
					}
					else if (valueType == typeof(System.Int16))
					{
						type = CimType.SInt16;
						wmiValue = val;
					}
					else if (valueType == typeof(System.Int32))
					{
						type = CimType.SInt32;
						wmiValue = val;
					}
					else if (valueType == typeof(System.Int64))
					{
						type = CimType.SInt64;
						wmiValue = val.ToString();
					}
					else if (valueType == typeof(System.Boolean))
					{
						type = CimType.Boolean;
						wmiValue = val;
					}
					else if (valueType == typeof(System.Single))
					{
						type = CimType.Real32;
						wmiValue = val;
					}
					else if (valueType == typeof(System.Double))
					{
						type = CimType.Real64;
						wmiValue = val;
					}
					else if (valueType == typeof(System.Char))
					{
						type = CimType.Char16;
						wmiValue = ((IConvertible)((System.Char)val)).ToInt16(null);
					}
					else if (valueType == typeof(System.String))
					{
						type = CimType.String;
						wmiValue = val;
					}
					else
					{
						// Check for an embedded object
						if (val is ManagementBaseObject)
						{
							type = CimType.Object;
							((ManagementBaseObject)val).Initialize();
							wmiValue = Marshal.GetObjectForIUnknown(((ManagementBaseObject) val).wbemObject);
						}
						else
							// System.Decimal, System.IntPr, System.UIntPtr, unhandled object, or unknown.
							Debug.Assert(false, "Unhandled type");
					}
				}
			}

			return wmiValue;
		}

	}//PropertyData
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\managementpath.cs ===
using System;
using System.Diagnostics;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Runtime.InteropServices;
using WbemUtilities_v1;
using WbemClient_v1;
using System.Globalization;
using System.Reflection;
using System.ComponentModel.Design.Serialization;

namespace System.Management
{
	/// <summary>
	/// Provides a wrapper for parsing and building paths to WMI objects
	/// </summary>
	[TypeConverter(typeof(ManagementPathConverter ))]
	public class ManagementPath : ICloneable
	{
		private static ManagementPath defaultPath = new ManagementPath("//./root/cimv2");
		internal event IdentifierChangedEventHandler IdentifierChanged;

		//Fires IdentifierChanged event
		private void FireIdentifierChanged()
		{
			if (IdentifierChanged != null)
				IdentifierChanged(this, null);
		}

		//internal factory
		/// <summary>
		/// Internal static "factory" method for making a new ManagementPath
		/// from the system property of a WMI object
		/// </summary>
		/// <param name="wbemObject">The WMI object whose __PATH property will
		/// be used to supply the returned object</param>
		internal static ManagementPath GetManagementPath (
			IWbemClassObjectFreeThreaded wbemObject)
		{
			ManagementPath path = null; 
			int status = (int)ManagementStatus.Failed;

			if (null != wbemObject)
			{
				int dummy1 = 0, dummy2 = 0;
				object val = null;
				status = wbemObject.Get_ ("__PATH", 0, ref val, ref dummy1, ref dummy2);

				if ((status & 0xfffff000) == 0x80041000)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				}
				else if ((status & 0x80000000) != 0)
				{
					Marshal.ThrowExceptionForHR(status);
				}
                if (System.DBNull.Value != val)
                    path = new ManagementPath ((string) val);
            }

			return path;
		}

		/// <summary>
		/// Default constructor - creates an empty ManagementPath object
		/// </summary>
		public ManagementPath () : this ((string) null) {}

		/// <summary>
		/// Constructs a ManagementPath object for the given path
		/// </summary>
		/// <param name="path"> A string representing the object path </param>
		public ManagementPath(string path) 
		{
			if ((null != path) && (0 < path.Length))
				CreateNewPath (path);
		}
		
		/// <summary>
		/// Returns the full object path as the string representation
		/// </summary>
		public override string ToString () {
			return this.Path;
		}

		/// <summary>
		/// Returns a copy of this ManagementPath object
		/// </summary>
		public ManagementPath Clone ()
		{
			return new ManagementPath (Path);
		}

		/// <summary>
		/// Standard Clone returns a copy of this ManagementPath as a generic "Object" type
		/// </summary>
		object ICloneable.Clone ()
		{
			return Clone ();	
		}

		/// <summary>
		/// Represents the default scope path used when no scope is specified.
		/// The default scope is \\.\root\cimv2, and can be changed by setting this member.
		/// </summary>
		public static ManagementPath DefaultPath {
			get { return ManagementPath.defaultPath; }
			set { ManagementPath.defaultPath = value; }
		}
		
		//private members
		private IWbemPath		wmiPath;
		
		private void CreateNewPath (string path)
		{
			wmiPath = (IWbemPath)new WbemDefPath ();
			uint flags = (uint) tag_WBEM_PATH_CREATE_FLAG.WBEMPATH_CREATE_ACCEPT_ALL;

			//For now we have to special-case the "root" namespace - 
			//  this is because in the case of "root", the path parser cannot tell whether 
			//  this is a namespace name or a class name
			//TODO : fix this so that special-casing is not needed
			if (path.ToLower().Equals("root"))
				flags = flags | (uint) tag_WBEM_PATH_CREATE_FLAG.WBEMPATH_TREAT_SINGLE_IDENT_AS_NS;

			int status = (int)ManagementStatus.NoError;

			try {
				status = wmiPath.SetText_(flags, path);
			} catch (Exception e) {
				// BUGBUG : old throw new ArgumentOutOfRangeException ("path");  new:
				ManagementException.ThrowWithExtendedInfo(e);
			}

			if ((status & 0xfffff000) == 0x80041000)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
			}
			else if ((status & 0x80000000) != 0)
			{
				Marshal.ThrowExceptionForHR(status);
			}
		}

		internal void ClearKeys (bool setAsSingleton)
		{
			int status = (int)ManagementStatus.NoError;

			try {
				if (null != wmiPath)
				{
					IWbemPathKeyList keyList = null;
					status = wmiPath.GetKeyList_(out keyList);

					if (null != keyList)
					{
						status = keyList.RemoveAllKeys_(0);
						if ((status & 0x80000000) == 0)
						{
							sbyte bSingleton = (setAsSingleton) ? (sbyte)(-1) : (sbyte)0;
							status = keyList.MakeSingleton_(bSingleton);
							FireIdentifierChanged ();		// BUGBUG : RemoveAllKeys success?
						}
					}
				}
			}
			catch (Exception e) {
				ManagementException.ThrowWithExtendedInfo(e);
			}
		
			if ((status & 0xfffff000) == 0x80041000)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
			}
			else if ((status & 0x80000000) != 0)
			{
				Marshal.ThrowExceptionForHR(status);
			}
		}
		
		internal bool IsEmpty 
		{
			get {
				return (Path == String.Empty);
			}
		}


		//
		// Methods
		//

		/// <summary>
		/// For a new path, sets the path as a class path. This means the path must have
		/// a class name but no key values.
		/// </summary>
		public void SetAsClass ()
		{
			if (IsClass || IsInstance)
				ClearKeys (false);
			else
				throw new ManagementException (ManagementStatus.InvalidOperation, null, null);
		}

		/// <summary>
		/// For a new path, sets the path as a singleton object path. Means it's a path to an instance
		/// but there are no keys.
		/// </summary>
		public void SetAsSingleton ()
		{
			if (IsClass || IsInstance)
				ClearKeys (true);
			else
				throw new ManagementException (ManagementStatus.InvalidOperation, null, null);
		}

		//
		// Properties
		//

		/// <summary>
		/// This property contains the string representation of the full path in this object
		/// </summary>
		[RefreshProperties(RefreshProperties.All)]
		public string Path
		{
			get {
				String pathStr = String.Empty;

				if (null != wmiPath)
				{
					// TODO - due to a bug in the current WMI path
					// parser, requesting the path from a parser which has
					// been only given a relative path results in an incorrect
					// value being returned (e.g. \\.\win32_logicaldisk). To work
					// around this for now we check if there are any namespaces,
					// and if not ask for the relative path instead.
					int flags = (int)tag_WBEM_GET_TEXT_FLAGS.WBEMPATH_GET_SERVER_TOO;
					uint nCount = 0;

					int status = (int)ManagementStatus.NoError;

					try {
						status = wmiPath.GetNamespaceCount_(out nCount);

						if ((status & 0x80000000) == 0)
						{
							if (0 == nCount)
								flags = (int)tag_WBEM_GET_TEXT_FLAGS.WBEMPATH_GET_RELATIVE_ONLY;

							// Get the space we need to reserve
							uint bufLen = 0;
				
							status = wmiPath.GetText_(flags, ref bufLen, null);

							if ((status & 0x80000000) == 0 && 0 < bufLen)
							{
								pathStr = new String ('0', (int) bufLen-1);
								status = wmiPath.GetText_(flags, ref bufLen, pathStr);
							}
						}
					}
					catch (Exception e) {
						ManagementException.ThrowWithExtendedInfo(e);
					}

					if ((status & 0xfffff000) == 0x80041000)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					}
					else if ((status & 0x80000000) != 0)
					{
						Marshal.ThrowExceptionForHR(status);
					}
				}

				return pathStr;
			}

			set {
				try {
					// Before overwriting, check it's OK
					ManagementPath newPath = new ManagementPath (value);
					wmiPath = newPath.wmiPath;
				}
				catch (Exception) {
					throw new ArgumentOutOfRangeException ();
				}
				FireIdentifierChanged();
			}
		}

		/// <summary>
		/// Represents the relative path - class name and keys only
		/// </summary>
		[RefreshProperties(RefreshProperties.All)]
		public string RelativePath
		{
			get 
			{ 
				String pathStr = String.Empty;

				if (null != wmiPath)
				{
					// Get the space we need to reserve
					uint bufLen = 0;
					int status = (int)ManagementStatus.NoError;

					try 
					{
						status = wmiPath.GetText_(
							(int) tag_WBEM_GET_TEXT_FLAGS.WBEMPATH_GET_RELATIVE_ONLY,
							ref bufLen, 
							null);

						if ((status & 0x80000000) == 0 && 0 < bufLen)
						{
							pathStr = new String ('0', (int) bufLen-1);
							status = wmiPath.GetText_(
								(int) tag_WBEM_GET_TEXT_FLAGS.WBEMPATH_GET_RELATIVE_ONLY,
								ref bufLen, 
								pathStr);
						}
					}
					catch (Exception e) 
					{
						ManagementException.ThrowWithExtendedInfo(e);
					}
	
					if ((status & 0xfffff000) == 0x80041000)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					}
					else if ((status & 0x80000000) != 0)
					{
						Marshal.ThrowExceptionForHR(status);
					}
				}

				return pathStr;
			}

			set {
				try {
					SetRelativePath (value);
				} catch (COMException) {
					throw new ArgumentOutOfRangeException ();
				}
				FireIdentifierChanged();
			}
		}

		internal void SetRelativePath (string relPath)
		{
			ManagementPath newPath = new ManagementPath (relPath);
			newPath.NamespacePath = this.NamespacePath;
			newPath.Server = this.Server;
			wmiPath = newPath.wmiPath;
		}

		//Used to update the relative path when the user changes any key properties
		internal void UpdateRelativePath(string relPath)
		{
			if (relPath == null)
				return;

			//Get the server & namespace part from the existing path, and concatenate the given relPath.
			//NOTE : we need to do this because IWbemPath doesn't have a function to set the relative path alone...
			string newPath = String.Empty;
			string nsPath = this.NamespacePath;

			if (nsPath != String.Empty)
				newPath = String.Concat(this.NamespacePath, ":", relPath);
			else
				newPath = relPath;

			if (wmiPath == null)
				wmiPath = (IWbemPath)new WbemDefPath ();

			//Set the flags for the SetText operation
			uint flags = (uint) tag_WBEM_PATH_CREATE_FLAG.WBEMPATH_CREATE_ACCEPT_ALL;

			//Special-case the "root" namespace - 
			//  this is because in the case of "root", the path parser cannot tell whether 
			//  this is a namespace name or a class name
			//TODO : fix this so that special-casing is not needed
			if (newPath.ToLower().Equals("root"))
				flags = flags | (uint) tag_WBEM_PATH_CREATE_FLAG.WBEMPATH_TREAT_SINGLE_IDENT_AS_NS;

			int status = (int)ManagementStatus.NoError;

			try 
			{
				status = wmiPath.SetText_(flags, newPath);
			} 
			catch (Exception e) 
			{
				// BUGBUG : old throw new ArgumentOutOfRangeException ("path");  new:
				ManagementException.ThrowWithExtendedInfo(e);
			}

			if ((status & 0xfffff000) == 0x80041000)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
			}
			else if ((status & 0x80000000) != 0)
			{
				Marshal.ThrowExceptionForHR(status);
			}
		
		}

		
		/// <summary>
		/// Represents the server part of this path
		/// </summary>
		[RefreshProperties(RefreshProperties.All)]
		public string Server
		{
			get { 
				String pathStr = String.Empty;

				if (null != wmiPath) {

					int status = (int)ManagementStatus.NoError;

					try {
						uint bufLen = 0;
						status = wmiPath.GetServer_(ref bufLen, null);

						if ((status & 0x80000000) == 0 && 0 < bufLen) {
							pathStr = new String ('0', (int) bufLen-1);
							status = wmiPath.GetServer_(ref bufLen, pathStr);
						}
					}
					catch (Exception e) {
						ManagementException.ThrowWithExtendedInfo(e);
					}

					if ((status & 0xfffff000) == 0x80041000)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					}
					else if ((status & 0x80000000) != 0)
					{
						Marshal.ThrowExceptionForHR(status);
					}
				}

				return pathStr;
			}
			set {
				String oldValue = Server;

				// Only set if changed
				if (0 != oldValue.ToUpper().CompareTo(value.ToUpper()))
				{
					if (null == wmiPath)
						wmiPath = (IWbemPath)new WbemDefPath ();

					int status = (int)ManagementStatus.NoError;

					try {
						status = wmiPath.SetServer_(value);
					}
					catch (Exception) {
						throw new ArgumentOutOfRangeException ();
					}

					if ((status & 0xfffff000) == 0x80041000)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					}
					else if ((status & 0x80000000) != 0)
					{
						Marshal.ThrowExceptionForHR(status);
					}

					FireIdentifierChanged();
				}
			}
		}

		internal void SetNamespacePath (string nsPath) {
			int status = (int)ManagementStatus.NoError;

			ManagementPath newPath = new ManagementPath (nsPath);

			if (null == newPath.wmiPath)
				newPath.wmiPath = (IWbemPath)new WbemDefPath ();

				// Remove all existing namespaces from the current path
			if (null != wmiPath)
				status = wmiPath.RemoveAllNamespaces_();
			else
				wmiPath = (IWbemPath)new WbemDefPath ();

			// Add the new ones in
			uint nCount = 0;
			status = newPath.wmiPath.GetNamespaceCount_(out nCount);

			if (status >= 0)
			{
				for (uint i = 0; i < nCount; i++) 
				{
					uint uLen = 0;
					status = newPath.wmiPath.GetNamespaceAt_(i, ref uLen, null);
					if (status >= 0)
					{
						string nSpace = new String ('0', (int) uLen-1);
						status = newPath.wmiPath.GetNamespaceAt_(i, ref uLen, nSpace);
						if (status >= 0)
						{
							status = wmiPath.SetNamespaceAt_(i, nSpace);
							if (status < 0)
								break;
						}
						else
							break;
					}
					else
						break;
				}
			}

			//
			// Update Server property if specified in the namespace.
			//
			if (status >= 0 && nCount > 0)		// Successfully set namespace.
			{
				uint bufLen = 0;
				status = newPath.wmiPath.GetServer_(ref bufLen, null);

				if (status >= 0 && bufLen > 0)
				{
					String server = new String ('0', (int) bufLen-1);
					status = newPath.wmiPath.GetServer_(ref bufLen, server);

					if (status >= 0)			// Can't use property set since it will do a get.
					{
						status = wmiPath.SetServer_(server);
					}
				}
			}

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}
		}

		/// <summary>
		/// Represents the namespace part of the path. Note this does not include
		/// the server name which can be retrieved separately.
		/// </summary>
		[RefreshProperties(RefreshProperties.All)]
		public string NamespacePath {
			get {
				string pathStr = String.Empty;

				if (null != wmiPath)
				{
					// TODO - due to a bug in the current WMI path
					// parser, requesting the namespace path from a parser which has
					// been only given a relative path results in an incorrect
					// value being returned (e.g. \\.\). To work
					// around this for now we check if there are any namespaces,
					// and if not just return "".
					uint nCount = 0;
					int status = (int)ManagementStatus.NoError;

					try {
						status = wmiPath.GetNamespaceCount_(out nCount);

						if ((status & 0x80000000) == 0 && 0 < nCount)
						{
							// Get the space we need to reserve
							uint bufLen = 0;
							status = wmiPath.GetText_(
								(int)tag_WBEM_GET_TEXT_FLAGS.WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY,
								ref bufLen, 
								null);

							if ((status & 0x80000000) == 0 && 0 < bufLen)
							{
								pathStr = new String ('0', (int) bufLen-1);
								status = wmiPath.GetText_(
									(int)tag_WBEM_GET_TEXT_FLAGS.WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY,
									ref bufLen, 
									pathStr);
							}
						}
					}
					catch (Exception e) {
						ManagementException.ThrowWithExtendedInfo(e);
					}

					if ((status & 0xfffff000) == 0x80041000)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					}
					else if ((status & 0x80000000) != 0)
					{
						Marshal.ThrowExceptionForHR(status);
					}
				}

				return pathStr;
			}

			set {
				try {
					SetNamespacePath (value);
				}
				catch (COMException)
				{
					throw new ArgumentOutOfRangeException ();
				}

				FireIdentifierChanged();
			}
		}

		/// <summary>
		/// Represents the class portion of this path
		/// </summary>
		[RefreshProperties(RefreshProperties.All)]
		public string ClassName
		{
			get { 
				String pathStr = String.Empty;
				int status = (int)ManagementStatus.NoError;

				try {
					if (null != wmiPath) 
					{
						uint bufLen = 0;
						status = wmiPath.GetClassName_(ref bufLen, null);

						if ((status & 0x80000000) == 0 && 0 < bufLen) 
						{
							pathStr = new String ('0', (int) bufLen-1);
							status = wmiPath.GetClassName_(ref bufLen, pathStr);
						}
					}
				}
				catch (COMException) {}

				return pathStr;
			}
			set {
				String oldValue = ClassName;

				// Only set if changed
				if (0 != oldValue.ToUpper().CompareTo(value.ToUpper()))
				{
					if (null == wmiPath)
						wmiPath = (IWbemPath)new WbemDefPath ();

					int status = (int)ManagementStatus.NoError;

					try {
						status = wmiPath.SetClassName_(value);
					}
					catch (COMException) {		// BUGBUG : Change this?
						throw new ArgumentOutOfRangeException ();
					}

					if ((status & 0xfffff000) == 0x80041000)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					}
					else if ((status & 0x80000000) != 0)
					{
						Marshal.ThrowExceptionForHR(status);
					}

					FireIdentifierChanged();
				}
			}
		}

			
		/// <summary>
		/// Returns true if this is a class path
		/// </summary>
		public bool IsClass {
			get { 
				if (null == wmiPath)
					return false;

				ulong uInfo = 0;
				int status = (int)ManagementStatus.NoError;

				try {
					status = wmiPath.GetInfo_(0, out uInfo);
				}
				catch (Exception e) {
					ManagementException.ThrowWithExtendedInfo(e);
				}

				if ((status & 0xfffff000) == 0x80041000)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				}
				else if ((status & 0x80000000) != 0)
				{
					Marshal.ThrowExceptionForHR(status);
				}

				return (0 != (uInfo & (ulong)tag_WBEM_PATH_STATUS_FLAG.WBEMPATH_INFO_IS_CLASS_REF));
			}
		}

		/// <summary>
		/// Returns true if this is an instance path
		/// </summary>
		public bool IsInstance {
			get { 
				if (null == wmiPath)
					return false;

				ulong uInfo = 0;
				int status = (int)ManagementStatus.NoError;

				try {
					status = wmiPath.GetInfo_(0, out uInfo);
				}
				catch (Exception e) {
					ManagementException.ThrowWithExtendedInfo(e);
				}

				if ((status & 0xfffff000) == 0x80041000)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				}
				else if ((status & 0x80000000) != 0)
				{
					Marshal.ThrowExceptionForHR(status);
				}

				return (0 != (uInfo & (ulong)tag_WBEM_PATH_STATUS_FLAG.WBEMPATH_INFO_IS_INST_REF));
			}
		}

		/// <summary>
		/// Returns true if this is a singleton instance path
		/// </summary>
		public bool IsSingleton {
			get { 
				if (null == wmiPath)
					return false;

				ulong uInfo = 0;
				int status = (int)ManagementStatus.NoError;

				try {
					status = wmiPath.GetInfo_(0, out uInfo);
				}
				catch (Exception e) {
					ManagementException.ThrowWithExtendedInfo(e);
				}

				if ((status & 0xfffff000) == 0x80041000)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				}
				else if ((status & 0x80000000) != 0)
				{
					Marshal.ThrowExceptionForHR(status);
				}

				return (0 != (uInfo & (ulong)tag_WBEM_PATH_STATUS_FLAG.WBEMPATH_INFO_IS_SINGLETON));
			}
		}
	}

	/// <summary>
	/// Type converter for ManagementPath to convert from String to ManagementPath
	/// </summary>
	class ManagementPathConverter : ExpandableObjectConverter 
	{
        
		/// <summary>
		/// Determines if this converter can convert an object in the given source type to the native type of the converter. 
		/// </summary>
		/// <param name='context'>An ITypeDescriptorContext that provides a format context.</param>
		/// <param name='sourceType'>A Type that represents the type you wish to convert from.</param>
		/// <returns>
		///    <para>true if this converter can perform the conversion; otherwise, false.</para>
		/// </returns>
		public override Boolean CanConvertFrom(ITypeDescriptorContext context, Type sourceType) 
		{
			if ((sourceType == typeof(ManagementPath))) 
			{
				return true;
			}
			return base.CanConvertFrom(context,sourceType);
		}
        
		/// <summary>
		/// Gets a value indicating whether this converter can convert an object to the given destination type using the context.
		/// </summary>
		/// <param name='context'>An ITypeDescriptorContext that provides a format context.</param>
		/// <param name='sourceType'>A Type that represents the type you wish to convert to.</param>
		/// <returns>
		///    <para>true if this converter can perform the conversion; otherwise, false.</para>
		/// </returns>
		public override Boolean CanConvertTo(ITypeDescriptorContext context, Type destinationType) 
		{
			if ((destinationType == typeof(InstanceDescriptor))) 
			{
				return true;
			}
			return base.CanConvertTo(context,destinationType);
		}
        
		/// <summary>
		///      Converts the given object to another type.  The most common types to convert
		///      are to and from a string object.  The default implementation will make a call
		///      to ToString on the object if the object is valid and if the destination
		///      type is string.  If this cannot convert to the desitnation type, this will
		///      throw a NotSupportedException.
		/// </summary>
		/// <param name='context'>An ITypeDescriptorContext that provides a format context.</param>
		/// <param name='culture'>A CultureInfo object. If a null reference (Nothing in Visual Basic) is passed, the current culture is assumed.</param>
		/// <param name='value'>The Object to convert.</param>
		/// <param name='destinationType'>The Type to convert the value parameter to.</param>
		/// <returns>An Object that represents the converted value.</returns>
		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) 
		{

			if (destinationType == null) 
			{
				throw new ArgumentNullException("destinationType");
			}

			if (value is ManagementPath && destinationType == typeof(InstanceDescriptor)) 
			{
				ManagementPath obj = ((ManagementPath)(value));
				ConstructorInfo ctor = typeof(ManagementPath).GetConstructor(new Type[] {typeof(System.String)});
				if (ctor != null) 
				{
					return new InstanceDescriptor(ctor, new object[] {obj.Path});
				}
			}
			return base.ConvertTo(context,culture,value,destinationType);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\qualifier.cs ===
using System;
using System.Runtime.InteropServices;
using WbemClient_v1;

namespace System.Management
{
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para>This class contains information about a WMI qualifier</para>
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class QualifierData
	{
		private ManagementBaseObject parent;  //need access to IWbemClassObject pointer to be able to refresh qualifiers
		private string propertyOrMethodName; //remains null for object qualifiers
		private string qualifierName;
		private QualifierType qualifierType;
		private Object qualifierValue;
		private int qualifierFlavor;
		private IWbemQualifierSetFreeThreaded qualifierSet;

		internal QualifierData(ManagementBaseObject parent, string propName, string qualName, QualifierType type)		
		{
			this.parent = parent;
			this.propertyOrMethodName = propName;
			this.qualifierName = qualName;
			this.qualifierType = type;
			RefreshQualifierInfo();
		}

		//This private function is used to refresh the information from the Wmi object before returning the requested data
		private void RefreshQualifierInfo()
		{
			int status = (int)ManagementStatus.Failed;

			qualifierSet = null;
			switch (qualifierType) {
				case QualifierType.ObjectQualifier :
					try {
						status = parent.wbemObject.GetQualifierSet_(out qualifierSet);
					} catch (Exception e) {
						ManagementException.ThrowWithExtendedInfo (e);
					}
					break;
				case QualifierType.PropertyQualifier :
					try {
						status = parent.wbemObject.GetPropertyQualifierSet_(propertyOrMethodName, out qualifierSet);
					} catch (Exception e) {
						ManagementException.ThrowWithExtendedInfo (e);
					}
					break;
				case QualifierType.MethodQualifier :
					try {
						status = parent.wbemObject.GetMethodQualifierSet_(propertyOrMethodName, out qualifierSet);
					} catch (Exception e) {
						ManagementException.ThrowWithExtendedInfo (e);
					}
					break;
				default :
					throw new ManagementException(ManagementStatus.Unexpected, null, null); //is this the best fit error ??
			}

			if ((status & 0x80000000) == 0)
			{
				try {
					qualifierValue = null; //Make sure it's null so that we don't leak !
					if (qualifierSet != null)
						status = qualifierSet.Get_(qualifierName, 0, ref qualifierValue, ref qualifierFlavor);
				} 
				catch (Exception e) {
					ManagementException.ThrowWithExtendedInfo(e);
				}
			}

			if ((status & 0xfffff000) == 0x80041000)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
			}
			else if ((status & 0x80000000) != 0)
			{
				Marshal.ThrowExceptionForHR(status);
			}
		}

		/// <summary>
		/// </summary>
		/// <value>
		///    The name of the qualifier
		/// </value>
		public string Name {
			get { return qualifierName; }
		}

		/// <summary>
		///    <para>[To be supplied.]</para>
		/// </summary>
		/// <value>
		///    <para>The value of the qualifier</para>
		/// </value>
		/// <remarks>
		///    Qualifiers can only be of the following subset of CIM types :
		///    String, UInt16, UInt32, SInt32, UInt64, SInt64, Real32, Real64, Bool
		///    <TABLE>
		///    </TABLE>
		/// </remarks>
		public Object Value {
			get { 
				RefreshQualifierInfo();
				return qualifierValue; 
			}
			set {
				int status = (int)ManagementStatus.NoError;

				try {
					RefreshQualifierInfo();
					object newValue = value;
					
					status = qualifierSet.Put_(qualifierName, ref newValue, 
						qualifierFlavor & ~(int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_MASK_ORIGIN);  
				} catch (Exception e) {
					ManagementException.ThrowWithExtendedInfo(e);
				}

				if ((status & 0xfffff000) == 0x80041000)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				}
				else if ((status & 0x80000000) != 0)
				{
					Marshal.ThrowExceptionForHR(status);
				}
			}
		}

		/// <summary>
		///    <para>[To be supplied.]</para>
		/// </summary>
		/// <value>
		///    Indicates whether this qualifier is
		///    amended or not.
		/// </value>
		/// <remarks>
		///    Amended qualifiers are qualifiers who's
		///    value can be localized through WMI localization mechanisms. Localized qualifiers
		///    reside in separate namespaces in WMI and can be merged into the basic class
		///    definition when retrieved.
		/// </remarks>
		public bool IsAmended {
			get { 
				RefreshQualifierInfo(); 
				return ((int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_MASK_AMENDED ==
					(qualifierFlavor & (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_AMENDED));
			}
			set 
			{
				int status = (int)ManagementStatus.NoError;

				try {
					RefreshQualifierInfo ();
					// Mask out origin bits 
					int flavor = qualifierFlavor & ~(int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_MASK_ORIGIN;

					if (value)
						flavor |= (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_AMENDED;
					else
						flavor &= ~(int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_AMENDED;

					status = qualifierSet.Put_(qualifierName, ref qualifierValue, flavor);
				} catch (Exception e) {
					ManagementException.ThrowWithExtendedInfo(e);
				}

				if ((status & 0xfffff000) == 0x80041000)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				}
				else if ((status & 0x80000000) != 0)
				{
					Marshal.ThrowExceptionForHR(status);
				}
			}
		}

		/// <summary>
		///    <para>[To be supplied.]</para>
		/// </summary>
		/// <value>
		///    Indicates whether the qualifier has
		///    been defined locally on this class or has propagated from a base class.
		/// </value>
		public bool IsLocal {
			get {
				RefreshQualifierInfo();
				return ((int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_ORIGIN_LOCAL ==
					(qualifierFlavor & (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_MASK_ORIGIN));
			}
		}

		/// <summary>
		/// </summary>
		/// <value>
		///    Defines whether this qualifier
		///    should be propagated to instances of the class.
		/// </value>
		public bool PropagatesToInstance {
			get {
				RefreshQualifierInfo();
				return ((int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE ==
					(qualifierFlavor & (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE));
			}
			set {
				int status = (int)ManagementStatus.NoError;

				try {
					RefreshQualifierInfo ();
					// Mask out origin bits 
					int flavor = qualifierFlavor & ~(int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_MASK_ORIGIN;

					if (value)
						flavor |= (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;
					else
						flavor &= ~(int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;

					status = qualifierSet.Put_(qualifierName, ref qualifierValue, flavor);
				} catch (Exception e) {
					ManagementException.ThrowWithExtendedInfo(e);
				}

				if ((status & 0xfffff000) == 0x80041000)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				}
				else if ((status & 0x80000000) != 0)
				{
					Marshal.ThrowExceptionForHR(status);
				}
			}
		}

		/// <summary>
		///    <para>[To be supplied.]</para>
		/// </summary>
		/// <value>
		///    Defines whether this qualifier
		///    should be propagated to subclasses of this class
		/// </value>
		public bool PropagatesToSubclass {
			get {
				RefreshQualifierInfo();
				return ((int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS ==
					(qualifierFlavor & (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS));
			}
			set {
				int status = (int)ManagementStatus.NoError;

				try {
					RefreshQualifierInfo ();
					// Mask out origin bits 
					int flavor = qualifierFlavor & ~(int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_MASK_ORIGIN;

					if (value)
						flavor |= (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;
					else
						flavor &= ~(int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;

					status = qualifierSet.Put_(qualifierName, ref qualifierValue, flavor);
				} catch (Exception e) {
					ManagementException.ThrowWithExtendedInfo(e);
				}

				if ((status & 0xfffff000) == 0x80041000)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				}
				else if ((status & 0x80000000) != 0)
				{
					Marshal.ThrowExceptionForHR(status);
				}
			}
		}

		/// <summary>
		///    <para>[To be supplied.]</para>
		/// </summary>
		/// <value>
		///    Defines whether the value of this
		///    qualifier can be overridden when propagated.
		/// </value>
		public bool IsOverridable {
			get {
				RefreshQualifierInfo();
				return ((int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_OVERRIDABLE == 
					(qualifierFlavor & (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_MASK_PERMISSIONS));
			}
			set {
				int status = (int)ManagementStatus.NoError;

				try {
					RefreshQualifierInfo ();
					// Mask out origin bits 
					int flavor = qualifierFlavor & ~(int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_MASK_ORIGIN;
					
					if (value)
						flavor &= ~(int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_NOT_OVERRIDABLE;
					else
						flavor |= (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_NOT_OVERRIDABLE;

					status = qualifierSet.Put_(qualifierName, ref qualifierValue, flavor);
				} catch (Exception e) {
					ManagementException.ThrowWithExtendedInfo(e);
				}

				if ((status & 0xfffff000) == 0x80041000)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				}
				else if ((status & 0x80000000) != 0)
				{
					Marshal.ThrowExceptionForHR(status);
				}
			}
		}

	}//QualifierData
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\qualifierset.cs ===
using System;
using System.Collections;
using System.Runtime.InteropServices;
using WbemClient_v1;

namespace System.Management
{
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	/// This class represents a collection of qualifier objects
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class QualifierDataCollection : ICollection, IEnumerable
	{
		private ManagementBaseObject parent;
		private string propertyOrMethodName;
		private QualifierType qualifierSetType;

		internal QualifierDataCollection(ManagementBaseObject parent) : base()
		{
			this.parent = parent;
			this.qualifierSetType = QualifierType.ObjectQualifier;
			this.propertyOrMethodName = null;
		}

		internal QualifierDataCollection(ManagementBaseObject parent, string propertyOrMethodName, QualifierType type) : base()
		{
			this.parent = parent;
			this.propertyOrMethodName = propertyOrMethodName;
			this.qualifierSetType = type;
		}

		/// <summary>
		/// Return the qualifier set associated with its type
		/// Overload with use of private data member, qualifierType
		/// </summary>
		private IWbemQualifierSetFreeThreaded GetTypeQualifierSet()
		{
			return GetTypeQualifierSet(qualifierSetType);
		}

		/// <summary>
		/// Return the qualifier set associated with its type
		/// </summary>
		private IWbemQualifierSetFreeThreaded GetTypeQualifierSet(QualifierType qualifierSetType)
		{
			IWbemQualifierSetFreeThreaded qualifierSet	= null;
			int status						= (int)ManagementStatus.NoError;

			switch (qualifierSetType) 
			{
				case QualifierType.ObjectQualifier :
					status = parent.wbemObject.GetQualifierSet_(out qualifierSet);
					break;
				case QualifierType.PropertyQualifier :
					status = parent.wbemObject.GetPropertyQualifierSet_(propertyOrMethodName, out qualifierSet);
					break;
				case QualifierType.MethodQualifier :
					status = parent.wbemObject.GetMethodQualifierSet_(propertyOrMethodName, out qualifierSet);
					break;
				default :
					throw new ManagementException(ManagementStatus.Unexpected, null, null);	// Is this the best fit error ??
			}

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}

			return qualifierSet;
		}

		//
		//ICollection
		//

		/// <value>
		///  The number of objects in the collection
		/// </value>
		public int Count {
			get {
				string[] qualifierNames = null;
                IWbemQualifierSetFreeThreaded quals;
                try
                {
                    quals = GetTypeQualifierSet();
                }
                catch(ManagementException e)
                {
                    // If we ask for the number of qualifiers on a system property, we return '0'
                    if(qualifierSetType == QualifierType.PropertyQualifier && e.ErrorCode == ManagementStatus.SystemProperty)
                        return 0;
                    else
                        throw;
                }
				int status = quals.GetNames_(0, out qualifierNames);
				
				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				return qualifierNames.Length;
			}
		}

		/// <value>
		/// Whether the object is synchronized
		/// </value>
 		public bool IsSynchronized { get { return false; } }

		/// <value>
		/// Object to be used for synchronization
		/// </value>
 		public object SyncRoot { get { return this; } }

		/// <summary>
		/// ICollection method to copy collection into array
		/// </summary>
		/// <param name="array"> Array to copy to </param>
		/// <param name="index"> Index to start from </param>
		public void CopyTo(Array array, int index)
		{
			if (null == array)
				throw new ArgumentNullException("array");

			if ((index < array.GetLowerBound(0)) || (index > array.GetUpperBound(0)))
				throw new ArgumentOutOfRangeException("index");

			// Get the names of the qualifiers
			string[] qualifierNames = null;
            IWbemQualifierSetFreeThreaded quals;
            try
            {
                quals = GetTypeQualifierSet();
            }
            catch(ManagementException e)
            {
                // There are NO qualifiers on system properties, so we just return
                if(qualifierSetType == QualifierType.PropertyQualifier && e.ErrorCode == ManagementStatus.SystemProperty)
                    return;
                else
                    throw;
            }
			int status = quals.GetNames_(0, out qualifierNames);

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}

			if ((index + qualifierNames.Length) > array.Length)
				throw new ArgumentException("index");

			foreach (string qualifierName in qualifierNames)
				array.SetValue(new QualifierData(parent, propertyOrMethodName, qualifierName, qualifierSetType), index++);

			return;
		}

		/// <summary>
		///    <para>Copies the collection into a specialized QualifierData
		///       objects array</para>
		/// </summary>
		/// <param name='qualifierArray'><para>The array of QualifierData objects to copy to</para></param>
		/// <param name=' index'>The start index to copy to</param>
		public void CopyTo(QualifierData[] qualifierArray, int index)
		{
			CopyTo((Array)qualifierArray, index);
		}

		//
		// IEnumerable
		//
		IEnumerator IEnumerable.GetEnumerator()
		{
			return (IEnumerator)(new QualifierDataEnumerator(parent, propertyOrMethodName, qualifierSetType));
		}

		/// <summary>
		/// Strongly-typed GetEnumerator returns an enumerator for the qualifiers collection
		/// </summary>
		public QualifierDataEnumerator GetEnumerator()
		{
			return new QualifierDataEnumerator(parent, propertyOrMethodName, qualifierSetType);
		}

		/// <summary>
		/// The enumerator for qualifiers in the qualifiers collection
		/// </summary>
		public class QualifierDataEnumerator : IEnumerator
		{
			private ManagementBaseObject parent;
			private string propertyOrMethodName;
			private QualifierType qualifierType;
			private string[] qualifierNames;
			private int index = -1;

			//Internal constructor
			internal QualifierDataEnumerator(ManagementBaseObject parent, string propertyOrMethodName, 
														QualifierType qualifierType)
			{
				this.parent						= parent;
				this.propertyOrMethodName		= propertyOrMethodName;
				this.qualifierType				= qualifierType;
				this.qualifierNames				= null;

				IWbemQualifierSetFreeThreaded qualifierSet	= null;
				int status						= (int)ManagementStatus.NoError;

				switch (qualifierType) 
				{
					case QualifierType.ObjectQualifier :
						status = parent.wbemObject.GetQualifierSet_(out qualifierSet);
						break;
					case QualifierType.PropertyQualifier :
						status = parent.wbemObject.GetPropertyQualifierSet_(propertyOrMethodName, out qualifierSet);
						break;
					case QualifierType.MethodQualifier :
						status = parent.wbemObject.GetMethodQualifierSet_(propertyOrMethodName, out qualifierSet);
						break;
					default :
						throw new ManagementException(ManagementStatus.Unexpected, null, null);	// Is this the best fit error ??
				}

                // If we got an error code back, assume there are NO qualifiers for this object/property/method
                if(status < 0)
                {
                    // TODO: Should we look at specific error codes.  For example, if you ask
                    // for the qualifier set on a system property, GetPropertyQualifierSet() returns
                    // WBEM_E_SYSTEM_PROPERTY.
                    qualifierNames = new String[]{};
                }
                else
                {
                    status = qualifierSet.GetNames_(0, out qualifierNames);
    							
                    if (status < 0)
                    {
                        if ((status & 0xfffff000) == 0x80041000)
                            ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
                        else
                            Marshal.ThrowExceptionForHR(status);
                    }
                }
			}
		
			//Standard "Current" variant
			object IEnumerator.Current {	get { return (object)this.Current; } }

			/// <summary>
			/// Returns the current qualifier object in the collection
			/// </summary>
			public QualifierData Current {
				get {
					if ((index == -1) || (index == qualifierNames.Length))
						throw new InvalidOperationException();
					else
						return new QualifierData(parent, propertyOrMethodName, 
												qualifierNames[index], qualifierType);
				}
			}

			/// <summary>
			/// Moves the enumerator to the next qualifier object in the collection
			/// </summary>
			public bool MoveNext()
			{
				if (index == qualifierNames.Length) //passed the end of the array
					return false; //don't advance the index any more

				index++;
				return (index == qualifierNames.Length) ? false : true;
			}

			/// <summary>
			/// Resets the enumerator to the beginning of the collection
			/// </summary>
			public void Reset()
			{
				index = -1;
			}
            
		}//QualifierDataEnumerator


		//
		//Methods
		//

		/// <summary>
		/// Indexer to access qualifiers in the collection by name
		/// </summary>
		/// <param name="qualifierName"> The name of the qualifier to access in the collection </param> 
		public virtual QualifierData this[string qualifierName] {
			get { 
				if (null == qualifierName)
					throw new ArgumentNullException("qualifierName");

				return new QualifierData(parent, propertyOrMethodName, qualifierName, qualifierSetType); 
			}
		}

		/// <summary>
		/// Removes a qualifier from the collection by name
		/// </summary>
		/// <param name="qualifierName"> Specifies the name of the qualifier to remove </param>
		public virtual void Remove(string qualifierName)
		{
			int status = GetTypeQualifierSet().Delete_(qualifierName);
		
			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}
		}

		/// <summary>
		/// Adds a qualifier to the collection. This variant takes the qualifier name and value
		/// </summary>
		/// <param name="qualifierName"> The name of the qualifier to be added to the collection </param>
		/// <param name="qualifierValue"> The value for the new qualifier </param>
		public virtual void Add(string qualifierName, object qualifierValue)
		{
			Add(qualifierName, qualifierValue, false, false, false, true);
		}



		/// <summary>
		/// Adds a qualifier to the collection. This variant takes all values for a QualifierData object
		/// </summary>
		/// <param name="qualifierName"> The qualifier name </param>
		/// <param name="qualifierValue"> The qualifier value </param>
		/// <param name="isAmended"> Indicates whether this qualifier is amended (flavor) </param>
		/// <param name="propagatesToInstance"> Indicates whether this qualifier propagates to instances </param>
		/// <param name="propagatesToSubclass"> Indicates whether this qualifier propagates to subclasses </param>
		/// <param name="isOverridable"> Specifies whether this qualifier's value is overridable in instances of subclasses </param>
		public virtual void Add(string qualifierName, object qualifierValue, bool isAmended, bool propagatesToInstance, bool propagatesToSubclass, bool isOverridable)
		{
			
			//Build the flavors bitmask and call the internal Add that takes a bitmask
			int qualFlavor = 0;
			if (isAmended) qualFlavor = (qualFlavor | (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_AMENDED);
			if (propagatesToInstance) qualFlavor = (qualFlavor | (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE);
			if (propagatesToSubclass) qualFlavor = (qualFlavor | (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);

			// Note we use the NOT condition here since WBEM_FLAVOR_OVERRIDABLE == 0
			if (!isOverridable) qualFlavor = (qualFlavor | (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_NOT_OVERRIDABLE);

			//Try to add the qualifier to the WMI object
			int status = GetTypeQualifierSet().Put_(qualifierName, ref qualifierValue, qualFlavor);
						
			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}
		}

	}//QualifierDataCollection
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\wmiutil.cs ===
using System;
using System.Runtime.InteropServices;
using WbemClient_v1;

namespace System.Management
{

	[Guid("2FD73A3B-64B3-480D-AEE9-54469D77123E"),	
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IWmiSec
	{
    	[PreserveSig] 
	    void BlessIWbemServices(
		[MarshalAs(UnmanagedType.Interface)]ref IWbemServices ppIWbemServices,
		[MarshalAs(UnmanagedType.BStr)] string user,
		[MarshalAs(UnmanagedType.BStr)]  string password,
		[MarshalAs(UnmanagedType.BStr)] string authority,
		 int impersonationLevel,
		 int authenticationLevel);

    	[PreserveSig] 
	    void BlessIEnumWbemClassObject(
		[MarshalAs(UnmanagedType.Interface)]ref IEnumWbemClassObject ppIEnumWbemClassObject,
		[MarshalAs(UnmanagedType.BStr)] string user,
		[MarshalAs(UnmanagedType.BStr)]  string password,
		[MarshalAs(UnmanagedType.BStr)] string authority,
		 int impersonationLevel,
		 int authenticationLevel);

    	[PreserveSig] 
	    void BlessIWbemCallResult(
		[MarshalAs(UnmanagedType.Interface)]ref IWbemCallResult ppIWbemCallResult,
		[MarshalAs(UnmanagedType.BStr)] string user,
		[MarshalAs(UnmanagedType.BStr)]  string password,
		[MarshalAs(UnmanagedType.BStr)] string authority,
		 int impersonationLevel,
		 int authenticationLevel);

		[PreserveSig]
		void SetSecurity(
			[In,Out] ref bool needToReset,
			[In,Out] ref IntPtr handle);

		[PreserveSig]
		void ResetSecurity(
			[In] IntPtr handle);
	}

	[ComImport, Guid("A8F03BE3-EDB7-4972-821F-AF6F8EA34884")]
	internal class WmiSec
	{
	}

	[Guid("A9A8F102-71CC-4C72-BC16-48E2CC917ADC"),	
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IWmiSinkDemultiplexor
	{
    	[PreserveSig] 
	    void GetDemultiplexedStub(
			[In,MarshalAs(UnmanagedType.IUnknown)]object pIUnknown,
			[Out,MarshalAs(UnmanagedType.IUnknown)]out object ppIUnknown
		);
	}

	[ComImport, Guid("D2EAA715-DAC7-4771-AF5C-931611A1853C")]
	internal class WmiSinkDemultiplexor
	{
	}

	[ComImport, Guid("87A5AD68-A38A-43ef-ACA9-EFE910E5D24C"),
	 InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IWmiEventSource
	{
		[PreserveSig]
		void Indicate(IntPtr pIWbemClassObject);

		[PreserveSig]
		void SetStatus(
			int lFlags,
			int hResult,
			[MarshalAs(UnmanagedType.BStr)] string strParam ,
			IntPtr pObjParam
		);
	}

#if USEIWOS
	// The following is a manually defined wrapper for IWbemObjectSink
	// since the size_is attribute cannot be dealt with by TlbImp.
	[Guid("7c857801-7381-11cf-884d-00aa004b2e24"),
	 InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	public interface IWbemObjectSink
	{
		[PreserveSig]
	    void Indicate(
	        long lObjectCount,
			[MarshalAs(UnmanagedType.Interface, SizeParamIndex=0)] IWbemClassObject [] apObjArray
	        );

		[PreserveSig]
	    void SetStatus(
	        long lFlags,
	        int hResult,
	        [MarshalAs(UnmanagedType.BStr)] string strParam,
	        [MarshalAs(UnmanagedType.Interface)] IWbemClassObject pObjParam
	        );

	};
#endif

	//Class for calling GetErrorInfo from managed code
	class WbemErrorInfo
	{
		public static IWbemClassObjectFreeThreaded GetErrorInfo()
		{
            IErrorInfo errorInfo = GetErrorInfo(0);
            if(null != errorInfo)
            {
                IntPtr pUnk = Marshal.GetIUnknownForObject(errorInfo);
                IntPtr pIWbemClassObject;
                Marshal.QueryInterface(pUnk, ref IWbemClassObjectFreeThreaded.IID_IWbemClassObject, out pIWbemClassObject);
                Marshal.Release(pUnk);

                // The IWbemClassObjectFreeThreaded instance will own reference count on pIWbemClassObject
                if(pIWbemClassObject != IntPtr.Zero)
                    return new IWbemClassObjectFreeThreaded(pIWbemClassObject);
            }
            return null;
		}
 
		[DllImport("oleaut32.dll", PreserveSig=false)]
		static extern IErrorInfo GetErrorInfo(int reserved);
	}

	//RCW for IErrorInfo
	[ComImport]
	[Guid("1CF2B120-547D-101B-8E65-08002B2BD119")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		internal interface IErrorInfo 
	{
		Guid GetGUID();

 		[return:MarshalAs(UnmanagedType.BStr)]
		string GetSource();

		[return:MarshalAs(UnmanagedType.BStr)]
		string GetDescription();

		[return:MarshalAs(UnmanagedType.BStr)]
		string GetHelpFile();

		uint GetHelpContext();
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\wmieventsink.cs ===
//#define USETLBIMP
//#define USEIWOS

using System;
using WbemClient_v1;
using System.Runtime.InteropServices;
using System.Diagnostics;
#if USETLBIMP
using WMISECLib;
#endif

namespace System.Management
{

#if USETLBIMP
internal class WmiEventSink : WMISECLib.IWmiEventSource
#elif USEIWOS
internal class WmiEventSink : IWbemObjectSink
#else
internal class WmiEventSink : IWmiEventSource
#endif
{
	private static int						s_hash = 0;
	private int								hash;
	private ManagementOperationObserver		watcher;
	private object							context;
	private ManagementScope					scope;
	private object							stub;			// The secured IWbemObjectSink

	// Used for Put's only
	internal event InternalObjectPutEventHandler  InternalObjectPut;
	private ManagementPath					path;			
	private string							className;

	internal WmiEventSink (ManagementOperationObserver watcher,
						 object context, 
						 ManagementScope scope) 
						 : this (watcher, context, scope, null, null) {}
	
	internal WmiEventSink (ManagementOperationObserver watcher,
						 object context, 
						 ManagementScope scope,
						 string path,
						 string className)
	{
		try {
			this.context = context;
			this.watcher = watcher;
			this.className = className;

			if (null != path)
				this.path = new ManagementPath (path);

			if (null != scope)
				this.scope = (ManagementScope) scope.Clone ();
#if USETLBIMP
			WMISECLib.WmiSinkDemultiplexor sinkDmux = new WMISECLib.WmiSinkDemultiplexor ();
			sinkDmux.GetDemultiplexedStub (this, ref m_stub);
#elif USEIWOS 
			IUnsecuredApartment unsecApp = new UnsecuredApartment ();
			unsecApp.CreateObjectStub (this, ref m_stub);
#else
			IWmiSinkDemultiplexor sinkDmux = (IWmiSinkDemultiplexor) new WmiSinkDemultiplexor ();
			sinkDmux.GetDemultiplexedStub (this, out stub);
#endif
			hash = Threading.Interlocked.Increment(ref s_hash);
		} catch {}
	}

	public override int GetHashCode () {
		return hash;
	}

	public IWbemObjectSink Stub { 
		get { 			
			try {
				return (null != stub) ? (IWbemObjectSink) stub : null; 
			} catch {
				return null;
			}
		}
	}

#if USEIWOS
	public virtual void Indicate (long lNumObjects, IWbemClassObject [] objArray)
	{
		try {
			for (long i = 0; i < lNumObjects; i++) {
				ObjectReadyEventArgs args = new ObjectReadyEventArgs (m_context, 
					new WmiObject(m_services, objArray[i]));
				watcher.FireObjectReady (args);
			}
		} catch {}
	}
#else
	public virtual void Indicate (IntPtr pIWbemClassObject)
	{
        Marshal.AddRef(pIWbemClassObject);
        IWbemClassObjectFreeThreaded obj = new IWbemClassObjectFreeThreaded(pIWbemClassObject);
		try {
			ObjectReadyEventArgs args = new ObjectReadyEventArgs (context, 
										ManagementBaseObject.GetBaseObject (obj, scope));
			watcher.FireObjectReady (args); 
		} catch {}
	}
#endif

	public void SetStatus (
#if USEIWOS
					long flags,
#else
					int flags, 
#endif
					int hResult, 
					String message, 
					IntPtr pErrorObj)
	{
        IWbemClassObjectFreeThreaded errObj = null;
        if(pErrorObj != IntPtr.Zero)
        {
            Marshal.AddRef(pErrorObj);
            errObj = new IWbemClassObjectFreeThreaded(pErrorObj);
        }

		try {
			if (flags == (int) tag_WBEM_STATUS_TYPE.WBEM_STATUS_COMPLETE)
			{
				// Is this a Put? If so fire the ObjectPut event
				if (null != path)
				{
					if (null == className)
						path.RelativePath = message;
					else
						path.RelativePath = className;

					// Fire the internal event (if anyone is interested)
					if (null != InternalObjectPut)
					{
						try {
							InternalObjectPutEventArgs iargs = new InternalObjectPutEventArgs (path);
							InternalObjectPut (this, iargs);
						} catch {}
					}

					ObjectPutEventArgs args = new ObjectPutEventArgs (context, path);
					watcher.FireObjectPut(args);
				}

				// Fire Completed event
				CompletedEventArgs args2 = new CompletedEventArgs (context, hResult, 
												new ManagementBaseObject (errObj));
				watcher.FireCompleted (args2);
				
				// Unhook and tidy up
				watcher.RemoveSink (this);
			}
			else if (0 != (flags & (int) tag_WBEM_STATUS_TYPE.WBEM_STATUS_PROGRESS))
			{
				// Fire Progress event
				ProgressEventArgs args = new ProgressEventArgs (context, 
					(int) (((uint)hResult & 0xFFFF0000) >> 16), hResult & 0xFFFF, message);

				watcher.FireProgress (args);
			}
		} catch {}
	}

	internal void Cancel () 
	{
		// BUGBUG : Throw exception on failure?
		try {
			scope.GetIWbemServices().CancelAsyncCall_((IWbemObjectSink) stub);
		} catch {}		
	}

	internal void ReleaseStub ()
	{
		try {
			/*
			 * We force a release of the stub here so as to allow
			 * unsecapp.exe to die as soon as possible.
			 */
			if (null != stub)
			{
				System.Runtime.InteropServices.Marshal.ReleaseComObject(stub);
				stub = null;
			}
		} catch {}
	}

}

// Special sink implementation for ManagementObject.Get
// Doesn't issue ObjectReady events
internal class WmiGetEventSink : WmiEventSink
{
	private ManagementObject	managementObject;

	internal WmiGetEventSink (ManagementOperationObserver watcher,
						 object context, 
						 ManagementScope scope,
						 ManagementObject managementObject) :
		base (watcher, context, scope)
	{
		this.managementObject = managementObject;
	}

#if USEIWOS
	public override void Indicate (long lNumObjects, IWbemClassObject [] objArray)
	{
		try {
			for (long i = 0; i < lNumObjects; i++) {
				if (null != managementObject)
					managementObject.WmiObject = objArray[i];
			}
		} catch () {}
	}
#else
	public override void Indicate (IntPtr pIWbemClassObject)
	{
        Marshal.AddRef(pIWbemClassObject);
		IWbemClassObjectFreeThreaded obj = new IWbemClassObjectFreeThreaded(pIWbemClassObject);
		if (null != managementObject)
		{
			try {
				managementObject.WmiObject = obj;
			} catch {}
		}
	}
#endif

}



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\instrumentation\codespit.cs ===
namespace System.Management.Instrumentation
{
    using System;
    using System.Reflection;
    using System.CodeDom;
    using System.CodeDom.Compiler;
    using Microsoft.CSharp;
    using System.IO;
#if xxx
    class CodeSpit
    {
        public static string Spit(Type t, IWbemObjectAccess iwoa)
        {
            string body = t.FullName + " inst = o as "+t.FullName+";\r\n";
            foreach(FieldInfo fi in t.GetFields())
            {
                int propType;
                int propHandle;
                iwoa.GetPropertyHandle(fi.Name, out propType, out propHandle);
                if(fi.FieldType == typeof(Byte))
                    body += "writeDWORD("+propHandle+", inst."+fi.Name+");\r\n";
                if(fi.FieldType == typeof(SByte))
                    body += "writeDWORD("+propHandle+", (uint)inst."+fi.Name+");\r\n";
                if(fi.FieldType == typeof(UInt16))
                    body += "writeDWORD("+propHandle+", inst."+fi.Name+");\r\n";
                if(fi.FieldType == typeof(Int16))
                    body += "writeDWORD("+propHandle+", (uint)inst."+fi.Name+");\r\n";
                if(fi.FieldType == typeof(UInt32))
                    body += "writeDWORD("+propHandle+", inst."+fi.Name+");\r\n";
                if(fi.FieldType == typeof(Int32))
                    body += "writeDWORD("+propHandle+", (uint)inst."+fi.Name+");\r\n";

                if(fi.FieldType == typeof(UInt64))
                    body += "writeQWORD("+propHandle+", inst."+fi.Name+");\r\n";
                if(fi.FieldType == typeof(Int64))
                    body += "writeQWORD("+propHandle+", (System.UInt64)inst."+fi.Name+");\r\n";

                if(fi.FieldType == typeof(Char))
                    body += "writeDWORD("+propHandle+", inst."+fi.Name+");\r\n";

                if(fi.FieldType == typeof(Boolean))
                    body += "writeDWORD("+propHandle+", (uint)(inst."+fi.Name+"?1:0));\r\n";

            }
            string code = @"
public class Hack
{
  public static void Func(object o, "+typeof(WriteDWORD).FullName+@" writeDWORD, "+typeof(WriteQWORD).FullName+@" writeQWORD)
  {
" + body +
                @"
  }
}
";
            return code;
        }
    }
#endif

    class HelperAssembly
    {

        string wmiNamespace;
        CodeNamespace codeNamespace;
        CodeTypeDeclaration theType;
        CodeMemberMethod staticConstructor;
        int typeCount = 0;

        const string iwoaName = "IWbemObjectAccessInternal";
        const string iwoaName2 = "IWbemObjectAccessInternal2";

        CodeVariableReferenceExpression clsVar = new CodeVariableReferenceExpression("cls");
        CodeVariableReferenceExpression iwoaVar = new CodeVariableReferenceExpression("iwoa");
        CodeVariableReferenceExpression iTempVar = new CodeVariableReferenceExpression("iTemp");
        CodeVariableReferenceExpression typeThisVar = new CodeVariableReferenceExpression("typeThis");
        CodeVariableReferenceExpression instNETVar = new CodeVariableReferenceExpression("instNET");
        CodeVariableReferenceExpression instWMIVar = new CodeVariableReferenceExpression("instWMI");

        CodeFieldReferenceExpression netTypesRef = new CodeFieldReferenceExpression(null, "netTypes");
        CodeFieldReferenceExpression toWMIMethodsRef = new CodeFieldReferenceExpression(null, "toWMIMethods");
        CodeFieldReferenceExpression toNETMethodsRef = new CodeFieldReferenceExpression(null, "toNETMethods");

        public HelperAssembly(string name, string wmiNamespace)
        {
            this.wmiNamespace = wmiNamespace;
            codeNamespace = new CodeNamespace(/*"WMIINTERNAL"*/);
            codeNamespace.Imports.Add(new CodeNamespaceImport("System"));
            codeNamespace.Imports.Add(new CodeNamespaceImport(typeof(System.Security.SuppressUnmanagedCodeSecurityAttribute).Namespace));
            codeNamespace.Imports.Add(new CodeNamespaceImport(typeof(System.Runtime.InteropServices.GuidAttribute).Namespace));
            codeNamespace.Imports.Add(new CodeNamespaceImport(typeof(System.Runtime.CompilerServices.MethodImplAttribute).Namespace));
            theType = new CodeTypeDeclaration(name);

            staticConstructor = new CodeTypeConstructor();
            theType.Members.Add(staticConstructor);


            CodeMemberField theOne = new CodeMemberField(name, "theOne");
            theOne.Attributes = MemberAttributes.Public|MemberAttributes.Static;
            theType.Members.Add(theOne);

            CodeAssignStatement assignTheOne = new CodeAssignStatement(new CodeFieldReferenceExpression(null, theOne.Name), new CodeObjectCreateExpression(name));
            staticConstructor.Statements.Add(assignTheOne);

            staticConstructor.Statements.Add(new CodeVariableDeclarationStatement(typeof(ManagementClass), clsVar.VariableName));
            staticConstructor.Statements.Add(new CodeVariableDeclarationStatement(iwoaName, iwoaVar.VariableName));
            staticConstructor.Statements.Add(new CodeVariableDeclarationStatement(typeof(int), iTempVar.VariableName));
            staticConstructor.Statements.Add(new CodeVariableDeclarationStatement(typeof(Type), typeThisVar.VariableName, new CodeTypeOfExpression(name)));


            sizeTypes = new CodePrimitiveExpression();

            CodeMemberField f;
            f = new CodeMemberField(typeof(Type[]), netTypesRef.FieldName);
            f.Attributes = MemberAttributes.Public|MemberAttributes.Static;
            f.InitExpression = new CodeArrayCreateExpression(typeof(Type), sizeTypes);
            theType.Members.Add(f);
            f = new CodeMemberField(typeof(MethodInfo[]), toWMIMethodsRef.FieldName);
            f.Attributes = MemberAttributes.Public|MemberAttributes.Static;
            f.InitExpression = new CodeArrayCreateExpression(typeof(MethodInfo), sizeTypes);
            theType.Members.Add(f);
            f = new CodeMemberField(typeof(MethodInfo[]), toNETMethodsRef.FieldName);
            f.Attributes = MemberAttributes.Public|MemberAttributes.Static;
            f.InitExpression = new CodeArrayCreateExpression(typeof(MethodInfo), sizeTypes);
            theType.Members.Add(f);

            codeNamespace.Types.Add(theType);
        }

        CodePrimitiveExpression sizeTypes;


        public void AddType(Type t)
        {
            CodeMemberMethod toWMI = new CodeMemberMethod();
            toWMI.Attributes = MemberAttributes.Public | MemberAttributes.Final;
            toWMI.Name = "toWMI_"+typeCount;
            toWMI.Parameters.Add(new CodeParameterDeclarationExpression(typeof(object), "o1"));
            toWMI.Parameters.Add(new CodeParameterDeclarationExpression(typeof(/*object*/IntPtr), "o2"));
            toWMI.Statements.Add(new CodeVariableDeclarationStatement(t.FullName, instNETVar.VariableName, new CodeCastExpression(t.FullName, new CodeVariableReferenceExpression("o1"))));
//            toWMI.Statements.Add(new CodeVariableDeclarationStatement(iwoaName, instWMIVar.VariableName, new CodeCastExpression(iwoaName, new CodeVariableReferenceExpression("o2"))));
            theType.Members.Add(toWMI);

            CodeMemberMethod toNET = new CodeMemberMethod();
            toNET.Attributes = MemberAttributes.Public | MemberAttributes.Final;
            toNET.Name = "toNET_"+typeCount;
            toNET.Parameters.Add(new CodeParameterDeclarationExpression(typeof(object), "o1"));
            toNET.Parameters.Add(new CodeParameterDeclarationExpression(typeof(object), "o2"));
            toNET.Statements.Add(new CodeVariableDeclarationStatement(t.FullName, instNETVar.VariableName, new CodeCastExpression(t.FullName, new CodeVariableReferenceExpression("o1"))));
            toNET.Statements.Add(new CodeVariableDeclarationStatement(iwoaName, instWMIVar.VariableName, new CodeCastExpression(iwoaName, new CodeVariableReferenceExpression("o2"))));
            theType.Members.Add(toNET);


            CodeExpression expr = new CodeArrayIndexerExpression(netTypesRef, new CodePrimitiveExpression(typeCount));
            staticConstructor.Statements.Add(new CodeAssignStatement(expr, new CodeTypeOfExpression(t)));
            expr = new CodeArrayIndexerExpression(toWMIMethodsRef, new CodePrimitiveExpression(typeCount));
            staticConstructor.Statements.Add(new CodeAssignStatement(expr, new CodeMethodInvokeExpression(typeThisVar, "GetMethod", new CodePrimitiveExpression(toWMI.Name))));
            expr = new CodeArrayIndexerExpression(toNETMethodsRef, new CodePrimitiveExpression(typeCount));
            staticConstructor.Statements.Add(new CodeAssignStatement(expr, new CodeMethodInvokeExpression(typeThisVar, "GetMethod", new CodePrimitiveExpression(toNET.Name))));


            string strWMIClass = wmiNamespace+":"+t.Name;
            staticConstructor.Statements.Add(new CodeAssignStatement(clsVar, new CodeObjectCreateExpression(typeof(ManagementClass), new CodeExpression[] {new CodePrimitiveExpression(strWMIClass)})));

            CodeTypeReferenceExpression bf = new CodeTypeReferenceExpression(typeof(BindingFlags));
            CodeFieldReferenceExpression bfNonPublic = new CodeFieldReferenceExpression(bf, "NonPublic");
            CodeFieldReferenceExpression bfInstance = new CodeFieldReferenceExpression(bf, "Instance");
            CodeBinaryOperatorExpression bfNonPublic_or_Instance = new CodeBinaryOperatorExpression(bfNonPublic, CodeBinaryOperatorType.BitwiseOr, bfInstance);
            CodeTypeReference mbo = new CodeTypeReference(typeof(ManagementBaseObject));
            CodeTypeOfExpression typeofMbo = new CodeTypeOfExpression(mbo);
            CodeMethodInvokeExpression propinfo = new CodeMethodInvokeExpression(typeofMbo, "GetProperty", new CodeExpression[] {new CodePrimitiveExpression("WmiObject"), bfNonPublic_or_Instance});
            CodeCastExpression cast = new CodeCastExpression(iwoaName, new CodeMethodInvokeExpression(propinfo, "GetValue", new CodeExpression[] {clsVar, new CodePrimitiveExpression(null)}));
            staticConstructor.Statements.Add(new CodeAssignStatement(iwoaVar, cast));

            int currentHandleCount = 0;
            foreach(MemberInfo fi in t.GetFields())
            {
                if(!(fi is FieldInfo || fi is PropertyInfo))
                    continue;
                Type t2;
                if(fi is FieldInfo)
                    t2 = (fi as FieldInfo).FieldType;
                else
                    t2 = (fi as PropertyInfo).PropertyType;

// BUG: The following causes a System.InvalidProgramException for some reason
//				CodeMemberField propHandle = new CodeMemberField(typeof(int), "handle_"+typeCount+"_"+currentHandleCount++);
				CodeMemberField propHandle = new CodeMemberField(typeof(int), String.Format("handle_{0}_{1}", typeCount, currentHandleCount++));
                propHandle.Attributes = MemberAttributes.Private|MemberAttributes.Static;
                theType.Members.Add(propHandle);

                CodeFieldReferenceExpression propHandleRef = new CodeFieldReferenceExpression(null, propHandle.Name);
                staticConstructor.Statements.Add(new CodeMethodInvokeExpression(iwoaVar, "GetPropertyHandle", new CodeExpression[] {new CodePrimitiveExpression(fi.Name), new CodeDirectionExpression(FieldDirection.Out, iTempVar), new CodeDirectionExpression(FieldDirection.Out, propHandleRef)}));

                if(t2 == typeof(UInt32))
                    toWMI.Statements.Add(new CodeMethodInvokeExpression(new CodeTypeReferenceExpression(iwoaName2), "WriteDWORD", new CodeExpression[] {new CodePrimitiveExpression(31), new CodeVariableReferenceExpression("o2"), propHandleRef, new CodeFieldReferenceExpression(instNETVar, fi.Name)}));
#if xxx
//                toWMI.Statements.Add(new CodeMethodInvokeExpression(instWMIVar, "WriteDWORD", new CodeExpression[] {propHandleRef, new CodeFieldReferenceExpression(instNETVar, fi.Name)}));
                if(fi.FieldType == typeof(Byte))
                    toWMI.Statements.Add(new CodeMethodInvokeExpression(instWMIVar, "WriteDWORD", new CodeExpression[] {propHandleRef, new CodeFieldReferenceExpression(instNETVar, fi.Name)}));
                if(fi.FieldType == typeof(SByte))
                    toWMI.Statements.Add(new CodeMethodInvokeExpression(instWMIVar, "WriteDWORD", new CodeExpression[] {propHandleRef, new CodeCastExpression(typeof(uint), new CodeFieldReferenceExpression(instNETVar, fi.Name))}));
                if(fi.FieldType == typeof(UInt16))
                    toWMI.Statements.Add(new CodeMethodInvokeExpression(instWMIVar, "WriteDWORD", new CodeExpression[] {propHandleRef, new CodeFieldReferenceExpression(instNETVar, fi.Name)}));
                if(fi.FieldType == typeof(Int16))
                    toWMI.Statements.Add(new CodeMethodInvokeExpression(instWMIVar, "WriteDWORD", new CodeExpression[] {propHandleRef, new CodeCastExpression(typeof(uint), new CodeFieldReferenceExpression(instNETVar, fi.Name))}));
                if(fi.FieldType == typeof(UInt32))
                    toWMI.Statements.Add(new CodeMethodInvokeExpression(instWMIVar, "WriteDWORD", new CodeExpression[] {propHandleRef, new CodeFieldReferenceExpression(instNETVar, fi.Name)}));
                if(fi.FieldType == typeof(Int32))
                    toWMI.Statements.Add(new CodeMethodInvokeExpression(instWMIVar, "WriteDWORD", new CodeExpression[] {propHandleRef, new CodeCastExpression(typeof(uint), new CodeFieldReferenceExpression(instNETVar, fi.Name))}));

                if(fi.FieldType == typeof(UInt64))
                    toWMI.Statements.Add(new CodeMethodInvokeExpression(instWMIVar, "WriteQWORD", new CodeExpression[] {propHandleRef, new CodeFieldReferenceExpression(instNETVar, fi.Name)}));
                if(fi.FieldType == typeof(Int64))
                    toWMI.Statements.Add(new CodeMethodInvokeExpression(instWMIVar, "WriteQWORD", new CodeExpression[] {propHandleRef, new CodeCastExpression(typeof(UInt64), new CodeFieldReferenceExpression(instNETVar, fi.Name))}));

                if(fi.FieldType == typeof(Char))
                    toWMI.Statements.Add(new CodeMethodInvokeExpression(instWMIVar, "WriteDWORD", new CodeExpression[] {propHandleRef, new CodeFieldReferenceExpression(instNETVar, fi.Name)}));
#endif
//                if(fi.FieldType == typeof(Boolean))
//                    body += "writeDWORD("+propHandle+", (uint)(inst."+fi.Name+"?1:0));\r\n";


                if(t2 == typeof(UInt32) && fi is FieldInfo)
                    toNET.Statements.Add(new CodeMethodInvokeExpression(instWMIVar, "ReadDWORD", new CodeExpression[] {propHandleRef, new CodeDirectionExpression(FieldDirection.Out, new CodeFieldReferenceExpression(instNETVar, fi.Name))}));
            }


            typeCount++;
            sizeTypes.Value = typeCount;
        }


        public string Code
        {
            get
            {
                CodeDomProvider prov = new CSharpCodeProvider();
                ICodeGenerator gen = prov.CreateGenerator();
                CodeGeneratorOptions options = new CodeGeneratorOptions();
                StringWriter sw = new StringWriter();
                gen.GenerateCodeFromNamespace(codeNamespace, sw, options);
                return sw.ToString() + iwoaDef;
            }
               
        }

        const string iwoaDef = @"[GuidAttribute(""49353C9A-516B-11D1-AEA6-00C04FB68820"")]
[TypeLibTypeAttribute(0x0200)]
[InterfaceTypeAttribute(0x0001)]
[SuppressUnmanagedCodeSecurityAttribute]
[ComImport]
interface IWbemObjectAccessInternal
{
void GetQualifierSet([Out] out IntPtr ppQualSet);
void Get([In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [In] Int32 lFlags, [In][Out] ref object pVal, [In][Out] ref Int32 pType, [In][Out] ref Int32 plFlavor);
void Put([In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [In] Int32 lFlags, [In] ref object pVal, [In] Int32 Type);
void Delete([In][MarshalAs(UnmanagedType.LPWStr)] string wszName);
void GetNames([In][MarshalAs(UnmanagedType.LPWStr)] string wszQualifierName, [In] Int32 lFlags, [In] ref object pQualifierVal, [Out][MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_BSTR)] out string[] pNames);
void BeginEnumeration([In] Int32 lEnumFlags);
void Next([In] Int32 lFlags, [In][Out][MarshalAs(UnmanagedType.BStr)] ref string strName, [In][Out] ref object pVal, [In][Out] ref Int32 pType, [In][Out] ref Int32 plFlavor);
void EndEnumeration();
void GetPropertyQualifierSet([In][MarshalAs(UnmanagedType.LPWStr)] string wszProperty, [Out] out IntPtr ppQualSet);
void Clone([Out] out IntPtr ppCopy);
void GetObjectText([In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.BStr)] out string pstrObjectText);
void SpawnDerivedClass([In] Int32 lFlags, [Out] out IntPtr ppNewClass);
void SpawnInstance([In] Int32 lFlags, [Out] out IntPtr ppNewInstance);
void CompareTo([In] Int32 lFlags, [In] IntPtr pCompareTo);
void GetPropertyOrigin([In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [Out][MarshalAs(UnmanagedType.BStr)] out string pstrClassName);
void InheritsFrom([In][MarshalAs(UnmanagedType.LPWStr)] string strAncestor);
void GetMethod([In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [In] Int32 lFlags, [Out] out IntPtr ppInSignature, [Out] out IntPtr ppOutSignature);
void PutMethod([In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [In] Int32 lFlags, [In] IntPtr pInSignature, [In] IntPtr pOutSignature);
void DeleteMethod([In][MarshalAs(UnmanagedType.LPWStr)] string wszName);
void BeginMethodEnumeration([In] Int32 lEnumFlags);
void NextMethod([In] Int32 lFlags, [In][Out][MarshalAs(UnmanagedType.BStr)] ref string pstrName, [In][Out] ref IntPtr ppInSignature, [In][Out] ref IntPtr ppOutSignature);
void EndMethodEnumeration();
void GetMethodQualifierSet([In][MarshalAs(UnmanagedType.LPWStr)] string wszMethod, [Out] out IntPtr ppQualSet);
void GetMethodOrigin([In][MarshalAs(UnmanagedType.LPWStr)] string wszMethodName, [Out][MarshalAs(UnmanagedType.BStr)] out string pstrClassName);
void GetPropertyHandle([In][MarshalAs(UnmanagedType.LPWStr)] string wszPropertyName, [Out] out Int32 pType, [Out] out Int32 plHandle);
void WritePropertyValue([In] Int32 lHandle, [In] Int32 lNumBytes, [In] ref Byte aData);
void ReadPropertyValue([In] Int32 lHandle, [In] Int32 lBufferSize, [Out] out Int32 plNumBytes, [Out] out Byte aData);
void ReadDWORD([In] Int32 lHandle, [Out] out UInt32 pdw);
void WriteDWORD([In] Int32 lHandle, [In] UInt32 dw);
void ReadQWORD([In] Int32 lHandle, [Out] out UInt64 pqw);
void WriteQWORD([In] Int32 lHandle, [In] UInt64 pw);
void GetPropertyInfoByHandle([In] Int32 lHandle, [Out][MarshalAs(UnmanagedType.BStr)] out string pstrName, [Out] out Int32 pType);
void Lock([In] Int32 lFlags);
void Unlock([In] Int32 lFlags);
}
class IWbemObjectAccessInternal2
{
protected const string DllName = ""WMINet_Utils.dll"";
protected const string EntryPointName = ""UFunc"";
[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] public static extern int Indicate(int vFunc, IntPtr objPtr, Int32 lObjectCount, IntPtr apObjArray);
[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] public static extern int WriteDWORD(int vFunc, IntPtr objPtr, Int32 lHandle, UInt32 dw);
}
";

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\instrumentation\assemblynameutility.cs ===
//------------------------------------------------------------------------------
// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
//    Copyright (c) Microsoft Corporation. All Rights Reserved.                
//    Information Contained Herein is Proprietary and Confidential.            
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Management.Instrumentation
{
	using System;
	using System.Reflection;

	class AssemblyNameUtility
	{
		private static string BinToString(byte [] rg)
		{
			if(rg == null)
				return "";
			string sz = "";
			for(int i=0;i<rg.GetLength(0);i++)
			{
				sz += String.Format("{0:x2}", rg[i]);
			}
			return sz;
		}

		public static string UniqueToAssemblyMinorVersion(Assembly assembly)
		{
            AssemblyName an = assembly.GetName(true);
			return an.Name + "_SN_"+BinToString(an.GetPublicKeyToken()) + "_Version_"+an.Version.Major +"."+ an.Version.Minor;// +"."+ an.Version.Revision+"."+an.Version.Build;
		}

        static string UniqueToAssemblyVersion(Assembly assembly)
        {
            AssemblyName an = assembly.GetName(true);
            return an.Name + "_SN_"+BinToString(an.GetPublicKeyToken()) + "_Version_"+an.Version.Major +"."+ an.Version.Minor+"."+an.Version.Build +"."+ an.Version.Revision;
        }

        public static string UniqueToAssemblyBuild(Assembly assembly)
		{
            return UniqueToAssemblyVersion(assembly) + "_Mvid_"+MetaDataInfo.GetMvid(assembly).ToString().ToLower();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\instrumentation\eventsource.cs ===
namespace System.Management.Instrumentation
{
    using System;
    using System.Runtime.InteropServices;
    using System.Collections;
    using System.Text.RegularExpressions;
    using System.Threading;

    class ComThreadingInfo
    {
        public enum APTTYPE
        {
            APTTYPE_CURRENT = -1,
            APTTYPE_STA = 0,
            APTTYPE_MTA = 1,
            APTTYPE_NA  = 2,
            APTTYPE_MAINSTA = 3
        }

        public enum THDTYPE
        {
            THDTYPE_BLOCKMESSAGES   = 0,
            THDTYPE_PROCESSMESSAGES = 1
        }

        [ComImport]
        [Guid("000001ce-0000-0000-C000-000000000046")]
        [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
        interface IComThreadingInfo 
        {
            APTTYPE GetCurrentApartmentType();
            THDTYPE GetCurrentThreadType();
            Guid GetCurrentLogicalThreadId();
            void SetCurrentLogicalThreadId([In] Guid rguid);
        }

        Guid IID_IUnknown = new Guid("00000000-0000-0000-C000-000000000046");

        ComThreadingInfo()
        {
            IComThreadingInfo info = (IComThreadingInfo)CoGetObjectContext(ref IID_IUnknown);

            apartmentType  = info.GetCurrentApartmentType();
            threadType = info.GetCurrentThreadType();
            logicalThreadId = info.GetCurrentLogicalThreadId();
        }

        public static ComThreadingInfo Current
        {
            get
            {
                return new ComThreadingInfo();
            }
        }

        public override string ToString()
        {
            return String.Format("{{{0}}} - {1} - {2}", LogicalThreadId, ApartmentType, ThreadType);
        }

        APTTYPE apartmentType;
        THDTYPE threadType;
        Guid logicalThreadId;

        public APTTYPE ApartmentType { get { return apartmentType; } 
        }
        public THDTYPE ThreadType { get { return threadType; } 
        }
        public Guid LogicalThreadId { get { return logicalThreadId; } 
        }

        [DllImport("Ole32.dll", PreserveSig = false)]
        [return:MarshalAs(UnmanagedType.IUnknown)]
        static extern object CoGetObjectContext([In] ref Guid riid);
    }

    sealed class EventSource : IWbemProviderInit, IWbemEventProvider, IWbemEventProviderQuerySink, IWbemEventProviderSecurity, IWbemServices_Old
    {
        IWbemDecoupledRegistrar registrar = (IWbemDecoupledRegistrar)new WbemDecoupledRegistrar();

        public EventSource(string namespaceName, string appName)
        {
            registrar.Register_(0, null, null, null, namespaceName, appName, this);
        }

        ~EventSource()
        {
            registrar.UnRegister_();
        }

        IWbemServices pNamespace = null;
        public IWbemObjectSink pSink = null;

        void RelocateSinkRCWToMTA()
        {
            Thread thread = new Thread(new ThreadStart(RelocateSinkRCWToMTA_ThreadFuncion));
            thread.ApartmentState = ApartmentState.MTA;
            thread.Start();
            thread.Join();
        }

        void RelocateSinkRCWToMTA_ThreadFuncion()
        {
            pSink = (IWbemObjectSink)RelocateRCWToCurrentApartment(pSink);
        }

        void RelocateNamespaceRCWToMTA()
        {
            Thread thread = new Thread(new ThreadStart(RelocateNamespaceRCWToMTA_ThreadFuncion));
            thread.ApartmentState = ApartmentState.MTA;
            thread.Start();
            thread.Join();
        }

        void RelocateNamespaceRCWToMTA_ThreadFuncion()
        {
            pSink = (IWbemObjectSink)RelocateRCWToCurrentApartment(pSink);
        }

        static object RelocateRCWToCurrentApartment(object comObject)
        {
            if(null == comObject)
                return null;

            IntPtr pUnk = Marshal.GetIUnknownForObject(comObject);
            int references = Marshal.ReleaseComObject(comObject);
            if(references != 0)
                throw new Exception(); // TODO?

            comObject = Marshal.GetObjectForIUnknown(pUnk);
            Marshal.Release(pUnk);
            return comObject;
        }

        public bool Any()
        {
            return (null==pSink)||(mapQueryIdToQuery.Count==0);
        }

        Hashtable mapQueryIdToQuery = new Hashtable();
        // IWbemProviderInit
        int IWbemProviderInit.Initialize_(
            [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszUser,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszNamespace,
            [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszLocale,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemServices   pNamespace,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemProviderInitSink   pInitSink)
        {
//            Console.WriteLine(ComThreadingInfo.Current.ApartmentType);
            this.pNamespace = pNamespace;
            RelocateNamespaceRCWToMTA();

            this.pSink = null;

            lock(mapQueryIdToQuery)
            {
                mapQueryIdToQuery.Clear();
            }

            pInitSink.SetStatus_((int)tag_WBEM_EXTRA_RETURN_CODES.WBEM_S_INITIALIZED, 0);
            Marshal.ReleaseComObject(pInitSink);

            return 0;
        }

        // IWbemEventProvider
        int IWbemEventProvider.ProvideEvents_(
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pSink,
            [In] Int32 lFlags)
        {
//            Console.WriteLine(ComThreadingInfo.Current.ApartmentType);
            this.pSink = pSink;
            RelocateSinkRCWToMTA();

            // TODO: Why do we get NewQuery BEFORE ProvideEvents?
//            mapQueryIdToQuery.Clear();
            return 0;
        }

        // IWbemEventProviderQuerySink
        int IWbemEventProviderQuerySink.NewQuery_(
            [In] UInt32 dwId,
            [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszQueryLanguage,
            [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszQuery)
        {
            lock(mapQueryIdToQuery)
            {
                mapQueryIdToQuery.Add(dwId, wszQuery);
            }
            return 0;
        }

        int IWbemEventProviderQuerySink.CancelQuery_([In] UInt32 dwId)
        {
            lock(mapQueryIdToQuery)
            {
                mapQueryIdToQuery.Remove(dwId);
            }
            return 0;
        }

        // IWbemEventProviderSecurity
        int IWbemEventProviderSecurity.AccessCheck_(
            [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszQueryLanguage,
            [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszQuery,
            [In] Int32 lSidLength,
            [In] ref Byte pSid)
        {
            return 0;
        }

        // IWbemServices
        int IWbemServices_Old.OpenNamespace_([In][MarshalAs(UnmanagedType.BStr)]  string   strNamespace,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][Out][MarshalAs(UnmanagedType.Interface)]  ref IWbemServices   ppWorkingNamespace,
            [In] IntPtr ppCallResult)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.CancelAsyncCall_([In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pSink)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.QueryObjectSink_([In] Int32 lFlags,
            [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemObjectSink   ppResponseHandler)
        {
            ppResponseHandler = null;
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.GetObject_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][Out][MarshalAs(UnmanagedType.Interface)]  ref IWbemClassObject_DoNotMarshal   ppObject,
            [In] IntPtr ppCallResult)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.GetObjectAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler)
        {
//            pResponseHandler.SetStatus(0, (int)tag_WBEMSTATUS.WBEM_E_NOT_FOUND, null, null);
//            Marshal.ReleaseComObject(pResponseHandler);
//            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_FOUND);

            Match match = Regex.Match(strObjectPath.ToLower(), "(.*?)\\.instanceid=\"(.*?)\",processid=\"(.*?)\"");
            if(match.Success==false)
            {
                pResponseHandler.SetStatus_(0, (int)tag_WBEMSTATUS.WBEM_E_NOT_FOUND, null, IntPtr.Zero);
                Marshal.ReleaseComObject(pResponseHandler);
                return (int)(tag_WBEMSTATUS.WBEM_E_NOT_FOUND);
            }

            string className = match.Groups[1].Value;
            string instanceId = match.Groups[2].Value;
            string processId = match.Groups[3].Value;


            if(Instrumentation.ProcessIdentity != processId)
            {
                pResponseHandler.SetStatus_(0, (int)tag_WBEMSTATUS.WBEM_E_NOT_FOUND, null, IntPtr.Zero);
                Marshal.ReleaseComObject(pResponseHandler);
                return (int)(tag_WBEMSTATUS.WBEM_E_NOT_FOUND);
            }

            int id = ((IConvertible)instanceId).ToInt32(null);
            if(InstrumentedAssembly.mapIDToRef.ContainsKey(id))
            {
                GCHandle h = (GCHandle)InstrumentedAssembly.mapIDToRef[id];
                if(h.IsAllocated)
                {
                    IWbemClassObjectFreeThreaded classObj;
                    pNamespace.GetObject_(h.Target.GetType().Name, 0, pCtx, out classObj, IntPtr.Zero);
                    IWbemClassObjectFreeThreaded inst;
                    classObj.SpawnInstance_(0, out inst);

                    Object o = h.GetHashCode();
                    inst.Put_("InstanceId", 0, ref o, 0);
                    o = Instrumentation.ProcessIdentity;
                    inst.Put_("ProcessId", 0, ref o, 0);
                    ConvertFuncToWMI func = (ConvertFuncToWMI)InstrumentedAssembly.mapTypeToToWMIFunc[h.Target.GetType()];
//                    func(h.Target, inst);
//                    pResponseHandler.Indicate_(1, ref inst);

                    pResponseHandler.SetStatus_(0, 0, null, IntPtr.Zero);
                    Marshal.ReleaseComObject(pResponseHandler);
                    return 0;
                }
            }
            pResponseHandler.SetStatus_(0, (int)tag_WBEMSTATUS.WBEM_E_NOT_FOUND, null, IntPtr.Zero);
            Marshal.ReleaseComObject(pResponseHandler);
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_FOUND);
#if xxx
            IWbemClassObject classObj = null;
            IWbemCallResult result = null;
            pNamespace.GetObject("TestInstance", 0, pCtx, ref classObj, ref result);
            IWbemClassObject inst;
            classObj.SpawnInstance(0, out inst);

            TestInstance testInstance = (TestInstance)mapNameToTestInstance[match.Groups[1].Value];

            Object o = (object)testInstance.name;
            inst.Put("name", 0, ref o, 0);
            o = (object)testInstance.value;
            inst.Put("value", 0, ref o, 0);

            pResponseHandler.Indicate(1, new IWbemClassObject[] {inst});
            pResponseHandler.SetStatus_(0, 0, IntPtr.Zero, IntPtr.Zero);
            Marshal.ReleaseComObject(pResponseHandler);
#endif
        }

        int IWbemServices_Old.PutClass_([In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pObject,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In] IntPtr ppCallResult)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.PutClassAsync_([In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pObject,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.DeleteClass_([In][MarshalAs(UnmanagedType.BStr)]  string   strClass,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In] IntPtr ppCallResult)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.DeleteClassAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strClass,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.CreateClassEnum_([In][MarshalAs(UnmanagedType.BStr)]  string   strSuperclass,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject   ppEnum)
        {
            ppEnum = null;
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.CreateClassEnumAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strSuperclass,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.PutInstance_([In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pInst,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In] IntPtr ppCallResult)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.PutInstanceAsync_([In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pInst,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.DeleteInstance_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In] IntPtr ppCallResult)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.DeleteInstanceAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.CreateInstanceEnum_([In][MarshalAs(UnmanagedType.BStr)]  string   strFilter,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject   ppEnum)
        {
            ppEnum = null;
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.CreateInstanceEnumAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strFilter,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler)
        {
            IWbemClassObjectFreeThreaded classObj;
            pNamespace.GetObject_(strFilter, 0, pCtx, out classObj, IntPtr.Zero);
            IWbemClassObjectFreeThreaded inst;
            classObj.SpawnInstance_(0, out inst);
            foreach(GCHandle h in InstrumentedAssembly.mapIDToRef.Values)
            {
                if(h.IsAllocated && h.Target.GetType().Name == strFilter)
                {
                    Object o = h.GetHashCode();
                    inst.Put_("InstanceId", 0, ref o, 0);
                    o = Instrumentation.ProcessIdentity;
                    inst.Put_("ProcessId", 0, ref o, 0);
                    ConvertFuncToWMI func = (ConvertFuncToWMI)InstrumentedAssembly.mapTypeToToWMIFunc[h.Target.GetType()];
//                    func(h.Target, inst);
//                    pResponseHandler.Indicate_(1, ref inst);
                }
            }
            pResponseHandler.SetStatus_(0, 0, null, IntPtr.Zero);
            Marshal.ReleaseComObject(pResponseHandler);
            return 0;
        }

        int IWbemServices_Old.ExecQuery_([In][MarshalAs(UnmanagedType.BStr)]  string   strQueryLanguage,
            [In][MarshalAs(UnmanagedType.BStr)]  string   strQuery,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject   ppEnum)
        {
            ppEnum = null;
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.ExecQueryAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strQueryLanguage,
            [In][MarshalAs(UnmanagedType.BStr)]  string   strQuery,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.ExecNotificationQuery_([In][MarshalAs(UnmanagedType.BStr)]  string   strQueryLanguage,
            [In][MarshalAs(UnmanagedType.BStr)]  string   strQuery,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject   ppEnum)
        {
            ppEnum = null;
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.ExecNotificationQueryAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strQueryLanguage,
            [In][MarshalAs(UnmanagedType.BStr)]  string   strQuery,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.ExecMethod_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath,
            [In][MarshalAs(UnmanagedType.BStr)]  string   strMethodName,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pInParams,
            [In][Out][MarshalAs(UnmanagedType.Interface)]  ref IWbemClassObject_DoNotMarshal   ppOutParams,
            [In] IntPtr ppCallResult)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.ExecMethodAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath,
            [In][MarshalAs(UnmanagedType.BStr)]  string   strMethodName,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pInParams,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }
    }
}


#if UNUSED_CODE
    class HResultException : Exception
    {
        public HResultException(int hr)
        {
            base.HResult = hr;
        }
    }

    class WbemStatusException : HResultException
    {
        public WbemStatusException(tag_WBEMSTATUS status) : base((int)status) {}
    }

    /*********************************************
     * Wbem Internal
     *********************************************/
    [TypeLibTypeAttribute(0x0200)]
    [InterfaceTypeAttribute(0x0001)]
    [GuidAttribute("6C19BE32-7500-11D1-AD94-00C04FD8FDFF")]
    [ComImport]
    interface IWbemMetaData
    {
        void GetClass([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszClassName, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pContext, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject   ppClass);
    } // end of IWbemMetaData

    [GuidAttribute("755F9DA6-7508-11D1-AD94-00C04FD8FDFF")]
    [TypeLibTypeAttribute(0x0200)]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemMultiTarget
    {
        void DeliverEvent([In] UInt32 dwNumEvents, [In][MarshalAs(UnmanagedType.Interface)]  ref IWbemClassObject   aEvents, [In] ref tag_WBEM_REM_TARGETS aTargets);
        void DeliverStatus([In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Error)]  Int32   hresStatus, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszStatus, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject   pErrorObj, [In] ref tag_WBEM_REM_TARGETS pTargets);
    } // end of IWbemMultiTarget

    struct tag_WBEM_REM_TARGETS
    {
        public Int32 m_lNumTargets;

        //        [ComConversionLossAttribute]
        //        public IntPtr m_aTargets;
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] UInt32[]  m_aTargets;
    } // end of tag_WBEM_REM_TARGETS
  
    [GuidAttribute("60E512D4-C47B-11D2-B338-00105A1F4AAF")]
    [TypeLibTypeAttribute(0x0200)]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemFilterProxy
    {
        void Initialize([In][MarshalAs(UnmanagedType.Interface)]  IWbemMetaData   pMetaData, [In][MarshalAs(UnmanagedType.Interface)]  IWbemMultiTarget   pMultiTarget);
        void Lock();
        void Unlock();
        void AddFilter([In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pContext, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszQuery, [In] UInt32 Id);
        void RemoveFilter([In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pContext, [In] UInt32 Id);
        void RemoveAllFilters([In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pContext);
        void AddDefinitionQuery([In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pContext, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszQuery);
        void RemoveAllDefinitionQueries([In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pContext);
        void Disconnect();
    } // end of IWbemFilterProxy

    [TypeLibTypeAttribute(0x0202)]
    [GuidAttribute("6C19BE35-7500-11D1-AD94-00C04FD8FDFF")]
    [ClassInterfaceAttribute((short)0x0000)]
    [ComImport]
    class WbemFilterProxy  /*: IWbemFilterProxy, IWbemObjectSink*/
    {
    } // end of WbemFilterProxy
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\instrumentation\metadatainfo.cs ===
//------------------------------------------------------------------------------
// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
//    Copyright (c) Microsoft Corporation. All Rights Reserved.                
//    Information Contained Herein is Proprietary and Confidential.            
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Management.Instrumentation
{
    using System;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Runtime.CompilerServices;
    using System.Text;


    /// <summary>
    /// CoClass for getting an IMetaDataDispenser
    /// </summary>
    [ComImport]
    [Guid("E5CB7A31-7512-11d2-89CE-0080C792E5D8")]
    [TypeLibType(TypeLibTypeFlags.FCanCreate) /*0x0002*/]
    [ClassInterface(ClassInterfaceType.None  /*(short)0x0000*/)]
    class CorMetaDataDispenser 
    {
    }

    /// <summary>
    /// This version of the IMetaDataDispenser interface defines
    /// the interfaces so that the last parameter from cor.h
    /// is the return value of the methods.  The 'raw' way to
    /// implement these methods is as follows:
    ///    void OpenScope(
    ///        [In][MarshalAs(UnmanagedType.LPWStr)]  string   szScope,
    ///        [In] UInt32 dwOpenFlags,
    ///        [In] ref Guid riid,
    ///        [Out] out IntPtr ppIUnk);
    /// The way to call this other version is as follows
    ///    IntPtr unk;
    ///    dispenser.OpenScope(assemblyName, 0, ref guidIMetaDataImport, out unk);
    ///    importInterface = (IMetaDataImport)Marshal.GetObjectForIUnknown(unk);
    ///    Marshal.Release(unk);
    /// </summary>
    [ComImport]
    [Guid("809c652e-7396-11d2-9771-00a0c9b4d50c")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown /*0x0001*/)]
    [TypeLibType(TypeLibTypeFlags.FRestricted /*0x0200*/)]
    interface IMetaDataDispenser
    {
        [return:MarshalAs(UnmanagedType.Interface)]
        object DefineScope(
            [In] ref Guid rclsid,
            [In] UInt32  dwCreateFlags,
            [In] ref Guid riid);

        [return:MarshalAs(UnmanagedType.Interface)]
        object OpenScope(
            [In][MarshalAs(UnmanagedType.LPWStr)]  string   szScope,
            [In] UInt32 dwOpenFlags,
            [In] ref Guid riid);

        [return:MarshalAs(UnmanagedType.Interface)]
        object OpenScopeOnMemory(
            [In] IntPtr pData,
            [In] UInt32 cbData,
            [In] UInt32 dwOpenFlags,
            [In] ref Guid riid);
    }


    /// <summary>
    /// This class is an INCOMPLETE IMPLEMENTATION OF IMetaDataImport.  For the purposes of
    /// System.Management.dll, we only needed to call one method, GetScopeProps
    /// </summary>
    [ComImport]
    [Guid("7DAC8207-D3AE-4c75-9B67-92801A497D44")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown /*0x0001*/)]
    [TypeLibType(TypeLibTypeFlags.FRestricted /*0x0200*/)]
    interface IMetaDataImportInternalOnly
    {
        void f1();
        void f2();
        void f3();
        void f4();
        void f5();
        void f6();
        void f7();
        void GetScopeProps(
            [Out][MarshalAs(UnmanagedType.LPWStr)] StringBuilder szName,
            [In] UInt32 cchName,
            [Out] out UInt32 pchName,
            [Out] out Guid pmvid);
    }


    /// <summary>
    /// This class wraps the functionality of IMetaDataImport.  It abstracts the
    /// details of working directly with the interface.
    /// </summary>
    class MetaDataInfo : IDisposable
    {
        public MetaDataInfo(Assembly assembly) : this(assembly.Location) {}

        public MetaDataInfo(string assemblyName)
        {
            // Get guid for IMetaDataImport
            Guid guidIMetaDataImport = new Guid(((GuidAttribute)Attribute.GetCustomAttribute(typeof(IMetaDataImportInternalOnly), typeof(GuidAttribute), false)).Value);

            // Get an IMetaDataImport for the assembly from a dispenser
            IMetaDataDispenser dispenser = (IMetaDataDispenser)new CorMetaDataDispenser();
            importInterface = (IMetaDataImportInternalOnly)dispenser.OpenScope(assemblyName, 0, ref guidIMetaDataImport);
            Marshal.ReleaseComObject(dispenser);
        }

        IMetaDataImportInternalOnly importInterface;

        // These two fields are initialized the first time either is requested
        // They are both retrieved through IMetaDataImport GetScopeProps
        string name = null;
        Guid mvid;

        void InitNameAndMvid()
        {
            // If we have never retrieved the name and MVID, get them now
            if(null==name)
            {
                UInt32 cchName;
                StringBuilder sb = new StringBuilder();
                sb.Capacity = 0;
                importInterface.GetScopeProps(sb, (UInt32)sb.Capacity, out cchName, out mvid);
                sb.Capacity = (int)cchName;
                importInterface.GetScopeProps(sb, (UInt32)sb.Capacity, out cchName, out mvid);
                name = sb.ToString();
            }
        }

        public string Name
        {
            get
            {
                InitNameAndMvid();
                return name;
            }
        }

        public Guid Mvid
        {
            get
            {
                InitNameAndMvid();
                return mvid;
            }
        }

        public void Dispose()
        {
            // We implement IDisposable on this class because the IMetaDataImport
            // can be an expensive object to keep in memory.
            if(importInterface == null)
                Marshal.ReleaseComObject(importInterface);
            importInterface = null;
            GC.SuppressFinalize(this);
        }

        ~MetaDataInfo()
        {
            Dispose();
        }

        public static Guid GetMvid(Assembly assembly)
        {
            using(MetaDataInfo info = new MetaDataInfo(assembly))
            {
                return info.Mvid;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\instrumentation\attributes.cs ===
//------------------------------------------------------------------------------
// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
//    Copyright (c) Microsoft Corporation. All Rights Reserved.                
//    Information Contained Herein is Proprietary and Confidential.            
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Management.Instrumentation
{
    using System;
    using System.Reflection;
    using System.Collections;
    using System.Text.RegularExpressions;
    using System.Management;

    /// <summary>
    /// This attribute needs to appear once on any assembly that provides management instrumentation.
    /// </summary>
    [AttributeUsage(AttributeTargets.Assembly)]
    public class InstrumentedAttribute : Attribute
    {
        string namespaceName;
        string securityDescriptor;

        /// <summary>
        /// Constructor that specifies that instrumentation will be in root\default
        /// </summary>
        public InstrumentedAttribute() : this(null, null) {}

        /// <summary>
        /// Constructor that specifies a namespace for instrumentation within an assembly
        /// </summary>
        /// <param name="namespaceName">Namespace for instrumentation instances and events</param>
        public InstrumentedAttribute(string namespaceName) : this(namespaceName, null) {}

        /// <summary>
        /// Constructor that specifies a namespace and security descriptor for instrumentation within an assembly
        /// </summary>
        /// <param name="namespaceName">Namespace for instrumentation instances and events</param>
        /// <param name="securityDescriptor">
        /// String security descriptor that allows only the specified users or groups to run
        /// applicatoins that provide the instance or event instrumenation supported by this assembly
        /// </param>
        public InstrumentedAttribute(string namespaceName, string securityDescriptor)
        {
            // TODO: Do we need validation
            // bug#62511 - always use backslash in name
            if(namespaceName != null)
                namespaceName = namespaceName.Replace('/', '\\');

            if(namespaceName == null || namespaceName.Length == 0)
                namespaceName = "root\\default"; // bug#60933 Use a default namespace if null


            bool once = true;
            foreach(string namespacePart in namespaceName.Split('\\'))
            {
                if(     namespacePart.Length == 0
                    ||  (once && namespacePart.ToLower() != "root")  // Must start with 'root'
                    ||  !Regex.Match(namespacePart, @"^[a-z,A-Z]").Success // All parts must start with letter
                    ||  Regex.Match(namespacePart, @"_$").Success // Must not end with an underscore
                    ||  Regex.Match(namespacePart, @"[^a-z,A-Z,0-9,_,\u0080-\uFFFF]").Success) // Only letters, digits, or underscores
                {
                    ManagementException.ThrowWithExtendedInfo(ManagementStatus.InvalidNamespace);
                }
                once = false;
            }

            this.namespaceName = namespaceName;
            this.securityDescriptor = securityDescriptor;
        }

        /// <summary>
        /// Namespace for instrumentation instances and events in this assembly
        /// </summary>
        public string NamespaceName 
        {
            get { return namespaceName == null ? string.Empty : namespaceName; }
        }
        
        /// <summary>
        /// String security descriptor that allows only the specified users or groups to run
        /// applicatoins that provide the instance or event instrumenation supported by this assembly
        /// </summary>
        public string SecurityDescriptor
        {
            get
            {
                // This will never return an empty string.  Instead, it will
                // return null, or a non-zero length string
                if(null == securityDescriptor || securityDescriptor.Length == 0)
                    return null;
                return securityDescriptor;
            }
        }

        internal static InstrumentedAttribute GetAttribute(Assembly assembly)
        {
            Object [] rg = assembly.GetCustomAttributes(typeof(InstrumentedAttribute), false);
            if(rg.Length > 0)
                return ((InstrumentedAttribute)rg[0]);
            return null;
        }

        internal static Type[] GetInstrumentedTypes(Assembly assembly)
        {
            ArrayList types = new ArrayList();
            GetInstrumentedDerivedTypes(assembly, types, null);
            return (Type[])types.ToArray(typeof(Type));
        }

        static void GetInstrumentedDerivedTypes(Assembly assembly, ArrayList types, Type typeParent)
        {
            foreach(Type type in assembly.GetTypes())
            {
                if(IsInstrumentationClass(type) && InstrumentationClassAttribute.GetBaseInstrumentationType(type) == typeParent)
                {
                    types.Add(type);
                    GetInstrumentedDerivedTypes(assembly, types, type);
                }
            }
        }

        static bool IsInstrumentationClass(Type type)
        {
            return (null != InstrumentationClassAttribute.GetAttribute(type));
        }

    }
    
    /// <summary>
    /// Specifies the type of instrumentation provided by a class
    /// </summary>
    public enum InstrumentationType
    {
        /// <summary>
        /// The class provides instances for management instrumentation
        /// </summary>
        Instance,
        /// <summary>
        /// The class provides events for management instrumentation
        /// </summary>
        Event,
        /// <summary>
        /// The class defines an abstract class for management instrumentation
        /// </summary>
        Abstract
    }

    /// <summary>
    /// This attribute specifies that a class provides event or instance instrumentaiton
    /// </summary>
    [AttributeUsage(AttributeTargets.Class)]
    public class InstrumentationClassAttribute : Attribute
    {
        InstrumentationType instrumentationType;
        string managedBaseClassName;

        /// <summary>
        /// Use this constructor if you are deriving this type from another
        /// type that has the InstrumentationClass attribute, or if this
        /// is a top level Instrumentation class (ie: an instance or abstract class
        /// without a base class, or an event derived from __ExtrinsicEvent
        /// </summary>
        /// <param name="instrumentationType">The type of instrumentation provided by this class</param>
        public InstrumentationClassAttribute(InstrumentationType instrumentationType)
        {
            this.instrumentationType = instrumentationType;
        }

        /// <summary>
        /// Use this constructor if you are creating a instrumentation class that
        /// has schema for an existing base class.  The class must contain
        /// proper member definitions for the properties of the existing
        /// WMI base class.  The members that are from the base class must
        /// be marked with the InheritedProperty attribute.
        /// </summary>
        /// <param name="instrumentationType">The type of instrumentation provided by this class</param>
        /// <param name="managedBaseClassName">Name of base class</param>
        public InstrumentationClassAttribute(InstrumentationType instrumentationType, string managedBaseClassName)
        {
            this.instrumentationType = instrumentationType;
            this.managedBaseClassName = managedBaseClassName;
        }

        /// <summary>
        /// The type of instrumentation provided by this class
        /// </summary>
        public InstrumentationType InstrumentationType
        {
            get { return instrumentationType; }
        }

        /// <summary>
        /// The name of the base class of this instrumentation class
        /// </summary>
        public string ManagedBaseClassName
        {
            get
            {
                // This will never return an empty string.  Instead, it will
                // return null, or a non-zero length string
                if(null == managedBaseClassName || managedBaseClassName.Length == 0)
                    return null;

                return managedBaseClassName;
            }
        }

        internal static InstrumentationClassAttribute GetAttribute(Type type)
        {
            Object [] rg = type.GetCustomAttributes(typeof(InstrumentationClassAttribute), false);
            if(rg.Length > 0)
                return ((InstrumentationClassAttribute)rg[0]);
            return null;
        }

        /// <summary>
        /// If this class is derived from another instrumentation class, this
        /// returns the Type of that class.  Otherwise, it return null.
        /// </summary>
        /// <param name="type"> </param>
        internal static Type GetBaseInstrumentationType(Type type)
        {
            // If the BaseType has a InstrumentationClass attribute,
            // we return the BaseType
            if(GetAttribute(type.BaseType) != null)
                return type.BaseType;
            return null;
        }
    }

    /// <summary>
    /// This attribute allows an instrumented class, or member of an instrumented clss
    /// to present an alternate name through management instrumentation
    /// </summary>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Field | AttributeTargets.Property  | AttributeTargets.Method)]
    public class ManagedNameAttribute : Attribute
    {
        string name;

        /// <summary>
        /// This constructor allows the alternate name to be specified for the
        /// ype, field, property, method, or paramter that this attribute is applied to.
        /// </summary>
        /// <param name="name"></param>
        public ManagedNameAttribute(string name)
        {
            this.name = name;
        }

        internal static string GetMemberName(MemberInfo member)
        {
            // This works for all sorts of things: Type, MethodInfo, PropertyInfo, FieldInfo
            Object [] rg = member.GetCustomAttributes(typeof(ManagedNameAttribute), false);
            if(rg.Length > 0)
            {
                // bug#69115 - if null or empty string are passed, we just ignore this attribute
                ManagedNameAttribute attr = (ManagedNameAttribute)rg[0];
                if(attr.name != null && attr.name.Length != 0)
                    return attr.name;
            }

            return member.Name;
        }

        internal static string GetBaseClassName(Type type)
        {
            InstrumentationClassAttribute attr = InstrumentationClassAttribute.GetAttribute(type);
            string name = attr.ManagedBaseClassName;
            if(name != null)
                return name;
            
            // Get managed base type's attribute
            InstrumentationClassAttribute attrParent = InstrumentationClassAttribute.GetAttribute(type.BaseType);

            // If the base type does not have a InstrumentationClass attribute,
            // return a base type based on the InstrumentationType
            if(null == attrParent)
            {
                switch(attr.InstrumentationType)
                {
                    case InstrumentationType.Abstract:
                        return null;
                    case InstrumentationType.Instance:
                        return null;
                    case InstrumentationType.Event:
                        return "__ExtrinsicEvent";
                    default:
                        break;
                }
            }

            // Our parent was also a managed provider type.  Use it's managed name.
            return GetMemberName(type.BaseType);
        }
    }

    /// <summary>
    /// This attribute allows a particular member of an instrumented class to be ignored
    /// by management instrumentation
    /// </summary>
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property  | AttributeTargets.Method)]
    public class IgnoreMemberAttribute : Attribute
    {
    }

#if REQUIRES_EXPLICIT_DECLARATION_OF_INHERITED_PROPERTIES
    [AttributeUsage(AttributeTargets.Field)]
    public class InheritedPropertyAttribute : Attribute
    {
        internal static InheritedPropertyAttribute GetAttribute(FieldInfo field)
        {
            Object [] rg = field.GetCustomAttributes(typeof(InheritedPropertyAttribute), false);
            if(rg.Length > 0)
                return ((InheritedPropertyAttribute)rg[0]);
            return null;
        }
    }
#endif

#if SUPPORTS_WMI_DEFAULT_VAULES
    [AttributeUsage(AttributeTargets.Field)]
    internal class ManagedDefaultValueAttribute : Attribute
    {
        Object defaultValue;
        public ManagedDefaultValueAttribute(Object defaultValue)
        {
            this.defaultValue = defaultValue;
        }

        public static Object GetManagedDefaultValue(FieldInfo field)
        {
            Object [] rg = field.GetCustomAttributes(typeof(ManagedDefaultValueAttribute), false);
            if(rg.Length > 0)
                return ((ManagedDefaultValueAttribute)rg[0]).defaultValue;

            return null;
        }
    }
#endif

#if SUPPORTS_ALTERNATE_WMI_PROPERTY_TYPE
    [AttributeUsage(AttributeTargets.Field)]
    internal class ManagedTypeAttribute : Attribute
    {
        Type type;
        public ManagedTypeAttribute(Type type)
        {
            this.type = type;
        }

        public static Type GetManagedType(FieldInfo field)
        {
            Object [] rg = field.GetCustomAttributes(typeof(ManagedTypeAttribute), false);
            if(rg.Length > 0)
                return ((ManagedTypeAttribute)rg[0]).type;

            return field.FieldType;
        }
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\interopclasses\wmiinterop.cs ===
using System;
using System.Runtime.InteropServices;
using System.Security;
using System.Runtime.Serialization;

namespace WbemClient_v1 {}
namespace WbemUtilities_v1 {}

namespace System.Management
{
	#region FreeThreadedInterfaces
    sealed class IWbemClassObjectFreeThreaded : IDisposable, ISerializable
    {
        const string DllName = "WMINet_Utils.dll";
        const string EntryPointName = "UFunc";
        const string SerializationBlobName = "flatWbemClassObject";
        static readonly string name = typeof(IWbemClassObjectFreeThreaded).FullName;
        public static Guid IID_IWbemClassObject = new Guid("DC12A681-737F-11CF-884D-00AA004B2E24");

        IntPtr pWbemClassObject = IntPtr.Zero;

        public IWbemClassObjectFreeThreaded(IntPtr pWbemClassObject)
        {
            // This instance will now own a single ref count on pWbemClassObject
            this.pWbemClassObject = pWbemClassObject;
        }

        public static implicit operator IntPtr(IWbemClassObjectFreeThreaded wbemClassObject)
        {
            if(null == wbemClassObject)
                return IntPtr.Zero;
            return wbemClassObject.pWbemClassObject;
        }

        public IWbemClassObjectFreeThreaded(SerializationInfo info, StreamingContext context)
        {
            Byte[] rg = info.GetValue(SerializationBlobName, typeof(Byte[])) as Byte[];
            if(null == rg)
                throw new SerializationException();

            DeserializeFromBlob(rg);
        }

        void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue(SerializationBlobName, SerializeToBlob());
        }

        public void Dispose()
        {
            if(pWbemClassObject != IntPtr.Zero)
            {
                Marshal.Release(pWbemClassObject);
                pWbemClassObject = IntPtr.Zero;
            }
            GC.SuppressFinalize(this);
        }

        ~IWbemClassObjectFreeThreaded()
        {
            Dispose();
        }

        void DeserializeFromBlob(Byte [] rg)
        {
            IntPtr hGlobal = IntPtr.Zero;
            UCOMIStream stream = null;
            try
            {
                // If something goes wrong, we want to make sure the object is invalidated
                pWbemClassObject = IntPtr.Zero;

                hGlobal = Marshal.AllocHGlobal(rg.Length);
                Marshal.Copy(rg, 0, hGlobal, rg.Length);
                stream = CreateStreamOnHGlobal(hGlobal, 0);
                pWbemClassObject = CoUnmarshalInterface(stream, ref IID_IWbemClassObject);
            }
            finally
            {
                if(stream != null)
                    Marshal.ReleaseComObject(stream);
                if(hGlobal != IntPtr.Zero)
                    Marshal.FreeHGlobal(hGlobal);
            }
        }

        Byte[] SerializeToBlob()
        {
            Byte [] rg = null;
            UCOMIStream stream = null;
            try
            {
                // Stream will own the HGlobal
                stream = CreateStreamOnHGlobal(IntPtr.Zero, 1);

                CoMarshalInterface(stream, ref IID_IWbemClassObject, pWbemClassObject, (UInt32)MSHCTX.MSHCTX_DIFFERENTMACHINE, IntPtr.Zero, (UInt32)MSHLFLAGS.MSHLFLAGS_TABLEWEAK);

                STATSTG statstg;
                stream.Stat(out statstg, (int)STATFLAG.STATFLAG_DEFAULT);
                rg = new Byte[statstg.cbSize];

                Marshal.Copy(GetHGlobalFromStream(stream), rg, 0, (int)statstg.cbSize);
            }
            finally
            {
                if(stream != null)
                    Marshal.ReleaseComObject(stream);
            }
            return rg;
        }

        // Interface methods
        public int GetQualifierSet_(out IWbemQualifierSetFreeThreaded ppQualSet)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            IntPtr pQualSet;
            int hResult = GetQualifierSet_f(3, pWbemClassObject, out pQualSet);
            if(hResult < 0)
                ppQualSet = null;
            else
                ppQualSet = new IWbemQualifierSetFreeThreaded(pQualSet);
            return hResult;
        }
        public int Get_(string wszName, Int32 lFlags, ref object pVal, ref Int32 pType, ref Int32 plFlavor)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            int hr = Get_f(4, pWbemClassObject, wszName, lFlags, ref pVal, ref pType, ref plFlavor);
            // There is a BUG in WMI where some instances (events and out params from method invocations)
            // do not have a __PATH property.  Unfortunately, GetNames says the object DOES have a __PATH
            // property.  Going under the assumption that __PATH should always exist, we make a slight fixup
            // if we detect a missing __PATH
            if(hr == (int)ManagementStatus.InvalidObject)
            {
                // We optimize the quick string comparison before trying the case insensitive comparison
                if(wszName == "__PATH" || wszName.ToLower() == "__path")
                {
                    hr = 0;
                    pType = (Int32)tag_CIMTYPE_ENUMERATION.CIM_STRING;
                    plFlavor = (Int32)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_ORIGIN_SYSTEM;
                    pVal = DBNull.Value;
                }
            }
            return hr;
        }
        public int Put_(string wszName, Int32 lFlags, ref object pVal, Int32 Type)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return Put_f(5, pWbemClassObject, wszName, lFlags, ref pVal, Type);
        }
        public int Delete_(string wszName)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return Delete_f(6, pWbemClassObject, wszName);
        }
        public int GetNames_(string wszQualifierName, Int32 lFlags, ref object pQualifierVal, out string[] pNames)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return GetNames_f(7, pWbemClassObject, wszQualifierName, lFlags, ref pQualifierVal, out pNames);
        }
        public int BeginEnumeration_(Int32 lEnumFlags)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return BeginEnumeration_f(8, pWbemClassObject, lEnumFlags);
        }
        public int Next_(Int32 lFlags, ref string strName, ref object pVal, ref Int32 pType, ref Int32 plFlavor)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return Next_f(9, pWbemClassObject, lFlags, ref strName, ref pVal, ref pType, ref plFlavor);
        }
        public int EndEnumeration_()
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return EndEnumeration_f(10, pWbemClassObject);
        }
        public int GetPropertyQualifierSet_(string wszProperty, out IWbemQualifierSetFreeThreaded ppQualSet)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            IntPtr pQualSet;
            int hResult = GetPropertyQualifierSet_f(11, pWbemClassObject, wszProperty, out pQualSet);
            if(hResult < 0)
                ppQualSet = null;
            else
                ppQualSet = new IWbemQualifierSetFreeThreaded(pQualSet);
            return hResult;
        }
        public int Clone_(out IWbemClassObjectFreeThreaded ppCopy)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            IntPtr pWbemClassObjectNew;
            int hResult = Clone_f(12, pWbemClassObject, out pWbemClassObjectNew);
            if(hResult < 0)
                ppCopy = null;
            else
                ppCopy = new IWbemClassObjectFreeThreaded(pWbemClassObjectNew);
            return hResult;
        }
        public int GetObjectText_(Int32 lFlags, out string pstrObjectText)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return GetObjectText_f(13, pWbemClassObject, lFlags, out pstrObjectText);
        }
        public int SpawnDerivedClass_(Int32 lFlags, out IWbemClassObjectFreeThreaded ppNewClass)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            IntPtr pWbemClassObjectNew;
            int hResult = SpawnDerivedClass_f(14, pWbemClassObject, lFlags, out pWbemClassObjectNew);
            if(hResult < 0)
                ppNewClass = null;
            else
                ppNewClass = new IWbemClassObjectFreeThreaded(pWbemClassObjectNew);
            return hResult;
        }
        public int SpawnInstance_(Int32 lFlags, out IWbemClassObjectFreeThreaded ppNewInstance)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            IntPtr pWbemClassObjectNew;
            int hResult = SpawnInstance_f(15, pWbemClassObject, lFlags, out pWbemClassObjectNew);
            if(hResult < 0)
                ppNewInstance = null;
            else
                ppNewInstance = new IWbemClassObjectFreeThreaded(pWbemClassObjectNew);
            return hResult;
        }
        public int CompareTo_(Int32 lFlags, IWbemClassObjectFreeThreaded pCompareTo)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return CompareTo_f(16, pWbemClassObject, lFlags, pCompareTo.pWbemClassObject);
        }
        public int GetPropertyOrigin_(string wszName, out string pstrClassName)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return GetPropertyOrigin_f(17, pWbemClassObject, wszName, out pstrClassName);
        }
        public int InheritsFrom_(string strAncestor)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return InheritsFrom_f(18, pWbemClassObject, strAncestor);
        }
        public int GetMethod_(string wszName, Int32 lFlags, out IWbemClassObjectFreeThreaded ppInSignature, out IWbemClassObjectFreeThreaded ppOutSignature)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            IntPtr pInSignature;
            IntPtr pOutSignature;
            int hResult = GetMethod_f(19, pWbemClassObject, wszName, lFlags, out pInSignature, out pOutSignature);
            ppInSignature = null;
            ppOutSignature = null;
            if(hResult >= 0)
            {
                // This can be NULL
                if(pInSignature != IntPtr.Zero)
                    ppInSignature = new IWbemClassObjectFreeThreaded(pInSignature);
                if(pOutSignature != IntPtr.Zero)
                    ppOutSignature = new IWbemClassObjectFreeThreaded(pOutSignature);
            }
            return hResult;
        }
        public int PutMethod_(string wszName, Int32 lFlags, IWbemClassObjectFreeThreaded pInSignature, IWbemClassObjectFreeThreaded pOutSignature)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return PutMethod_f(20, pWbemClassObject, wszName, lFlags, pInSignature, pOutSignature);
        }
        public int DeleteMethod_(string wszName)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return DeleteMethod_f(21, pWbemClassObject, wszName);
        }
        public int BeginMethodEnumeration_(Int32 lEnumFlags)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return BeginMethodEnumeration_f(22, pWbemClassObject, lEnumFlags);
        }
        public int NextMethod_(Int32 lFlags, out string pstrName, out IWbemClassObjectFreeThreaded ppInSignature, out IWbemClassObjectFreeThreaded ppOutSignature)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);

            // TODO: Provide overload which optionally only gets the name param
            IntPtr pInSignature;
            IntPtr pOutSignature;
            int hResult = NextMethod_f(23, pWbemClassObject, lFlags, out pstrName, out pInSignature, out pOutSignature);
            ppInSignature = null;
            ppOutSignature = null;
            if(hResult >= 0)
            {
                // This can be NULL
                if(pInSignature != IntPtr.Zero)
                    ppInSignature = new IWbemClassObjectFreeThreaded(pInSignature);
                if(pOutSignature != IntPtr.Zero)
                    ppOutSignature = new IWbemClassObjectFreeThreaded(pOutSignature);
            }
            return hResult;
        }
        public int EndMethodEnumeration_()
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return EndMethodEnumeration_f(24, pWbemClassObject);
        }
        public int GetMethodQualifierSet_(string wszMethod, out IWbemQualifierSetFreeThreaded ppQualSet)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            IntPtr pQualSet;
            int hResult = GetMethodQualifierSet_f(25, pWbemClassObject, wszMethod, out pQualSet);
            if(hResult < 0)
                ppQualSet = null;
            else
                ppQualSet = new IWbemQualifierSetFreeThreaded(pQualSet);
            return hResult;
        }
        public int GetMethodOrigin_(string wszMethodName, out string pstrClassName)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return GetMethodOrigin_f(26, pWbemClassObject, wszMethodName, out pstrClassName);
        }

        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int GetQualifierSet_f(int vFunc, IntPtr pWbemClassObject, [Out] out IntPtr ppQualSet);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int Get_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In][Out] ref object pVal, [In][Out] ref Int32 pType, [In][Out] ref Int32 plFlavor);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int Put_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In] ref object pVal, [In] Int32 Type);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int Delete_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int GetNames_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszQualifierName, [In] Int32 lFlags, [In] ref object pQualifierVal, [Out][MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_BSTR)]  out string[]   pNames);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int BeginEnumeration_f(int vFunc, IntPtr pWbemClassObject, [In] Int32 lEnumFlags);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int Next_f(int vFunc, IntPtr pWbemClassObject, [In] Int32 lFlags, [In][Out][MarshalAs(UnmanagedType.BStr)]  ref string   strName, [In][Out] ref object pVal, [In][Out] ref Int32 pType, [In][Out] ref Int32 plFlavor);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int EndEnumeration_f(int vFunc, IntPtr pWbemClassObject);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int GetPropertyQualifierSet_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszProperty, [Out] out IntPtr ppQualSet);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int Clone_f(int vFunc, IntPtr pWbemClassObject, [Out] out IntPtr ppCopy);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int GetObjectText_f(int vFunc, IntPtr pWbemClassObject, [In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrObjectText);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int SpawnDerivedClass_f(int vFunc, IntPtr pWbemClassObject, [In] Int32 lFlags, [Out] out IntPtr ppNewClass);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int SpawnInstance_f(int vFunc, IntPtr pWbemClassObject, [In] Int32 lFlags, [Out] out IntPtr ppNewInstance);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int CompareTo_f(int vFunc, IntPtr pWbemClassObject, [In] Int32 lFlags, [In] IntPtr pCompareTo);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int GetPropertyOrigin_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrClassName);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int InheritsFrom_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   strAncestor);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int GetMethod_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [Out]out IntPtr ppInSignature, [Out] out IntPtr ppOutSignature);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int PutMethod_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In] IntPtr pInSignature, [In] IntPtr pOutSignature);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int DeleteMethod_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int BeginMethodEnumeration_f(int vFunc, IntPtr pWbemClassObject, [In] Int32 lEnumFlags);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int NextMethod_f(int vFunc, IntPtr pWbemClassObject, [In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.BStr)] out string pstrName, [Out] out IntPtr ppInSignature, [Out] out IntPtr ppOutSignature);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int EndMethodEnumeration_f(int vFunc, IntPtr pWbemClassObject);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int GetMethodQualifierSet_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszMethod, [Out] out IntPtr ppQualSet);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int GetMethodOrigin_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszMethodName, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrClassName);

        enum STATFLAG 
        {
            STATFLAG_DEFAULT    = 0,
            STATFLAG_NONAME     = 1
        }

        enum MSHCTX
        {
            MSHCTX_LOCAL               = 0,
            MSHCTX_NOSHAREDMEM         = 1,
            MSHCTX_DIFFERENTMACHINE    = 2,
            MSHCTX_INPROC              = 3 
        }

        enum MSHLFLAGS 
        {
            MSHLFLAGS_NORMAL         = 0,
            MSHLFLAGS_TABLESTRONG    = 1,
            MSHLFLAGS_TABLEWEAK      = 2,
            MSHLFLAGS_NOPING         = 3
        }

        [DllImport("ole32.dll", PreserveSig=false)]
        static extern UCOMIStream CreateStreamOnHGlobal(IntPtr hGlobal, int fDeleteOnRelease);

        [DllImport("ole32.dll", PreserveSig=false)]
        static extern IntPtr GetHGlobalFromStream([In] UCOMIStream pstm);

        [DllImport("ole32.dll", PreserveSig=false)]
        static extern void CoGetMarshalSizeMax(
            [In] ref UInt32 ulSize,      //Pointer to the upper-bound value
            [In] ref Guid riid,         //Reference to the identifier of the interface
            [In] IntPtr Unk,      //Pointer to the interface to be marshaled
            [In] UInt32 dwDestContext,  //Destination process
            [In] IntPtr pvDestContext,   //Reserved for future use
            [In] UInt32 mshlflags       //Reason for marshaling
            );

        [DllImport("ole32.dll", PreserveSig=false)]
        static extern void CoMarshalInterface(
            [In] UCOMIStream pStm,        //Pointer to the stream used for marshaling
            [In] ref Guid riid,          //Reference to the identifier of the 
            [In] IntPtr Unk,      //Pointer to the interface to be marshaled
            [In] UInt32 dwDestContext,  //Destination process
            [In] IntPtr pvDestContext,   //Reserved for future use
            [In] UInt32 mshlflags       //Reason for marshaling
            );

        [DllImport("ole32.dll", PreserveSig=false)]
        static extern IntPtr CoUnmarshalInterface(
            [In] UCOMIStream pStm,  //Pointer to the stream
            [In] ref Guid riid     //Reference to the identifier of the interface
            );
    }

    sealed class IWbemQualifierSetFreeThreaded
    {
        const string DllName = "WMINet_Utils.dll";
        const string EntryPointName = "UFunc";
        const string SerializationBlobName = "flatWbemClassObject";
        static readonly string name = typeof(IWbemQualifierSetFreeThreaded).FullName;
        public static Guid IID_IWbemClassObject = new Guid("DC12A681-737F-11CF-884D-00AA004B2E24");

        IntPtr pWbemQualifierSet = IntPtr.Zero;
        public IWbemQualifierSetFreeThreaded(IntPtr pWbemQualifierSet)
        {
            // This instance will now own a single ref count on pWbemClassObject
            this.pWbemQualifierSet = pWbemQualifierSet;
        }

        public int Get_(string wszName, Int32 lFlags, ref object pVal, ref Int32 plFlavor)
        {
            if(pWbemQualifierSet == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return Get_f(3, pWbemQualifierSet, wszName, lFlags, ref pVal, ref plFlavor);
        }
        public int Put_(string wszName, ref object pVal, Int32 lFlavor)
        {
            if(pWbemQualifierSet == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return Put_f(4, pWbemQualifierSet, wszName, ref pVal, lFlavor);
        }
        public int Delete_(string wszName)
        {
            if(pWbemQualifierSet == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return Delete_f(5, pWbemQualifierSet, wszName);
        }
        public int GetNames_(Int32 lFlags, out string[] pNames)
        {
            if(pWbemQualifierSet == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return GetNames_f(6, pWbemQualifierSet, lFlags, out pNames);
        }
        public int BeginEnumeration_(Int32 lFlags)
        {
            if(pWbemQualifierSet == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return BeginEnumeration_f(7, pWbemQualifierSet, lFlags);
        }
        public int Next_(Int32 lFlags, out string pstrName, out object pVal, out Int32 plFlavor)
        {
            if(pWbemQualifierSet == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return Next_f(8, pWbemQualifierSet, lFlags, out pstrName, out pVal, out plFlavor);
        }
        public int EndEnumeration_()
        {
            if(pWbemQualifierSet == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return EndEnumeration_f(9, pWbemQualifierSet);
        }

        
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int Get_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In][Out] ref object pVal, [In][Out] ref Int32 plFlavor);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int Put_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] ref object pVal, [In] Int32 lFlavor);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int Delete_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int GetNames_f(int vFunc, IntPtr pWbemClassObject, [In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_BSTR)]  out string[]   pNames);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int BeginEnumeration_f(int vFunc, IntPtr pWbemClassObject, [In] Int32 lFlags);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int Next_f(int vFunc, IntPtr pWbemClassObject, [In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrName, [Out] out object pVal, [Out] out Int32 plFlavor);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int EndEnumeration_f(int vFunc, IntPtr pWbemClassObject);
    }

    class MarshalWbemObject : ICustomMarshaler 
    {
        public static ICustomMarshaler GetInstance(string cookie)
        {
            return new MarshalWbemObject(cookie);
        }

        string cookie;
        MarshalWbemObject(string cookie)
        {
            this.cookie = cookie;
        }

        public void CleanUpManagedData(object obj) 
        {
        }

        public void CleanUpNativeData(IntPtr pObj) 
        {
//            Marshal.Release(pObj);
        }

        public int GetNativeDataSize() 
        {
            return -1; // not a value type, so use -1
        }

        public IntPtr MarshalManagedToNative(object obj) 
        {
            return (IntPtr)obj;
        }

        public object MarshalNativeToManaged(IntPtr pObj) 
        {
            return new IWbemClassObjectFreeThreaded(pObj);
        }
    }
	#endregion

    #region Interfaces
    [InterfaceTypeAttribute(0x0001)]
    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("DC12A681-737F-11CF-884D-00AA004B2E24")]
    [ComImport]
    interface IWbemClassObject_DoNotMarshal
    {
        [PreserveSig] int GetQualifierSet_([Out][MarshalAs(UnmanagedType.Interface)]  out IWbemQualifierSet_DoNotMarshal   ppQualSet);
        [PreserveSig] int Get_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In][Out] ref object pVal, [In][Out] ref Int32 pType, [In][Out] ref Int32 plFlavor);
        [PreserveSig] int Put_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In] ref object pVal, [In] Int32 Type);
        [PreserveSig] int Delete_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName);
        [PreserveSig] int GetNames_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszQualifierName, [In] Int32 lFlags, [In] ref object pQualifierVal, [Out][MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_BSTR)]  out string[]   pNames);
        [PreserveSig] int BeginEnumeration_([In] Int32 lEnumFlags);
        [PreserveSig] int Next_([In] Int32 lFlags, [In][Out][MarshalAs(UnmanagedType.BStr)]  ref string   strName, [In][Out] ref object pVal, [In][Out] ref Int32 pType, [In][Out] ref Int32 plFlavor);
        [PreserveSig] int EndEnumeration_();
        [PreserveSig] int GetPropertyQualifierSet_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszProperty, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemQualifierSet_DoNotMarshal   ppQualSet);
        [PreserveSig] int Clone_([Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject_DoNotMarshal   ppCopy);
        [PreserveSig] int GetObjectText_([In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrObjectText);
        [PreserveSig] int SpawnDerivedClass_([In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject_DoNotMarshal   ppNewClass);
        [PreserveSig] int SpawnInstance_([In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject_DoNotMarshal   ppNewInstance);
        [PreserveSig] int CompareTo_([In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pCompareTo);
        [PreserveSig] int GetPropertyOrigin_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrClassName);
        [PreserveSig] int InheritsFrom_([In][MarshalAs(UnmanagedType.LPWStr)]  string   strAncestor);
        [PreserveSig] int GetMethod_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject_DoNotMarshal   ppInSignature, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject_DoNotMarshal   ppOutSignature);
        [PreserveSig] int PutMethod_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pInSignature, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pOutSignature);
        [PreserveSig] int DeleteMethod_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName);
        [PreserveSig] int BeginMethodEnumeration_([In] Int32 lEnumFlags);
        [PreserveSig] int NextMethod_([In] Int32 lFlags, [In][Out][MarshalAs(UnmanagedType.BStr)]  ref string   pstrName, [In][Out][MarshalAs(UnmanagedType.Interface)]  ref IWbemClassObject_DoNotMarshal   ppInSignature, [In][Out][MarshalAs(UnmanagedType.Interface)]  ref IWbemClassObject_DoNotMarshal   ppOutSignature);
        [PreserveSig] int EndMethodEnumeration_();
        [PreserveSig] int GetMethodQualifierSet_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszMethod, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemQualifierSet_DoNotMarshal   ppQualSet);
        [PreserveSig] int GetMethodOrigin_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszMethodName, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrClassName);
    }

    [InterfaceTypeAttribute(0x0001)]
    [GuidAttribute("DC12A680-737F-11CF-884D-00AA004B2E24")]
    [TypeLibTypeAttribute(0x0200)]
    [ComImport]
    interface IWbemQualifierSet_DoNotMarshal
    {
        [PreserveSig] int Get_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In][Out] ref object pVal, [In][Out] ref Int32 plFlavor);
        [PreserveSig] int Put_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] ref object pVal, [In] Int32 lFlavor);
        [PreserveSig] int Delete_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName);
        [PreserveSig] int GetNames_([In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_BSTR)]  out string[]   pNames);
        [PreserveSig] int BeginEnumeration_([In] Int32 lFlags);
        [PreserveSig] int Next_([In] Int32 lFlags, [In][Out][MarshalAs(UnmanagedType.BStr)]  ref string   pstrName, [In][Out] ref object pVal, [In][Out] ref Int32 plFlavor);
        [PreserveSig] int EndEnumeration_();
    }

    [InterfaceTypeAttribute(0x0001)]
    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("DC12A687-737F-11CF-884D-00AA004B2E24")]
    [ComImport]
    interface IWbemLocator
    {
        [PreserveSig] int ConnectServer_([In][MarshalAs(UnmanagedType.BStr)]  string   strNetworkResource, [In][MarshalAs(UnmanagedType.BStr)]  string   strUser, [In][MarshalAs(UnmanagedType.BStr)]  string   strPassword, [In][MarshalAs(UnmanagedType.BStr)]  string   strLocale, [In] Int32 lSecurityFlags, [In][MarshalAs(UnmanagedType.BStr)]  string   strAuthority, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemServices   ppNamespace);
    }

    [GuidAttribute("44ACA674-E8FC-11D0-A07C-00C04FB68820")]
    [TypeLibTypeAttribute(0x0200)]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemContext
    {
        [PreserveSig] int Clone_([Out][MarshalAs(UnmanagedType.Interface)]  out IWbemContext   ppNewCopy);
        [PreserveSig] int GetNames_([In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_BSTR)]  out string[]   pNames);
        [PreserveSig] int BeginEnumeration_([In] Int32 lFlags);
        [PreserveSig] int Next_([In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrName, [Out] out object pValue);
        [PreserveSig] int EndEnumeration_();
        [PreserveSig] int SetValue_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In] ref object pValue);
        [PreserveSig] int GetValue_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [Out] out object pValue);
        [PreserveSig] int DeleteValue_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags);
        [PreserveSig] int DeleteAll_();
    }

    [InterfaceTypeAttribute(0x0001)]
    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("9556DC99-828C-11CF-A37E-00AA003240C7")]
    [ComImport]
    interface IWbemServices
    {
        [PreserveSig] int OpenNamespace_([In][MarshalAs(UnmanagedType.BStr)]  string   strNamespace, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][Out][MarshalAs(UnmanagedType.Interface)]  ref IWbemServices   ppWorkingNamespace, [In] IntPtr ppCallResult);
        [PreserveSig] int CancelAsyncCall_([In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pSink);
        [PreserveSig] int QueryObjectSink_([In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemObjectSink   ppResponseHandler);
        [PreserveSig] int GetObject_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [Out][MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(MarshalWbemObject))] out IWbemClassObjectFreeThreaded ppObject, [In] IntPtr ppCallResult);
        [PreserveSig] int GetObjectAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int PutClass_([In] IntPtr pObject, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In] IntPtr ppCallResult);
        [PreserveSig] int PutClassAsync_([In] IntPtr pObject, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int DeleteClass_([In][MarshalAs(UnmanagedType.BStr)]  string   strClass, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In] IntPtr ppCallResult);
        [PreserveSig] int DeleteClassAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strClass, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int CreateClassEnum_([In][MarshalAs(UnmanagedType.BStr)]  string   strSuperclass, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject   ppEnum);
        [PreserveSig] int CreateClassEnumAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strSuperclass, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int PutInstance_([In] IntPtr pInst, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In] IntPtr ppCallResult);
        [PreserveSig] int PutInstanceAsync_([In] IntPtr pInst, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int DeleteInstance_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In] IntPtr ppCallResult);
        [PreserveSig] int DeleteInstanceAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int CreateInstanceEnum_([In][MarshalAs(UnmanagedType.BStr)]  string   strFilter, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject   ppEnum);
        [PreserveSig] int CreateInstanceEnumAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strFilter, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int ExecQuery_([In][MarshalAs(UnmanagedType.BStr)]  string   strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)]  string   strQuery, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject   ppEnum);
        [PreserveSig] int ExecQueryAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)]  string   strQuery, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int ExecNotificationQuery_([In][MarshalAs(UnmanagedType.BStr)]  string   strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)]  string   strQuery, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject   ppEnum);
        [PreserveSig] int ExecNotificationQueryAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)]  string   strQuery, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int ExecMethod_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath, [In][MarshalAs(UnmanagedType.BStr)]  string   strMethodName, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In] IntPtr pInParams, [Out][MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(MarshalWbemObject))] out IWbemClassObjectFreeThreaded ppOutParams, [In] IntPtr ppCallResult);
        [PreserveSig] int ExecMethodAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath, [In][MarshalAs(UnmanagedType.BStr)]  string   strMethodName, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In] IntPtr pInParams, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
    }

    [InterfaceTypeAttribute(0x0001)]
    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("9556DC99-828C-11CF-A37E-00AA003240C7")]
    [ComImport]
    interface IWbemServices_Old
    {
        [PreserveSig] int OpenNamespace_([In][MarshalAs(UnmanagedType.BStr)]  string   strNamespace, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][Out][MarshalAs(UnmanagedType.Interface)]  ref IWbemServices   ppWorkingNamespace, [In] IntPtr ppCallResult);
        [PreserveSig] int CancelAsyncCall_([In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pSink);
        [PreserveSig] int QueryObjectSink_([In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemObjectSink   ppResponseHandler);
        [PreserveSig] int GetObject_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][Out][MarshalAs(UnmanagedType.Interface)]  ref IWbemClassObject_DoNotMarshal   ppObject, [In] IntPtr ppCallResult);
        [PreserveSig] int GetObjectAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int PutClass_([In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pObject, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In] IntPtr ppCallResult);
        [PreserveSig] int PutClassAsync_([In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pObject, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int DeleteClass_([In][MarshalAs(UnmanagedType.BStr)]  string   strClass, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In] IntPtr ppCallResult);
        [PreserveSig] int DeleteClassAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strClass, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int CreateClassEnum_([In][MarshalAs(UnmanagedType.BStr)]  string   strSuperclass, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject   ppEnum);
        [PreserveSig] int CreateClassEnumAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strSuperclass, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int PutInstance_([In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pInst, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In] IntPtr ppCallResult);
        [PreserveSig] int PutInstanceAsync_([In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pInst, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int DeleteInstance_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In] IntPtr ppCallResult);
        [PreserveSig] int DeleteInstanceAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int CreateInstanceEnum_([In][MarshalAs(UnmanagedType.BStr)]  string   strFilter, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject   ppEnum);
        [PreserveSig] int CreateInstanceEnumAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strFilter, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int ExecQuery_([In][MarshalAs(UnmanagedType.BStr)]  string   strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)]  string   strQuery, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject   ppEnum);
        [PreserveSig] int ExecQueryAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)]  string   strQuery, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int ExecNotificationQuery_([In][MarshalAs(UnmanagedType.BStr)]  string   strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)]  string   strQuery, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject   ppEnum);
        [PreserveSig] int ExecNotificationQueryAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)]  string   strQuery, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int ExecMethod_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath, [In][MarshalAs(UnmanagedType.BStr)]  string   strMethodName, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pInParams, [In][Out][MarshalAs(UnmanagedType.Interface)]  ref IWbemClassObject_DoNotMarshal   ppOutParams, [In] IntPtr ppCallResult);
        [PreserveSig] int ExecMethodAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath, [In][MarshalAs(UnmanagedType.BStr)]  string   strMethodName, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pInParams, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
    }

    [GuidAttribute("44ACA675-E8FC-11D0-A07C-00C04FB68820")]
    [TypeLibTypeAttribute(0x0200)]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemCallResult
    {
        [PreserveSig] int GetResultObject_([In] Int32 lTimeout, [Out][MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(MarshalWbemObject))] out IWbemClassObjectFreeThreaded ppResultObject);
        [PreserveSig] int GetResultString_([In] Int32 lTimeout, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrResultString);
        [PreserveSig] int GetResultServices_([In] Int32 lTimeout, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemServices   ppServices);
        [PreserveSig] int GetCallStatus_([In] Int32 lTimeout, [Out] out Int32 plStatus);
    }

    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("7C857801-7381-11CF-884D-00AA004B2E24")]
    [InterfaceTypeAttribute(0x0001)]
    [System.Security.SuppressUnmanagedCodeSecurity]
    [ComImport]
    interface IWbemObjectSink
    {
//      [PreserveSig] int Indicate_([In] Int32 lObjectCount, [In][MarshalAs(UnmanagedType.Interface)]  ref IWbemClassObject   apObjArray);
//      [PreserveSig] int Indicate_([In] Int32 lObjectCount, [In][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] IWbemObjectAccess[] apObjArray);
        [PreserveSig] int Indicate_([In] Int32 lObjectCount, [In] IntPtr apObjArray);
        [PreserveSig] int SetStatus_([In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Error)]  Int32   hResult, [In][MarshalAs(UnmanagedType.BStr)]  string   strParam, [In] IntPtr pObjParam);
    }

    [InterfaceTypeAttribute(0x0001)]
    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("027947E1-D731-11CE-A357-000000000001")]
    [ComImport]
    interface IEnumWbemClassObject
    {
        [PreserveSig] int Reset_();
        [PreserveSig] int Next_([In] Int32 lTimeout, [In] UInt32 uCount, [Out][MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(MarshalWbemObject))] out IWbemClassObjectFreeThreaded apObjects, [Out] out UInt32 puReturned);
        [PreserveSig] int NextAsync_([In] UInt32 uCount, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pSink);
        [PreserveSig] int Clone_([Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject   ppEnum);
        [PreserveSig] int Skip_([In] Int32 lTimeout, [In] UInt32 nCount);
    }

    [TypeLibTypeAttribute(0x0200)]
    [InterfaceTypeAttribute(0x0001)]
    [GuidAttribute("C1E2D759-CABD-11D3-A11B-00105A1F515A")]
    [ComImport]
    interface IWbemRawSdAccessor
    {
        [PreserveSig] int Get_([In] Int32 lFlags, [In] UInt32 uBufSize, [Out] out UInt32 puSDSize, [In][Out] ref Byte pSD);
        [PreserveSig] int Put_([In] Int32 lFlags, [In] UInt32 uBufSize, [In] ref Byte pSD);
    }

    [InterfaceTypeAttribute(0x0001)]
    [GuidAttribute("B7B31DF9-D515-11D3-A11C-00105A1F515A")]
    [ComImport]
    interface IWbemShutdown
    {
        [PreserveSig] int Shutdown_([In] Int32 uReason, [In] UInt32 uMaxMilliseconds, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx);
    }

    [GuidAttribute("4212DC47-142E-4C6C-BC49-6CA232DD0959")]
    [InterfaceTypeAttribute(0x0001)]
    /*[ComConversionLossAttribute]*/
    [ComImport]
    interface IWbemCallStatus
    {
        [PreserveSig] int GetCallStatus_([In] UInt32 uFlags, [In] UInt32 lLocale, [Out][MarshalAs(UnmanagedType.Error)]  out Int32   phRes, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pszMsg, [In] ref System.Guid riid, [Out] IntPtr pObj);
    }

    [InterfaceTypeAttribute(0x0001)]
    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("BFBF883A-CAD7-11D3-A11B-00105A1F515A")]
    [ComImport]
    interface IWbemObjectTextSrc
    {
        [PreserveSig] int GetText_([In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pObj, [In] UInt32 uObjTextFormat, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [Out][MarshalAs(UnmanagedType.BStr)]  out string   strText);
        [PreserveSig] int CreateFromText_([In] Int32 lFlags, [In][MarshalAs(UnmanagedType.BStr)]  string   strText, [In] UInt32 uObjTextFormat, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject_DoNotMarshal   pNewObj);
    }

    [GuidAttribute("49353C9A-516B-11D1-AEA6-00C04FB68820")]
    [TypeLibTypeAttribute(0x0200)]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemObjectAccess
    {
        [PreserveSig] int GetQualifierSet_([Out][MarshalAs(UnmanagedType.Interface)]  out IWbemQualifierSet_DoNotMarshal   ppQualSet);
        [PreserveSig] int Get_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In][Out] ref object pVal, [In][Out] ref Int32 pType, [In][Out] ref Int32 plFlavor);
        [PreserveSig] int Put_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In] ref object pVal, [In] Int32 Type);
        [PreserveSig] int Delete_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName);
        [PreserveSig] int GetNames_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszQualifierName, [In] Int32 lFlags, [In] ref object pQualifierVal, [Out][MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_BSTR)]  out string[]   pNames);
        [PreserveSig] int BeginEnumeration_([In] Int32 lEnumFlags);
        [PreserveSig] int Next_([In] Int32 lFlags, [In][Out][MarshalAs(UnmanagedType.BStr)]  ref string   strName, [In][Out] ref object pVal, [In][Out] ref Int32 pType, [In][Out] ref Int32 plFlavor);
        [PreserveSig] int EndEnumeration_();
        [PreserveSig] int GetPropertyQualifierSet_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszProperty, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemQualifierSet_DoNotMarshal   ppQualSet);
        [PreserveSig] int Clone_([Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject_DoNotMarshal   ppCopy);
        [PreserveSig] int GetObjectText_([In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrObjectText);
        [PreserveSig] int SpawnDerivedClass_([In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject_DoNotMarshal   ppNewClass);
        [PreserveSig] int SpawnInstance_([In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject_DoNotMarshal   ppNewInstance);
        [PreserveSig] int CompareTo_([In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pCompareTo);
        [PreserveSig] int GetPropertyOrigin_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrClassName);
        [PreserveSig] int InheritsFrom_([In][MarshalAs(UnmanagedType.LPWStr)]  string   strAncestor);
        [PreserveSig] int GetMethod_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject_DoNotMarshal   ppInSignature, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject_DoNotMarshal   ppOutSignature);
        [PreserveSig] int PutMethod_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pInSignature, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pOutSignature);
        [PreserveSig] int DeleteMethod_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName);
        [PreserveSig] int BeginMethodEnumeration_([In] Int32 lEnumFlags);
        [PreserveSig] int NextMethod_([In] Int32 lFlags, [In][Out][MarshalAs(UnmanagedType.BStr)]  ref string   pstrName, [In][Out][MarshalAs(UnmanagedType.Interface)]  ref IWbemClassObject_DoNotMarshal   ppInSignature, [In][Out][MarshalAs(UnmanagedType.Interface)]  ref IWbemClassObject_DoNotMarshal   ppOutSignature);
        [PreserveSig] int EndMethodEnumeration_();
        [PreserveSig] int GetMethodQualifierSet_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszMethod, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemQualifierSet_DoNotMarshal   ppQualSet);
        [PreserveSig] int GetMethodOrigin_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszMethodName, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrClassName);
        [PreserveSig] int GetPropertyHandle_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszPropertyName, [Out] out Int32 pType, [Out] out Int32 plHandle);
        [PreserveSig] int WritePropertyValue_([In] Int32 lHandle, [In] Int32 lNumBytes, [In] ref Byte aData);
        [PreserveSig] int ReadPropertyValue_([In] Int32 lHandle, [In] Int32 lBufferSize, [Out] out Int32 plNumBytes, [Out] out Byte aData);
        [PreserveSig] int ReadDWORD_([In] Int32 lHandle, [Out] out UInt32 pdw);
        [PreserveSig] int WriteDWORD_([In] Int32 lHandle, [In] UInt32 dw);
        [PreserveSig] int ReadQWORD_([In] Int32 lHandle, [Out] out UInt64 pqw);
        [PreserveSig] int WriteQWORD_([In] Int32 lHandle, [In] UInt64 pw);
        [PreserveSig] int GetPropertyInfoByHandle_([In] Int32 lHandle, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrName, [Out] out Int32 pType);
        [PreserveSig] int Lock_([In] Int32 lFlags);
        [PreserveSig] int Unlock_([In] Int32 lFlags);
    }

    [InterfaceTypeAttribute(0x0001)]
    [GuidAttribute("6DAF974E-2E37-11D2-AEC9-00C04FB68820")]
    [ComImport]
    interface IMofCompiler
    {
        [PreserveSig] int CompileFile_([In][MarshalAs(UnmanagedType.LPWStr)]  string   FileName, [In][MarshalAs(UnmanagedType.LPWStr)]  string   ServerAndNamespace, [In][MarshalAs(UnmanagedType.LPWStr)]  string   User, [In][MarshalAs(UnmanagedType.LPWStr)]  string   Authority, [In][MarshalAs(UnmanagedType.LPWStr)]  string   Password, [In] Int32 lOptionFlags, [In] Int32 lClassFlags, [In] Int32 lInstanceFlags, [In][Out] ref tag_CompileStatusInfo pInfo);
        [PreserveSig] int CompileBuffer_([In] Int32 BuffSize, [In] ref Byte pBuffer, [In][MarshalAs(UnmanagedType.LPWStr)]  string   ServerAndNamespace, [In][MarshalAs(UnmanagedType.LPWStr)]  string   User, [In][MarshalAs(UnmanagedType.LPWStr)]  string   Authority, [In][MarshalAs(UnmanagedType.LPWStr)]  string   Password, [In] Int32 lOptionFlags, [In] Int32 lClassFlags, [In] Int32 lInstanceFlags, [In][Out] ref tag_CompileStatusInfo pInfo);
        [PreserveSig] int CreateBMOF_([In][MarshalAs(UnmanagedType.LPWStr)]  string   TextFileName, [In][MarshalAs(UnmanagedType.LPWStr)]  string   BMOFFileName, [In][MarshalAs(UnmanagedType.LPWStr)]  string   ServerAndNamespace, [In] Int32 lOptionFlags, [In] Int32 lClassFlags, [In] Int32 lInstanceFlags, [In][Out] ref tag_CompileStatusInfo pInfo);
    }

    [GuidAttribute("1CFABA8C-1523-11D1-AD79-00C04FD8FDFF")]
    [TypeLibTypeAttribute(0x0200)]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IUnsecuredApartment
    {
        [PreserveSig] int CreateObjectStub_([In][MarshalAs(UnmanagedType.IUnknown)]  object   pObject, [Out][MarshalAs(UnmanagedType.IUnknown)]  out object   ppStub);
    }

    [GuidAttribute("EB87E1BC-3233-11D2-AEC9-00C04FB68820")]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemStatusCodeText
    {
        [PreserveSig] int GetErrorCodeText_([In][MarshalAs(UnmanagedType.Error)]  Int32   hRes, [In] UInt32 LocaleId, [In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.BStr)]  out string   MessageText);
        [PreserveSig] int GetFacilityCodeText_([In][MarshalAs(UnmanagedType.Error)]  Int32   hRes, [In] UInt32 LocaleId, [In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.BStr)]  out string   MessageText);
    }

    [GuidAttribute("C49E32C7-BC8B-11D2-85D4-00105A1F8304")]
    [TypeLibTypeAttribute(0x0200)]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemBackupRestore
    {
        [PreserveSig] int Backup_([In][MarshalAs(UnmanagedType.LPWStr)]  string   strBackupToFile, [In] Int32 lFlags);
        [PreserveSig] int Restore_([In][MarshalAs(UnmanagedType.LPWStr)]  string   strRestoreFromFile, [In] Int32 lFlags);
    }

    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("A359DEC5-E813-4834-8A2A-BA7F1D777D76")]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemBackupRestoreEx
    {
        [PreserveSig] int Backup_([In][MarshalAs(UnmanagedType.LPWStr)]  string   strBackupToFile, [In] Int32 lFlags);
        [PreserveSig] int Restore_([In][MarshalAs(UnmanagedType.LPWStr)]  string   strRestoreFromFile, [In] Int32 lFlags);
        [PreserveSig] int Pause_();
        [PreserveSig] int Resume_();
    }

    [InterfaceTypeAttribute(0x0001)]
    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("49353C99-516B-11D1-AEA6-00C04FB68820")]
    [ComImport]
    interface IWbemRefresher
    {
        [PreserveSig] int Refresh_([In] Int32 lFlags);
    }

    [GuidAttribute("2705C288-79AE-11D2-B348-00105A1F8177")]
    [TypeLibTypeAttribute(0x0200)]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemHiPerfEnum
    {
        [PreserveSig] int AddObjects_([In] Int32 lFlags, [In] UInt32 uNumObjects, [In] ref Int32 apIds, [In][MarshalAs(UnmanagedType.Interface)]  ref IWbemObjectAccess   apObj);
        [PreserveSig] int RemoveObjects_([In] Int32 lFlags, [In] UInt32 uNumObjects, [In] ref Int32 apIds);
        [PreserveSig] int GetObjects_([In] Int32 lFlags, [In] UInt32 uNumObjects, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemObjectAccess   apObj, [Out] out UInt32 puReturned);
        [PreserveSig] int RemoveAll_([In] Int32 lFlags);
    }

    [GuidAttribute("49353C92-516B-11D1-AEA6-00C04FB68820")]
    [TypeLibTypeAttribute(0x0200)]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemConfigureRefresher
    {
        [PreserveSig] int AddObjectByPath_([In][MarshalAs(UnmanagedType.Interface)]  IWbemServices   pNamespace, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszPath, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pContext, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject_DoNotMarshal   ppRefreshable, [In][Out] ref Int32 plId);
        [PreserveSig] int AddObjectByTemplate_([In][MarshalAs(UnmanagedType.Interface)]  IWbemServices   pNamespace, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pTemplate, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pContext, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject_DoNotMarshal   ppRefreshable, [In][Out] ref Int32 plId);
        [PreserveSig] int AddRefresher_([In][MarshalAs(UnmanagedType.Interface)]  IWbemRefresher   pRefresher, [In] Int32 lFlags, [In][Out] ref Int32 plId);
        [PreserveSig] int Remove_([In] Int32 lId, [In] Int32 lFlags);
        [PreserveSig] int AddEnum_([In][MarshalAs(UnmanagedType.Interface)]  IWbemServices   pNamespace, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszClassName, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pContext, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemHiPerfEnum   ppEnum, [In][Out] ref Int32 plId);
    }

    [InterfaceTypeAttribute(0x0001)]
    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("E246107B-B06E-11D0-AD61-00C04FD8FDFF")]
    [ComImport]
    interface IWbemUnboundObjectSink
    {
        [PreserveSig] int IndicateToConsumer_([In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pLogicalConsumer, [In] Int32 lNumObjects, [In][MarshalAs(UnmanagedType.Interface)]  ref IWbemClassObject_DoNotMarshal   apObjects);
    }

    [InterfaceTypeAttribute(0x0001)]
    [GuidAttribute("CE61E841-65BC-11D0-B6BD-00AA003240C7")]
    [TypeLibTypeAttribute(0x0200)]
    [ComImport]
    interface IWbemPropertyProvider
    {
        [PreserveSig] int GetProperty_([In] Int32 lFlags, [In][MarshalAs(UnmanagedType.BStr)]  string   strLocale, [In][MarshalAs(UnmanagedType.BStr)]  string   strClassMapping, [In][MarshalAs(UnmanagedType.BStr)]  string   strInstMapping, [In][MarshalAs(UnmanagedType.BStr)]  string   strPropMapping, [Out] out object pvValue);
        [PreserveSig] int PutProperty_([In] Int32 lFlags, [In][MarshalAs(UnmanagedType.BStr)]  string   strLocale, [In][MarshalAs(UnmanagedType.BStr)]  string   strClassMapping, [In][MarshalAs(UnmanagedType.BStr)]  string   strInstMapping, [In][MarshalAs(UnmanagedType.BStr)]  string   strPropMapping, [In] ref object pvValue);
    }

    [InterfaceTypeAttribute(0x0001)]
    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("E245105B-B06E-11D0-AD61-00C04FD8FDFF")]
    [ComImport]
    interface IWbemEventProvider
    {
        [PreserveSig] int ProvideEvents_([In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pSink, [In] Int32 lFlags);
    }

    [GuidAttribute("580ACAF8-FA1C-11D0-AD72-00C04FD8FDFF")]
    [TypeLibTypeAttribute(0x0200)]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemEventProviderQuerySink
    {
        [PreserveSig] int NewQuery_([In] UInt32 dwId, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszQueryLanguage, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszQuery);
        [PreserveSig] int CancelQuery_([In] UInt32 dwId);
    }

    [InterfaceTypeAttribute(0x0001)]
    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("631F7D96-D993-11D2-B339-00105A1F4AAF")]
    [ComImport]
    interface IWbemEventProviderSecurity
    {
        [PreserveSig] int AccessCheck_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszQueryLanguage, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszQuery, [In] Int32 lSidLength, [In] ref Byte pSid);
    }

    [GuidAttribute("631F7D97-D993-11D2-B339-00105A1F4AAF")]
    [TypeLibTypeAttribute(0x0200)]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemProviderIdentity
    {
        [PreserveSig] int SetRegistrationObject_([In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pProvReg);
    }

    [InterfaceTypeAttribute(0x0001)]
    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("E246107A-B06E-11D0-AD61-00C04FD8FDFF")]
    [ComImport]
    interface IWbemEventConsumerProvider
    {
        [PreserveSig] int FindConsumer_([In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pLogicalConsumer, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemUnboundObjectSink   ppConsumer);
    }

    [InterfaceTypeAttribute(0x0001)]
    [GuidAttribute("17CF534A-D8A3-4AD0-AC92-5E3D01717151")]
    [TypeLibTypeAttribute(0x0200)]
    [ComImport]
    interface IWbemEventConsumerProviderEx
    {
        [PreserveSig] int FindConsumer_([In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pLogicalConsumer, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemUnboundObjectSink   ppConsumer);
        [PreserveSig] int ValidateSubscription_([In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pLogicalConsumer);
    }

    [GuidAttribute("1BE41571-91DD-11D1-AEB2-00C04FB68820")]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemProviderInitSink
    {
        [PreserveSig] int SetStatus_([In] Int32 lStatus, [In] Int32 lFlags);
    }

    [GuidAttribute("1BE41572-91DD-11D1-AEB2-00C04FB68820")]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemProviderInit
    {
        [PreserveSig] int Initialize_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszUser, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszNamespace, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszLocale, [In][MarshalAs(UnmanagedType.Interface)]  IWbemServices   pNamespace, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemProviderInitSink   pInitSink);
    }

    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("49353C93-516B-11D1-AEA6-00C04FB68820")]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemHiPerfProvider
    {
        [PreserveSig] int QueryInstances_([In][MarshalAs(UnmanagedType.Interface)]  IWbemServices   pNamespace, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszClass, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pSink);
        [PreserveSig] int CreateRefresher_([In][MarshalAs(UnmanagedType.Interface)]  IWbemServices   pNamespace, [In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemRefresher   ppRefresher);
        [PreserveSig] int CreateRefreshableObject_([In][MarshalAs(UnmanagedType.Interface)]  IWbemServices   pNamespace, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectAccess   pTemplate, [In][MarshalAs(UnmanagedType.Interface)]  IWbemRefresher   pRefresher, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pContext, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemObjectAccess   ppRefreshable, [Out] out Int32 plId);
        [PreserveSig] int StopRefreshing_([In][MarshalAs(UnmanagedType.Interface)]  IWbemRefresher   pRefresher, [In] Int32 lId, [In] Int32 lFlags);
        [PreserveSig] int CreateRefreshableEnum_([In][MarshalAs(UnmanagedType.Interface)]  IWbemServices   pNamespace, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszClass, [In][MarshalAs(UnmanagedType.Interface)]  IWbemRefresher   pRefresher, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pContext, [In][MarshalAs(UnmanagedType.Interface)]  IWbemHiPerfEnum   pHiPerfEnum, [Out] out Int32 plId);
        [PreserveSig] int GetObjects_([In][MarshalAs(UnmanagedType.Interface)]  IWbemServices   pNamespace, [In] Int32 lNumObjects, [In][Out][MarshalAs(UnmanagedType.Interface)]  ref IWbemObjectAccess   apObj, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pContext);
    }

    [InterfaceTypeAttribute(0x0001)]
    [GuidAttribute("1005CBCF-E64F-4646-BCD3-3A089D8A84B4")]
    [ComImport]
    interface IWbemDecoupledRegistrar
    {
        [PreserveSig] int Register_([In] Int32 a_Flags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   a_Context, [In][MarshalAs(UnmanagedType.LPWStr)]  string   a_User, [In][MarshalAs(UnmanagedType.LPWStr)]  string   a_Locale, [In][MarshalAs(UnmanagedType.LPWStr)]  string   a_Scope, [In][MarshalAs(UnmanagedType.LPWStr)]  string   a_Registration, [In][MarshalAs(UnmanagedType.IUnknown)]  object   a_Unknown);
        [PreserveSig] int UnRegister_();
    }

    [GuidAttribute("86336D20-CA11-4786-9EF1-BC8A946B42FC")]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemDecoupledBasicEventProvider
    {
        [PreserveSig] int Register_([In] Int32 a_Flags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   a_Context, [In][MarshalAs(UnmanagedType.LPWStr)]  string   a_User, [In][MarshalAs(UnmanagedType.LPWStr)]  string   a_Locale, [In][MarshalAs(UnmanagedType.LPWStr)]  string   a_Scope, [In][MarshalAs(UnmanagedType.LPWStr)]  string   a_Registration, [In][MarshalAs(UnmanagedType.IUnknown)]  object   a_Unknown);
        [PreserveSig] int UnRegister_();
        [PreserveSig] int GetSink_([In] Int32 a_Flags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   a_Context, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemObjectSink   a_Sink);
        [PreserveSig] int GetService_([In] Int32 a_Flags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   a_Context, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemServices   a_Service);
    }

    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("75ABD540-F492-4161-86A5-37FC8898F69E")]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemSecureObjectSink
    {
        [PreserveSig] int Indicate_([In] Int32 lObjectCount, [In][MarshalAs(UnmanagedType.Interface)]  ref IWbemClassObject_DoNotMarshal   apObjArray);
        [PreserveSig] int SetStatus_([In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Error)]  Int32   hResult, [In][MarshalAs(UnmanagedType.BStr)]  string   strParam, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pObjParam);
        [PreserveSig] int IndicateWithSD_([In] Int32 lNumObjects, [In][MarshalAs(UnmanagedType.IUnknown)]  ref object   apObjects, [In] Int32 lSDLength, [In] ref Byte pSD);
    }

    [InterfaceTypeAttribute(0x0001)]
    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("3AE0080A-7E3A-4366-BF89-0FEEDC931659")]
    [ComImport]
    interface IWbemEventSink
    {
        [PreserveSig] int Indicate_([In] Int32 lObjectCount, [In][MarshalAs(UnmanagedType.Interface)]  ref IWbemClassObject_DoNotMarshal   apObjArray);
        [PreserveSig] int SetStatus_([In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Error)]  Int32   hResult, [In][MarshalAs(UnmanagedType.BStr)]  string   strParam, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pObjParam);
        [PreserveSig] int IndicateWithSD_([In] Int32 lNumObjects, [In][MarshalAs(UnmanagedType.IUnknown)]  ref object   apObjects, [In] Int32 lSDLength, [In] ref Byte pSD);
        [PreserveSig] int SetSinkSecurity_([In] Int32 lSDLength, [In] ref Byte pSD);
        [PreserveSig] int IsActive_();
        [PreserveSig] int GetRestrictedSink_([In] Int32 lNumQueries, [In][MarshalAs(UnmanagedType.LPWStr)]  ref string   awszQueries, [In][MarshalAs(UnmanagedType.IUnknown)]  object   pCallback, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemEventSink   ppSink);
        [PreserveSig] int SetBatchingParameters_([In] Int32 lFlags, [In] UInt32 dwMaxBufferSize, [In] UInt32 dwMaxSendLatency);
    }

    [GuidAttribute("9AE62877-7544-4BB0-AA26-A13824659ED6")]
    /*[ComConversionLossAttribute]*/
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemPathKeyList
    {
        [PreserveSig] int GetCount_([Out] out UInt32 puKeyCount);
        [PreserveSig] int SetKey_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] UInt32 uFlags, [In] UInt32 uCimType, [In] IntPtr pKeyVal);
        [PreserveSig] int SetKey2_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] UInt32 uFlags, [In] UInt32 uCimType, [In] ref object pKeyVal);
        [PreserveSig] int GetKey_([In] UInt32 uKeyIx, [In] UInt32 uFlags, [In][Out] ref UInt32 puNameBufSize, [In][Out][MarshalAs(UnmanagedType.LPWStr)]  string   pszKeyName, [In][Out] ref UInt32 puKeyValBufSize, [In][Out] IntPtr pKeyVal, [Out] out UInt32 puApparentCimType);
        [PreserveSig] int GetKey2_([In] UInt32 uKeyIx, [In] UInt32 uFlags, [In][Out] ref UInt32 puNameBufSize, [In][Out][MarshalAs(UnmanagedType.LPWStr)]  string   pszKeyName, [In][Out] ref object pKeyValue, [Out] out UInt32 puApparentCimType);
        [PreserveSig] int RemoveKey_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] UInt32 uFlags);
        [PreserveSig] int RemoveAllKeys_([In] UInt32 uFlags);
        [PreserveSig] int MakeSingleton_([In] SByte bSet);
        [PreserveSig] int GetInfo_([In] UInt32 uRequestedInfo, [Out] out UInt64 puResponse);
        [PreserveSig] int GetText_([In] Int32 lFlags, [In][Out] ref UInt32 puBuffLength, [In][Out][MarshalAs(UnmanagedType.LPWStr)]  string   pszText);
    }

    [GuidAttribute("3BC15AF2-736C-477E-9E51-238AF8667DCC")]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemPath
    {
        [PreserveSig] int SetText_([In] UInt32 uMode, [In][MarshalAs(UnmanagedType.LPWStr)]  string   pszPath);
        [PreserveSig] int GetText_([In] Int32 lFlags, [In][Out] ref UInt32 puBuffLength, [In][Out][MarshalAs(UnmanagedType.LPWStr)]  string   pszText);
        [PreserveSig] int GetInfo_([In] UInt32 uRequestedInfo, [Out] out UInt64 puResponse);
        [PreserveSig] int SetServer_([In][MarshalAs(UnmanagedType.LPWStr)]  string   Name);
        [PreserveSig] int GetServer_([In][Out] ref UInt32 puNameBufLength, [In][Out][MarshalAs(UnmanagedType.LPWStr)]  string   pName);
        [PreserveSig] int GetNamespaceCount_([Out] out UInt32 puCount);
        [PreserveSig] int SetNamespaceAt_([In] UInt32 uIndex, [In][MarshalAs(UnmanagedType.LPWStr)]  string   pszName);
        [PreserveSig] int GetNamespaceAt_([In] UInt32 uIndex, [In][Out] ref UInt32 puNameBufLength, [In][Out][MarshalAs(UnmanagedType.LPWStr)]  string   pName);
        [PreserveSig] int RemoveNamespaceAt_([In] UInt32 uIndex);
        [PreserveSig] int RemoveAllNamespaces_();
        [PreserveSig] int GetScopeCount_([Out] out UInt32 puCount);
        [PreserveSig] int SetScope_([In] UInt32 uIndex, [In][MarshalAs(UnmanagedType.LPWStr)]  string   pszClass);
        [PreserveSig] int SetScopeFromText_([In] UInt32 uIndex, [In][MarshalAs(UnmanagedType.LPWStr)]  string   pszText);
        [PreserveSig] int GetScope_([In] UInt32 uIndex, [In][Out] ref UInt32 puClassNameBufSize, [In][Out][MarshalAs(UnmanagedType.LPWStr)]  string   pszClass, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemPathKeyList   pKeyList);
        [PreserveSig] int GetScopeAsText_([In] UInt32 uIndex, [In][Out] ref UInt32 puTextBufSize, [In][Out][MarshalAs(UnmanagedType.LPWStr)]  string   pszText);
        [PreserveSig] int RemoveScope_([In] UInt32 uIndex);
        [PreserveSig] int RemoveAllScopes_();
        [PreserveSig] int SetClassName_([In][MarshalAs(UnmanagedType.LPWStr)]  string   Name);
        [PreserveSig] int GetClassName_([In][Out] ref UInt32 puBuffLength, [In][Out][MarshalAs(UnmanagedType.LPWStr)]  string   pszName);
        [PreserveSig] int GetKeyList_([Out][MarshalAs(UnmanagedType.Interface)]  out IWbemPathKeyList   pOut);
        [PreserveSig] int CreateClassPart_([In] Int32 lFlags, [In][MarshalAs(UnmanagedType.LPWStr)]  string   Name);
        [PreserveSig] int DeleteClassPart_([In] Int32 lFlags);
        [PreserveSig] int IsRelative_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszMachine, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszNamespace);
        [PreserveSig] int IsRelativeOrChild_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszMachine, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszNamespace, [In] Int32 lFlags);
        [PreserveSig] int IsLocal_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszMachine);
        [PreserveSig] int IsSameClassName_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszClass);
    }

    [GuidAttribute("81166F58-DD98-11D3-A120-00105A1F515A")]
    [InterfaceTypeAttribute(0x0001)]
    /*[ComConversionLossAttribute]*/
    [ComImport]
    interface IWbemQuery
    {
        [PreserveSig] int Empty_();
        [PreserveSig] int SetLanguageFeatures_([In] Int32 lFlags, [In] UInt32 uArraySize, [In] ref UInt32 puFeatures);
        [PreserveSig] int TestLanguageFeatures_([In][Out] ref UInt32 uArraySize, [Out] out UInt32 puFeatures);
        [PreserveSig] int Parse_([In][MarshalAs(UnmanagedType.LPWStr)]  string   pszLang, [In][MarshalAs(UnmanagedType.LPWStr)]  string   pszQuery, [In] UInt32 uFlags);
        [PreserveSig] int GetAnalysis_([In] UInt32 uAnalysisType, [In] UInt32 uFlags, [Out] IntPtr pAnalysis);
        [PreserveSig] int FreeMemory_([In] IntPtr pMem);
        [PreserveSig] int GetQueryInfo_([In] UInt32 uAnalysisType, [In] UInt32 uInfoId, [In] UInt32 uBufSize, [Out] IntPtr pDestBuf);
        [PreserveSig] int AttachClassDef_([In] ref System.Guid riid, [In] IntPtr pClassDef);
        [PreserveSig] int TestObject_([In] UInt32 uTestType, [In] UInt32 uFlags, [In] ref System.Guid riid, [In] IntPtr pObj);
        [PreserveSig] int StringTest_([In] UInt32 uTestType, [In][MarshalAs(UnmanagedType.LPWStr)]  string   pszTestStr, [In][MarshalAs(UnmanagedType.LPWStr)]  string   pszExpr);
    }
    #endregion

    #region Enums
    enum tag_WBEM_GENUS_TYPE
    {
        WBEM_GENUS_CLASS = unchecked((int)0x00000001),
        WBEM_GENUS_INSTANCE = unchecked((int)0x00000002),
    }

    enum tag_WBEM_CHANGE_FLAG_TYPE
    {
        WBEM_FLAG_CREATE_OR_UPDATE = unchecked((int)0x00000000),
        WBEM_FLAG_UPDATE_ONLY = unchecked((int)0x00000001),
        WBEM_FLAG_CREATE_ONLY = unchecked((int)0x00000002),
        WBEM_FLAG_UPDATE_COMPATIBLE = unchecked((int)0x00000000),
        WBEM_FLAG_UPDATE_SAFE_MODE = unchecked((int)0x00000020),
        WBEM_FLAG_UPDATE_FORCE_MODE = unchecked((int)0x00000040),
        WBEM_MASK_UPDATE_MODE = unchecked((int)0x00000060),
        WBEM_FLAG_ADVISORY = unchecked((int)0x00010000),
    }

    enum tag_WBEM_GENERIC_FLAG_TYPE
    {
        WBEM_FLAG_RETURN_IMMEDIATELY = unchecked((int)0x00000010),
        WBEM_FLAG_RETURN_WBEM_COMPLETE = unchecked((int)0x00000000),
        WBEM_FLAG_BIDIRECTIONAL = unchecked((int)0x00000000),
        WBEM_FLAG_FORWARD_ONLY = unchecked((int)0x00000020),
        WBEM_FLAG_NO_ERROR_OBJECT = unchecked((int)0x00000040),
        WBEM_FLAG_RETURN_ERROR_OBJECT = unchecked((int)0x00000000),
        WBEM_FLAG_SEND_STATUS = unchecked((int)0x00000080),
        WBEM_FLAG_DONT_SEND_STATUS = unchecked((int)0x00000000),
        WBEM_FLAG_ENSURE_LOCATABLE = unchecked((int)0x00000100),
        WBEM_FLAG_DIRECT_READ = unchecked((int)0x00000200),
        WBEM_FLAG_SEND_ONLY_SELECTED = unchecked((int)0x00000000),
        WBEM_RETURN_WHEN_COMPLETE = unchecked((int)0x00000000),
        WBEM_RETURN_IMMEDIATELY = unchecked((int)0x00000010),
        WBEM_MASK_RESERVED_FLAGS = unchecked((int)0x0001F000),
        WBEM_FLAG_USE_AMENDED_QUALIFIERS = unchecked((int)0x00020000),
        WBEM_FLAG_STRONG_VALIDATION = unchecked((int)0x00100000),
    }

    enum tag_WBEM_STATUS_TYPE
    {
        WBEM_STATUS_COMPLETE = unchecked((int)0x00000000),
        WBEM_STATUS_REQUIREMENTS = unchecked((int)0x00000001),
        WBEM_STATUS_PROGRESS = unchecked((int)0x00000002),
    }

    enum tag_WBEM_TIMEOUT_TYPE
    {
        WBEM_NO_WAIT = unchecked((int)0x00000000),
        WBEM_INFINITE = unchecked((int)0xFFFFFFFF),
    }

    enum tag_WBEM_CONDITION_FLAG_TYPE
    {
        WBEM_FLAG_ALWAYS = unchecked((int)0x00000000),
        WBEM_FLAG_ONLY_IF_TRUE = unchecked((int)0x00000001),
        WBEM_FLAG_ONLY_IF_FALSE = unchecked((int)0x00000002),
        WBEM_FLAG_ONLY_IF_IDENTICAL = unchecked((int)0x00000003),
        WBEM_MASK_PRIMARY_CONDITION = unchecked((int)0x00000003),
        WBEM_FLAG_KEYS_ONLY = unchecked((int)0x00000004),
        WBEM_FLAG_REFS_ONLY = unchecked((int)0x00000008),
        WBEM_FLAG_LOCAL_ONLY = unchecked((int)0x00000010),
        WBEM_FLAG_PROPAGATED_ONLY = unchecked((int)0x00000020),
        WBEM_FLAG_SYSTEM_ONLY = unchecked((int)0x00000030),
        WBEM_FLAG_NONSYSTEM_ONLY = unchecked((int)0x00000040),
        WBEM_MASK_CONDITION_ORIGIN = unchecked((int)0x00000070),
        WBEM_FLAG_CLASS_OVERRIDES_ONLY = unchecked((int)0x00000100),
        WBEM_FLAG_CLASS_LOCAL_AND_OVERRIDES = unchecked((int)0x00000200),
        WBEM_MASK_CLASS_CONDITION = unchecked((int)0x00000300),
    }
    enum tag_WBEM_FLAVOR_TYPE
    {
        WBEM_FLAVOR_DONT_PROPAGATE = unchecked((int)0x00000000),
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE = unchecked((int)0x00000001),
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS = unchecked((int)0x00000002),
        WBEM_FLAVOR_MASK_PROPAGATION = unchecked((int)0x0000000F),
        WBEM_FLAVOR_OVERRIDABLE = unchecked((int)0x00000000),
        WBEM_FLAVOR_NOT_OVERRIDABLE = unchecked((int)0x00000010),
        WBEM_FLAVOR_MASK_PERMISSIONS = unchecked((int)0x00000010),
        WBEM_FLAVOR_ORIGIN_LOCAL = unchecked((int)0x00000000),
        WBEM_FLAVOR_ORIGIN_PROPAGATED = unchecked((int)0x00000020),
        WBEM_FLAVOR_ORIGIN_SYSTEM = unchecked((int)0x00000040),
        WBEM_FLAVOR_MASK_ORIGIN = unchecked((int)0x00000060),
        WBEM_FLAVOR_NOT_AMENDED = unchecked((int)0x00000000),
        WBEM_FLAVOR_AMENDED = unchecked((int)0x00000080),
        WBEM_FLAVOR_MASK_AMENDED = unchecked((int)0x00000080),
    }

    enum tag_WBEM_QUERY_FLAG_TYPE
    {
        WBEM_FLAG_DEEP = unchecked((int)0x00000000),
        WBEM_FLAG_SHALLOW = unchecked((int)0x00000001),
        WBEM_FLAG_PROTOTYPE = unchecked((int)0x00000002),
    }

    enum tag_WBEM_SECURITY_FLAGS
    {
        WBEM_ENABLE = unchecked((int)0x00000001),
        WBEM_METHOD_EXECUTE = unchecked((int)0x00000002),
        WBEM_FULL_WRITE_REP = unchecked((int)0x00000004),
        WBEM_PARTIAL_WRITE_REP = unchecked((int)0x00000008),
        WBEM_WRITE_PROVIDER = unchecked((int)0x00000010),
        WBEM_REMOTE_ACCESS = unchecked((int)0x00000020),
        WBEM_RIGHT_SUBSCRIBE = unchecked((int)0x00000001),
        WBEM_RIGHT_PUBLISH = unchecked((int)0x00000001),
    }

    enum tag_WBEM_LIMITATION_FLAG_TYPE
    {
        WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS = unchecked((int)0x00000010),
        WBEM_FLAG_EXCLUDE_PROPERTY_QUALIFIERS = unchecked((int)0x00000020),
    }

    enum tag_WBEM_TEXT_FLAG_TYPE
    {
        WBEM_FLAG_NO_FLAVORS = unchecked((int)0x00000001),
    }

    enum tag_WBEM_COMPARISON_FLAG
    {
        WBEM_COMPARISON_INCLUDE_ALL = unchecked((int)0x00000000),
        WBEM_FLAG_IGNORE_QUALIFIERS = unchecked((int)0x00000001),
        WBEM_FLAG_IGNORE_OBJECT_SOURCE = unchecked((int)0x00000002),
        WBEM_FLAG_IGNORE_DEFAULT_VALUES = unchecked((int)0x00000004),
        WBEM_FLAG_IGNORE_CLASS = unchecked((int)0x00000008),
        WBEM_FLAG_IGNORE_CASE = unchecked((int)0x00000010),
        WBEM_FLAG_IGNORE_FLAVOR = unchecked((int)0x00000020),
    }

    enum tag_WBEM_LOCKING
    {
        WBEM_FLAG_ALLOW_READ = unchecked((int)0x00000001),
    }

    enum tag_CIMTYPE_ENUMERATION
    {
        CIM_ILLEGAL = unchecked((int)0x00000FFF),
        CIM_EMPTY = unchecked((int)0x00000000),
        CIM_SINT8 = unchecked((int)0x00000010),
        CIM_UINT8 = unchecked((int)0x00000011),
        CIM_SINT16 = unchecked((int)0x00000002),
        CIM_UINT16 = unchecked((int)0x00000012),
        CIM_SINT32 = unchecked((int)0x00000003),
        CIM_UINT32 = unchecked((int)0x00000013),
        CIM_SINT64 = unchecked((int)0x00000014),
        CIM_UINT64 = unchecked((int)0x00000015),
        CIM_REAL32 = unchecked((int)0x00000004),
        CIM_REAL64 = unchecked((int)0x00000005),
        CIM_BOOLEAN = unchecked((int)0x0000000B),
        CIM_STRING = unchecked((int)0x00000008),
        CIM_DATETIME = unchecked((int)0x00000065),
        CIM_REFERENCE = unchecked((int)0x00000066),
        CIM_CHAR16 = unchecked((int)0x00000067),
        CIM_OBJECT = unchecked((int)0x0000000D),
        CIM_FLAG_ARRAY = unchecked((int)0x00002000),
    }

    enum tag_WBEM_BACKUP_RESTORE_FLAGS
    {
        WBEM_FLAG_BACKUP_RESTORE_DEFAULT = unchecked((int)0x00000000),
        WBEM_FLAG_BACKUP_RESTORE_FORCE_SHUTDOWN = unchecked((int)0x00000001),
    }

    enum tag_WBEM_REFRESHER_FLAGS
    {
        WBEM_FLAG_REFRESH_AUTO_RECONNECT = unchecked((int)0x00000000),
        WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT = unchecked((int)0x00000001),
    }

    enum tag_WBEM_SHUTDOWN_FLAGS
    {
        WBEM_SHUTDOWN_UNLOAD_COMPONENT = unchecked((int)0x00000001),
        WBEM_SHUTDOWN_WMI = unchecked((int)0x00000002),
        WBEM_SHUTDOWN_OS = unchecked((int)0x00000003),
    }

    enum tag_WBEMSTATUS_FORMAT
    {
        WBEMSTATUS_FORMAT_NEWLINE = unchecked((int)0x00000000),
        WBEMSTATUS_FORMAT_NO_NEWLINE = unchecked((int)0x00000001),
    }

    enum tag_WBEMSTATUS
    {
        WBEM_NO_ERROR = unchecked((int)0x00000000),
        WBEM_S_NO_ERROR = unchecked((int)0x00000000),
        WBEM_S_SAME = unchecked((int)0x00000000),
        WBEM_S_FALSE = unchecked((int)0x00000001),
        WBEM_S_ALREADY_EXISTS = unchecked((int)0x00040001),
        WBEM_S_RESET_TO_DEFAULT = unchecked((int)0x00040002),
        WBEM_S_DIFFERENT = unchecked((int)0x00040003),
        WBEM_S_TIMEDOUT = unchecked((int)0x00040004),
        WBEM_S_NO_MORE_DATA = unchecked((int)0x00040005),
        WBEM_S_OPERATION_CANCELLED = unchecked((int)0x00040006),
        WBEM_S_PENDING = unchecked((int)0x00040007),
        WBEM_S_DUPLICATE_OBJECTS = unchecked((int)0x00040008),
        WBEM_S_ACCESS_DENIED = unchecked((int)0x00040009),
        WBEM_S_PARTIAL_RESULTS = unchecked((int)0x00040010),
        WBEM_S_NO_POSTHOOK = unchecked((int)0x00040011),
        WBEM_S_POSTHOOK_WITH_BOTH = unchecked((int)0x00040012),
        WBEM_S_POSTHOOK_WITH_NEW = unchecked((int)0x00040013),
        WBEM_S_POSTHOOK_WITH_STATUS = unchecked((int)0x00040014),
        WBEM_S_POSTHOOK_WITH_OLD = unchecked((int)0x00040015),
        WBEM_S_REDO_PREHOOK_WITH_ORIGINAL_OBJECT = unchecked((int)0x00040016),
        WBEM_S_SOURCE_NOT_AVAILABLE = unchecked((int)0x00040017),
        WBEM_E_FAILED = unchecked((int)0x80041001),
        WBEM_E_NOT_FOUND = unchecked((int)0x80041002),
        WBEM_E_ACCESS_DENIED = unchecked((int)0x80041003),
        WBEM_E_PROVIDER_FAILURE = unchecked((int)0x80041004),
        WBEM_E_TYPE_MISMATCH = unchecked((int)0x80041005),
        WBEM_E_OUT_OF_MEMORY = unchecked((int)0x80041006),
        WBEM_E_INVALID_CONTEXT = unchecked((int)0x80041007),
        WBEM_E_INVALID_PARAMETER = unchecked((int)0x80041008),
        WBEM_E_NOT_AVAILABLE = unchecked((int)0x80041009),
        WBEM_E_CRITICAL_ERROR = unchecked((int)0x8004100A),
        WBEM_E_INVALID_STREAM = unchecked((int)0x8004100B),
        WBEM_E_NOT_SUPPORTED = unchecked((int)0x8004100C),
        WBEM_E_INVALID_SUPERCLASS = unchecked((int)0x8004100D),
        WBEM_E_INVALID_NAMESPACE = unchecked((int)0x8004100E),
        WBEM_E_INVALID_OBJECT = unchecked((int)0x8004100F),
        WBEM_E_INVALID_CLASS = unchecked((int)0x80041010),
        WBEM_E_PROVIDER_NOT_FOUND = unchecked((int)0x80041011),
        WBEM_E_INVALID_PROVIDER_REGISTRATION = unchecked((int)0x80041012),
        WBEM_E_PROVIDER_LOAD_FAILURE = unchecked((int)0x80041013),
        WBEM_E_INITIALIZATION_FAILURE = unchecked((int)0x80041014),
        WBEM_E_TRANSPORT_FAILURE = unchecked((int)0x80041015),
        WBEM_E_INVALID_OPERATION = unchecked((int)0x80041016),
        WBEM_E_INVALID_QUERY = unchecked((int)0x80041017),
        WBEM_E_INVALID_QUERY_TYPE = unchecked((int)0x80041018),
        WBEM_E_ALREADY_EXISTS = unchecked((int)0x80041019),
        WBEM_E_OVERRIDE_NOT_ALLOWED = unchecked((int)0x8004101A),
        WBEM_E_PROPAGATED_QUALIFIER = unchecked((int)0x8004101B),
        WBEM_E_PROPAGATED_PROPERTY = unchecked((int)0x8004101C),
        WBEM_E_UNEXPECTED = unchecked((int)0x8004101D),
        WBEM_E_ILLEGAL_OPERATION = unchecked((int)0x8004101E),
        WBEM_E_CANNOT_BE_KEY = unchecked((int)0x8004101F),
        WBEM_E_INCOMPLETE_CLASS = unchecked((int)0x80041020),
        WBEM_E_INVALID_SYNTAX = unchecked((int)0x80041021),
        WBEM_E_NONDECORATED_OBJECT = unchecked((int)0x80041022),
        WBEM_E_READ_ONLY = unchecked((int)0x80041023),
        WBEM_E_PROVIDER_NOT_CAPABLE = unchecked((int)0x80041024),
        WBEM_E_CLASS_HAS_CHILDREN = unchecked((int)0x80041025),
        WBEM_E_CLASS_HAS_INSTANCES = unchecked((int)0x80041026),
        WBEM_E_QUERY_NOT_IMPLEMENTED = unchecked((int)0x80041027),
        WBEM_E_ILLEGAL_NULL = unchecked((int)0x80041028),
        WBEM_E_INVALID_QUALIFIER_TYPE = unchecked((int)0x80041029),
        WBEM_E_INVALID_PROPERTY_TYPE = unchecked((int)0x8004102A),
        WBEM_E_VALUE_OUT_OF_RANGE = unchecked((int)0x8004102B),
        WBEM_E_CANNOT_BE_SINGLETON = unchecked((int)0x8004102C),
        WBEM_E_INVALID_CIM_TYPE = unchecked((int)0x8004102D),
        WBEM_E_INVALID_METHOD = unchecked((int)0x8004102E),
        WBEM_E_INVALID_METHOD_PARAMETERS = unchecked((int)0x8004102F),
        WBEM_E_SYSTEM_PROPERTY = unchecked((int)0x80041030),
        WBEM_E_INVALID_PROPERTY = unchecked((int)0x80041031),
        WBEM_E_CALL_CANCELLED = unchecked((int)0x80041032),
        WBEM_E_SHUTTING_DOWN = unchecked((int)0x80041033),
        WBEM_E_PROPAGATED_METHOD = unchecked((int)0x80041034),
        WBEM_E_UNSUPPORTED_PARAMETER = unchecked((int)0x80041035),
        WBEM_E_MISSING_PARAMETER_ID = unchecked((int)0x80041036),
        WBEM_E_INVALID_PARAMETER_ID = unchecked((int)0x80041037),
        WBEM_E_NONCONSECUTIVE_PARAMETER_IDS = unchecked((int)0x80041038),
        WBEM_E_PARAMETER_ID_ON_RETVAL = unchecked((int)0x80041039),
        WBEM_E_INVALID_OBJECT_PATH = unchecked((int)0x8004103A),
        WBEM_E_OUT_OF_DISK_SPACE = unchecked((int)0x8004103B),
        WBEM_E_BUFFER_TOO_SMALL = unchecked((int)0x8004103C),
        WBEM_E_UNSUPPORTED_PUT_EXTENSION = unchecked((int)0x8004103D),
        WBEM_E_UNKNOWN_OBJECT_TYPE = unchecked((int)0x8004103E),
        WBEM_E_UNKNOWN_PACKET_TYPE = unchecked((int)0x8004103F),
        WBEM_E_MARSHAL_VERSION_MISMATCH = unchecked((int)0x80041040),
        WBEM_E_MARSHAL_INVALID_SIGNATURE = unchecked((int)0x80041041),
        WBEM_E_INVALID_QUALIFIER = unchecked((int)0x80041042),
        WBEM_E_INVALID_DUPLICATE_PARAMETER = unchecked((int)0x80041043),
        WBEM_E_TOO_MUCH_DATA = unchecked((int)0x80041044),
        WBEM_E_SERVER_TOO_BUSY = unchecked((int)0x80041045),
        WBEM_E_INVALID_FLAVOR = unchecked((int)0x80041046),
        WBEM_E_CIRCULAR_REFERENCE = unchecked((int)0x80041047),
        WBEM_E_UNSUPPORTED_CLASS_UPDATE = unchecked((int)0x80041048),
        WBEM_E_CANNOT_CHANGE_KEY_INHERITANCE = unchecked((int)0x80041049),
        WBEM_E_CANNOT_CHANGE_INDEX_INHERITANCE = unchecked((int)0x80041050),
        WBEM_E_TOO_MANY_PROPERTIES = unchecked((int)0x80041051),
        WBEM_E_UPDATE_TYPE_MISMATCH = unchecked((int)0x80041052),
        WBEM_E_UPDATE_OVERRIDE_NOT_ALLOWED = unchecked((int)0x80041053),
        WBEM_E_UPDATE_PROPAGATED_METHOD = unchecked((int)0x80041054),
        WBEM_E_METHOD_NOT_IMPLEMENTED = unchecked((int)0x80041055),
        WBEM_E_METHOD_DISABLED = unchecked((int)0x80041056),
        WBEM_E_REFRESHER_BUSY = unchecked((int)0x80041057),
        WBEM_E_UNPARSABLE_QUERY = unchecked((int)0x80041058),
        WBEM_E_NOT_EVENT_CLASS = unchecked((int)0x80041059),
        WBEM_E_MISSING_GROUP_WITHIN = unchecked((int)0x8004105A),
        WBEM_E_MISSING_AGGREGATION_LIST = unchecked((int)0x8004105B),
        WBEM_E_PROPERTY_NOT_AN_OBJECT = unchecked((int)0x8004105C),
        WBEM_E_AGGREGATING_BY_OBJECT = unchecked((int)0x8004105D),
        WBEM_E_UNINTERPRETABLE_PROVIDER_QUERY = unchecked((int)0x8004105F),
        WBEM_E_BACKUP_RESTORE_WINMGMT_RUNNING = unchecked((int)0x80041060),
        WBEM_E_QUEUE_OVERFLOW = unchecked((int)0x80041061),
        WBEM_E_PRIVILEGE_NOT_HELD = unchecked((int)0x80041062),
        WBEM_E_INVALID_OPERATOR = unchecked((int)0x80041063),
        WBEM_E_LOCAL_CREDENTIALS = unchecked((int)0x80041064),
        WBEM_E_CANNOT_BE_ABSTRACT = unchecked((int)0x80041065),
        WBEM_E_AMENDED_OBJECT = unchecked((int)0x80041066),
        WBEM_E_CLIENT_TOO_SLOW = unchecked((int)0x80041067),
        WBEM_E_NULL_SECURITY_DESCRIPTOR = unchecked((int)0x80041068),
        WBEM_E_TIMED_OUT = unchecked((int)0x80041069),
        WBEM_E_INVALID_ASSOCIATION = unchecked((int)0x8004106A),
        WBEM_E_AMBIGUOUS_OPERATION = unchecked((int)0x8004106B),
        WBEM_E_QUOTA_VIOLATION = unchecked((int)0x8004106C),
        WBEM_E_RESERVED_001 = unchecked((int)0x8004106D),
        WBEM_E_RESERVED_002 = unchecked((int)0x8004106E),
        WBEM_E_UNSUPPORTED_LOCALE = unchecked((int)0x8004106F),
        WBEM_E_HANDLE_OUT_OF_DATE = unchecked((int)0x80041070),
        WBEM_E_CONNECTION_FAILED = unchecked((int)0x80041071),
        WBEM_E_INVALID_HANDLE_REQUEST = unchecked((int)0x80041072),
        WBEM_E_PROPERTY_NAME_TOO_WIDE = unchecked((int)0x80041073),
        WBEM_E_CLASS_NAME_TOO_WIDE = unchecked((int)0x80041074),
        WBEM_E_METHOD_NAME_TOO_WIDE = unchecked((int)0x80041075),
        WBEM_E_QUALIFIER_NAME_TOO_WIDE = unchecked((int)0x80041076),
        WBEM_E_RERUN_COMMAND = unchecked((int)0x80041077),
        WBEM_E_DATABASE_VER_MISMATCH = unchecked((int)0x80041078),
        WBEM_E_VETO_DELETE = unchecked((int)0x80041079),
        WBEM_E_VETO_PUT = unchecked((int)0x8004107A),
        WBEM_E_INVALID_LOCALE = unchecked((int)0x80041080),
        WBEM_E_PROVIDER_SUSPENDED = unchecked((int)0x80041081),
        WBEM_E_SYNCHRONIZATION_REQUIRED = unchecked((int)0x80041082),
        WBEM_E_NO_SCHEMA = unchecked((int)0x80041083),
        WBEM_E_PROVIDER_ALREADY_REGISTERED = unchecked((int)0x80041084),
        WBEM_E_PROVIDER_NOT_REGISTERED = unchecked((int)0x80041085),
        WBEM_E_FATAL_TRANSPORT_ERROR = unchecked((int)0x80041086),
        WBEM_E_ENCRYPTED_CONNECTION_REQUIRED = unchecked((int)0x80041087),
        WBEM_E_PROVIDER_TIMED_OUT = unchecked((int)0x80041088),
        WBEM_E_NO_KEY = unchecked((int)0x80041089),
        WBEMESS_E_REGISTRATION_TOO_BROAD = unchecked((int)0x80042001),
        WBEMESS_E_REGISTRATION_TOO_PRECISE = unchecked((int)0x80042002),
        WBEMMOF_E_EXPECTED_QUALIFIER_NAME = unchecked((int)0x80044001),
        WBEMMOF_E_EXPECTED_SEMI = unchecked((int)0x80044002),
        WBEMMOF_E_EXPECTED_OPEN_BRACE = unchecked((int)0x80044003),
        WBEMMOF_E_EXPECTED_CLOSE_BRACE = unchecked((int)0x80044004),
        WBEMMOF_E_EXPECTED_CLOSE_BRACKET = unchecked((int)0x80044005),
        WBEMMOF_E_EXPECTED_CLOSE_PAREN = unchecked((int)0x80044006),
        WBEMMOF_E_ILLEGAL_CONSTANT_VALUE = unchecked((int)0x80044007),
        WBEMMOF_E_EXPECTED_TYPE_IDENTIFIER = unchecked((int)0x80044008),
        WBEMMOF_E_EXPECTED_OPEN_PAREN = unchecked((int)0x80044009),
        WBEMMOF_E_UNRECOGNIZED_TOKEN = unchecked((int)0x8004400A),
        WBEMMOF_E_UNRECOGNIZED_TYPE = unchecked((int)0x8004400B),
        WBEMMOF_E_EXPECTED_PROPERTY_NAME = unchecked((int)0x8004400C),
        WBEMMOF_E_TYPEDEF_NOT_SUPPORTED = unchecked((int)0x8004400D),
        WBEMMOF_E_UNEXPECTED_ALIAS = unchecked((int)0x8004400E),
        WBEMMOF_E_UNEXPECTED_ARRAY_INIT = unchecked((int)0x8004400F),
        WBEMMOF_E_INVALID_AMENDMENT_SYNTAX = unchecked((int)0x80044010),
        WBEMMOF_E_INVALID_DUPLICATE_AMENDMENT = unchecked((int)0x80044011),
        WBEMMOF_E_INVALID_PRAGMA = unchecked((int)0x80044012),
        WBEMMOF_E_INVALID_NAMESPACE_SYNTAX = unchecked((int)0x80044013),
        WBEMMOF_E_EXPECTED_CLASS_NAME = unchecked((int)0x80044014),
        WBEMMOF_E_TYPE_MISMATCH = unchecked((int)0x80044015),
        WBEMMOF_E_EXPECTED_ALIAS_NAME = unchecked((int)0x80044016),
        WBEMMOF_E_INVALID_CLASS_DECLARATION = unchecked((int)0x80044017),
        WBEMMOF_E_INVALID_INSTANCE_DECLARATION = unchecked((int)0x80044018),
        WBEMMOF_E_EXPECTED_DOLLAR = unchecked((int)0x80044019),
        WBEMMOF_E_CIMTYPE_QUALIFIER = unchecked((int)0x8004401A),
        WBEMMOF_E_DUPLICATE_PROPERTY = unchecked((int)0x8004401B),
        WBEMMOF_E_INVALID_NAMESPACE_SPECIFICATION = unchecked((int)0x8004401C),
        WBEMMOF_E_OUT_OF_RANGE = unchecked((int)0x8004401D),
        WBEMMOF_E_INVALID_FILE = unchecked((int)0x8004401E),
        WBEMMOF_E_ALIASES_IN_EMBEDDED = unchecked((int)0x8004401F),
        WBEMMOF_E_NULL_ARRAY_ELEM = unchecked((int)0x80044020),
        WBEMMOF_E_DUPLICATE_QUALIFIER = unchecked((int)0x80044021),
        WBEMMOF_E_EXPECTED_FLAVOR_TYPE = unchecked((int)0x80044022),
        WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES = unchecked((int)0x80044023),
        WBEMMOF_E_MULTIPLE_ALIASES = unchecked((int)0x80044024),
        WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES2 = unchecked((int)0x80044025),
        WBEMMOF_E_NO_ARRAYS_RETURNED = unchecked((int)0x80044026),
        WBEMMOF_E_MUST_BE_IN_OR_OUT = unchecked((int)0x80044027),
        WBEMMOF_E_INVALID_FLAGS_SYNTAX = unchecked((int)0x80044028),
        WBEMMOF_E_EXPECTED_BRACE_OR_BAD_TYPE = unchecked((int)0x80044029),
        WBEMMOF_E_UNSUPPORTED_CIMV22_QUAL_VALUE = unchecked((int)0x8004402A),
        WBEMMOF_E_UNSUPPORTED_CIMV22_DATA_TYPE = unchecked((int)0x8004402B),
        WBEMMOF_E_INVALID_DELETEINSTANCE_SYNTAX = unchecked((int)0x8004402C),
        WBEMMOF_E_INVALID_QUALIFIER_SYNTAX = unchecked((int)0x8004402D),
        WBEMMOF_E_QUALIFIER_USED_OUTSIDE_SCOPE = unchecked((int)0x8004402E),
        WBEMMOF_E_ERROR_CREATING_TEMP_FILE = unchecked((int)0x8004402F),
        WBEMMOF_E_ERROR_INVALID_INCLUDE_FILE = unchecked((int)0x80044030),
        WBEMMOF_E_INVALID_DELETECLASS_SYNTAX = unchecked((int)0x80044031),
    }

    enum tag_WMI_OBJ_TEXT
    {
        WMI_OBJ_TEXT_CIM_DTD_2_0 = unchecked((int)0x00000001),
        WMI_OBJ_TEXT_WMI_DTD_2_0 = unchecked((int)0x00000002),
        WMI_OBJ_TEXT_WMI_EXT1 = unchecked((int)0x00000003),
        WMI_OBJ_TEXT_WMI_EXT2 = unchecked((int)0x00000004),
        WMI_OBJ_TEXT_WMI_EXT3 = unchecked((int)0x00000005),
        WMI_OBJ_TEXT_WMI_EXT4 = unchecked((int)0x00000006),
        WMI_OBJ_TEXT_WMI_EXT5 = unchecked((int)0x00000007),
        WMI_OBJ_TEXT_WMI_EXT6 = unchecked((int)0x00000008),
        WMI_OBJ_TEXT_WMI_EXT7 = unchecked((int)0x00000009),
        WMI_OBJ_TEXT_WMI_EXT8 = unchecked((int)0x0000000A),
        WMI_OBJ_TEXT_WMI_EXT9 = unchecked((int)0x0000000B),
        WMI_OBJ_TEXT_WMI_EXT10 = unchecked((int)0x0000000C),
        WMI_OBJ_TEXT_LAST = unchecked((int)0x0000000D),
    }

    enum tag_WBEM_COMPILER_OPTIONS
    {
        WBEM_FLAG_CHECK_ONLY = unchecked((int)0x00000001),
        WBEM_FLAG_AUTORECOVER = unchecked((int)0x00000002),
        WBEM_FLAG_WMI_CHECK = unchecked((int)0x00000004),
        WBEM_FLAG_CONSOLE_PRINT = unchecked((int)0x00000008),
        WBEM_FLAG_DONT_ADD_TO_LIST = unchecked((int)0x00000010),
        WBEM_FLAG_SPLIT_FILES = unchecked((int)0x00000020),
        WBEM_FLAG_CONNECT_REPOSITORY_ONLY = unchecked((int)0x00000040),
    }

    enum tag_WBEM_PROVIDER_REQUIREMENTS_TYPE
    {
        WBEM_REQUIREMENTS_START_POSTFILTER = unchecked((int)0x00000000),
        WBEM_REQUIREMENTS_STOP_POSTFILTER = unchecked((int)0x00000001),
        WBEM_REQUIREMENTS_RECHECK_SUBSCRIPTIONS = unchecked((int)0x00000002),
    }

    enum tag_WBEM_EXTRA_RETURN_CODES
    {
        WBEM_S_INITIALIZED = unchecked((int)0x00000000),
        WBEM_S_LIMITED_SERVICE = unchecked((int)0x00043001),
        WBEM_S_INDIRECTLY_UPDATED = unchecked((int)0x00043002),
        WBEM_S_SUBJECT_TO_SDS = unchecked((int)0x00043003),
        WBEM_E_RETRY_LATER = unchecked((int)0x80043001),
        WBEM_E_RESOURCE_CONTENTION = unchecked((int)0x80043002),
    }

    enum tag_WBEM_PROVIDER_FLAGS
    {
        WBEM_FLAG_OWNER_UPDATE = unchecked((int)0x00010000),
    }

    enum tag_WBEM_INFORMATION_FLAG_TYPE
    {
        WBEM_FLAG_SHORT_NAME = unchecked((int)0x00000001),
        WBEM_FLAG_LONG_NAME = unchecked((int)0x00000002),
    }

    enum tag_WBEM_BATCH_TYPE
    {
        WBEM_FLAG_BATCH_IF_NEEDED = unchecked((int)0x00000000),
        WBEM_FLAG_MUST_BATCH = unchecked((int)0x00000001),
        WBEM_FLAG_MUST_NOT_BATCH = unchecked((int)0x00000002),
    }

    enum tag_WBEM_PATH_STATUS_FLAG
    {
        WBEMPATH_INFO_ANON_LOCAL_MACHINE = unchecked((int)0x00000001),
        WBEMPATH_INFO_HAS_MACHINE_NAME = unchecked((int)0x00000002),
        WBEMPATH_INFO_IS_CLASS_REF = unchecked((int)0x00000004),
        WBEMPATH_INFO_IS_INST_REF = unchecked((int)0x00000008),
        WBEMPATH_INFO_HAS_SUBSCOPES = unchecked((int)0x00000010),
        WBEMPATH_INFO_IS_COMPOUND = unchecked((int)0x00000020),
        WBEMPATH_INFO_HAS_V2_REF_PATHS = unchecked((int)0x00000040),
        WBEMPATH_INFO_HAS_IMPLIED_KEY = unchecked((int)0x00000080),
        WBEMPATH_INFO_CONTAINS_SINGLETON = unchecked((int)0x00000100),
        WBEMPATH_INFO_V1_COMPLIANT = unchecked((int)0x00000200),
        WBEMPATH_INFO_V2_COMPLIANT = unchecked((int)0x00000400),
        WBEMPATH_INFO_CIM_COMPLIANT = unchecked((int)0x00000800),
        WBEMPATH_INFO_IS_SINGLETON = unchecked((int)0x00001000),
        WBEMPATH_INFO_IS_PARENT = unchecked((int)0x00002000),
        WBEMPATH_INFO_SERVER_NAMESPACE_ONLY = unchecked((int)0x00004000),
        WBEMPATH_INFO_NATIVE_PATH = unchecked((int)0x00008000),
        WBEMPATH_INFO_WMI_PATH = unchecked((int)0x00010000),
        WBEMPATH_INFO_PATH_HAD_SERVER = unchecked((int)0x00020000),
    }

    enum tag_WBEM_PATH_CREATE_FLAG
    {
        WBEMPATH_CREATE_ACCEPT_RELATIVE = unchecked((int)0x00000001),
        WBEMPATH_CREATE_ACCEPT_ABSOLUTE = unchecked((int)0x00000002),
        WBEMPATH_CREATE_ACCEPT_ALL = unchecked((int)0x00000004),
        WBEMPATH_TREAT_SINGLE_IDENT_AS_NS = unchecked((int)0x00000008),
    }

    enum tag_WBEM_GET_TEXT_FLAGS
    {
        WBEMPATH_COMPRESSED = unchecked((int)0x00000001),
        WBEMPATH_GET_RELATIVE_ONLY = unchecked((int)0x00000002),
        WBEMPATH_GET_SERVER_TOO = unchecked((int)0x00000004),
        WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY = unchecked((int)0x00000008),
        WBEMPATH_GET_NAMESPACE_ONLY = unchecked((int)0x00000010),
        WBEMPATH_GET_ORIGINAL = unchecked((int)0x00000020),
    }

    enum tag_WBEM_GET_KEY_FLAGS
    {
        WBEMPATH_TEXT = unchecked((int)0x00000001),
        WBEMPATH_QUOTEDTEXT = unchecked((int)0x00000002),
    }

    enum WMIQ_ANALYSIS_TYPE
    {
        WMIQ_ANALYSIS_RPN_SEQUENCE = unchecked((int)0x00000001),
        WMIQ_ANALYSIS_ASSOC_QUERY = unchecked((int)0x00000002),
        WMIQ_ANALYSIS_PROP_ANALYSIS_MATRIX = unchecked((int)0x00000003),
        WMIQ_ANALYSIS_QUERY_TEXT = unchecked((int)0x00000004),
        WMIQ_ANALYSIS_RESERVED = unchecked((int)0x08000000),
    }

    enum __MIDL___MIDL_itf_wmi_0000_0001
    {
        WMIQ_ANALYSIS_RPN_SEQUENCE = unchecked((int)0x00000001),
        WMIQ_ANALYSIS_ASSOC_QUERY = unchecked((int)0x00000002),
        WMIQ_ANALYSIS_PROP_ANALYSIS_MATRIX = unchecked((int)0x00000003),
        WMIQ_ANALYSIS_QUERY_TEXT = unchecked((int)0x00000004),
        WMIQ_ANALYSIS_RESERVED = unchecked((int)0x08000000),
    }

    enum WMIQ_RPN_TOKEN_FLAGS
    {
        WMIQ_RPN_TOKEN_EXPRESSION = unchecked((int)0x00000001),
        WMIQ_RPN_TOKEN_AND = unchecked((int)0x00000002),
        WMIQ_RPN_TOKEN_OR = unchecked((int)0x00000003),
        WMIQ_RPN_TOKEN_NOT = unchecked((int)0x00000004),
        WMIQ_RPN_OP_UNDEFINED = unchecked((int)0x00000000),
        WMIQ_RPN_OP_EQ = unchecked((int)0x00000001),
        WMIQ_RPN_OP_NE = unchecked((int)0x00000002),
        WMIQ_RPN_OP_GE = unchecked((int)0x00000003),
        WMIQ_RPN_OP_LE = unchecked((int)0x00000004),
        WMIQ_RPN_OP_LT = unchecked((int)0x00000005),
        WMIQ_RPN_OP_GT = unchecked((int)0x00000006),
        WMIQ_RPN_OP_LIKE = unchecked((int)0x00000007),
        WMIQ_RPN_OP_ISA = unchecked((int)0x00000008),
        WMIQ_RPN_OP_ISNOTA = unchecked((int)0x00000009),
        WMIQ_RPN_LEFT_PROPERTY_NAME = unchecked((int)0x00000001),
        WMIQ_RPN_RIGHT_PROPERTY_NAME = unchecked((int)0x00000002),
        WMIQ_RPN_CONST2 = unchecked((int)0x00000004),
        WMIQ_RPN_CONST = unchecked((int)0x00000008),
        WMIQ_RPN_RELOP = unchecked((int)0x00000010),
        WMIQ_RPN_LEFT_FUNCTION = unchecked((int)0x00000020),
        WMIQ_RPN_RIGHT_FUNCTION = unchecked((int)0x00000040),
        WMIQ_RPN_GET_TOKEN_TYPE = unchecked((int)0x00000001),
        WMIQ_RPN_GET_EXPR_SHAPE = unchecked((int)0x00000002),
        WMIQ_RPN_GET_LEFT_FUNCTION = unchecked((int)0x00000003),
        WMIQ_RPN_GET_RIGHT_FUNCTION = unchecked((int)0x00000004),
        WMIQ_RPN_GET_RELOP = unchecked((int)0x00000005),
        WMIQ_RPN_NEXT_TOKEN = unchecked((int)0x00000001),
        WMIQ_RPN_FROM_UNARY = unchecked((int)0x00000001),
        WMIQ_RPN_FROM_PATH = unchecked((int)0x00000002),
        WMIQ_RPN_FROM_CLASS_LIST = unchecked((int)0x00000004),
    }

    enum __MIDL___MIDL_itf_wmi_0000_0002
    {
        WMIQ_RPN_TOKEN_EXPRESSION = unchecked((int)0x00000001),
        WMIQ_RPN_TOKEN_AND = unchecked((int)0x00000002),
        WMIQ_RPN_TOKEN_OR = unchecked((int)0x00000003),
        WMIQ_RPN_TOKEN_NOT = unchecked((int)0x00000004),
        WMIQ_RPN_OP_UNDEFINED = unchecked((int)0x00000000),
        WMIQ_RPN_OP_EQ = unchecked((int)0x00000001),
        WMIQ_RPN_OP_NE = unchecked((int)0x00000002),
        WMIQ_RPN_OP_GE = unchecked((int)0x00000003),
        WMIQ_RPN_OP_LE = unchecked((int)0x00000004),
        WMIQ_RPN_OP_LT = unchecked((int)0x00000005),
        WMIQ_RPN_OP_GT = unchecked((int)0x00000006),
        WMIQ_RPN_OP_LIKE = unchecked((int)0x00000007),
        WMIQ_RPN_OP_ISA = unchecked((int)0x00000008),
        WMIQ_RPN_OP_ISNOTA = unchecked((int)0x00000009),
        WMIQ_RPN_LEFT_PROPERTY_NAME = unchecked((int)0x00000001),
        WMIQ_RPN_RIGHT_PROPERTY_NAME = unchecked((int)0x00000002),
        WMIQ_RPN_CONST2 = unchecked((int)0x00000004),
        WMIQ_RPN_CONST = unchecked((int)0x00000008),
        WMIQ_RPN_RELOP = unchecked((int)0x00000010),
        WMIQ_RPN_LEFT_FUNCTION = unchecked((int)0x00000020),
        WMIQ_RPN_RIGHT_FUNCTION = unchecked((int)0x00000040),
        WMIQ_RPN_GET_TOKEN_TYPE = unchecked((int)0x00000001),
        WMIQ_RPN_GET_EXPR_SHAPE = unchecked((int)0x00000002),
        WMIQ_RPN_GET_LEFT_FUNCTION = unchecked((int)0x00000003),
        WMIQ_RPN_GET_RIGHT_FUNCTION = unchecked((int)0x00000004),
        WMIQ_RPN_GET_RELOP = unchecked((int)0x00000005),
        WMIQ_RPN_NEXT_TOKEN = unchecked((int)0x00000001),
        WMIQ_RPN_FROM_UNARY = unchecked((int)0x00000001),
        WMIQ_RPN_FROM_PATH = unchecked((int)0x00000002),
        WMIQ_RPN_FROM_CLASS_LIST = unchecked((int)0x00000004),
    }

    enum WMIQ_ASSOCQ_FLAGS
    {
        WMIQ_ASSOCQ_ASSOCIATORS = unchecked((int)0x00000001),
        WMIQ_ASSOCQ_REFERENCES = unchecked((int)0x00000002),
        WMIQ_ASSOCQ_RESULTCLASS = unchecked((int)0x00000004),
        WMIQ_ASSOCQ_ASSOCCLASS = unchecked((int)0x00000008),
        WMIQ_ASSOCQ_ROLE = unchecked((int)0x00000010),
        WMIQ_ASSOCQ_RESULTROLE = unchecked((int)0x00000020),
        WMIQ_ASSOCQ_REQUIREDQUALIFIER = unchecked((int)0x00000040),
        WMIQ_ASSOCQ_REQUIREDASSOCQUALIFIER = unchecked((int)0x00000080),
        WMIQ_ASSOCQ_CLASSDEFSONLY = unchecked((int)0x00000100),
        WMIQ_ASSOCQ_KEYSONLY = unchecked((int)0x00000200),
        WMIQ_ASSOCQ_SCHEMAONLY = unchecked((int)0x00000400),
        WMIQ_ASSOCQ_CLASSREFSONLY = unchecked((int)0x00000800),
    }

    enum __MIDL___MIDL_itf_wmi_0000_0003
    {
        WMIQ_ASSOCQ_ASSOCIATORS = unchecked((int)0x00000001),
        WMIQ_ASSOCQ_REFERENCES = unchecked((int)0x00000002),
        WMIQ_ASSOCQ_RESULTCLASS = unchecked((int)0x00000004),
        WMIQ_ASSOCQ_ASSOCCLASS = unchecked((int)0x00000008),
        WMIQ_ASSOCQ_ROLE = unchecked((int)0x00000010),
        WMIQ_ASSOCQ_RESULTROLE = unchecked((int)0x00000020),
        WMIQ_ASSOCQ_REQUIREDQUALIFIER = unchecked((int)0x00000040),
        WMIQ_ASSOCQ_REQUIREDASSOCQUALIFIER = unchecked((int)0x00000080),
        WMIQ_ASSOCQ_CLASSDEFSONLY = unchecked((int)0x00000100),
        WMIQ_ASSOCQ_KEYSONLY = unchecked((int)0x00000200),
        WMIQ_ASSOCQ_SCHEMAONLY = unchecked((int)0x00000400),
        WMIQ_ASSOCQ_CLASSREFSONLY = unchecked((int)0x00000800),
    }

    enum tag_WMIQ_LANGUAGE_FEATURES
    {
        WMIQ_LF1_BASIC_SELECT = unchecked((int)0x00000001),
        WMIQ_LF2_CLASS_NAME_IN_QUERY = unchecked((int)0x00000002),
        WMIQ_LF3_STRING_CASE_FUNCTIONS = unchecked((int)0x00000003),
        WMIQ_LF4_PROP_TO_PROP_TESTS = unchecked((int)0x00000004),
        WMIQ_LF5_COUNT_STAR = unchecked((int)0x00000005),
        WMIQ_LF6_ORDER_BY = unchecked((int)0x00000006),
        WMIQ_LF7_DISTINCT = unchecked((int)0x00000007),
        WMIQ_LF8_ISA = unchecked((int)0x00000008),
        WMIQ_LF9_THIS = unchecked((int)0x00000009),
        WMIQ_LF10_COMPEX_SUBEXPRESSIONS = unchecked((int)0x0000000A),
        WMIQ_LF11_ALIASING = unchecked((int)0x0000000B),
        WMIQ_LF12_GROUP_BY_HAVING = unchecked((int)0x0000000C),
        WMIQ_LF13_WMI_WITHIN = unchecked((int)0x0000000D),
        WMIQ_LF14_SQL_WRITE_OPERATIONS = unchecked((int)0x0000000E),
        WMIQ_LF15_GO = unchecked((int)0x0000000F),
        WMIQ_LF16_SINGLE_LEVEL_TRANSACTIONS = unchecked((int)0x00000010),
        WMIQ_LF17_QUALIFIED_NAMES = unchecked((int)0x00000011),
        WMIQ_LF18_ASSOCIATONS = unchecked((int)0x00000012),
        WMIQ_LF19_SYSTEM_PROPERTIES = unchecked((int)0x00000013),
        WMIQ_LF20_EXTENDED_SYSTEM_PROPERTIES = unchecked((int)0x00000014),
        WMIQ_LF21_SQL89_JOINS = unchecked((int)0x00000015),
        WMIQ_LF22_SQL92_JOINS = unchecked((int)0x00000016),
        WMIQ_LF23_SUBSELECTS = unchecked((int)0x00000017),
        WMIQ_LF24_UMI_EXTENSIONS = unchecked((int)0x00000018),
        WMIQ_LF25_DATEPART = unchecked((int)0x00000019),
        WMIQ_LF26_LIKE = unchecked((int)0x0000001A),
        WMIQ_LF27_CIM_TEMPORAL_CONSTRUCTS = unchecked((int)0x0000001B),
        WMIQ_LF28_STANDARD_AGGREGATES = unchecked((int)0x0000001C),
        WMIQ_LF29_MULTI_LEVEL_ORDER_BY = unchecked((int)0x0000001D),
        WMIQ_LF30_WMI_PRAGMAS = unchecked((int)0x0000001E),
        WMIQ_LF31_QUALIFIER_TESTS = unchecked((int)0x0000001F),
        WMIQ_LF32_SP_EXECUTE = unchecked((int)0x00000020),
        WMIQ_LF33_ARRAY_ACCESS = unchecked((int)0x00000021),
        WMIQ_LF34_UNION = unchecked((int)0x00000022),
        WMIQ_LF35_COMPLEX_SELECT_TARGET = unchecked((int)0x00000023),
        WMIQ_LF36_REFERENCE_TESTS = unchecked((int)0x00000024),
        WMIQ_LF37_SELECT_INTO = unchecked((int)0x00000025),
        WMIQ_LF38_BASIC_DATETIME_TESTS = unchecked((int)0x00000026),
        WMIQ_LF39_COUNT_COLUMN = unchecked((int)0x00000027),
        WMIQ_LF40_BETWEEN = unchecked((int)0x00000028),
        WMIQ_LF_LAST = unchecked((int)0x00000028),
    }

    enum tag_WMIQ_RPNQ_FEATURE
    {
        WMIQ_RPNF_WHERE_CLAUSE_PRESENT = unchecked((int)0x00000001),
        WMIQ_RPNF_QUERY_IS_CONJUNCTIVE = unchecked((int)0x00000002),
        WMIQ_RPNF_QUERY_IS_DISJUNCTIVE = unchecked((int)0x00000004),
        WMIQ_RPNF_PROJECTION = unchecked((int)0x00000008),
        WMIQ_RPNF_FEATURE_SELECT_STAR = unchecked((int)0x00000010),
        WMIQ_RPNF_EQUALITY_TESTS_ONLY = unchecked((int)0x00000020),
        WMIQ_RPNF_COUNT_STAR = unchecked((int)0x00000040),
        WMIQ_RPNF_QUALIFIED_NAMES_IN_SELECT = unchecked((int)0x00000080),
        WMIQ_RPNF_QUALIFIED_NAMES_IN_WHERE = unchecked((int)0x00000100),
        WMIQ_RPNF_PROP_TO_PROP_TESTS = unchecked((int)0x00000200),
        WMIQ_RPNF_ORDER_BY = unchecked((int)0x00000400),
        WMIQ_RPNF_ISA_USED = unchecked((int)0x00000800),
        WMIQ_RPNF_ISNOTA_USED = unchecked((int)0x00001000),
        WMIQ_RPNF_GROUP_BY_HAVING = unchecked((int)0x00002000),
        WMIQ_RPNF_WITHIN_INTERVAL = unchecked((int)0x00004000),
        WMIQ_RPNF_WITHIN_AGGREGATE = unchecked((int)0x00008000),
        WMIQ_RPNF_SYSPROP_CLASS = unchecked((int)0x00010000),
        WMIQ_RPNF_REFERENCE_TESTS = unchecked((int)0x00020000),
        WMIQ_RPNF_DATETIME_TESTS = unchecked((int)0x00040000),
        WMIQ_RPNF_ARRAY_ACCESS = unchecked((int)0x00080000),
        WMIQ_RPNF_QUALIFIER_FILTER = unchecked((int)0x00100000),
        WMIQ_RPNF_SELECTED_FROM_PATH = unchecked((int)0x00200000),
    }
    #endregion

    #region Structs
    struct tag_CompileStatusInfo
    {
        public Int32 lPhaseError;
        [MarshalAs(UnmanagedType.Error)] public   Int32 hRes;
        public Int32 ObjectNum;
        public Int32 FirstLine;
        public Int32 LastLine;
        public UInt32 dwOutFlags;
    }

    struct tag_SWbemQueryQualifiedName
    {
        /*[ComConversionLossAttribute]*/
        public UInt32 m_uVersion;
        public UInt32 m_uTokenType;
        public UInt32 m_uNameListSize;
        public IntPtr m_ppszNameList;
        /*[ComConversionLossAttribute]*/
        public Int32 m_bArraysUsed;
        public IntPtr m_pbArrayElUsed;
        /*[ComConversionLossAttribute]*/
        public IntPtr m_puArrayIndex;
        /*[ComConversionLossAttribute]*/
    }

    struct tag_SWbemRpnConst
    {
        public UInt64 unionhack;
    }

    struct tag_SWbemRpnQueryToken
    {
        /*[ComConversionLossAttribute]*/
        public UInt32 m_uVersion;
        public UInt32 m_uTokenType;
        public UInt32 m_uSubexpressionShape;
        public UInt32 m_uOperator;
        public IntPtr m_pRightIdent;
        /*[ComConversionLossAttribute]*/
        public IntPtr m_pLeftIdent;
        /*[ComConversionLossAttribute]*/
        public UInt32 m_uConstApparentType;
        public tag_SWbemRpnConst m_Const;
        public UInt32 m_uConst2ApparentType;
        public tag_SWbemRpnConst m_Const2;
        [MarshalAs(UnmanagedType.LPWStr)] public   string m_pszRightFunc;
        [MarshalAs(UnmanagedType.LPWStr)] public   string m_pszLeftFunc;
    }

    struct tag_SWbemRpnTokenList
    {
        public UInt32 m_uVersion;
        public UInt32 m_uTokenType;
        public UInt32 m_uNumTokens;
    }

    struct tag_SWbemRpnEncodedQuery
    {
        /*[ComConversionLossAttribute]*/
        public UInt32 m_uVersion;
        public UInt32 m_uTokenType;
        public UInt32 m_uParsedFeatureMask1;
        public UInt32 m_uParsedFeatureMask2;
        public UInt32 m_uDetectedArraySize;
        public IntPtr m_puDetectedFeatures;
        /*[ComConversionLossAttribute]*/
        public UInt32 m_uSelectListSize;
        public IntPtr m_ppSelectList;
        /*[ComConversionLossAttribute]*/
        public UInt32 m_uFromTargetType;
        [MarshalAs(UnmanagedType.LPWStr)] public   string m_pszOptionalFromPath;
        public UInt32 m_uFromListSize;
        public IntPtr m_ppszFromList;
        /*[ComConversionLossAttribute]*/
        public UInt32 m_uWhereClauseSize;
        public IntPtr m_ppRpnWhereClause;
        /*[ComConversionLossAttribute]*/
        public double m_dblWithinPolling;
        public double m_dblWithinWindow;
        public UInt32 m_uOrderByListSize;
        public IntPtr m_ppszOrderByList;
        /*[ComConversionLossAttribute]*/
        public IntPtr m_uOrderDirectionEl;
        /*[ComConversionLossAttribute]*/
    }

    struct tag_SWbemAnalysisMatrix
    {
        /*[ComConversionLossAttribute]*/
        public UInt32 m_uVersion;
        public UInt32 m_uMatrixType;
        [MarshalAs(UnmanagedType.LPWStr)] public   string m_pszProperty;
        public UInt32 m_uPropertyType;
        public UInt32 m_uEntries;
        public IntPtr m_pValues;
        /*[ComConversionLossAttribute]*/
        public IntPtr m_pbTruthTable;
        /*[ComConversionLossAttribute]*/
    }

    struct tag_SWbemAnalysisMatrixList
    {
        /*[ComConversionLossAttribute]*/
        public UInt32 m_uVersion;
        public UInt32 m_uMatrixType;
        public UInt32 m_uNumMatrices;
        public IntPtr m_pMatrices;
        /*[ComConversionLossAttribute]*/
    }

    struct tag_SWbemAssocQueryInf
    {
        public UInt32 m_uVersion;
        public UInt32 m_uAnalysisType;
        public UInt32 m_uFeatureMask;
        [MarshalAs(UnmanagedType.Interface)] public   IWbemPath m_pPath;
        [MarshalAs(UnmanagedType.LPWStr)] public   string m_pszPath;
        [MarshalAs(UnmanagedType.LPWStr)] public   string m_pszQueryText;
        [MarshalAs(UnmanagedType.LPWStr)] public   string m_pszResultClass;
        [MarshalAs(UnmanagedType.LPWStr)] public   string m_pszAssocClass;
        [MarshalAs(UnmanagedType.LPWStr)] public   string m_pszRole;
        [MarshalAs(UnmanagedType.LPWStr)] public   string m_pszResultRole;
        [MarshalAs(UnmanagedType.LPWStr)] public   string m_pszRequiredQualifier;
        [MarshalAs(UnmanagedType.LPWStr)] public   string m_pszRequiredAssocQualifier;
    }
    #endregion

    #region Co Classes
    [ClassInterfaceAttribute((short)0x0000)]
    [GuidAttribute("4590F811-1D3A-11D0-891F-00AA004B2E24")]
    [TypeLibTypeAttribute(0x0202)]
    [ComImport]
    class WbemLocator 
    {
    }

    [ClassInterfaceAttribute((short)0x0000)]
    [GuidAttribute("674B6698-EE92-11D0-AD71-00C04FD8FDFF")]
    [TypeLibTypeAttribute(0x0202)]
    [ComImport]
    class WbemContext 
    {
    }

    [ClassInterfaceAttribute((short)0x0000)]
    [GuidAttribute("49BD2028-1523-11D1-AD79-00C04FD8FDFF")]
    [TypeLibTypeAttribute(0x0002)]
    [ComImport]
    class UnsecuredApartment 
    {
    }

    [GuidAttribute("9A653086-174F-11D2-B5F9-00104B703EFD")]
    [ClassInterfaceAttribute((short)0x0000)]
    [TypeLibTypeAttribute(0x0002)]
    [ComImport]
    class WbemClassObject 
    {
    }

    [ClassInterfaceAttribute((short)0x0000)]
    [GuidAttribute("6DAF9757-2E37-11D2-AEC9-00C04FB68820")]
    [TypeLibTypeAttribute(0x0002)]
    [ComImport]
    class MofCompiler 
    {
    }

    [ClassInterfaceAttribute((short)0x0000)]
    [TypeLibTypeAttribute(0x0002)]
    [GuidAttribute("EB87E1BD-3233-11D2-AEC9-00C04FB68820")]
    [ComImport]
    class WbemStatusCodeText 
    {
    }

    [GuidAttribute("C49E32C6-BC8B-11D2-85D4-00105A1F8304")]
    [ClassInterfaceAttribute((short)0x0000)]
    [TypeLibTypeAttribute(0x0002)]
    [ComImport]
    class WbemBackupRestore 
    {
    }

    [ClassInterfaceAttribute((short)0x0000)]
    [GuidAttribute("C71566F2-561E-11D1-AD87-00C04FD8FDFF")]
    [TypeLibTypeAttribute(0x0202)]
    [ComImport]
    class WbemRefresher 
    {
    }

    [ClassInterfaceAttribute((short)0x0000)]
    [TypeLibTypeAttribute(0x0202)]
    [GuidAttribute("8D1C559D-84F0-4BB3-A7D5-56A7435A9BA6")]
    [ComImport]
    class WbemObjectTextSrc 
    {
    }

    [ClassInterfaceAttribute((short)0x0000)]
    [GuidAttribute("CB8555CC-9128-11D1-AD9B-00C04FD8FDFF")]
    [TypeLibTypeAttribute(0x0002)]
    [ComImport]
    class WbemAdministrativeLocator 
    {
    }

    [TypeLibTypeAttribute(0x0002)]
    [ClassInterfaceAttribute((short)0x0000)]
    [GuidAttribute("CD184336-9128-11D1-AD9B-00C04FD8FDFF")]
    [ComImport]
    class WbemAuthenticatedLocator 
    {
    }

    [TypeLibTypeAttribute(0x0002)]
    [ClassInterfaceAttribute((short)0x0000)]
    [GuidAttribute("443E7B79-DE31-11D2-B340-00104BCC4B4A")]
    [ComImport]
    class WbemUnauthenticatedLocator 
    {
    }

    [GuidAttribute("4CFC7932-0F9D-4BEF-9C32-8EA2A6B56FCB")]
    [TypeLibTypeAttribute(0x0002)]
    [ClassInterfaceAttribute((short)0x0000)]
    [ComImport]
    class WbemDecoupledRegistrar 
    {
    }

    [GuidAttribute("F5F75737-2843-4F22-933D-C76A97CDA62F")]
    [TypeLibTypeAttribute(0x0002)]
    [ClassInterfaceAttribute((short)0x0000)]
    [ComImport]
    class WbemDecoupledBasicEventProvider 
    {
    }

    [ClassInterfaceAttribute((short)0x0000)]
    [GuidAttribute("CF4CC405-E2C5-4DDD-B3CE-5E7582D8C9FA")]
    [TypeLibTypeAttribute(0x0202)]
    [ComImport]
    class WbemDefPath 
    {
    }

    [GuidAttribute("EAC8A024-21E2-4523-AD73-A71A0AA2F56A")]
    [ClassInterfaceAttribute((short)0x0000)]
    [TypeLibTypeAttribute(0x0002)]
    [ComImport]
    class WbemQuery 
    {
    }
    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\instrumentation\managementinstaller.cs ===
namespace System.Management.Instrumentation
{
    using System;
    using System.Reflection;
    using System.Collections;
    using System.Configuration.Install;
    using System.Text;
    using System.IO;


	/// <summary>
	/// Include an instance of this installer class in the project installer for
	/// an assembly that includes instrumentaiton
	/// </summary>
    public class ManagementInstaller : Installer
	{
        // TODO: Is this correct
        private static bool helpPrinted = false;
        /// <summary>
        /// Displays installer options for this class
        /// </summary>
        public override string HelpText {
            get {
                if (helpPrinted)
                    return base.HelpText;
                else {
                    helpPrinted = true;
//                    return Res.GetString(Res.HelpText) + "\r\n" + base.HelpText;
                    // TODO: Localize
                    StringBuilder help = new StringBuilder();
                    help.Append("/MOF=[filename]\r\n");
                    help.Append("   File to write equivalent MOF for instrumented assemblies");
                    return help.ToString() + "\r\n" + base.HelpText;
                }
            }
        }

    
        /// <summary>
        /// Install the assembly
        /// </summary>
        /// <param name="savedState"></param>
		public override void Install(IDictionary savedState) {
			base.Install(savedState);
            // TODO: Localize
            Context.LogMessage("Installing WMI Schema: Started");

            string assemblyPath = Context.Parameters["assemblypath"];
            Assembly assembly = Assembly.LoadFrom(assemblyPath);

            SchemaNaming naming = SchemaNaming.GetSchemaNaming(assembly);

            // See if this assembly provides instrumentation
            if(null == naming)
                return;

            if(naming.IsAssemblyRegistered() == false)
            {
                Context.LogMessage("Registering assembly: " + naming.DecoupledProviderInstanceName);

                naming.RegisterNonAssemblySpecificSchema(Context);
                naming.RegisterAssemblySpecificSchema();
            }
            mof = naming.GenerateMof();

            Context.LogMessage("Installing WMI Schema: Finished");
		}

        string mof;

        /// <summary>
        /// Commit
        /// </summary>
        /// <param name="savedState"></param>
		public override void Commit(IDictionary savedState) {
			base.Commit(savedState);

            // See if we were asked to generate a MOF file
            if(Context.Parameters.ContainsKey("mof"))
            {
                string mofFile = Context.Parameters["mof"];

                // bug#62252 - Pick a default MOF file name
                if(mofFile == null || mofFile.Length == 0)
                {
                    mofFile = Context.Parameters["assemblypath"];
                    if(mofFile == null || mofFile.Length == 0)
                        mofFile = "defaultmoffile";
                    else
                        mofFile = Path.GetFileName(mofFile);
                }

                // Append '.mof' in necessary
                if(mofFile.Length<4)
                    mofFile += ".mof";
                else
                {
                    string end = mofFile.Substring(mofFile.Length-4,4);
                    end.ToLower();
                    if(end != ".mof")
                        mofFile += ".mof";
                }
                Context.LogMessage("Generating MOF file: "+mofFile);
                using(StreamWriter log = new StreamWriter(mofFile, false, Encoding.ASCII))
                {
                    log.WriteLine("//**************************************************************************");
                    log.WriteLine("//* {0}", mofFile);
                    log.WriteLine("//**************************************************************************");
                    log.WriteLine(mof);
                }
            }
		}
        /// <summary>
        /// Rollback
        /// </summary>
        /// <param name="savedState"></param>
		public override void Rollback(IDictionary savedState) {
			base.Rollback(savedState);
		}

        /// <summary>
        /// Uninstall
        /// </summary>
        /// <param name="savedState"></param>
		public override void Uninstall(IDictionary savedState) {
			base.Uninstall(savedState);
		}
	}

    /// <summary>
    /// This class is a default project installer from assemblies that have management
    /// instrumentation but do not use other installers (such as services, or message
    /// queues).  To use this default project installer, simply derive a class from
    /// DefaultManagementProjectInstaller inside the assembly.  No methods need
    /// to be overridden. 
    /// </summary>
    public class DefaultManagementProjectInstaller : Installer
    {
        /// <summary>
        /// Default constructor for DefaultManagementProjectInstaller
        /// </summary>
        public DefaultManagementProjectInstaller()
        {
            // Instantiate installer for assembly.
            ManagementInstaller managementInstaller = new ManagementInstaller();

            // Add installers to collection. Order is not important.
            Installers.Add(managementInstaller);
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\instrumentation\wmicapabilities.cs ===
namespace System.Management.Instrumentation
{
    using System;
    using System.IO;
    using Microsoft.Win32;

    internal class WMICapabilities
    {
        const string WMIKeyPath = @"Software\Microsoft\WBEM";
        const string WMINetKeyPath = @"Software\Microsoft\WBEM\.NET";
        const string WMICIMOMKeyPath = @"Software\Microsoft\WBEM\CIMOM";

        const string MultiIndicateSupportedValueNameVal = "MultiIndicateSupported";
        const string AutoRecoverMofsVal = "Autorecover MOFs";
        const string AutoRecoverMofsTimestampVal = "Autorecover MOFs timestamp";
        const string InstallationDirectoryVal = "Installation Directory";
        const string FrameworkSubDirectory = "Framework";

        /// <summary>
        /// Key to WMI.NET information
        /// </summary>
        static RegistryKey wmiNetKey = Registry.LocalMachine.OpenSubKey(WMINetKeyPath, false);

        static RegistryKey wmiCIMOMKey = Registry.LocalMachine.OpenSubKey(WMICIMOMKeyPath, true);

        static RegistryKey wmiKey = Registry.LocalMachine.OpenSubKey(WMIKeyPath, false);

        /// <summary>
        /// Indicates if IWbemObjectSink supports calls with multiple objects.
        /// On some versions of WMI, IWbemObjectSink will leak memory if
        /// Indicate is called with lObjectCount greater than 1.
        /// If the registry value,
        /// HKLM\Software\Microsoft\WBEM\.NET\MultiIndicateSupported
        /// exists and is non-zero, it is assumed that we can call Indicate
        /// with multiple objects.
        /// Allowed values
        /// -1 - We have not determined support for multi-indicate yet
        ///  0 - We do not support multi-indicate
        ///  1 - We support multi-indicate
        /// </summary>
        static int multiIndicateSupported = -1;
        static public bool MultiIndicateSupported
        {
            get
            {
                if(-1 == multiIndicateSupported)
                {
                    multiIndicateSupported = 0;

                    // See if there is a WMI.NET key
                    if(wmiNetKey != null)
                    {
                        // Try to get the 'MultiIndicateSupported' value
                        Object result = wmiNetKey.GetValue(MultiIndicateSupportedValueNameVal, 0);

                        // The value should be a DWORD (returned as an 'int'), and is 1 if supported
                        if(result.GetType() == typeof(int) && (int)result==1)
                            multiIndicateSupported = 1;
                    }
                }
                return multiIndicateSupported == 1;
            }
        }

        static public void AddAutorecoverMof(string path)
        {
            if(null != wmiCIMOMKey)
            {
                object mofsTemp = wmiCIMOMKey.GetValue(AutoRecoverMofsVal);
                string [] mofs = mofsTemp as string[];
                    if(null == mofs)
                    {
                        if(null != mofsTemp)
                        {
                            // Oh No!  We have a auto recover key, but it is not reg multistring
                            // We just give up
                            return;
                        }
                        mofs = new string[] {};
                    }

                // We ALWAYS update the autorecover timestamp
                wmiCIMOMKey.SetValue(AutoRecoverMofsTimestampVal, DateTime.Now.ToFileTime().ToString());

                // Look for path in existing autorecover key
                foreach(string mof in mofs)
                {
                    if(mof.ToLower() == path.ToLower())
                    {
                        // We already have this MOF
                        return;
                    }
                }

                // We have the array of strings.  Now, add a new one
                string [] newMofs = new string[mofs.Length+1];
                mofs.CopyTo(newMofs, 0);
                newMofs[newMofs.Length-1] = path;

                wmiCIMOMKey.SetValue(AutoRecoverMofsVal, newMofs);
                wmiCIMOMKey.SetValue(AutoRecoverMofsTimestampVal, DateTime.Now.ToFileTime().ToString());
            }
        }

        static string installationDirectory = null;
        public static string InstallationDirectory
        {
            get
            {
                if(null == installationDirectory && null != wmiKey)
                    installationDirectory = wmiKey.GetValue(InstallationDirectoryVal).ToString();
                return installationDirectory;
            }
        }

        public static string FrameworkDirectory
        {
            get
            {
                return Path.Combine(InstallationDirectory, FrameworkSubDirectory);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\instrumentation\schemamapping.cs ===
//------------------------------------------------------------------------------
// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
//    Copyright (c) Microsoft Corporation. All Rights Reserved.                
//    Information Contained Herein is Proprietary and Confidential.            
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Management.Instrumentation
{
    using System;
    using System.Reflection;
    using System.Management;

    class SchemaMapping
    {
        Type classType;
        ManagementClass newClass;
        string className;
        string classPath;

        public Type ClassType { get { return classType; } }
        public ManagementClass NewClass { get { return newClass; } }
        public string ClassName { get { return className; } }
        public string ClassPath { get { return classPath; } }

        InstrumentationType instrumentationType;
        public InstrumentationType InstrumentationType { get { return instrumentationType; } }

        public SchemaMapping(Type type, SchemaNaming naming)
        {
            classType = type;

            string baseClassName = ManagedNameAttribute.GetBaseClassName(type);
            className = ManagedNameAttribute.GetMemberName(type);
            instrumentationType = InstrumentationClassAttribute.GetAttribute(type).InstrumentationType;

            classPath = naming.NamespaceName + ":" + className;

            if(null == baseClassName)
            {
                newClass = new ManagementClass(naming.NamespaceName, "", null);
                newClass.SystemProperties ["__CLASS"].Value = className;
            }
            else
            {
                ManagementClass baseClass = new ManagementClass(naming.NamespaceName + ":" + baseClassName);
                newClass = baseClass.Derive(className);
            }

            PropertyDataCollection props = newClass.Properties;

            // type specific info
            switch(instrumentationType)
            {
                case InstrumentationType.Event:
                    break;
                case InstrumentationType.Instance:
                    props.Add("ProcessId", CimType.String, false);
                    props.Add("InstanceId", CimType.String, false);
                    props["ProcessId"].Qualifiers.Add("key", true);
                    props["InstanceId"].Qualifiers.Add("key", true);
                    newClass.Qualifiers.Add("dynamic", true, false, false, false, true);
                    newClass.Qualifiers.Add("provider", naming.DecoupledProviderInstanceName, false, false, false, true);
                    break;
                case InstrumentationType.Abstract:
                    newClass.Qualifiers.Add("abstract", true, false, false, false, true);
                    break;
                default:
                    break;
            }

            foreach(MemberInfo field in type.GetFields())
            {
                if(!(field is FieldInfo || field is PropertyInfo))
                    continue;

                if(field.DeclaringType != type)
                    continue;

                if(field.GetCustomAttributes(typeof(IgnoreMemberAttribute), false).Length > 0)
                    continue;

                String propName = ManagedNameAttribute.GetMemberName(field);


#if REQUIRES_EXPLICIT_DECLARATION_OF_INHERITED_PROPERTIES
                if(InheritedPropertyAttribute.GetAttribute(field) != null)
                    continue;
#else
                // See if this field already exists on the WMI class
                // In other words, is it inherited from a base class
                // TODO: Make this more efficient
                //  - If we have a null base class name, all property names
                //    should be new
                //  - We could get all base class property names into a
                //    hashtable, and look them up from there
                bool propertyExists = true;
                try
                {
                    PropertyData prop = newClass.Properties[propName];
                }
                catch(ManagementException e)
                {
                    if(e.ErrorCode != ManagementStatus.NotFound)
                        throw e;
                    else
                        propertyExists = false;
                }
                if(propertyExists)
                    continue;
#endif

#if SUPPORTS_ALTERNATE_WMI_PROPERTY_TYPE
                Type t2 = ManagedTypeAttribute.GetManagedType(field);
#else
                Type t2;
                if(field is FieldInfo)
                    t2 = (field as FieldInfo).FieldType;
                else
                    t2 = (field as PropertyInfo).PropertyType;
#endif

                CimType cimtype = CimType.String;

                if(t2 == typeof(SByte))
                    cimtype = CimType.SInt8;
                else if(t2 == typeof(Byte))
                    cimtype = CimType.UInt8;
                else if(t2 == typeof(Int16))
                    cimtype = CimType.SInt16;
                else if(t2 == typeof(UInt16))
                    cimtype = CimType.UInt16;
                else if(t2 == typeof(Int32))
                    cimtype = CimType.SInt32;
                else if(t2 == typeof(UInt32))
                    cimtype = CimType.UInt32;
                else if(t2 == typeof(Int64))
                    cimtype = CimType.SInt64;
                else if(t2 == typeof(UInt64))
                    cimtype = CimType.UInt64;
                else if(t2 == typeof(Single))
                    cimtype = CimType.Real32;
                else if(t2 == typeof(Double))
                    cimtype = CimType.Real64;
                else if(t2 == typeof(Boolean))
                    cimtype = CimType.Boolean;
                else if(t2 == typeof(String))
                    cimtype = CimType.String;
                else if(t2 == typeof(Char))
                    cimtype = CimType.Char16;
                else if(t2 == typeof(DateTime))
                    cimtype = CimType.DateTime;
                else if(t2 == typeof(TimeSpan))
                    cimtype = CimType.DateTime;
                else
                    throw new Exception(String.Format("Unsupported type for event member - {0}", t2.Name));
// HACK: The following line cause a strange System.InvalidProgramException when run through InstallUtil
//				throw new Exception("Unsupported type for event member - " + t2.Name);


//              TODO: if(t2 == typeof(Decimal))

#if SUPPORTS_WMI_DEFAULT_VAULES
                Object defaultValue = ManagedDefaultValueAttribute.GetManagedDefaultValue(field);

                // TODO: Is it safe to make this one line?
                if(null == defaultValue)
                    props.Add(propName, cimtype, false);
                else
                    props.Add(propName, defaultValue, cimtype);
#else
                props.Add(propName, cimtype, false);
#endif

                // Must at 'interval' SubType on TimeSpans
                if(t2 == typeof(TimeSpan))
                {
                    PropertyData prop = props[propName];
                    prop.Qualifiers.Add("SubType", "interval", false, true, true, true);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\test1.cs ===
// Cool source file
using System;
using System.WMI;
using System.IO;

class WmiPlusTest
{
  public static int Main()
  {

	System.Diagnostics.TraceSwitch MySwitch = new System.Diagnostics.TraceSwitch("MySwitch",null);
    MySwitch.Level=System.Diagnostics.TraceLevel.Verbose;

    Console.WriteLine("WMI COM+ Test Application");
   
	
	//Create a WmiPath object
	WmiPath Path = new WmiPath("root\\cimv2");
	Console.WriteLine("String in WmiPath object is : {0}", Path.PathString);

	//Make a connection to this path
	WmiCollection Session = WmiCollection.Connect(Path);
	
	//Get a class from this connection
	WmiObject ServiceClass = Session.Get(new WmiPath("Win32_LogicalDisk"));
	//WmiObject ServiceClass = Session.Get("Win32_LogicalDisk");
	//Display the class name (__CLASS property of the class)
	Console.WriteLine("The name of this class is : {0}", ServiceClass["__CLASS"]);

	//Enumerate instances 
	WmiCollection Instances = Session.Open(new WmiPath("Win32_LogicalDisk"));
	foreach (WmiObject obj in Instances)
		Console.WriteLine("The key of this instance is : {0}", obj["Name"]);
    
	//Query
	WmiCollection QueryRes = Session.Query(new WmiQuery("select * from Win32_Service"));
	foreach (WmiObject Service in QueryRes)
		Console.WriteLine("{0}", Service["Name"]);

	return 0;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\test.cs ===
// Cool source file
using System;
using System.WMI;
using System.IO;
//using Microsoft.Win32.Interop;

class WmiPlusTest
{
  public static int Main(String[] args)
  {

	TextWriter oldTW = null; //used to save old console.out for logging
	StreamWriter sw = null;  //used to redirect console.out to file for logging
    Console.WriteLine("WMI Plus Test Application");
   
	//validate arguments
	if ( ((args.Length != 0) && (args.Length != 2)) || ((args.Length == 2) && (args[0] != "/log")) ) 
    {
        Console.WriteLine("Usage: ... "); 
        return 0; 
    }
	
	//if "/log" specified, redirect Console.Out to log file
	if (args.Length > 0)
	{
		FileStream fs = new FileStream(args[1], FileMode.OpenOrCreate, FileAccess.ReadWrite); //open log file
		oldTW = Console.Out; //save default standard output
		sw = new StreamWriter(fs);
		Console.SetOut(sw); //replace with file
	}
	

	//Create a WmiPath object
	WmiPath Path = new WmiPath("root\\default");
	Console.WriteLine("String in WmiPath object is : {0}", Path.PathString);

	//Make a connection to this path
	WmiCollection Session = WmiCollection.Connect(Path);
//	WmiCollection Session = WmiCollection.Connect("root\\cimv2");
	
	//Get a class from this connection
	WmiObject ServiceClass = Session.Get(new WmiPath("MyStaticClass"));
	//Display the class name (__CLASS property of the class)
	Console.WriteLine("The name of this class is : {0}", ServiceClass["__CLASS"]);

	//Enumerate instances (static only because of security problem !!)
	WmiCollection Instances = Session.Open(new WmiPath("MyStaticClass"));
	foreach (WmiObject obj in Instances)
		Console.WriteLine("The key of this instance is : {0}", obj["MyProp"]);
    
	
//		WmiCollection Services = Session.Open("Win32_Service");		
//		foreach (WmiObject Service in Services)
//			Console.WriteLine("{0}", Service["Name"]);
//r	}
//r	catch (Exception e)
//r	{
//r		Console.WriteLine("Exception caught : {0}", e.Message);
//r	}
		

	//flush log file, and restore standard output if changed
	if (sw != null)
		sw.Flush();
	if (oldTW != null)
		Console.SetOut(oldTW);

	return 0;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\instrumentation\instrumentation.cs ===
namespace System.Management.Instrumentation
{
    using System;
    using System.Collections;
    using System.Reflection;
    using System.Threading;
    using System.Runtime.InteropServices;
    using Microsoft.CSharp;
    using System.CodeDom.Compiler;
    using System.Management;

    using WbemClient_v1;

	internal delegate void ProvisionFunction(Object o);

    /// <summary>
    ///    The Instrumentation class provides the managed code portions of the
    ///    generic WMI Event/Instance Provider.  There is a single instance of
    ///    this class per AppDomain.
    /// </summary>
    public class Instrumentation
    {

        static string processIdentity = null;
        static internal string ProcessIdentity
        {
            get
            {
                if(null == processIdentity)
                    processIdentity = Guid.NewGuid().ToString().ToLower();
                return processIdentity;
            }
        }

        #region Public Members of Instrumentation class
        
        /// <summary>
        /// This method fires a Management Event
        /// </summary>
        /// <param name="o">Object that determines the class, properties, and values of the event</param>
        public static void Fire(Object o)
        {
            GetFireFunction(o.GetType())(o);
        }

        /// <summary>
        /// This method makes an instance visible through management instrumentation.
        /// </summary>
        /// <param name="o">Instance that is to be visible through management instrumentation</param>
        public static void Publish(Object o)
        {
            GetPublishFunction(o.GetType())(o);
        }

        /// <summary>
        /// This method makes an instance that was previously published through the Instrumentation.Publish
        /// method no longer visible through management instrumenation
        /// </summary>
        /// <param name="o">Object to remove from visibility for management instrumentation.</param>
        public static void Revoke(Object o)
        {
            GetRevokeFunction(o.GetType())(o);
        }

        public static void SetBatchSize(Type t, int batchSize)
        {
            GetInstrumentedAssembly(t.Assembly).SetBatchSize(t, batchSize);
        }

        #endregion

        #region Non-Public Members of Instrumentation class

        internal static ProvisionFunction GetFireFunction(Type type)
        {
            return new ProvisionFunction(GetInstrumentedAssembly(type.Assembly).Fire);
        }

        internal static ProvisionFunction GetPublishFunction(Type type)
        {
            return new ProvisionFunction(GetInstrumentedAssembly(type.Assembly).Publish);
        }

        internal static ProvisionFunction GetRevokeFunction(Type type)
        {
            return new ProvisionFunction(GetInstrumentedAssembly(type.Assembly).Revoke);
        }

        private static Hashtable instrumentedAssemblies = new Hashtable();

        private static void Initialize(Assembly assembly)
        {
            if(instrumentedAssemblies.ContainsKey(assembly))
                return;

            SchemaNaming naming = SchemaNaming.GetSchemaNaming(assembly);
            if(naming == null)
                return;

            if(false == naming.IsAssemblyRegistered())
                throw new Exception("This assembly has not been registered with WMI");

            InstrumentedAssembly instrumentedAssembly = new InstrumentedAssembly(assembly, naming);
            instrumentedAssemblies.Add(assembly, instrumentedAssembly);
        }

		private static InstrumentedAssembly GetInstrumentedAssembly(Assembly assembly)
		{
			if(false == instrumentedAssemblies.ContainsKey(assembly))
				Initialize(assembly);
			return (InstrumentedAssembly)instrumentedAssemblies[assembly];
		}

#if SUPPORTS_WMI_DEFAULT_VAULES
        internal static ProvisionFunction GetInitializeInstanceFunction(Type type)
		{
			return new ProvisionFunction(InitializeInstance);
		}

		private static void InitializeInstance(Object o)
		{
			Type type = o.GetType();
			string className = ManagedNameAttribute.GetClassName(type);
			SchemaNaming naming = InstrumentedAttribute.GetSchemaNaming(type.Assembly);
			ManagementClass theClass = new ManagementClass(naming.NamespaceName + ":" + className);
			foreach(FieldInfo field in type.GetFields())
			{
				Object val = theClass.Properties[ManagedNameAttribute.GetFieldName(field)].Value;
				if(null != val)
				{
					field.SetValue(o, val);
				}
			}
		}
#endif
        #endregion
    }
    delegate int WriteDWORD(int handle, uint dw);
    delegate int WriteQWORD(int handle, UInt64 dw);

    delegate void ConvertFuncToWMI(object o1, IntPtr/*object*/ o2);
    delegate void ConvertFuncToNET(object o1, object o2);

    class InstrumentedAssembly
    {
        SchemaNaming naming;

		public EventSource source;
		private void InitEventSource()
		{
            source = new EventSource(naming.NamespaceName, naming.DecoupledProviderInstanceName);
        }

        public static Hashtable mapTypeToToWMIFunc = new Hashtable();
        public static Hashtable mapTypeToToNETFunc = new Hashtable(); //TODO LOCK THIS

        public InstrumentedAssembly(Assembly assembly, SchemaNaming naming)
        {
            this.naming = naming;

            CSharpCodeProvider provider = new CSharpCodeProvider();
            ICodeCompiler compiler = provider.CreateCompiler();
            CompilerParameters parameters = new CompilerParameters();
            parameters.GenerateInMemory = true;
            parameters.ReferencedAssemblies.Add(assembly.Location);
            parameters.ReferencedAssemblies.Add(typeof(BaseEvent).Assembly.Location);
            parameters.ReferencedAssemblies.Add(typeof(System.ComponentModel.Component).Assembly.Location);
            CompilerResults results = compiler.CompileAssemblyFromSource(parameters, naming.Code);
            foreach(CompilerError err in results.Errors)
            {
                Console.WriteLine(err.ToString());
            }
            Type dynType = results.CompiledAssembly.GetType("WMINET_Converter");

            Type[] types = (Type[])dynType.GetField("netTypes").GetValue(null);
            MethodInfo[] toWMIs = (MethodInfo[])dynType.GetField("toWMIMethods").GetValue(null);
            MethodInfo[] toNETs = (MethodInfo[])dynType.GetField("toNETMethods").GetValue(null);
            Object theOne = dynType.GetField("theOne").GetValue(null);
            for(int i=0;i<types.Length;i++)
            {
                ConvertFuncToWMI toWMI = (ConvertFuncToWMI)Delegate.CreateDelegate(typeof(ConvertFuncToWMI), theOne, toWMIs[i].Name);
                ConvertFuncToNET toNET = (ConvertFuncToNET)Delegate.CreateDelegate(typeof(ConvertFuncToNET), theOne, toNETs[i].Name);
                mapTypeToToWMIFunc.Add(types[i], toWMI);
                mapTypeToToNETFunc.Add(types[i], toNET);
            }

			// TODO: Is STA/MTA all we have to worry about?
			if(Thread.CurrentThread.ApartmentState == ApartmentState.STA)
			{
				// We are on an STA thread.  Create the event source on an MTA
				Thread thread = new Thread(new ThreadStart(InitEventSource));
                thread.ApartmentState = ApartmentState.MTA;
				thread.Start();
				thread.Join();
			}
			else
			{
				InitEventSource();
			}
        }

		public void Fire(Object o)
		{
			Fire(o.GetType(), o);
		}



        public static Hashtable mapIDToRef = new Hashtable();
        public void Publish(Object o)
        {
            GCHandle h = GCHandle.Alloc(o, GCHandleType.Weak);
            mapIDToRef.Add(h.GetHashCode(), h);
        }

        public void Revoke(Object o)
        {
            GCHandle h = GCHandle.Alloc(o, GCHandleType.Weak);
            if(mapIDToRef.ContainsKey(h.GetHashCode()))
                mapIDToRef.Remove(h.GetHashCode());
        }

//        delegate void ManagedToIWbem(object o, WriteDWORD writeDWORD, WriteQWORD writeQWORD);

        class TypeInfo
        {
            public void xWriteDWORD(int handle, uint dw) {}
            public void xWriteQWORD(int handle, UInt64 dw) {}

            public bool isSTA = false;

            // Make ThreadLocal
            public IWbemClassObject_DoNotMarshal obj;
            int batchSize = 20;
            bool batchEvents = true;
            public IWbemObjectAccess[] xoa;// = new IWbemObjectAccess[batchMaxSize];
            ClassObjectArray oatest;
            public WriteDWORD[] writeDWORD;// = new WriteDWORD[batchMaxSize];
            public WriteQWORD[] writeQWORD;// = new WriteQWORD[batchMaxSize];

            public IWbemObjectAccess[] xoa1 = new IWbemObjectAccess[1];
            ClassObjectArray oa1test;
            public WriteDWORD writeDWORD1;
            public WriteQWORD writeQWORD1;

            public int currentIndex = 0;

            public object o;
//            public ManagedToIWbem managedToIWbem;
            public ConvertFuncToWMI toWMI;
            public ConvertFuncToNET toNET;

            public EventSource source;

            class ClassObjectArray
            {
                public IntPtr[] realInterfaces;
                public IntPtr realPointer = IntPtr.Zero;
                int length = 0;
                public ClassObjectArray(IWbemObjectAccess[] objects)
                {
                    length = objects.Length;
                    realPointer = Marshal.AllocHGlobal(length*IntPtr.Size);
                    realInterfaces = new IntPtr[length];
                    for(int i=0;i<length;i++)
                    {
                        IntPtr interfaceIUnknown = Marshal.GetIUnknownForObject(objects[i]);
                        IntPtr interfaceIWbemClassObject;
                        Marshal.QueryInterface(interfaceIUnknown, ref IWbemClassObjectFreeThreaded.IID_IWbemClassObject , out interfaceIWbemClassObject);

                        Marshal.WriteIntPtr(realPointer, i*IntPtr.Size, interfaceIWbemClassObject);

                        realInterfaces[i] = interfaceIWbemClassObject;

                        Marshal.Release(interfaceIUnknown);
                    }

                }
                ~ClassObjectArray()
                {
                    if(length > 0)
                    {
                        for(int i=0;i<length;i++)
                        {
                            IntPtr interfacePointer = Marshal.ReadIntPtr(realPointer, i*IntPtr.Size);
                            Marshal.Release(interfacePointer);
                        }
                        Marshal.FreeHGlobal(realPointer);
                    }
                }
            }

            public void Fire()
            {
                if(source.Any())
                    return;
                if(!batchEvents)
                {
//                    managedToIWbem(o, writeDWORD1, writeQWORD1);
                    toWMI(o, /*xoa1[0]*/oa1test.realInterfaces[0]);
                    source.pSink.Indicate_(1, oa1test.realPointer);
//                    int j = Indicate(3, source.ipSink, 1, oa1test.realPointer);
                }
                else
                {
                    lock(this)
                    {
//                        managedToIWbem(o, writeDWORD[currentIndex], writeQWORD[currentIndex++]);
                        toWMI(o, /*xoa[currentIndex++]*/ oatest.realInterfaces[currentIndex++]);
                        if(cleanupThread == null)
                        {
                            int tickCount = Environment.TickCount;
                            if(tickCount-lastFire<1000)
                            {
                                cleanupThread = new Thread(new ThreadStart(Cleanup));
                                cleanupThread.ApartmentState = ApartmentState.MTA;
                                cleanupThread.Start();
                            }
                            else
                            {
                                source.pSink.Indicate_(currentIndex, oatest.realPointer);
//                                Indicate(3, source.ipSink, currentIndex, oatest.realPointer);
                                currentIndex = 0;
                                lastFire = tickCount;
                            }
                        }
                        else if(currentIndex==batchSize)
                        {
                            source.pSink.Indicate_(currentIndex, oatest.realPointer);
//                            Indicate(3, source.ipSink, currentIndex, oatest.realPointer);
                            currentIndex = 0;
                            lastFire = Environment.TickCount;
                        }
                    }
                }
            }

            public int lastFire = 0;

            public void SetBatchSize(int batchSize)
            {
                if(!WMICapabilities.MultiIndicateSupported)
                    batchSize = 1;
                lock(this)
                {
                    if(currentIndex > 0)
                    {
                        source.pSink.Indicate_(currentIndex, oatest.realPointer);
//                        Indicate(3, source.ipSink, currentIndex, oatest.realPointer);
                        currentIndex = 0;
                        lastFire = Environment.TickCount;
                    }
                    if(batchSize > 1)
                    {
                        batchEvents = true;
                        this.batchSize = batchSize;

                        xoa = new IWbemObjectAccess[batchSize];

                        writeDWORD = new WriteDWORD[batchSize];
                        writeQWORD = new WriteQWORD[batchSize];
                        IWbemClassObject_DoNotMarshal obj2;
                        for(int i=0;i<batchSize;i++)
                        {
                            obj.Clone_(out obj2);
                            xoa[i] = (IWbemObjectAccess)obj2;
                            writeDWORD[i] = new WriteDWORD(xoa[i].WriteDWORD_);
                            writeQWORD[i] = new WriteQWORD(xoa[i].WriteQWORD_);
                        }
                        oatest = new ClassObjectArray(xoa);
                    }
                    else
                        batchEvents = false;
                }
            }

            public void Cleanup()
            {
//                Console.WriteLine("CLEANUP " + t.Name);
                int idleCount = 0;
                while(idleCount<20)
                {
                    Thread.Sleep(100);
                    if(0==currentIndex)
                    {
                        idleCount++;
                        continue;
                    }
                    idleCount = 0;
                    if((Environment.TickCount - lastFire)<100)
                        continue;
                    lock(this)
                    {
                        if(currentIndex>0)
                        {
                            source.pSink.Indicate_(currentIndex, oatest.realPointer);
//                            Indicate(3, source.ipSink, currentIndex, oatest.realPointer);
                            currentIndex = 0;
                            lastFire = Environment.TickCount;
                        }
                    }
                }
                cleanupThread = null;
//                Console.WriteLine("CLEANUP END " + t.Name);
            }
            public Thread cleanupThread = null;

            public Type t;
            public TypeInfo(EventSource source, SchemaNaming naming, Type t)
            {
                this.toWMI = (ConvertFuncToWMI)InstrumentedAssembly.mapTypeToToWMIFunc[t];
                this.toNET = (ConvertFuncToNET)InstrumentedAssembly.mapTypeToToNETFunc[t];
                this.t = t;
                isSTA = Thread.CurrentThread.ApartmentState == ApartmentState.STA;
                ManagementClass eventClass = new ManagementClass(naming.NamespaceName+":"+ManagedNameAttribute.GetMemberName(t));
                PropertyInfo prop = typeof(ManagementBaseObject).GetProperty("WmiObject", BindingFlags.Instance | BindingFlags.NonPublic);

                ManagementObject evt = eventClass.CreateInstance();
                obj = (IWbemClassObject_DoNotMarshal)prop.GetValue(evt, null);
                this.source = source;


                SetBatchSize(batchSize);

                IWbemClassObject_DoNotMarshal obj2;
                obj.Clone_(out obj2);
                xoa1[0] = (IWbemObjectAccess)obj2;
                oa1test = new ClassObjectArray(xoa1);

                writeDWORD1 = new WriteDWORD(xoa1[0].WriteDWORD_);
                writeQWORD1 = new WriteQWORD(xoa1[0].WriteQWORD_);

#if xxx
                string code = CodeSpit.Spit(t, xoa1[0]);
                CSharpCodeProvider provider = new CSharpCodeProvider();
                ICodeCompiler compiler = provider.CreateCompiler();
                CompilerParameters parameters = new CompilerParameters();
                parameters.GenerateInMemory = true;

                parameters.ReferencedAssemblies.Add(t.Assembly.Location);
                parameters.ReferencedAssemblies.Add(typeof(WriteDWORD).Assembly.Location);
                parameters.ReferencedAssemblies.Add(typeof(Event).Assembly.Location);
                CompilerResults results = compiler.CompileAssemblyFromSource(parameters, code);
                foreach(CompilerError err in results.Errors)
                {
                    Console.WriteLine(err.ToString());
                }
                Type dynType = results.CompiledAssembly.GetType("Hack");

                MethodInfo doit = dynType.GetMethod("Func");

                managedToIWbem = (ManagedToIWbem)Delegate.CreateDelegate(typeof(ManagedToIWbem), doit);
#endif
            }
        }

        [ThreadStatic] Hashtable mapTypeToTypeInfo = new Hashtable();

        public void SetBatchSize(Type t, int batchSize)
        {
            GetTypeInfo(t).SetBatchSize(batchSize);
        }

        TypeInfo lastTypeInfo = null;
        Type lastType = null;
        TypeInfo GetTypeInfo(Type t)
        {
            if(lastType==t)
                return lastTypeInfo;

            lastType = t;
            TypeInfo typeInfo = (TypeInfo)mapTypeToTypeInfo[t];
            if(null==typeInfo)
            {
                typeInfo = new TypeInfo(source, naming, t);
                mapTypeToTypeInfo.Add(t, typeInfo);
            }
            lastTypeInfo = typeInfo;
            return typeInfo;
        }

        public void Fire(Type t, Object o)
        {

            TypeInfo typeInfo = GetTypeInfo(t);
			typeInfo.o = o;
			if(typeInfo.isSTA)
			{
				// We are on an STA thread.  Create the event source on an MTA
				Thread thread = new Thread(new ThreadStart(typeInfo.Fire));
                thread.ApartmentState = ApartmentState.MTA;
                thread.Start();
				thread.Join();
			}
			else
            {
				typeInfo.Fire();
			}
		}
	}


    /// <summary>
    /// Objects that implement the IEvent interface are know to be sources
    /// of Management Instrumentation events.  Classes that do not derive
    /// from System.Management.Instrumentation.Event should implement
    /// this interface instead
    /// </summary>
    public interface IEvent
    {
        /// <summary>
        /// The implementation of this method performs that action of firing
        /// the management instrumentation event.
        /// </summary>
        void Fire();
    }

    /// <summary>
    /// Classes that derive from Event are known to be management instrumentation
    /// event classes.  These derived classes will inherit an implementation of
    /// IEvent that will allow events to be fired through the IEvent.Fire() method.
    /// </summary>
    public abstract class BaseEvent : IEvent
	{
		private ProvisionFunction fireFunction = null;
		private ProvisionFunction FireFunction
		{
			get
			{
				if(null == fireFunction)
				{
					fireFunction = Instrumentation.GetFireFunction(this.GetType());
				}
				return fireFunction;
			}
		}

		/// <summary>
		/// The implementation of this method causes the event to fire.
		/// </summary>
        public void Fire()
		{
			FireFunction(this);
		}
	}

    /// <summary>
    /// Objects that implement the IInstance interface are know to be sources
    /// of Management Instrumentation instances.  Classes that do not derive
    /// from System.Management.Instrumentation.Instance should implement
    /// this interface instead.
    /// </summary>
    public interface IInstance
    {
        /// <summary>
        /// The implementation of this property determines when instances
        /// of classes that implement IInstance are visible through
        /// Management Instrumentation.
        /// When Published is set to true, the instance is visible through
        /// Management Instrumentation
        /// </summary>
        bool Published
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Classes that derive from Instance are known to be management instrumentation
    /// instance classes.  These derived classes will inherit an implementation of
    /// IInstance that will allow instances to be published through the IInstance.Publish
    /// property
    /// </summary>
    public abstract class Instance : IInstance
    {
        private ProvisionFunction publishFunction = null;
        private ProvisionFunction revokeFunction = null;
        private ProvisionFunction PublishFunction
        {
            get
            {
                if(null == publishFunction)
                {
                    publishFunction = Instrumentation.GetPublishFunction(this.GetType());
                }
                return publishFunction;
            }
        }
        private ProvisionFunction RevokeFunction
        {
            get
            {
                if(null == revokeFunction)
                {
                    revokeFunction = Instrumentation.GetRevokeFunction(this.GetType());
                }
                return revokeFunction;
            }
        }
        private bool published = false;

        /// <summary>
        /// The implementation of this property determines when instances
        /// of classes that derive from  Instance are visible through
        /// Management Instrumentation.
        /// When Published is set to true, the instance is visible through
        /// Management Instrumentation
        /// </summary>
        public bool Published
        {
            get
            {
                return published;
            }
            set
            {
                if(published && false==value)
                {
                    // We ARE published, and the caller is setting published to FALSE
                    RevokeFunction(this);
                    published = false;
                }
                else if(!published && true==value)
                {
                    // We ARE NOT published, and the caller is setting published to TRUE
                    PublishFunction(this);
                    published = true;
                }
            }
        }
    }
}

#if JEFF_WARNING_REMOVAL_TEST 
namespace System.Management
{
    class DoNothing
    {
        static void SayNothing()
        {
            tag_SWbemRpnConst w;
            w.unionhack = 0;

            tag_CompileStatusInfo x;
            x.lPhaseError = 0;
            x.hRes = 0;
            x.ObjectNum = 0;
            x.FirstLine = 0;
            x.LastLine = 0;
            x.dwOutFlags = 0;

            tag_SWbemQueryQualifiedName y;
            y.m_uVersion = 0;
            y.m_uTokenType = 0;
            y.m_uNameListSize = 0;
            y.m_ppszNameList = IntPtr.Zero;
            y.m_bArraysUsed = 0;
            y.m_pbArrayElUsed = IntPtr.Zero;
            y.m_puArrayIndex = IntPtr.Zero;

            tag_SWbemRpnQueryToken z;
            z.m_uVersion = 0;
            z.m_uTokenType = 0;
            z.m_uSubexpressionShape = 0;
            z.m_uOperator = 0;
            z.m_pRightIdent = IntPtr.Zero;
            z.m_pLeftIdent = IntPtr.Zero;
            z.m_uConstApparentType = 0;
            z.m_Const = w;
            z.m_uConst2ApparentType = 0;
            z.m_Const2 = w;
            z.m_pszRightFunc = "";
            z.m_pszLeftFunc = "";

            tag_SWbemRpnTokenList a;
            a.m_uVersion = 0;
            a.m_uTokenType = 0;
            a.m_uNumTokens = 0;

            tag_SWbemRpnEncodedQuery b;
            b.m_uVersion = 0;
            b.m_uTokenType = 0;
            b.m_uParsedFeatureMask1 = 0;
            b.m_uParsedFeatureMask2 = 0;
            b.m_uDetectedArraySize = 0;
            b.m_puDetectedFeatures = IntPtr.Zero;
            b.m_uSelectListSize = 0;
            b.m_ppSelectList = IntPtr.Zero;
            b.m_uFromTargetType = 0;
            b.m_pszOptionalFromPath = "";
            b.m_uFromListSize = 0;
            b.m_ppszFromList = IntPtr.Zero;
            b.m_uWhereClauseSize = 0;
            b.m_ppRpnWhereClause = IntPtr.Zero;
            b.m_dblWithinPolling = 0;
            b.m_dblWithinWindow = 0;
            b.m_uOrderByListSize = 0;
            b.m_ppszOrderByList = IntPtr.Zero;
            b.m_uOrderDirectionEl = IntPtr.Zero;

            tag_SWbemAnalysisMatrix c;
            c.m_uVersion = 0;
            c.m_uMatrixType = 0;
            c.m_pszProperty = "";
            c.m_uPropertyType = 0;
            c.m_uEntries = 0;
            c.m_pValues = IntPtr.Zero;
            c.m_pbTruthTable = IntPtr.Zero;

            tag_SWbemAnalysisMatrixList d;
            d.m_uVersion = 0;
            d.m_uMatrixType = 0;
            d.m_uNumMatrices = 0;
            d.m_pMatrices = IntPtr.Zero;

            tag_SWbemAssocQueryInf e;
            e.m_uVersion = 0;
            e.m_uAnalysisType = 0;
            e.m_uFeatureMask = 0;
            e.m_pPath = null;
            e.m_pszPath = "";
            e.m_pszQueryText = "";
            e.m_pszResultClass = "";
            e.m_pszAssocClass = "";
            e.m_pszRole = "";
            e.m_pszResultRole = "";
            e.m_pszRequiredQualifier = "";
            e.m_pszRequiredAssocQualifier = "";
        }
    }
}
#endif

#if xxxx

    public static void SetField(Object inst, ISWbemProperty prop, FieldInfo field)
    {
        Object o = prop.get_Value();
        IConvertible i = (IConvertible)o;

        Type t2 = field.FieldType;

        if(t2 == typeof(SByte))
            o = i.ToSByte(null);
        else if(t2 == typeof(Byte))
            o = i.ToByte(null);
        else if(t2 == typeof(Int16))
            o = i.ToInt16(null);
        else if(t2 == typeof(UInt16))
            o = i.ToUInt16(null);
        else if(t2 == typeof(Int32))
            o = i.ToInt32(null);
        else if(t2 == typeof(UInt32))
            o = i.ToUInt32(null);
        else if(t2 == typeof(Int64))
            o = i.ToInt64(null);
        else if(t2 == typeof(UInt64))
            o = i.ToUInt64(null);
        else if(t2 == typeof(Single))
            o = i.ToSingle(null);
        else if(t2 == typeof(Double))
            o = i.ToDouble(null);
        else if(t2 == typeof(Boolean))
            o = i.ToBoolean(null);
        else if(t2 == typeof(String))
            o = i.ToString(null);
        else if(t2 == typeof(Char))
            o = i.ToChar(null);
        else if(t2 == typeof(DateTime))
//            o = i.ToDateTime(null);

        {/*Console.WriteLine(" NO CONVERSION TO DATETIME: "+o+" - "+o.GetType().Name);*/return;}
        else if(t2 == typeof(TimeSpan))
//            o = //i.To;
        {/*Console.WriteLine(" NO CONVERSION TO TIMESPAN: "+o+" - "+o.GetType().Name);*/return;}
        else if(t2 == typeof(Object))
            /*Nothing to do*/o = o;
        else
            throw new Exception("Unsupported type for default property - " + t2.Name);

        field.SetValue(inst, o);
    }

    public static void SetProp(Object o, ISWbemProperty prop)
    {
        try
        {
            // TODO: FIX UP THIS MESS!!!!
            if(o == null)
                /*NOTHING TO DO*/o = o;
            else if(o.GetType() == typeof(DateTime))
            {
                DateTime dt = (DateTime)o;
                TimeSpan ts = dt.Subtract(dt.ToUniversalTime());
                int diffUTC = (ts.Minutes + ts.Hours * 60);
                if(diffUTC >= 0)
                    o = String.Format("{0:D4}{1:D2}{2:D2}{3:D2}{4:D2}{5:D2}.{6:D3}000+{7:D3}", new Object [] {dt.Year, dt.Month, dt.Day, dt.Hour, dt.Minute, dt.Second, dt.Millisecond, diffUTC});
                else
                    o = String.Format("{0:D4}{1:D2}{2:D2}{3:D2}{4:D2}{5:D2}.{6:D3}000-{7:D3}", new Object [] {dt.Year, dt.Month, dt.Day, dt.Hour, dt.Minute, dt.Second, dt.Millisecond, -diffUTC});
            }
            else if(o.GetType() == typeof(TimeSpan))
            {
                TimeSpan ts = (TimeSpan)o;
                o = String.Format("{0:D8}{1:D2}{2:D2}{3:D2}.{4:D3}000:000", new Object [] {ts.Days, ts.Hours, ts.Minutes, ts.Seconds, ts.Milliseconds});
            }
            else if(o.GetType() == typeof(char))
            {
                if(0 == (char)o)
                    o = (int)0;
                else
                  o=o.ToString();
            }

            prop.set_Value(ref o);
        }
        catch
        {
//            Console.WriteLine(prop.Name + " - "+o.GetType().Name + " - " + (o == null));
            o = o.ToString();
            prop.set_Value(ref o);
        }
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\asp+\processes\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\asynctest1\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\assocclass\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\classcreate\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\classenum\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\asp+\processes\webform1.cs ===
namespace Processes
{
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Management;

/// <summary>
///    Summary description for WebForm1.
/// </summary>
public class WebForm1 : System.Web.UI.Page
{
	public ListBox ListBox1;
	private ManagementObjectSearcher searcher;
		
    protected void Page_Load(object sender, EventArgs e)
    {
        if (!IsPostBack)
        {
            //
            // Evals true first time browser hits the page
            //
			searcher = new ManagementObjectSearcher (new InstanceEnumerationQuery("Win32_Process"));
        }

		ListItemCollection items = ListBox1.Items;

		foreach (ManagementObject process in searcher.Get()) {
			items.Add ((string)process["Name"]);
		}
    }

    protected override void Init()
    {
        //
        // CODEGEN: This call is required by the ASP+ WFC Form Designer.
        //
        InitializeComponent();
    }

    /// <summary>
    ///    Required method for Designer support - do not modify
    ///    the contents of this method with the code editor
    /// </summary>
    private void InitializeComponent()
	{
		
		
		
		
		
	}
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\assocclass\class1.cs ===
namespace assocClass
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		ManagementClass c = new ManagementClass ("CIM_Setting");

		foreach (ManagementClass cc in c.GetRelatedClasses ())
		{
			Console.WriteLine (cc.ClassPath);
		}

        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\src\instrumentation\schemaregistration.cs ===
//------------------------------------------------------------------------------
// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
//    Copyright (c) Microsoft Corporation. All Rights Reserved.                
//    Information Contained Herein is Proprietary and Confidential.            
// </copyright>                                                                
//------------------------------------------------------------------------------

// TODO: Better logging to context of InstallUtil
namespace System.Management.Instrumentation
{
    using System;
    using System.Reflection;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Configuration.Install;
    using System.Management;
    using Microsoft.Win32;
    using System.IO;
    using System.Text;

    class SchemaNaming
    {
        public static SchemaNaming GetSchemaNaming(Assembly assembly)
        {
            InstrumentedAttribute attr = InstrumentedAttribute.GetAttribute(assembly);

            // See if this assembly provides instrumentation
            if(null == attr)
                return null;

            return new SchemaNaming(attr.NamespaceName, attr.SecurityDescriptor, assembly);
        }

        Assembly assembly;
        SchemaNaming(string namespaceName, string securityDescriptor, Assembly assembly)
        {
            this.assembly = assembly;
            assemblyInfo = new AssemblySpecificNaming(namespaceName, securityDescriptor, assembly);
        }

        ///////////////////////////////////////////
        // string constants
        const string Win32ProviderClassName = "__Win32Provider";
        const string EventProviderRegistrationClassName = "__EventProviderRegistration";
        const string InstanceProviderRegistrationClassName = "__InstanceProviderRegistration";
        const string DecoupledProviderClassName = "MSFT_DecoupledProvider";
        const string ProviderClassName = "WMINET_ManagedAssemblyProvider";
        const string InstrumentationClassName = "WMINET_Instrumentation";
        const string InstrumentedAssembliesClassName = "WMINET_InstrumentedAssemblies5";
        const string DecoupledProviderCLSID = "{54D8502C-527D-43f7-A506-A9DA075E229C}";
        const string GlobalWmiNetNamespace = @"root\MicrosoftWmiNet";
        const string InstrumentedNamespacesClassName = "WMINET_InstrumentedNamespaces";
        const string NamingClassName = "WMINET_Naming";


        ///////////////////////////////////////////
        // class that holds read only naming info
        // specific to an assembly
        private class AssemblySpecificNaming
        {
            public AssemblySpecificNaming(string namespaceName, string securityDescriptor, Assembly assembly)
            {
                this.namespaceName = namespaceName;
                this.securityDescriptor = securityDescriptor;
                this.decoupledProviderInstanceName = AssemblyNameUtility.UniqueToAssemblyMinorVersion(assembly);
                this.assemblyUniqueIdentifier = AssemblyNameUtility.UniqueToAssemblyBuild(assembly);
                this.assemblyName = assembly.GetName().FullName;
                this.assemblyPath = assembly.Location;
            }

            string namespaceName;
            string securityDescriptor;
            string decoupledProviderInstanceName;
            string assemblyUniqueIdentifier;
            string assemblyName;
            string assemblyPath;

            public string NamespaceName {get {return namespaceName;} }
            public string SecurityDescriptor {get {return securityDescriptor;} }
            public string DecoupledProviderInstanceName {get {return decoupledProviderInstanceName;} }
            public string AssemblyUniqueIdentifier {get {return assemblyUniqueIdentifier;} }
            public string AssemblyName {get {return assemblyName;} }
            public string AssemblyPath {get {return assemblyPath;} }
        }

        ///////////////////////////////////////////
        // Accessors for name information
        // After these methods, there should be no
        // use of the lower case names
        AssemblySpecificNaming assemblyInfo;

        public string NamespaceName {get {return assemblyInfo.NamespaceName;} }
        public string SecurityDescriptor {get {return assemblyInfo.SecurityDescriptor;} }
        public string DecoupledProviderInstanceName {get {return assemblyInfo.DecoupledProviderInstanceName;} }
        string AssemblyUniqueIdentifier {get {return assemblyInfo.AssemblyUniqueIdentifier;} }
        string AssemblyName {get {return assemblyInfo.AssemblyName;} }
        string AssemblyPath {get {return assemblyInfo.AssemblyPath;} }

        string Win32ProviderClassPath {get {return MakeClassPath(assemblyInfo.NamespaceName, Win32ProviderClassName);} }
        string DecoupledProviderClassPath {get {return MakeClassPath(assemblyInfo.NamespaceName, DecoupledProviderClassName);} }
        string InstrumentationClassPath {get {return MakeClassPath(assemblyInfo.NamespaceName, InstrumentationClassName);} }
        string EventProviderRegistrationClassPath {get {return MakeClassPath(assemblyInfo.NamespaceName, EventProviderRegistrationClassName);} }
        string EventProviderRegistrationPath {get {return AppendProperty(EventProviderRegistrationClassPath, "provider", @"\\\\.\\"+ProviderPath.Replace(@"\", @"\\").Replace(@"""", @"\"""));} }
        string InstanceProviderRegistrationClassPath {get {return MakeClassPath(assemblyInfo.NamespaceName, InstanceProviderRegistrationClassName);} }
        string InstanceProviderRegistrationPath {get {return AppendProperty(InstanceProviderRegistrationClassPath, "provider", @"\\\\.\\"+ProviderPath.Replace(@"\", @"\\").Replace(@"""", @"\"""));} }

        string ProviderClassPath {get {return MakeClassPath(assemblyInfo.NamespaceName, ProviderClassName);} }
        string ProviderPath {get {return AppendProperty(ProviderClassPath, "Name", assemblyInfo.DecoupledProviderInstanceName);} }
        string RegistrationClassPath {get {return MakeClassPath(assemblyInfo.NamespaceName, InstrumentedAssembliesClassName);} }
        string RegistrationPath {get {return AppendProperty(RegistrationClassPath, "Name", assemblyInfo.DecoupledProviderInstanceName);} }

        string GlobalRegistrationNamespace {get {return GlobalWmiNetNamespace;} }
        string GlobalInstrumentationClassPath {get {return MakeClassPath(GlobalWmiNetNamespace, InstrumentationClassName);} }
        string GlobalRegistrationClassPath {get {return MakeClassPath(GlobalWmiNetNamespace, InstrumentedNamespacesClassName);} }
        string GlobalRegistrationPath {get {return AppendProperty(GlobalRegistrationClassPath, "NamespaceName", assemblyInfo.NamespaceName.Replace(@"\", @"\\"));} }
        string GlobalNamingClassPath {get {return MakeClassPath(GlobalWmiNetNamespace, NamingClassName);} }

        string DataDirectory {get {return Path.Combine(WMICapabilities.FrameworkDirectory, NamespaceName);} }
        string MofPath {get {return Path.Combine(DataDirectory, DecoupledProviderInstanceName + ".mof");} }
        string CodePath {get {return Path.Combine(DataDirectory, DecoupledProviderInstanceName + ".cs");} }

        static string MakeClassPath(string namespaceName, string className)
        {
            return namespaceName + ":" + className;
        }

        static string AppendProperty(string classPath, string propertyName, string propertyValue)
        {
            return classPath+'.'+propertyName+"=\""+propertyValue+'\"';
        }

        public bool IsAssemblyRegistered()
        {
            if(DoesInstanceExist(RegistrationPath))
            {
                ManagementObject inst = new ManagementObject(RegistrationPath);
                return (0==AssemblyUniqueIdentifier.ToLower().CompareTo(inst["RegisteredBuild"].ToString().ToLower()));
            }
            return false;
        }

        ManagementObject registrationInstance = null;
        ManagementObject RegistrationInstance
        {
            get
            {
                if(null == registrationInstance)
                    registrationInstance = new ManagementObject(RegistrationPath);
                return registrationInstance;
            }
        }

        public string Code
        {
            get
            {
                using(StreamReader reader = new StreamReader(CodePath))
                {
                    return reader.ReadToEnd();
                }
            }
        }
//        public string Mof { get { return (string)RegistrationInstance["Mof"]; } }

        internal string GenerateMof()
        {
            Type[] types = InstrumentedAttribute.GetInstrumentedTypes(assembly);
            string[] mofs = new string[types.Length];

            for(int i=0;i<types.Length;i++)
            {
                SchemaMapping mapping = new SchemaMapping(types[i], this);
                mofs[i] = GetMofFormat(mapping.NewClass);
            }
            return GenerateMof(mofs);
        }

        string GenerateMof(string [] mofs)
        {
            return String.Concat(
                "//**************************************************************************\r\n",
                String.Format("//* {0}\r\n", DecoupledProviderInstanceName),
                String.Format("//* {0}\r\n", AssemblyUniqueIdentifier),
                "//**************************************************************************\r\n",
                "#pragma autorecover\r\n",
                EnsureNamespaceInMof(GlobalRegistrationNamespace),
                EnsureNamespaceInMof(NamespaceName),

                PragmaNamespace(GlobalRegistrationNamespace),
                GetMofFormat(new ManagementClass(GlobalInstrumentationClassPath)),
                GetMofFormat(new ManagementClass(GlobalRegistrationClassPath)),
                GetMofFormat(new ManagementClass(GlobalNamingClassPath)),
                GetMofFormat(new ManagementObject(GlobalRegistrationPath)),

                PragmaNamespace(NamespaceName),
                GetMofFormat(new ManagementClass(InstrumentationClassPath)),
                GetMofFormat(new ManagementClass(RegistrationClassPath)),
                GetMofFormat(new ManagementClass(DecoupledProviderClassPath)),
                GetMofFormat(new ManagementClass(ProviderClassPath)),

                GetMofFormat(new ManagementObject(ProviderPath)),
//                events.Count>0?GetMofFormat(new ManagementObject(EventProviderRegistrationPath)):"",
                GetMofFormat(new ManagementObject(EventProviderRegistrationPath)),
                GetMofFormat(new ManagementObject(InstanceProviderRegistrationPath)),

                String.Concat(mofs),

                GetMofFormat(new ManagementObject(RegistrationPath)) );
        }

        public void RegisterNonAssemblySpecificSchema(InstallContext context)
        {
            EnsureNamespace(context, GlobalRegistrationNamespace);

            EnsureClassExists(context, GlobalInstrumentationClassPath, new ClassMaker(MakeGlobalInstrumentationClass));

            EnsureClassExists(context, GlobalRegistrationClassPath, new ClassMaker(MakeNamespaceRegistrationClass));

            EnsureClassExists(context, GlobalNamingClassPath, new ClassMaker(MakeNamingClass));

            EnsureNamespace(context, NamespaceName);

            EnsureClassExists(context, InstrumentationClassPath, new ClassMaker(MakeInstrumentationClass));

            EnsureClassExists(context, RegistrationClassPath, new ClassMaker(MakeRegistrationClass));

            // Make sure Hosting model is set correctly by default.  If not, we blow away the class definition
            try
            {
                ManagementClass cls = new ManagementClass(DecoupledProviderClassPath);
                if(cls["HostingModel"].ToString() != "Decoupled:Com")
                {
                    cls.Delete();
                }
            }
            catch(ManagementException e)
            {
                if(e.ErrorCode != ManagementStatus.NotFound)
                    throw e;
            }

            EnsureClassExists(context, DecoupledProviderClassPath, new ClassMaker(MakeDecoupledProviderClass));

            EnsureClassExists(context, ProviderClassPath, new ClassMaker(MakeProviderClass));

            if(!DoesInstanceExist(GlobalRegistrationPath))
                RegisterNamespaceAsInstrumented();
        }

        public void RegisterAssemblySpecificSchema()
        {
            Type[] types = InstrumentedAttribute.GetInstrumentedTypes(assembly);

            StringCollection events = new StringCollection();
            StringCollection instances = new StringCollection();
            StringCollection abstracts = new StringCollection();

            string[] mofs = new string[types.Length];

            HelperAssembly helper = new HelperAssembly("WMINET_Converter", NamespaceName);
            for(int i=0;i<types.Length;i++)
            {
                SchemaMapping mapping = new SchemaMapping(types[i], this);
                ReplaceClassIfNecessary(mapping.ClassPath, mapping.NewClass);
                mofs[i] = GetMofFormat(mapping.NewClass);
                switch(mapping.InstrumentationType)
                {
                    case InstrumentationType.Event:
                        events.Add(mapping.ClassName);
                        helper.AddType(mapping.ClassType);
                        break;
                    case InstrumentationType.Instance:
                        instances.Add(mapping.ClassName);
                        helper.AddType(mapping.ClassType);
                        break;
                    case InstrumentationType.Abstract:
                        abstracts.Add(mapping.ClassName);
                        break;
                    default:
                        break;
                }
            }

            RegisterAssemblySpecificDecoupledProviderInstance();
            RegisterProviderAsEventProvider(events);
            RegisterProviderAsInstanceProvider();

            RegisterAssemblyAsInstrumented();

            Directory.CreateDirectory(DataDirectory);

            using(StreamWriter log = new StreamWriter(CodePath, false, Encoding.ASCII))
            {
                log.WriteLine(helper.Code);
            }

            // Always generate the MOF in unicode
            using(StreamWriter log = new StreamWriter(MofPath, false, Encoding.Unicode))
            {
                log.WriteLine(GenerateMof(mofs));
            }
            WMICapabilities.AddAutorecoverMof(MofPath);
        }

        ///////////////////////////////////////////
        // Functions that create instances for the
        // registration of various objects
        void RegisterNamespaceAsInstrumented()
        {
            ManagementClass registrationClass = new ManagementClass(GlobalRegistrationClassPath);
            ManagementObject inst = registrationClass.CreateInstance();
            inst["NamespaceName"] = NamespaceName;
            inst.Put();
        }

        void RegisterAssemblyAsInstrumented()
        {
            ManagementClass registrationClass = new ManagementClass(RegistrationClassPath);
            ManagementObject inst = registrationClass.CreateInstance();
            inst["Name"] = DecoupledProviderInstanceName;
            inst["RegisteredBuild"] = AssemblyUniqueIdentifier;
            inst["FullName"] = AssemblyName;
            inst["PathToAssembly"] = AssemblyPath;
            inst["Code"] = "";
            inst["Mof"] = "";
            inst.Put();
        }

        void RegisterAssemblySpecificDecoupledProviderInstance()
        {
            ManagementClass providerClass = new ManagementClass(ProviderClassPath);
            ManagementObject inst = providerClass.CreateInstance();
            inst["Name"] = DecoupledProviderInstanceName;
            inst["HostingModel"] = "Decoupled:Com"; // TODO : SHOULD NOT NEED
            if(null != SecurityDescriptor)
                inst["SecurityDescriptor"] = SecurityDescriptor;
            inst.Put();
        }

        string RegisterProviderAsEventProvider(StringCollection events)
        {
            // TODO: Hanlde no events with MOF generation
//            if(events.Count == 0)
//                return null;

            ManagementClass providerRegistrationClass = new ManagementClass(EventProviderRegistrationClassPath);
            ManagementObject inst = providerRegistrationClass.CreateInstance();
            inst["provider"] = "\\\\.\\"+ProviderPath;
            string [] queries = new string[events.Count];
            int iCur = 0;
            foreach(string eventName in events)
                queries[iCur++] = "select * from "+eventName;

            inst["EventQueryList"] = queries;
            return inst.Put().Path;
        }

        string RegisterProviderAsInstanceProvider()
        {
            ManagementClass providerRegistrationClass = new ManagementClass(InstanceProviderRegistrationClassPath);
            ManagementObject inst = providerRegistrationClass.CreateInstance();
            inst["provider"] = "\\\\.\\"+ProviderPath;
            inst["SupportsGet"] = true;
            inst["SupportsEnumeration"] = true;
            return inst.Put().Path;
        }

        ///////////////////////////////////////////
        // Functions that create Class prototypes

        delegate ManagementClass ClassMaker();

        ManagementClass MakeNamingClass()
        {
            ManagementClass baseClass = new ManagementClass(GlobalInstrumentationClassPath);
            ManagementClass newClass = baseClass.Derive(NamingClassName);
            newClass.Qualifiers.Add("abstract", true);
            PropertyDataCollection props = newClass.Properties;
            props.Add("InstrumentedAssembliesClassName", InstrumentedAssembliesClassName, CimType.String);
            return newClass;
        }
        
        ManagementClass MakeInstrumentationClass()
        {
            ManagementClass newClass = new ManagementClass(NamespaceName, "", null);
            newClass.SystemProperties ["__CLASS"].Value = InstrumentationClassName;
            newClass.Qualifiers.Add("abstract", true);
            return newClass;
        }

        ManagementClass MakeGlobalInstrumentationClass()
        {
            ManagementClass newClass = new ManagementClass(GlobalWmiNetNamespace, "", null);
            newClass.SystemProperties ["__CLASS"].Value = InstrumentationClassName;
            newClass.Qualifiers.Add("abstract", true);
            return newClass;
        }

        ManagementClass MakeRegistrationClass()
        {
            ManagementClass baseClass = new ManagementClass(InstrumentationClassPath);
            ManagementClass newClass = baseClass.Derive(InstrumentedAssembliesClassName);
            PropertyDataCollection props = newClass.Properties;
            props.Add("Name", CimType.String, false);
            PropertyData prop = props["Name"];
            prop.Qualifiers.Add("key", true);
            props.Add("RegisteredBuild", CimType.String, false);
            props.Add("FullName", CimType.String, false);
            props.Add("PathToAssembly", CimType.String, false);
            props.Add("Code", CimType.String, false);
            props.Add("Mof", CimType.String, false);
            return newClass;
        }

        ManagementClass MakeNamespaceRegistrationClass()
        {
            ManagementClass baseClass = new ManagementClass(GlobalInstrumentationClassPath);
            ManagementClass newClass = baseClass.Derive(InstrumentedNamespacesClassName);
            PropertyDataCollection props = newClass.Properties;
            props.Add("NamespaceName", CimType.String, false);
            PropertyData prop = props["NamespaceName"];
            prop.Qualifiers.Add("key", true);
            return newClass;
        }

        ManagementClass MakeDecoupledProviderClass()
        {
            ManagementClass baseClass = new ManagementClass(Win32ProviderClassPath);
            ManagementClass newClass = baseClass.Derive(DecoupledProviderClassName);
            PropertyDataCollection props = newClass.Properties;
            props.Add("HostingModel", "Decoupled:Com", CimType.String);
            props.Add("SecurityDescriptor", CimType.String, false);
            props.Add("Version", 1, CimType.UInt32);
            props["CLSID"].Value = DecoupledProviderCLSID;
            return newClass;
        }

        ManagementClass MakeProviderClass()
        {
            ManagementClass baseClass = new ManagementClass(DecoupledProviderClassPath);
            ManagementClass newClass = baseClass.Derive(ProviderClassName);
            PropertyDataCollection props = newClass.Properties;
            props.Add("Assembly", CimType.String, false);
            return newClass;
        }

        ///////////////////////////////////////////
        // WMI Helper Functions
        static void EnsureNamespace(string baseNamespace, string childNamespaceName)
        {
            if(!DoesInstanceExist(baseNamespace + ":__NAMESPACE.Name=\""+childNamespaceName+"\""))
            {
                ManagementClass namespaceClass = new ManagementClass(baseNamespace + ":__NAMESPACE");
                ManagementObject inst = namespaceClass.CreateInstance();
                inst["Name"] = childNamespaceName;
                inst.Put();
            }
        }

        static void EnsureNamespace(InstallContext context, string namespaceName)
        {
            context.LogMessage("Ensuring that namespace exists: "+namespaceName);

            string fullNamespace = null;
            foreach(string name in namespaceName.Split(new char[] {'\\'}))
            {
                if(fullNamespace == null)
                {
                    fullNamespace = name;
                    continue;
                }
                EnsureNamespace(fullNamespace, name);
                fullNamespace += "\\" + name;
            }
        }

        static void EnsureClassExists(InstallContext context, string classPath, ClassMaker classMakerFunction)
        {
            try
            {
                context.LogMessage("Ensuring that class exists: "+classPath);
                ManagementClass theClass = new ManagementClass(classPath);
                theClass.Get();
            }
            catch(ManagementException e)
            {
                if(e.ErrorCode == ManagementStatus.NotFound)
                {
                    // The class does not exist.  Create it.
                    context.LogMessage("Ensuring that class exists: CREATING "+classPath);
                    ManagementClass theClass = classMakerFunction();
                    theClass.Put();
                }
                else
                    throw e;
            }
        }

        static bool DoesInstanceExist(string objectPath)
        {
            bool exists = false;
            try
            {
                ManagementObject inst = new ManagementObject(objectPath);
                inst.Get();
                exists = true;
            }
            catch(ManagementException e)
            {
                if(     ManagementStatus.InvalidNamespace != e.ErrorCode
                    &&  ManagementStatus.InvalidClass != e.ErrorCode
                    &&  ManagementStatus.NotFound != e.ErrorCode
                    )
                    throw e;
            }
            return exists;
        }

        /// <summary>
        /// Given a class path, this function will return the ManagementClass
        /// if it exists, or null if it does not.
        /// </summary>
        /// <param name="classPath">WMI path to Class</param>
        /// <returns></returns>
        static ManagementClass SafeGetClass(string classPath)
        {
            ManagementClass theClass = null;
            try
            {
                ManagementClass existingClass = new ManagementClass(classPath);
                existingClass.Get();
                theClass = existingClass;
            }
            catch(ManagementException e)
            {
                if(e.ErrorCode != ManagementStatus.NotFound)
                    throw e;
            }
            return theClass;
        }

        /// <summary>
        /// Given a class path, and a ManagementClass class definition, this
        /// function will create the class if it does not exist, replace the
        /// class if it exists but is different, or do nothing if the class
        /// exists and is identical.  This is useful for performance reasons
        /// since it can be expensive to delete an existing class and replace
        /// it.
        /// </summary>
        /// <param name="classPath">WMI path to class</param>
        /// <param name="newClass">Class to create or replace</param>
        static void ReplaceClassIfNecessary(string classPath, ManagementClass newClass)
        {
            ManagementClass oldClass = SafeGetClass(classPath);
            if(null == oldClass)
                newClass.Put();
            else
            {
                // TODO: Figure Out Why CompareTo does not work!!!
                //                if(false == newClass.CompareTo(newClass, ComparisonSettings.IgnoreCase | ComparisonSettings.IgnoreObjectSource))
                if(newClass.GetText(TextFormat.Mof) != oldClass.GetText(TextFormat.Mof))
                {
                    // TODO: Log to context?
                    oldClass.Delete();
                    newClass.Put();
                }
            }
        }

        static string GetMofFormat(ManagementObject obj)
        {
            return obj.GetText(TextFormat.Mof).Replace("\n", "\r\n") + "\r\n";
        }

        static string PragmaNamespace(string namespaceName)
        {
            return String.Format("#pragma namespace(\"\\\\\\\\.\\\\{0}\")\r\n\r\n", namespaceName.Replace("\\", "\\\\"));
        }

        static string EnsureNamespaceInMof(string baseNamespace, string childNamespaceName)
        {
            return String.Format("{0}instance of __Namespace\r\n{{\r\n  Name = \"{1}\";\r\n}};\r\n\r\n", PragmaNamespace(baseNamespace), childNamespaceName);
        }

        static string EnsureNamespaceInMof(string namespaceName)
        {
            string mof="";
            string fullNamespace = null;
            foreach(string name in namespaceName.Split(new char[] {'\\'}))
            {
                if(fullNamespace == null)
                {
                    fullNamespace = name;
                    continue;
                }
                mof+=EnsureNamespaceInMof(fullNamespace, name);
                fullNamespace += "\\" + name;
            }
            return mof;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\classqualifierenum\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\collection1\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\asynctest1\class1.cs ===
namespace ClientTest
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		Console.WriteLine ("Main executing on thread " + System.Threading.Thread.CurrentThread.GetHashCode ());
		// Sync
		
		try {
			ManagementObject diskC = new ManagementObject("Win32_logicaldisk='C:'");
			diskC.Get ();
			Console.WriteLine (diskC["FreeSpace"]);
		} catch (ManagementException e) {
			Console.WriteLine ("Caught WMI Exception: " + e.Message + e.ErrorCode);
		}

		// Now do it async
		ManagementOperationWatcher results = new ManagementOperationWatcher ();
		ObjectHandler objHandler = new ObjectHandler ("LaLa");
		ObjectHandler objHandler2 = new ObjectHandler ("Po");
		CompletionHandler completionHandler = new CompletionHandler ();
		results.ObjectReady += new ObjectReadyEventHandler (objHandler.NewObject);
		results.ObjectReady += new ObjectReadyEventHandler (objHandler2.NewObject);
		results.Completed += new CompletedEventHandler (completionHandler.Done);
		
		// 1) Simple Get

		Console.WriteLine ("\nObject Get\n");
		Console.WriteLine ("==========\n\n");
		
		try {
			ManagementObject diskC = new ManagementObject("Win32_logicaldisk='C:'");
			diskC.Get (results);

			while (!completionHandler.IsComplete) {
				System.Threading.Thread.Sleep (1000);
			}

			completionHandler.Reset ();
		} catch (ManagementException e) {
			Console.WriteLine ("Caught WMI Exception (Get): " + e.Message + e.ErrorCode);
		}

		// 2) Enumeration

		Console.WriteLine ("\nObject Enumeration\n");
		Console.WriteLine ("==================\n\n");
		
		try {
			ManagementObjectSearcher searcher = new ManagementObjectSearcher (new SelectQuery("win32_logicaldisk"));
			searcher.Get (results);
			
			while (!completionHandler.IsComplete) {
				System.Threading.Thread.Sleep (1000);
			}
    
			completionHandler.Reset ();
		}
		catch (ManagementException e) {
			Console.WriteLine ("Caught WMI Exception (Query): " + e.Message + e.ErrorCode);
		}

		
		// 3) Object Put
		Console.WriteLine ("\nObject Put\n");
		Console.WriteLine ("==========\n\n");
		PutHandler putHandler = new PutHandler ();
		results.ObjectPut += new ObjectPutEventHandler (putHandler.JustPut);
		
		try {
			ManagementObject newObj = new ManagementObject("root/default:__cimomidentification=@");
			newObj.Get ();
			newObj.Put (results);

			while (!completionHandler.IsComplete) {
				System.Threading.Thread.Sleep (1000);
			}

			completionHandler.Reset ();

		} catch (ManagementException e) {
			Console.WriteLine ("Caught WMI Exception (Put): " + e.Message + e.ErrorCode);
		}

		// 4) Use a listener that throws an exception
		try {
			Console.WriteLine ("\nCreating listener with exception\n");
			Console.WriteLine ("================================\n\n");
			ManagementObjectSearcher objS = new ManagementObjectSearcher
				("root/default", "select * from __CIMOMIDentification");
			ManagementOperationWatcher watcher = new ManagementOperationWatcher ();
			ObjectHandler objH = new ObjectHandler ("Dipsy");
			watcher.ObjectReady += new ObjectReadyEventHandler (objH.NewObject);
			watcher.ObjectReady += new ObjectReadyEventHandler (objH.NewObjectWithException);
			watcher.ObjectReady += new ObjectReadyEventHandler (objH.NewObject);
			watcher.ObjectReady += new ObjectReadyEventHandler (objH.NewObject);
			watcher.Completed += new CompletedEventHandler (completionHandler.Done);

			objS.Get (watcher);

			while (!completionHandler.IsComplete) {
				System.Threading.Thread.Sleep (1000);
			}

			completionHandler.Reset ();
		}
		catch (ManagementException e)
		{
			Console.WriteLine ("Caught WMI Exception (Put): " + e.Message + e.ErrorCode);
		}

		return 0;
    }
}

public class ObjectHandler {
	private String m_name;

	public ObjectHandler (String name) {
		m_name = name;
	}

	public void NewObject (object sender, ObjectReadyEventArgs e) {
		Console.WriteLine ("New object arrived for " + m_name + " on thread " + System.Threading.Thread.CurrentThread.GetHashCode ());
		if (null != e.Context)
			Console.WriteLine ("Context is " + e.Context.ToString ());
		try {
			ManagementObject obj = (ManagementObject)e.NewObject;
			Console.WriteLine (obj["DeviceID"] + " " + obj["FreeSpace"]);
		} catch (Exception) {}
	}

	public void NewObjectWithException (object sender, ObjectReadyEventArgs e) {
		Console.WriteLine ("New ex object arrived for " + m_name + " on thread " + System.Threading.Thread.CurrentThread.GetHashCode ());
		throw new Exception ("ListenerException");
	}
}

public class InterestingEventHandler {
	public InterestingEventHandler () {}

	public void WMIEventArrived (object sender, ObjectReadyEventArgs e) {
		ManagementObject obj = (ManagementObject)e.NewObject;
		ManagementObject obj2 = (ManagementObject)(obj["TargetInstance"]);
		Console.WriteLine ("New event arrived about process " + obj2["Name"] + " on thread " + System.Threading.Thread.CurrentThread.GetHashCode ());
	}
}

public class PutHandler {
	public void JustPut (object sender, ObjectPutEventArgs e) {
		Console.WriteLine ("Path to save object is " + e.Path.Path + " on thread " +
					System.Threading.Thread.CurrentThread.GetHashCode ());

		if (null != e.Context)
			Console.WriteLine ("Context is " + e.Context.ToString ());
	}
}

public class CompletionHandler {
	private bool m_bIsComplete = false;

	public void Done (object sender, CompletedEventArgs e) {
		if (null != e.Context)
			Console.WriteLine ("Context is " + e.Context.ToString ());

		Console.WriteLine ("Operation completed with status " + e.Status + " on thread " 
							+ System.Threading.Thread.CurrentThread.GetHashCode ());
		m_bIsComplete = true;
	}

	public bool IsComplete {
		get { return m_bIsComplete; }
	}

	public void Reset () { m_bIsComplete = false; }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\classenum\class1.cs ===
namespace ClassEnum
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		ManagementClass process = new ManagementClass ("cim_process");
		
		foreach (ManagementClass processSubClass in process.GetSubclasses ())
			Console.WriteLine ("Name of subclass is " + processSubClass.ClassPath);

		foreach (ManagementObject processInstance in process.GetInstances ())
			Console.WriteLine ("Name of instance is " + processInstance.Path.RelativePath);
        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\classcreate\class1.cs ===
namespace ClassCreate
{
using System;
using System.Management;
using System.Runtime.InteropServices;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

	public static string ArrayToString (Array value)
	{
		System.Text.StringBuilder str = new System.Text.StringBuilder ();

		foreach (object o in value)
			str.Append (o + " ");

		return str.ToString ();
	}

	public static string ObjectArrayToString (Array value)
	{
		System.Text.StringBuilder str = new System.Text.StringBuilder ();

		foreach (ManagementBaseObject o in value)
			str.Append (o.GetText(TextFormat.Mof) + "\r\n");

		return str.ToString ();
	}

	public static int Main(string[] args)
    {
		// Ensure we delete any previous copies of the class and its subclasses
		try {
			ManagementClass testSubClass = new ManagementClass ("root/default:URTNEWSUBCLASS");
			testSubClass.Delete ();
		} catch (ManagementException) {}
		try {
			ManagementClass testClass = new ManagementClass ("root/default:URTNEWCLASS");
			testClass.Delete ();
		} catch (ManagementException) {}

		// Get an empty class
        ManagementClass emptyClass = new ManagementClass ("root/default", "", null);

		// Set the class name
		emptyClass.SystemProperties ["__CLASS"].Value = "URTNEWCLASS";

		// Add some qualifiers
		QualifierCollection qualSet = emptyClass.Qualifiers;

		qualSet.Add ("sint32", (int)132235);
		qualSet.Add ("string", "Floxihoxibellification");
		qualSet.Add ("real64", (double)-12.33434234);
		qualSet.Add ("boolean", true);
		qualSet.Add ("sint32Array", new int[] {1, 2, 3}, false, true, false, true);
		qualSet.Add ("stringArray", new string[] {"il", "spezzio"}, false, false, false, false);
		qualSet.Add ("real64Array", new double[] {1.2, -1.3}, true, true, true, true);
		qualSet.Add ("booleanArray", new bool[] {false, true}, true, false, true, true);

		Console.WriteLine ("sint32: " + qualSet["sint32"].Value);
		Console.WriteLine ("string: " + qualSet["string"].Value);
		Console.WriteLine ("real64: " + qualSet["real64"].Value);
		Console.WriteLine ("boolean: " + qualSet["boolean"].Value);
		Console.WriteLine ("sint32Array: " + ArrayToString((Array)qualSet["sint32Array"].Value));
		Console.WriteLine ("stringArray: " + ArrayToString((Array)qualSet["stringArray"].Value));
		Console.WriteLine ("real64Array: " + ArrayToString((Array)qualSet["real64Array"].Value));
		Console.WriteLine ("booleanArray: " + ArrayToString((Array)qualSet["booleanArray"].Value));

		// Add some properties
		PropertyCollection propSet = emptyClass.Properties;

		// Use the simple Add that selects the right type
		propSet.Add ("uint8", (byte)10);
		propSet.Add ("uint16", (ushort)10);
		propSet.Add ("uint32", (uint)10);
		propSet.Add ("uint32x", (int) 11);
		propSet.Add ("uint32xx", (UInt32)123);
		propSet.Add ("uint32xxx", "12");
		propSet.Add ("uint64", (ulong)10);
		propSet.Add ("sint8", (sbyte)10);
		propSet.Add ("sint16", (short)10);
		propSet.Add ("sint32", (int)10);
		propSet.Add ("sint64", (long)10);
		propSet.Add ("bool", true);
		propSet.Add ("string", "Wibble");
		propSet.Add ("real32", (float) 10.23);
		propSet.Add ("real64", (double) 11.2222);

		ManagementClass embeddedClass = new ManagementClass ("root/default", "", null);
		embeddedClass.SystemProperties ["__CLASS"].Value = "URTEMBEDDEDCLASS";
		propSet.Add ("object", embeddedClass);

		// For datetime/reference types, use the non-default Add
		propSet.Add ("datetime", "20000728044535.000000-420" ,CimType.DateTime);
		propSet.Add ("reference", "foo=10", CimType.Reference);

		// Echo the non-null property values
		Console.WriteLine ("uint8: " + emptyClass["uint8"]);
		Console.WriteLine ("uint16: " + emptyClass["uint16"]);
		Console.WriteLine ("uint32: " + emptyClass["uint32"]);
		Console.WriteLine ("uint32x: " + emptyClass["uint32x"]);
		Console.WriteLine ("uint32xx: " + emptyClass["uint32xx"]);
		Console.WriteLine ("uint32xxx: " + emptyClass["uint32xxx"]);
		Console.WriteLine ("uint64: " + emptyClass["uint64"]);
		Console.WriteLine ("sint8: " + emptyClass["sint8"]);
		Console.WriteLine ("sint16: " + emptyClass["sint16"]);
		Console.WriteLine ("sint32: " + emptyClass["sint32"]);
		Console.WriteLine ("sint64: " + emptyClass["sint64"]);
		Console.WriteLine ("bool: " + emptyClass["bool"]);
		Console.WriteLine ("string: " + emptyClass["string"]);
		Console.WriteLine ("real32: " + emptyClass["real32"]);
		Console.WriteLine ("real64: " + emptyClass["real64"]);
		Console.WriteLine ("datetime: " + emptyClass["datetime"]);
		Console.WriteLine ("reference: " + emptyClass["reference"]);
		Console.WriteLine ("object: " + ((ManagementBaseObject)emptyClass["object"]).GetText(TextFormat.Mof));


		// Add a null property and put some qualifiers on it
		propSet.Add("referenceNull", CimType.Reference, false);
		Property newProp = propSet["referenceNull"];
		newProp.Qualifiers.Add ("read", true);

		// Add other simple null properties
		propSet.Add ("uint8Null", CimType.UInt8, false);
		propSet.Add ("uint16Null", CimType.UInt16, false);
		propSet.Add ("uint32Null", CimType.UInt32, false);
		propSet.Add ("uint64Null", CimType.UInt64, false);
		propSet.Add ("sint8Null", CimType.SInt8, false);
		propSet.Add ("sint16Null", CimType.SInt16, false);
		propSet.Add ("sint32Null", CimType.SInt32, false);
		propSet.Add ("sint64Null", CimType.SInt64, false);
		propSet.Add ("boolNull", CimType.Boolean, false);
		propSet.Add ("stringNull", CimType.String, false);
		propSet.Add ("real32Null", CimType.Real32, false);
		propSet.Add ("real64Null", CimType.Real64, false);
		propSet.Add ("objectNull", CimType.Object, false);
		propSet.Add ("datetimeNull", CimType.DateTime, false);


		// Add array null properties
		propSet.Add ("uint8ArrayNull", CimType.UInt8, true);
		propSet.Add ("uint16ArrayNull", CimType.UInt16, true);
		propSet.Add ("uint32ArrayNull", CimType.UInt32, true);
		propSet.Add ("uint64ArrayNull", CimType.UInt64, true);
		propSet.Add ("sint8ArrayNull", CimType.SInt8, true);
		propSet.Add ("sint16ArrayNull", CimType.SInt16, true);
		propSet.Add ("sint32ArrayNull", CimType.SInt32, true);
		propSet.Add ("sint64ArrayNull", CimType.SInt64, true);
		propSet.Add ("boolArrayNull", CimType.Boolean, true);
		propSet.Add ("stringArrayNull", CimType.String, true);
		propSet.Add ("real32ArrayNull", CimType.Real32, true);
		propSet.Add ("real64ArrayNull", CimType.Real64, true);
		propSet.Add ("objectArrayNull", CimType.Object, true);
		propSet.Add ("datetimeArrayNull", CimType.DateTime, true);

		// Add some array properties
		propSet.Add ("uint8Array", new byte[]{10, 20});
		propSet.Add ("uint16Array", new ushort[] {10, 20});
		propSet.Add ("uint32Array", new uint[] {10, 20});
		propSet.Add ("uint64Array", new ulong[] {10, 20});
		propSet.Add ("sint8Array", new sbyte[] {10, 20});
		propSet.Add ("sint16Array", new short[] {10, 20});
		propSet.Add ("sint32Array", new int[] {10, 20});
		propSet.Add ("sint64Array", new long[] {10, 20});
		propSet.Add ("boolArray", new bool[] {true, false, true});
		propSet.Add ("stringArray", new string[] {"Wibble", "Wobble"});
		propSet.Add ("real32Array", new float[] {(float)10.23, (float)111.22});
		propSet.Add ("real64Array", new double[] {11.2222, -23.32});
		propSet.Add ("datetimeArray", new string[] {"20000728044535.000000-420"}, CimType.DateTime);
		propSet.Add ("referenceArray", new string[] {"Foo=10" ,"bar.Nonesuch=\"a\""}, CimType.Reference);
		// BUGBUG following causes a TypeMismatch - RAID 45235 against runtime
		propSet.Add ("objectArray", new ManagementClass[] { embeddedClass, embeddedClass });

		// Echo the non-null array property values
		Console.WriteLine ("uint8Array: " + ArrayToString((Array)emptyClass["uint8Array"]));
		Console.WriteLine ("uint16Array: " + ArrayToString((Array)emptyClass["uint16Array"]));
		Console.WriteLine ("uint32Array: " + ArrayToString((Array)emptyClass["uint32Array"]));
		Console.WriteLine ("uint64Array: " + ArrayToString((Array)emptyClass["uint64Array"]));
		Console.WriteLine ("sint8Array: " + ArrayToString((Array)emptyClass["sint8Array"]));
		Console.WriteLine ("sint16Array: " + ArrayToString((Array)emptyClass["sint16Array"]));
		Console.WriteLine ("sint32Array: " + ArrayToString((Array)emptyClass["sint32Array"]));
		Console.WriteLine ("sint64Array: " + ArrayToString((Array)emptyClass["sint64Array"]));
		Console.WriteLine ("boolArray: " + ArrayToString((Array)emptyClass["boolArray"]));
		Console.WriteLine ("stringArray: " + ArrayToString((Array)emptyClass["stringArray"]));
		Console.WriteLine ("real32Array: " + ArrayToString((Array)emptyClass["real32Array"]));
		Console.WriteLine ("real64Array: " + ArrayToString((Array)emptyClass["real64Array"]));
		Console.WriteLine ("datetimeArray: " + ArrayToString((Array)emptyClass["datetimeArray"]));
		Console.WriteLine ("referenceArray: " + ArrayToString((Array)emptyClass["referenceArray"]));
		Console.WriteLine ("objectArray: " + ObjectArrayToString((Array)emptyClass["objectArray"]));

		emptyClass.Put();
		Console.WriteLine ("Successfully saved new base class");

		// Create a derived class
		ManagementClass baseClass = new ManagementClass ("root/default:URTNEWCLASS");
		ManagementClass newClass = baseClass.Derive ("URTNEWSUBCLASS");
		newClass.Put();
		Console.WriteLine ("Successfully saved new subclass");
        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\collectioncopyto\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\compareto\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\component\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\classqualifierenum\class1.cs ===
namespace ClassQualifierEnum
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
        ManagementClass MgmtsubclassObj = new ManagementClass();
		MgmtsubclassObj.Scope = new ManagementScope("root\\cimv2"); 
		MgmtsubclassObj.Path = new ManagementPath("Win32_Processor");
		MgmtsubclassObj.Options = new ObjectGetOptions();
		MgmtsubclassObj.Get();
		foreach (Qualifier Qual in MgmtsubclassObj.Qualifiers)
			Console.WriteLine("Qualifier    : {0} = {1}", Qual.Name, Qual.Value );
		Console.ReadLine();
		foreach (Property Prop in MgmtsubclassObj.Properties)
		{
			if (null == Prop.Value)
				Console.WriteLine("Property   : {0}", Prop.Name);
			else
				Console.WriteLine("Property   : {0} = {1}", Prop.Name, Prop.Value);
		}
		Console.ReadLine();
		return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\context\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\collection1\class1.cs ===
namespace Collection1
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		// Explicit scope + data query
		ManagementScope scope = new ManagementScope ("root/cimv2");
		DataQuery query = new DataQuery ("select * from Win32_process");
		
		ManagementObjectSearcher searcher = 
				new ManagementObjectSearcher (query);
		
		ManagementObjectCollection processes = searcher.Get();

		foreach (ManagementBaseObject process in processes) {
			Console.WriteLine (process["Name"]);
		}

		// Implicit scope + data query
		DataQuery query2 = new DataQuery ("select * from win32_logicaldisk");
		ManagementObjectSearcher searcher2 = 
				new ManagementObjectSearcher (query2);
		
		ManagementObjectCollection disks = searcher2.Get();

		foreach (ManagementObject disk in disks) {
			Console.WriteLine (disk["Freespace"]);
		}

		// Implicit scope + select query
		ManagementObjectSearcher searcher3 = 
			new ManagementObjectSearcher(new SelectQuery("win32_service"));

		foreach (ManagementObject service in searcher3.Get())
			Console.WriteLine (service["Name"]);

		//Asynchronous query
		ManagementOperationWatcher l = new ManagementOperationWatcher ();
		ObjectHandler objHandler = new ObjectHandler ("LaLa");
		ObjectHandler objHandler2 = new ObjectHandler ("Po");
		CompletionHandler completionHandler = new CompletionHandler ();
		
		l.ObjectReady += new ObjectReadyEventHandler (objHandler.NewObject);
		l.ObjectReady += new ObjectReadyEventHandler (objHandler2.NewObject);
		l.Completed += new CompletedEventHandler (completionHandler.Done);

		searcher2.Get (l);

		while (!completionHandler.IsComplete) {
			System.Threading.Thread.Sleep (1000);
		}

		//Event watcher
		ManagementEventWatcher w = new ManagementEventWatcher (
				"select * from __instancemodificationevent within 5 where targetinstance isa 'Win32_Process'");

		try {
			ManagementBaseObject o = w.WaitForNextEvent ();
			Console.WriteLine (o["__CLASS"]);
		} catch (ManagementException e) {
			Console.WriteLine ("Exception: " + e.Message);
		}
        return 0;
    }
}

public class ObjectHandler {
	private String m_name;

	public ObjectHandler (String name) {
		m_name = name;
	}

	public void NewObject (object sender, ObjectReadyEventArgs e) {
		Console.WriteLine ("New object arrived for " + m_name + " on thread " + System.Threading.Thread.CurrentThread.GetHashCode ());
		if (null != e.Context)
			Console.WriteLine ("Context is " + e.Context.ToString ());
		try {
			ManagementBaseObject obj = e.NewObject;
			Console.WriteLine (obj["DeviceID"] + " " + obj["FreeSpace"]);
		} catch (Exception) {}
	}
}

public class CompletionHandler {
	private bool m_bIsComplete = false;

	public void Done (object sender, CompletedEventArgs e) {
		if (null != e.Context)
			Console.WriteLine ("Context is " + e.Context.ToString ());

		Console.WriteLine ("Operation completed with status " + e.Status + " on thread " 
							+ System.Threading.Thread.CurrentThread.GetHashCode ());
		m_bIsComplete = true;
	}

	public bool IsComplete {
		get { return m_bIsComplete; }
	}

	public void Reset () { m_bIsComplete = false; }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\compareto\class1.cs ===
namespace CompareTo
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		ManagementObject diskC = new ManagementObject ("Win32_LogicalDisk='C:'");
		ManagementObject diskD = new ManagementObject ("Win32_LogicalDisk='D:'");
		Console.WriteLine (diskC.CompareTo (diskD, ComparisonSettings.IncludeAll));

		ManagementObject anotherDiskC = new ManagementObject ("Win32_LogicalDisk='C:'");
		Console.WriteLine (diskC.CompareTo (diskC, ComparisonSettings.IncludeAll));
        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\copyto\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\collectioncopyto\class1.cs ===
namespace CollectionCopyTo
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		ManagementObjectSearcher s = new ManagementObjectSearcher 
			(new DataQuery("select * from Win32_Process"));
		ManagementObject[] processes = new ManagementObject [100];

		ManagementObjectCollection c = s.Get ();
		c.CopyTo (processes, 0);
		
		for (int i = 0; i < processes.Length; i++)
			if (null != processes[i])
				Console.WriteLine (((ManagementObject)(processes[i]))["Name"]);

        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\createinstance\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\delegatethrow\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\delegatethrowtest\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\component\form1.cs ===
namespace Component
{
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.WinForms;
using System.Data;

/// <summary>
///    Summary description for Form1.
/// </summary>
public class Form1 : System.WinForms.Form
{
    /// <summary> 
    ///    Required designer variable
    /// </summary>
    private System.ComponentModel.Container components;
	
	private System.Management.ManagementObject cDrive;
	
	private System.Management.ManagementObject win32LogicalDisk;

    public Form1()
    {
        //
        // Required for Win Form Designer support
        //
        InitializeComponent();

        //
        // TODO: Add any constructor code after InitializeComponent call
        //
    }

    /// <summary>
    ///    Clean up any resources being used
    /// </summary>
    public override void Dispose()
    {
        base.Dispose();
        components.Dispose();
    }

    /// <summary>
    ///    Required method for Designer support - do not modify
    ///    the contents of this method with the code editor
    /// </summary>
    private void InitializeComponent()
	{
		this.components = new System.ComponentModel.Container();
		this.cDrive = new System.Management.ManagementObject();
		this.win32LogicalDisk = new System.Management.ManagementObject();
		
		//@design cDrive.SetLocation(new System.Drawing.Point(116, 7));
		
		//@design win32LogicalDisk.SetLocation(new System.Drawing.Point(7, 7));
		
		this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
		this.Text = "Form1";
		//@design this.TrayLargeIcon = true;
		//@design this.TrayHeight = 201;
		this.ClientSize = new System.Drawing.Size(352, 277);
		
		
	}
    /*
     * The main entry point for the application.
     *
     */
    public static void Main(string[] args) 
    {
        Application.Run(new Form1());
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\deleteclass\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\copyto\class1.cs ===
namespace CopyTo
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
        ManagementClass dummyClass = new ManagementClass("root/default","",null);
		dummyClass.SystemProperties["__CLASS"].Value = "TestMyCopyToClass";
		PropertySet mykeyprop = dummyClass.Properties;
		mykeyprop.Add("reg_prop","string_prop");
		mykeyprop.Add("MyKey","Hello");
		dummyClass.Put();
		ManagementPath myPath = new ManagementPath("root/cimv2");
		// CopyTo( )
		ManagementPath newPath = dummyClass.CopyTo(myPath); 
		Console.WriteLine (newPath.Path);
		return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\context\class1.cs ===
namespace Context
{
using System;
using System.Collections;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
        // Create a class
			ManagementClass dummyClass = new ManagementClass("root/default","",null);
			dummyClass.SystemProperties["__CLASS"].Value = "TestDelClassSync";
			PropertySet mykeyprop = dummyClass.Properties;
			mykeyprop.Add("MydelKey","delHello");
			dummyClass.Put();

// Get the Class TestDelClassSync
			ManagementClass dummyDeleteCheck = new ManagementClass("root/default","TestDelClassSync",null);
			dummyDeleteCheck.Get();

// Set the Delete Options on the Class TestDelClassSync
			//int Capacity = 8;
			CaseInsensitiveHashtable MyHash = new CaseInsensitiveHashtable();
			DeleteOptions Options = new DeleteOptions(MyHash);
			dummyDeleteCheck.Delete(Options);
return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\enuminstances\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\delegatethrow\form1.cs ===
namespace DelegateThrow
{
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.WinForms;
using System.Data;
using System.Management;

/// <summary>
///    Summary description for Form1.
/// </summary>
public class Form1 : System.WinForms.Form
{
    /// <summary> 
    ///    Required designer variable
    /// </summary>
    private System.ComponentModel.Container components;
	private System.WinForms.Label labelStatus;
	private System.WinForms.GroupBox groupBox1;
	private System.WinForms.CheckBox checkBoxIncludeThrowingDelegate;
	private System.WinForms.Button buttonStart;
	private ManagementObjectSearcher searcher;
	
    public Form1()
    {
        //
        // Required for Win Form Designer support
        //
        InitializeComponent();

        //
        // TODO: Add any constructor code after InitializeComponent call
        //
    }

    /// <summary>
    ///    Clean up any resources being used
    /// </summary>
    public override void Dispose()
    {
        base.Dispose();
        components.Dispose();
    }

    /// <summary>
    ///    Required method for Designer support - do not modify
    ///    the contents of this method with the code editor
    /// </summary>
    private void InitializeComponent()
	{
		this.components = new System.ComponentModel.Container();
		this.checkBoxIncludeThrowingDelegate = new System.WinForms.CheckBox();
		this.labelStatus = new System.WinForms.Label();
		this.buttonStart = new System.WinForms.Button();
		this.groupBox1 = new System.WinForms.GroupBox();
		
		checkBoxIncludeThrowingDelegate.Location = new System.Drawing.Point(40, 104);
		checkBoxIncludeThrowingDelegate.Text = "Include Throwing Delegate";
		checkBoxIncludeThrowingDelegate.Size = new System.Drawing.Size(200, 24);
		checkBoxIncludeThrowingDelegate.AccessibleRole = System.WinForms.AccessibleRoles.CheckButton;
		checkBoxIncludeThrowingDelegate.TabIndex = 1;
		checkBoxIncludeThrowingDelegate.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
		
		labelStatus.Location = new System.Drawing.Point(16, 24);
		labelStatus.Text = "Not started";
		labelStatus.Size = new System.Drawing.Size(184, 24);
		labelStatus.TabIndex = 0;
		
		buttonStart.Location = new System.Drawing.Point(32, 32);
		buttonStart.Size = new System.Drawing.Size(224, 48);
		buttonStart.TabIndex = 0;
		buttonStart.Text = "Start";
		buttonStart.AddOnClick(new System.EventHandler(buttonStart_Click));
		
		groupBox1.Location = new System.Drawing.Point(32, 160);
		groupBox1.TabIndex = 2;
		groupBox1.TabStop = false;
		groupBox1.Text = "Status";
		groupBox1.Size = new System.Drawing.Size(224, 64);
		
		this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
		this.Text = "Form1";
		//@design this.TrayLargeIcon = true;
		//@design this.TrayHeight = 0;
		
		groupBox1.Controls.Add(labelStatus);
		this.Controls.Add(groupBox1);
		this.Controls.Add(checkBoxIncludeThrowingDelegate);
		this.Controls.Add(buttonStart);

		
		searcher = new ManagementObjectSearcher ("root/default", "select * from __CIMOMIdentification");
	
		
	}
	protected void buttonStart_Click(object sender, System.EventArgs e)
	{
		ManagementOperationWatcher watcher = new ManagementOperationWatcher ();
		CompletionHandler handler = new CompletionHandler (labelStatus);
		int opCount = 4;

		// Attach some event handlers for the object
		watcher.ObjectReady += new ObjectReadyEventHandler (handler.HandleObject);
		watcher.ObjectReady += new ObjectReadyEventHandler (handler.HandleObject);
		
		if (checkBoxIncludeThrowingDelegate.Checked)
		{
			watcher.ObjectReady += new ObjectReadyEventHandler (handler.HandleObjectWithException);
			opCount++;
		}

		watcher.ObjectReady += new ObjectReadyEventHandler (handler.HandleObject);
		watcher.ObjectReady += new ObjectReadyEventHandler (handler.HandleObject);
		
		// Add a completed event handler
		watcher.Completed += new CompletedEventHandler (handler.Done);

		// record the number of listeners
		handler.SetInitialOpCount (opCount);

		// go
		searcher.Get(watcher);
	}

    /*
     * The main entry point for the application.
     *
     */
    public static void Main(string[] args) 
    {
        Application.Run(new Form1());
    }

}

internal class CompletionHandler 
{
	private int opCount = 0;
	private int initialOpCount = 0;
	private Label labelStatus;

	internal CompletionHandler (Label labelStatus)
	{
		this.labelStatus = labelStatus;
	}

	internal void HandleObject (object sender, ObjectReadyEventArgs args) {
		++opCount;

	}

	internal void HandleObjectWithException (object sender, ObjectReadyEventArgs args) {
		++opCount;
		throw new Exception();
	}

	internal void Done (object sender, CompletedEventArgs args) {
		if (opCount == initialOpCount)
			labelStatus.Text = "All " + opCount + " callbacks processed";
		else
			labelStatus.Text = "Only " + opCount + " of " + initialOpCount + " callbacks processed";
	}

	internal void SetInitialOpCount (int opCount)
	{
		initialOpCount = opCount;
		this.opCount = 0;
	}
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\createinstance\class1.cs ===
namespace CreateInstance
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		try {
			ManagementClass existingClass = new ManagementClass ("root/default:TestCreateInstance");
			existingClass.Delete ();
		} catch {}

		ManagementClass newClass = new ManagementClass ("root/default", "", null);
		newClass["__CLASS"] = "TestCreateInstance";

		newClass.Properties.Add ("MyKey", CIMType.Uint32, false);
		newClass.Properties["mykey"].Qualifiers.Add ("key", true);
		newClass.Put();

		ManagementObject newInstance = newClass.CreateInstance ();
		newInstance["MyKey"] = 22;
		ManagementPath newPath = newInstance.Put();
		Console.WriteLine (newPath.Path);

		ManagementObject getInstance = new ManagementObject ("root/default:TestCreateInstance=22");
		Console.WriteLine (getInstance["__RELPATH"]);
        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\enumprops\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\delegatethrowtest\form1.cs ===
namespace DelegateThrow
{
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.WinForms;
using System.Data;
using System.Management;

/// <summary>
///    Summary description for Form1.
/// </summary>
public class Form1 : System.WinForms.Form
{
    /// <summary> 
    ///    Required designer variable
    /// </summary>
    private System.ComponentModel.Container components;
	private System.WinForms.Label labelStatus;
	private System.WinForms.GroupBox groupBox1;
	private System.WinForms.CheckBox checkBoxIncludeThrowingDelegate;
	private System.WinForms.Button buttonStart;
	private ManagementObjectSearcher searcher;
	
    public Form1()
    {
        //
        // Required for Win Form Designer support
        //
        InitializeComponent();

        //
        // TODO: Add any constructor code after InitializeComponent call
        //
    }

    /// <summary>
    ///    Clean up any resources being used
    /// </summary>
    public override void Dispose()
    {
        base.Dispose();
        components.Dispose();
    }

    /// <summary>
    ///    Required method for Designer support - do not modify
    ///    the contents of this method with the code editor
    /// </summary>
    private void InitializeComponent()
	{
		this.components = new System.ComponentModel.Container();
		this.checkBoxIncludeThrowingDelegate = new System.WinForms.CheckBox();
		this.labelStatus = new System.WinForms.Label();
		this.buttonStart = new System.WinForms.Button();
		this.groupBox1 = new System.WinForms.GroupBox();
		
		checkBoxIncludeThrowingDelegate.Location = new System.Drawing.Point(40, 104);
		checkBoxIncludeThrowingDelegate.Text = "Include Throwing Delegate";
		checkBoxIncludeThrowingDelegate.Size = new System.Drawing.Size(200, 24);
		checkBoxIncludeThrowingDelegate.AccessibleRole = System.WinForms.AccessibleRoles.CheckButton;
		checkBoxIncludeThrowingDelegate.TabIndex = 1;
		checkBoxIncludeThrowingDelegate.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
		
		labelStatus.Location = new System.Drawing.Point(16, 24);
		labelStatus.Text = "Not started";
		labelStatus.Size = new System.Drawing.Size(184, 24);
		labelStatus.TabIndex = 0;
		
		buttonStart.Location = new System.Drawing.Point(32, 32);
		buttonStart.Size = new System.Drawing.Size(224, 48);
		buttonStart.TabIndex = 0;
		buttonStart.Text = "Start";
		buttonStart.AddOnClick(new System.EventHandler(buttonStart_Click));
		
		groupBox1.Location = new System.Drawing.Point(32, 160);
		groupBox1.TabIndex = 2;
		groupBox1.TabStop = false;
		groupBox1.Text = "Status";
		groupBox1.Size = new System.Drawing.Size(224, 64);
		
		this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
		this.Text = "Form1";
		//@design this.TrayLargeIcon = true;
		//@design this.TrayHeight = 0;
		
		groupBox1.Controls.Add(labelStatus);
		this.Controls.Add(groupBox1);
		this.Controls.Add(checkBoxIncludeThrowingDelegate);
		this.Controls.Add(buttonStart);

		
		searcher = new ManagementObjectSearcher ("root/default", "select * from __CIMOMIdentification");
	
		
	}
	protected void buttonStart_Click(object sender, System.EventArgs e)
	{
		ManagementOperationWatcher watcher = new ManagementOperationWatcher ();
		CompletionHandler handler = new CompletionHandler (labelStatus);
		int opCount = 4;

		// Attach some event handlers for the object
		watcher.ObjectReady += new ObjectReadyEventHandler (handler.HandleObject);
		watcher.ObjectReady += new ObjectReadyEventHandler (handler.HandleObject);
		
		if (checkBoxIncludeThrowingDelegate.Checked)
		{
			watcher.ObjectReady += new ObjectReadyEventHandler (handler.HandleObjectWithException);
			opCount++;
		}

		watcher.ObjectReady += new ObjectReadyEventHandler (handler.HandleObject);
		watcher.ObjectReady += new ObjectReadyEventHandler (handler.HandleObject);
		
		// Add a completed event handler
		watcher.Completed += new CompletedEventHandler (handler.Done);

		// record the number of listeners
		handler.SetInitialOpCount (opCount);

		// go
		searcher.Get(watcher);
	}

    /*
     * The main entry point for the application.
     *
     */
    public static void Main(string[] args) 
    {
        Application.Run(new Form1());
    }

}

internal class CompletionHandler 
{
	private int opCount = 0;
	private int initialOpCount = 0;
	private Label labelStatus;

	internal CompletionHandler (Label labelStatus)
	{
		this.labelStatus = labelStatus;
	}

	internal void HandleObject (object sender, ObjectReadyEventArgs args) {
		++opCount;

	}

	internal void HandleObjectWithException (object sender, ObjectReadyEventArgs args) {
		++opCount;
		throw new Exception();
	}

	internal void Done (object sender, CompletedEventArgs args) {
		if (opCount == initialOpCount)
			labelStatus.Text = "All " + opCount + " callbacks processed";
		else
			labelStatus.Text = "Only " + opCount + " of " + initialOpCount + " callbacks processed";
	}

	internal void SetInitialOpCount (int opCount)
	{
		initialOpCount = opCount;
		this.opCount = 0;
	}
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\enumsubclasses\test.cs ===
// Cool source file
using System;
using System.WMI;
using System.IO;
//using Microsoft.Win32.Interop;

class WmiPlusTest
{
  public static int Main(String[] args)
  {

	TextWriter oldTW = null; //used to save old console.out for logging
	StreamWriter sw = null;  //used to redirect console.out to file for logging
    Console.WriteLine("WMI Plus Test Application");
   
	//validate arguments
	if ( ((args.Length != 0) && (args.Length != 2)) || ((args.Length == 2) && (args[0] != "/log")) ) 
    {
        Console.WriteLine("Usage: ... "); 
        return 0; 
    }
	
	//if "/log" specified, redirect Console.Out to log file
	if (args.Length > 0)
	{
		FileStream fs = new FileStream(args[1], FileMode.OpenOrCreate, FileAccess.ReadWrite); //open log file
		oldTW = Console.Out; //save default standard output
		sw = new StreamWriter(fs);
		Console.SetOut(sw); //replace with file
	}
	

	//Create a WmiPath object
	WmiPath Path = new WmiPath("root\\default");
	Console.WriteLine("String in WmiPath object is : {0}", Path.PathString);

	//Make a connection to this path
	WmiCollection Session = WmiCollection.Connect(Path);
//	WmiCollection Session = WmiCollection.Connect("root\\cimv2");
	
	//Get a class from this connection
	WmiObject ServiceClass = Session.Get(new WmiPath("MyStaticClass"));
	//Display the class name (__CLASS property of the class)
	Console.WriteLine("The name of this class is : {0}", ServiceClass["__CLASS"]);

	//Enumerate instances (static only because of security problem !!)
	WmiCollection Instances = Session.Open(new WmiPath("MyStaticClass"));
	foreach (WmiObject obj in Instances)
		Console.WriteLine("The key of this instance is : {0}", obj["MyProp"]);
    
	
//		WmiCollection Services = Session.Open("Win32_Service");		
//		foreach (WmiObject Service in Services)
//			Console.WriteLine("{0}", Service["Name"]);
//r	}
//r	catch (Exception e)
//r	{
//r		Console.WriteLine("Exception caught : {0}", e.Message);
//r	}
		

	//flush log file, and restore standard output if changed
	if (sw != null)
		sw.Flush();
	if (oldTW != null)
		Console.SetOut(oldTW);

	return 0;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\deleteclass\class1.cs ===
namespace DeleteClass
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

	/*
	 * Note that if you remove the [MTAThread] attribute below, the code as
	 * arranged will run in an STA and block indefinitely because the 
	 * message pump cannot process the incoming RPC call.
	 * If you remove this attribute, you will also find that the line
	 * folowing the comment marked **SOURCE**, when moved to the line
	 * marked **DESTINATION**, causes the chosen threading model to be
	 * MTA and everything starts working again!
	 */

	[MTAThread]
    public static int Main(string[] args)
    {
        try
		{
			// **DESTINATION**
			// Create watcher and completionHandler
			
			ManagementOperationWatcher delete_res = new ManagementOperationWatcher();
			ManagementOperationWatcher results = new ManagementOperationWatcher();
			CompletionHandler completionHandler = new CompletionHandler();
			CompletionHandler completionHandler_res = new CompletionHandler();
			delete_res.Completed += new CompletedEventHandler(completionHandler_res.Done);
            results.Completed += new CompletedEventHandler(completionHandler.Done);
			PutHandler putHandler = new PutHandler ();
		    results.ObjectPut += new ObjectPutEventHandler (putHandler.JustPut);

			// Create the class TestDelClassasync for deletion later
			// **SOURCE **
			ManagementClass newclassObj = new ManagementClass("root/default","",null);
			newclassObj.SystemProperties["__CLASS"].Value = "TestDelClassasync";
			PropertySet mykeyprop = newclassObj.Properties;
			mykeyprop.Add("MyKey","Hello");

			Console.WriteLine("Thread is {0}", System.Threading.Thread.CurrentThread.ApartmentState);
			newclassObj.Put(results);
			while (!completionHandler.IsComplete) {
				System.Threading.Thread.Sleep (1000);
			}
			completionHandler.Reset ();
						
			ManagementClass dummyClassCheck = new ManagementClass("root/default","TestDelClassasync",null);
			//dummyClassCheck.Get();
			Console.WriteLine(dummyClassCheck.SystemProperties["__Class"].Value.ToString());

			// Delete the Class aync
			newclassObj.Delete(delete_res);
			while (!completionHandler_res.IsComplete) {
				System.Threading.Thread.Sleep (1000);
			}
			completionHandler_res.Reset ();
			if ("System.Management.ManagementOperationWatcher" == completionHandler_res.Sender)
			{
				Console.WriteLine("Test 10.2: Able to delete classes asynchronously.");
			}
			else
			{
				Console.WriteLine("Test 10.2: Unable to delete classes asynchronously.");
			}
		}
		catch (Exception e)
		{
			Console.WriteLine("Test 10.2: " + e.GetType().ToString());
			Console.WriteLine(e.Message + e.StackTrace);
		}


        return 0;
    }

	public class ObjectHandler {
	private String m_name;

	public ObjectHandler (String name) {
		m_name = name;
	}

	public void NewObject (object sender, ObjectReadyEventArgs e) {
		Console.WriteLine ("New object arrived for " + m_name + " on thread " + System.Threading.Thread.CurrentThread.GetHashCode ());
		if (null != e.Context)
			Console.WriteLine ("Context is " + e.Context.ToString ());
		try {
			ManagementObject obj = (ManagementObject)e.NewObject;
			Console.WriteLine (obj["DeviceID"] + " " + obj["FreeSpace"]);
		} catch (Exception) {}
	}
}

public class InterestingEventHandler {
	public InterestingEventHandler () {}

	public void WMIEventArrived (object sender, ObjectReadyEventArgs e) {
		ManagementObject obj = (ManagementObject)e.NewObject;
		ManagementObject obj2 = (ManagementObject)(obj["TargetInstance"]);
		Console.WriteLine ("New event arrived about process " + obj2["Name"] + " on thread " + System.Threading.Thread.CurrentThread.GetHashCode ());
	}
}

public class PutHandler {
	public void JustPut (object sender, ObjectPutEventArgs e) {
		Console.WriteLine ("Path to save object is " + e.Path.Path + " on thread " +
					System.Threading.Thread.CurrentThread.GetHashCode ());

		if (null != e.Context)
			Console.WriteLine ("Context is " + e.Context.ToString ());
	}
}

public class CompletionHandler {
	private bool m_bIsComplete = false;
	private string result = "";

	public void Done (object sender, CompletedEventArgs e) {
		if (null != e.Context)
			Console.WriteLine ("Context is " + e.Context.ToString ());

		result = sender.ToString ();

		Console.WriteLine ("Operation completed with status " + e.Status + " on thread " 
							+ System.Threading.Thread.CurrentThread.GetHashCode ());
		m_bIsComplete = true;
	}

	public bool IsComplete {
		get { return m_bIsComplete; }
	}

	public string Sender {
		get { return result; }
	}

	public void Reset () { m_bIsComplete = false; }
}
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\enumsubclasses\test1.cs ===
// Cool source file
using System;
using System.WMI;
using System.IO;

class WmiPlusTest
{
  public static int Main()
  {

	System.Diagnostics.TraceSwitch MySwitch = new System.Diagnostics.TraceSwitch("MySwitch",null);
    MySwitch.Level=System.Diagnostics.TraceLevel.Verbose;

    Console.WriteLine("WMI COM+ Test Application");
   
	
	//Create a WmiPath object
	WmiPath Path = new WmiPath("root\\cimv2");
	Console.WriteLine("String in WmiPath object is : {0}", Path.PathString);

	//Make a connection to this path
	WmiCollection Session = WmiCollection.Connect(Path);
	
	//Get a class from this connection
	WmiObject ServiceClass = Session.Get(new WmiPath("Win32_LogicalDisk"));
	//WmiObject ServiceClass = Session.Get("Win32_LogicalDisk");
	//Display the class name (__CLASS property of the class)
	Console.WriteLine("The name of this class is : {0}", ServiceClass["__CLASS"]);

	//Enumerate instances 
	WmiCollection Instances = Session.Open(new WmiPath("Win32_LogicalDisk"));
	foreach (WmiObject obj in Instances)
		Console.WriteLine("The key of this instance is : {0}", obj["Name"]);
    
	//Query
	WmiCollection QueryRes = Session.Query(new WmiQuery("select * from Win32_Service"));
	foreach (WmiObject Service in QueryRes)
		Console.WriteLine("{0}", Service["Name"]);

	return 0;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\eventwatcherasync\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\enuminstances\enumerateinstances.cs ===
namespace EnumInstances
{
using System;
using System.Management;

/// <summary>
///    ManagementObjectSearcher Example 1 : Enumerate environment variables
/// </summary>
public class EnumerateInstances
{
    public EnumerateInstances()
    {
    }

    public static int Main(string[] args)
    {
		//Build a query for enumeration of Win32_Environment instances
		InstanceEnumerationQuery query = new InstanceEnumerationQuery("Win32_Environment");

		//Instantiate an object searcher with this query
		ManagementObjectSearcher searcher = new ManagementObjectSearcher(query); 

		//Call Get() to retrieve the collection of objects and loop through it
		foreach (ManagementBaseObject envVar in searcher.Get())
			Console.WriteLine("Variable : {0}, Value = {1}", envVar["Name"],envVar["VariableValue"]);

		Console.ReadLine();

		return 0;
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\eventwatcherpolling\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\enumprops\enumerateproperties.cs ===
namespace EnumProps
{
using System;
using System.Management;


/// <summary>
///    ManagementObject Example 1 : enumerate properties of a service object
/// </summary>
public class EnumerateProperties
{
    public EnumerateProperties()
    {
    }

    public static int Main(string[] args)
    {
		//Get the Alerter service object
		ManagementObject myService = new ManagementObject("Win32_Service=\"Alerter\"");

		//Enumerate through the properties of this object and display the names and values
		foreach (Property p in myService.Properties)
			Console.WriteLine("Property {0} = {1}", p.Name, p.Value);

		Console.ReadLine(); //to pause before closing the window

        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\enumsubclasses\class1.cs ===
namespace Test2
{
    using System;
	using System.Management.Root.Cimv2.Win32;

    /// <summary>
    ///    Summary description for Class1.
    /// </summary>
    public class Class1
    {
        public Class1()
        {
            //
            // TODO: Add Constructor Logic here
            //
        }

        public static int Main(string[] args)
        {
            //
            // TODO: Add code to start application here
            //
			Wmisetting ws= new Wmisetting();
			ws.LoggingLevel = 1;
            return 0;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\exception\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\invokemethod\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\eventwatcherasync\class1.cs ===
namespace eventwatcherasync
{
using System;
using System.Management;
using System.Threading;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class EventWatcherAsync
{
    public EventWatcherAsync()
    {
    }

    public static int Main(string[] args)
    {
		//Create event query to receive timer events
		WQLEventQuery query = new WQLEventQuery("__TimerEvent", "TimerId=\"Timer1\"");

		//Initialize an event watcher and subscribe to events that match this query
		ManagementEventWatcher watcher = new ManagementEventWatcher(query);

		//Setup a listener for events
		watcher.EventArrived += new EventArrivedEventHandler((new EventHandler()).HandleEvent);

		watcher.Start();

		Thread.Sleep(10000);
		
		watcher.Stop();

		return 0;
    }
}

public class EventHandler
{
	public void HandleEvent(object sender, EventArrivedEventArgs e)
	{
		Console.WriteLine("Event arrived !");
	}

}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\eventwatcherpolling\class1.cs ===
namespace eventwatcherpolling
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class EventWatcherPolling
{
    public EventWatcherPolling()
    {
    }

	public static int Main(string[] args)
    {
		//Create event query to be notified within 1 second of a change in a service
		WQLEventQuery query = new WQLEventQuery("__InstanceModificationEvent", new TimeSpan(0,0,1), "TargetInstance isa \"Win32_Service\"");

		//Initialize an event watcher and subscribe to events that match this query
		ManagementEventWatcher watcher = new ManagementEventWatcher(query);
		
		//wait for 5 events
		int i = 0;
		while (i < 5)
		{
			//Block until the next event occurs
			ManagementBaseObject e = watcher.WaitForNextEvent();

			//Display information from the event
			Console.WriteLine("Service {0} has changed, State is {1}", 
				((ManagementBaseObject)e["TargetInstance"])["Name"],
				((ManagementBaseObject)e["TargetInstance"])["State"]);
			i++;
		}

		//cancel the subscription
		watcher.Stop();

		return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\enumsubclasses\wmisetting.cs ===
// Early Bound Managed Code Wrapper for WMI class Win32_Wmisetting
//------------------------------------------------------------------------------
/// <autogenerated>
///     This class was generated by a tool.
///     Runtime Version: 1.0.2107.0
///
///     Changes to this file may cause incorrect behavior and will be lost if 
///     the code is regenerated.
/// </autogenerated>
//------------------------------------------------------------------------------

namespace System.Management.Root.Cimv2.Win32 {
    using System;
    using System.Management;
    
    public class Wmisetting {
        private _ManagementSystemProperties _privSystemProps;
        private ManagementObject _privObject;
        
        public Wmisetting() {
            String _strPath = "";
            if (((_defServer) != (String.Empty))) {
                _strPath = ((_strPath) + (_defServer));
            }
            _strPath = ((_strPath) + ((("\\") + (((_defNamespace) + (((":") + (((_defClassName) + ("=@"))))))))));
            _privObject = new ManagementObject(_strPath);
            _privSystemProps = new _ManagementSystemProperties(_privObject);
        }
        public Wmisetting(ManagementPath _thePath) {
            _privObject = new ManagementObject(_thePath);
            _privSystemProps = new _ManagementSystemProperties(_privObject);
        }
        
        public String _defServer {
            get {
                return "";
            }
        }
        public String _defNamespace {
            get {
                return "Root\\Cimv2";
            }
        }
        public String _defClassName {
            get {
                return "Win32_Wmisetting";
            }
        }
        public _ManagementSystemProperties _SystemProps {
            get {
                return _privSystemProps;
            }
        }
        public ManagementObject _Object {
            get {
                return _privObject;
            }
        }
        public String ASPScriptDefaultNamespace {
            get {
                return (String)(_privObject["ASPScriptDefaultNamespace"]);
            }
            set {
                _privObject["ASPScriptDefaultNamespace"] = value;
                _privObject.Put();
            }
        }
        public Boolean ASPScriptEnabled {
            get {
                return (Boolean)(_privObject["ASPScriptEnabled"]);
            }
            set {
                _privObject["ASPScriptEnabled"] = value;
                _privObject.Put();
            }
        }
        public String AutorecoverMofs {
            get {
                return (String)(_privObject["AutorecoverMofs"]);
            }
            set {
                _privObject["AutorecoverMofs"] = value;
                _privObject.Put();
            }
        }
        public UInt32 AutoStartWin9X {
            get {
                return (UInt32)(_privObject["AutoStartWin9X"]);
            }
            set {
                _privObject["AutoStartWin9X"] = value;
                _privObject.Put();
            }
        }
        public UInt32 BackupInterval {
            get {
                return (UInt32)(_privObject["BackupInterval"]);
            }
            set {
                _privObject["BackupInterval"] = value;
                _privObject.Put();
            }
        }
        public DateTime BackupLastTime {
            get {
                return (DateTime)(_privObject["BackupLastTime"]);
            }
            set {
                _privObject["BackupLastTime"] = value;
                _privObject.Put();
            }
        }
        public String BuildVersion {
            get {
                return (String)(_privObject["BuildVersion"]);
            }
            set {
                _privObject["BuildVersion"] = value;
                _privObject.Put();
            }
        }
        public String Caption {
            get {
                return (String)(_privObject["Caption"]);
            }
            set {
                _privObject["Caption"] = value;
                _privObject.Put();
            }
        }
        public String DatabaseDirectory {
            get {
                return (String)(_privObject["DatabaseDirectory"]);
            }
            set {
                _privObject["DatabaseDirectory"] = value;
                _privObject.Put();
            }
        }
        public UInt32 DatabaseMaxSize {
            get {
                return (UInt32)(_privObject["DatabaseMaxSize"]);
            }
            set {
                _privObject["DatabaseMaxSize"] = value;
                _privObject.Put();
            }
        }
        public String Description {
            get {
                return (String)(_privObject["Description"]);
            }
            set {
                _privObject["Description"] = value;
                _privObject.Put();
            }
        }
        public Boolean EnableAnonWin9xConnections {
            get {
                return (Boolean)(_privObject["EnableAnonWin9xConnections"]);
            }
            set {
                _privObject["EnableAnonWin9xConnections"] = value;
                _privObject.Put();
            }
        }
        public Boolean EnableEvents {
            get {
                return (Boolean)(_privObject["EnableEvents"]);
            }
            set {
                _privObject["EnableEvents"] = value;
                _privObject.Put();
            }
        }
        public Boolean EnableStartupHeapPreallocation {
            get {
                return (Boolean)(_privObject["EnableStartupHeapPreallocation"]);
            }
            set {
                _privObject["EnableStartupHeapPreallocation"] = value;
                _privObject.Put();
            }
        }
        public UInt32 HighThresholdOnClientObjects {
            get {
                return (UInt32)(_privObject["HighThresholdOnClientObjects"]);
            }
            set {
                _privObject["HighThresholdOnClientObjects"] = value;
                _privObject.Put();
            }
        }
        public UInt32 HighThresholdOnEvents {
            get {
                return (UInt32)(_privObject["HighThresholdOnEvents"]);
            }
            set {
                _privObject["HighThresholdOnEvents"] = value;
                _privObject.Put();
            }
        }
        public String InstallationDirectory {
            get {
                return (String)(_privObject["InstallationDirectory"]);
            }
            set {
                _privObject["InstallationDirectory"] = value;
                _privObject.Put();
            }
        }
        public UInt32 LastStartupHeapPreallocation {
            get {
                return (UInt32)(_privObject["LastStartupHeapPreallocation"]);
            }
            set {
                _privObject["LastStartupHeapPreallocation"] = value;
                _privObject.Put();
            }
        }
        public String LoggingDirectory {
            get {
                return (String)(_privObject["LoggingDirectory"]);
            }
            set {
                _privObject["LoggingDirectory"] = value;
                _privObject.Put();
            }
        }
        public UInt32 LoggingLevel {
            get {
                return (UInt32)(_privObject["LoggingLevel"]);
            }
            set {
                _privObject["LoggingLevel"] = value;
                _privObject.Put();
            }
        }
        public UInt32 LowThresholdOnClientObjects {
            get {
                return (UInt32)(_privObject["LowThresholdOnClientObjects"]);
            }
            set {
                _privObject["LowThresholdOnClientObjects"] = value;
                _privObject.Put();
            }
        }
        public UInt32 LowThresholdOnEvents {
            get {
                return (UInt32)(_privObject["LowThresholdOnEvents"]);
            }
            set {
                _privObject["LowThresholdOnEvents"] = value;
                _privObject.Put();
            }
        }
        public UInt32 MaxLogFileSize {
            get {
                return (UInt32)(_privObject["MaxLogFileSize"]);
            }
            set {
                _privObject["MaxLogFileSize"] = value;
                _privObject.Put();
            }
        }
        public UInt32 MaxWaitOnClientObjects {
            get {
                return (UInt32)(_privObject["MaxWaitOnClientObjects"]);
            }
            set {
                _privObject["MaxWaitOnClientObjects"] = value;
                _privObject.Put();
            }
        }
        public UInt32 MaxWaitOnEvents {
            get {
                return (UInt32)(_privObject["MaxWaitOnEvents"]);
            }
            set {
                _privObject["MaxWaitOnEvents"] = value;
                _privObject.Put();
            }
        }
        public String MofSelfInstallDirectory {
            get {
                return (String)(_privObject["MofSelfInstallDirectory"]);
            }
            set {
                _privObject["MofSelfInstallDirectory"] = value;
                _privObject.Put();
            }
        }
        public String SettingID {
            get {
                return (String)(_privObject["SettingID"]);
            }
            set {
                _privObject["SettingID"] = value;
                _privObject.Put();
            }
        }
        
        
        public class _ManagementSystemProperties {
            private ManagementObject _privObject;
            
            public _ManagementSystemProperties(ManagementObject ManagedObject) {
                _privObject = ManagedObject;
            }
            
            public Int32 Genus {
                get {
                    return (Int32)(_privObject["__GENUS"]);
                }
            }
            public String Class {
                get {
                    return (String)(_privObject["__CLASS"]);
                }
            }
            public String Superclass {
                get {
                    return (String)(_privObject["__SUPERCLASS"]);
                }
            }
            public String Dynasty {
                get {
                    return (String)(_privObject["__DYNASTY"]);
                }
            }
            public String Relpath {
                get {
                    return (String)(_privObject["__RELPATH"]);
                }
            }
            public Int32 Property_Count {
                get {
                    return (Int32)(_privObject["__PROPERTY_COUNT"]);
                }
            }
            public String Derivation {
                get {
                    return (String)(_privObject["__DERIVATION"]);
                }
            }
            public String Server {
                get {
                    return (String)(_privObject["__SERVER"]);
                }
            }
            public String Namespace {
                get {
                    return (String)(_privObject["__NAMESPACE"]);
                }
            }
            public String Path {
                get {
                    return (String)(_privObject["__PATH"]);
                }
            }
            
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\invokemethodasync\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\iis\iisvroot.cs ===
namespace IISVRoot
{
   using System;
   using System.IO;	
   using System.Management;

   /// <summary>
    /// Creates and Deletes IIS 6.0 Virtual Roots
    /// </summary>
    public class IISVirtualRoot
    {
   	public static void Main(string[] args)
   	{
		string strerror = "";		
		Create("W3SVC/1/ROOT/", "c:/NewDir/", "NewDir", out strerror);
		Console.WriteLine(strerror);
#if DELETE
                if (strerror.Length == 0)
                {
 			Delete("W3SVC/1/ROOT/", "c:/NewDir/", "NewDir", out strerror); 
			Console.WriteLine(strerror);                 
                }
#endif
   	}
        /// <summary>
        /// Creates an IIS 6.0 Virtual Root
        /// </summary>
        /// <param name="RootWeb"></param>
        /// <param name="PhysicalDirectory"> </param>
        /// <param name="VirtualDirectory"> </param>
        /// <param name="Error"> </param>
        static public void Create(string RootWeb, string PhysicalDirectory, string VirtualDirectory, out string Error)
        {
            try
            {
			// Create a new instance of IIS_WebVirtualDirSetting and set the appropriate properties
  			    ManagementClass vdirSettingClass = new ManagementClass("//jnoss3/root/MicrosoftIISv2:IIs_WebVirtualDirSetting");
			    ManagementObject vdirSetting = vdirSettingClass.CreateInstance ();
			    vdirSetting["Name"] = RootWeb + VirtualDirectory;
			    vdirSetting["Path"] = PhysicalDirectory;
			    vdirSetting["AppFriendlyName"]=VirtualDirectory;
			    vdirSetting["AppRoot"] = ("/LM/" + RootWeb + VirtualDirectory);
			    vdirSetting.Put();

                // Call the AppCreate2 method on the corresponding instance of IIS_WebVirtualDir
                ManagementObject vdir = new ManagementObject("//jnoss3/root/MicrosoftIISv2:IIs_WebVirtualDir.Name='" + RootWeb + VirtualDirectory + "'");
                object[] args = { 2 };
                vdir.InvokeMethod("AppCreate2", args);
                Error = "";
            }
            catch(Exception e)
            {
                Error = e.ToString();
            }
        }

        /// <summary>
        /// Deletes an IIS 6.0 Virtual Root
        /// </summary>
        /// <param name="WebRoot"> </param>
        /// <param name="PhysicalDirectory"> </param>
        /// <param name="VirtualDirectory"> </param>
        /// <param name="Error"> </param>
 #if DELETE
        static public void Delete(string RootWeb, string PhysicalDirectory, string VirtualDirectory, out string Error)
        {
            try
            {
                // delete IIS VRoot
                ManagementObject vdir = new ManagementObject("root/MicrosoftIISv2:IIs_WebVirtualDir='" +  RootWeb + VirtualDirectory + "'");
                object[] args = { true };
                vdir.InvokeMethod("AppDelete", args);
                vdir.Delete();
                // delete physical directory
                if (Directory.Exists(PhysicalDirectory))
                {
 	            Directory.Delete(PhysicalDirectory, true);
                }
                Error = "";
            }
            catch(Exception e)
            {
                Error = e.ToString();   
            }
        }
#endif
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\exception\class1.cs ===
namespace Exception
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		try {
			ManagementClass c = new ManagementClass ("nosuchclass000");
			Console.WriteLine ("Class name is {0}", c["__CLASS"]);
		} catch (ManagementException e) {
			Console.WriteLine ("Call returned {0:x} - {1}", (UInt32)e.ErrorCode, e.Message);
		}
        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\nspath\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\nullcontext\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\pathtest\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\noauth\assemblyinfo.cs ===
using System;
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]

[assembly:CLSCompliant(true)]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\invokemethod\class1.cs ===
namespace InvokeMethod
{
using System;
using System.Management;
using System.Collections;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		ManagementClass processClass = new ManagementClass ("Win32_Process");

		// 1. Invocation using parameter instances
		ManagementBaseObject inParams = processClass.GetMethodParameters ("Create");
		inParams["CommandLine"] = "calc.exe";
		ManagementBaseObject outParams = processClass.InvokeMethod ("Create", inParams, null);
		Console.WriteLine ("Creation of calculator process returned: " + outParams["returnValue"]);
		Console.WriteLine ("Process id: " + outParams["processId"]);

		// 2. Invocation using args array
		object[] methodArgs = { "notepad.exe", null, null, 0 };
		object result = processClass.InvokeMethod ("Create", methodArgs);
		Console.WriteLine ("Creation of process returned: " + result);
		Console.WriteLine ("Process id: " + methodArgs[3]);
        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\priv2\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\invokemethodasync\class1.cs ===
namespace InvokeMethodAsync
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
        ManagementClass processClass = new ManagementClass("Win32_Process");

		// Create a watcher and completion handler
		ManagementOperationWatcher watcher = new ManagementOperationWatcher();
		ObjectReadyHandler objHandler = new ObjectReadyHandler();
            watcher.ObjectReady += new ObjectReadyEventHandler(objHandler.NewObject);

		// Invoke using parameter instances
		ManagementBaseObject inParams = processClass.GetMethodParameters("Create");
		inParams.Properties["CommandLine"].Value = "calc.exe";
		processClass.InvokeMethod(watcher, "Create", inParams, null);
			
		while(!objHandler.IsComplete)				//Infinite loop here
		{
			System.Threading.Thread.Sleep(1000);
		}
		objHandler.Reset(); 

		ManagementBaseObject o = objHandler.ReturnObject;
		Console.WriteLine(o.GetText(TextFormat.MOF));			
		Console.WriteLine ("Creation of calculator process returned: " + o["returnValue"]);
		Console.WriteLine ("Process id: " + o["processId"]);

		return 0;
    }

	public class ObjectReadyHandler
	{
		private bool m_bIsComplete = false;
        ManagementBaseObject m_returnObj;

		public void NewObject(object sender, ObjectReadyEventArgs e)
		{
			try
			{
				Console.WriteLine("New Object arrived!");
				m_returnObj = e.NewObject;
				m_bIsComplete = true;
			}
			catch (Exception ex)
			{
				Console.WriteLine("e.NewObject exception in ObjectHandler class - ");
				Console.Write(ex.Message + ex.StackTrace);
			}
		}

		public ManagementBaseObject ReturnObject
		{
			get {return m_returnObj;}
		}

		public bool IsComplete 
		{
			get{return m_bIsComplete;}
		}
		
		public void Reset()
		{
			m_bIsComplete = false;
		}
	}
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\privilegetest\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\nspath\class1.cs ===
namespace nspath
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		ManagementPath path = new ManagementPath();
		path.NamespacePath = "root/cimv2";		// throw exception here
        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\propertycopyto\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\nullcontext\class1.cs ===
namespace nullcontext
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
        ConnectionOptions con = new ConnectionOptions( );
		con.Locale = null;
		con.Username = null;
		con.Password = null;
		con.Authority = null;
		con.Impersonation  = ImpersonationLevel.Impersonate;
		con.Authentication = AuthenticationLevel.Connect; 
		con.EnablePrivileges = false;
		Console.WriteLine(con.Context); 
		con.Context = null;
        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\propertyqualifiersets\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\noauth\class1.cs ===
namespace NoAuth
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		string mylocale="ms_409";

		try 
		{
			// Setting the ManagementObject with the ConnectionOptions
			ConnectionOptions con = new ConnectionOptions(
						mylocale,
						".\\Administrator",
						"",
						null,
						ImpersonationLevel.Impersonate,
						AuthenticationLevel.None,
						false,
						null);

			ManagementPath mypath = new ManagementPath("Win32_LogicalDisk");
			ManagementScope myscope = new ManagementScope("\\\\w23-wmichssp17\\root\\cimv2",con);
			ManagementClass pobj = new ManagementClass(myscope,mypath,null);
			pobj.Get();
			Console.WriteLine(pobj.Scope.Options.Authentication); 
			Console.WriteLine(pobj["__PATH"]); 
	    }
		catch (ManagementException e)
	    {	
			Console.WriteLine("Access is Denied and cannot open class. " + e.Message); 
		}
		catch (Exception e)
		{
			Console.WriteLine(e.Message + e.StackTrace);
		}
        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\priv2\class1.cs ===
namespace priv2
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
       		string mylocale="ms_409";
			int count = 0;
		
			// Setting the ManagementObject with the ConnectionOptions
			ConnectionOptions con = new ConnectionOptions(mylocale,null,null,null,ImpersonationLevel.Impersonate,AuthenticationLevel.Connect,
				false,null);
			ManagementPath mypath = new ManagementPath("Win32_LogicalDisk='c:'");
			ManagementScope myscope = new ManagementScope("\\\\.\\root\\cimv2",con);
			// Query for different folders seems to wait for a while.
			ObjectQuery myquery = new ObjectQuery("WQL","Select * from Win32_NtLogevent Where logfile='Security'");
			ManagementObjectSearcher pobj = new ManagementObjectSearcher(myscope,myquery);
			pobj.Options.ReturnImmediately = true;
			pobj.Options.Rewindable = false;
			ManagementObjectCollection SecurityLogCollection = pobj.Get();
			foreach(ManagementObject SecurityLog in SecurityLogCollection)
			{
				count++;
				Console.WriteLine(SecurityLog["Logfile"] + " [" + count + "]");
			}
			

        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\queryinstances\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\pathtest\class1.cs ===
namespace PathTest
{
using System;
using System.Collections;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		ManagementPath path = new ManagementPath ("\\\\products1\\root\\cimv2:Win32_Something.A=10,B='haha'");
		Console.WriteLine (path.ToString());
		Console.WriteLine ("Path[" + path.Path + "]");
		Console.WriteLine ("Server[" + path.Server + "]");
		Console.WriteLine ("ClassName[" + path.ClassName + "]");
		Console.WriteLine ("RelativePath[" + path.RelativePath + "]");
		Console.WriteLine ("NamespacePath[" + path.NamespacePath + "]");
		
		ManagementPath path2 = new ManagementPath();
		path2.ClassName = "Fred";
		Console.WriteLine ("Path[" + path2.Path + "]");
		path2.SetAsSingletion ();
		Console.WriteLine ("Path[" + path2.Path + "]");
		
		path2.SetAsClass ();
		Console.WriteLine ("Path[" + path2.Path + "]");

        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\scopechange\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\privilegetest\class1.cs ===
namespace PrivilegeTest
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		ManagementObjectSearcher s = new ManagementObjectSearcher ("root/cimv2", 
			"select Message from Win32_NTLogEvent where LogFile='Security'");

		if ((null != args) && (0 < args.Length))
		{ 
			if ("p" == args[0])
				s.Scope.Options.EnablePrivileges = true;
		}

		s.Options.Rewindable = false;
		s.Options.ReturnImmediately = true;
		
		try {
			foreach (ManagementBaseObject o in s.Get())
				Console.WriteLine (o["Message"]);
		} catch (ManagementException e) {
			Console.WriteLine ("Call returned {0:x} - {1}", (UInt32)e.ErrorCode, e.Message);
		}

        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\propertycopyto\class1.cs ===
namespace PropertyCopyTo
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		ManagementObject disk = new ManagementObject("Win32_logicalDisk='C:'");
		Property[] properties = new Property [100];

		System.Management.PropertyCollection c = disk.Properties;
		c.CopyTo (properties, 0);
		
		for (int i = 0; i < properties.Length; i++)
			if (null != properties[i])
				Console.WriteLine (properties[i].Name + " " + properties[i].Type);

        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\setvolumename\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\propertyqualifiersets\class1.cs ===
namespace Project1
{
using System;
using System.Management;
using System.Collections;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
        //
        // TODO: Add code to start application here
        //
   		ManagementObject o = new ManagementObject("Win32_LogicalDisk=\"C:\"");
		Console.WriteLine("Object path is : {0}", o["__PATH"]);
		PropertySet s = o.Properties;
		Console.WriteLine("Object has {0} properties", s.Count);
		Console.WriteLine("Key property value is : {0}", s["DeviceID"].Value);

		foreach (Property p in s)
			Console.WriteLine("Property {0} = {1}", p.Name, p.Type);

		foreach (Qualifier q in o.Qualifiers)
			Console.WriteLine("Qualifier {0} = {1}", q.Name, q.Value);

		o.Qualifiers.Add("myQual", "myVal");
		o.Qualifiers["myQual"].Value = "myNewVal";

		Console.WriteLine("Qualifier : {0} = {1}", o.Qualifiers["myQual"].Name, o.Qualifiers["myQual"].Value);

		return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\stopevents\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\queryinstances\queryinstances.cs ===
namespace QueryInstances
{
using System;
using System.Management;

/// <summary>
///    ManagementObjectSearcher Example 2 : query for environment vars for certain user
/// </summary>
public class QueryInstances
{
    public QueryInstances()
    {
    }

    public static int Main(string[] args)
    {
		ManagementObjectSearcher s;
		SelectQuery q;

		//Create a query for system environment variables only
		q = new SelectQuery("Win32_Environment", "UserName=\"<SYSTEM>\"");

		//Initialize a searcher with this query
		s = new ManagementObjectSearcher(q);

		//Get the resulting collection and loop through it
		foreach (ManagementBaseObject o in s.Get())
			Console.WriteLine("System environment variable {0} = {1}", o["Name"], o["VariableValue"]);

		return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\sysprop\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\test1\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\scopechange\class1.cs ===
namespace ScopeChange
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		// Simple example of how the ManagementScope object deals with
		// changes to its properties
		ManagementClass sysClass = new ManagementClass ("root/cimv2:__SystemClass");
		Console.WriteLine (sysClass["__PATH"]);

		sysClass.Scope.Path.NamespacePath = "root/default";
		Console.WriteLine (sysClass["__PATH"]);

		sysClass.Scope.Options.Impersonation = System.Management.ImpersonationLevel.Identify;
		Console.WriteLine (sysClass["__PATH"]);

		return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\timeout\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\setvolumename\class1.cs ===
namespace SetVolumeName
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		ManagementObject disk = new ManagementObject ("Win32_LogicalDisk=\"C:\"");
		disk["VolumeName"] = "Stimpy";
		ManagementPath path = disk.Put ();
		Console.WriteLine (path.Path);
        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\traverserelations\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\sysprop\class1.cs ===
namespace Sysprop
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
       try
		{
			// Create a class with a NULL key and five instances
			// Create class
			ManagementClass mClass = new ManagementClass("root/default","",null);
 			mClass.SystemProperties["__Class"].Value = "test";
			mClass.Properties.Add("foo",CIMType.Uint16,false);	 // Create a NULL
			mClass.Properties["foo"].Qualifiers.Add("key",true); // key
			mClass.Put();

			ManagementObject mObj = mClass.CreateInstance();
			mObj["foo"] = 10;
			mObj.Put();	

			ManagementObject m = new ManagementObject("root/cimv2:Win32_process");
			Console.WriteLine("RELPATH is " + m["__RELPATH"]);
			Console.WriteLine("PATH is " + m["__PATH"]); // nothing displayed
			Console.WriteLine("PATH is " + m.Path.ToString());		// InvalidCastException

			// Attempt to display info from newly created ManagementObject
			Console.WriteLine("RELPATH is " + mObj["__RELPATH"]);
			Console.WriteLine("PATH is " + mObj["__PATH"]); // nothing displayed
			Console.WriteLine("PATH is " + mObj.Path.Path);		// InvalidCastException

			// Attempt to display info from newly created ManagementClass 
			//Console.WriteLine("RELPATH is " + mClass["__RELPATH"]);
			//Console.WriteLine("PATH is " + mClass.Path);	// compile error: lacks get accessor
			Console.Read();
			mClass.Delete();
			return 0;
		}
		catch (Exception e)
		{
			Console.WriteLine("Test : " + e.GetType().ToString());
			Console.WriteLine(e.Message + e.StackTrace);
			return 0 ;
		}
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\timeout\class1.cs ===
namespace timeout
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		try
		{
			// Create a timer event instance
			ManagementClass timerClass = new ManagementClass("root/default",
				"__IntervalTimerInstruction",
				null);
			ManagementObject timerObj = timerClass.CreateInstance();
			timerObj["IntervalBetweenEvents"] = 5000;	//fire every ten seconds
			timerObj["TimerID"] = "Timer612";		
			timerObj.Put(); 

			// Create an EventWatcherOptions
            EventWatcherOptions options = new EventWatcherOptions();
			options.Timeout = new TimeSpan(0,0,0,2,0);	// time out in 2 secs
			options.BlockSize = 2;
            
			// Create an event query
			WQLEventQuery query = new WQLEventQuery("__TimerEvent", 
													"TimerID='Timer612'");

			// Create an event watcher and subscribe the events that matches the event query
			ManagementEventWatcher watcher = new ManagementEventWatcher(
				new ManagementScope("root/default"),
				query,
				options);

            // Block until next event arrives or throw a ManagementException:TimedOut
			ManagementBaseObject e = watcher.WaitForNextEvent(); 
			
			// Assertion: Event was received.
            Console.WriteLine("Unable to specify Timeout for an event when calling ManagementEventWatcher.WaitForNextEvent().");
			return 1;
		}
		catch (ManagementException e)
		{
			Console.WriteLine("Error Message is " + e.Message);
			Console.WriteLine("Error Code is " + e.ErrorCode);
            Console.WriteLine("Status.Timedout is " + ManagementStatus.Timedout);
			if (ManagementStatus.Timedout == e.ErrorCode)
			{
				// Assertion: Event was not received within time out period
				// Clean up -
				ManagementObject timerObj = new ManagementObject("root/default:__IntervalTimerInstruction.TimerID='Timer612'");
				timerObj.Delete();
				Console.WriteLine("Test6.1.2: Able to specify Timeout for an event when calling ManagementEventWatcher.WaitForNextEvent().");
				return 0;
			}
			else
			{
				Console.WriteLine("Test6.1.2: Unable to specify Timeout for an event when calling ManagementEventWatcher.WaitForNextEvent().");
				return 1;
			}
		}
		catch (Exception e)
		{
			Console.WriteLine("Test6.1.2: " + e.GetType());
			Console.WriteLine(e.Message + e.StackTrace);
			return 1;
		}
	}
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\stopevents\class1.cs ===
namespace stopevents
{
using System;
using System.Management;


/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
        // Create a timer event instance
			ManagementClass timerClass = new ManagementClass("root/default",
				"__IntervalTimerInstruction",
				null);
			ManagementObject timerObj = timerClass.CreateInstance();
			timerObj["IntervalBetweenEvents"] = 500;	//fire every half a second
			timerObj["TimerID"] = "Timer62";		
			timerObj.Put();

			// Create an EventWatcherOptions
          		  EventWatcherOptions options = new EventWatcherOptions();
			options.Timeout = new TimeSpan(0,0,0,5,0);	// timeout in 5 secs
			options.BlockSize = 2;
            
			// Create an event query
			WQLEventQuery query = new WQLEventQuery("__TimerEvent", "TimerID='Timer62'");

			// Create an event watcher and subscribe the events that matches the event query
			ManagementEventWatcher watcher = new ManagementEventWatcher(
				new ManagementScope("root/default"),
				query,
				options);

			// Create a Stopped handler
			EventStoppedHandler stopHandlerObj = new EventStoppedHandler();
			watcher.Stopped += new StoppedEventHandler(stopHandlerObj.Stopped);

          		// Block until next event arrives or throw a ManagementException:TimedOut
			ManagementBaseObject e = watcher.WaitForNextEvent(); 
			
			// Assertion: Event was received.
			// Cancel subscription
			watcher.Stop();
			while (!stopHandlerObj.IsStopped)
			{
				System.Threading.Thread.Sleep(1000);
			}
		return 0;
    }
}

public class EventStoppedHandler
{
	private bool isStopped = false;

	internal void Stopped (object sender, StoppedEventArgs args)
	{
		isStopped = true;
	}

	public bool IsStopped { get { return isStopped; } }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\test1\class1.cs ===
namespace Test1
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		ManagementObject disk = new ManagementObject ("win32_logicaldisk");
		Console.WriteLine ("Class name is " + disk.SystemProperties ["__CLASS"]);

		ManagementObject diskC = new ManagementObject ("win32_logicaldisk='C:'");
		Console.WriteLine ("Freespace is " + diskC["FreeSpace"]);

		ManagementObject process0 = new ManagementObject ("Win32_Process='0'");
		ManagementOperationWatcher watcher = new ManagementOperationWatcher ();

		CompletionHandler completionHandler = new CompletionHandler ();
		watcher.Completed += new CompletedEventHandler (completionHandler.Done);

		process0.Get (watcher);

		while (!completionHandler.IsComplete) {
			System.Threading.Thread.Sleep (1000);
		}

		Console.WriteLine (process0["Name"]);

        return 0;
    }
}

public class CompletionHandler {
	private bool m_bIsComplete = false;

	public void Done (object sender, CompletedEventArgs e) {
		if (null != e.Context)
			Console.WriteLine ("Context is " + e.Context.ToString ());

		Console.WriteLine ("Operation completed with status " + e.Status + " on thread " 
							+ System.Threading.Thread.CurrentThread.GetHashCode ());
		m_bIsComplete = true;
	}

	public bool IsComplete {
		get { return m_bIsComplete; }
	}

	public void Reset () { m_bIsComplete = false; }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\traverserelations\traverserelations.cs ===
namespace TraverseRelations
{
using System;
using System.Management;
using System.Threading;

/// <summary>
///    ManagementObject Example 2 : Traverse associations & invoke methods
/// </summary>
public class TraverseRelations
{
    public TraverseRelations()
    {
    }

    public static int Main(string[] args)
    {
		ManagementObject myService;
		ManagementObjectCollection relatedServices;

		//Get the W3SVC service object
		myService = new ManagementObject("Win32_Service=\"W3SVC\"");

		//Find all services that it depends on
		relatedServices = myService.GetRelated("Win32_Service");
		
		//Loop through and start all these services
		foreach (ManagementObject service in relatedServices)
		{
			Console.WriteLine("This service depends on {0}, we'll start it...", service["Name"]);
			try {
				service.InvokeMethod("StartService", null);
			} catch (ManagementException) {
				Console.WriteLine("Couldn't start the service !!");
			}
			
			//Poll for the service having started (note: we could use event notifications here...)
			while ((string)service["State"] != "Running")
			{
				Console.WriteLine(service["State"]);
				Thread.Sleep(1000);
				service.Get(); //refresh the data in this object
			}

			Console.WriteLine("Service is {0} !!!", service["State"]);
		}

		Console.ReadLine();

		return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\useridnullref\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\wmi\wmiclient\test\useridnullref\class1.cs ===
namespace UserIDNullRef
{
    using System;
	using System.Management;

    /// <summary>
    ///    Summary description for Class1.
    /// </summary>
    public class Class1
    {
        public Class1()
        {
            //
            // TODO: Add Constructor Logic here
            //
        }

        public static int Main(string[] args)
        {
		try 
		{
			ManagementClass userid = new ManagementClass ("root/default:userid");
			string[] privilegesArray = null;
			string impersonationLevel = null;
			String domain = null;
			String user = null;
			bool[] enableArray = null;
			object [] mArgs = 
			{
				domain,
				user,
				impersonationLevel,
				privilegesArray,
				enableArray,
			};

			userid.InvokeMethod ("GetUserID", mArgs);
			Console.WriteLine ("User is " + mArgs[0] + "\\" + mArgs[1]);
			Console.WriteLine ("Impersonation level is: " + mArgs[2]);
			

			Console.WriteLine ("Privileges:");

			foreach (String privilege in (string[])mArgs[3])
			{
				Console.WriteLine (privilege);
			}

			foreach (bool en in (bool[])mArgs[4])
			{
				Console.WriteLine (en);
			}
			
		    } //end of try
		catch (ManagementException e)
			    {	
				Console.WriteLine("ManagementExecption" + e.Message);
			}
		
		catch (Exception e)
		{
			Console.WriteLine("Exception" + e.Message); 
		}

            return 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\icepick.inc ===
#
# Instrument with ICECAP on free builds (if we have a valid pointer to
# the ICEPICK tool).
#

!IF "$(ICEPICK_CMD)" != ""
!IF $(FREEBUILD)
POST_BUILD_CMD=$(ICEPICK_CMD) $@ $(ICEPICK_OPTIONS) -OUTPUT:.\$(@B).xyz && copy $(@B).xyz $@ && copy $(@B).pdb $(@R).pdb && del $(@B).xyz $(@B).pdb
!ENDIF
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\exe\main.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    main.c

Abstract:

    This is the main routine for the Internet Services suite.

Author:

    David Treadwell (davidtr)   7-27-93

Revision History:
    Murali Krishnan ( Muralik)  16-Nov-1994  Added Gopher service
    Murali Krishnan ( Muralik)  3-July-1995  Removed non-internet info + trims
    Sophia Chung     (sophiac)  09-Oct-1995  Splitted internet services into
                                             access and info services
    Murali Krishnan ( Muralik)  20-Feb-1996  Enabled to run on NT Workstation

--*/

//
// INCLUDES
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>             // Service control APIs
#include <rpc.h>
#include <stdlib.h>
#include <inetsvcs.h>
#include <iis64.h>

#include "inetimsg.h"
#include "iisadmin.hxx"
#include <pwsdata.hxx>
#include <objbase.h>

#define SERVICES_KEY \
    "System\\CurrentControlSet\\Services"

#define INETINFO_PARAM_KEY \
    "System\\CurrentControlSet\\Services\\InetInfo\\Parameters"

#define DISPATCH_ENTRIES_KEY    "DispatchEntries"

#define DLL_PATH_NAME_VALUE     "IISDllPath"


#define PRELOAD_DLLS_VALUE      "PreloadDlls"

//
// Modifications to this name should also be made in tsunami.hxx
//

#define INETA_W3ONLY_NO_AUTH            TEXT("W3OnlyNoAuth")

//
// Functions used to start/stop the RPC server
//

typedef   DWORD ( *PFN_INETINFO_START_RPC_SERVER)   ( VOID );
typedef   DWORD ( *PFN_INETINFO_STOP_RPC_SERVER)    ( VOID );

//
// Local function used by the above to load and invoke a service DLL.
//

VOID
InetinfoStartService (
    IN DWORD argc,
    IN LPSTR argv[]
    );

VOID
StartDispatchTable(
    VOID
    );

VOID
W95RegisterService(
    VOID
    );

BOOL
StartMessageThread(
    VOID
    );

LRESULT
CALLBACK
MessageProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

//
// Functions used to preload dlls into the inetinfo process
//

BOOL
LoadPreloadDlls(
    HMODULE * * ppPreloadDllHandles
    );

VOID
UnloadPreloadDlls(
    HMODULE * * ppPreloadDllHandles
    );


//
// Used if the services Dll or entry point can't be found
//

VOID
AbortService(
    LPSTR  ServiceName,
    DWORD   Error
    );

//
// Dispatch table for all services. Passed to NetServiceStartCtrlDispatcher.
//
// Add new service entries here and in the DLL name list.
// Also add an entry in the following table InetServiceDllTable
//

SERVICE_TABLE_ENTRY InetServiceDispatchTable[] = {
                        { "GopherSvc", InetinfoStartService  },
                        { "MSFtpSvc",  InetinfoStartService  },
                        { "W3Svc",     InetinfoStartService  },
                        { "IISADMIN",  InetinfoStartService  },
                        { NULL,              NULL  },
                        };

SERVICE_TABLE_ENTRY W3ServiceDispatchTable[] = {
                        { "W3Svc",     InetinfoStartService  },
                        { NULL,              NULL  },
                        };

//
// DLL names for all services.
//  (should correspond exactly with above InetServiceDispatchTable)
//

struct SERVICE_DLL_TABLE_ENTRY  {

    LPSTR               lpServiceName;
    LPSTR               lpDllName;
    CRITICAL_SECTION    csLoadLock;
} InetServiceDllTable[] = {
    { "GopherSvc",      "gopherd.dll" },
    { "MSFtpSvc",       "ftpsvc2.dll" },
    { "W3Svc",          "w3svc.dll" },
    { "IISADMIN",       "iisadmin.dll" },
    { NULL,             NULL }
};

//
// Global parameter data passed to each service.
//

TCPSVCS_GLOBAL_DATA InetinfoGlobalData;

#include <initguid.h>
DEFINE_GUID(IisExeGuid, 
0x784d8901, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#ifndef _NO_TRACING_
#include "pudebug.h"
DECLARE_DEBUG_PRINTS_OBJECT()
#endif

//
// A global variable that remembers that we'll refuse to start.
//

BOOL RefuseStartup = FALSE;
BOOL g_fRunAsExe = FALSE;
BOOL g_fWindows95 = FALSE;
BOOL g_fW3svcNoAuth = FALSE;
BOOL g_fOleInitialized = TRUE;

DWORD __cdecl
main(
    IN DWORD argc,
    IN LPSTR argv[]
    )

/*++

Routine Description:

    This is the main routine for the LANMan services.  It starts up the
    main thread that is going to handle the control requests from the
    service controller.

    It basically sets up the ControlDispatcher and, on return, exits
    from this main thread.  The call to NetServiceStartCtrlDispatcher
    does not return until all services have terminated, and this process
    can go away.

    The ControlDispatcher thread will start/stop/pause/continue any
    services.  If a service is to be started, it will create a thread
    and then call the main routine of that service.  The "main routine"
    for each service is actually an intermediate function implemented in
    this module that loads the DLL containing the server being started
    and calls its entry point.


Arguments:

    None.

Return Value:

    None.

--*/
{

    HMODULE  dllHandle = NULL;
    HINSTANCE  hRpcRef = NULL;
    HMODULE * pPreloadDllHandles = NULL;
    DWORD dwIndex;
    struct SERVICE_DLL_TABLE_ENTRY * pEntry;
    DWORD err = ERROR_SUCCESS;

    //
    // Initialize OLE
    //

#ifndef _NO_TRACING_
    HRESULT hr;

    CREATE_DEBUG_PRINT_OBJECT("Inetinfo.exe", IisExeGuid);
    CREATE_INITIALIZE_DEBUG();
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED );
#else
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED );
#endif
    if ( FAILED(hr)) {
        if ( hr != E_INVALIDARG ) {
            IIS_PRINTF((buff,"CoInitialize failed with %x\n",hr));
            g_fOleInitialized = FALSE;
        }
    }

    //
    // are we chicago?
    //

    {
        OSVERSIONINFO osInfo;
        osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        if ( GetVersionEx( &osInfo ) ) {
            g_fWindows95 = (osInfo.dwPlatformId != VER_PLATFORM_WIN32_NT);
        }
    }

    //
    // Initialize Global Data.
    //

    if ( !g_fWindows95 ) {

        //
        // Use the rpcref library, so that multiple services can
        // independently "start" the rpc server
        //

        hRpcRef = LoadLibrary("rpcref.dll");

        if ( hRpcRef != NULL )
        {
            InetinfoGlobalData.StartRpcServerListen =
                (PFN_INETINFO_START_RPC_SERVER)
                GetProcAddress(hRpcRef,"InetinfoStartRpcServerListen");

            InetinfoGlobalData.StopRpcServerListen =
                (PFN_INETINFO_STOP_RPC_SERVER)
                GetProcAddress(hRpcRef,"InetinfoStopRpcServerListen");
        }
        else
        {
            IIS_PRINTF((buff,
                       "Error %d loading rpcref.dll\n",
                       GetLastError() ));
#ifndef _NO_TRACING_
            DELETE_DEBUG_PRINT_OBJECT()
            DELETE_INITIALIZE_DEBUG()
#endif
            return GetLastError();
        }

    }

    //
    //  Initialize service entry locks
    //

    for ( dwIndex = 0 ; ; dwIndex++ )
    {
        pEntry = &( InetServiceDllTable[ dwIndex ] );
        if ( pEntry->lpServiceName == NULL )
        {
            break;
        }

        InitializeCriticalSection( &( pEntry->csLoadLock ) );
    }

    //
    //  Disable hard-error popups.
    //

    SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );


    //
    // Preload Dlls specified in the registry
    //

    if ( !LoadPreloadDlls( &pPreloadDllHandles ) )
    {
        IIS_PRINTF(( buff, "Error pre-loading DLLs\n" ));
    }


    if ( (argc > 2) && !_stricmp( argv[1], "-e" ))
    {
        PCHAR    pszName = argv[2];
        HANDLE   hAsExeEvent;
        HANDLE   hStartW3svc = NULL;
        PIISADMIN_SERVICE_DLL_EXEENTRY IisAdminExeEntry = NULL;
        PIISADMIN_SERVICE_DLL_EXEEXIT  IisAdminExeExit  = NULL;
        BOOL     IsIisAdmin = TRUE;

        //
        // Create the start w3svc event for win95.  This is used
        // to inform the 1st instance that w3 need to start the web
        // server.
        //

        if ( g_fWindows95 ) {

            hStartW3svc = CreateEvent( NULL,
                                       FALSE,
                                       FALSE,
                                       "inetinfo_start_w3svc");

            err = GetLastError();
            if ( hStartW3svc == NULL ) {
                IIS_PRINTF((buff,"Cannot create %s event. err %d\n",
                    "inetinfo_start_w3svc", err));
                goto Finished;
            }

            if ( err != ERROR_SUCCESS ) {
                IIS_PRINTF((buff,
                    "Error %d in CreateEvent of start w3svc\n", err));
            } else {

                //
                // Register outself as a fake service
                //

                W95RegisterService( );

                //
                // Start the thread that will contain the windows message loop
                //

                if ( !StartMessageThread( ) ) {
                    err = GetLastError();
                    CloseHandle(hStartW3svc);
                    goto Finished;
                }
            }
        }

        //
        //  Create a named event.  The common internet services code attempts
        //  to create a semaphore with the same name, if it fails then the
        //  service is being run as an exe
        //

        g_fRunAsExe = TRUE;

        hAsExeEvent = CreateEvent( NULL,
                                   FALSE,
                                   FALSE,
                                   IIS_AS_EXE_OBJECT_NAME);

        err = GetLastError();
        if ( hAsExeEvent == NULL ) {

            IIS_PRINTF((buff,"Cannot create %s event. err %d\n",
                IIS_AS_EXE_OBJECT_NAME, err));
            goto Finished;
        }

        if ( err != ERROR_SUCCESS ) {

            CloseHandle(hAsExeEvent);

            IIS_PRINTF((buff,
                "Error %d in CreateEvent[%s]\n",
                err, IIS_AS_EXE_OBJECT_NAME));

            if ( (_stricmp("W3Svc", pszName) == 0) && g_fWindows95 ) {

                //
                // someone's trying to start the w3svc.  Set the start w3svc
                // event.
                //

                IIS_PRINTF((buff,"Setting start w3svc event\n"));
                SetEvent(hStartW3svc);
                CloseHandle(hStartW3svc);
                err = 0;
            }
            goto Finished;
        }

        //
        // All services are dependent on IISADMIN
        // so if it's not IISADMIN or we are running win95, call it
        //

        if ( (_stricmp(IISADMIN_NAME, pszName) != 0) || g_fWindows95 ) {

            //
            // Not IISADMIN
            //

            IsIisAdmin = FALSE;

            dllHandle = LoadLibrary(IISADMIN_NAME);

            if ( dllHandle == NULL ) {

                err = GetLastError();

                IIS_PRINTF((buff,
                         "Inetinfo: Failed to load DLL %s: %ld\n",
                                  IISADMIN_NAME, err));
                goto Finished;
            }

            //
            // Get the address of the service's main entry point.  This
            // entry point has a well-known name.
            //

            IisAdminExeEntry = (PIISADMIN_SERVICE_DLL_EXEENTRY)GetProcAddress(
                                                        dllHandle,
                                                        IISADMIN_EXEENTRY_STRING
                                                        );

            if (IisAdminExeEntry == NULL ) {
                err = GetLastError();
                IIS_PRINTF((buff,
                        "Inetinfo: Can't find entry %s in DLL %s: %ld\n",
                        IISADMIN_EXEENTRY_STRING, IISADMIN_NAME, err));
                goto Finished;
            }

            IisAdminExeExit = (PIISADMIN_SERVICE_DLL_EXEEXIT)GetProcAddress(
                                                        dllHandle,
                                                        IISADMIN_EXEEXIT_STRING
                                                        );

            if (IisAdminExeExit == NULL ) {
                err = GetLastError();
                IIS_PRINTF((buff,
                    "Inetinfo: Can't find entry %s in DLL %s: %ld\n",
                     IISADMIN_EXEEXIT_STRING, IISADMIN_NAME, err);
                     );
                goto Finished;
            }

            if (!IisAdminExeEntry( TRUE, FALSE, TRUE)) {
                IIS_PRINTF((buff,"IISadmin init failed\n"));
                err = 1;
                goto Finished;
            }
        }

        //
        //  Offset argv so that the first entry points to the dll name to
        //  load
        //


        if (g_fWindows95) {
            BOOL bStartW3svc = FALSE;
            HANDLE hEvents[2];
            hEvents[0] = hAsExeEvent;
            hEvents[1] = hStartW3svc;

            if (_stricmp(IISADMIN_NAME, pszName) != 0) {
                bStartW3svc = TRUE;
            }
            while (TRUE) {
                if (bStartW3svc) {
                    PCHAR tmpArgv[1];

                    tmpArgv[0] = "W3Svc";
                    IIS_PRINTF((buff,"Starting W3svc\n"));
                    InetinfoStartService( 1, &tmpArgv[0] );
                    IIS_PRINTF((buff,"Exiting W3svc\n"));
                }

                err = MsgWaitForMultipleObjects(
                                    2,
                                    hEvents,
                                    FALSE,      // don't wait all
                                    INFINITE,
                                    0);         // windows event mask

                if ( err == (WAIT_OBJECT_0+1) ) {
                    bStartW3svc = TRUE;
                } else {
                    IIS_PRINTF((buff,"Exiting IISAdmin\n"));
                    break;
                }
            }
        }
        else {
            IIS_PRINTF((buff,"Starting %s\n", pszName));
            InetinfoStartService( 1, &argv[2] );
        }

        if (!IsIisAdmin) {
            IisAdminExeExit();
        }

        if ( hStartW3svc != NULL ) {
            CloseHandle( hStartW3svc );
        }
        CloseHandle( hAsExeEvent );

    } else {

        if ( !g_fWindows95 ) {
            StartDispatchTable( );
        } else {
            IIS_PRINTF((buff,"No arguments supplied. Exiting\n"));
        }
    }

Finished:

    //
    // Unload pre-loaded Dlls
    //

    UnloadPreloadDlls( &pPreloadDllHandles );

    //
    // Cleanup OLE
    //

    if ( g_fOleInitialized ) {
        CoUninitialize();
        g_fOleInitialized = FALSE;
    }

    //
    // Free the admin service dll
    // Note: this must happen after CoUninitialize or it causes
    // a crash on Win95
    //

    if (dllHandle != NULL) {
        FreeLibrary( dllHandle );
    }


    if ( hRpcRef != NULL ) {
        FreeLibrary( hRpcRef );
        hRpcRef = NULL;
    }

    //
    //  Terminate service entry locks
    //

    for ( dwIndex = 0 ; ; dwIndex++ )
    {
        pEntry = &( InetServiceDllTable[ dwIndex ] );
        if ( pEntry->lpServiceName == NULL )
        {
            break;
        }

        DeleteCriticalSection( &( pEntry->csLoadLock ) );
    }
    
    IIS_PRINTF((buff,"Exiting inetinfo.exe\n"));
#ifndef _NO_TRACING_
    DELETE_DEBUG_PRINT_OBJECT()
    DELETE_INITIALIZE_DEBUG()
#endif
    return err;

} // main



DWORD
FindEntryFromDispatchTable(
            IN LPSTR pszService
            )
{
    SERVICE_TABLE_ENTRY  * pService;

    for(pService = InetServiceDispatchTable;
        pService->lpServiceName != NULL;
        pService++) {

        if ( !lstrcmpi( pService->lpServiceName, pszService)) {
    
            return DIFF(pService - InetServiceDispatchTable);
        }
    }

    //
    // We have not found the entry. Set error and return
    //

    SetLastError( ERROR_INVALID_PARAMETER);
    return 0xFFFFFFFF;

} // FindEntryFromDispatchTable()

BOOL
GetDLLNameForDispatchEntryService(
    IN LPSTR                    pszService,
    IN OUT CHAR *               pszDllName,
    IN DWORD                    cbDllName
)
/*++

Routine Description:

    If the image name is not in the static dispatch table, then it might be
    in the registry under the value "IISDllName" under the key for the
    service.  This routine reads the registry for the setting (if existing).

    This code allows the exchange folks to install their service DLLs in a
    location other than "%systemroot%\inetsrv".  

Arguments:

    pszService - Service name
    pszDllName - Filled with image name
    cbDllName - Size of buffer pointed to by pszDllName

Return Value:

    TRUE if successful, else FALSE.

--*/
{
    HKEY hkey = NULL, hkeyService = NULL;
    DWORD err;
    DWORD valType;
    DWORD nBytes;
    BOOL ret = FALSE;
    
    err = RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 SERVICES_KEY,
                 0,
                 KEY_READ,
                 &hkeyService
                 );

    if (err != ERROR_SUCCESS) {

        IIS_PRINTF((buff, 
            "Inetinfo: Failed to open service key: %ld\n", err));

        goto Cleanup;
    }

    err = RegOpenKeyEx(
                 hkeyService,
                 pszService,
                 0,
                 KEY_READ,
                 &hkey
                 );

    if (err != ERROR_SUCCESS) {

        IIS_PRINTF((buff, 
            "Inetinfo: Failed to open service key for %s: %ld\n",
                pszService, err));

        goto Cleanup;
    }

    nBytes = cbDllName;

    err = RegQueryValueEx(
                hkey,
                DLL_PATH_NAME_VALUE,
                NULL,
                &valType,
                (LPBYTE)pszDllName,
                &nBytes);

    if ( err == ERROR_SUCCESS &&
         ( valType == REG_SZ || valType == REG_EXPAND_SZ ) )
    {
        IIS_PRINTF((buff,
            "Service Dll is %s", pszDllName));

        ret = TRUE;
    }

Cleanup:

    if (hkey != NULL) {
        RegCloseKey( hkey );
    }

    if (hkeyService != NULL) {
        RegCloseKey( hkeyService );
    }

    return ret;
}


VOID
InetinfoStartService (
    IN DWORD argc,
    IN LPSTR argv[]
    )

/*++

Routine Description:

    This routine loads the DLL that contains a service and calls its
    main routine.

Arguments:

    DllName - name of the DLL

    argc, argv - Passed through to the service

Return Value:

    None.

--*/

{
    HMODULE dllHandle;
    PINETSVCS_SERVICE_DLL_ENTRY serviceEntry;
    BOOL ok;
    DWORD Error;
    CHAR tmpDllName[MAX_PATH+1];
    LPSTR DllName;
    DWORD dwIndex;

    //
    // If we need to refuse to start services, do so.
    //

    if ( RefuseStartup ) {
        AbortService(argv[0], ERROR_INVALID_PARAMETER);
        return;
    }

    //
    // Find the Dll Name for requested service
    //

    dwIndex = FindEntryFromDispatchTable( argv[0] );
    if ( dwIndex == 0xFFFFFFFF ) {

        if ( GetDLLNameForDispatchEntryService( argv[0],
                                                tmpDllName,
                                                sizeof( tmpDllName ) ) ) {
            IIS_PRINTF((buff,
                        "Service %s has path set in registry.  Assuming %s\n",
                        argv[0],
                        tmpDllName));
            DllName = tmpDllName;
        }
        else if ( strlen(argv[0]) < (MAX_PATH-4) ) {
            strcpy(tmpDllName, argv[0]);
            strcat(tmpDllName, ".dll");

            IIS_PRINTF((buff,"Service %s not on primary list.  Assuming %s\n",
                argv[0], tmpDllName));
            DllName = tmpDllName;
        } else {
            Error = ERROR_INSUFFICIENT_BUFFER;
            IIS_PRINTF((buff,
                    "Inetinfo: Failed To Find Dll For %s : %ld\n",
                    argv[0], Error));
            AbortService( argv[0], Error);
            return;
        }
    }
    else
    {
        DllName = InetServiceDllTable[ dwIndex ].lpDllName;
    }

    //
    // Load the DLL that contains the service.
    //

    if ( dwIndex != 0xFFFFFFFF )
    {
        EnterCriticalSection( &( InetServiceDllTable[ dwIndex ].csLoadLock ) );
    }

    dllHandle = LoadLibraryEx( DllName, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );
    if ( dllHandle == NULL ) {
        Error = GetLastError();
        IIS_PRINTF((buff,
                 "Inetinfo: Failed to load DLL %s: %ld\n",
                 DllName, Error));
        AbortService(argv[0], Error);
        LeaveCriticalSection( &( InetServiceDllTable[ dwIndex ].csLoadLock ) );
        return;
    }

    //
    // Get the address of the service's main entry point.  This
    // entry point has a well-known name.
    //

    serviceEntry = (PINETSVCS_SERVICE_DLL_ENTRY)GetProcAddress(
                                                dllHandle,
                                                INETSVCS_ENTRY_POINT_STRING
                                                );

    if ( serviceEntry == NULL ) {
        Error = GetLastError();
        IIS_PRINTF((buff,
                 "Inetinfo: Can't find entry %s in DLL %s: %ld\n",
                 INETSVCS_ENTRY_POINT_STRING, DllName, Error));
        AbortService(argv[0], Error);
    } else {

        //
        // Call the service's main entry point.  This call doesn't return
        // until the service exits.
        //

        serviceEntry( argc, argv, &InetinfoGlobalData );

    }

    if ( dwIndex != 0xFFFFFFFF )
    {
        LeaveCriticalSection( &( InetServiceDllTable[ dwIndex ].csLoadLock ) );
    }

    //
    // wait for the control dispatcher routine to return.  This
    // works around a problem where simptcp was crashing because the
    // FreeLibrary() was happenning before the control routine returned.
    //

    Sleep( 500 );

    //
    // Unload the DLL.
    //

    ok = FreeLibrary( dllHandle );
    if ( !ok ) {
        IIS_PRINTF((buff,
                 "INETSVCS: Can't unload DLL %s: %ld\n",
                 DllName, GetLastError()));
    }
    
    return;
} // InetinfoStartService



VOID
DummyCtrlHandler(
    DWORD   Opcode
    )
/*++

Routine Description:

    This is a dummy control handler which is only used if we can't load
    a services DLL entry point.  Then we need this so we can send the
    status back to the service controller saying we are stopped, and why.

Arguments:

    OpCode - Ignored

Return Value:

    None.

--*/

{
    return;

} // DummyCtrlHandler


VOID
AbortService(
    LPSTR  ServiceName,
    DWORD  Error)
/*++

Routine Description:

    This is called if we can't load the entry point for a service.  It
    gets a handle so it can call SetServiceStatus saying we are stopped
    and why.

Arguments:

    ServiceName - the name of the service that couldn't be started
    Error - the reason it couldn't be started

Return Value:

    None.

--*/
{
    SERVICE_STATUS_HANDLE GenericServiceStatusHandle;
    SERVICE_STATUS GenericServiceStatus;

    if (!g_fRunAsExe) {
        GenericServiceStatus.dwServiceType        = SERVICE_WIN32;
        GenericServiceStatus.dwCurrentState       = SERVICE_STOPPED;
        GenericServiceStatus.dwControlsAccepted   = SERVICE_CONTROL_STOP;
        GenericServiceStatus.dwCheckPoint         = 0;
        GenericServiceStatus.dwWaitHint           = 0;
        GenericServiceStatus.dwWin32ExitCode      = Error;
        GenericServiceStatus.dwServiceSpecificExitCode = 0;

        GenericServiceStatusHandle = RegisterServiceCtrlHandler(
                    ServiceName,
                    DummyCtrlHandler);

        if (GenericServiceStatusHandle == (SERVICE_STATUS_HANDLE)0) {

            IIS_PRINTF((buff,
                     "[Inetinfo]RegisterServiceCtrlHandler[%s] failed %d\n",
                     ServiceName, GetLastError()));

        } else if (!SetServiceStatus (GenericServiceStatusHandle,
                    &GenericServiceStatus)) {

            IIS_PRINTF((buff,
                     "[Inetinfo]SetServiceStatus[%s] error %ld\n",
                     ServiceName, GetLastError()));
        }
    }

    return;
}



VOID
StartDispatchTable(
    VOID
    )
/*++

Routine Description:

    Returns the dispatch table to use.  It uses the default if
    the DispatchEntries value key does not exist

Arguments:

    None.

Return Value:

    Pointer to the dispatch table to use.

--*/
{
    LPSERVICE_TABLE_ENTRY dispatchTable = InetServiceDispatchTable;
    LPSERVICE_TABLE_ENTRY tableEntry = NULL;

    LPBYTE buffer;
    HKEY hKey = NULL;

    DWORD i;
    DWORD err;
    DWORD valType;
    DWORD nBytes = 0;
    DWORD nEntries = 0;
    PCHAR entry;
    BOOL  IsIisAdmin = TRUE;
    HMODULE  dllHandle;
    PIISADMIN_SERVICE_DLL_EXEENTRY IisAdminExeEntry = NULL;
    PIISADMIN_SERVICE_DLL_EXEEXIT  IisAdminExeExit  = NULL;
    DWORD   dwW3svcNoAuth;

    //
    // See if need to augment the dispatcher table
    //

    err = RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 INETINFO_PARAM_KEY,
                 0,
                 KEY_READ,
                 &hKey
                 );

    if ( err != ERROR_SUCCESS ) {
        hKey = NULL;
        goto start_dispatch;
    }

    //
    // See if mono service
    //

    nBytes = sizeof(dwW3svcNoAuth);
    if ( RegQueryValueEx(
                    hKey,
                    INETA_W3ONLY_NO_AUTH,
                    NULL,
                    &valType,
                    (LPBYTE)&dwW3svcNoAuth,
                    &nBytes
                    ) == ERROR_SUCCESS && valType == REG_DWORD ) {
        g_fW3svcNoAuth = !!dwW3svcNoAuth;
    }

    if ( g_fW3svcNoAuth ) {

        dllHandle = LoadLibrary(IISADMIN_NAME);

        if ( dllHandle == NULL ) {

            err = GetLastError();

            IIS_PRINTF((buff,
                     "Inetinfo: Failed to load DLL %s: %ld\n",
                              IISADMIN_NAME, err));
            return;
        }

        //
        // Get the address of the service's main entry point.  This
        // entry point has a well-known name.
        //

        IisAdminExeEntry = (PIISADMIN_SERVICE_DLL_EXEENTRY)GetProcAddress(
                                                    dllHandle,
                                                    IISADMIN_EXEENTRY_STRING
                                                    );

        if (IisAdminExeEntry == NULL ) {
            err = GetLastError();
            IIS_PRINTF((buff,
                    "Inetinfo: Can't find entry %s in DLL %s: %ld\n",
                    IISADMIN_EXEENTRY_STRING, IISADMIN_NAME, err));
            return;
        }

        IisAdminExeExit = (PIISADMIN_SERVICE_DLL_EXEEXIT)GetProcAddress(
                                                    dllHandle,
                                                    IISADMIN_EXEEXIT_STRING
                                                    );

        if (IisAdminExeExit == NULL ) {
            err = GetLastError();
            IIS_PRINTF((buff,
                "Inetinfo: Can't find entry %s in DLL %s: %ld\n",
                 IISADMIN_EXEEXIT_STRING, IISADMIN_NAME, err);
                 );
            return;
        }

        if (!IisAdminExeEntry( FALSE, TRUE, TRUE )) {
            IIS_PRINTF((buff,"IISadmin init failed\n"));
            return;
        }

        IsIisAdmin = FALSE;

        dispatchTable = W3ServiceDispatchTable;

        goto start_dispatch;
    }

    //
    // See if the value exists and get the size of the buffer needed
    //

    nBytes = 0;
    err = RegQueryValueEx(
                    hKey,
                    DISPATCH_ENTRIES_KEY,
                    NULL,
                    &valType,
                    NULL,
                    &nBytes
                    );

    if ( (err != ERROR_SUCCESS) || (nBytes <= sizeof(CHAR)) ) {
        goto start_dispatch;
    }

    //
    // Allocate nBytes to query the buffer
    //

    buffer = (LPBYTE)LocalAlloc(0, nBytes);
    if ( buffer == NULL ) {
        goto start_dispatch;
    }

    //
    // Get the values
    //

    err = RegQueryValueEx(
                    hKey,
                    DISPATCH_ENTRIES_KEY,
                    NULL,
                    &valType,
                    buffer,
                    &nBytes
                    );

    if ( (err != ERROR_SUCCESS) || (valType != REG_MULTI_SZ) ) {
        LocalFree(buffer);
        goto start_dispatch;
    }

    //
    // Walk the list and see how many entries we have. Remove the list
    // terminator from the byte count
    //

    nBytes -= sizeof(CHAR);
    for ( i = 0, entry = (PCHAR)buffer;
        i < nBytes;
        i += sizeof(CHAR) ) {

        if ( *entry++ == '\0' ) {
            nEntries++;
        }
    }

    if ( nEntries == 0 ) {
        LocalFree(buffer);
        goto start_dispatch;
    }

    //
    // Add the number of entries in the default list (including the NULL entry)
    //

    nEntries += sizeof(InetServiceDispatchTable) / sizeof(SERVICE_TABLE_ENTRY);

    //
    // Now we need to allocate the new dispatch table
    //

    tableEntry = (LPSERVICE_TABLE_ENTRY)
        LocalAlloc(0, nEntries * sizeof(SERVICE_TABLE_ENTRY));

    if ( tableEntry == NULL ) {
        LocalFree(buffer);
        goto start_dispatch;
    }

    //
    // set the dispatch table pointer to the new table
    //

    dispatchTable = tableEntry;

    //
    // Populate the table starting with the defaults
    //

    for (i=0; InetServiceDispatchTable[i].lpServiceName != NULL; i++ ) {

        tableEntry->lpServiceName =
            InetServiceDispatchTable[i].lpServiceName;
        tableEntry->lpServiceProc =
            InetServiceDispatchTable[i].lpServiceProc;
        tableEntry++;

    }

    //
    // Now let's add the ones specified in the registry
    //

    entry = (PCHAR)buffer;

    tableEntry->lpServiceName = entry;
    tableEntry->lpServiceProc = InetinfoStartService;
    tableEntry++;

    //
    // Skip the first char and the last NULL terminator.
    // This is needed because we already added the first one.
    //

    for ( i = 2*sizeof(CHAR); i < nBytes; i += sizeof(CHAR) ) {

        if ( *entry++ == '\0' ) {
            tableEntry->lpServiceName = entry;
            tableEntry->lpServiceProc = InetinfoStartService;
            tableEntry++;
        }
    }

    //
    // setup sentinel entry
    //

    tableEntry->lpServiceName = NULL;
    tableEntry->lpServiceProc = NULL;

start_dispatch:

    if ( hKey != NULL ) {
        RegCloseKey(hKey);
    }

    //
    // Call StartServiceCtrlDispatcher to set up the control interface.
    // The API won't return until all services have been terminated. At that
    // point, we just exit.
    //

    if (! StartServiceCtrlDispatcher (
                dispatchTable
                )) {
        //
        // Log an event for failing to start control dispatcher
        //

        IIS_PRINTF((buff,
                 "Inetinfo: Failed to start control dispatcher %lu\n",
                  GetLastError()));
    }

    //
    // free table if allocated
    //

    if ( dispatchTable != InetServiceDispatchTable &&
         dispatchTable != W3ServiceDispatchTable ) {
        LocalFree( dispatchTable );
        LocalFree( buffer );
    }

    if (!IsIisAdmin) {
        IisAdminExeExit();
        FreeLibrary( dllHandle );
    }

    return;

} // StartDispatchTable


// define the message window class name
#define     PWS_WATCHER_WINDOW_CLASS        "INETINFO_MESSAGES"


// message thread to get windows95 close message
// most helpful for proper cleanup during shutdown
LRESULT
CALLBACK
MessageProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HANDLE  hEvent;
    DWORD   i;

    switch( message ) {

        case WM_ENDSESSION:

            if ( lParam == 0 ) {
                IIS_PRINTF((buff,"Got EndSession message with shutdown\n"));
            } else {
                IIS_PRINTF((buff,
                    "Got EndSession message with Logoff[%x]\n",message));
                break;
            }

        case WM_CLOSE:

            //
            // shut down w3svc
            //

            hEvent = CreateEvent(NULL, TRUE, FALSE, PWS_SHUTDOWN_EVENT);
            if ( hEvent ) {
                if ( GetLastError() == ERROR_ALREADY_EXISTS ) {
                    SetEvent( hEvent );
                }
                CloseHandle(hEvent);
            }

            //
            // shutdown code courtesy johnsona
            // shut down iisadmin
            //

            hEvent = CreateEvent(NULL, TRUE, FALSE, IIS_AS_EXE_OBJECT_NAME);

            if ( hEvent ) {

                if ( GetLastError() == ERROR_ALREADY_EXISTS ) {
                    SetEvent( hEvent );
                }

                CloseHandle(hEvent);

                for (i=0; i < 20; i++) {
                    hEvent = CreateEvent(NULL,
                                        TRUE,
                                        FALSE,
                                        IIS_AS_EXE_OBJECT_NAME);

                    if ( hEvent != NULL ) {
                        DWORD err = GetLastError();
                        CloseHandle(hEvent);
                        if ( err == ERROR_ALREADY_EXISTS ) {
                            Sleep(500);
                            continue;
                        }
                    }
                }
                break;
            }

            break;
    }

    // do the default processing
    return(DefWindowProc(hWnd, message, wParam, lParam ));
}


DWORD
PwsMessageThread(
    PVOID pv
    )
{
    WNDCLASS    wndclass;
    MSG         msg;
    HWND        hwnd;

    HINSTANCE   hInst = GetModuleHandle( NULL );

    // prepare and register the window class
    wndclass.style  =   0;
    wndclass.lpfnWndProc = MessageProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance  = hInst;
    wndclass.hIcon      = NULL;
    wndclass.hCursor    = NULL;
    wndclass.hbrBackground = NULL;
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = PWS_WATCHER_WINDOW_CLASS;
    if ( !RegisterClass( &wndclass ) )
        return GetLastError();

    // create the window
    hwnd = CreateWindow(
        PWS_WATCHER_WINDOW_CLASS,       // pointer to registered class name
        "",                 // pointer to window name
        0,                  // window style
        0,                  // horizontal position of window
        0,                  // vertical position of window
        0,                  // window width
        0,                  // window height
        NULL,           // handle to parent or owner window
        NULL,           // handle to menu or child-window identifier
        hInst,          // handle to application instance
        NULL            // pointer to window-creation data
       );
    if ( !hwnd )
        return GetLastError();

    // run the message loop
    while (GetMessage(&msg, NULL, 0, 0))
        {
        TranslateMessage(&msg);
        DispatchMessage( &msg);
        }

    return(1);

} // PwsMessageThread

BOOL
StartMessageThread(
    VOID
    )
{
    HANDLE hThread;
    DWORD  dwThread;
    DWORD err;

    hThread = CreateThread( NULL,
                            0,
                            (LPTHREAD_START_ROUTINE) PwsMessageThread,
                            NULL,
                            0,
                            &dwThread );

    err = GetLastError();
    CloseHandle( hThread );

    if ( hThread == NULL  ) {
        IIS_PRINTF((buff,"Error %d on CreateThread\n",err));
        SetLastError(err);
        return FALSE;
    }

    return(TRUE);
} // StartMessageThread



typedef
DWORD
(*PREGISTER_SERVICE_PROCESS)(
    DWORD dwProcessId,
    DWORD dwServiceType
    );

#define RSP_UNREGISTER_SERVICE  0x00000000
#define RSP_SIMPLE_SERVICE      0x00000001

VOID
W95RegisterService(
    VOID
    )
{
    HMODULE dllHandle;
    DWORD err;
    PREGISTER_SERVICE_PROCESS pRegisterService;

    dllHandle = LoadLibrary("kernel32.dll");

    if ( dllHandle == NULL ) {
        err = GetLastError();
        IIS_PRINTF((buff,"Unable to load kernel32.dll. err %d\n",
            err ));
        return;
    }

    pRegisterService = (PREGISTER_SERVICE_PROCESS)GetProcAddress(
                                                dllHandle,
                                                "RegisterServiceProcess"
                                                );

    if ( pRegisterService != NULL ) {
        err = pRegisterService(
                    GetCurrentProcessId(),
                    RSP_SIMPLE_SERVICE
                    );
        IIS_PRINTF((buff,"Register Service returns %d\n",err));
    }

    CloseHandle(dllHandle);
    return;

} // W95RegisterService


BOOL
LoadPreloadDlls(
    HMODULE * * ppPreloadDllHandles
    )
/*++

Routine Description:

    Force pre-loading of any DLLs listed in the associated registry key.
    This is to support DLLs that have code which must run before other parts
    of inetinfo start.

Arguments:

    On input, an (uninitialized) pointer to an array of module handles. This
    array is allocated, filled out, and returned to the caller by this
    function. The caller must eventually call UnloadPreloadDlls on this array
    in order to close the handles and release the memory.

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    BOOL bSuccess = TRUE;
    HKEY hKey = NULL;
    DWORD err;
    DWORD cbBufferLen;
    DWORD valType;
    LPBYTE pbBuffer = NULL;
    DWORD i;
    PCHAR pszTemp = NULL;
    DWORD nEntries;
    PCHAR pszEntry = NULL;
    DWORD curEntry;


    *ppPreloadDllHandles = NULL;


    err = RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 INETINFO_PARAM_KEY,
                 0,
                 KEY_QUERY_VALUE,
                 &hKey
                 );

    if ( err != ERROR_SUCCESS ) {
        // Note: not considered an error if the key is not there

        hKey = NULL;

        goto Exit;
    }


    //
    // See if the value exists and get the size of the buffer needed
    //

    cbBufferLen = 0;

    err = RegQueryValueEx(
                    hKey,
                    PRELOAD_DLLS_VALUE,
                    NULL,
                    &valType,
                    NULL,
                    &cbBufferLen
                    );

    //
    // Check for no value or an empty value (double null terminated).
    //
    if ( ( err != ERROR_SUCCESS ) || ( cbBufferLen <= 2 * sizeof(CHAR) ) )
    {
        // Note: not considered an error if the value is not there

        goto Exit;
    }

    //
    // Allocate cbBufferLen in order to fetch the data
    //

    pbBuffer = (LPBYTE)LocalAlloc(
                        0,
                        cbBufferLen
                        );

    if ( pbBuffer == NULL )
    {
        bSuccess = FALSE;
        goto Exit;
    }

    //
    // Get the values
    //

    err = RegQueryValueEx(
                    hKey,
                    PRELOAD_DLLS_VALUE,
                    NULL,
                    &valType,
                    pbBuffer,
                    &cbBufferLen
                    );

    if ( ( err != ERROR_SUCCESS ) || ( valType != REG_MULTI_SZ ) )
    {
        bSuccess = FALSE;
        goto Exit;
    }


    //
    // Walk the list and see how many entries we have. Ignore the list
    // terminator in the last byte of the buffer.
    //

    nEntries = 0;
    pszTemp = (PCHAR)pbBuffer;

    for ( i = 0; i < ( cbBufferLen - sizeof(CHAR) ) ; i += sizeof(CHAR) )
    {
        if ( *pszTemp == '\0' )
        {
            nEntries++;
        }

        pszTemp++;
    }


    //
    // Allocate the array of handles, with room for a sentinel entry
    //

    *ppPreloadDllHandles = (HMODULE *)LocalAlloc(
                                            0,
                                            ( nEntries + 1 ) * sizeof(HMODULE)
                                            );

    if ( *ppPreloadDllHandles == NULL )
    {
        bSuccess = FALSE;
        goto Exit;
    }


    //
    // Now attempt to load each DLL, and save the handle in the array
    //

    pszTemp = (PCHAR)pbBuffer;
    pszEntry = (PCHAR)pbBuffer;
    curEntry = 0;

    for ( i = 0; i < ( cbBufferLen - sizeof(CHAR) ) ; i += sizeof(CHAR) )
    {
        if ( *pszTemp == '\0' )
        {
            //
            // We've hit the end of one of the SZs in the Multi-SZ;
            // Load the DLL
            //

            (*ppPreloadDllHandles)[curEntry] = LoadLibrary( pszEntry );

            if ( (*ppPreloadDllHandles)[curEntry] == NULL )
            {
                IIS_PRINTF(( buff, "Preloading FAILED for DLL: %s\n", pszEntry ));
            }
            else
            {
                IIS_PRINTF(( buff, "Preloaded DLL: %s\n", pszEntry ));

                // Only move to the next slot if we got a valid handle
                curEntry++;
            }


            // Set the next entry pointer past the current null char
            pszEntry = pszTemp + sizeof(CHAR);
        }

        pszTemp++;
    }


    // Put in a sentinel at the end of the array

    (*ppPreloadDllHandles)[curEntry] = NULL;


Exit:

    if ( hKey != NULL )
    {
        RegCloseKey( hKey );
    }

    if ( pbBuffer != NULL )
    {
        LocalFree( pbBuffer );
    }


    return bSuccess;

} // LoadPreloadDlls


VOID
UnloadPreloadDlls(
    HMODULE * * ppPreloadDllHandles
    )
/*++

Routine Description:

    Unload any DLLs which were preloaded by LoadPreloadDlls.

Arguments:

    Pointer to an array of module handles. Each handle will be freed,
    and then the memory of the array will be LocalFree()ed by this function.

Return Value:

    None.

--*/
{
    HMODULE * pHandleArray = *ppPreloadDllHandles;

    if ( pHandleArray != NULL )
    {

        IIS_PRINTF(( buff, "Unloading Preloaded DLLs\n" ));


        while ( *pHandleArray != NULL )
        {
            FreeLibrary( *pHandleArray );

            pHandleArray++;
        }


        LocalFree( *ppPreloadDllHandles );

        *ppPreloadDllHandles = NULL;
    }

    return;

} // UnloadPreloadDlls
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\application_table.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    application_table.cxx

Abstract:

    This class is a hashtable which manages the set of applications.

    Threading: Always called on the main worker thread.

Author:

    Seth Pollack (sethp)        03-Nov-1998

Revision History:

--*/



#include "precomp.h"



/***************************************************************************++

Routine Description:

    Begin termination of this object. Tell all referenced or owned entities 
    which may hold a reference to this object to release that reference 
    (and not take any more), in order to break reference cycles. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
APPLICATION_TABLE::Terminate(
    )
{

    DWORD SuccessCount = 0;
    DWORD CountOfElementsInTable = 0;

    
    //
    // BUGBUG Iterating in order to clean up, remove, and delete each 
    // element of the table is difficult to do with lkhash today.
    // GeorgeRe plans to fix this eventually. For now, the alternative
    // is to iterate through the table building up in list of all the 
    // elements, and then go through the list and shutdown, remove, and
    // delete each element -- yuck!!
    //
    // Once this gets fixed, we can see if it is valuable to unify any
    // table management code between the app pool, virtual site,
    // and application tables.
    //
    
    LIST_ENTRY DeleteListHead;
    PLIST_ENTRY pDeleteListEntry = NULL;
    APPLICATION * pApplication = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;
    HRESULT hr = S_OK;


    InitializeListHead( &DeleteListHead );

    
    CountOfElementsInTable = Size();


    //
    // Note that for good form we grab the write lock since we will be 
    // modifying objects in the table (although no other thread should 
    // touch this data structure anyways).
    //
    
    SuccessCount = Apply( 
                        DeleteApplicationAction,
                        &DeleteListHead,
                        LKL_WRITELOCK
                        );
    
    DBG_ASSERT( SuccessCount == CountOfElementsInTable );


    // now for each, clean it up, remove it from the table, and delete it
    
    while (  ! IsListEmpty( &DeleteListHead )  )
    {
    
        pDeleteListEntry = RemoveHeadList( &DeleteListHead );

        DBG_ASSERT( pDeleteListEntry != NULL );

        pApplication = APPLICATION::ApplicationFromDeleteListEntry( pDeleteListEntry );


        // remove it from the table

        ReturnCode = DeleteRecord( pApplication );

        if ( ReturnCode != LK_SUCCESS )
        {

            hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Removing application from hashtable failed\n"
                ));

        }

        
        //
        // All remaining shutdown work is done in it's destructor.
        //

        delete pApplication;
    
    }


    return;

}   // APPLICATION_TABLE::Terminate



/***************************************************************************++

Routine Description:

    A routine that may be applied to all APPLICATIONs in the hashtable
    to prepare for termination. Conforms to the PFnRecordAction prototype.

Arguments:

    pApplication - The application.

    pDeleteListHead - List head into which to insert the application for
    later deletion.

Return Value:

    LK_ACTION - LKA_SUCCEEDED always.

--***************************************************************************/

// note: static!
LK_ACTION
APPLICATION_TABLE::DeleteApplicationAction(
    IN APPLICATION * pApplication, 
    IN VOID * pDeleteListHead
    )
{

    DBG_ASSERT( pApplication != NULL );
    DBG_ASSERT( pDeleteListHead != NULL );


    InsertHeadList( 
        ( PLIST_ENTRY ) pDeleteListHead,
        pApplication->GetDeleteListEntry()
        );


    return LKA_SUCCEEDED;
    
}   // APPLICATION_TABLE::DeleteApplicationAction



#if DBG
/***************************************************************************++

Routine Description:

    Debug dump the table.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
APPLICATION_TABLE::DebugDump(
    )
{

    DWORD SuccessCount = 0;
    DWORD CountOfElementsInTable = 0;


    CountOfElementsInTable = Size();


    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Dumping application table; total count: %lu\n",
            CountOfElementsInTable
            ));
    }


    SuccessCount = Apply( 
                        DebugDumpApplicationAction,
                        NULL
                        );
    
    DBG_ASSERT( SuccessCount == CountOfElementsInTable );


    return;

}   // APPLICATION_TABLE::DebugDump



/***************************************************************************++

Routine Description:

    A routine that may be applied to all APPLICATIONs in the hashtable
    to perform a debug dump. Conforms to the PFnRecordAction prototype.

Arguments:

    pApplication - The application.

    pIgnored - Ignored.

Return Value:

    LK_ACTION - LKA_SUCCEEDED always.

--***************************************************************************/

// note: static!
LK_ACTION
APPLICATION_TABLE::DebugDumpApplicationAction(
    IN APPLICATION * pApplication, 
    IN VOID * pIgnored
    )
{

    DBG_ASSERT( pApplication != NULL );
    UNREFERENCED_PARAMETER( pIgnored );


    pApplication->DebugDump();
    

    return LKA_SUCCEEDED;
    
}   // APPLICATION_TABLE::DebugDumpApplicationAction
#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\application.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    application.h

Abstract:

    The IIS web admin service application class definition.

Author:

    Seth Pollack (sethp)        04-Nov-1998

Revision History:

--*/


#ifndef _APPLICATION_H_
#define _APPLICATION_H_



//
// forward references
//

class APP_POOL;
class VIRTUAL_SITE;
class UL_AND_WORKER_MANAGER;



//
// common #defines
//

#define APPLICATION_SIGNATURE       CREATE_SIGNATURE( 'APLN' )
#define APPLICATION_SIGNATURE_FREED CREATE_SIGNATURE( 'aplX' )



//
// structs, enums, etc.
//

// app id struct needed by the hashtable
typedef struct _APPLICATION_ID
{

    DWORD VirtualSiteId;
    LPCWSTR pApplicationUrl;
    
} APPLICATION_ID;


// application configuration
typedef struct _APPLICATION_CONFIG
{

    //
    // Note that the virtual site, URL path, and app index are not part
    // of this config structure, since they are fixed for the lifetime
    // of an application.
    //


    //
    // The id of the app pool that services this application.
    //
    LPCWSTR pAppPoolId;

    //
    // The resolved app pool object.
    //
    APP_POOL * pAppPool;

    //
    // READ THIS: If you add to or modify this structure, be sure to 
    // update the change flags structure below to match. 
    //

} APPLICATION_CONFIG;



// application configuration change flags
typedef struct _APPLICATION_CONFIG_CHANGE_FLAGS
{
    DWORD_PTR pAppPoolId : 1;
    // Flag not needed for pAppPool, it is tied to pAppPoolId

} APPLICATION_CONFIG_CHANGE_FLAGS;

// application states
typedef enum _APPLICATION_STATE
{

    //
    // The object is not yet initialized.
    //
    UninitializedApplicationState = 1,

    //
    // The application is running.
    // This does not mean that it will
    // not return 503, or may not have
    // any URL's associated with it.
    //
    InitializedApplicationState,

} APPLICATION_STATE;


//
// prototypes
//

class APPLICATION
{

public:

    APPLICATION(
        );

    virtual
    ~APPLICATION(
        );

    HRESULT
    Initialize(
        IN const APPLICATION_ID * pApplicationId,
        IN VIRTUAL_SITE * pVirtualSite,
        IN APPLICATION_CONFIG * pApplicationConfig
        );

    HRESULT
    SetConfiguration(
        IN APPLICATION_CONFIG * pApplicationConfig,
        IN APPLICATION_CONFIG_CHANGE_FLAGS * pWhatHasChanged OPTIONAL
        );

    HRESULT
    ReregisterURLs(
        );

    HRESULT
    RegisterLoggingProperties(
        );

    inline
    APP_POOL *
    GetAppPool(
        )
        const
    { return m_pAppPool; }

    inline
    const APPLICATION_ID *
    GetApplicationId(
        )
        const
    { return &m_ApplicationId; }

    inline
    PLIST_ENTRY
    GetVirtualSiteListEntry(
        )
    { return &m_VirtualSiteListEntry; }

    static
    APPLICATION *
    ApplicationFromVirtualSiteListEntry(
        IN const LIST_ENTRY * pVirtualSiteListEntry
        );

    inline
    PLIST_ENTRY
    GetAppPoolListEntry(
        )
    { return &m_AppPoolListEntry; }

    static
    APPLICATION *
    ApplicationFromAppPoolListEntry(
        IN const LIST_ENTRY * pAppPoolListEntry
        );

    inline
    PLIST_ENTRY
    GetDeleteListEntry(
        )
    { return &m_DeleteListEntry; }

    static
    APPLICATION *
    ApplicationFromDeleteListEntry(
        IN const LIST_ENTRY * pDeleteListEntry
        );

    HRESULT
    ConfigureMaxBandwidth(
        );

    HRESULT
    ConfigureMaxConnections(
        );

    HRESULT
    ConfigureConnectionTimeout(
        );

#if DBG
    VOID
    DebugDump(
        );

#endif  // DBG


private:

    HRESULT 
    ActivateConfigGroup(
        );

    HRESULT
    SetAppPool(
        IN APP_POOL * pAppPool
        );

    HRESULT
    InitializeConfigGroup(
        );

    HRESULT
    AddUrlsToConfigGroup(
        );

    HRESULT
    SetConfigGroupAppPoolInformation(
        );

    HRESULT
    SetConfigGroupStateInformation(
        IN HTTP_ENABLED_STATE NewState
        );

    HRESULT
    RegisterSiteIdWithHttpSys(
        );


    DWORD m_Signature;

    APPLICATION_ID m_ApplicationId;

    // current state for this application, 
    // this value only tells whether the object
    // has been initialized or not.  it does not
    // reflex whether urls are registered with HTTP.SYS
    // or if HTTP.SYS is blocking requests for this
    // application.
    APPLICATION_STATE m_State;

    // used by the associated VIRTUAL_SITE to keep a list of its APPLICATIONs
    LIST_ENTRY m_VirtualSiteListEntry;

    // used by the associated APP_POOL to keep a list of its APPLICATIONs
    LIST_ENTRY m_AppPoolListEntry;

    VIRTUAL_SITE * m_pVirtualSite;

    APP_POOL * m_pAppPool;

    // UL configuration group
    HTTP_CONFIG_GROUP_ID m_UlConfigGroupId;

    // Is UL currently logging information?
    BOOL m_ULLogging;

    // used for building a list of APPLICATIONs to delete
    LIST_ENTRY m_DeleteListEntry;    

};  // class APPLICATION



#endif  // _APPLICATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\application_table.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    application_table.h

Abstract:

    The IIS web admin service application table class definition.

Author:

    Seth Pollack (sethp)        03-Nov-1998

Revision History:

--*/


#ifndef _APPLICATION_TABLE_H_
#define _APPLICATION_TABLE_H_



//
// prototypes
//

class APPLICATION_TABLE
    : public CTypedHashTable< APPLICATION_TABLE, APPLICATION, const APPLICATION_ID * >
{

public:

    APPLICATION_TABLE(
        )
        : CTypedHashTable< APPLICATION_TABLE, APPLICATION, const APPLICATION_ID * >
                ( "APPLICATION_TABLE" )
    { /* do nothing*/ }

    virtual
    ~APPLICATION_TABLE(
        )
    { DBG_ASSERT( Size() == 0 ); }

    static
    const APPLICATION_ID *
    ExtractKey(
        IN const APPLICATION * pApplication
        )  
    { return pApplication->GetApplicationId(); }
    
    static
    DWORD
    CalcKeyHash(
        IN const APPLICATION_ID * Key
        ) 
    { return HashStringNoCase( Key->pApplicationUrl, Key->VirtualSiteId ); }
    
    static
    bool
    EqualKeys(
        IN const APPLICATION_ID * Key1,
        IN const APPLICATION_ID * Key2
        )
    { return ( ( Key1->VirtualSiteId == Key2->VirtualSiteId ) && 
               ( _wcsicmp( Key1->pApplicationUrl, Key2->pApplicationUrl ) == 0 ) ); }
    
    static
    void
    AddRefRecord(
        IN APPLICATION * pApplication,
        IN int IncrementAmount
        ) 
    { /* do nothing*/ }

    VOID
    Terminate(
        );

    static
    LK_ACTION
    DeleteApplicationAction(
        IN APPLICATION * pApplication, 
        IN VOID * pDeleteListHead
        );


#if DBG
    VOID
    DebugDump(
        );

    static
    LK_ACTION
    DebugDumpApplicationAction(
        IN APPLICATION * pApplication, 
        IN VOID * pIgnored
        );
#endif  // DBG


};  // APPLICATION_TABLE



#endif  // _APPLICATION_TABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\app_pool.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    app_pool.cxx

Abstract:

    This class encapsulates a single app pool. 

    Threading: For the class itself, Reference(), Dereference(), and the
    destructor may be called on any thread; all other work is done on the 
    main worker thread.

Author:

    Seth Pollack (sethp)        01-Oct-1998

Revision History:

--*/



#include "precomp.h"
#include <Aclapi.h>


//
// local prototypes
//

ULONG
CountOfBitsSet(
    IN DWORD_PTR Value
    );

HRESULT
CreateTokenForUser(
    IN  LPWSTR UserName,
    IN  LPWSTR UserPassword,
    IN  DWORD  LogonMethod,
    OUT TOKEN_CACHE_ENTRY ** ppTokenCacheEntry
    );


/***************************************************************************++

Routine Description:

    Constructor for the APP_POOL class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

APP_POOL::APP_POOL(
    )
{

    //
    // Set the initial reference count to 1, in order to represent the
    // reference owned by the creator of this instance.
    //

    m_RefCount = 1;


    m_InAppPoolTable = FALSE;

    m_State = UninitializedAppPoolState; 

    m_pAppPoolId = NULL;

    ZeroMemory( &m_Config, sizeof( m_Config ) );

    m_AppPoolHandle = NULL;

    m_WaitingForDemandStart = FALSE;

    InitializeListHead( &m_WorkerProcessListHead );
    m_WorkerProcessCount = 0;

    m_AdjustedMaxSteadyStateProcessCount = 0;

    m_AvailableProcessorMask = 0;

    InitializeListHead( &m_ApplicationListHead );
    m_ApplicationCount = 0;

    m_TotalWorkerProcessRotations = 0;

    m_TotalWorkerProcessFailures = 0;
    
    m_RecentWorkerProcessFailures = 0;
    m_RecentFailuresWindowBeganTickCount = 0;
    
    m_DeleteListEntry.Flink = NULL;
    m_DeleteListEntry.Blink = NULL; 

    m_pWorkerProcessTokenCacheEntry = NULL;

    m_pJobObject = NULL;

    m_Signature = APP_POOL_SIGNATURE;

}   // APP_POOL::APP_POOL



/***************************************************************************++

Routine Description:

    Destructor for the APP_POOL class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

APP_POOL::~APP_POOL(
    )
{

    DBG_ASSERT( m_Signature == APP_POOL_SIGNATURE );

    m_Signature = APP_POOL_SIGNATURE_FREED;

    DBG_ASSERT( m_RefCount == 0 );

    DBG_ASSERT( m_InAppPoolTable == FALSE );

    DBG_ASSERT( m_State == DeletePendingAppPoolState );

    DBG_ASSERT( m_AppPoolHandle == NULL );

    DBG_ASSERT( ! m_WaitingForDemandStart );


    //
    // This should not go away with any of its worker processes still around.
    //

    DBG_ASSERT( IsListEmpty( &m_WorkerProcessListHead ) );
    DBG_ASSERT( m_WorkerProcessCount == 0 );


    //
    // This should not go away with any applications still referring to it.
    //

    DBG_ASSERT( IsListEmpty( &m_ApplicationListHead ) );
    DBG_ASSERT( m_ApplicationCount == 0 );

    DBG_ASSERT( m_pWorkerProcessTokenCacheEntry == NULL );

    DBG_ASSERT ( m_pJobObject == NULL );

    //
    // Free any separately allocated config.
    //

    if ( m_Config.pOrphanAction != NULL )
    {
        DBG_REQUIRE( GlobalFree( m_Config.pOrphanAction ) == NULL );
        m_Config.pOrphanAction = NULL;
    }


    if ( m_pAppPoolId != NULL )
    {
        DBG_REQUIRE( GlobalFree( m_pAppPoolId ) == NULL );
        m_pAppPoolId = NULL;
    }


}   // APP_POOL::~APP_POOL



/***************************************************************************++

Routine Description:

    Increment the reference count for this object. Note that this method must 
    be thread safe, and must not be able to fail. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
APP_POOL::Reference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedIncrement( &m_RefCount );


    // 
    // The reference count should never have been less than zero; and
    // furthermore once it has hit zero it should never bounce back up;
    // given these conditions, it better be greater than one now.
    //
    
    DBG_ASSERT( NewRefCount > 1 );


    return;

}   // APP_POOL::Reference



/***************************************************************************++

Routine Description:

    Decrement the reference count for this object, and cleanup if the count 
    hits zero. Note that this method must be thread safe, and must not be
    able to fail. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
APP_POOL::Dereference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedDecrement( &m_RefCount );

    // ref count should never go negative
    DBG_ASSERT( NewRefCount >= 0 );

    if ( NewRefCount == 0 )
    {
        // time to go away

        IF_DEBUG( WEB_ADMIN_SERVICE_REFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Reference count has hit zero in APP_POOL instance, deleting (ptr: %p; id: %S)\n",
                this,
                GetAppPoolId()
                ));
        }


        delete this;


    }
    

    return;
    
}   // APP_POOL::Dereference



/***************************************************************************++

Routine Description:

    Execute a work item on this object.

Arguments:

    pWorkItem - The work item to execute.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::ExecuteWorkItem(
    IN const WORK_ITEM * pWorkItem
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );
    DBG_ASSERT( GetWebAdminService()->IsBackwardCompatibilityEnabled() == FALSE );

    DBG_ASSERT( pWorkItem != NULL );


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Executing work item with serial number: %lu in APP_POOL (ptr: %p; id: %S) with operation: %p\n",
            pWorkItem->GetSerialNumber(),
            this,
            GetAppPoolId(),
            pWorkItem->GetOpCode()
            ));
    }


    switch ( pWorkItem->GetOpCode() )
    {

        case DemandStartAppPoolWorkItem:
            hr = DemandStartWorkItem();
        break;

        default:

            // invalid work item!
            DBG_ASSERT( FALSE );
            
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;
            
    }


    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Executing work item on APP_POOL failed\n"
            ));

    }


    return hr;
    
}   // APP_POOL::ExecuteWorkItem



/***************************************************************************++

Routine Description:

    Initialize the app pool instance.

Arguments:

    pAppPoolId - ID string for the app pool.

    pAppPoolConfig - The configuration parameters for this app pool. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::Initialize(
    IN LPCWSTR pAppPoolId,
    IN APP_POOL_CONFIG * pAppPoolConfig
    )
{
    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;
    ULONG NumberOfCharacters = 0;

    // Security descriptor variables for locking the app pool
    // down to just the Local System
    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
    PSID psidLocalSystem = NULL;
    PACL pACL = NULL;

    EXPLICIT_ACCESS ea[2];

    SECURITY_DESCRIPTOR sd = {0};
    SECURITY_ATTRIBUTES sa = {0};

    // Security descriptor variables for locking the app pool 
    // down also to the initial user.  If we get change notifications
    // working this code will be removed.
    BUFFER SidAndAttributes;  // Holds the SID and ATTRIBUTES for the token.
    PSID psidUser = NULL;     // Will eventually point to the sid that is 
                              // created in the buffer space, don't free it.

    DWORD SizeofTokenUser = 0;
    DWORD NumAclInUse = 1;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pAppPoolId != NULL );
    DBG_ASSERT( pAppPoolConfig != NULL );


    //
    // First, make copy of the ID string.
    //

    // count the characters, and add 1 for the terminating null
    NumberOfCharacters = wcslen( pAppPoolId ) + 1;

    m_pAppPoolId = ( LPWSTR )GlobalAlloc( GMEM_FIXED, ( sizeof( WCHAR ) * NumberOfCharacters ) );

    if ( m_pAppPoolId == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating memory failed\n"
            ));

        goto exit;
    }


    wcscpy( m_pAppPoolId, pAppPoolId );

    //
    // Since we don't have change notifcations working, go ahead
    // and process the user for the app pool in the initialization
    // routine.  If we get the change notifications working then
    // we can remove this and let it happen in the Set Configuration
    // call below.
    //
    hr = SetTokenForWorkerProcesses(pAppPoolConfig->pUserName,
                                    pAppPoolConfig->pUserPassword,
                                    pAppPoolConfig->UserType,
                                    pAppPoolConfig->LogonMethod);
    if ( FAILED ( hr ) )
    {
        const WCHAR * EventLogStrings[1];

        EventLogStrings[0] = m_pAppPoolId;

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_PROCESS_IDENTITY_FAILURE,       // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                0                                       // error code
                );
    }

    //
    // Local System shall have all rights to the 
    // App_pool.  Until we have completed the config
    // work the Local System will be the only one 
    // with access.
    
    //
    // Get a sid that represents LOCAL_SYSTEM.
    //
    if(! AllocateAndInitializeSid( &SIDAuthNT, 1,
                 SECURITY_LOCAL_SYSTEM_RID,
                 0, 0, 0, 0, 0, 0, 0,
                 &psidLocalSystem ) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating Local System SID failed\n"
            ));

        goto exit;
    }
    
    ZeroMemory(&ea, 2 * sizeof(EXPLICIT_ACCESS));

    //
    // Now setup the access structure to allow 
    // read access for the trustee.
    //
    ea[0].grfAccessPermissions = GENERIC_ALL;
    ea[0].grfAccessMode = GRANT_ACCESS;
    ea[0].grfInheritance= NO_INHERITANCE;
    ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ea[0].Trustee.ptstrName  = (LPTSTR) psidLocalSystem;

    //
    // In addition to ACLing local system we also need
    // to acl the worker process identity so we can access
    // the app pool from the other worker process.
    //

    // 
    //
    // if the current token is the LOCAL_SYSTEM token
    // then we do not need to do anything, it all ready
    // has full access to the app_pool.
    //

    if ( m_pWorkerProcessTokenCacheEntry != NULL &&  
         m_pWorkerProcessTokenCacheEntry != GetWebAdminService()->GetLocalSystemTokenCacheEntry()  )
    {

        // 
        // We need to get the sid from the token, first call the lookup 
        // to determine the size of the 
        //
        if (GetTokenInformation( m_pWorkerProcessTokenCacheEntry->QueryPrimaryToken(),
                                  TokenUser,
                                  NULL,
                                  0,
                                  &SizeofTokenUser ) )
        {
            //
            // if this worked, then there is a problem because
            // this call should fail with INSUFFICIENT_BUFFER_SIZE
            //
            hr = E_FAIL;
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Did not error when we expected to\n"
                ));

            goto exit;
        }
        else
        {
            hr = GetLastError();
            if ( hr != ERROR_INSUFFICIENT_BUFFER )
            {
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Failed to get the size of the sid for the token\n"
                    ));

                goto exit;
            }
            else
            {
                // ERROR_INSUFFICIENT_BUFFER is not a real error.
                hr = S_OK;
            }
        }

        //
        // Now resize the buffer to be the right size
        if ( ! SidAndAttributes.Resize( SizeofTokenUser ) )
        {
            hr = GetLastError();
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Failed to resize the buffer to the correct size\n"
                ));

            goto exit;
        }

        //
        // Zero out the memory just to be safe.
        //
        memset ( SidAndAttributes.QueryPtr(), 0, SizeofTokenUser );


        //
        // Now use the GetTokenInformation routine to get the
        // security SID.
        //
        if (!GetTokenInformation( m_pWorkerProcessTokenCacheEntry->QueryPrimaryToken(),
                                  TokenUser,
                                  SidAndAttributes.QueryPtr(),
                                  SizeofTokenUser,
                                  &SizeofTokenUser ) )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Error getting the account SID based on the token\n"
                ));

            goto exit;
        }

        // Set the psidUser to point to the sid that has been returned.
        psidUser = ( ( PTOKEN_USER ) (SidAndAttributes.QueryPtr()))->User.Sid;

        ea[1].grfAccessPermissions = GENERIC_READ | SYNCHRONIZE;
        ea[1].grfAccessMode = SET_ACCESS;
        ea[1].grfInheritance= NO_INHERITANCE;
        ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[1].Trustee.TrusteeType = TRUSTEE_IS_USER;
        ea[1].Trustee.ptstrName  = (LPTSTR) psidUser;
    
        NumAclInUse = 2;

    }

    //
    // Now we have the objects, we can go ahead and
    // setup the entries in the ACL.
    //

    // Create a new ACL that contains the new ACEs.
    //
    Win32Error = SetEntriesInAcl(NumAclInUse, ea, NULL, &pACL);
    if ( Win32Error != ERROR_SUCCESS ) 
    {
        hr = HRESULT_FROM_WIN32(Win32Error);
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting ACE's into ACL failed.\n"
            ));

        goto exit;
    }

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) 
    {  
        hr = HRESULT_FROM_WIN32(GetLastError());
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing the security descriptor failed\n"
            ));

        goto exit;
    } 

    if (!SetSecurityDescriptorDacl(&sd, 
            TRUE,     // fDaclPresent flag   
            pACL, 
            FALSE))   // not a default DACL 
    {  
        hr = HRESULT_FROM_WIN32(GetLastError());
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting the DACL on the security descriptor failed\n"
            ));

        goto exit;
    } 

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle = FALSE;


    //
    // Finally we can create the app pool secured correctly.
    //
    Win32Error = HttpCreateAppPool(
                        &m_AppPoolHandle,           // returned handle
                        m_pAppPoolId,               // app pool ID
                        &sa,                        // security attributes
                        HTTP_OPTION_OVERLAPPED |    // async i/o
                        HTTP_OPTION_CONTROLLER      // controller
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't create app pool handle\n"
            ));

        goto exit;
    }


    //
    // Associate the app pool handle with the work queue's completion port.
    //
    
    hr = GetWebAdminService()->GetWorkQueue()->
                BindHandleToCompletionPort( 
                    m_AppPoolHandle, 
                    0
                    );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Binding app pool handle to completion port failed\n"
            ));

        goto exit;
    }

    //
    // Make sure we don't all ready have a job object.
    //
    DBG_ASSERT ( m_pJobObject == NULL );

    if (! GetWebAdminService()->IsBackwardCompatibilityEnabled() )
    {
        //
        // Allocate a new job object for the app pool.
        //
        m_pJobObject = new JOB_OBJECT;
        if ( m_pJobObject == NULL )
        {
            DPERROR(( 
                DBG_CONTEXT,
                HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY),
                "Failed to allocate the job object object\n"
                ));

            goto exit;
        }

        //
        // Initialize the new job object so it is ready to 
        // have limits set on it.
        //
        hr = m_pJobObject->Initialize(this);
        if ( FAILED ( hr ) )
        {
    
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Initialization of the job object failed\n"
                ));

            goto exit;
        }

    }

    //
    // Set the configuration information.
    //


    hr = SetConfiguration( pAppPoolConfig, NULL ); 

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Accepting configuration failed\n"
            ));

        goto exit;
    }


    //
    // Set the state to running. We must do this before posting the
    // demand start wait, as demand start requests are only acted on
    // if the app pool is in the running state. 
    //
    hr = ProcessStateChangeCommand( MD_APPPOOL_COMMAND_START , FALSE );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Starting the app pool failed\n"
            ));

        goto exit;
    }

exit:

    if (psidLocalSystem) 
    {
        FreeSid(psidLocalSystem);
        psidLocalSystem = NULL;
    }

    if (pACL) 
    {
        LocalFree(pACL);
        pACL = NULL;
    }

    return hr;
    
}   // APP_POOL::Initialize

/***************************************************************************++

Routine Description:

    Reset the app_pool to allow access to the current configured user.

Arguments:

    AccessMode - can be SET_ACCESS or REVOKE_ACCESS

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::ResetAppPoolAccess(
    IN ACCESS_MODE AccessMode
    )
{
    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;

    BUFFER SidAndAttributes;  // Holds the SID and ATTRIBUTES for the token.
    PSID psidUser = NULL;     // Will eventually point to the sid that is 
                              // created in the buffer space, don't free it.

    EXPLICIT_ACCESS ea;       // Used to describe an ACE for adding to a ACL.

    PACL pACL = NULL;         // Pointer to the new ACL to add to the security
                              // info.

    PACL                 pOldDACL = NULL;

    PSECURITY_DESCRIPTOR pSD = NULL;
    DWORD   SizeofTokenUser = 0;

    DBG_ASSERT ( AccessMode == SET_ACCESS || AccessMode == REVOKE_ACCESS );

    //
    // if the current token is the LOCAL_SYSTEM token
    // then we do not need to do anything, it all ready
    // has full access to the app_pool.
    //

    if ( NULL == m_pWorkerProcessTokenCacheEntry ||
         m_pWorkerProcessTokenCacheEntry == GetWebAdminService()->GetLocalSystemTokenCacheEntry() )
    {
        // no configuration changes needed.
        return S_OK;
    }

    // 
    // We need to get the sid from the token, first call the lookup 
    // to determine the size of the 
    //
    if (GetTokenInformation( m_pWorkerProcessTokenCacheEntry->QueryPrimaryToken(),
                              TokenUser,
                              NULL,
                              0,
                              &SizeofTokenUser ) )
    {
        //
        // if this worked, then there is a problem because
        // this call should fail with INSUFFICIENT_BUFFER_SIZE
        //
        hr = E_FAIL;
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Did not error when we expected to\n"
            ));

        goto exit;
    }
    else
    {
        hr = GetLastError();
        if ( hr != ERROR_INSUFFICIENT_BUFFER )
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Failed to get the size of the sid for the token\n"
                ));

            goto exit;
        }
        else
        {
            // ERROR_INSUFFICIENT_BUFFER is not a real error.
            hr = S_OK;
        }
    }

    //
    // Now resize the buffer to be the right size
    if ( ! SidAndAttributes.Resize( SizeofTokenUser ) )
    {
        hr = GetLastError();
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Failed to resize the buffer to the correct size\n"
            ));

        goto exit;
    }

    //
    // Zero out the memory just to be safe.
    //
    memset ( SidAndAttributes.QueryPtr(), 0, SizeofTokenUser );


    //
    // Now use the GetTokenInformation routine to get the
    // security SID.
    //
    if (!GetTokenInformation( m_pWorkerProcessTokenCacheEntry->QueryPrimaryToken(),
                              TokenUser,
                              SidAndAttributes.QueryPtr(),
                              SizeofTokenUser,
                              &SizeofTokenUser ) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Error getting the account SID based on the token\n"
            ));

        goto exit;
    }

    // Set the psidUser to point to the sid that has been returned.
    psidUser = ( ( PTOKEN_USER ) (SidAndAttributes.QueryPtr()))->User.Sid;

    
    ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));

    //
    // Now setup the access structure to allow 
    // read and synchronize access for the trustee.
    //
    ea.grfAccessPermissions = GENERIC_READ | SYNCHRONIZE;
    ea.grfAccessMode = AccessMode;
    ea.grfInheritance= NO_INHERITANCE;
    ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea.Trustee.TrusteeType = TRUSTEE_IS_USER;
    ea.Trustee.ptstrName  = (LPTSTR) psidUser;

    //
    // The pOldDACL is just a pointer into memory owned 
    // by the pSD, so only free the pSD.
    //
    Win32Error = GetSecurityInfo( m_AppPoolHandle,
                                  SE_FILE_OBJECT, 
                                  DACL_SECURITY_INFORMATION,
                                  NULL,        // owner SID
                                  NULL,        // primary group SID
                                  &pOldDACL,   // PACL*
                                  NULL,        // PACL*
                                  &pSD );      // Security Descriptor 
    if ( Win32Error != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32(Win32Error);

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not get security info for the app pool handle \n"
            ));

        goto exit;
    }

    //
    // Create a new ACL that contains the new ACEs.
    //
    Win32Error = SetEntriesInAcl(1, &ea, pOldDACL, &pACL);
    if ( Win32Error != ERROR_SUCCESS ) 
    {
        hr = HRESULT_FROM_WIN32(Win32Error);
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting ACE's into ACL failed.\n"
            ));

        goto exit;
    }

    Win32Error = SetSecurityInfo(m_AppPoolHandle, 
                                  SE_FILE_OBJECT, 
                                  DACL_SECURITY_INFORMATION,
                                  NULL, 
                                  NULL, 
                                  pACL, 
                                  NULL);
    if ( Win32Error != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32(Win32Error);
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not set new security info \n"
            ));

        goto exit;
    }

exit:

    if( pSD != NULL ) 
    {
        LocalFree((HLOCAL) pSD); 
    }

    if( pACL != NULL ) 
    {
        LocalFree((HLOCAL) pACL); 
    }

    return hr;
}


/***************************************************************************++

Routine Description:

    Accept a set of configuration parameters for this app pool. 

Arguments:

    pAppPoolConfig - The configuration for this app pool. 

    pWhatHasChanged - Which particular configuration values were changed.
    This is always provided in change notify cases; it is always NULL in
    initial read cases. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::SetConfiguration(
    IN APP_POOL_CONFIG * pAppPoolConfig,
    IN APP_POOL_CONFIG_CHANGE_FLAGS * pWhatHasChanged OPTIONAL
    )
{

    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;
    
    DBG_ASSERT( pAppPoolConfig != NULL );


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "New configuration for app pool (ptr: %p; id: %S)\n",
            this,
            GetAppPoolId()
            ));
    }


    //
    // Note that we rely on the config store to ensure that the configuration
    // data are valid. 
    //

    //
    // For the first time through, figure out what user identity we should
    // run under.
    //
    // Issue-10/30/2000-EmilyK change notifications on identity
    //                         
    // Currently the ResetAppPoolAccess code does not do gain
    // access for worker processes.  Until it does we do the real
    // work in the initalization routine and not here.  However leaving
    // this code in does not functionally hurt anything so it will still
    // run, until this is settled.
    //
    if ( pWhatHasChanged == NULL ) 
    {
        // 
        // if we had a valid token before we want to revoke it's 
        // privledges on the app_pool before setting up a new
        // token.  if a worker process has the app_pool open they
        // will be able to continue to use it even if we have 
        // revoked their access.
        //
        hr = ResetAppPoolAccess ( REVOKE_ACCESS );
        if ( FAILED ( hr ) )
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Failure revoking app pool access to the worker process identity\n"
                ));

            //
            // We will continue on from here, however we should review
            // this decision to make sure it is not a Security Hole.
            //
            // Security Review needed.
            //
        }

        hr = SetTokenForWorkerProcesses(pAppPoolConfig->pUserName,
                                        pAppPoolConfig->pUserPassword,
                                        pAppPoolConfig->UserType,
                                        pAppPoolConfig->LogonMethod);
        if ( FAILED ( hr ) )
        {
            const WCHAR * EventLogStrings[1];

            EventLogStrings[0] = m_pAppPoolId;

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_PROCESS_IDENTITY_FAILURE,       // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    0                                       // error code
                    );
        }
        else 
        {
            // 
            // now that we have changed the worker process token
            // we are ready to secure to the new worker process token.
            //
            hr = ResetAppPoolAccess ( SET_ACCESS );
            if ( FAILED ( hr ) )
            {
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Failure granting app pool access to the worker process identity\n"
                    ));

                //
                // We will continue on from here.  We will get failures
                // when we try and launch a worker process and deal with 
                // the issues there.
                //
            }

        }
    }

    //
    // Free any old separately allocated config.
    //

    if ( m_Config.pOrphanAction != NULL )
    {
        DBG_REQUIRE( GlobalFree( m_Config.pOrphanAction ) == NULL );
        m_Config.pOrphanAction = NULL;
    }

    if ( m_Config.pPeriodicProcessRestartSchedule  != NULL )
    {
        DBG_REQUIRE( GlobalFree( m_Config.pPeriodicProcessRestartSchedule ) == NULL );
        m_Config.pPeriodicProcessRestartSchedule  = NULL;
    }

    //
    // Copy the inline config parameters into this instance. 
    //

    CopyMemory( &m_Config, pAppPoolConfig, sizeof( m_Config ) );


    //
    // Copy any referenced config parameters.
    //

    if ( pAppPoolConfig->pOrphanAction != NULL )
    {

        m_Config.pOrphanAction = ( LPWSTR )GlobalAlloc( GMEM_FIXED, ( wcslen( pAppPoolConfig->pOrphanAction ) + 1 ) * sizeof( WCHAR ) );

        if ( m_Config.pOrphanAction == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Allocating memory failed\n"
                ));

            //
            // If there is no memory, then we can live with no orphan action.
            // Press on, so that we don't leave our config in a half-baked
            // state.
            //

            hr = S_OK;
        }
        else
        {

            wcscpy( m_Config.pOrphanAction, pAppPoolConfig->pOrphanAction );

        }
    }
    
    if ( pAppPoolConfig->pPeriodicProcessRestartSchedule != NULL )
    {
        DWORD cbRestartSchedule = GetMultiszByteLength( pAppPoolConfig->pPeriodicProcessRestartSchedule );
        m_Config.pPeriodicProcessRestartSchedule = ( LPWSTR )GlobalAlloc( GMEM_FIXED,  cbRestartSchedule );

        if ( m_Config.pPeriodicProcessRestartSchedule == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Allocating memory for pPeriodicProcessRestartSchedule failed\n"
                ));

            //
            // If there is no memory, then we can live with no pPeriodicProcessRestartSchedule
            // Press on, so that we don't leave our config in a half-baked
            // state.
            //

            hr = S_OK;
        }
        else
        {

            memcpy( m_Config.pPeriodicProcessRestartSchedule, pAppPoolConfig->pPeriodicProcessRestartSchedule, cbRestartSchedule );

        }
    }

    //
    // We do not want to copy any of the User Logon information, the less
    // amount of time we hold the password in memory the better.  Since we did
    // not copy the memory, we need to fix the pointers to be NULL.
    //
    m_Config.pUserName = NULL;
    m_Config.pUserPassword = NULL;

    //
    // Configure the job object if we need to.
    //

    // In BC mode the job object will be null.
    if (  m_pJobObject && 
          ( pWhatHasChanged == NULL ||
              pWhatHasChanged->CPUResetInterval ||
              pWhatHasChanged->CPULimit ||
              pWhatHasChanged->CPUAction )  )
    {
        hr = m_pJobObject->SetConfiguration( pAppPoolConfig->CPUResetInterval, 
                                             pAppPoolConfig->CPULimit,
                                             pAppPoolConfig->CPUAction);
        if ( FAILED ( hr ) )
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Failure configuring the job object\n"
                ));

            goto exit;
        }
    }

    //
    // Inform UL of new app pool configuration.
    //

    //
    // See if the app pool max queue length has been set or changed, 
    // and if so, handle it.
    //

    if ( ( pWhatHasChanged == NULL ) || ( pWhatHasChanged->UlAppPoolQueueLength ) )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Setting app pool's (ptr: %p; id: %S) UL queue length max: %lu\n",
                this,
                GetAppPoolId(),
                m_Config.UlAppPoolQueueLength
                ));
        }


        Win32Error = HttpSetAppPoolInformation(
                            m_AppPoolHandle,        // app pool handle
                            HttpAppPoolQueueLengthInformation,
                                                    // information class
                            reinterpret_cast <VOID *> ( &m_Config.UlAppPoolQueueLength ),
                                                    // data
                            sizeof( m_Config.UlAppPoolQueueLength )
                                                    // data length
                            );

        if ( Win32Error != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32( Win32Error );

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Setting app pool information failed\n"
                ));

            //
            // We tried, press on.
            //

            hr = S_OK;
        }

    }
    
    //
    // Handle changes in Worker Process Recycling related parameters
    // Inform worker processes about any relevant changes so that 
    // they update their recycler configuration
    //
    // Do not do anything on initial read
    //
    if ( pWhatHasChanged != NULL )
    {
        InformAllWorkerProcessesAboutParameterChanges( pWhatHasChanged );
    }
   
    //
    // Determine based on our config settings exactly which processors 
    // may be used, and what our maximum steady state process limit is.
    //

    DetermineAvailableProcessorsAndProcessCount();


#if DBG
    //
    // Dump the configuration.
    //

    DebugDump();
#endif  // DBG


    //
    // If allowed, rotate all worker processes to ensure that the config 
    // changes take effect. 
    //

    //
    // CODEWORK We only need to do this for certain property changes; others
    // don't require rotating running processes. Should we be smarter here
    // and only rotate when needed? 
    // Right now (12/3/99) the only app pool config properties that don't 
    // require rotation to take full effect are: pinging enabled, rapid fail
    // protection enabled, and orphaning. (12/21/99 also shutdown time limit,
    // ping interval, ping time limit.) (1/11/00 also disallow overlapping
    // rotation, orphan action.) (1/21/00 also ul app pool queue length.)
    // As it stands, it doesn't seem worth it to special case this; so for 
    // now we'll just always rotate. EricDe agrees with this (12/6/99).
    //

    //
    // Process any ServerCommand that may want us to alter the state of the 
    // app pool.
    if ( ( pWhatHasChanged != NULL ) && 
         ( pWhatHasChanged->ServerCommand == TRUE ))
    {
        hr = ProcessStateChangeCommand( 
                                    m_Config.ServerCommand,  // command to perform
                                    TRUE                     // it is a direct command
                                    );
        if ( FAILED( hr ) )
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Failed processing the state command change\n"
                ));

            // Issue:  Do we want to log an error here?  Careful
            //         it might be overactive logging.

            // press on in the face of errors.

            hr = S_OK;
        }
    }

    hr = HandleConfigChangeAffectingWorkerProcesses();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Handling config change affecting worker processes failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // APP_POOL::SetConfiguration



/***************************************************************************++

Routine Description:

    Register an application as being part of this app pool.

Arguments:

    pApplication - Pointer to the APPLICATION instance.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::AssociateApplication(
    IN APPLICATION * pApplication
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pApplication != NULL );


    InsertHeadList( 
        &m_ApplicationListHead, 
        pApplication->GetAppPoolListEntry() 
        );
        
    m_ApplicationCount++;


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Associated application %lu:\"%S\" with app pool \"%S\"; app count now: %lu\n",
            ( pApplication->GetApplicationId() )->VirtualSiteId,
            ( pApplication->GetApplicationId() )->pApplicationUrl,
            m_pAppPoolId,
            m_ApplicationCount
            ));
    }


    return hr;
    
}   // APP_POOL::AssociateApplication



/***************************************************************************++

Routine Description:

    Remove the registration of an application that is part of this app
    pool.

Arguments:

    pApplication - Pointer to the APPLICATION instance.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::DissociateApplication(
    IN APPLICATION * pApplication
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pApplication != NULL );


    RemoveEntryList( pApplication->GetAppPoolListEntry() );
    ( pApplication->GetAppPoolListEntry() )->Flink = NULL; 
    ( pApplication->GetAppPoolListEntry() )->Blink = NULL; 

    m_ApplicationCount--;


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Dissociated application %lu:\"%S\" from app pool \"%S\"; app count now: %lu\n",
            ( pApplication->GetApplicationId() )->VirtualSiteId,
            ( pApplication->GetApplicationId() )->pApplicationUrl,
            m_pAppPoolId,
            m_ApplicationCount
            ));
    }


    return hr;
    
}   // APP_POOL::DissociateApplication



/***************************************************************************++

Routine Description:

    Handle the fact that there has been an unplanned worker process failure.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::ReportWorkerProcessFailure(
    )
{

    HRESULT hr = S_OK;
    DWORD TickCount = 0;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );
    DBG_ASSERT( GetWebAdminService()->IsBackwardCompatibilityEnabled() == FALSE );

    //
    // See if it's time to reset the tick count which is used to remember
    // when the time window began that we use for counting recent rapid
    // failures. 
    // Note that tick counts are in milliseconds. Tick counts roll over 
    // every 49.7 days, but the arithmetic operation works correctly 
    // anyways in this case.
    //

    TickCount = GetTickCount();

    if ( ( TickCount - m_RecentFailuresWindowBeganTickCount ) > ( m_Config.RapidFailProtectionIntervalMS ) )
    {

        //
        // It's time to reset the time window, and the recent fail count.
        //

        IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Resetting rapid repeated failure count and time window in app pool (ptr: %p; id: %S)\n",
                this,
                GetAppPoolId()
                ));
        }


        m_RecentFailuresWindowBeganTickCount = TickCount;

        m_RecentWorkerProcessFailures = 0;
    }


    //
    // Update counters.
    //

    m_TotalWorkerProcessFailures++;

    m_RecentWorkerProcessFailures++;


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Total WP failures: %lu; recent WP failures: %lu for app pool (ptr: %p; id: %S)\n",
            m_TotalWorkerProcessFailures,
            m_RecentWorkerProcessFailures,
            this,
            GetAppPoolId()
            ));
    }

    //
    // Check the recent fail count against the limit. When it hits the
    // threshold, take action. We only do this when it firsts hits the
    // limit. 
    //

    if ( m_RecentWorkerProcessFailures == m_Config.RapidFailProtectionMaxCrashes )
    {

#if DBG
        if ( ReadDwordParameterValueFromRegistry( REGISTRY_VALUE_W3SVC_BREAK_ON_WP_ERROR, 0 ) )
        {
            DBG_ASSERT ( FALSE );
        }
#endif

        //
        // We've had a rash of recent failures. Take action. 
        //

        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Rapid repeated failure limit hit in app pool (ptr: %p; id: %S)\n",
                this,
                GetAppPoolId()
                ));
        }


        //
        // Log an event: flurry of worker process failures detected.
        //

        const WCHAR * EventLogStrings[1];

        EventLogStrings[0] = m_pAppPoolId;

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_RAPID_REPEATED_FAILURE,       // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                0                                       // error code
                );


        if ( m_Config.RapidFailProtectionEnabled ) 
        {

            // Handle turning off appliations in UL for the 
            // failed apppool.
            //
            IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
            {
                DBGPRINTF((
                    DBG_CONTEXT, 
                    "Enagaging rapid fail protection in app pool (ptr: %p; id: %S)\n",
                    this,
                    GetAppPoolId()
                    ));
            }


            //
            // Log an event: engaging rapid fail protection.
            //

            const WCHAR * EventLogStrings[1];

            EventLogStrings[0] = m_pAppPoolId;

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_RAPID_FAIL_PROTECTION,        // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    0                                       // error code
                    );

            //
            // Engage rapid fail protection.
            //

            hr = ProcessStateChangeCommand( MD_APPPOOL_COMMAND_STOP , FALSE );

            if ( FAILED( hr ) )
            {
    
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Engaging rapid fail protection failed\n"
                    ));

                goto exit;
            }

        }

    }


exit:

    return hr;

}   // APP_POOL::ReportWorkerProcessFailure



/***************************************************************************++

Routine Description:

    Start the new worker process which will replace a currently running one.
    Once the new worker process is ready (or if it failed to start 
    correctly), we begin shutdown of the old worker process.

Arguments:

    pWorkerProcessToReplace - Pointer to the worker process to replace,
    once we have started its replacement. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::RequestReplacementWorkerProcess(
    IN WORKER_PROCESS * pWorkerProcessToReplace
    )
{

    HRESULT hr = S_OK;
    DWORD_PTR ProcessorMask = 0;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pWorkerProcessToReplace != NULL );


    //
    // Check to see if we should actually create the new replacement process. 
    //

    if ( ! IsOkToReplaceWorkerProcess() )
    {
        //
        // Signal to callers that we are not going to replace.
        //
        
        hr = E_FAIL;

        goto exit;
    }


    //
    // Get the affinity mask to use. This can fail if the affinity mask 
    // of the previous process is no longer valid, and so cannot be used
    // for the replacement process. 
    //

    hr = GetAffinityMaskForReplacementProcess(
                pWorkerProcessToReplace->GetProcessAffinityMask(),
                &ProcessorMask
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Can't replace process because the affinity mask of the previous process is no longer valid\n"
            ));

        goto exit;
    }


    //
    // Create a replacement. 
    //

    hr = CreateWorkerProcess( 
                ReplaceWorkerProcessStartReason, 
                pWorkerProcessToReplace, 
                ProcessorMask
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating worker process failed\n"
            ));

        goto exit;
    }


    //
    // Update counters.
    //

    m_TotalWorkerProcessRotations++;


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Total WP rotations: %lu for app pool (ptr: %p; id: %S)\n",
            m_TotalWorkerProcessRotations,
            this,
            GetAppPoolId()
            ));
    }


exit:

    return hr;
    
}   // APP_POOL::RequestReplacementWorkerProcess


/***************************************************************************++

Routine Description:

    Adds a worker process to the job object, while it is still in
    suspended mode.  This way any job's it creates will also be added.

Arguments:

    WORKER_PROCESS* pWorkerProcess

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
APP_POOL::AddWorkerProcessToJobObject(
    WORKER_PROCESS* pWorkerProcess
    )
{
    HRESULT hr = S_OK;

    DBG_ASSERT ( pWorkerProcess );

    //
    // In BC mode the job object will be null so 
    // we won't need to really do anything here.
    //

    if ( m_pJobObject )
    {
        DBG_ASSERT ( pWorkerProcess->GetProcessHandle() );

        hr = m_pJobObject->AddWorkerProcess(  pWorkerProcess->GetProcessHandle() );
        if ( FAILED( hr ) )
        {
            const WCHAR * EventLogStrings[2];
            WCHAR StringizedProcessId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];

            _snwprintf( StringizedProcessId, 
                        sizeof( StringizedProcessId ) / sizeof ( WCHAR ), L"%lu", 
                        pWorkerProcess->GetRegisteredProcessId() );

            EventLogStrings[0] = StringizedProcessId;
            EventLogStrings[1] = GetAppPoolId();


            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_WP_NOT_ADDED_TO_JOBOBJECT,                   // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),   // count of strings
                    EventLogStrings,                                       // array of strings
                    hr                                                     // error code
                    );
            
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Adding worker process %lu to the job object representing App Pool '%S' failed\n",
                pWorkerProcess->GetRegisteredProcessId(),
                GetAppPoolId()
                ));

            //
            // Forget the failure now.  And continue to deal with the worker process
            // as if nothing was wrong.  The worst that will happen is the worker process
            // will not be monitored as part of the job.
            //
            hr = S_OK;
        }
    }

    return hr;

} // end APP_POOL::AddWorkerProcessToJobObject


/***************************************************************************++

Routine Description:

    Informs this app pool that one of its worker processes has 
    completed its start-up attempt. This means that the worker process has
    either reached the running state correctly, or suffered an error which
    prevented it from doing so (but was not fatal to the service as a whole). 

    This notification allows the app pool to do any processing that
    was pending on the start-up of a worker process.

Arguments:

    StartReason - The reason the worker process was started.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::WorkerProcessStartupAttemptDone(
    IN WORKER_PROCESS_START_REASON StartReason,
    IN WORKER_PROCESS* pWorkerProcess
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    switch( StartReason )
    {

    case ReplaceWorkerProcessStartReason:

        //
        // Nothing to do here.
        //

        //
        // We should not be getting ReplaceWorkerProcessStartReason in 
        // backward compatibility mode.
        //

        DBG_ASSERT(GetWebAdminService()->IsBackwardCompatibilityEnabled() == FALSE);
        
        break;


    case DemandStartWorkerProcessStartReason:

        //
        // If we are in backward compatiblity mode 
        // we need to finish the service starting
        //
        if (GetWebAdminService()->IsBackwardCompatibilityEnabled())
        {
            GetWebAdminService()->InetinfoRegistered();
        }

        //
        // See if we should start waiting for another demand start notification
        // from UL for this app pool. If we are in backward compatibility mode, 
        // then we are not going to do the WaitForDemandStartIfNeeded here, we will
        // issue a wait only if something happens to the current worker process.
        //

        hr = WaitForDemandStartIfNeeded();
    
        if ( FAILED( hr ) )
        {
    
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Waiting for demand start notification if needed failed\n"
                ));

        }

        break;


    default:

        // invalid start reason!
        DBG_ASSERT( FALSE );
        
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    
        break;
        
    }


    return hr;
    
}   // APP_POOL::WorkerProcessStartupAttemptDone



/***************************************************************************++

Routine Description:

    Remove a worker process object from the list on this app pool object. 

Arguments:

    pWorkerProcess - The worker process object to remove.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::RemoveWorkerProcessFromList(
    IN WORKER_PROCESS * pWorkerProcess
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );
    DBG_ASSERT( pWorkerProcess != NULL );

    RemoveEntryList( pWorkerProcess->GetListEntry() );
    ( pWorkerProcess->GetListEntry() )->Flink = NULL; 
    ( pWorkerProcess->GetListEntry() )->Blink = NULL; 

    m_WorkerProcessCount--;

    //
    // Clean up the reference to the worker process that the app 
    // pool holds. Because each worker process is reference counted, it 
    // will delete itself as soon as it's reference count hits zero.
    //

    pWorkerProcess->Dereference();

    //
    // See if we should start waiting for another demand start notification
    // from UL for this app pool.  Even in Backward Compatibility mode we 
    // should initiate this wait here, because inetinfo.exe may be recycling
    // and we may need to get another worker process up.
    //

    hr = WaitForDemandStartIfNeeded();

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Waiting for demand start notification if needed failed\n"
            ));

        // Issue:  Should we care about this error?

    }


    //
    // See if shutdown is underway, and if so if it has completed now 
    // that this worker process is gone. 
    //
    
    hr = CheckIfShutdownUnderwayAndNowCompleted();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Checking if shutdown is underway and now completed failed\n"
            ));

        goto exit;
    }


exit:

    return hr;
    
}   // APP_POOL::RemoveWorkerProcessFromList



/***************************************************************************++

Routine Description:

    Kick off gentle shutdown of this app pool, by telling all of its worker
    processes to shut down. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::Shutdown(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    //
    // Update our state to remember that we are shutting down.
    // We won't mark the state in the metabase until we have 
    // shutdown.

    // Issue:  We could mark it as shutting down.
    //
    hr = ChangeState( ShutdownPendingAppPoolState, FALSE );
    if ( FAILED ( hr ) )
    {
        // Issue: investigate this error path

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Failed to change the state of the app pool \n"
            ));

        goto exit;
    }


    //
    // Shut down the worker processes belonging to this app pool.
    //

    hr = ShutdownAllWorkerProcesses();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Shutting down worker processes for app pool failed\n"
            ));

        goto exit;
    }


    //
    // See if shutdown has already completed. This could happen if we have
    // no worker processes that need to go through the clean shutdown 
    // handshaking. 
    //
    
    hr = CheckIfShutdownUnderwayAndNowCompleted();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Checking if shutdown is underway and now completed failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // APP_POOL::Shutdown

/***************************************************************************++

Routine Description:

    Request all worker processes from this app pool to send counters. 

Arguments:

    OUT DWORD* pNumberOfProcessToWaitFor - Number of wp's to wait for.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::RequestCounters(
    OUT DWORD* pNumberOfProcessToWaitFor
    )
{

    HRESULT hr = S_OK;
    PLIST_ENTRY pListEntry = NULL;
    PLIST_ENTRY pNextListEntry = NULL;
    WORKER_PROCESS * pWorkerProcess = NULL;
    DWORD NumberProcesses = 0;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT ( pNumberOfProcessToWaitFor );

    //
    // If this app pool is not in a running state, then it is either not
    // initialized yet, or it is shutting down.  In either case, skip requesting
    // counters from it's worker process.  The worker processes will send counters
    // on shutdown so don't worry about not getting them if the app pool is 
    // shutting down.
    //
    if ( m_State != RunningAppPoolState )
    {
        *pNumberOfProcessToWaitFor = 0;
        return S_OK;
    }

    pListEntry = m_WorkerProcessListHead.Flink;

    while ( pListEntry != &m_WorkerProcessListHead )
    {

        DBG_ASSERT( pListEntry != NULL );

        pNextListEntry = pListEntry->Flink;

        pWorkerProcess = WORKER_PROCESS::WorkerProcessFromListEntry( pListEntry );

        //
        // Ask the worker process to request counters.
        // 

        hr = pWorkerProcess->RequestCounters();

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Requesting counters of worker process failed\n"
                ));

            //
            // Press on in the face of errors on a particular worker process.
            //

            hr = S_OK;
        }
        else
        {
            //
            // Only increment this value if we have 
            // successfully requested counters from
            // the worker process.
            //
            // The worker process will return S_FALSE
            // if it was not in a state, where it should
            // be doing things like requesting counters.
            //

            if ( hr != S_FALSE ) 
            {
                NumberProcesses++;
            }

        }


        pListEntry = pNextListEntry;
        
    }

    *pNumberOfProcessToWaitFor = NumberProcesses;

    return hr;

}   // APP_POOL::RequestCounters


/***************************************************************************++

Routine Description:

    Request all worker processes reset there perf counter state.
Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::ResetAllWorkerProcessPerfCounterState(
    )
{

    HRESULT hr = S_OK;
    PLIST_ENTRY pListEntry = NULL;
    PLIST_ENTRY pNextListEntry = NULL;
    WORKER_PROCESS * pWorkerProcess = NULL;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    pListEntry = m_WorkerProcessListHead.Flink;

    while ( pListEntry != &m_WorkerProcessListHead )
    {

        DBG_ASSERT( pListEntry != NULL );

        pNextListEntry = pListEntry->Flink;

        pWorkerProcess = WORKER_PROCESS::WorkerProcessFromListEntry( pListEntry );

        //
        // Ask the worker process to request counters.
        // 

        hr = pWorkerProcess->ResetPerfCounterState();

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Requesting counters of worker process failed\n"
                ));

            //
            // Press on in the face of errors on a particular worker process.
            //

            hr = S_OK;
        }

        pListEntry = pNextListEntry;
        
    }

    return hr;

}   // APP_POOL::ResetAllWorkerProcessPerfCounterState



/***************************************************************************++

Routine Description:

    Begin termination of this object. Tell all referenced or owned entities 
    which may hold a reference to this object to release that reference 
    (and not take any more), in order to break reference cycles. 

    Note that this function may cause the instance to delete itself; 
    instance state should not be accessed when unwinding from this call. 

Arguments:

    IsAppPoolInMetabase - tells if we should record it's state on the way out.

Return Value:

    None.

--***************************************************************************/

VOID
APP_POOL::Terminate(
    IN BOOL IsAppPoolInMetabase
    )
{

    HRESULT hr = S_OK;
    PLIST_ENTRY pListEntry = NULL;
    WORKER_PROCESS * pWorkerProcess = NULL;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    //
    // Issue: Should this move to the end?  Do we need to have changed the m_State value
    // before we do any of this work?
    //
    // Set the virtual site state to stopped.  (In Metabase does not affect UL)
    //
    DBG_REQUIRE( SUCCEEDED( ChangeState( DeletePendingAppPoolState, IsAppPoolInMetabase ) ) );

    //
    // Shutdown the job object and make sure that 
    // we get a valid hresult returned (if we are 
    // not in BC Mode).  If we are the JobObject
    // will be NULL.
    //

    if ( m_pJobObject )
    {
        DBG_REQUIRE ( m_pJobObject->Terminate() == S_OK );
        m_pJobObject->Dereference();
        m_pJobObject = NULL;
    }

    while ( m_WorkerProcessCount > 0 )
    {
    
        pListEntry = m_WorkerProcessListHead.Flink;

        //
        // The list shouldn't be empty, since the count was greater than zero.
        //
        
        DBG_ASSERT( pListEntry != &m_WorkerProcessListHead );


        pWorkerProcess = WORKER_PROCESS::WorkerProcessFromListEntry( pListEntry );


        //
        // Terminate the worker process. Note that the worker process 
        // will call back to remove itself from this list inside this call.
        //

        pWorkerProcess->Terminate();

    }

    DBG_ASSERT( IsListEmpty( &m_WorkerProcessListHead ) );


    //
    // Note that closing the handle will cause the demand start i/o 
    // (if any) to complete as cancelled, allowing us to at that point
    // clean up its reference count.
    //
    
    if ( m_AppPoolHandle != NULL )
    {
        DBG_REQUIRE( CloseHandle( m_AppPoolHandle ) );
        m_AppPoolHandle = NULL;
    }

    //
    // If we are holding a handle to a worker process token that 
    // we actually created for this worker process, we need to close that handle.
    //
    if ( m_pWorkerProcessTokenCacheEntry != NULL )
    {
        m_pWorkerProcessTokenCacheEntry->DereferenceCacheEntry();
        m_pWorkerProcessTokenCacheEntry = NULL;
    }

    //
    // Tell our parent to remove this instance from it's data structures,
    // and dereference the instance. 
    //

    if ( IsInAppPoolTable() )
    {

        hr = GetWebAdminService()->GetUlAndWorkerManager()->RemoveAppPoolFromTable( this );

        if ( FAILED( hr ) )
        {

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Removing app pool from table failed\n"
                ));

        }


        //
        // Note: that may have been our last reference, so don't do any
        // more work here.
        //

    }
   

    return;
    
}   // APP_POOL::Terminate


/***************************************************************************++

Routine Description:

    A static class method to "upcast" from the delete list LIST_ENTRY 
    pointer of a APP_POOL to the APP_POOL as a whole.

Arguments:

    pDeleteListEntry - A pointer to the m_DeleteListEntry member of a 
    APP_POOL.

Return Value:

    The pointer to the containing APP_POOL.

--***************************************************************************/

// note: static!
APP_POOL *
APP_POOL::AppPoolFromDeleteListEntry(
    IN const LIST_ENTRY * pDeleteListEntry
)
{

    APP_POOL * pAppPool = NULL;

    DBG_ASSERT( pDeleteListEntry != NULL );

    //  get the containing structure, then verify the signature
    pAppPool = CONTAINING_RECORD(
                            pDeleteListEntry,
                            APP_POOL,
                            m_DeleteListEntry
                            );

    DBG_ASSERT( pAppPool->m_Signature == APP_POOL_SIGNATURE );

    return pAppPool;

}   // APP_POOL::AppPoolFromDeleteListEntry



/***************************************************************************++

Routine Description:

    Check whether this app pool should be waiting to receive demand start
    requests, and if so, issue the wait.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::WaitForDemandStartIfNeeded(
    )
{

    HRESULT hr = S_OK;

    // we never wait on demand starts in BC mode.
    // just ignore them.
    if ( GetWebAdminService()->IsBackwardCompatibilityEnabled() )
    {
        goto exit;
    }

    //
    // Check to see if we are in a state where we should even bother 
    // waiting for a demand start notification.
    //

    if ( ! IsOkToCreateWorkerProcess() )
    {
        goto exit;
    }


    //
    // If we are already waiting for a demand start, don't wait again.
    //

    if ( m_WaitingForDemandStart )
    {
        goto exit;
    }

    hr = WaitForDemandStart();

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Preparing to receive demand start notification failed\n"
            ));

        goto exit;
    }

exit:

    return hr;

}   // APP_POOL::WaitForDemandStartIfNeeded

/***************************************************************************++

Routine Description:

    Function exposes publicly the DemandStartWorkItem function
    only in backward compatibility mode.  It asserts and does
    nothing in the forward compatibility mode.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::DemandStartInBackwardCompatibilityMode(
    )
{

    HRESULT hr = S_OK;

    // In backward compatibility mode there is only one
    // application and it is the default application so
    // we never worry that we are on the right application.
    DBG_ASSERT(GetWebAdminService()->IsBackwardCompatibilityEnabled());

    if (GetWebAdminService()->IsBackwardCompatibilityEnabled())
    {
        hr = DemandStartWorkItem();
        if ( FAILED( hr ) )
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Failed to demand start the worker process in backward compatibility mode.\n"
                ));
            goto exit;
        }
    }

exit:

    return hr;

}   // APP_POOL::DemandStartInBackwardCompatibilityMode


#if DBG
/***************************************************************************++

Routine Description:

    Dump out key internal data structures.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
APP_POOL::DebugDump(
    )
{

    PLIST_ENTRY pListEntry = NULL;
    APPLICATION * pApplication = NULL;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "********App pool (ptr: %p; id: %S)\n",
            this,
            GetAppPoolId()
            ));
    }
    

    //
    // List config for this app pool.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Periodic restart period (in minutes; zero means disabled): %lu\n",
            m_Config.PeriodicProcessRestartPeriodInMinutes
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Periodic restart request count (zero means disabled): %lu\n",
            m_Config.PeriodicProcessRestartRequestCount
            ));


        DBGPRINTF((
            DBG_CONTEXT, 
            "--Restart based on virtual memory usage (in kB; zero means disabled): %lu\n",
            m_Config.PeriodicProcessRestartMemoryUsageInKB
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Periodic restart schedule (MULTISZ - only first value printed) - %S\n",
            ( (m_Config.pPeriodicProcessRestartSchedule != NULL ) ? 
               m_Config.pPeriodicProcessRestartSchedule:L"<empty>" )
            ));



        DBGPRINTF((
            DBG_CONTEXT, 
            "--Max (steady state) process count: %lu\n",
            m_Config.MaxSteadyStateProcessCount
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--SMP affinitization enabled: %S\n",
            ( m_Config.SMPAffinitized ? L"TRUE" : L"FALSE" )
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--SMP affinitization processor mask: %p\n",
            m_Config.SMPAffinitizedProcessorMask
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Pinging enabled: %S\n",
            ( m_Config.PingingEnabled ? L"TRUE" : L"FALSE" )
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Idle timeout (zero means disabled): %lu\n",
            m_Config.IdleTimeoutInMinutes
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Rapid fail protection enabled: %S\n",
            ( m_Config.RapidFailProtectionEnabled ? L"TRUE" : L"FALSE" )
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Rapid fail protection time limit ( in milliseconds ) : %lu\n",
            m_Config.RapidFailProtectionIntervalMS
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Rapid fail protection max crashes : %lu\n",
            m_Config.RapidFailProtectionMaxCrashes
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Orphan processes for debugging enabled: %S\n",
            ( m_Config.OrphanProcessesForDebuggingEnabled ? L"TRUE" : L"FALSE" )
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Startup time limit (in seconds): %lu\n",
            m_Config.StartupTimeLimitInSeconds
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Shutdown time limit (in seconds): %lu\n",
            m_Config.ShutdownTimeLimitInSeconds
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Ping interval (in seconds): %lu\n",
            m_Config.PingIntervalInSeconds
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Ping response time limit (in seconds): %lu\n",
            m_Config.PingResponseTimeLimitInSeconds
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Disallow overlapping rotation (false means overlap is ok): %S\n",
            ( m_Config.DisallowOverlappingRotation ? L"TRUE" : L"FALSE" )
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Orphan action: %S\n",
            ( m_Config.pOrphanAction ? m_Config.pOrphanAction : L"<none>" )
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--UL app pool queue length max: %lu\n",
            m_Config.UlAppPoolQueueLength
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Disallow rotation on config changes (false means rotation is ok): %S\n",
            ( m_Config.DisallowRotationOnConfigChanges ? L"TRUE" : L"FALSE" )
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--User runas type (0 - local system, 1 - local service, 2 - network service, 3 - specific): %d\n",
            ( m_Config.UserType )
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--LogonMethod (0 - interactive, 1 - batch, 2 - network): %d\n",
            ( m_Config.LogonMethod )
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--CPUAction (0 - log, 1 - kill, 2 - trace?, 3 - throttle?): %d\n",
            ( m_Config.CPUAction )
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--CPULimit (0-100,000): %d\n",
            ( m_Config.CPULimit )
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--CPUResetInterval (minutes): %d\n",
            ( m_Config.CPUResetInterval )
            ));

    }

    //
    // List the applications of this app pool.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            ">>>>App pool's applications:\n"
            ));
    }


    pListEntry = m_ApplicationListHead.Flink;

    while ( pListEntry != &m_ApplicationListHead )
    {
    
        DBG_ASSERT( pListEntry != NULL );

        pApplication = APPLICATION::ApplicationFromAppPoolListEntry( pListEntry );


        IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                ">>>>>>>>Application of site: %lu with path: %S\n",
                pApplication->GetApplicationId()->VirtualSiteId,
                pApplication->GetApplicationId()->pApplicationUrl
                ));
        }


        pListEntry = pListEntry->Flink;

    }


    return;
    
}   // APP_POOL::DebugDump
#endif  // DBG



/***************************************************************************++

Routine Description:

    Wait asynchronously for a demand start request from UL for this app 
    pool. This is done by posting an async i/o to UL. This i/o will be 
    completed by UL to request that a worker process be started for this
    app pool.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::WaitForDemandStart(
    )
{

    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;
    WORK_ITEM * pWorkItem = NULL; 


    //
    // Create a work item to use for the async i/o, so that the resulting
    // work can be serviced on the main worker thread via the work queue.
    // 

    hr = GetWebAdminService()->GetWorkQueue()->GetBlankWorkItem( &pWorkItem );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not get a blank work item\n"
            ));

        goto exit;
    }


    pWorkItem->SetWorkDispatchPointer( this );
    
    pWorkItem->SetOpCode( DemandStartAppPoolWorkItem );


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "About to issue demand start for app pool (ptr: %p; id: %S) using work item with serial number: %li\n",
            this,
            GetAppPoolId(),
            pWorkItem->GetSerialNumber()
            ));
    }


    Win32Error = HttpWaitForDemandStart(
                        m_AppPoolHandle,            // app pool handle
                        NULL,                       // buffer (not needed)
                        0,                          // buffer length (not needed)
                        NULL,                       // bytes returned (not needed)
                        pWorkItem->GetOverlapped()  // OVERLAPPED
                        );

    if ( Win32Error != ERROR_IO_PENDING )
    {
        //
        // The UL api specifies that we always get pending here on success,
        // and so will receive a completion later (as opposed to potentially
        // completing immediately, with NO_ERROR). Assert just to confirm this.
        //

        DBG_ASSERT( Win32Error != NO_ERROR );


        hr = HRESULT_FROM_WIN32( Win32Error );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Issuing demand start async i/o failed\n"
            ));


        //
        // If queueing failed, free the work item here. (In the success case,
        // it will be freed once it is serviced.)
        //
        GetWebAdminService()->GetWorkQueue()->FreeWorkItem( pWorkItem );

        goto exit;
    }


    m_WaitingForDemandStart = TRUE;


exit:

    return hr;

}   // APP_POOL::WaitForDemandStart



/***************************************************************************++

Routine Description:

    Respond to a demand start request from UL by attempting to start a new 
    worker process.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::DemandStartWorkItem(
    )
{

    HRESULT hr = S_OK;


    //
    // Since we've come out of the wait for demand start, clear the flag.
    //

    m_WaitingForDemandStart = FALSE;


    //
    // Check to see if we should actually create the new process. 
    //

    if ( ! IsOkToCreateWorkerProcess() )
    {
        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Demand start request received for app pool (ptr: %p; id: %S); creating worker process\n",
            this,
            GetAppPoolId()
            ));
    }


    //
    // Create the process.
    //

    hr = CreateWorkerProcess( 
                DemandStartWorkerProcessStartReason, 
                NULL,
                GetAffinityMaskForNewProcess()
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not create worker process\n"
            ));


        //
        // We've made an effort to demand start a process. Generally this
        // won't fail, but in a weird case where it does (say for example
        // that the worker process exe can't find a dependent dll), then
        // don't treat this as a service-fatal error. Instead, return S_OK.
        //

        hr = S_OK;

        goto exit;
    }


exit:

    return hr;

}   // APP_POOL::DemandStartWorkItem



/***************************************************************************++

Routine Description:

    Check whether it is ok to create a new worker process. 

Arguments:

    None.

Return Value:

    BOOL - TRUE if it is ok to create a worker process, FALSE if not.

--***************************************************************************/

BOOL
APP_POOL::IsOkToCreateWorkerProcess(
    )
    const
{

    BOOL OkToCreate = TRUE; 

    
    //
    // If we are in some state other than the normal running state (for
    // example, if we are shutting down), don't create more worker 
    // processes.
    //

    if ( m_State != RunningAppPoolState )
    {
        OkToCreate = FALSE; 

        goto exit;
    }


    //
    // in BC Mode we don't care about the number of worker processes created
    // this is because we may still have on that is shutting down while we have
    // another one being started due to an inetinfo crash and iisreset being 
    // enabled.
    //

    //
    // Don't create new processes if we would exceed the configured limit.
    // or if we are in backward compatibility mode, ignore the limit and
    // never allow a second worker process to be created. (just in case)
    //

    if ( m_WorkerProcessCount >= m_AdjustedMaxSteadyStateProcessCount 
         &&  GetWebAdminService()->IsBackwardCompatibilityEnabled() == FALSE )
    {
        OkToCreate = FALSE; 

        goto exit;
    }


    //
    // If the system is experiencing extreme memory pressure, then 
    // don't worsen the situation by creating more worker processes.
    // 

    if ( GetWebAdminService()->GetLowMemoryDetector()->IsSystemInLowMemoryCondition() )
    {
        OkToCreate = FALSE; 

        goto exit;
    }

exit:

    // We should never ask for a worker process to be created and
    // be denied in backward compatibility mode.
    //
    // Worst case is a low memory situation and the server goes down
    // but this is better than if the svchost side stays up and the
    // inetinfo part is not up.
    if ( !OkToCreate &&
         GetWebAdminService()->IsBackwardCompatibilityEnabled() )
    {           
        DBG_REQUIRE ( GetWebAdminService()->RequestStopService(FALSE) == S_OK );
    }

    return OkToCreate; 

}   // APP_POOL::IsOkToCreateWorkerProcess



/***************************************************************************++

Routine Description:

    Check whether it is ok to replace a worker process. 

Arguments:

    None.

Return Value:

    BOOL - TRUE if it is ok to replace a worker process, FALSE if not.

--***************************************************************************/

BOOL
APP_POOL::IsOkToReplaceWorkerProcess(
    )
    const
{

    BOOL OkToReplace = TRUE; 
    ULONG ProcessesGoingAwaySoon = 0;
    ULONG SteadyStateProcessCount = 0;

    
    //
    // If we are in some state other than the normal running state (for
    // example, if we are shutting down), don't replace processes.
    //

    if ( m_State != RunningAppPoolState )
    {
        OkToReplace = FALSE; 

        goto exit;
    }


    if ( m_Config.DisallowOverlappingRotation )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "For app pool (ptr: %p; id: %S), disallowing replace because overlapping replacement not allowed\n",
                this,
                GetAppPoolId()
                ));
        }

        OkToReplace = FALSE; 

        goto exit;
    }


    //
    // If the maximum number of processes has been adjusted down on 
    // the fly, we disallow replacement of processes while the steady
    // state process count remains over the new maximum. (This will
    // casue a process requesting replacement to instead just spin 
    // down, helping us throttle down to the new max.) To do this, we 
    // check the current number of processes that are *not* being 
    // replaced against the current max. 
    //

    ProcessesGoingAwaySoon = GetCountOfProcessesGoingAwaySoon();

    SteadyStateProcessCount = m_WorkerProcessCount - ProcessesGoingAwaySoon;

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "For app pool (ptr: %p; id: %S), total WPs: %lu; steady state WPs: %lu; WPs going away soon: %lu; max steady state allowed: %lu\n",
            this,
            GetAppPoolId(),
            m_WorkerProcessCount,
            SteadyStateProcessCount,
            ProcessesGoingAwaySoon,
            m_AdjustedMaxSteadyStateProcessCount
            ));
    }


    if ( SteadyStateProcessCount > m_AdjustedMaxSteadyStateProcessCount )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "For app pool (ptr: %p; id: %S), disallowing replace because we are over the process count limit\n",
                this,
                GetAppPoolId()
                ));
        }

        OkToReplace = FALSE; 

        goto exit;
    }


    //
    // If we are orphaning, and the system is experiencing extreme memory 
    // pressure, then don't potentially worsen the situation by creating 
    // more replacement worker processes. This is because the replacee may 
    // be orphaned, and so we've ended up with two worker processes when
    // we used to have one. 
    // 

    if ( IsOrphaningProcessesForDebuggingEnabled() &&
         GetWebAdminService()->GetLowMemoryDetector()->IsSystemInLowMemoryCondition() )
    {
        OkToReplace = FALSE; 

        goto exit;
    }


exit:

    return OkToReplace; 

}   // APP_POOL::IsOkToReplaceWorkerProcess



/***************************************************************************++

Routine Description:

    Determine the set of worker processes that are currently being replaced.

Arguments:

    None.

Return Value:

    ULONG - The count of processes being replaced. 

--***************************************************************************/

ULONG
APP_POOL::GetCountOfProcessesGoingAwaySoon(
    )
    const
{

    PLIST_ENTRY pListEntry = NULL;
    PLIST_ENTRY pNextListEntry = NULL;
    WORKER_PROCESS * pWorkerProcess = NULL;
    ULONG ProcessesGoingAwaySoon = 0;


    //
    // Count the number of processes being replaced.
    //


    pListEntry = m_WorkerProcessListHead.Flink;


    while ( pListEntry != &m_WorkerProcessListHead )
    {

        DBG_ASSERT( pListEntry != NULL );

        pNextListEntry = pListEntry->Flink;

        pWorkerProcess = WORKER_PROCESS::WorkerProcessFromListEntry( pListEntry );


        if ( pWorkerProcess->IsGoingAwaySoon() )
        {
            ProcessesGoingAwaySoon++;
        }


        pListEntry = pNextListEntry;
        
    }


    return ProcessesGoingAwaySoon;

}   // APP_POOL::GetCountOfProcessesGoingAwaySoon



/***************************************************************************++

Routine Description:

    Create a new worker process for this app pool.

Arguments:

    StartReason - The reason the worker process is being started.

    pWorkerProcessToReplace - If the worker process is being created to replace
    an existing worker process, this parameter identifies that predecessor 
    process; NULL otherwise.

    ProcessAffinityMask - If this worker process is to run on a particular
    processor, this mask specifies which one. If this parameter is zero, this 
    worker process will not be affinitized. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::CreateWorkerProcess(
    IN WORKER_PROCESS_START_REASON StartReason,
    IN WORKER_PROCESS * pWorkerProcessToReplace OPTIONAL,
    IN DWORD_PTR ProcessAffinityMask OPTIONAL
    )
{

    HRESULT hr = S_OK;
    HRESULT hr2 = S_OK;
    WORKER_PROCESS * pWorkerProcess = NULL;


    pWorkerProcess = new WORKER_PROCESS( 
                                this,
                                StartReason,
                                pWorkerProcessToReplace,
                                ProcessAffinityMask
                                );

    if ( pWorkerProcess == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating WORKER_PROCESS failed\n"
            ));


        //
        // If we couldn't even create the object, then it certainly isn't
        // going to be able to tell us when it's startup attempt is done;
        // so instead we attempt to do it here.
        //

        hr2 = WorkerProcessStartupAttemptDone( DemandStartWorkerProcessStartReason, NULL );

        if ( FAILED( hr2 ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr2,
                "Notifying that worker process startup attempt is done failed\n"
                ));

        }


        goto exit;
    }


    InsertHeadList( &m_WorkerProcessListHead, pWorkerProcess->GetListEntry() );
    m_WorkerProcessCount++;

    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Initializing new worker process\n"
            ));
    }


    hr = pWorkerProcess->Initialize();
    
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing worker process object failed\n"
            ));

        //
        // Note that if worker process initialization fails, it will
        // mark itself as terminally ill, and terminate itself. That
        // Terminate method will call back into this app pool instance
        // to remove it from the datastructure, and dereference it.
        //

        goto exit;
    }

exit:

    return hr;
    
}   // APP_POOL::CreateWorkerProcess



/***************************************************************************++

Routine Description:

    Determine based on our config settings exactly which processors may be
    used, and what our maximum steady state process limit is.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
APP_POOL::DetermineAvailableProcessorsAndProcessCount(
    )
{

    SYSTEM_INFO SystemInfo;
    ULONG NumberOfAvailableProcessors = 0;


    //
    // Initialize our private variable for the max steady state process count. 
    //

    m_AdjustedMaxSteadyStateProcessCount = m_Config.MaxSteadyStateProcessCount;


    if ( m_Config.SMPAffinitized )
    {

        //
        // Initialize the available processor mask to be the system processor
        // mask, restricted by the per app pool processor mask.
        //

        ZeroMemory( &SystemInfo, sizeof( SystemInfo ) );


        GetSystemInfo( &SystemInfo );

        DBG_ASSERT( CountOfBitsSet( SystemInfo.dwActiveProcessorMask ) == SystemInfo.dwNumberOfProcessors );


        m_AvailableProcessorMask = SystemInfo.dwActiveProcessorMask & m_Config.SMPAffinitizedProcessorMask;


        //
        // Restrict the max steady state process count based on the number
        // of available processors.
        //

        NumberOfAvailableProcessors = CountOfBitsSet( m_AvailableProcessorMask );


        if ( m_AdjustedMaxSteadyStateProcessCount > NumberOfAvailableProcessors )
        {
            m_AdjustedMaxSteadyStateProcessCount = NumberOfAvailableProcessors; 
        }


        //
        // Validate that the config is reasonable.
        //

        //
        // BUGBUG Should this check be done in the config store as part of
        // it's validation code? 
        //

        if ( NumberOfAvailableProcessors == 0 )
        {

            //
            // Log an event: SMP affinitization mask set such that no processors
            // may be used.
            //

            const WCHAR * EventLogStrings[1];

            EventLogStrings[0] = m_pAppPoolId;

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_SMP_MASK_NO_PROCESSORS,       // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    0                                       // error code
                    );

        }


        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "SMP Affinitization enabled for app pool (ptr: %p; id: %S), available processors mask: %p\n",
                this,
                GetAppPoolId(),
                m_AvailableProcessorMask
                ));
        }

    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "App pool's (ptr: %p; id: %S) adjusted max (steady state) process count: %lu\n",
            this,
            GetAppPoolId(),
            m_AdjustedMaxSteadyStateProcessCount
            ));
    }


    return;

}   // APP_POOL::DetermineAvailableProcessorsAndProcessCount



/***************************************************************************++

Routine Description:

    Determine what affinity mask to use for a new process. If we are running
    in SMP affinitized mode, then find an unused processor. Otherwise, 
    return an empty mask. 

Arguments:

    None.

Return Value:

    DWORD_PTR - The new affinity mask to use. 

--***************************************************************************/

DWORD_PTR
APP_POOL::GetAffinityMaskForNewProcess(
    )
    const
{

    if ( m_Config.SMPAffinitized )
    {

        //
        // Find a free processor for this new worker process.
        //

        return ChooseFreeProcessor();

    }
    else
    {

        //
        // We are not running affinitized, so use the empty mask.
        //

        return 0;

    }

}   // APP_POOL::GetAffinityMaskForNewProcess



/***************************************************************************++

Routine Description:

    Find an unused processor for a new worker process.

Arguments:

    None.

Return Value:

    DWORD_PTR - The new affinity mask to use. 

--***************************************************************************/

DWORD_PTR
APP_POOL::ChooseFreeProcessor(
    )
    const
{

    DWORD_PTR ProcessorsCurrentlyInUse = 0;
    DWORD_PTR AvailableProcessorsNotInUse = 0;
    DWORD_PTR ProcessorMask = 1;


    //
    // Find the set of processors that we are allowed to use, but that
    // are not currently in use.
    //

    ProcessorsCurrentlyInUse = GetProcessorsCurrentlyInUse();

    AvailableProcessorsNotInUse = m_AvailableProcessorMask & ( ~ ProcessorsCurrentlyInUse );


    //
    // There should be at least one free processor.
    //
    
    DBG_ASSERT( CountOfBitsSet( AvailableProcessorsNotInUse ) >= 1 );


    //
    // Now find a free processor.
    //

    while ( ProcessorMask )
    {
    
        if ( AvailableProcessorsNotInUse & ProcessorMask )
        {
            break;
        }

        ProcessorMask <<= 1;
        
    }


    DBG_ASSERT( ProcessorMask != 0 );


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "SMP affinitization: processors currently in use: %p; available processors not in use: %p; free processor selected: %p\n",
            ProcessorsCurrentlyInUse,
            AvailableProcessorsNotInUse,
            ProcessorMask
            ));
    }


    return ProcessorMask;

}   // APP_POOL::ChooseFreeProcessor



/***************************************************************************++

Routine Description:

    Determine the set of processors in currently in use by worker processes
    of this app pool.

Arguments:

    None.

Return Value:

    DWORD_PTR - The set of processors in use. 

--***************************************************************************/

DWORD_PTR
APP_POOL::GetProcessorsCurrentlyInUse(
    )
    const
{

    PLIST_ENTRY pListEntry = NULL;
    PLIST_ENTRY pNextListEntry = NULL;
    WORKER_PROCESS * pWorkerProcess = NULL;
    DWORD_PTR ProcessorsCurrentlyInUse = 0;


    //
    // Logical OR the affinity masks of all current worker processes of this
    // app pool together, in order to get the set of processors in use.
    //


    pListEntry = m_WorkerProcessListHead.Flink;


    while ( pListEntry != &m_WorkerProcessListHead )
    {

        DBG_ASSERT( pListEntry != NULL );

        pNextListEntry = pListEntry->Flink;

        pWorkerProcess = WORKER_PROCESS::WorkerProcessFromListEntry( pListEntry );


        //
        // Update the mask. Note that some processes might be affinitized to 
        // the same processor. This is because during process rotation, the 
        // replacement process will start up with the same affinitization as
        // the process it is retiring. Also note that a process which is not
        // affinitized will return 0 for its mask, which does the right thing.
        //

        ProcessorsCurrentlyInUse |= pWorkerProcess->GetProcessAffinityMask();


        pListEntry = pNextListEntry;
        
    }


    return ProcessorsCurrentlyInUse;

}   // APP_POOL::GetProcessorsCurrentlyInUse



/***************************************************************************++

Routine Description:

    Determine what affinity mask to use for a replacement process. 

Arguments:

    PreviousProcessAffinityMask - The process affinity mask for the process
    being replaced.

    pReplacementProcessAffinityMask - The process affinity mask to use for
    the replacement process.

Return Value:

    HRESULT 

--***************************************************************************/

HRESULT
APP_POOL::GetAffinityMaskForReplacementProcess(
    IN DWORD_PTR PreviousProcessAffinityMask,
    OUT DWORD_PTR * pReplacementProcessAffinityMask
    )
    const
{

    HRESULT hr = S_OK;


    DBG_ASSERT( pReplacementProcessAffinityMask != NULL );


    //
    // Initialize output parameters.
    //

    *pReplacementProcessAffinityMask = 0;


    if ( m_Config.SMPAffinitized )
    {

        //
        // Affinitization is on. 
        //

        if ( ! PreviousProcessAffinityMask )
        {

            //
            // The previous process was not affinitized. Find a free 
            // processor to affinitize this replacement worker process. 
            // There should always be one available in this case (since
            // we know that if we made it this far, then the current 
            // steady state count of processes is within the bounds set
            // by the available processor mask; so there must be at least
            // one processor that has no processes affinitized to it).
            //

            *pReplacementProcessAffinityMask = ChooseFreeProcessor();

        }
        else if ( PreviousProcessAffinityMask & m_AvailableProcessorMask )
        {
        
            //
            // The old mask is still valid. Follow suit with the new one.
            //

            *pReplacementProcessAffinityMask = PreviousProcessAffinityMask;
            
        }
        else
        {
            //
            // The old mask is no longer valid. Signal to callers that we 
            // are not going to replace.
            //

            hr = E_FAIL;

            IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
            {
                DBGPRINTF((
                    DBG_CONTEXT, 
                    "For app pool (ptr: %p; id: %S), not replacing worker process because its affinity mask is no longer valid\n",
                    this,
                    GetAppPoolId()
                    ));
            }

        }

    }
    else
    {

        //
        // We are not running affinitized, so use the empty mask.
        //

        *pReplacementProcessAffinityMask = 0;

    }


    return hr;

}   // APP_POOL::GetAffinityMaskForReplacementProcess



/***************************************************************************++

Routine Description:

    Look up a WORKER_PROCESS object associated with this app pool by
    process id.

Arguments:

    ProcessId - The process id of the worker process to locate.

Return Value:

    WORKER_PROCESS * - Pointer to the located WORKER_PROCESS, or NULL if not
    found.

--***************************************************************************/

WORKER_PROCESS *
APP_POOL::FindWorkerProcess(
    IN DWORD ProcessId
    )
{

    PLIST_ENTRY pListEntry = m_WorkerProcessListHead.Flink;
    WORKER_PROCESS * pWorkerProcess = NULL;
    BOOL FoundIt = FALSE;
    

    while ( pListEntry != &m_WorkerProcessListHead )
    {
    
        DBG_ASSERT( pListEntry != NULL );

        pWorkerProcess = WORKER_PROCESS::WorkerProcessFromListEntry( pListEntry );

        if ( pWorkerProcess->GetProcessId() == ProcessId )
        {
            FoundIt = TRUE;
            break;
        }

        pListEntry = pListEntry->Flink;

    }


    return ( FoundIt ? pWorkerProcess : NULL );
    
}   // APP_POOL::FindWorkerProcess



/***************************************************************************++

Routine Description:

    Disables the application pool by stopping all the worker processes,
    marking the app pool to not issue any more demand starts to Ul, and
    pausing all the applications associated with the app pool. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::DisableAppPool(
    )
{

    HRESULT hr = S_OK;
    HTTP_ENABLED_STATE NewHttpAppPoolState = HttpEnabledStateInactive;
    DWORD Win32Error = NO_ERROR;

    //
    // Only disable running applications.
    //
    if ( m_State != RunningAppPoolState ) 
    {
        return S_OK;
    }

    //
    // Tell http that the app pool is disabled.
    //

    Win32Error = HttpSetAppPoolInformation(
                        m_AppPoolHandle,                // app pool handle
                        HttpAppPoolStateInformation,    // information class
                        reinterpret_cast <VOID *> ( &NewHttpAppPoolState ),  // data
                        sizeof( HTTP_ENABLED_STATE )    // data length
                        );
    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Disabling app pool in http failed\n"
            ));

        goto exit;

    }

    // 
    // Stop the worker processes.
    hr = ShutdownAllWorkerProcesses();
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "shuttind down worker processes failed\n"
            ));

        goto exit;
    }

    hr = ChangeState ( DisabledAppPoolState, TRUE );
    if ( FAILED ( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "changing state of application failed\n"
            ));

        //
        // Don't pass an error back from here, because it will just cause
        // use to attempt to reset the state to not stopped, even though
        // all the real work did complete successfully.
        //

        hr = S_OK;
    }

exit:

    return hr;

}   // APP_POOL::DisableAppPool

/***************************************************************************++

Routine Description:

    Enables an application pool that has previously been disabled. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
APP_POOL::EnableAppPool(
    )
{

    HRESULT hr = S_OK;
    HTTP_ENABLED_STATE NewHttpAppPoolState = HttpEnabledStateActive;
    DWORD Win32Error = NO_ERROR;

    //
    // Only enable, disabled applications.
    //
    if ( m_State != DisabledAppPoolState &&
         m_State != UninitializedAppPoolState ) 
    {
        // 
        // For now we simply return ok if it is not a
        // disabled application.  I am adding the assert
        // because I believe the internal path
        // never should get here.  
        //
        DBG_ASSERT ( m_State == DisabledAppPoolState &&
                     m_State == UninitializedAppPoolState );
        return S_OK;
    }

    //
    // We need to change this state before enabling 
    // applications because the applications will check
    // the state.
    //
    //
    // Issue:  Do we want to just change state before
    // but not change it in the metabase, and if it all
    // activates correctly we can change state again 
    // after and change the metabase?  Or do we want to 
    // leave it like this?  If we do leave it like this
    // it will be reverted back by the ProcessChange command
    // that calls this. ( assuming we return a bad hr )
    //

    hr = ChangeState ( RunningAppPoolState, TRUE );
    if ( FAILED ( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "changing state of application failed\n"
            ));

        return hr;
    }
    
    Win32Error = HttpSetAppPoolInformation(
                        m_AppPoolHandle,                // app pool handle
                        HttpAppPoolStateInformation,    // information class
                        reinterpret_cast <VOID *> ( &NewHttpAppPoolState ),  // data
                        sizeof( HTTP_ENABLED_STATE )    // data length
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Enabling app pool state in http failed\n"
            ));

        goto exit;

    }

    //
    // See if we should wait asynchronously for a demand start notification
    // from UL for this app pool.  If we are in backward compatibility mode, 
    // then we are not going to do the WaitForDemandStartIfNeeded here, we will
    // request a DemandStartWorkItem once we have finished configuring the system.
    //
    // Note that EnableAppPool will only be called in BC mode when the app
    // pool is first created.  We don't support the ServerCommand to start
    // and stop the app pool.
    //

    hr = WaitForDemandStartIfNeeded();
    if ( FAILED( hr ) )
    {   
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Waiting for demand start notification if needed failed\n"
            ));

        goto exit;
    }

exit:

    return hr;

}   // APP_POOL::EnableAppPool

/***************************************************************************++

Routine Description:

    Attempt to apply a state change command to this object. This could
    fail if the state change is invalid.  In other words, if the state is
    not an acceptable state to be changing to.

Arguments:

    Command - The requested state change command.

    DirectCommand - Whether or not the user is directly controlling this
    app pool or not.  Basically if it is direct then the state will be written
    back to the metabase.  If it is not the state will not be written back.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::ProcessStateChangeCommand(
    IN DWORD Command,
    IN BOOL DirectCommand
    )
{

    HRESULT hr = S_OK;
    HRESULT hr2 = S_OK;
    DWORD ServiceState = 0;
    APP_POOL_STATE AppPoolState = m_State;

    //
    // We only support these two commands on an app pool.
    // This assert may be overactive if config is not safe
    // guarding against the other values.
    //
    DBG_ASSERT ( Command == MD_APPPOOL_COMMAND_START  || 
                 Command == MD_APPPOOL_COMMAND_STOP );

    if ( Command != MD_APPPOOL_COMMAND_START  &&
         Command != MD_APPPOOL_COMMAND_STOP )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Determine the current state of affairs.
    //

    ServiceState = GetWebAdminService()->GetServiceState();


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Received state change command for app pool: %S; command: %lu, app pool state: %lu, service state: %lu\n",
            m_pAppPoolId,
            Command,
            AppPoolState,
            ServiceState
            ));
    }


    //
    // Update the autostart setting if appropriate.
    //

    if ( DirectCommand )
    {

        //
        // Set autostart to TRUE for a direct start command; set it
        // to FALSE for a direct stop command.
        //

        m_Config.AutoStart = ( Command == MD_APPPOOL_COMMAND_START ) ? TRUE : FALSE;

        hr = GetWebAdminService()->GetConfigAndControlManager()->GetConfigManager()->
            SetAppPoolAutostart(
                m_pAppPoolId,
                m_Config.AutoStart
                );

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Setting autostart in config store for app pool failed\n"
                ));

            //
            // Press on in the face of errors.
            //

            hr = S_OK;

        }

    }


    //
    // Figure out which command has been issued, and see if it should
    // be acted on or ignored, given the current state.
    //
    // There is a general rule of thumb that a child entity (such as
    // an virtual site) cannot be made more "active" than it's parent
    // entity currently is (the service). 
    //

    switch ( Command )
    {

    case MD_APPPOOL_COMMAND_START:

        //
        // If the site is stopped, then start it. If it's in any other state,
        // this is an invalid state transition.
        //
        // Note that the service must be in the started or starting state in 
        // order to start a site.
        //

        if ( ( ( AppPoolState == UninitializedAppPoolState ) ||
               ( AppPoolState == DisabledAppPoolState ) ) &&
             ( ( ServiceState == SERVICE_RUNNING ) ||
               ( ServiceState == SERVICE_START_PENDING ) ) )
        {

            //
            // If this is a flowed (not direct) command, and autostart is false, 
            // then ignore this command. In other words, the user has indicated
            // that this site should not be started at service startup, etc.
            //

            // 
            // Issue:  Since we set the AutoStart above in the Direct case, this
            //         decision does not have to be so complicated.
            //

            if ( ( ! DirectCommand ) && ( ! m_Config.AutoStart ) )
            {

                IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
                {
                    DBGPRINTF((
                        DBG_CONTEXT, 
                        "Ignoring flowed site start command because autostart is false for app pool: %S\n",
                        GetAppPoolId()
                        ));
                }

            }
            else
            {

                hr = EnableAppPool();

            }

        }
        else 
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_SERVICE_CONTROL );
        }

        break;

    case MD_APPPOOL_COMMAND_STOP:

        //
        // If the site is started, then stop it. If it's in 
        // any other state, this is an invalid state transition.
        //
        // Note that since we are making the app pool less active,
        // we can ignore the state of the service.  
        //

        if ( ( AppPoolState == RunningAppPoolState ) )
        {

            hr = DisableAppPool();

        } 
        else 
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_SERVICE_CONTROL );
        }

        break;


    default:

        //
        // Invalid command!
        //

        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;

    }


    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Executing app pool state change command failed\n"
            ));


        //
        // In case of failure, reset to the state we were in to start with
        //

        hr2 = ChangeState( AppPoolState, TRUE );

        if ( FAILED( hr2 ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr2,
                "Changing app pool state failed\n"
                ));

            //
            // Ignore failures here and press on...
            //

        }

    }

    return hr;

}   // APP_POOL::ProcessStateChangeCommand

/***************************************************************************++

Routine Description:

    Update the state of this object.

Arguments:

    NewState - The state we are attempting to change the app pool to.

    WriteToMetabase - Flag to notify if we should actually update the metabase 
                      with the new state or not.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::ChangeState(
    IN APP_POOL_STATE NewState,
    IN BOOL  WriteToMetabase
    )
{

    HRESULT hr = S_OK;

    m_State = NewState;

    if ( WriteToMetabase )
    {
        hr = RecordState();
        if ( FAILED ( hr ) )
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Setting state in config store for app pool failed\n"
                ));

            //
            // Press on in the face of errors.
            //

            hr = S_OK;

        }
    }

    return hr;

}   // VIRTUAL_SITE::ChangeState

/***************************************************************************++

Routine Description:

    Write the current state of this object to the metabase

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
APP_POOL::RecordState(
    )
{

    HRESULT hr = S_OK;
    DWORD ConfigState = 0;

    if ( m_State == RunningAppPoolState ) 
    {
        ConfigState = MD_APPPOOL_STATE_STARTED;
    }
    else
    {
        ConfigState = MD_APPPOOL_STATE_STOPPED;
    }

    hr = GetWebAdminService()->GetConfigAndControlManager()->GetConfigManager()->
        SetAppPoolState(
            m_pAppPoolId,
            ConfigState
            );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting state in config store for app pool failed\n"
            ));

    }

    return hr;

}   // VIRTUAL_SITE::RecordState

/***************************************************************************++

Routine Description:

    Recycles all worker processes in an app pool.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
APP_POOL::RecycleWorkerProcesses(
    )
{

    HRESULT hr = S_OK;
    PLIST_ENTRY pListEntry = NULL;
    PLIST_ENTRY pNextListEntry = NULL;
    WORKER_PROCESS * pWorkerProcess = NULL;


    DBG_ASSERT( GetWebAdminService()->IsBackwardCompatibilityEnabled() == FALSE );

    //
    // Only recycle enabled app pools.
    //
    if ( m_State != RunningAppPoolState ) 
    {
        return HRESULT_FROM_WIN32(ERROR_OBJECT_NOT_FOUND);
    }


    pListEntry = m_WorkerProcessListHead.Flink;


    while ( pListEntry != &m_WorkerProcessListHead )
    {

        DBG_ASSERT( pListEntry != NULL );

        pNextListEntry = pListEntry->Flink;

        pWorkerProcess = WORKER_PROCESS::WorkerProcessFromListEntry( pListEntry );


        //
        // Shutdown the worker process. Note that the worker process will
        // eventually clean itself up and remove itself from this list;
        // this could happen later, but it also could happen immediately!
        // This is the reason we captured the next list entry pointer 
        // above, instead of trying to access the memory after the object
        // may have gone away.
        //

        hr = pWorkerProcess->InitiateReplacement();

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Failed to start a replacement of a worker process\n"
                ));

            goto exit;

        }


        pListEntry = pNextListEntry;
        
    }


exit:

    return hr;

}   // APP_POOL::RecycleWorkerProcesses

/***************************************************************************++

Routine Description:

    There has a been a config change that requires rotating the worker 
    processes for this app pool, in order to fully effect the change. If
    it is allowed, rotate them all. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::HandleConfigChangeAffectingWorkerProcesses(
    )
{

    HRESULT hr = S_OK;

    
    if ( m_Config.DisallowRotationOnConfigChanges )
    {
        //
        // We are not allowed to rotate on config changes. 
        //

        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "NOT rotating worker processes of app pool (ptr: %p; id: %S) on config change, as this behavior has been configured off\n",
                this,
                GetAppPoolId()
                ));
        }

        goto exit;
    }


    //
    // Rotate all worker processes to ensure that the config changes take 
    // effect. 
    //

    hr = ReplaceAllWorkerProcesses();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Replacing all worker processes failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // APP_POOL::HandleConfigChangeAffectingWorkerProcesses

/***************************************************************************++

Routine Description:

    Shut down all worker processes serving this app pool.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::ShutdownAllWorkerProcesses(
    )
{

    HRESULT hr = S_OK;
    PLIST_ENTRY pListEntry = NULL;
    PLIST_ENTRY pNextListEntry = NULL;
    WORKER_PROCESS * pWorkerProcess = NULL;


    pListEntry = m_WorkerProcessListHead.Flink;


    while ( pListEntry != &m_WorkerProcessListHead )
    {

        DBG_ASSERT( pListEntry != NULL );

        pNextListEntry = pListEntry->Flink;

        pWorkerProcess = WORKER_PROCESS::WorkerProcessFromListEntry( pListEntry );


        //
        // Shutdown the worker process. Note that the worker process will
        // eventually clean itself up and remove itself from this list;
        // this could happen later, but it also could happen immediately!
        // This is the reason we captured the next list entry pointer 
        // above, instead of trying to access the memory after the object
        // may have gone away.
        //

        hr = pWorkerProcess->Shutdown( TRUE );

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Shutdown of worker process failed\n"
                ));

            //
            // Press on in the face of errors on a particular worker process.
            //

            hr = S_OK;
        }


        pListEntry = pNextListEntry;
        
    }


    return hr;

}   // APP_POOL::ShutdownAllWorkerProcesses



/***************************************************************************++

Routine Description:

    Rotate all worker processes serving this app pool.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::ReplaceAllWorkerProcesses(
    )
{

    HRESULT hr = S_OK;
    PLIST_ENTRY pListEntry = NULL;
    PLIST_ENTRY pNextListEntry = NULL;
    WORKER_PROCESS * pWorkerProcess = NULL;


    pListEntry = m_WorkerProcessListHead.Flink;


    while ( pListEntry != &m_WorkerProcessListHead )
    {

        DBG_ASSERT( pListEntry != NULL );

        pNextListEntry = pListEntry->Flink;

        pWorkerProcess = WORKER_PROCESS::WorkerProcessFromListEntry( pListEntry );


        //
        // Tell the worker process to get itself replaced.
        //

        hr = pWorkerProcess->InitiateReplacement();

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Initiating process replacement failed\n"
                ));

            //
            // Press on in the face of errors on a particular worker process.
            //

            hr = S_OK;
        }


        pListEntry = pNextListEntry;
        
    }


    return hr;

}   // APP_POOL::ReplaceAllWorkerProcesses

/***************************************************************************++

Routine Description:

    Inform all worker processes serving this app pool about changes in
    App Pool related parameters    

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::InformAllWorkerProcessesAboutParameterChanges(
    IN APP_POOL_CONFIG_CHANGE_FLAGS * pWhatHasChanged
    )
{

    HRESULT hr = S_OK;
    HRESULT hr1 = S_OK;

    PLIST_ENTRY pListEntry = NULL;
    PLIST_ENTRY pNextListEntry = NULL;
    WORKER_PROCESS * pWorkerProcess = NULL;


    pListEntry = m_WorkerProcessListHead.Flink;


    while ( pListEntry != &m_WorkerProcessListHead )
    {

        DBG_ASSERT( pListEntry != NULL );

        pNextListEntry = pListEntry->Flink;

        pWorkerProcess = WORKER_PROCESS::WorkerProcessFromListEntry( pListEntry );

        hr1 = pWorkerProcess->SendWorkerProcessRecyclerParameters( 
                                                pWhatHasChanged );

        if ( FAILED( hr1 ) )
        {
            hr = hr1;
        }
        pListEntry = pNextListEntry;
        
    }

    return hr;

}   // APP_POOL::InformAllWorkerProcessesAboutParameterChanges

/***************************************************************************++

Routine Description:

    See if shutdown is underway. If it is, see if shutdown has finished. If
    it has, clean up this instance. 

    Note that this function may cause the instance to delete itself; 
    instance state should not be accessed when unwinding from this call. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::CheckIfShutdownUnderwayAndNowCompleted(
    )
{

    HRESULT hr = S_OK;


    //
    // Are we shutting down?
    //

    if ( m_State == ShutdownPendingAppPoolState )
    {

        //
        // If so, have all the worker processes gone away, meaning that 
        // we are done?
        //

        if ( m_WorkerProcessCount == 0 )
        {

            //
            // Clean up this instance.
            //

            Terminate( TRUE );

        }

    }


    return hr;

}   // APP_POOL::CheckIfShutdownUnderwayAndNowCompleted

/***************************************************************************++

Routine Description:

    Function will set the m_WorkerProccessLaunchToken to be the correct
    token to launch all worker processes under.  If it fails we will log
    an error in the calling function, and then leave it alone.  We will fail
    any attempt to launch a worker process.

Arguments:

    LPWSTR pUserName
    LPWSTR pUserPassword
    APP_POOL_USER_TYPE usertype

Return Value:

    HRESULT

--***************************************************************************/
HRESULT 
APP_POOL::SetTokenForWorkerProcesses(
    IN LPWSTR pUserName,
    IN LPWSTR pUserPassword,
    IN DWORD usertype,
    IN DWORD logonmethod
    )
{
    HRESULT hr = S_OK;

    //
    // Only if we created the worker process token using a LogonUser do
    // we need to close the token before re-assigning it.
    //
    if ( m_pWorkerProcessTokenCacheEntry != NULL )
    {
        m_pWorkerProcessTokenCacheEntry->DereferenceCacheEntry();
        m_pWorkerProcessTokenCacheEntry = NULL;
    }

    switch (usertype)
    {
        case (LocalSystemAppPoolUserType):
            m_pWorkerProcessTokenCacheEntry = GetWebAdminService()->GetLocalSystemTokenCacheEntry();
            m_pWorkerProcessTokenCacheEntry->ReferenceCacheEntry();
        break;

        case (LocalServiceAppPoolUserType):
            m_pWorkerProcessTokenCacheEntry = GetWebAdminService()->GetLocalServiceTokenCacheEntry();
            m_pWorkerProcessTokenCacheEntry->ReferenceCacheEntry();
        break;

        case(NetworkServiceAppPoolUserType):
            m_pWorkerProcessTokenCacheEntry = GetWebAdminService()->GetNetworkServiceTokenCacheEntry();
            m_pWorkerProcessTokenCacheEntry->ReferenceCacheEntry();
        break;

        case (SpecificUserAppPoolUserType):

            if ( pUserName && pUserPassword )  
            {
                DWORD LogonMethodInLogonUserTerms = LOGON32_LOGON_NETWORK_CLEARTEXT;

                switch ( logonmethod )
                {
                    case ( InteractiveAppPoolLogonMethod ):
                        LogonMethodInLogonUserTerms = LOGON32_LOGON_INTERACTIVE;
                    break;

                    case ( BatchAppPoolLogonMethod ):
                        LogonMethodInLogonUserTerms = LOGON32_LOGON_BATCH;
                    break;

                    case ( NetworkAppPoolLogonMethod ):
                        LogonMethodInLogonUserTerms = LOGON32_LOGON_NETWORK;
                    break;

                    case ( NetworkClearTextAppPoolLogonMethod ):
                        LogonMethodInLogonUserTerms = LOGON32_LOGON_NETWORK_CLEARTEXT;
                    break;

                    default:

                        DBG_ASSERT ( 0 );

                }

                hr = CreateTokenForUser(pUserName,
                                        pUserPassword,
                                        LogonMethodInLogonUserTerms,
                                        &m_pWorkerProcessTokenCacheEntry);

                if ( FAILED (hr) )
                {
                    goto exit;
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
                goto exit;
            }

        break;

        default:
            DBG_ASSERT( FALSE );
    }


exit:

    return hr;
}

/***************************************************************************++

Routine Description:

    Function will return a token representing the user the worker processes
    are to run as.

Arguments:

    IN  LPWSTR UserName        -- User the token should represent
    IN  LPWSTR UserPassword    -- Password the token should represent
    OUT HANDLE* pUserToken     -- Token that was created (will be null if we failed)

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
CreateTokenForUser(
    IN  LPWSTR pUserName,
    IN  LPWSTR pUserPassword,
    IN  DWORD  LogonMethod,
    OUT TOKEN_CACHE_ENTRY** ppTokenCacheEntry
    )
{
    HRESULT hr      = S_OK;
    DWORD   dwLogonError = ERROR_SUCCESS;
    TOKEN_CACHE_ENTRY * pTempTokenCacheEntry = NULL;

    DBG_ASSERT(ppTokenCacheEntry);
    DBG_ASSERT(pUserName);
    DBG_ASSERT(pUserPassword);

    //
    // Set the default out parameter.
    //
    *ppTokenCacheEntry = NULL;

    //
    // Attempt to logon as the user.
    //
    hr = GetWebAdminService()->GetTokenCache().GetCachedToken(
                    pUserName,                   // user name
                    L"",                         // domain
                    pUserPassword,               // password
                    LogonMethod,                 // type of logon
                    FALSE,                       // not UPN logon
                    &pTempTokenCacheEntry,       // returned token cache entry
                    &dwLogonError                // Logon Error
                    );

    if (FAILED(hr))
    {
        DBG_ASSERT(NULL == pTempTokenCacheEntry);
        goto exit;
    }

    if (NULL == pTempTokenCacheEntry)
    {
        hr = HRESULT_FROM_WIN32(dwLogonError);
        goto exit;
    }

    *ppTokenCacheEntry = pTempTokenCacheEntry;

exit:

    return hr;

} // end CreateTokenForUser

/***************************************************************************++

Routine Description:

    Return the count of bits set to 1 in the input parameter. 

Arguments:

    Value - The target value on which to count set bits. 

Return Value:

    ULONG - The number of bits that were set. 

--***************************************************************************/

ULONG
CountOfBitsSet(
    IN DWORD_PTR Value
    )
{

    ULONG Count = 0;


    //
    // Note: designed to work independent of the size in bits of the value.
    //

    while ( Value )
    {
    
        if ( Value & 1 )
        {
            Count++;
        }

        Value >>= 1;
        
    }

    return Count;

}   // CountOfBitsSet


/***************************************************************************++

Routine Description:

    Return the count of bytes in MULTISZ including terminating zeroes. 

Arguments:

    pString - MULTISZ string

Return Value:

    DWORD - The number of bytes
    
--***************************************************************************/

DWORD 
GetMultiszByteLength(
    LPWSTR pString
    )
{
    if( pString == 0 )
    {
        return 0;
    }
    DWORD cbString = 0;
    while( * pString != 0 || 
           *(pString + 1) != 0 )
    {
        pString++; 
        cbString++;
    }
    cbString = (cbString + 2) * sizeof (WCHAR);
    return cbString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\app_pool.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    app_pool.h

Abstract:

    The IIS web admin service app pool class definition.

Author:

    Seth Pollack (sethp)        01-Oct-1998

Revision History:

--*/


#ifndef _APP_POOL_H_
#define _APP_POOL_H_



//
// forward references
//

class WORKER_PROCESS;
class UL_AND_WORKER_MANAGER;



//
// common #defines
//

#define APP_POOL_SIGNATURE       CREATE_SIGNATURE( 'APOL' )
#define APP_POOL_SIGNATURE_FREED CREATE_SIGNATURE( 'apoX' )


#define wszDEFAULT_APP_POOL  L"DefaultAppPool"
//
// structs, enums, etc.
//

// app pool user types
typedef enum _APP_POOL_USER_TYPE
{
    //
    // The app pool runs as local system.
    //
    LocalSystemAppPoolUserType = 0,

    // 
    // The app pool runs as local service
    //
    LocalServiceAppPoolUserType,

    //
    // The app pool runs as network service
    //
    NetworkServiceAppPoolUserType,

    //
    // The app pool runs as the specified user
    //
    SpecificUserAppPoolUserType

} APP_POOL_USER_TYPE;

// app pool logon method
// matches the defines for LOGON_METHOD in
// iiscnfg.x
typedef enum _APP_POOL_LOGON_METHOD
{

    // Logon interactively
    InteractiveAppPoolLogonMethod = 0,

    // Logon using batch settings
    BatchAppPoolLogonMethod,

    // Logon using network settings
    NetworkAppPoolLogonMethod,

    // Logon using network clear text settings
    NetworkClearTextAppPoolLogonMethod


} APP_POOL_LOGON_METHOD;

// app pool states
typedef enum _APP_POOL_STATE
{

    //
    // The object is not yet initialized.
    //
    UninitializedAppPoolState = 1,

    //
    // The app pool is running normally.
    //
    RunningAppPoolState,

    //
    // The app pool has been disabled
    // 
    DisabledAppPoolState,

    //
    // The app pool is shutting down. It may be waiting for it's 
    // worker processes to shut down too. 
    //
    ShutdownPendingAppPoolState,

    //
    // This object instance can go away as soon as it's reference 
    // count hits zero.
    //
    DeletePendingAppPoolState,

} APP_POOL_STATE;


// reasons to start a worker process
typedef enum _WORKER_PROCESS_START_REASON
{

    //
    // Starting because of a demand start notification from UL.
    //
    DemandStartWorkerProcessStartReason = 1,

    //
    // Starting as a replacement for an another running worker process.
    //
    ReplaceWorkerProcessStartReason,

} WORKER_PROCESS_START_REASON;


// APP_POOL work items
typedef enum _APP_POOL_WORK_ITEM
{

    //
    // Process a request from UL to demand start a new worker process.
    //
    DemandStartAppPoolWorkItem = 1
   
} APP_POOL_WORK_ITEM;


// app pool configuration
typedef struct _APP_POOL_CONFIG
{

    //
    // How often to rotate worker processes based on time, in minutes. 
    // Zero means disabled.
    //
    ULONG PeriodicProcessRestartPeriodInMinutes;

    //
    // How often to rotate worker processes based on requests handled. 
    // Zero means disabled.
    //
    ULONG PeriodicProcessRestartRequestCount;

    //
    // How often to rotate worker processes based on schedule
    // MULTISZ array of time information
    //                    <time>\0<time>\0\0
    //                    time is of military format hh:mm 
    //                    (hh>=0 && hh<=23)
    //                    (mm>=0 && hh<=59)time, in minutes. 
    // NULL or empty string means disabled.
    //
    LPWSTR pPeriodicProcessRestartSchedule;

    //
    // How often to rotate worker processes based on amount of VM used by process
    // Zero means disabled.
    //
    ULONG PeriodicProcessRestartMemoryUsageInKB;

    //
    // The maximum number of worker processes (in a steady state; 
    // transiently, there may be more than this number running during 
    // process rotation). In a typical configuration this is set to one. 
    // A number greater than one is used for web gardens.
    //
    ULONG MaxSteadyStateProcessCount;

    //
    // Whether worker processes for this app pool should be hard affinitized 
    // to processors. If this option is enabled, then the max steady state
    // process count is cropped down to the number of processors configured 
    // to be used (if the configured max exceeds that count of processors). 
    //
    BOOL SMPAffinitized;

    //
    // If this app pool is running in SMP affinitized mode, this mask can be
    // used to limit which of the processors on the machine are used by this
    // app pool. 
    //
    DWORD_PTR SMPAffinitizedProcessorMask;

    //
    // Whether pinging is enabled. 
    //
    BOOL PingingEnabled;

    //
    // The idle timeout period for worker processes, in minutes. 
    // Zero means disabled.
    //
    ULONG IdleTimeoutInMinutes;

    //
    // Whether rapid, repeated failure protection is enabled (by 
    // automatically pausing all apps in the app pool in such cases.)
    //
    BOOL RapidFailProtectionEnabled;

    //
    // Window for a specific number of failures to take place in.
    //
    DWORD RapidFailProtectionIntervalMS;
    //
    // Number of failures that should cause an app pool to go 
    // into rapid fail protection.
    //
    DWORD RapidFailProtectionMaxCrashes;

    //
    // Whether orphaning of worker processes for debugging is enabled. 
    //
    BOOL OrphanProcessesForDebuggingEnabled;

    //
    // How long a worker process is given to start up, in seconds. 
    // This is measured from when the process is launched, until it
    // registers with the Web Admin Service. 
    //
    ULONG StartupTimeLimitInSeconds;

    //
    // How long a worker process is given to shut down, in seconds. 
    // This is measured from when the process is asked to shut down, 
    // until it finishes and exits. 
    //
    ULONG ShutdownTimeLimitInSeconds;

    //
    // The ping interval for worker processes, in seconds. 
    // This is the interval between ping cycles. This value is ignored
    // if pinging is not enabled. 
    //
    ULONG PingIntervalInSeconds;

    //
    // The ping response time limit for worker processes, in seconds. 
    // This value is ignored if pinging is not enabled. 
    //
    ULONG PingResponseTimeLimitInSeconds;

    //
    // Whether a replacement worker process can be created while the
    // one being replaced is still alive. TRUE means this overlap
    // is not allowed; FALSE means it is allowed.
    //
    BOOL DisallowOverlappingRotation;

    //
    // The command to run on an orphaned worker process. Only used
    // if orphaning is enabled, and if this field is non-NULL.
    //
    LPWSTR pOrphanAction;

    //
    // The maximum number of requests that UL will queue on this app
    // pool, waiting for service by a worker process. 
    //
    ULONG UlAppPoolQueueLength;

    //
    // Whether worker processes should be rotated on configuration 
    // changes, including for example changes to app pool settings that
    // require a process restart to take effect; or site or app control
    // operation (start/stop/pause/continue) that require rotation to
    // guarantee component unloading. TRUE means this rotation
    // is not allowed (which may delay new settings taking effect, 
    // may prevent component unloading, etc.); FALSE means it is allowed. 
    //
    BOOL DisallowRotationOnConfigChanges;


    //
    // Note, when a config object is stored with the APP_POOL 
    // none of this information will be stored.  We will only
    // store the actual token that will be used to launch
    // the worker processes.  These values will be NULL.
    //

    //
    // What type of user should we launch the processes as?
    //
    DWORD UserType;

    //
    // If the type is APP_POOL_USER_SPECIFIED than what is the user account
    //
    LPWSTR  pUserName;

    //
    // What is the password of the user account we wish to run as.
    // 
    LPWSTR  pUserPassword;  
            
    //
    // Tells which type of logon method to use to get the token to 
    // start processes with.
    //
    DWORD LogonMethod;

    //
    // What action to take if the job object user time limit fires.
    DWORD CPUAction;

    //
    // How many 1/1000th % of the processor time can the job use.
    DWORD CPULimit;

    //
    // Over how long do we monitor for the CPULimit (in minutes).
    DWORD CPUResetInterval;

    // 
    // Do we start this app pool on startup?
    BOOL AutoStart;

    // 
    // Tells us if we want to change the state of the app pool.
    // This is only honored on a modification to the app pool change notification.
    DWORD ServerCommand;

    //
    // READ THIS: If you add to or modify this structure, be sure to 
    // update the change flags structure below to match. 
    //

} APP_POOL_CONFIG;


// app pool configuration change flags
typedef struct _APP_POOL_CONFIG_CHANGE_FLAGS
{

    DWORD_PTR PeriodicProcessRestartPeriodInMinutes : 1;
    DWORD_PTR PeriodicProcessRestartRequestCount : 1;
    DWORD_PTR pPeriodicProcessRestartSchedule : 1;
    DWORD_PTR PeriodicProcessRestartMemoryUsageInKB : 1;
    DWORD_PTR MaxSteadyStateProcessCount : 1;
    DWORD_PTR SMPAffinitized : 1;
    DWORD_PTR SMPAffinitizedProcessorMask : 1;
    DWORD_PTR PingingEnabled : 1;
    DWORD_PTR IdleTimeoutInMinutes : 1;
    DWORD_PTR RapidFailProtectionEnabled : 1;
    DWORD_PTR RapidFailProtectionIntervalMS : 1;
    DWORD_PTR RapidFailProtectionMaxCrashes : 1;
    DWORD_PTR OrphanProcessesForDebuggingEnabled : 1;
    DWORD_PTR StartupTimeLimitInSeconds : 1;
    DWORD_PTR ShutdownTimeLimitInSeconds : 1;
    DWORD_PTR PingIntervalInSeconds : 1;
    DWORD_PTR PingResponseTimeLimitInSeconds : 1;
    DWORD_PTR DisallowOverlappingRotation : 1;
    DWORD_PTR pOrphanAction : 1;
    DWORD_PTR UlAppPoolQueueLength : 1;
    DWORD_PTR DisallowRotationOnConfigChanges : 1;
    DWORD_PTR UserType : 1;
    DWORD_PTR pUserName : 1;
    DWORD_PTR pUserPassword : 1;
    DWORD_PTR LogonMethod : 1;
    DWORD_PTR CPUAction : 1;
    DWORD_PTR CPULimit : 1;
    DWORD_PTR CPUResetInterval : 1;
    // Note, we don't care about AutoStart so we don't need a flag
    DWORD_PTR ServerCommand : 1;

} APP_POOL_CONFIG_CHANGE_FLAGS;



//
// prototypes
//

class APP_POOL
    : public WORK_DISPATCH
{

public:

    APP_POOL(
        );

    virtual
    ~APP_POOL(
        );

    virtual
    VOID
    Reference(
        );

    virtual
    VOID
    Dereference(
        );

    virtual
    HRESULT
    ExecuteWorkItem(
        IN const WORK_ITEM * pWorkItem
        );

    HRESULT
    Initialize(
        IN LPCWSTR pAppPoolId,
        IN APP_POOL_CONFIG * pAppPoolConfig
        );

    HRESULT
    SetConfiguration(
        IN APP_POOL_CONFIG * pAppPoolConfig,
        IN APP_POOL_CONFIG_CHANGE_FLAGS * pWhatHasChanged OPTIONAL
        );

    inline
    VOID
    MarkAsInAppPoolTable(
        )
    { m_InAppPoolTable = TRUE; }

    inline
    VOID
    MarkAsNotInAppPoolTable(
        )
    { m_InAppPoolTable = FALSE; }

    inline
    BOOL
    IsInAppPoolTable(
        )
        const
    { return m_InAppPoolTable; }

    inline
    LPCWSTR
    GetAppPoolId(
        )
        const
    { return m_pAppPoolId; }

    inline
    HANDLE
    GetAppPoolHandle(
        )
        const
    { return m_AppPoolHandle; }

    inline
    ULONG
    GetPeriodicProcessRestartPeriodInMinutes(
        )
        const
    { return m_Config.PeriodicProcessRestartPeriodInMinutes; }

    inline
    ULONG
    GetPeriodicProcessRestartRequestCount(
        )
        const
    { return m_Config.PeriodicProcessRestartRequestCount; }

    inline
    ULONG
    GetPeriodicProcessRestartMemoryUsageInKB(
        )
        const
    { return m_Config.PeriodicProcessRestartMemoryUsageInKB; }

    inline
    LPWSTR
    GetPeriodicProcessRestartSchedule(
        )
        const
    { return m_Config.pPeriodicProcessRestartSchedule; }

    inline
    BOOL
    IsPingingEnabled(
        )
        const
    { return m_Config.PingingEnabled; }

    inline
    ULONG
    GetPingIntervalInSeconds(
        )
        const
    { return m_Config.PingIntervalInSeconds; }

    inline
    ULONG
    GetPingResponseTimeLimitInSeconds(
        )
        const
    { return m_Config.PingResponseTimeLimitInSeconds; }

    inline
    ULONG
    GetStartupTimeLimitInSeconds(
        )
        const
    { return m_Config.StartupTimeLimitInSeconds; }

    inline
    ULONG
    GetShutdownTimeLimitInSeconds(
        )
        const
    { return m_Config.ShutdownTimeLimitInSeconds; }

    inline
    BOOL
    IsOrphaningProcessesForDebuggingEnabled(
        )
        const
    { return m_Config.OrphanProcessesForDebuggingEnabled; }

    inline
    LPWSTR
    GetOrphanAction(
        )
        const
    { return m_Config.pOrphanAction; }

    inline
    ULONG
    GetIdleTimeoutInMinutes(
        )
        const
    { return m_Config.IdleTimeoutInMinutes; }

    HRESULT
    AssociateApplication(
        IN APPLICATION * pApplication
        );

    HRESULT
    DissociateApplication(
        IN APPLICATION * pApplication
        );

    HRESULT
    ReportWorkerProcessFailure(
        );

    HRESULT
    RequestReplacementWorkerProcess(
        IN WORKER_PROCESS * pWorkerProcessToReplace
        );

    HRESULT
    AddWorkerProcessToJobObject(
        WORKER_PROCESS* pWorkerProcess
        );


    HRESULT
    WorkerProcessStartupAttemptDone(
        IN WORKER_PROCESS_START_REASON StartReason,
        IN WORKER_PROCESS* pWorkerProcess
        );

    HRESULT
    RemoveWorkerProcessFromList(
        IN WORKER_PROCESS * pWorkerProcess
        );
        
    HRESULT
    Shutdown(
        );

    HRESULT
    RequestCounters(
        OUT DWORD* pNumberOfProcessToWaitFor
        );

    HRESULT
    ResetAllWorkerProcessPerfCounterState(
        );

    VOID
    Terminate(
        IN BOOL IsAppPoolInMetabase
        );

    inline
    PLIST_ENTRY
    GetDeleteListEntry(
        )
    { return &m_DeleteListEntry; }

    static
    APP_POOL *
    AppPoolFromDeleteListEntry(
        IN const LIST_ENTRY * pDeleteListEntry
        );

    HRESULT
    WaitForDemandStartIfNeeded(
        );

    HRESULT
    DemandStartInBackwardCompatibilityMode(
        );

    HANDLE
    GetWorkerProcessToken(
        )
    {
        if (m_pWorkerProcessTokenCacheEntry)
            return m_pWorkerProcessTokenCacheEntry->QueryPrimaryToken();
        else
            return NULL;
    }

    HRESULT
    DisableAppPool(
        );

    HRESULT
    EnableAppPool(
        );

    HRESULT
    RecycleWorkerProcesses(
        );

    HRESULT
    ProcessStateChangeCommand(
        IN DWORD Command,
        IN BOOL DirectCommand
        );

    BOOL
    IsAppPoolRunning(
        )
    {   return ( m_State == RunningAppPoolState ); }

    HRESULT
    RecordState(
        );

#if DBG
    VOID
    DebugDump(
        );
#endif  // DBG

private:

    HRESULT
    ResetAppPoolAccess(
        IN ACCESS_MODE AccessMode
        );

    HRESULT
    WaitForDemandStart(
        );

    HRESULT
    DemandStartWorkItem(
        );

    BOOL
    IsOkToCreateWorkerProcess(
        )
        const;

    BOOL
    IsOkToReplaceWorkerProcess(
        )
        const;

    ULONG
    GetCountOfProcessesGoingAwaySoon(
        )
        const;

    HRESULT
    CreateWorkerProcess(
        IN WORKER_PROCESS_START_REASON StartReason,
        IN WORKER_PROCESS * pWorkerProcessToReplace OPTIONAL,
        IN DWORD_PTR ProcessAffinityMask OPTIONAL
        );

    VOID
    DetermineAvailableProcessorsAndProcessCount(
        );

    DWORD_PTR
    GetAffinityMaskForNewProcess(
        )
        const;

    DWORD_PTR
    ChooseFreeProcessor(
        )
        const;

    DWORD_PTR
    GetProcessorsCurrentlyInUse(
        )
        const;

    HRESULT
    GetAffinityMaskForReplacementProcess(
        IN DWORD_PTR PreviousProcessAffinityMask,
        OUT DWORD_PTR * pReplacementProcessAffinityMask
        )
        const;

    //
    // BUGBUG This method isn't currently used. Do we need it?
    //
    WORKER_PROCESS *
    FindWorkerProcess(
        IN DWORD ProcessId
        );

    HRESULT
    HandleConfigChangeAffectingWorkerProcesses(
        );


    HRESULT
    ShutdownAllWorkerProcesses(
        );

    HRESULT
    ReplaceAllWorkerProcesses(
        );

    HRESULT
    InformAllWorkerProcessesAboutParameterChanges(
        IN APP_POOL_CONFIG_CHANGE_FLAGS * pWhatHasChanged
        );


    HRESULT
    CheckIfShutdownUnderwayAndNowCompleted(
        );

    HRESULT 
    SetTokenForWorkerProcesses(
        IN LPWSTR pUserName,
        IN LPWSTR pUserPassword,
        IN DWORD usertype,
        IN DWORD logonmethod
        );

    HRESULT
    ChangeState(
        IN APP_POOL_STATE   NewState,
        IN BOOL             WriteToMetabase
        );


    DWORD m_Signature;

    LONG m_RefCount;

    // are we in the parent app pool table?
    BOOL m_InAppPoolTable;

    APP_POOL_STATE m_State;

    LPWSTR m_pAppPoolId;

    JOB_OBJECT* m_pJobObject;

    APP_POOL_CONFIG m_Config;

    // UL app pool handle
    HANDLE m_AppPoolHandle;

    BOOL m_WaitingForDemandStart;

    // worker processes for this app pool
    LIST_ENTRY m_WorkerProcessListHead;
    ULONG m_WorkerProcessCount;

    // What handle to launch the worker processess under
    TOKEN_CACHE_ENTRY * m_pWorkerProcessTokenCacheEntry;

    //
    // The maximum number of worker processes (in a steady state; 
    // transiently, there may be more than this number running during 
    // process rotation). In a typical configuration this is set to one. 
    // A number greater than one is used for web gardens. This value is
    // initialized to the value for max processes set in the configuration 
    // store, unless the app pool is running in SMP affinitized mode, in  
    // which case the number is capped at the number of processors configured 
    // to be used. 
    //
    ULONG m_AdjustedMaxSteadyStateProcessCount;

    //
    // A mask of which processors are available for use by this app pool, 
    // used for the SMP affinitized case. A bit set to 1 means that the 
    // processor may be used; a bit set to 0 means that it may not. 
    //
    DWORD_PTR m_AvailableProcessorMask;

    // applications associated with this app pool
    LIST_ENTRY m_ApplicationListHead;
    ULONG m_ApplicationCount;

    // number of planned process rotations done
    ULONG m_TotalWorkerProcessRotations;

    // keep track of worker process failures
    ULONG m_TotalWorkerProcessFailures;
    
    // watch for flurries of failures
    ULONG m_RecentWorkerProcessFailures;
    DWORD m_RecentFailuresWindowBeganTickCount;
    
    // used for building a list of APP_POOLs to delete
    LIST_ENTRY m_DeleteListEntry;

};  // class APP_POOL


//
// helper functions 
//

// BUGBUG: find better home for GetMultiszByteLength

DWORD 
GetMultiszByteLength(
    LPWSTR pString
    );


#endif  // _APP_POOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\app_pool_table.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    app_pool_table.cxx

Abstract:

    This class is a hashtable which manages the set of app pools.

    Threading: Always called on the main worker thread.

Author:

    Seth Pollack (sethp)        01-Oct-1998

Revision History:

--*/



#include "precomp.h"



/***************************************************************************++

Routine Description:

    Shutdown all app pools in the table.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL_TABLE::Shutdown(
    )
{

    DWORD SuccessCount = 0;
    DWORD CountOfElementsInTable = 0;

    
    //
    // BUGBUG Iterating in order to clean up, remove, and delete each 
    // element of the table is difficult to do with lkhash today.
    // GeorgeRe plans to fix this eventually. For now, the alternative
    // is to iterate through the table building up in list of all the 
    // elements, and then go through the list and shutdown, remove, and
    // delete each element -- yuck!!
    //
    // Once this gets fixed, we can see if it is valuable to unify any
    // table management code between the app pool, virtual site,
    // and application tables.
    //
    
    LIST_ENTRY DeleteListHead;
    PLIST_ENTRY pDeleteListEntry = NULL;
    APP_POOL * pAppPool = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;
    HRESULT hr = S_OK;


    InitializeListHead( &DeleteListHead );

    
    CountOfElementsInTable = Size();


    //
    // Note that for good form we grab the write lock since we will be 
    // modifying objects in the table (although no other thread should 
    // touch this data structure anyways).
    //
    
    SuccessCount = Apply( 
                        DeleteAppPoolAction,
                        &DeleteListHead,
                        LKL_WRITELOCK
                        );
    
    DBG_ASSERT( SuccessCount == CountOfElementsInTable );


    // now for each, shut it down
    
    while (  ! IsListEmpty( &DeleteListHead )  )
    {
    
        pDeleteListEntry = RemoveHeadList( &DeleteListHead );

        DBG_ASSERT( pDeleteListEntry != NULL );

        pAppPool = APP_POOL::AppPoolFromDeleteListEntry( pDeleteListEntry );


        //
        // Shutdown the app pool. Because each app pool is reference
        // counted, it will delete itself as soon as it's reference
        // count hits zero.
        //
        
        hr = pAppPool->Shutdown();

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Shutting down app pool failed\n"
                ));

            //
            // Keep going.
            //

            hr = S_OK;
        }

    }


    return hr;

}   // APP_POOL_TABLE::Shutdown

/***************************************************************************++

Routine Description:

    RequestCounters from all app pools in the table.

Arguments:

    OUT DWORD* pNumberOfProcessToWaitFor - returns the number of worker processes
                                           that the perf manager should wait for.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL_TABLE::RequestCounters(
    OUT DWORD* pNumberOfProcessToWaitFor
    )
{

    DWORD SuccessCount = 0;
    DWORD CountOfElementsInTable = 0;

    
    //
    // BUGBUG Iterating in order to clean up, remove, and delete each 
    // element of the table is difficult to do with lkhash today.
    // GeorgeRe plans to fix this eventually. For now, the alternative
    // is to iterate through the table building up in list of all the 
    // elements, and then go through the list and shutdown, remove, and
    // delete each element -- yuck!!
    //
    // Once this gets fixed, we can see if it is valuable to unify any
    // table management code between the app pool, virtual site,
    // and application tables.
    //
    
    LIST_ENTRY DeleteListHead;
    PLIST_ENTRY pDeleteListEntry = NULL;
    APP_POOL * pAppPool = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;
    HRESULT hr = S_OK;
    DWORD NumProcesses = 0;
    DWORD TotalProcesses = 0;


    DBG_ASSERT ( pNumberOfProcessToWaitFor );

    InitializeListHead( &DeleteListHead );

    
    CountOfElementsInTable = Size();


    //
    // Note that for good form we grab the write lock since we will be 
    // modifying objects in the table (although no other thread should 
    // touch this data structure anyways).
    //
    
    SuccessCount = Apply( 
                        DeleteAppPoolAction,
                        &DeleteListHead,
                        LKL_WRITELOCK
                        );
    
    DBG_ASSERT( SuccessCount == CountOfElementsInTable );


    // now for each, shut it down
    
    while (  ! IsListEmpty( &DeleteListHead )  )
    {
    
        pDeleteListEntry = RemoveHeadList( &DeleteListHead );

        DBG_ASSERT( pDeleteListEntry != NULL );

        pAppPool = APP_POOL::AppPoolFromDeleteListEntry( pDeleteListEntry );
        
        //
        // Clear out the number of processes.  Since Request Counters
        // just replaces this value, this isn't neccessary, but it is
        // clean.
        //
        NumProcesses = 0;

        hr = pAppPool->RequestCounters(&NumProcesses);

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Shutting down app pool failed\n"
                ));

            //
            // Keep going.
            //

            hr = S_OK;
        }
        else
        {
            TotalProcesses +=NumProcesses;
        }

    }

    *pNumberOfProcessToWaitFor = TotalProcesses;

    return hr;

}   // APP_POOL_TABLE::RequestCounters


/***************************************************************************++

Routine Description:

    Reset all worker processes's perf counter state so that they
    will accept incoming perf counter messages.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL_TABLE::ResetAllWorkerProcessPerfCounterState(
    )
{

    DWORD SuccessCount = 0;
    DWORD CountOfElementsInTable = 0;

    
    //
    // BUGBUG Iterating in order to clean up, remove, and delete each 
    // element of the table is difficult to do with lkhash today.
    // GeorgeRe plans to fix this eventually. For now, the alternative
    // is to iterate through the table building up in list of all the 
    // elements, and then go through the list and shutdown, remove, and
    // delete each element -- yuck!!
    //
    // Once this gets fixed, we can see if it is valuable to unify any
    // table management code between the app pool, virtual site,
    // and application tables.
    //
    
    LIST_ENTRY DeleteListHead;
    PLIST_ENTRY pDeleteListEntry = NULL;
    APP_POOL * pAppPool = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;
    HRESULT hr = S_OK;


    InitializeListHead( &DeleteListHead );

    
    CountOfElementsInTable = Size();


    //
    // Note that for good form we grab the write lock since we will be 
    // modifying objects in the table (although no other thread should 
    // touch this data structure anyways).
    //
    
    SuccessCount = Apply( 
                        DeleteAppPoolAction,
                        &DeleteListHead,
                        LKL_WRITELOCK
                        );
    
    DBG_ASSERT( SuccessCount == CountOfElementsInTable );


    // now for each, shut it down
    
    while (  ! IsListEmpty( &DeleteListHead )  )
    {
    
        pDeleteListEntry = RemoveHeadList( &DeleteListHead );

        DBG_ASSERT( pDeleteListEntry != NULL );

        pAppPool = APP_POOL::AppPoolFromDeleteListEntry( pDeleteListEntry );
        
        //
        // Clear out the number of processes.  Since Request Counters
        // just replaces this value, this isn't neccessary, but it is
        // clean.
        //
        hr = pAppPool->ResetAllWorkerProcessPerfCounterState();

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Shutting down app pool failed\n"
                ));

            //
            // Keep going.
            //

            hr = S_OK;
        }

    }

    return hr;

}   // APP_POOL_TABLE::ResetAllWorkerProcessPerfCounterState



/***************************************************************************++

Routine Description:

    Begin termination of this object. Tell all referenced or owned entities 
    which may hold a reference to this object to release that reference 
    (and not take any more), in order to break reference cycles. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
APP_POOL_TABLE::Terminate(
    )
{

    DWORD SuccessCount = 0;
    DWORD CountOfElementsInTable = 0;

    
    //
    // BUGBUG Iterating in order to clean up, remove, and delete each 
    // element of the table is difficult to do with lkhash today.
    // GeorgeRe plans to fix this eventually. For now, the alternative
    // is to iterate through the table building up in list of all the 
    // elements, and then go through the list and shutdown, remove, and
    // delete each element -- yuck!!
    //
    // Once this gets fixed, we can see if it is valuable to unify any
    // table management code between the app pool, virtual site,
    // and application tables.
    //
    
    LIST_ENTRY DeleteListHead;
    PLIST_ENTRY pDeleteListEntry = NULL;
    APP_POOL * pAppPool = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;
    HRESULT hr = S_OK;


    InitializeListHead( &DeleteListHead );

    
    CountOfElementsInTable = Size();


    //
    // Note that for good form we grab the write lock since we will be 
    // modifying objects in the table (although no other thread should 
    // touch this data structure anyways).
    //
    
    SuccessCount = Apply( 
                        DeleteAppPoolAction,
                        &DeleteListHead,
                        LKL_WRITELOCK
                        );
    
    DBG_ASSERT( SuccessCount == CountOfElementsInTable );


    // now for each, terminate it
    
    while (  ! IsListEmpty( &DeleteListHead )  )
    {
    
        pDeleteListEntry = RemoveHeadList( &DeleteListHead );

        DBG_ASSERT( pDeleteListEntry != NULL );

        pAppPool = APP_POOL::AppPoolFromDeleteListEntry( pDeleteListEntry );


        //
        // Terminate the app pool. Because each app pool is reference
        // counted, it will delete itself as soon as it's reference
        // count hits zero.
        //

        pAppPool->Terminate( TRUE );
        
    }


    return;

}   // APP_POOL_TABLE::Terminate



/***************************************************************************++

Routine Description:

    A routine that may be applied to all APP_POOLs in the hashtable
    to prepare for shutdown or termination. Conforms to the PFnRecordAction 
    prototype.

Arguments:

    pAppPool - The app pool.

    pDeleteListHead - List head into which to insert the app pool for
    later deletion.

Return Value:

    LK_ACTION - LKA_SUCCEEDED always.

--***************************************************************************/

// note: static!
LK_ACTION
APP_POOL_TABLE::DeleteAppPoolAction(
    IN APP_POOL * pAppPool, 
    IN VOID * pDeleteListHead
    )
{

    DBG_ASSERT( pAppPool != NULL );
    DBG_ASSERT( pDeleteListHead != NULL );


    InsertHeadList( 
        ( PLIST_ENTRY ) pDeleteListHead,
        pAppPool->GetDeleteListEntry()
        );


    return LKA_SUCCEEDED;
    
}   // APP_POOL_TABLE::DeleteAppPoolAction

/***************************************************************************++

Routine Description:

    Requests that all app pools recycle there worker processes.

Arguments:

    pAppPool - The app pool.

    pIgnored - Needed for signature but not used.

Return Value:

    LK_ACTION - LKA_SUCCEEDED always.

--***************************************************************************/
// note: static!
LK_ACTION
APP_POOL_TABLE::RehookAppPoolAction(
    IN APP_POOL * pAppPool, 
    IN VOID * pIgnored
    )
{

    HRESULT hr = S_OK;
    LK_ACTION LkAction = LKA_SUCCEEDED;


    DBG_ASSERT( pAppPool != NULL );
    UNREFERENCED_PARAMETER( pIgnored );
    DBG_ASSERT( GetWebAdminService()->IsBackwardCompatibilityEnabled() == FALSE );

    // let the worker processes know that they should recycle.
    hr = pAppPool->RecycleWorkerProcesses();
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Recyceling the worker process failed\n"
            ));

        LkAction = LKA_FAILED;

        goto exit;
    }

    // let the metabase know that the state of the app pool has changed
    hr = pAppPool->RecordState();
    if ( FAILED ( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Recyceling the worker process failed\n"
            ));

        LkAction = LKA_FAILED;

        goto exit;
    }

exit:

    return LkAction;
    
}   // APP_POOL_TABLE::RehookAppPoolAction


#if DBG
/***************************************************************************++

Routine Description:

    Debug dump the table.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
APP_POOL_TABLE::DebugDump(
    )
{

    DWORD SuccessCount = 0;
    DWORD CountOfElementsInTable = 0;


    CountOfElementsInTable = Size();


    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Dumping app pool table; total count: %lu\n",
            CountOfElementsInTable
            ));
    }


    SuccessCount = Apply( 
                        DebugDumpAppPoolAction,
                        NULL
                        );
    
    DBG_ASSERT( SuccessCount == CountOfElementsInTable );


    return;

}   // APP_POOL_TABLE::DebugDump



/***************************************************************************++

Routine Description:

    A routine that may be applied to all APP_POOLs in the hashtable
    to perform a debug dump. Conforms to the PFnRecordAction prototype.

Arguments:

    pAppPool - The app pool.

    pIgnored - Ignored.

Return Value:

    LK_ACTION - LKA_SUCCEEDED always.

--***************************************************************************/

// note: static!
LK_ACTION
APP_POOL_TABLE::DebugDumpAppPoolAction(
    IN APP_POOL * pAppPool, 
    IN VOID * pIgnored
    )
{

    DBG_ASSERT( pAppPool != NULL );
    UNREFERENCED_PARAMETER( pIgnored );


    pAppPool->DebugDump();


    return LKA_SUCCEEDED;
    
}   // APP_POOL_TABLE::DebugDumpAppPoolAction
#endif  // DBG



/***************************************************************************++

Routine Description:

    Respond to the fact that we have left the low memory condition.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL_TABLE::LeavingLowMemoryCondition(
    )
{

    HRESULT hr = S_OK;
    DWORD SuccessCount = 0;
    DWORD CountOfElementsInTable = 0;


    CountOfElementsInTable = Size();

    SuccessCount = Apply( 
                        LeavingLowMemoryConditionAppPoolAction,
                        NULL
                        );

    //
    // The success count will be less than the number of elements in the table
    // if we went back into low memory.
    //
    if ( SuccessCount < CountOfElementsInTable )
    {

        DBGPRINTF(( 
            DBG_CONTEXT,
            "Did not make it out of low memory, could of been because of re-entering low memory\n"
            ));

        // this is not considered a failure.
    }


    return hr;

}   // APP_POOL_TABLE::LeavingLowMemoryCondition



/***************************************************************************++

Routine Description:

    A routine that may be applied to all APP_POOLs in the hashtable
    to handle leaving the low memory condition. Conforms to the 
    PFnRecordAction prototype.

Arguments:

    pAppPool - The app pool.

    pIgnored - Ignored.

Return Value:

    LK_ACTION

--***************************************************************************/

// note: static!
LK_ACTION
APP_POOL_TABLE::LeavingLowMemoryConditionAppPoolAction(
    IN APP_POOL * pAppPool, 
    IN VOID * pIgnored
    )
{

    HRESULT hr = S_OK;
    LK_ACTION LkAction = LKA_SUCCEEDED;


    DBG_ASSERT( pAppPool != NULL );
    UNREFERENCED_PARAMETER( pIgnored );

    hr = pAppPool->WaitForDemandStartIfNeeded();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Waiting for demand start if needed failed\n"
            ));

        LkAction = LKA_FAILED;
    }

    //
    // Need to check that we didn't just fall back into a low memory condition,
    // if we did we should abort this recovery from the low memory, otherwise we
    // risk entering it again and looping back to try and take a lock on the table
    // that we all ready have taken.
    //
    if ( GetWebAdminService()->GetLowMemoryDetector()->HaveEnteredLowMemoryCondition() )
    {
        return LKA_ABORT;
    }

    return LkAction;
    
}   // APP_POOL_TABLE::LeavingLowMemoryConditionAppPoolAction
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\application.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    application.cxx

Abstract:

    This class encapsulates a single application.

    Threading: Always called on the main worker thread.

Author:

    Seth Pollack (sethp)        04-Nov-1998

Revision History:

--*/



#include "precomp.h"



//
// local prototypes
//

//
// local #defines
//

#define STACK_BUFFER_SIZE_IN_BYTES 128



/***************************************************************************++

Routine Description:

    Constructor for the APPLICATION class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

APPLICATION::APPLICATION(
    )
{

    m_ApplicationId.VirtualSiteId = INVALID_VIRTUAL_SITE_ID;
    m_ApplicationId.pApplicationUrl = NULL;

    m_State = UninitializedApplicationState; 

    m_VirtualSiteListEntry.Flink = NULL;
    m_VirtualSiteListEntry.Blink = NULL;

    m_AppPoolListEntry.Flink = NULL;
    m_AppPoolListEntry.Blink = NULL;

    m_pVirtualSite = NULL;

    m_pAppPool = NULL;

    m_UlConfigGroupId = HTTP_NULL_ID;

    m_DeleteListEntry.Flink = NULL;
    m_DeleteListEntry.Blink = NULL;

    m_ULLogging = FALSE;

    m_Signature = APPLICATION_SIGNATURE;

}   // APPLICATION::APPLICATION



/***************************************************************************++

Routine Description:

    Destructor for the APPLICATION class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

APPLICATION::~APPLICATION(
    )
{

    DWORD Win32Error = NO_ERROR;


    DBG_ASSERT( m_Signature == APPLICATION_SIGNATURE );

    m_Signature = APPLICATION_SIGNATURE_FREED;

    //
    // Clear the virtual site and app pool associations.
    //

    if ( m_pVirtualSite != NULL )
    {
        DBG_REQUIRE( SUCCEEDED( m_pVirtualSite->DissociateApplication( this ) ) );
        m_pVirtualSite = NULL;
    }


    if ( m_pAppPool != NULL )
    {
        DBG_REQUIRE( SUCCEEDED( m_pAppPool->DissociateApplication( this ) ) );

        //
        // Dereference the app pool object, since it is reference counted
        // and we have been holding a pointer to it.
        //

        m_pAppPool->Dereference();

        m_pAppPool = NULL;
    }


    //
    // Delete the UL config group.
    //

    //
    // Http saw us passing down a zero, which means that some initialization
    // probably failed.  Until we understand why we might not be initializing
    // I am putting in this assert.
    //
    DBG_ASSERT (  m_UlConfigGroupId != HTTP_NULL_ID );

    if ( m_UlConfigGroupId != HTTP_NULL_ID )
    {
        Win32Error = HttpDeleteConfigGroup(
                            GetWebAdminService()->GetUlAndWorkerManager()->GetUlControlChannel(),
                                                        // control channel
                            m_UlConfigGroupId           // config group ID
                            );
    }

    DBG_ASSERT( Win32Error == NO_ERROR );


    m_UlConfigGroupId = HTTP_NULL_ID;


    //
    // Free allocated memory.
    //

    if ( m_ApplicationId.pApplicationUrl != NULL )
    {
        // cast away const
        DBG_REQUIRE( GlobalFree( const_cast< LPWSTR >( m_ApplicationId.pApplicationUrl ) ) == NULL );

        m_ApplicationId.pApplicationUrl = NULL;
    }

}   // APPLICATION::~APPLICATION



/***************************************************************************++

Routine Description:

    Initialize the application instance.

Arguments:

    pApplicationId - The identifier (virtual site ID and URL prefix) for the
    application.

    pVirtualSite - The virtual site which owns this application.

    pApplicationConfig - The configuration parameters for this application. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APPLICATION::Initialize(
    IN const APPLICATION_ID * pApplicationId,
    IN VIRTUAL_SITE * pVirtualSite,
    IN APPLICATION_CONFIG * pApplicationConfig
    )
{

    HRESULT hr = S_OK;
    ULONG NumberOfCharacters = 0;

    DBG_ASSERT( pApplicationId != NULL );
    DBG_ASSERT( pApplicationId->pApplicationUrl != NULL );
    DBG_ASSERT( pVirtualSite != NULL );
    DBG_ASSERT( pApplicationConfig != NULL );

    //
    // First, copy the application id.
    //

    //
    // Count the characters, and add 1 for the terminating null.
    //
    
    NumberOfCharacters = wcslen( pApplicationId->pApplicationUrl ) + 1;

    m_ApplicationId.pApplicationUrl =
        ( LPWSTR ) GlobalAlloc( GMEM_FIXED, ( sizeof( WCHAR ) * NumberOfCharacters ) );

    if ( m_ApplicationId.pApplicationUrl == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Allocating memory failed\n"
            ));

        goto exit;
    }


    //
    // Cast away const.
    //
    
    wcscpy(
        const_cast< LPWSTR >( m_ApplicationId.pApplicationUrl ),
        pApplicationId->pApplicationUrl
        );


    m_ApplicationId.VirtualSiteId = pApplicationId->VirtualSiteId;

    //
    // The virtual site IDs better match.
    //

    DBG_ASSERT( m_ApplicationId.VirtualSiteId == pVirtualSite->GetVirtualSiteId() );


    //
    // Next, set up the virtual site association.
    //

    hr = pVirtualSite->AssociateApplication( this );

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Associating application with virtual site failed\n"
            ));

        goto exit;
    }

    //
    // Only set this pointer if the association succeeded.
    //

    m_pVirtualSite = pVirtualSite;


    //
    // Set up the UL config group.
    //

    hr = InitializeConfigGroup();

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Initializing config group failed\n"
            ));

        goto exit;
    }


    //
    // Set the initial configuration, including telling UL about it. 
    //

    hr = SetConfiguration( pApplicationConfig, NULL );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting application configuration failed\n"
            ));

        goto exit;
    }

    //
    // Activate the application, whether or not it can accept 
    // requests is dependent on the app pool.
    //
    hr = ActivateConfigGroup();
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "activating the config group failed\n"
            ));

        goto exit;
    }

    m_State = InitializedApplicationState;

exit:

    return hr;

}   // APPLICATION::Initialize



/***************************************************************************++

Routine Description:

    Accept a set of configuration parameters for this application. 

Arguments:

    pApplicationConfig - The configuration for this application. 

    pWhatHasChanged - Which particular configuration values were changed.
    This is always provided in change notify cases; it is always NULL in
    initial read cases. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APPLICATION::SetConfiguration(
    IN APPLICATION_CONFIG * pApplicationConfig,
    IN APPLICATION_CONFIG_CHANGE_FLAGS * pWhatHasChanged OPTIONAL
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( pApplicationConfig != NULL );


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "New configuration for application of site: %lu with path: %S\n",
            GetApplicationId()->VirtualSiteId,
            GetApplicationId()->pApplicationUrl
            ));
    }

    //
    // See if the app pool has been set or changed, and if so, handle it.
    //

    if ( ( pWhatHasChanged == NULL ) || ( pWhatHasChanged->pAppPoolId ) )
    {

        hr = SetAppPool( pApplicationConfig->pAppPool );

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Setting new app pool for application failed\n"
                ));

            goto exit;
        }

    }


#if DBG
    //
    // Dump the configuration.
    //

    DebugDump();
#endif  // DBG


exit:

    return hr;

}   // APPLICATION::SetConfiguration


/***************************************************************************++

Routine Description:

    Re-register all URLs with UL, by tossing the currently registered ones,
    and re-doing the registration. This is done when the site bindings 
    change.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APPLICATION::ReregisterURLs(
    )
{

    DWORD Win32Error = NO_ERROR;
    HRESULT hr = S_OK;


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Bindings change: removing all URLs registered for config group of application of site: %lu with path: %S\n",
            GetApplicationId()->VirtualSiteId,
            GetApplicationId()->pApplicationUrl
            ));
    }

    DBG_ASSERT( m_UlConfigGroupId != HTTP_NULL_ID );

    //
    // Issue:  Do we only want to call this if we have added applications to the URL group. 
    //         It would probably be a good optimization, but I doubt it's neccessary and for
    //         now I am afraid of missing removing urls.
    //
    Win32Error = HttpRemoveAllUrlsFromConfigGroup(
                        GetWebAdminService()->GetUlAndWorkerManager()->GetUlControlChannel(),
                                                        // control channel
                        m_UlConfigGroupId               // config group id
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Removing all URLs from config group failed\n"
            ));

        goto exit;
    }

    //
    // Add the URL(s) which represent this app to the config group.
    //

    hr = AddUrlsToConfigGroup();

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Adding URLs to config group failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // APPLICATION::ReregisterURLs



/***************************************************************************++

Routine Description:

    A static class method to "upcast" from a LIST_ENTRY to an APPLICATION.

Arguments:

    pListEntry - A pointer to the m_VirtualSiteListEntry member of an
    APPLICATION.

Return Value:

    The pointer to the containing APPLICATION.

--***************************************************************************/

// note: static!
APPLICATION *
APPLICATION::ApplicationFromVirtualSiteListEntry(
    IN const LIST_ENTRY * pVirtualSiteListEntry
)
{

    APPLICATION * pApplication = NULL;

    DBG_ASSERT( pVirtualSiteListEntry != NULL );

    //  get the containing structure, then verify the signature
    pApplication = CONTAINING_RECORD(
                        pVirtualSiteListEntry,
                        APPLICATION,
                        m_VirtualSiteListEntry
                        );

    DBG_ASSERT( pApplication->m_Signature == APPLICATION_SIGNATURE );

    return pApplication;

}   // APPLICATION::ApplicationFromVirtualSiteListEntry



/***************************************************************************++

Routine Description:

    A static class method to "upcast" from a LIST_ENTRY to an APPLICATION.

Arguments:

    pListEntry - A pointer to the m_AppPoolListEntry member of an
    APPLICATION.

Return Value:

    The pointer to the containing APPLICATION.

--***************************************************************************/

// note: static!
APPLICATION *
APPLICATION::ApplicationFromAppPoolListEntry(
    IN const LIST_ENTRY * pAppPoolListEntry
)
{

    APPLICATION * pApplication = NULL;

    DBG_ASSERT( pAppPoolListEntry != NULL );

    //  get the containing structure, then verify the signature
    pApplication = CONTAINING_RECORD(
                        pAppPoolListEntry,
                        APPLICATION,
                        m_AppPoolListEntry
                        );

    DBG_ASSERT( pApplication->m_Signature == APPLICATION_SIGNATURE );

    return pApplication;

}   // APPLICATION::ApplicationFromAppPoolListEntry



/***************************************************************************++

Routine Description:

    A static class method to "upcast" from the delete list LIST_ENTRY
    pointer of an APPLICATION to the APPLICATION as a whole.

Arguments:

    pDeleteListEntry - A pointer to the m_DeleteListEntry member of an
    APPLICATION.

Return Value:

    The pointer to the containing APPLICATION.

--***************************************************************************/

// note: static!
APPLICATION *
APPLICATION::ApplicationFromDeleteListEntry(
    IN const LIST_ENTRY * pDeleteListEntry
)
{

    APPLICATION * pApplication = NULL;

    DBG_ASSERT( pDeleteListEntry != NULL );

    //  get the containing structure, then verify the signature
    pApplication = CONTAINING_RECORD(
                            pDeleteListEntry,
                            APPLICATION,
                            m_DeleteListEntry
                            );

    DBG_ASSERT( pApplication->m_Signature == APPLICATION_SIGNATURE );

    return pApplication;

}   // APPLICATION::ApplicationFromDeleteListEntry



#if DBG
/***************************************************************************++

Routine Description:

    Dump out key internal data structures.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
APPLICATION::DebugDump(
    )
{

    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "********Application of site: %lu with path: %S; member of app pool: %S;\n",
            GetApplicationId()->VirtualSiteId,
            GetApplicationId()->pApplicationUrl,
            m_pAppPool->GetAppPoolId()
            ));
    }


    return;

}   // APPLICATION::DebugDump
#endif  // DBG

/***************************************************************************++

Routine Description:

    Activate the config group in HTTP.SYS if the parent app pool is active.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/
HRESULT 
APPLICATION::ActivateConfigGroup()
{
    HRESULT hr = S_OK;

    // not sure why we would get here and not have the 
    // config group setup. so I am adding the assert.
    DBG_ASSERT (  m_UlConfigGroupId != HTTP_NULL_ID );

    if  ( m_UlConfigGroupId != HTTP_NULL_ID )
    {
        hr = SetConfigGroupStateInformation( HttpEnabledStateActive );

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Enabling config group failed\n"
                ));

            goto exit;
        }

    }

exit:
    return hr;
}

/***************************************************************************++

Routine Description:

    Associate this application with an application pool. 

Arguments:

    pAppPool - The new application pool with which this application should
    be associated.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APPLICATION::SetAppPool(
    IN APP_POOL * pAppPool
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( pAppPool != NULL );


    //
    // First, remove the association with the old app pool, if any.
    //


    if ( m_pAppPool != NULL )
    {
        hr = m_pAppPool->DissociateApplication( this );

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Dissociating application from app pool failed\n"
                ));

            goto exit;
        }

        //
        // Dereference the app pool object, since it is reference counted
        // and we have been holding a pointer to it.
        //

        m_pAppPool->Dereference();

        m_pAppPool = NULL;

    }


    hr = pAppPool->AssociateApplication( this );

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Associating application with app pool failed\n"
            ));

        goto exit;
    }

    //
    // Only set this pointer if the association succeeded.
    //

    m_pAppPool = pAppPool;

    //
    // Reference the app pool object, since it is reference counted
    // and we will be holding a pointer to it.
    //

    m_pAppPool->Reference();


    //
    // Let UL know about the new configuration.
    //

    hr = SetConfigGroupAppPoolInformation();

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Setting information on config group failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // APPLICATION::SetAppPool



/***************************************************************************++

Routine Description:

    Initialize the UL config group associated with this application.

    Note:  Must always be called after the Virtual Site knows about this application
           because there is an error route where the VS may be asked to remove
           all the applications config group info, and this must work.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APPLICATION::InitializeConfigGroup(
    )
{

    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;


    //
    // First, create the config group.
    //
    DBG_ASSERT (  m_UlConfigGroupId == HTTP_NULL_ID );


    Win32Error = HttpCreateConfigGroup(
                        GetWebAdminService()->GetUlAndWorkerManager()->GetUlControlChannel(),
                                                    // control channel
                        &m_UlConfigGroupId          // returned config group ID
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Creating config group failed\n"
            ));

        goto exit;
    }


    //
    // Add the URL(s) which represent this app to the config group.
    //

    //
    // We do not care if this fails, 
    // because if it does we will have deactivated 
    // the site.  Therefore we are not checking the 
    // returned hresult.
    // 
    AddUrlsToConfigGroup();

    //
    // Assuming we have a URL then we can configure the SiteId and 
    // Logging information if this is the default site.
    //
    DBG_ASSERT( m_ApplicationId.pApplicationUrl != NULL );

    if ( m_ApplicationId.pApplicationUrl && wcscmp(m_ApplicationId.pApplicationUrl, L"/") == 0)
    {
        //
        // This only happens during initalization of a config group.  
        // Site Id will not change for a default application so once
        // we have done this registration, we don't worry about
        // config changes for the SiteId.
        //
        hr = RegisterSiteIdWithHttpSys();
        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Setting site on default url failed\n"
                ));

            goto exit;

        }

        hr = RegisterLoggingProperties();

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Adding log info to config group failed\n"
                ));

            goto exit;

        }

        hr = ConfigureMaxBandwidth();
        if ( FAILED( hr ) )
        {
            DPERROR((
                DBG_CONTEXT,
                hr,
                "Setting max bandwidth on default url failed\n"
                ));

            goto exit;

        }

        hr = ConfigureMaxConnections();
        if ( FAILED( hr ) )
        {
            DPERROR((
                DBG_CONTEXT,
                hr,
                "Setting max connections on default url failed\n"
                ));

            goto exit;

        }

        hr = ConfigureConnectionTimeout();
        if ( FAILED( hr ) )
        {
            DPERROR((
                DBG_CONTEXT,
                hr,
                "Setting connection timeout on default url failed\n"
                ));

            goto exit;

        }

    }

exit:

    return hr;

}   // APPLICATION::InitializeConfigGroup



/***************************************************************************++

Routine Description:

    Determine the set of fully-qualified URLs which represent this
    application, and register each of them with the config group.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APPLICATION::AddUrlsToConfigGroup(
    )
{

    LPCWSTR pSuffix = NULL;
    ULONG SuffixLengthInBytes = 0;
    LPCWSTR pPrefix = NULL;
    ULONG PrefixLengthInBytesSansTermination = 0;
    ULONG TotalLengthInBytes = 0;
    LPWSTR BufferToUse = NULL;
    WCHAR StackBuffer[ STACK_BUFFER_SIZE_IN_BYTES / sizeof( WCHAR ) ];
    LPWSTR HeapBuffer = NULL;
    BYTE * WriteSuffixHere = NULL;
    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;
    HTTP_URL_CONTEXT UrlContext = 0;

    //
    // CODEWORK Change this function to use the BUFFER class instead? 
    //

    DBG_ASSERT (  m_UlConfigGroupId != HTTP_NULL_ID );

    DBG_ASSERT( m_pVirtualSite != NULL );
    DBG_ASSERT( m_ApplicationId.pApplicationUrl != NULL );

    if ( m_pVirtualSite->GetState() != W3_CONTROL_STATE_STARTED )
    {
        //
        // If the virtual site is not started then don't add 
        // any urls to HTTP.SYS.  Simply return with success
        // because this is the expected behavior if the site
        // is not started.
        //

        hr = S_OK;

        goto exit;
    }

    m_pVirtualSite->ResetUrlPrefixIterator();


    // set up a simple alias for readability
    pSuffix = m_ApplicationId.pApplicationUrl;

    SuffixLengthInBytes = ( ( wcslen( pSuffix ) + 1 ) * sizeof( WCHAR ) );


    // loop for each prefix

    while ( ( pPrefix = m_pVirtualSite->GetNextUrlPrefix() ) != NULL )
    {

        //
        // Don't include the terminating null, as it will be overwritten later
        // by the suffix.
        //
        PrefixLengthInBytesSansTermination = ( wcslen( pPrefix ) * sizeof( WCHAR ) );


        //
        // Determine if we can use the fast stack buffer, or if we instead
        // need to allocate on the heap.
        //

        TotalLengthInBytes = PrefixLengthInBytesSansTermination + SuffixLengthInBytes;

        if ( TotalLengthInBytes <= STACK_BUFFER_SIZE_IN_BYTES )
        {
            BufferToUse = StackBuffer;
        }
        else
        {
            HeapBuffer = ( LPWSTR ) GlobalAlloc( GMEM_FIXED, TotalLengthInBytes );

            if ( HeapBuffer == NULL )
            {
                hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

                DPERROR((
                    DBG_CONTEXT,
                    hr,
                    "Allocating memory failed\n"
                    ));

                goto exit;
            }

            BufferToUse = HeapBuffer;

        }


        //
        // Next, copy the prefix and suffix.
        //

        memcpy( BufferToUse, pPrefix, PrefixLengthInBytesSansTermination);


        //
        // Figure out where to write the suffix. Note that the ( BYTE * )
        // cast is needed, or otherwise the offset will be done in WCHARs.
        //

        WriteSuffixHere = ( reinterpret_cast <BYTE *> ( BufferToUse )) 
                          + PrefixLengthInBytesSansTermination;

        memcpy( WriteSuffixHere, pSuffix, SuffixLengthInBytes );


        DBG_ASSERT( ( ( wcslen( BufferToUse ) + 1 ) * sizeof( WCHAR ) ) == TotalLengthInBytes );


        //
        // Next, register the URL.
        //

        //
        // For the URL context, stuff the site id in the high 32 bits.
        //

        UrlContext = m_pVirtualSite->GetVirtualSiteId();
        UrlContext = UrlContext << 32;


        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "About to register fully qualified URL: %S; site id: %lu; URL context: %#I64x\n",
                BufferToUse,
                m_pVirtualSite->GetVirtualSiteId(),
                UrlContext
                ));
        }


        Win32Error = HttpAddUrlToConfigGroup(
                            GetWebAdminService()->GetUlAndWorkerManager()->GetUlControlChannel(),
                                                        // control channel
                            m_UlConfigGroupId,          // config group ID
                            BufferToUse,                // fully qualified URL
                            UrlContext                  // URL context
                            );

        if ( Win32Error != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32( Win32Error );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Adding URL to config group failed: %S\n",
                BufferToUse
                ));

            goto exit;

        }


        //
        // Clean up.
        //

        if ( HeapBuffer != NULL )
        {
            DBG_REQUIRE( GlobalFree( HeapBuffer ) == NULL );
            HeapBuffer = NULL;
        }

    }


exit:

    //
    // If we failed to configure the bindings
    // then we need to log an event and 
    // shutdown the site.
    //
    if (  FAILED ( hr ) ) 
    {
        const WCHAR * EventLogStrings[1];

        // If we have a url then let the users know which one,
        // other wise just let them know there was a problem.
        if ( BufferToUse != NULL )
        {
            // Either the BufferToUse is pointing to the HeapBuffer or the stack buffer
            // if it is pointing to the heap buffer assert that it is valid if it is pointing
            // to it.
            DBG_ASSERT ( HeapBuffer ||  ( TotalLengthInBytes <= STACK_BUFFER_SIZE_IN_BYTES ) );

            EventLogStrings[0] = BufferToUse;

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_BINDING_FAILURE,              // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    hr                                      // error code
                    );
        }
        else
        {
            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_BINDING_FAILURE_2,              // message id
                    0,
                                                            // count of strings
                    NULL,                        // array of strings
                    hr                                      // error code
                    );
        }

        //
        // FailedToBindUrlsForSite does not return an hresult
        // because it is used when we are trying to handle a hresult
        // all ready and any errors it might wonder into it just
        // has to handle.
        //
        m_pVirtualSite->FailedToBindUrlsForSite( hr );

    }  // end of if (FAILED ( hr ))

    if ( HeapBuffer != NULL )
    {
        DBG_REQUIRE( GlobalFree( HeapBuffer ) == NULL );
        HeapBuffer = NULL;
    }


    return hr;

}   // APPLICATION::AddUrlsToConfigGroup



/***************************************************************************++

Routine Description:

    Set the app pool property on the config group.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APPLICATION::SetConfigGroupAppPoolInformation(
    )
{

    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;
    HTTP_CONFIG_GROUP_APP_POOL AppPoolInformation;


    DBG_ASSERT( m_pAppPool != NULL );

    DBG_ASSERT (  m_UlConfigGroupId != HTTP_NULL_ID );

    AppPoolInformation.Flags.Present = 1;
    AppPoolInformation.AppPoolHandle = m_pAppPool->GetAppPoolHandle();


    Win32Error = HttpSetConfigGroupInformation(
                        GetWebAdminService()->GetUlAndWorkerManager()->GetUlControlChannel(),
                                                            // control channel
                        m_UlConfigGroupId,                  // config group ID
                        HttpConfigGroupAppPoolInformation,  // information class
                        &AppPoolInformation,                // data to set
                        sizeof( AppPoolInformation )        // data length
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Setting config group app pool information failed\n"
            ));

    }


    return hr;

}   // APPLICATION::SetConfigGroupAppPoolInformation





/***************************************************************************++

Routine Description:

    Activate or deactivate UL's HTTP request handling for this config group.

Arguments:

    NewState - The state to set, from the HTTP_ENABLED_STATE enum.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APPLICATION::SetConfigGroupStateInformation(
    IN HTTP_ENABLED_STATE NewState
    )
{

    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;
    HTTP_CONFIG_GROUP_STATE ConfigGroupState;


    DBG_ASSERT( m_UlConfigGroupId != HTTP_NULL_ID );


    ConfigGroupState.Flags.Present = 1;
    ConfigGroupState.State = NewState;


    Win32Error = HttpSetConfigGroupInformation(
                        GetWebAdminService()->GetUlAndWorkerManager()->GetUlControlChannel(),
                                                            // control channel
                        m_UlConfigGroupId,                  // config group ID
                        HttpConfigGroupStateInformation,    // information class
                        &ConfigGroupState,                  // data to set
                        sizeof( ConfigGroupState )          // data length
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Setting config group state failed\n"
            ));

    }


    return hr;

}   // APPLICATION::SetConfigGroupStateInformation



/***************************************************************************++

Routine Description:

    Set the logging properties on the config group.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APPLICATION::RegisterLoggingProperties(
    )
{

    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;
    HTTP_CONFIG_GROUP_LOGGING LoggingInformation;

    DBG_ASSERT (  m_UlConfigGroupId != HTTP_NULL_ID );

    // If UL is already logging or if we are trying to tell
    // UL to start logging than we should pass the info down.
    if ( m_ULLogging || m_pVirtualSite->LoggingEnabled() )
    {

        // Always set the present flag it is intrinsic to UL.
        LoggingInformation.Flags.Present = 1;

        // Determine if logging is enabled at all.  If it is then
        // update all properties.  If it is not then just update the
        // property to disable logging.

        LoggingInformation.LoggingEnabled = (m_pVirtualSite->LoggingEnabled() == TRUE);
        IF_DEBUG( WEB_ADMIN_SERVICE_LOGGING )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Logging Enabled: %d\n",
                LoggingInformation.LoggingEnabled 
                ));
        }

        if ( LoggingInformation.LoggingEnabled )
        {
            if (   !m_pVirtualSite->GetLogFileDirectory() 
                || !m_pVirtualSite->GetVirtualSiteDirectory())
            {
                DPERROR((
                    DBG_CONTEXT,
                    E_INVALIDARG,
                    "Skipping UL Configuration of Logging, LogFile or VirtualSite Directory was NULL\n"
                    ));

                // Don't bubble up an error from here because we don't want to cause WAS to shutdown.
                goto exit;
            }

            LoggingInformation.LogFileDir.Length = wcslen(m_pVirtualSite->GetLogFileDirectory()) * sizeof(WCHAR);
            LoggingInformation.LogFileDir.MaximumLength = LoggingInformation.LogFileDir.Length + (1 * sizeof(WCHAR));
            LoggingInformation.LogFileDir.Buffer = m_pVirtualSite->GetLogFileDirectory();

            IF_DEBUG( WEB_ADMIN_SERVICE_LOGGING )
            {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "Log File Length: %d; Log File Max Length: %d; Log File Path: %S\n",
                    LoggingInformation.LogFileDir.Length,
                    LoggingInformation.LogFileDir.MaximumLength,
                    LoggingInformation.LogFileDir.Buffer
                    ));
            }

            LoggingInformation.LogFormat = m_pVirtualSite->GetLogFileFormat();

            IF_DEBUG( WEB_ADMIN_SERVICE_LOGGING )
            {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "Logging Format: %d\n",
                    LoggingInformation.LogFormat
                    ));
            }

            // Get the site name, but advance it one character to avoid the leading slash
            LoggingInformation.SiteName.Length = (wcslen(m_pVirtualSite->GetVirtualSiteDirectory()) - 1) * sizeof(WCHAR);
            LoggingInformation.SiteName.MaximumLength = LoggingInformation.SiteName.Length + 1 * sizeof(WCHAR);
            LoggingInformation.SiteName.Buffer = m_pVirtualSite->GetVirtualSiteDirectory() + 1;

            IF_DEBUG( WEB_ADMIN_SERVICE_LOGGING )
            {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "Site Length: %d; Site Max Length: %d; Site: %S\n",
                    LoggingInformation.SiteName.Length,
                    LoggingInformation.SiteName.MaximumLength,
                    LoggingInformation.SiteName.Buffer
                    ));
            }


            LoggingInformation.LogPeriod = m_pVirtualSite->GetLogPeriod();
            LoggingInformation.LogFileTruncateSize = m_pVirtualSite->GetLogFileTruncateSize();
            LoggingInformation.LogExtFileFlags = m_pVirtualSite->GetLogExtFileFlags();
            LoggingInformation.LocaltimeRollover =  ( m_pVirtualSite->GetLogFileLocaltimeRollover() == TRUE ) ;

            IF_DEBUG( WEB_ADMIN_SERVICE_LOGGING )
            {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "LogPeriod: %d; LogTruncateSize: %d; LogExtFileFlags: %d LogFileLocaltimeRollover: %S\n",
                    LoggingInformation.LogPeriod,
                    LoggingInformation.LogFileTruncateSize,
                    LoggingInformation.LogExtFileFlags,
                    LoggingInformation.LocaltimeRollover ? L"TRUE" : L"FALSE"
                    ));
            }
    
        }
        else
        {
            // Just for sanity sake, set defaults for the properties before
            // passing the disable logging to UL.
            LoggingInformation.LogFileDir.Length = 0;
            LoggingInformation.LogFileDir.MaximumLength = 0;
            LoggingInformation.LogFileDir.Buffer = NULL;
            LoggingInformation.LogFormat = HttpLoggingTypeMaximum;
            LoggingInformation.SiteName.Length = 0;
            LoggingInformation.SiteName.MaximumLength = 0;
            LoggingInformation.SiteName.Buffer = NULL;
            LoggingInformation.LogPeriod = 0;
            LoggingInformation.LogFileTruncateSize = 0;
            LoggingInformation.LogExtFileFlags = 0;
            LoggingInformation.LocaltimeRollover = FALSE;
        }

        Win32Error = HttpSetConfigGroupInformation(
                            GetWebAdminService()->GetUlAndWorkerManager()->GetUlControlChannel(),
                                                                // control channel
                            m_UlConfigGroupId,                  // config group ID
                            HttpConfigGroupLogInformation,      // information class
                            &LoggingInformation,                // data to set
                            sizeof( LoggingInformation )        // data length
                            );

        if ( Win32Error != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32( Win32Error );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Setting config group logging information failed\n"
                ));

            DWORD dwMessageId;

            switch  ( Win32Error  )
            {
                case ( ERROR_PATH_NOT_FOUND ):
                    //
                    // If we got back this error, then we assume that the problem was that the drive
                    // letter mapped to a network path, and could not be used.  Http.sys does not
                    // support working with mapped drives.
                    //
                    dwMessageId = WAS_EVENT_LOG_DIRECTORY_MAPPED_NETWORK_DRIVE;
                break;

                case ( ERROR_INVALID_NAME ):
                case ( ERROR_BAD_NETPATH ):
                    //
                    // UNC machine or share name is not valid.
                    //
                    dwMessageId = WAS_EVENT_LOG_DIRECTORY_MACHINE_OR_SHARE_INVALID;
                break;

                case ( ERROR_ACCESS_DENIED ):
                    //
                    // The account that the server is running under does not
                    // have access to the particular network share.
                    //
                    dwMessageId = WAS_EVENT_LOG_DIRECTORY_ACCESS_DENIED;
                break;

                case ( ERROR_NOT_SUPPORTED ):
                    // 
                    // The log file directory name is not fully qualified, 
                    // for instance, it could be missing the drive letter.
                    //
                    dwMessageId = WAS_EVENT_LOG_DIRECTORY_NOT_FULLY_QUALIFIED;
                break;

                default:
                    //
                    // Something was wrong with the logging properties, but
                    // we are not sure what.
                    //
                    dwMessageId = WAS_EVENT_LOGGING_FAILURE;
            }

            //
            // Log an event: Configuring the log information in UL failed..
            //

            const WCHAR * EventLogStrings[1];
            WCHAR StringizedSiteId[ MAX_SIZE_BUFFER_FOR_ITOW ];
            _itow(m_ApplicationId.VirtualSiteId, StringizedSiteId, 10);

            EventLogStrings[0] = StringizedSiteId;

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    dwMessageId,         // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    hr                                      // error code
                    );


            // Don't bubble this error up any farther than need be.  
            // It is not fatal to not have logging on a site.
            hr = S_OK;

        }
        else
        {
            // Remember if UL is now logging. 
            if (LoggingInformation.LoggingEnabled)
            {
                m_ULLogging = TRUE;
            }
            else
            {
                m_ULLogging = FALSE;
            }

        }

    }

exit:
    return hr;

}   // APPLICATION::RegisterLoggingProperties

/***************************************************************************++

Routine Description:

    Tell HTTP.SYS what the SiteId for this application is.
    This actually declares this application as the root application.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APPLICATION::RegisterSiteIdWithHttpSys(
    )
{
    DWORD Win32Error = 0;

    DBG_ASSERT (  m_UlConfigGroupId != HTTP_NULL_ID );

    HTTP_CONFIG_GROUP_SITE SiteConfig;

    SiteConfig.SiteId = m_ApplicationId.VirtualSiteId;

    Win32Error = HttpSetConfigGroupInformation(
                    GetWebAdminService()->GetUlAndWorkerManager()->GetUlControlChannel(),
                                                        // control channel
                    m_UlConfigGroupId,                  // config group ID
                    HttpConfigGroupSiteInformation,     // information class
                    &SiteConfig,                        // data to set
                    sizeof( SiteConfig )                // data length
                    );

    if ( Win32Error != NO_ERROR )
    {
        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32( Win32Error ),
            "Setting site id information in http.sys failed\n"
            ));
    }

    return S_OK;

}   // APPLICATION::RegisterSiteIdWithHttpSys

/***************************************************************************++

Routine Description:

    Tell HTTP.SYS what the max connections value is for the site.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APPLICATION::ConfigureMaxConnections(
    )
{  
    DBG_ASSERT ( m_pVirtualSite );

    DBG_ASSERT (  m_UlConfigGroupId != HTTP_NULL_ID );

    HTTP_CONFIG_GROUP_MAX_CONNECTIONS connections;

    connections.Flags.Present = 1;
    connections.MaxConnections = m_pVirtualSite->GetMaxConnections();

    DWORD Win32Error = 0;

    Win32Error = HttpSetConfigGroupInformation(
                    GetWebAdminService()->GetUlAndWorkerManager()->GetUlControlChannel(),
                                                        // control channel
                    m_UlConfigGroupId,                  // config group ID
                    HttpConfigGroupConnectionInformation,     // information class
                    &connections,                        // data to set
                    sizeof( connections )                // data length
                    );

    if ( Win32Error != NO_ERROR )
    {
        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32( Win32Error ),
            "Setting connection information in http.sys failed\n"
            ));
    }

    return S_OK;

}   // APPLICATION::ConfigureMaxConnections

/***************************************************************************++

Routine Description:

    Tell HTTP.SYS what the Max Bandwidth for this application is.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APPLICATION::ConfigureMaxBandwidth(
    )
{
     
    DBG_ASSERT ( m_pVirtualSite );

    DBG_ASSERT (  m_UlConfigGroupId != HTTP_NULL_ID );

    HTTP_CONFIG_GROUP_MAX_BANDWIDTH bandwidth;

    bandwidth.Flags.Present = 1;
    bandwidth.MaxBandwidth = m_pVirtualSite->GetMaxBandwidth();

    DWORD Win32Error = 0;

    Win32Error = HttpSetConfigGroupInformation(
                    GetWebAdminService()->GetUlAndWorkerManager()->GetUlControlChannel(),
                                                        // control channel
                    m_UlConfigGroupId,                  // config group ID
                    HttpConfigGroupBandwidthInformation,     // information class
                    &bandwidth,                        // data to set
                    sizeof( bandwidth )                // data length
                    );

    if ( Win32Error != NO_ERROR )
    {
        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32( Win32Error ),
            "Setting connection information in http.sys failed\n"
            ));
    }

    return S_OK;


}   // APPLICATION::ConfigureMaxBandwidth

/***************************************************************************++

Routine Description:

    Tell HTTP.SYS the ConnectionTimeout for this application.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APPLICATION::ConfigureConnectionTimeout(
    )
{
     
    DBG_ASSERT ( m_pVirtualSite );
    DBG_ASSERT (  m_UlConfigGroupId != HTTP_NULL_ID );

    DWORD ConnectionTimeout = m_pVirtualSite->GetConnectionTimeout();
    DWORD Win32Error = 0;

    Win32Error = HttpSetConfigGroupInformation(
                    GetWebAdminService()->GetUlAndWorkerManager()->GetUlControlChannel(),
                                                        // control channel
                    m_UlConfigGroupId,                  // config group ID
                    HttpConfigGroupConnectionTimeoutInformation,     // information class
                    &ConnectionTimeout,                        // data to set
                    sizeof( ConnectionTimeout )                // data length
                    );

    if ( Win32Error != NO_ERROR )
    {
        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32( Win32Error ),
            "Setting connection timeout information in http.sys failed\n"
            ));
    }

    return S_OK;


}   // APPLICATION::ConfigureConnectionTimeout
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\app_pool_table.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    app_pool_table.h

Abstract:

    The IIS web admin service app pool table class definition.

Author:

    Seth Pollack (sethp)        01-Oct-1998

Revision History:

--*/


#ifndef _APP_POOL_TABLE_H_
#define _APP_POOL_TABLE_H_



//
// prototypes
//

class APP_POOL_TABLE
    : public CTypedHashTable< APP_POOL_TABLE, APP_POOL, const WCHAR * >
{

public:

    APP_POOL_TABLE(
        )
        : CTypedHashTable< APP_POOL_TABLE, APP_POOL, const WCHAR * >
                ( "APP_POOL_TABLE" )
    { /* do nothing*/ }

    ~APP_POOL_TABLE(
        )
    { DBG_ASSERT( Size() == 0 ); }

    static
    const WCHAR *
    ExtractKey(
        IN const APP_POOL * pAppPool
        )  
    { return pAppPool->GetAppPoolId(); }
    
    static
    DWORD
    CalcKeyHash(
        IN const WCHAR * Key
        ) 
    { return HashStringNoCase( Key ); }
    
    static
    bool
    EqualKeys(
        IN const WCHAR * Key1,
        IN const WCHAR * Key2
        )
    { return ( _wcsicmp( Key1, Key2 ) == 0 ); }
    
    static
    void
    AddRefRecord(
        IN APP_POOL * pAppPool,
        IN int IncrementAmount
        ) 
    { /* do nothing*/ }

    HRESULT
    Shutdown(
        );

    HRESULT
    RequestCounters(
        OUT DWORD* pNumberOfProcessToWaitFor
        );

    HRESULT
    ResetAllWorkerProcessPerfCounterState(
        );

    VOID
    Terminate(
        );

    static
    LK_ACTION
    DeleteAppPoolAction(
        IN APP_POOL * pAppPool, 
        IN VOID * pDeleteListHead
        );

    static
    LK_ACTION
    RehookAppPoolAction(
        IN APP_POOL * pAppPool, 
        IN VOID * pIgnored
        );


#if DBG
    VOID
    DebugDump(
        );

    static
    LK_ACTION
    DebugDumpAppPoolAction(
        IN APP_POOL * pAppPool, 
        IN VOID * pIgnored
        );
#endif  // DBG


    HRESULT
    LeavingLowMemoryCondition(
        );

    static
    LK_ACTION
    LeavingLowMemoryConditionAppPoolAction(
        IN APP_POOL * pAppPool, 
        IN VOID * pIgnored
        );


};  // APP_POOL_TABLE



#endif  // _APP_POOL_TABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\config_and_control_manager.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    config_and_control_manager.h

Abstract:

    The IIS web admin service configuration and control manager class 
    definition.

Author:

    Seth Pollack (sethp)        16-Feb-2000

Revision History:

--*/



#ifndef _CONFIG_AND_CONTROL_MANAGER_H_
#define _CONFIG_AND_CONTROL_MANAGER_H_



//
// common #defines
//

#define CONFIG_AND_CONTROL_MANAGER_SIGNATURE        CREATE_SIGNATURE( 'CCMG' )
#define CONFIG_AND_CONTROL_MANAGER_SIGNATURE_FREED  CREATE_SIGNATURE( 'ccmX' )



//
// prototypes
//


class CONFIG_AND_CONTROL_MANAGER
{

public:

    CONFIG_AND_CONTROL_MANAGER(
        );

    virtual
    ~CONFIG_AND_CONTROL_MANAGER(
        );

    HRESULT
    Initialize(
        );

    VOID
    Terminate(
        );

    HRESULT
    RehookChangeProcessing(
        );

    HRESULT
    StopChangeProcessing(
        );

    inline
    CONFIG_MANAGER *
    GetConfigManager(
        )
    { 
        return &m_ConfigManager;
    }

    inline
    BOOL
    IsChangeProcessingEnabled(
        )
    { 
        return m_ProcessChanges;
    }


private:

    HRESULT
    InitializeControlApiClassFactory(
        );

    VOID
    TerminateControlApiClassFactory(
        );


    DWORD m_Signature;

    // brokers configuration state and changes
    CONFIG_MANAGER m_ConfigManager;

    // class factory for the control api
    CONTROL_API_CLASS_FACTORY * m_pControlApiClassFactory;

    BOOL m_CoInitialized;

    BOOL m_ProcessChanges;

    DWORD m_ClassObjectCookie;


};  // class CONFIG_AND_CONTROL_MANAGER



#endif  // _CONFIG_AND_CONTROL_MANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\config_change.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    config_change.h

Abstract:

    The IIS web admin service configuration change class definition.

Author:

    Seth Pollack (sethp)        18-Nov-1999

Revision History:

--*/



#ifndef _CONFIG_CHANGE_H_
#define _CONFIG_CHANGE_H_



//
// common #defines
//

#define CONFIG_CHANGE_SIGNATURE         CREATE_SIGNATURE( 'CFCH' )
#define CONFIG_CHANGE_SIGNATURE_FREED   CREATE_SIGNATURE( 'cfcX' )


//
// We are expecting 3 tables: app pools, virtual sites, and applications.
//

#define NUMBER_OF_CONFIG_TABLES 4

#define TABLE_INDEX_APPPOOLS    0
#define TABLE_INDEX_SITES       1
#define TABLE_INDEX_APPS        2
#define TABLE_INDEX_GLOBAL      3



//
// structs, enums, etc.
//

// CONFIG_CHANGE work items
typedef enum _CONFIG_CHANGE_WORK_ITEM
{

    //
    // Process a configuration change.
    //
    ProcessChangeConfigChangeWorkItem = 1,
    
} CONFIG_CHANGE_WORK_ITEM;



//
// prototypes
//


class CONFIG_CHANGE
    : public WORK_DISPATCH
{

public:

    CONFIG_CHANGE(
        );

    virtual
    ~CONFIG_CHANGE(
        );

    virtual
    VOID
    Reference(
        );

    virtual
    VOID
    Dereference(
        );

    virtual
    HRESULT
    ExecuteWorkItem(
        IN const WORK_ITEM * pWorkItem
        );

    HRESULT
    Initialize(
        IN ISimpleTableWrite2 ** ppDeltaTables,
        IN ULONG CountOfTables,
        IN DWORD ChangeNotifyCookie
        );

    inline
    ISimpleTableWrite2 *
    GetDeltaTable(
        IN ULONG TableIndex
        )
    { return m_ppDeltaTables[ TableIndex ]; }

    inline
    ISimpleTableController *
    GetTableController(
        IN ULONG TableIndex
        )
    { return m_ppTableControllers[ TableIndex ]; }

    inline
    DWORD
    GetChangeNotifyCookie(
        )
        const
    { return m_ChangeNotifyCookie; }


private:

    DWORD m_Signature;

    LONG m_RefCount;

    ISimpleTableWrite2 * m_ppDeltaTables[ NUMBER_OF_CONFIG_TABLES ];
    
    ISimpleTableController * m_ppTableControllers[ NUMBER_OF_CONFIG_TABLES ];

    DWORD m_ChangeNotifyCookie;


};  // class CONFIG_CHANGE



#endif  // _CONFIG_CHANGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\config_and_control_manager.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    config_and_control_manager.cxx

Abstract:

    The IIS web admin service configuration and control manager class 
    implementation. This class owns access to all configuration data, 
    both via the catalog config store apis and the metabase apis; as well
    as control commands that come in through our control api. 

    Threading: Always called on the main worker thread.

Author:

    Seth Pollack (sethp)        16-Feb-2000

Revision History:

--*/



#include  "precomp.h"



/***************************************************************************++

Routine Description:

    Constructor for the CONFIG_AND_CONTROL_MANAGER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONFIG_AND_CONTROL_MANAGER::CONFIG_AND_CONTROL_MANAGER(
    )
    :
    m_ConfigManager()
{

    m_pControlApiClassFactory = NULL;

    m_CoInitialized = FALSE;

    m_ProcessChanges = TRUE;

    m_ClassObjectCookie = 0;

    m_Signature = CONFIG_AND_CONTROL_MANAGER_SIGNATURE;

}   // CONFIG_AND_CONTROL_MANAGER::CONFIG_AND_CONTROL_MANAGER



/***************************************************************************++

Routine Description:

    Destructor for the CONFIG_AND_CONTROL_MANAGER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONFIG_AND_CONTROL_MANAGER::~CONFIG_AND_CONTROL_MANAGER(
    )
{

    DBG_ASSERT( m_Signature == CONFIG_AND_CONTROL_MANAGER_SIGNATURE );

    m_Signature = CONFIG_AND_CONTROL_MANAGER_SIGNATURE_FREED;

    DBG_ASSERT( m_pControlApiClassFactory == NULL );

    DBG_ASSERT( ! m_ProcessChanges );

    DBG_ASSERT( m_CoInitialized == FALSE );


}   // CONFIG_AND_CONTROL_MANAGER::~CONFIG_AND_CONTROL_MANAGER



/***************************************************************************++

Routine Description:

    Initialize the configuration manager.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_AND_CONTROL_MANAGER::Initialize(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    hr = CoInitializeEx(
                NULL,                   // reserved
                COINIT_MULTITHREADED    // threading model
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing COM failed\n"
            ));

        goto exit;
    }

    m_CoInitialized = TRUE;


    //
    // Read the initial configuration.
    //

    hr = m_ConfigManager.Initialize();

    if ( FAILED( hr ) )
    {
    
        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_CONFIG_MANAGER_INITIALIZATION_FAILED,              // message id
                0,                                                     // count of strings
                NULL,                                                  // array of strings
                hr                                                     // error code
                );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing configuration manager failed\n"
            ));

        goto exit;
    }


    //
    // Set up the control api class factory.
    //

    hr = InitializeControlApiClassFactory();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing control api class factory failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // CONFIG_AND_CONTROL_MANAGER::Initialize



/***************************************************************************++

Routine Description:

    Begin termination of this object. Tell all referenced or owned entities 
    which may hold a reference to this object to release that reference 
    (and not take any more), in order to break reference cycles. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
CONFIG_AND_CONTROL_MANAGER::Terminate(
    )
{

    //
    // Stop processing config change notifications and control operations 
    // now, if we haven't already.
    //

    DBG_REQUIRE( SUCCEEDED( StopChangeProcessing() ) );


    //
    // Terminate the config manager. This will also ensure that config
    // change processing stops, as that could generate new WORK_ITEMs.
    //
    
    m_ConfigManager.Terminate();


    //
    // CoUninitialize. Make sure we do it on the same thread we CoInitialize'd
    // on originally.
    //

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    if ( m_CoInitialized )
    {
        CoUninitialize();
        m_CoInitialized = FALSE;
    }

}   // CONFIG_AND_CONTROL_MANAGER::Terminate



/***************************************************************************++

Routine Description:

    Discontinue accepting and processing config changes and control 
    operations. This can be safely called multiple times. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_AND_CONTROL_MANAGER::StopChangeProcessing(
    )
{

    HRESULT hr = S_OK;


    if ( m_ProcessChanges )
    {


        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Disabling config change and control operation processing\n"
                ));
        }


        m_ProcessChanges = FALSE;


        //
        // Tear down the control api class factory. This will prevent new 
        // callers from being able to get our control interface. 
        //

        TerminateControlApiClassFactory();


        //
        // Turn off config change processing.
        //

        hr = m_ConfigManager.StopChangeProcessing();

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Stopping config change processing failed\n"
                ));

            goto exit;
        }


        //
        // Note that control operation processing if turned off implicitly
        // as soon as we set m_ProcessChanges to FALSE.
        //

    }


exit:

    return hr;

}   // CONFIG_AND_CONTROL_MANAGER::StopChangeProcessing


/***************************************************************************++

Routine Description:

    Discontinue accepting and processing config changes and control 
    operations. This can be safely called multiple times. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_AND_CONTROL_MANAGER::RehookChangeProcessing(
    )
{

    HRESULT hr = S_OK;

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Rehooking change notification processing\n"
            ));
    }

    hr = m_ConfigManager.RehookChangeProcessing();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Rehooking config change processing failed\n"
            ));

        goto exit;
    }

exit:

    return hr;

}   // CONFIG_AND_CONTROL_MANAGER::RehookChangeProcessing


/***************************************************************************++

Routine Description:

    Create and register the class factory for the control api.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_AND_CONTROL_MANAGER::InitializeControlApiClassFactory(
    )
{

    HRESULT hr = S_OK;


    //
    // Create the class factory.
    //

    DBG_ASSERT( m_pControlApiClassFactory == NULL );
    
    m_pControlApiClassFactory = new CONTROL_API_CLASS_FACTORY();

    if ( m_pControlApiClassFactory == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating CONTROL_API_CLASS_FACTORY failed\n"
            ));

        goto exit;
    }


    //
    // Register it with COM.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Registering control api class factory\n"
            ));
    }

    hr = CoRegisterClassObject(
                CLSID_W3Control,                // CLSID
                m_pControlApiClassFactory,      // class factory pointer
                CLSCTX_SERVER,                  // allowed class contexts
                REGCLS_MULTIPLEUSE,             // multi-use
                &m_ClassObjectCookie            // returned cookie
                ); 

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Registering class object failed\n"
            ));

        //
        // Clean up the class object now, since we couldn't register it.
        //

        m_pControlApiClassFactory->Release();
        m_pControlApiClassFactory = NULL;


        goto exit;
    }


exit:

    return hr;

}   // CONFIG_AND_CONTROL_MANAGER::InitializeControlApiClassFactory



/***************************************************************************++

Routine Description:

    Revoke and clean up the class factory for the control api.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
CONFIG_AND_CONTROL_MANAGER::TerminateControlApiClassFactory(
    )
{

    HRESULT hr = S_OK;


    //
    // Only clean up if we haven't already.
    //

    if ( m_pControlApiClassFactory != NULL )
    {

        //
        // Unregister it with COM.
        //

        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Revoking control api class factory\n"
                ));
        }

        DBG_REQUIRE( SUCCEEDED( CoRevokeClassObject( m_ClassObjectCookie ) ) );


        //
        // Clean up the class object.
        //

        m_pControlApiClassFactory->Release();
        m_pControlApiClassFactory = NULL;

    }


    return;

}   // CONFIG_AND_CONTROL_MANAGER::TerminateControlApiClassFactory
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\config_change.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    config_change.cxx

Abstract:

    The IIS web admin service configuration change class implementation. 
    This class is used to queue config changes to the main worker thread.

    Threading: Configuration changes arrive on COM threads (i.e., secondary 
    threads), and so instances of this class are created on secondary threads.
    Actual processing of config changes happens on the main worker thread.

Author:

    Seth Pollack (sethp)        18-Nov-1999

Revision History:

--*/



#include  "precomp.h"



/***************************************************************************++

Routine Description:

    Constructor for the CONFIG_CHANGE class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONFIG_CHANGE::CONFIG_CHANGE(
    )
{

    ULONG i = 0;

    //
    // Set the initial reference count to 1, in order to represent the
    // reference owned by the creator of this instance.
    //

    m_RefCount = 1;


    for ( i = 0; i < NUMBER_OF_CONFIG_TABLES; i++ )
    {
        m_ppDeltaTables[i] = NULL;
        m_ppTableControllers[i] = NULL;
    }
    

    m_ChangeNotifyCookie = 0;

    m_Signature = CONFIG_CHANGE_SIGNATURE;

}   // CONFIG_CHANGE::CONFIG_CHANGE



/***************************************************************************++

Routine Description:

    Destructor for the CONFIG_CHANGE class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONFIG_CHANGE::~CONFIG_CHANGE(
    )
{

    ULONG i = 0;


    DBG_ASSERT( m_Signature == CONFIG_CHANGE_SIGNATURE );

    m_Signature = CONFIG_CHANGE_SIGNATURE_FREED;

    DBG_ASSERT( m_RefCount == 0 );

    //
    // Release all the delta tables and table controllers.
    //

    for ( i = 0; i < NUMBER_OF_CONFIG_TABLES; i++ )
    {
        if ( m_ppDeltaTables[i] != NULL )
        {
            m_ppDeltaTables[i]->Release();
            m_ppDeltaTables[i] = NULL;
        }

        if ( m_ppTableControllers[i] != NULL )
        {
            m_ppTableControllers[i]->Release();
            m_ppTableControllers[i] = NULL;
        }
    }

}   // CONFIG_CHANGE::~CONFIG_CHANGE



/***************************************************************************++

Routine Description:

    Increment the reference count for this object. Note that this method must
    be thread safe, and must not be able to fail.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
CONFIG_CHANGE::Reference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedIncrement( &m_RefCount );


    //
    // The reference count should never have been less than zero; and
    // furthermore once it has hit zero it should never bounce back up;
    // given these conditions, it better be greater than one now.
    //
    
    DBG_ASSERT( NewRefCount > 1 );


    return;

}   // CONFIG_CHANGE::Reference



/***************************************************************************++

Routine Description:

    Decrement the reference count for this object, and cleanup if the count
    hits zero. Note that this method must be thread safe, and must not be
    able to fail.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
CONFIG_CHANGE::Dereference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedDecrement( &m_RefCount );

    // ref count should never go negative
    DBG_ASSERT( NewRefCount >= 0 );

    if ( NewRefCount == 0 )
    {
        // time to go away

        IF_DEBUG( WEB_ADMIN_SERVICE_REFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Reference count has hit zero in CONFIG_CHANGE instance, deleting (ptr: %p)\n",
                this
                ));
        }


        delete this;


    }


    return;

}   // CONFIG_CHANGE::Dereference



/***************************************************************************++

Routine Description:

    Execute a work item on this object.

Arguments:

    pWorkItem - The work item to execute.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_CHANGE::ExecuteWorkItem(
    IN const WORK_ITEM * pWorkItem
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( pWorkItem != NULL );


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Executing work item with serial number: %lu in CONFIG_CHANGE (ptr: %p) with operation: %p\n",
            pWorkItem->GetSerialNumber(),
            this,
            pWorkItem->GetOpCode()
            ));
    }


    switch ( pWorkItem->GetOpCode() )
    {

    case ProcessChangeConfigChangeWorkItem:

        hr = GetWebAdminService()->GetConfigAndControlManager()->GetConfigManager()->
                ProcessConfigChange( this );

        break;

    default:

        // invalid work item!
        DBG_ASSERT( FALSE );

        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;

    }


    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Executing work item on CONFIG_CHANGE failed\n"
            ));

    }


    return hr;

}   // CONFIG_CHANGE::ExecuteWorkItem



/***************************************************************************++

Routine Description:

    Initialize this instance. 

Arguments:

    ppDeltaTables - The array of tables, each containing deltas for one
    configuration table. 

    CountOfTables - The number of tables in the array.

    ChangeNotifyCookie - The cookie value for this notification registration. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_CHANGE::Initialize(
    IN ISimpleTableWrite2 ** ppDeltaTables,
    IN ULONG CountOfTables,
    IN DWORD ChangeNotifyCookie
    )
{

    HRESULT hr = S_OK;
    ULONG i = 0;


    DBG_ASSERT( ppDeltaTables != NULL );

    DBG_ASSERT( CountOfTables == NUMBER_OF_CONFIG_TABLES );


    m_ChangeNotifyCookie = ChangeNotifyCookie;


    for ( i = 0; i < NUMBER_OF_CONFIG_TABLES; i++ )
    {

        if ( ppDeltaTables[i] != NULL )
        {

            //
            // Get and AddRef() the table pointer.
            //

            m_ppDeltaTables[i] = ppDeltaTables[i];

            m_ppDeltaTables[i]->AddRef();


            //
            // Get the matching table controller pointer.
            //

            hr = m_ppDeltaTables[i]->QueryInterface(
                                            IID_ISimpleTableController, 
                                            reinterpret_cast <VOID **> ( &( m_ppTableControllers[i] ) )
                                            );

            if ( FAILED( hr ) )
            {
            
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Getting simple table controller interface failed\n"
                    )); 

                goto exit;
            }

        }

    }


exit:

    return hr;

}   // CONFIG_CHANGE::Initialize
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\com_registration.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    com_registration.cxx

Abstract:

    Entry points for registering and unregistering the COM pieces of
    the IIS web admin service.

Author:

    Seth Pollack (sethp)        18-Feb-2000

Revision History:

--*/



#include "precomp.h"

static const WCHAR g_szAPPID[] = L"AppID";
static const WCHAR g_szCLSID[] = L"CLSID";
static const WCHAR g_szINTERFACE[] = L"Interface";

static WCHAR * g_pwchCLSID_W3Control = NULL;
static WCHAR * g_pwchIID_W3Control = NULL;


/***************************************************************************++

Routine Description:

    Frees strings for GUIDS

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/
static
void
FreeGlobalGUIDStrings()
{
    delete [] g_pwchCLSID_W3Control;
    g_pwchCLSID_W3Control = NULL;
    delete [] g_pwchIID_W3Control;
    g_pwchIID_W3Control = NULL;
    return;
}

/***************************************************************************++

Routine Description:

    Allocates strings for GUIDS

Arguments:

    None.

Return Value:

    HRESULT - S_OK if strings allocated else E_OUTOFMEMORY;

--***************************************************************************/
static 
HRESULT
AllocateGlobalGUIDStrings()
{
    HRESULT hr = S_OK;
    int iRet;

    DBG_ASSERT(NULL == g_pwchCLSID_W3Control);
    DBG_ASSERT(NULL == g_pwchIID_W3Control);

    // get the string representation for CLSID_W3Control
    g_pwchCLSID_W3Control = new WCHAR[MAX_PATH];
    if (NULL == g_pwchCLSID_W3Control)
    {
        hr = E_OUTOFMEMORY;
        goto error_exit;
    }
    iRet = StringFromGUID2(CLSID_W3Control,         // GUID to convert
                           g_pwchCLSID_W3Control,   // storage for GUID
                           MAX_PATH                 // number of characters
                          );
    DBG_ASSERT(0 != iRet);

    // get the string representation for IID_IW3Control
    g_pwchIID_W3Control = new WCHAR[MAX_PATH];
    if (NULL == g_pwchIID_W3Control)
    {
        hr = E_OUTOFMEMORY;
        goto error_exit;
    }

    iRet = StringFromGUID2(IID_IW3Control,          // GUID to convert
                           g_pwchIID_W3Control,     // storage for GUID
                           MAX_PATH                 // number of characters
                          );
    DBG_ASSERT(0 != iRet);

    return S_OK;
error_exit:
    FreeGlobalGUIDStrings();
    return hr;
}


/***************************************************************************++

Routine Description:

    Registers COM pieces. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

STDAPI
DllRegisterServer(
    )
{

    DWORD Win32Error = NO_ERROR;
    HKEY KeyHandle = NULL;
    HKEY KeyHandle2 = NULL;
    ACL LaunchAcl;
    HRESULT hr = S_OK;

    // when copying and appending - use this
    STACK_STRU(struTemp, 256);

    hr = AllocateGlobalGUIDStrings();
    if (FAILED(hr))
    {
        goto exit;
    }
    
    //
    // Set the AppID key.
    //

    // create string of the form: AppID\{...}
    struTemp.Copy(g_szAPPID);
    struTemp.Append(L"\\");
    struTemp.Append(g_pwchCLSID_W3Control);

    Win32Error = RegCreateKeyEx(
                        HKEY_CLASSES_ROOT,
                        struTemp.QueryStr(),
                        NULL, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_ALL_ACCESS, 
                        NULL,
                        &KeyHandle, 
                        NULL
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }

    Win32Error = RegSetValueEx(
                        KeyHandle,
                        L"",
                        NULL, 
                        REG_SZ, 
                        ( BYTE * )( L"IIS W3 Control" ),
                        sizeof( L"IIS W3 Control" )
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }

    //
    // Create the LaunchPermissions property
    //

    //
    // initialize an empty acl, which will be what we want
    // to write to the registry to block all launch permissions.
    //
    if ( !InitializeAcl( &LaunchAcl, sizeof( LaunchAcl ), ACL_REVISION ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }

    Win32Error = RegSetValueEx(
                        KeyHandle,
                        L"LaunchPermission",
                        NULL, 
                        REG_BINARY, 
                        reinterpret_cast<BYTE *>( &LaunchAcl ),
                        sizeof( LaunchAcl )
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }
        
    
    Win32Error = RegSetValueEx(
                        KeyHandle,
                        L"LocalService",
                        NULL, 
                        REG_SZ, 
                        ( BYTE * )( WEB_ADMIN_SERVICE_NAME_W ),
                        sizeof( WEB_ADMIN_SERVICE_NAME_W )
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }

    DBG_REQUIRE( RegCloseKey( KeyHandle ) == NO_ERROR );
    KeyHandle = NULL;

    //
    // Set the CLSID key.
    //

    // create string of the form: CLSID\{....}
    struTemp.Copy(g_szCLSID);
    struTemp.Append(L"\\");
    struTemp.Append(g_pwchCLSID_W3Control);

    Win32Error = RegCreateKeyEx(
                        HKEY_CLASSES_ROOT,
                        struTemp.QueryStr(),
                        NULL, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_ALL_ACCESS, 
                        NULL,
                        &KeyHandle, 
                        NULL
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }


    Win32Error = RegSetValueEx(
                        KeyHandle,
                        L"",
                        NULL, 
                        REG_SZ, 
                        ( BYTE * )( L"IIS W3 Control" ),
                        sizeof( L"IIS W3 Control" )
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }

    Win32Error = RegSetValueEx(
                        KeyHandle,
                        L"AppID",
                        NULL, 
                        REG_SZ, 
                        ( BYTE * )( g_pwchCLSID_W3Control ),
                        (wcslen(g_pwchCLSID_W3Control) + 1) * sizeof( WCHAR )  // byte size of string with trailing NULL
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }

    DBG_REQUIRE( RegCloseKey( KeyHandle ) == NO_ERROR );
    KeyHandle = NULL;


    //
    // Register the interface proxy/stub.
    //

    // create string of form: CLSID\{...}
    struTemp.Copy(g_szCLSID);
    struTemp.Append(L"\\");
    struTemp.Append(g_pwchIID_W3Control);

    Win32Error = RegCreateKeyEx(
                        HKEY_CLASSES_ROOT,
                        struTemp.QueryStr(),
                        NULL, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_ALL_ACCESS, 
                        NULL,
                        &KeyHandle, 
                        NULL
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }

    Win32Error = RegSetValueEx(
                        KeyHandle,
                        L"",
                        NULL, 
                        REG_SZ, 
                        ( BYTE * )( L"IIS W3 Control Interface ProxyStub" ),
                        sizeof( L"IIS W3 Control Interface ProxyStub" )
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }


    Win32Error = RegCreateKeyEx(
                        KeyHandle,
                        L"InprocServer32",
                        NULL, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_ALL_ACCESS, 
                        NULL,
                        &KeyHandle2, 
                        NULL
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }

    Win32Error = RegSetValueEx(
                        KeyHandle2,
                        L"",
                        NULL, 
                        REG_SZ, 
                        ( BYTE * )( L"inetsrv\\w3ctrlps.dll" ),
                        sizeof( L"inetsrv\\w3ctrlps.dll" )
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }


    Win32Error = RegSetValueEx(
                        KeyHandle2,
                        L"ThreadingModel",
                        NULL, 
                        REG_SZ, 
                        ( BYTE * )( L"Both" ),
                        sizeof( L"Both" )
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }


    DBG_REQUIRE( RegCloseKey( KeyHandle2 ) == NO_ERROR );
    KeyHandle2 = NULL;

    DBG_REQUIRE( RegCloseKey( KeyHandle ) == NO_ERROR );
    KeyHandle = NULL;


    //
    // Register the interface.
    //

    // create a string of the form: Interface\{...}
    struTemp.Copy(g_szINTERFACE);
    struTemp.Append(L"\\");
    struTemp.Append(g_pwchIID_W3Control);

    Win32Error = RegCreateKeyEx(
                        HKEY_CLASSES_ROOT,
                        struTemp.QueryStr(),
                        NULL, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_ALL_ACCESS, 
                        NULL,
                        &KeyHandle, 
                        NULL
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }

    Win32Error = RegSetValueEx(
                        KeyHandle,
                        L"",
                        NULL, 
                        REG_SZ, 
                        ( BYTE * )( L"IW3Control" ),
                        sizeof( L"IW3Control" )
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }


    Win32Error = RegCreateKeyEx(
                        KeyHandle,
                        L"ProxyStubClsid32",
                        NULL, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_ALL_ACCESS, 
                        NULL,
                        &KeyHandle2, 
                        NULL
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }

    Win32Error = RegSetValueEx(
                        KeyHandle2,
                        L"",
                        NULL, 
                        REG_SZ, 
                        ( BYTE * )g_pwchIID_W3Control,
                        (wcslen(g_pwchIID_W3Control) + 1) * sizeof( WCHAR ) // byte size of string with trailing NULL
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }


    DBG_REQUIRE( RegCloseKey( KeyHandle2 ) == NO_ERROR );
    KeyHandle2 = NULL;

    DBG_REQUIRE( RegCloseKey( KeyHandle ) == NO_ERROR );
    KeyHandle = NULL;


exit:

    if ( FAILED( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "DllRegisterServer failed\n"
            ));
    }


    if ( KeyHandle != NULL )
    {
        DBG_REQUIRE( RegCloseKey( KeyHandle ) == NO_ERROR );
        KeyHandle = NULL;
    }

    if ( KeyHandle2 != NULL )
    {
        DBG_REQUIRE( RegCloseKey( KeyHandle2 ) == NO_ERROR );
        KeyHandle2 = NULL;
    }

    FreeGlobalGUIDStrings();

    return hr;

}   // DllRegisterServer



/***************************************************************************++

Routine Description:

    Unregisters COM pieces. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

STDAPI
DllUnregisterServer(
    )
{

    HRESULT hr = S_OK;

    // when copying and appending - use this buffer 
    STACK_STRU(struTemp, 256);
    STACK_STRU(struTemp2, 256);

    hr = AllocateGlobalGUIDStrings();
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Delete AppID.
    //

    // create string of the form: AppID\{...}
    struTemp.Copy(g_szAPPID);
    struTemp.Append(L"\\");
    struTemp.Append(g_pwchCLSID_W3Control);

    DBG_REQUIRE( RegDeleteKey( HKEY_CLASSES_ROOT, struTemp.QueryStr() ) == NO_ERROR );

    //
    // Delete CLSID.
    //

    // create string of the form: CLSID\{....}
    struTemp.Copy(g_szCLSID);
    struTemp.Append(L"\\");
    struTemp.Append(g_pwchCLSID_W3Control);

    DBG_REQUIRE( RegDeleteKey( HKEY_CLASSES_ROOT, struTemp.QueryStr() ) == NO_ERROR );


    //
    // Delete the interface proxy/stub.
    //

    // create string of form: CLSID\{...}
    struTemp.Copy(g_szCLSID);
    struTemp.Append(L"\\");
    struTemp.Append(g_pwchIID_W3Control);

    // need to delete the sub key's first
    struTemp2.Copy(struTemp.QueryStr());
    struTemp2.Append(L"\\");
    struTemp2.Append(L"InprocServer32");

    // first delete the sub key.
    DBG_REQUIRE( RegDeleteKey( HKEY_CLASSES_ROOT, struTemp2.QueryStr() ) == NO_ERROR );

    // then delete the top key
    DBG_REQUIRE( RegDeleteKey( HKEY_CLASSES_ROOT, struTemp.QueryStr() ) == NO_ERROR );


    //
    // Delete the interface.
    //

    // create a string of the form: Interface\{...}
    struTemp.Copy(g_szINTERFACE);
    struTemp.Append(L"\\");
    struTemp.Append(g_pwchIID_W3Control);

    // need to delete the sub key's first
    struTemp2.Copy(struTemp.QueryStr());
    struTemp2.Append(L"\\");
    struTemp2.Append(L"ProxyStubClsid32");

    // first delete the sub key.
    DBG_REQUIRE( RegDeleteKey( HKEY_CLASSES_ROOT, struTemp2.QueryStr() ) == NO_ERROR );
    
    // then delete the top key
    DBG_REQUIRE( RegDeleteKey( HKEY_CLASSES_ROOT, struTemp.QueryStr() ) == NO_ERROR );


    FreeGlobalGUIDStrings();
    return hr;

}   // DllUnregisterServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\config_change_sink.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    config_change_sink.h

Abstract:

    The IIS web admin service configuration change sink class definition.

Author:

    Seth Pollack (sethp)        18-Nov-1999

Revision History:

--*/



#ifndef _CONFIG_CHANGE_SINK_H_
#define _CONFIG_CHANGE_SINK_H_



//
// common #defines
//

#define CONFIG_CHANGE_SINK_SIGNATURE        CREATE_SIGNATURE( 'CCSK' )
#define CONFIG_CHANGE_SINK_SIGNATURE_FREED  CREATE_SIGNATURE( 'ccsX' )



//
// prototypes
//


class CONFIG_CHANGE_SINK
    : public ISimpleTableEvent
{

public:

    CONFIG_CHANGE_SINK(
        );

    virtual
    ~CONFIG_CHANGE_SINK(
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    QueryInterface(
        IN REFIID iid,
        OUT VOID ** ppObject
        );

    virtual
    ULONG
    STDMETHODCALLTYPE
    AddRef(
        );

    virtual
    ULONG
    STDMETHODCALLTYPE
    Release(
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    OnChange(
        IN ISimpleTableWrite2 ** ppDeltaTables,
        IN ULONG CountOfTables,
        IN DWORD ChangeNotifyCookie
        );


private:


    DWORD m_Signature;

    LONG m_RefCount;


};  // class CONFIG_CHANGE_SINK



#endif  // _CONFIG_CHANGE_SINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\config_change_sink.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    config_change_sink.cxx

Abstract:

    The IIS web admin service configuration change sink class implementation. 
    This class handles notifcations of configuration changes.

    Threading: Configuration changes arrive on COM threads (i.e., secondary 
    threads), and so work items are posted to process the changes on the main 
    worker thread.

Author:

    Seth Pollack (sethp)        18-Nov-1999

Revision History:

--*/



#include  "precomp.h"



/***************************************************************************++

Routine Description:

    Constructor for the CONFIG_CHANGE_SINK class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONFIG_CHANGE_SINK::CONFIG_CHANGE_SINK(
    )
{

    //
    // Set the initial reference count to 1, in order to represent the
    // reference owned by the creator of this instance.
    //

    m_RefCount = 1;

    m_Signature = CONFIG_CHANGE_SINK_SIGNATURE;

}   // CONFIG_CHANGE_SINK::CONFIG_CHANGE_SINK



/***************************************************************************++

Routine Description:

    Destructor for the CONFIG_CHANGE_SINK class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONFIG_CHANGE_SINK::~CONFIG_CHANGE_SINK(
    )
{

    DBG_ASSERT( m_Signature == CONFIG_CHANGE_SINK_SIGNATURE );

    m_Signature = CONFIG_CHANGE_SINK_SIGNATURE_FREED;

    DBG_ASSERT( m_RefCount == 0 );

}   // CONFIG_CHANGE_SINK::~CONFIG_CHANGE_SINK



/***************************************************************************++

Routine Description:

    Standard IUnknown::QueryInterface.

Arguments:

    iid - The requested interface id.

    ppObject - The returned interface pointer, or NULL on failure.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CONFIG_CHANGE_SINK::QueryInterface(
    IN REFIID iid,
    OUT VOID ** ppObject
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ppObject != NULL );


    if ( iid == IID_IUnknown || iid == IID_ISimpleTableEvent )
    {
        *ppObject = reinterpret_cast < ISimpleTableEvent * > ( this );

        AddRef();
    }
    else
    {
        *ppObject = NULL;
        
        hr = E_NOINTERFACE;
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "QueryInterface on CONFIG_CHANGE_SINK object failed\n"
            ));

    }


    return hr;

}   // CONFIG_CHANGE_SINK::QueryInterface



/***************************************************************************++

Routine Description:

    Standard IUnknown::AddRef.

Arguments:

    None.

Return Value:

    ULONG - The new reference count.

--***************************************************************************/

ULONG
STDMETHODCALLTYPE
CONFIG_CHANGE_SINK::AddRef(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedIncrement( &m_RefCount );


    //
    // The reference count should never have been less than zero; and
    // furthermore once it has hit zero it should never bounce back up;
    // given these conditions, it better be greater than one now.
    //
    
    DBG_ASSERT( NewRefCount > 1 );


    return ( ( ULONG ) NewRefCount );

}   // CONFIG_CHANGE_SINK::AddRef



/***************************************************************************++

Routine Description:

    Standard IUnknown::Release.

Arguments:

    None.

Return Value:

    ULONG - The new reference count.

--***************************************************************************/

ULONG
STDMETHODCALLTYPE
CONFIG_CHANGE_SINK::Release(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedDecrement( &m_RefCount );

    // ref count should never go negative
    DBG_ASSERT( NewRefCount >= 0 );

    if ( NewRefCount == 0 )
    {
        // time to go away

        IF_DEBUG( WEB_ADMIN_SERVICE_REFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Reference count has hit zero in CONFIG_CHANGE_SINK, deleting (ptr: %p)\n",
                this
                ));
        }


        delete this;


    }


    return ( ( ULONG ) NewRefCount );

}   // CONFIG_CHANGE_SINK::Release



/***************************************************************************++

Routine Description:

    Process configuration changes by posting a work item to the main worker
    thread. 

Arguments:

    ppDeltaTables - The array of tables, each containing deltas for one
    configuration table. Any of these may be NULL.

    CountOfTables - The number of tables in the array.

    ChangeNotifyCookie - The cookie value for this notification registration. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CONFIG_CHANGE_SINK::OnChange(
    IN ISimpleTableWrite2 ** ppDeltaTables,
    IN ULONG CountOfTables,
    IN DWORD ChangeNotifyCookie
    )
{

    HRESULT hr = S_OK;
    CONFIG_CHANGE * pConfigChange = NULL;
    ULONG i = 0;


    DBG_ASSERT( ! ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( ppDeltaTables != NULL );
    DBG_ASSERT( CountOfTables == NUMBER_OF_CONFIG_TABLES );

    //
    // Need to call back to catalog and adjust the tables to make sure
    // they are not telling me to do something I can not handle.
    //
    for ( DWORD i = 0; i < CountOfTables ; i++ )
    {
    //    hr = PostProcessChanges ( ppDeltaTables[i] );
        if ( FAILED ( hr ) )
        {
      
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Post processing the changes failed on table %d\n",
                i
                ));

            GetWebAdminService()->FatalErrorOnSecondaryThread( hr );

            goto exit;

        }
    }

    //
    // Create an object to hold the config change information.
    //

    pConfigChange = new CONFIG_CHANGE();

    if ( pConfigChange == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating CONFIG_CHANGE failed\n"
            ));

        GetWebAdminService()->FatalErrorOnSecondaryThread( hr );

        goto exit;
    }


    //
    // Note that the config change object will AddRef() any interface 
    // pointers it keeps.
    //

    hr = pConfigChange->Initialize(
                            ppDeltaTables,
                            CountOfTables,
                            ChangeNotifyCookie
                            );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing config change failed\n"
            ));

        GetWebAdminService()->FatalErrorOnSecondaryThread( hr );

        goto exit;
    }


    //
    // Post to the main worker thread for processing.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "About to create/queue work item for processing configuration changes, CONFIG_CHANGE (ptr: %p)\n",
            pConfigChange
            ));
    }


    QueueWorkItemFromSecondaryThread(
        pConfigChange,
        ProcessChangeConfigChangeWorkItem
        );


exit:

    // The QueueWorkItemFromSecondaryThread will
    // have taken a reference on this object as well
    // as the one the constructor provides, so we need
    // to release the one the constructor provided.
    if (pConfigChange)
    {
        pConfigChange->Dereference();
        pConfigChange = NULL;
    }

    return hr;

}   // CONFIG_CHANGE_SINK::OnChange
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\config_manager.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    config_manager.cxx

Abstract:

    The IIS web admin service configuration manager class implementation. 
    This class manages access to configuration metadata, as well as 
    handling dynamic configuration changes.

    Threading: Access to configuration metadata is done on the main worker 
    thread. Configuration changes arrive on COM threads (i.e., secondary 
    threads), and so work items are posted to process the changes on the main 
    worker thread.

Author:

    Seth Pollack (sethp)        5-Jan-1999

Revision History:

--*/



#include  "precomp.h"

//
// This is declared in iiscnfg.h but it is ansii and we need unicode.
#define IIS_MD_SVC_INFO_PATH_W            L"Info"


/***************************************************************************++

Routine Description:

    Constructor for the CONFIG_MANAGER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONFIG_MANAGER::CONFIG_MANAGER(
    )
{

    m_pISimpleTableDispenser2  = NULL;

    m_pISimpleTableAdvise = NULL; 

    m_pConfigChangeSink = NULL; 

    m_ChangeNotifyCookie = 0;

    m_ChangeNotifySinkRegistered = FALSE;

    m_ProcessConfigChanges = TRUE;

    m_Signature = CONFIG_MANAGER_SIGNATURE;

}   // CONFIG_MANAGER::CONFIG_MANAGER



/***************************************************************************++

Routine Description:

    Destructor for the CONFIG_MANAGER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONFIG_MANAGER::~CONFIG_MANAGER(
    )
{

    DBG_ASSERT( m_Signature == CONFIG_MANAGER_SIGNATURE );

    m_Signature = CONFIG_MANAGER_SIGNATURE_FREED;

    DBG_ASSERT( ! m_ProcessConfigChanges );

    DBG_ASSERT( ! m_ChangeNotifySinkRegistered );

    DBG_ASSERT( m_pConfigChangeSink == NULL );

    DBG_ASSERT( m_pISimpleTableAdvise == NULL );

    DBG_ASSERT( m_pISimpleTableDispenser2 == NULL );


}   // CONFIG_MANAGER::~CONFIG_MANAGER



/***************************************************************************++

Routine Description:

    Initialize the configuration manager.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::Initialize(
    )
{

    HRESULT hr = S_OK;
    ISnapshotManager * pISnapshotManager = NULL;
    DWORD SnapshotId = 0;
    BOOL SnapshotReferenced = FALSE;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    //
    // BUGBUG Temporary -- this call to cookdown should go away once
    // the separate config admin service is working. Certainly before
    // beta 1.
    //
    // Force a check to make sure that the config cache is up to date;
    // this will update the cache if necessary. 
    //

    hr = CookDown( WSZ_PRODUCT_IIS );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Cookdown of configuration failed; will attempt to read old version if it exists\n"
            ));


        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_CONFIG_MANAGER_COOKDOWN_FAILED,                    // message id
                0,                                                     // count of strings
                NULL,                                                  // array of strings
                hr                                                     // error code
                );

    }


    //
    // Get the config store's main interface.
    //

    hr = GetSimpleTableDispenser(
                WSZ_PRODUCT_IIS,                // product name
                0,                              // reserved
                &m_pISimpleTableDispenser2      // returned interface
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating simple table dispenser failed\n"
            )); 

        goto exit;
    }


    //
    // Reference the latest snapshot, so that we have stable access
    // to a consistent view.
    //
    
    hr = m_pISimpleTableDispenser2->QueryInterface(
                                        IID_ISnapshotManager, 
                                        reinterpret_cast <VOID **> ( &pISnapshotManager )
                                        );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Getting snapshot manager interface failed\n"
            )); 

        goto exit;
    }


    hr = pISnapshotManager->QueryLatestSnapshot( &SnapshotId );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Referencing snapshot failed\n"
            )); 

        goto exit;
    }

    SnapshotReferenced = TRUE;


    //
    // Now read all initial configuration.
    //

    hr = ReadAllConfiguration();

    if ( FAILED( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Reading initial configuration failed\n"
            ));

        goto exit;
    }


    //
    // Subscribe for change notification, relative to the snapshot
    // we just read.
    //

    hr = RegisterChangeNotify( SnapshotId );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Registering for change notification failed\n"
            ));

        goto exit;
    }

    // Configure the metabase to advertise the features the
    // server supports.  
    AdvertiseServiceInformationInMB();

exit:

    if ( SnapshotReferenced )
    {
        DBG_REQUIRE( SUCCEEDED( pISnapshotManager->ReleaseSnapshot( SnapshotId ) ) );
    }


    if ( pISnapshotManager != NULL )
    {
        pISnapshotManager->Release();
        pISnapshotManager = NULL;
    }


    return hr;

}   // CONFIG_MANAGER::Initialize



/***************************************************************************++

Routine Description:

    Begin termination of this object. Tell all referenced or owned entities 
    which may hold a reference to this object to release that reference 
    (and not take any more), in order to break reference cycles. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
CONFIG_MANAGER::Terminate(
    )
{
    HRESULT hr = S_OK;

    //
    // Our parent's Terminiate() method should already have stopped config
    // change processing. 
    //

    DBG_ASSERT( m_ProcessConfigChanges == FALSE );


    //
    // Release held interface pointers.
    //

    if ( m_pConfigChangeSink != NULL )
    {
        m_pConfigChangeSink->Release();
        m_pConfigChangeSink = NULL;
    }


    if ( m_pISimpleTableAdvise != NULL )
    {
        m_pISimpleTableAdvise->Release();
        m_pISimpleTableAdvise = NULL;
    }


    if ( m_pISimpleTableDispenser2 != NULL )
    {
        m_pISimpleTableDispenser2->Release();
        m_pISimpleTableDispenser2 = NULL;
    }

    hr = UninitCookdown( WSZ_PRODUCT_IIS, FALSE );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Uninitialization of Cookdown failed.\n"
            ));

    }

}   // CONFIG_MANAGER::Terminate



/***************************************************************************++

Routine Description:

    Process a configuration change notification. 

Arguments:

    pConfigChange - The configuration change description object. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ProcessConfigChange(
    IN CONFIG_CHANGE * pConfigChange
    )
{

    HRESULT hr = S_OK;
    ULONG TableIndex = 0;
    ULONG i = 0;
    ULONG j = 0;
    DWORD Action = 0;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( pConfigChange != NULL );

    DBG_ASSERT( pConfigChange->GetChangeNotifyCookie() == m_ChangeNotifyCookie );


    //
    // If we have turned off config change processing, then bail out.
    //

    if ( ! m_ProcessConfigChanges )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Ignoring configuration change because we are no longer processing them (CONFIG_CHANGE ptr: %p)\n",
                pConfigChange
                ));
        }

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Processing configuration change (CONFIG_CHANGE ptr: %p)\n",
            pConfigChange
            ));
    }


    //
    // Process the changes. In order to avoid invalid intermediate states,
    // the changes are processed in a particular order. Specifically, we
    // want to avoid situations where we have an entity that depends on 
    // another entity that transiently might not be present. (For example, 
    // adding a new application before it's application pool is added).
    // Therefore, we process addtions, then modifications, then deletions;
    // and within each of those groups, we process additions and 
    // modifications in least to most dependent order, and deletions in 
    // the opposite order. So the order is:
    //
    // additions
    //  app pools
    //  sites
    //  apps
    // modifications
    //  app pools
    //  sites
    //  apps
    // deletions
    //  apps
    //  sites
    //  app pools
    //


    //
    // Note that the ordering described above simply prevents invalid
    // intermediate states in terms of pointers between internal objects. It
    // does not prevent transient weird behavior around config changes. 
    // Specifically, hierarchical URL routing can cause transient misrouting
    // of requests while moving from one stable state to another. 
    // For example, say you are adding a new app at /app/ under a site. If 
    // you put the content out in the filesystem before adding the config, 
    // then the root app (at /) could accidentally serve that content, 
    // perhaps with the wrong security settings or the like, until the new
    // config is updated and processed. On the other hand, if you add the 
    // config first before the content, you will get 404 errors.
    // A second example is adding two apps to the config, one at /app1/ and 
    // one at /app1/app2/. If get these in one change set, and add /app1/ 
    // first, then in that moment until we add /app1/app2/, the app1 will get 
    // requests intended for app2. 
    // There are a variety of workarounds for these cases. However, the
    // general answer is, if a customer is concerned about this, they should
    // pause the virtual site (or some appropriate unit of the web server),
    // make the changes, then re-enable the site. I believe by the way that
    // existing IIS has the same problems. 
    // BUGBUG Is this solution acceptible? Or should we try to do something
    // better? And if so, what? Current plan is this solution. EricDe agrees
    // (12/6/99).
    //


    //
    // Process additions.
    //

    for ( TableIndex = 0; TableIndex < NUMBER_OF_CONFIG_TABLES; TableIndex++ )
    {

        //
        // Go on to the next table if this one is NULL.
        //

        if ( pConfigChange->GetTableController( TableIndex ) == NULL )
        {
            continue;
        }


        for ( i = 0; ; i++ )
        {
            hr = pConfigChange->GetTableController( TableIndex )->GetWriteRowAction( i, &Action ); 

            if ( hr == E_ST_NOMOREROWS )
            {
                hr = S_OK;

                break;
            }
            else if ( FAILED( hr ) )
            {

                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Error getting write row action\n"
                    ));

                goto exit;
            }

            if ( Action == eST_ROW_INSERT )
            {

                switch ( TableIndex )
                {
                
                case TABLE_INDEX_GLOBAL:

                    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
                    {
                        DBGPRINTF((
                            DBG_CONTEXT, 
                            "About to process config update: global data modified\n"
                            ));
                    }

                    hr = ModifyGlobalData(
                            pConfigChange->GetDeltaTable( TableIndex ),
                            i
                            );

                    if ( FAILED( hr ) )
                    {
                    
                        DPERROR(( 
                            DBG_CONTEXT,
                            hr,
                            "Modifying global data failed\n"
                            ));

                        goto exit;
                    }

                    break;

                case TABLE_INDEX_APPPOOLS:

                    //
                    // Don't allow for insertions of app pools in BC mode.
                    //
                    if ( !GetWebAdminService()->IsBackwardCompatibilityEnabled() )
                    {

                        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
                        {
                            DBGPRINTF((
                                DBG_CONTEXT, 
                                "About to process config update: app pool added\n"
                                ));
                        }

                        hr = CreateAppPool(
                                    pConfigChange->GetDeltaTable( TableIndex ),
                                    i,
                                    FALSE
                                    );

                        if ( FAILED( hr ) )
                        {
                    
                            DPERROR(( 
                                DBG_CONTEXT,
                                hr,
                                "Creating app pool failed\n"
                                ));

                            goto exit;
                        }
                    }

                    break;

                case TABLE_INDEX_SITES:

                    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
                    {
                        DBGPRINTF((
                            DBG_CONTEXT, 
                            "About to process config update: virtual site added\n"
                            ));
                    }

                    hr = CreateVirtualSite(
                                pConfigChange->GetDeltaTable( TableIndex ),
                                i,
                                FALSE
                                );

                    if ( FAILED( hr ) )
                    {
                    
                        DPERROR(( 
                            DBG_CONTEXT,
                            hr,
                            "Creating virtual site failed\n"
                            ));

                        goto exit;
                    }

                    break;
                
                case TABLE_INDEX_APPS:

                    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
                    {
                        DBGPRINTF((
                            DBG_CONTEXT, 
                            "About to process config update: application added\n"
                            ));
                    }

                    hr = CreateApplication(
                                pConfigChange->GetDeltaTable( TableIndex ),
                                i,
                                FALSE
                                );

                    if ( FAILED( hr ) )
                    {
                    
                        DPERROR(( 
                            DBG_CONTEXT,
                            hr,
                            "Creating application failed\n"
                            ));

                        goto exit;
                    }

                    break;

                default:
                 
                // We could hit here with TABLE_INDEX_GLOBAL, however
                // we should still assert, because we should never have
                // more than one row, and we should never have less than
                // one row, so an insert or delete notification would be
                // a problem.

                DBG_ASSERT( FALSE );
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

                break;

                }

            }

        }

    }


    //
    // Process modifications.
    //

    for ( TableIndex = 0; TableIndex < NUMBER_OF_CONFIG_TABLES; TableIndex++ )
    {

        //
        // Go on to the next table if this one is NULL.
        //

        if ( pConfigChange->GetTableController( TableIndex ) == NULL )
        {
            continue;
        }


        for ( i = 0; ; i++ )
        {
            hr = pConfigChange->GetTableController( TableIndex )->GetWriteRowAction( i, &Action ); 

            if ( hr == E_ST_NOMOREROWS )
            {
                hr = S_OK;

                break;
            }
            else if ( FAILED( hr ) )
            {

                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Error getting write row action\n"
                    ));

                goto exit;
            }

            if ( Action == eST_ROW_UPDATE )
            {

                switch ( TableIndex )
                {
                
                case TABLE_INDEX_GLOBAL:

                    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
                    {
                        DBGPRINTF((
                            DBG_CONTEXT, 
                            "About to process config update: global data modified\n"
                            ));
                    }

                    hr = ModifyGlobalData(
                            pConfigChange->GetDeltaTable( TableIndex ),
                            i
                            );

                    if ( FAILED( hr ) )
                    {
                    
                        DPERROR(( 
                            DBG_CONTEXT,
                            hr,
                            "Modifying global data failed\n"
                            ));

                        goto exit;
                    }

                    break;

                case TABLE_INDEX_APPPOOLS:

                    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
                    {
                        DBGPRINTF((
                            DBG_CONTEXT, 
                            "About to process config update: app pool modified\n"
                            ));
                    }

                    hr = ModifyAppPool(
                                pConfigChange->GetDeltaTable( TableIndex ),
                                i
                                );

                    if ( FAILED( hr ) )
                    {
                    
                        DPERROR(( 
                            DBG_CONTEXT,
                            hr,
                            "Modifying app pool failed\n"
                            ));

                        goto exit;
                    }

                    break;
                
                case TABLE_INDEX_SITES:

                    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
                    {
                        DBGPRINTF((
                            DBG_CONTEXT, 
                            "About to process config update: virtual site modified\n"
                            ));
                    }

                    hr = ModifyVirtualSite(
                                pConfigChange->GetDeltaTable( TableIndex ),
                                i
                                );

                    if ( FAILED( hr ) )
                    {
                    
                        DPERROR(( 
                            DBG_CONTEXT,
                            hr,
                            "Modifying virtual site failed\n"
                            ));

                        goto exit;
                    }

                    break;
                
                case TABLE_INDEX_APPS:

                    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
                    {
                        DBGPRINTF((
                            DBG_CONTEXT, 
                            "About to process config update: application modified\n"
                            ));
                    }

                    hr = ModifyApplication(
                                pConfigChange->GetDeltaTable( TableIndex ),
                                i
                                );

                    if ( FAILED( hr ) )
                    {
                    
                        DPERROR(( 
                            DBG_CONTEXT,
                            hr,
                            "Modifying application failed\n"
                            ));

                        goto exit;
                    }

                    break;

                default:

                DBG_ASSERT( FALSE );
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

                break;

                }

            }

        }

    }


    //
    // Process deletions. Note reverse table order.
    //

    for ( j = 0; j < NUMBER_OF_CONFIG_TABLES; j++ )
    {

        TableIndex = NUMBER_OF_CONFIG_TABLES - j - 1;


        //
        // Go on to the next table if this one is NULL.
        //

        if ( pConfigChange->GetTableController( TableIndex ) == NULL )
        {
            continue;
        }


        for ( i = 0; ; i++ )
        {
            hr = pConfigChange->GetTableController( TableIndex )->GetWriteRowAction( i, &Action ); 

            if ( hr == E_ST_NOMOREROWS )
            {
                hr = S_OK;

                break;
            }
            else if ( FAILED( hr ) )
            {

                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Error getting write row action\n"
                    ));

                goto exit;
            }

            if ( Action == eST_ROW_DELETE )
            {

                switch ( TableIndex )
                {
                
                case TABLE_INDEX_APPPOOLS:

                    //
                    // Don't allow for deletions of app pools in BC mode.
                    //
                    if ( !GetWebAdminService()->IsBackwardCompatibilityEnabled() )
                    {
                        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
                        {
                            DBGPRINTF((
                                DBG_CONTEXT, 
                                "About to process config update: app pool deleted\n"
                                ));
                        }

                        hr = DeleteAppPool(
                                    pConfigChange->GetDeltaTable( TableIndex ),
                                    i
                                    );

                        if ( FAILED( hr ) )
                        {
                    
                            DPERROR(( 
                                DBG_CONTEXT,
                                hr,
                                "Deleting app pool failed\n"
                                ));

                            goto exit;
                        }
                    }

                    break;
                
                case TABLE_INDEX_SITES:

                    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
                    {
                        DBGPRINTF((
                            DBG_CONTEXT, 
                            "About to process config update: virtual site deleted\n"
                            ));
                    }

                    hr = DeleteVirtualSite(
                                pConfigChange->GetDeltaTable( TableIndex ),
                                i
                                );

                    if ( FAILED( hr ) )
                    {
                    
                        DPERROR(( 
                            DBG_CONTEXT,
                            hr,
                            "Deleting virtual site failed\n"
                            ));

                        goto exit;
                    }

                    break;
                
                case TABLE_INDEX_APPS:

                    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
                    {
                        DBGPRINTF((
                            DBG_CONTEXT, 
                            "About to process config update: application deleted\n"
                            ));
                    }

                    hr = DeleteApplication(
                                pConfigChange->GetDeltaTable( TableIndex ),
                                i
                                );

                    if ( FAILED( hr ) )
                    {
                    
                        DPERROR(( 
                            DBG_CONTEXT,
                            hr,
                            "Deleting application failed\n"
                            ));

                        goto exit;
                    }

                    break;

                default:

                // We could hit here with TABLE_INDEX_GLOBAL, however
                // we should still assert, because we should never have
                // more than one row, and we should never have less than
                // one row, so an insert or delete notification would be
                // a problem.

                DBG_ASSERT( FALSE );
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

                break;

                }

            }

        }

    }


exit:

    return hr;

}   // CONFIG_MANAGER::ProcessConfigChange



/***************************************************************************++

Routine Description:

    Discontinue both listening for configuration changes, and also 
    processing those config changes that have already been queued but not
    yet handled. This can be safely called multiple times. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::StopChangeProcessing(
    )
{

    HRESULT hr = S_OK;
			

    if ( m_ProcessConfigChanges )
    {


        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Disabling config change processing\n"
                ));
        }


        m_ProcessConfigChanges = FALSE;


        hr = UnregisterChangeNotify();

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Unregistering config change notification failed\n"
                ));

            goto exit;
        }

    }


exit:

    return hr;

}   // CONFIG_MANAGER::StopChangeProcessing


/***************************************************************************++

Routine Description:

    Notifies the catalog that there has been a problem with inetinfo
    and has the catalog rehook up for change notifications.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::RehookChangeProcessing(
    )
{

    HRESULT hr = S_OK;


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Rehooking config change processing\n"
            ));
    }

    
    //
    // Tell catalog to rehookup change notifications
    //
    hr = RecoverFromInetInfoCrash( WSZ_PRODUCT_IIS );
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Rehooking change notifications failed\n"
            ));

    }

    return hr;

}   // CONFIG_MANAGER::RehookChangeProcessing


/***************************************************************************++

Routine Description:

    Write the virtual site state and error value back to the config store.

Arguments:

    VirtualSiteId - The virtual site.

    ServerState - The value to write for the ServerState property.

    Win32Error - The value to write for the Win32Error property.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::SetVirtualSiteStateAndError(
    IN DWORD VirtualSiteId,
    IN DWORD ServerState,
    IN DWORD Win32Error
    )
{

    HRESULT hr = S_OK;
    ISimpleTableWrite2 * pISTVirtualSites = NULL;
    static const ULONG SiteColumns[] = { 
                            iSITES_SiteID,
                            iSITES_ServerState,
                            iSITES_Win32Error
                            };
    static const ULONG CountOfSiteColumns = sizeof( SiteColumns ) / sizeof( ULONG );
    VOID * pSiteValues[ cSITES_NumberOfColumns ];
    ULONG RowIndex = 0;

    //
    // Only save these values to the metabase if we believe
    // that writing to the metabase is still possible.
    //
    if ( GetWebAdminService()->DontWriteToMetabase() )
    {
        return S_OK;
    }

    //
    // Get the sites table from the config store.
    //

    hr = GetTable( 
                wszTABLE_SITES,
                EXPECTED_VERSION_SITES,
                TRUE,
                reinterpret_cast <VOID **> ( &pISTVirtualSites ) 
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Getting sites table failed\n"
            ));

        goto exit;
    }


    //
    // Set up the column values for writing.
    //

    pSiteValues[ iSITES_SiteID ] = &VirtualSiteId; 
    pSiteValues[ iSITES_ServerState ] = &ServerState; 
    pSiteValues[ iSITES_Win32Error ] = &Win32Error; 


    //
    // Write the values to the config store. Even though the call
    // is to add row for "insert", it is really for update, not insert.
    //

    hr = pISTVirtualSites->AddRowForInsert( &RowIndex );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Adding row (to do write) failed\n"
            ));

        goto exit;
    }


    hr = pISTVirtualSites->SetWriteColumnValues(
                                RowIndex,                       // row to read
                                CountOfSiteColumns,             // count of columns
                                const_cast <ULONG *> ( SiteColumns ),  // which columns
                                NULL,                           // column sizes
                                pSiteValues                     // new values
                                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting write column values failed\n"
            ));

        goto exit;
    }


    hr = pISTVirtualSites->UpdateStore();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Updating store failed\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Wrote to config store for virtual site with ID: %lu, state: %lu; error: %lu\n",
            VirtualSiteId,
            ServerState,
            Win32Error
            ));
    }


exit: 

    if ( pISTVirtualSites != NULL )
    {
        pISTVirtualSites->Release();
        pISTVirtualSites = NULL; 
    }


    return hr;

}   // CONFIG_MANAGER::SetVirtualSiteStateAndError



/***************************************************************************++

Routine Description:

    Write the virtual site autostart property back to the config store.

Arguments:

    VirtualSiteId - The virtual site.

    Autostart - The value to write for the autostart property.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::SetVirtualSiteAutostart(
    IN DWORD VirtualSiteId,
    IN BOOL Autostart
    )
{

    HRESULT hr = S_OK;
    ISimpleTableWrite2 * pISTVirtualSites = NULL;
    static const ULONG SiteColumns[] = { 
                            iSITES_SiteID,
                            iSITES_ServerAutoStart
                            };
    static const ULONG CountOfSiteColumns = sizeof( SiteColumns ) / sizeof( ULONG );
    VOID * pSiteValues[ cSITES_NumberOfColumns ];
    ULONG RowIndex = 0;

    //
    // AutoStart should never change when this would not be acceptable.
    //
    DBG_ASSERT ( !GetWebAdminService()->DontWriteToMetabase() );

    //
    // Get the sites table from the config store.
    //

    hr = GetTable( 
                wszTABLE_SITES,
                EXPECTED_VERSION_SITES,
                TRUE,
                reinterpret_cast <VOID **> ( &pISTVirtualSites )
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Getting sites table failed\n"
            ));

        goto exit;
    }


    //
    // Set up the column values for writing.
    //

    pSiteValues[ iSITES_SiteID ] = &VirtualSiteId; 
    pSiteValues[ iSITES_ServerAutoStart ] = &Autostart; 


    //
    // Write the values to the config store. Even though the call
    // is to add row for "insert", it is really for update, not insert.
    //

    hr = pISTVirtualSites->AddRowForInsert( &RowIndex );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Adding row (to do write) failed\n"
            ));

        goto exit;
    }


    hr = pISTVirtualSites->SetWriteColumnValues(
                                RowIndex,                       // row to read
                                CountOfSiteColumns,             // count of columns
                                const_cast < ULONG * > ( SiteColumns ),  // which columns
                                NULL,                           // column sizes
                                pSiteValues                     // new values
                                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting write column values failed\n"
            ));

        goto exit;
    }


    hr = pISTVirtualSites->UpdateStore();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Updating store failed\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Wrote to config store for virtual site with ID: %lu, Autostart value: %S\n",
            VirtualSiteId,
            ( Autostart ? L"TRUE" : L"FALSE" )
            ));
    }


exit: 

    if ( pISTVirtualSites != NULL )
    {
        pISTVirtualSites->Release();
        pISTVirtualSites = NULL; 
    }


    return hr;

}   // CONFIG_MANAGER::SetVirtualSiteAutostart

/***************************************************************************++

Routine Description:

    Write the app pool state back to the config store.

Arguments:

    IN LPCWSTR pAppPoolId  -  App Pool whose state changed.

    IN DWORD ServerState - The value to write for the ServerState property.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
CONFIG_MANAGER::SetAppPoolState(
    IN LPCWSTR pAppPoolId,
    IN DWORD ServerState
    )
{

    HRESULT hr = S_OK;
    ISimpleTableWrite2 * pISTAppPools = NULL;
    static const ULONG AppPoolColumns[] = { 
                            iAPPPOOLS_AppPoolID,
                            iAPPPOOLS_AppPoolState
                            };
    static const ULONG CountOfAppPoolColumns = sizeof( AppPoolColumns ) / sizeof( ULONG );
    VOID * pAppPoolValues[ cAPPPOOLS_NumberOfColumns ];
    ULONG RowIndex = 0;

    DBG_ASSERT ( pAppPoolId );

    //
    // Only save these values to the metabase if we believe
    // that writing to the metabase is still possible.
    //
    if ( GetWebAdminService()->DontWriteToMetabase() )
    {
        return S_OK;
    }

    //
    // Get the sites table from the config store.
    //

    hr = GetTable( 
                wszTABLE_APPPOOLS,
                EXPECTED_VERSION_APPPOOLS,
                TRUE,
                reinterpret_cast < VOID ** > ( &pISTAppPools ) 
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Getting app pool table failed\n"
            ));

        goto exit;
    }


    //
    // Set up the column values for writing.
    //

    pAppPoolValues[ iAPPPOOLS_AppPoolID ] = ( LPVOID ) pAppPoolId; 
    pAppPoolValues[ iAPPPOOLS_AppPoolState ] = &ServerState; 


    //
    // Write the values to the config store. Even though the call
    // is to add row for "insert", it is really for update, not insert.
    //

    hr = pISTAppPools->AddRowForInsert( &RowIndex );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Adding row (to do write) failed\n"
            ));

        goto exit;
    }


    hr = pISTAppPools->SetWriteColumnValues(
                                RowIndex,                          // row to read
                                CountOfAppPoolColumns,             // count of columns
                                const_cast < ULONG * > ( AppPoolColumns ),  // which columns
                                NULL,                              // column sizes
                                pAppPoolValues                     // new values
                                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting write column values failed\n"
            ));

        goto exit;
    }


    hr = pISTAppPools->UpdateStore();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Updating store failed\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Wrote to config store for app pool with ID: %S, state: %lu; \n",
            pAppPoolId,
            ServerState
            ));
    }


exit: 

    if ( pISTAppPools != NULL )
    {
        pISTAppPools->Release();
        pISTAppPools = NULL; 
    }


    return hr;

}   // CONFIG_MANAGER::SetAppPoolState



/***************************************************************************++

Routine Description:

    Write the app pool autostart property back to the config store.

Arguments:

    pAppPoolId - The app pool id for the app pool that's changing.

    Autostart - The value to write for the autostart property.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
CONFIG_MANAGER::SetAppPoolAutostart(
    IN LPCWSTR pAppPoolId,
    IN BOOL Autostart
    )
{

    HRESULT hr = S_OK;
    ISimpleTableWrite2 * pISTAppPools = NULL;
    static const ULONG AppPoolColumns[] = { 
                            iAPPPOOLS_AppPoolID,
                            iAPPPOOLS_AppPoolAutoStart
                            };
    static const ULONG CountOfAppPoolColumns = sizeof( AppPoolColumns ) / sizeof( ULONG );
    VOID * pAppPoolValues[ cAPPPOOLS_NumberOfColumns ];
    ULONG RowIndex = 0;

    // We should never get called in BC Mode.

    DBG_ASSERT ( !GetWebAdminService()->IsBackwardCompatibilityEnabled() );

    //
    // AutoStart should never change when this would not be acceptable.
    //
    DBG_ASSERT ( !GetWebAdminService()->DontWriteToMetabase() );


    //
    // Get the sites table from the config store.
    //

    hr = GetTable( 
                wszTABLE_APPPOOLS,
                EXPECTED_VERSION_APPPOOLS,
                TRUE,
                reinterpret_cast <VOID **> ( &pISTAppPools )  
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Getting app pool table failed\n"
            ));

        goto exit;
    }


    //
    // Set up the column values for writing.
    //

    pAppPoolValues[ iAPPPOOLS_AppPoolID ] =  ( LPVOID ) pAppPoolId; 
    pAppPoolValues[ iAPPPOOLS_AppPoolAutoStart ] = &Autostart; 


    //
    // Write the values to the config store. Even though the call
    // is to add row for "insert", it is really for update, not insert.
    //

    hr = pISTAppPools->AddRowForInsert( &RowIndex );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Adding row (to do write) failed\n"
            ));

        goto exit;
    }


    hr = pISTAppPools->SetWriteColumnValues(
                                RowIndex,                       // row to read
                                CountOfAppPoolColumns,             // count of columns
                                const_cast <ULONG *> (AppPoolColumns),   // which columns
                                NULL,                           // column sizes
                                pAppPoolValues                     // new values
                                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting write column values failed\n"
            ));

        goto exit;
    }


    hr = pISTAppPools->UpdateStore();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Updating store failed\n"
            ));

        goto exit;
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Wrote to config store for app pool with ID: %S, Autostart value: %S\n",
            pAppPoolId,
            ( Autostart ? L"TRUE" : L"FALSE" )
            ));
    }


exit: 

    if ( pISTAppPools != NULL )
    {
        pISTAppPools->Release();
        pISTAppPools = NULL; 
    }


    return hr;

}   // CONFIG_MANAGER::SetAppPoolAutostart


/***************************************************************************++

Routine Description:

    Read the initial configuration.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReadAllConfiguration(
    )
{

    HRESULT hr = S_OK;

    hr = ReadGlobalData ();

    if ( FAILED( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Reading global data about service failed \n"
            ));

        goto exit;
    }

    hr = ReadAllAppPools();

    if ( FAILED( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Reading app pools failed\n"
            ));

        goto exit;
    }

    hr = ReadAllVirtualSites();

    if ( FAILED( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Reading virtual sites failed\n"
            ));

        goto exit;
    }

    hr = ReadAllApplications();

    if ( FAILED( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Reading applications failed\n"
            ));

        goto exit;
    }
   
exit:

    return hr;

}   // CONFIG_MANAGER::ReadAllConfiguration



/***************************************************************************++

Routine Description:

    Read all app pools listed in the config store.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReadAllAppPools(
    )
{

    HRESULT hr = S_OK;
    ISimpleTableRead2 * pISTAppPools = NULL;
    ULONG i = 0;
    DWORD AppPoolCount = 0;


    //
    // Get the app pools table from the config store.
    //

    hr = GetTable( 
                wszTABLE_APPPOOLS,
                EXPECTED_VERSION_APPPOOLS,
                FALSE,
                reinterpret_cast <VOID **> ( &pISTAppPools )  
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Getting app pools table failed\n"
            ));

        goto exit;
    }


    //
    // Read all the rows.
    //

    for ( i = 0; ; i++ )
    {
    
        hr = CreateAppPool(
                    pISTAppPools,
                    i,
                    TRUE
                    );

        if ( hr == E_ST_NOMOREROWS )
        {
            hr = S_OK;

            break;
        }
        else if ( FAILED( hr ) )
        {

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Creating app pool failed\n"
                ));

            goto exit;
        }


        AppPoolCount++;

    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
         DBGPRINTF((
             DBG_CONTEXT, 
             "Total number of app pools read: %lu\n",
             AppPoolCount
             )); 
    } 

    // need to check that we did configure at least the 
    // default app pool, if we are in BC mode.  otherwise
    // need to error and shutdown.

    if ( GetWebAdminService()->IsBackwardCompatibilityEnabled() &&
         !(GetWebAdminService()->GetUlAndWorkerManager()->AppPoolsExist()) ) 
    {
        // log an error 
        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_BC_WITH_NO_APP_POOL,         // message id
                0,                                      // count of strings
                NULL,                                   // array of strings
                0                                       // error code
                );

        // return an error.
        hr = E_FAIL;
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "In BC Mode there are no app pools configured\n"
            ));

        goto exit;
    }

exit: 

    if ( pISTAppPools != NULL )
    {
        pISTAppPools->Release();
        pISTAppPools = NULL;
    }


    return hr;

}   // CONFIG_MANAGER::ReadAllAppPools



/***************************************************************************++

Routine Description:

    Read an app pool from the config store, and then call the UL&WM to 
    create it.

Arguments:

    pISTAppPools - The table from which to read the app pool. This is an
    ISimpleTableRead2 if InitialRead is TRUE; but it must be a 
    ISimpleTableWrite2 if InitialRead is FALSE.

    RowIndex - The row number to read from the table.

    InitialRead - TRUE if this is the initial data read, FALSE if it is
    for handling a change notify.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::CreateAppPool(
    IN ISimpleTableRead2 * pISTAppPools,
    IN ULONG RowIndex,
    IN BOOL InitialRead
    )
{

    HRESULT hr = S_OK;
    LPWSTR pAppPoolId = NULL;
    APP_POOL_CONFIG AppPoolConfig;
    BOOL fBackCompat = GetWebAdminService()->IsBackwardCompatibilityEnabled();


    DBG_ASSERT( pISTAppPools != NULL );


    hr = ReadAppPoolConfig(
                pISTAppPools,
                RowIndex,
                InitialRead,
                &pAppPoolId,
                &AppPoolConfig,
                NULL
                );

    if ( hr == E_ST_NOMOREROWS )
    {
        // 
        // Only ignore and pass out this return value for
        // create functions.  The create functions are called
        // both on initial setup and on change notifications.
        // The Delete and Modify functions are only called on
        // for change notifications.
        //
        // For change notifications it is a real error 
        // if E_ST_NOMOREROWS is returned.  For the initial
        // setup this is how the loop knows all data has been
        // processed.
        //
        goto exit;
    }
    else if ( hr == S_FALSE )
    {
        //
        // Only App Pool configuration might return
        // S_FALSE.  It symbolizes that the data
        // read was not relevant to the system because
        // we are in backward compatibility mode.
        //

        hr = S_OK;

        goto exit;
    }
    else if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Error reading an app pool row\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Creating app pool with ID: %S\n",
            pAppPoolId
            ));
    }

    hr = GetWebAdminService()->GetUlAndWorkerManager()->CreateAppPool(
                                                            pAppPoolId,
                                                            &AppPoolConfig
                                                            );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating app pool failed\n"
            ));

        goto exit;
    }


exit: 

    return hr;

}   // CONFIG_MANAGER::CreateAppPool



/***************************************************************************++

Routine Description:

    Read an app pool from a configuration table, and then call the UL&WM to 
    delete it.

Arguments:

    pISTAppPools - The table from which to read the app pool. 

    RowIndex - The row number to read from the table.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::DeleteAppPool(
    IN ISimpleTableRead2 * pISTAppPools,
    IN ULONG RowIndex
    )
{

    HRESULT hr = S_OK;
    LPWSTR pAppPoolId = NULL;
    APP_POOL_CONFIG AppPoolConfig;

    DBG_ASSERT( pISTAppPools != NULL );

    DBG_ASSERT ( ! GetWebAdminService()->IsBackwardCompatibilityEnabled()  );

    hr = ReadAppPoolConfig(
                pISTAppPools,
                RowIndex,
                FALSE,
                &pAppPoolId,
                &AppPoolConfig,
                NULL
                );

    if ( hr == S_FALSE )
    {
        //
        // Only App Pool configuration might return
        // S_FALSE.  It symbolizes that the data
        // read was not relevant to the system because
        // we are in backward compatibility mode.
        //

        hr = S_OK;

        goto exit;
    }
    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Error reading an app pool row\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Deleting app pool with ID: %S\n",
            pAppPoolId
            ));
    }

    //
    // Delete the app pool in the UL&WM.
    // 

    hr = GetWebAdminService()->GetUlAndWorkerManager()->DeleteAppPool( pAppPoolId );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Deleting app pool failed\n"
            ));

        goto exit;
    }

exit: 

    return hr;

}   // CONFIG_MANAGER::DeleteAppPool



/***************************************************************************++

Routine Description:

    Read an app pool from a configuration table, and then call the UL&WM to 
    modify it.

Arguments:

    pISTAppPools - The table from which to read the app pool. 

    RowIndex - The row number to read from the table.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ModifyAppPool(
    IN ISimpleTableRead2 * pISTAppPools,
    IN ULONG RowIndex
    )
{

    HRESULT hr = S_OK;
    LPWSTR pAppPoolId = NULL;
    APP_POOL_CONFIG AppPoolConfig;
    APP_POOL_CONFIG_CHANGE_FLAGS WhatHasChanged;


    DBG_ASSERT( pISTAppPools != NULL );


    hr = ReadAppPoolConfig(
                pISTAppPools,
                RowIndex,
                FALSE,
                &pAppPoolId,
                &AppPoolConfig,
                &WhatHasChanged
                );

    if ( hr == S_FALSE )
    {
        //
        // Only App Pool configuration might return
        // S_FALSE.  It symbolizes that the data
        // read was not relevant to the system because
        // we are in backward compatibility mode.
        //

        hr = S_OK;

        goto exit;
    }
    else if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Error reading an app pool row\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Modifying app pool with ID: %S\n",
            pAppPoolId
            ));
    }


    //
    // Modify the app pool in the UL&WM.
    //

    hr = GetWebAdminService()->GetUlAndWorkerManager()->ModifyAppPool(
                                                            pAppPoolId,
                                                            &AppPoolConfig,
                                                            &WhatHasChanged
                                                            );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Modifying app pool failed\n"
            ));

        goto exit;
    }


exit: 

    return hr;

}   // CONFIG_MANAGER::ModifyAppPool



/***************************************************************************++

Routine Description:

    Read a single app pool from the config store.

Arguments:

    pISTAppPools - The table from which to read the app pool. This is an
    ISimpleTableRead2 if InitialRead is TRUE; but it must be a 
    ISimpleTableWrite2 if InitialRead is FALSE.

    RowIndex - The row number to read from the table.

    InitialRead - TRUE if this is the initial data read, FALSE if it is
    for handling a change notify.

    ppAppPoolName - Outputs the app pool name read.

    pAppPoolConfig - Outputs the app pool configuration read.

    pWhatHasChanged - Optionally outputs which particular configuration
    values were changed.

Return Value:

    HRESULT -- Returning E_ST_NOMORE is a failure since we have all ready
               verified outside of this function that more data should be readable.

               Returning S_FALSE is a signal that while data was available we 
               did not return it because it was not about the DefaultAppPool and 
               we are in backward compatibility mode.

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReadAppPoolConfig(
    IN ISimpleTableRead2 * pISTAppPools,
    IN ULONG RowIndex,
    IN BOOL InitialRead,
    OUT LPWSTR * ppAppPoolName,
    OUT APP_POOL_CONFIG * pAppPoolConfig,
    OUT APP_POOL_CONFIG_CHANGE_FLAGS * pWhatHasChanged OPTIONAL
    )
{

    HRESULT hr = S_OK;
    static const ULONG AppPoolColumns[] = { 
                            iAPPPOOLS_AppPoolID, 
                            iAPPPOOLS_PeriodicRestartTime,
                            iAPPPOOLS_PeriodicRestartRequests,
                            iAPPPOOLS_PeriodicRestartMemory,
                            iAPPPOOLS_PeriodicRestartSchedule,
                            iAPPPOOLS_MaxProcesses,
                            iAPPPOOLS_PingingEnabled,
                            iAPPPOOLS_IdleTimeout,
                            iAPPPOOLS_RapidFailProtection,
                            iAPPPOOLS_SMPAffinitized,
                            iAPPPOOLS_SMPProcessorAffinityMask,
                            iAPPPOOLS_OrphanWorkerProcess,
                            iAPPPOOLS_StartupTimeLimit,
                            iAPPPOOLS_ShutdownTimeLimit,
                            iAPPPOOLS_PingInterval,
                            iAPPPOOLS_PingResponseTime,
                            iAPPPOOLS_DisallowOverlappingRotation,
                            iAPPPOOLS_OrphanAction,
                            iAPPPOOLS_AppPoolQueueLength,
                            iAPPPOOLS_DisallowRotationOnConfigChange,
                            iAPPPOOLS_WAMUserName,  
                            iAPPPOOLS_WAMUserPass,  
                            iAPPPOOLS_AppPoolIdentityType,
                            iAPPPOOLS_LogonMethod,
                            iAPPPOOLS_CPUAction,  
                            iAPPPOOLS_CPULimit,  
                            iAPPPOOLS_CPUResetInterval ,
                            iAPPPOOLS_AppPoolCommand ,
                            iAPPPOOLS_AppPoolAutoStart,
                            iAPPPOOLS_RapidFailProtectionInterval,  
                            iAPPPOOLS_RapidFailProtectionMaxCrashes 
                            };

    static const ULONG CountOfAppPoolColumns = sizeof( AppPoolColumns ) / sizeof( ULONG );
    VOID * pAppPoolValues[ cAPPPOOLS_NumberOfColumns ];
    DWORD ColumnStatusFlags[ cAPPPOOLS_NumberOfColumns ];


    DBG_ASSERT( pISTAppPools != NULL );
    DBG_ASSERT( ppAppPoolName != NULL );
    DBG_ASSERT( pAppPoolConfig != NULL );


    //
    // Initialize output parameters.
    //

    *ppAppPoolName = NULL;

    ZeroMemory( pAppPoolConfig, sizeof( *pAppPoolConfig ) );


    //
    // Notes on using ISimpleTable:
    //
    // 1. While fetching columns, IST returns pointers to the column values
    // and IST owns all the memory. The pointers are valid for the lifetime 
    // of the IST pointer only. If you want a value to live beyond that, you 
    // need to make a copy.
    // 2. In GetColumnValues, data is returned indexed by the column id in 
    // the array, independent of which columns are retrieved.
    //


    if ( InitialRead )
    {

        //
        // On the initial read of data, we have an ISimpleTableRead2.
        //

        hr = ( reinterpret_cast <ISimpleTableRead2 *> ( pISTAppPools ))->GetColumnValues(
                        RowIndex,                       // row to read
                        CountOfAppPoolColumns,          // count of columns
                        const_cast < ULONG * > ( AppPoolColumns ),     // which columns
                        NULL,                           // returned column sizes
                        pAppPoolValues                  // returned values
                        );

    }
    else
    {

        //
        // On subsequent change notifies, we have an ISimpleTableWrite2.
        //

        hr = ( reinterpret_cast <ISimpleTableWrite2 *> ( pISTAppPools ) )->GetWriteColumnValues(
                        RowIndex,                       // row to read
                        CountOfAppPoolColumns,          // count of columns
                        const_cast <ULONG *> ( AppPoolColumns ),     // which columns
                        ColumnStatusFlags,              // returned column status flags
                        NULL,                           // returned column sizes
                        pAppPoolValues                  // returned values
                        );

    }


    if ( FAILED( hr ) )
    {

        if ( hr != E_ST_NOMOREROWS )
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Error reading an app pool row\n"
                ));
        }

        goto exit;
    }


    //
    // If we are in backward compatibility mode and we 
    // are not on the DefaultAppPool then ignore this data.
    //

    if (GetWebAdminService()->IsBackwardCompatibilityEnabled() 
        &&     (   pAppPoolValues[ iAPPPOOLS_AppPoolID ] == NULL
                || ( _wcsicmp(
                    reinterpret_cast<LPWSTR> ( pAppPoolValues[ iAPPPOOLS_AppPoolID ] )
                  , wszDEFAULT_APP_POOL) != 0)
               )
       )
    {
        hr = S_FALSE;
        goto exit;
    }

    //
    // Get the app pool id.
    //

    *ppAppPoolName = reinterpret_cast<LPWSTR> ( pAppPoolValues[ iAPPPOOLS_AppPoolID ] ) ;


    //
    // Get the app pool configuration.
    //

    DBG_ASSERT ( pAppPoolValues[ iAPPPOOLS_StartupTimeLimit ] );
    DBG_ASSERT ( pAppPoolValues[ iAPPPOOLS_ShutdownTimeLimit ] );
    DBG_ASSERT ( pAppPoolValues[ iAPPPOOLS_AppPoolQueueLength ] );

    //
    // These properties matter whether or not we are in BC Mode.
    //

    pAppPoolConfig->StartupTimeLimitInSeconds =
    * ( reinterpret_cast <ULONG*> (( pAppPoolValues[ iAPPPOOLS_StartupTimeLimit ] ) ) );

    pAppPoolConfig->ShutdownTimeLimitInSeconds =
    * ( reinterpret_cast <ULONG*> (( pAppPoolValues[ iAPPPOOLS_ShutdownTimeLimit ] ) ) );

    pAppPoolConfig->UlAppPoolQueueLength =
    * ( reinterpret_cast <ULONG*> (( pAppPoolValues[ iAPPPOOLS_AppPoolQueueLength ] ) ) );

    // Blocking the user from being able to configure the worker process
    // in inetinfo in a way we do not support.
    if (GetWebAdminService()->IsBackwardCompatibilityEnabled())
    {
        //
        // Set up for BC mode.
        //

        pAppPoolConfig->PeriodicProcessRestartPeriodInMinutes = 0;
        pAppPoolConfig->PeriodicProcessRestartRequestCount = 0;
        pAppPoolConfig->PeriodicProcessRestartMemoryUsageInKB = 0;
        pAppPoolConfig->pPeriodicProcessRestartSchedule = NULL;
        pAppPoolConfig->MaxSteadyStateProcessCount = 1;
        pAppPoolConfig->PingingEnabled = FALSE;
        pAppPoolConfig->IdleTimeoutInMinutes = 0;
        pAppPoolConfig->SMPAffinitized = FALSE;
        pAppPoolConfig->SMPAffinitizedProcessorMask = 0;
        pAppPoolConfig->OrphanProcessesForDebuggingEnabled = FALSE;
        pAppPoolConfig->PingIntervalInSeconds = MAX_SECONDS_IN_ULONG_OF_MILLISECONDS - 1;
        pAppPoolConfig->PingResponseTimeLimitInSeconds = MAX_SECONDS_IN_ULONG_OF_MILLISECONDS - 1;
        pAppPoolConfig->DisallowOverlappingRotation = TRUE;
        pAppPoolConfig->pOrphanAction = NULL;
        pAppPoolConfig->DisallowRotationOnConfigChanges = TRUE;
        pAppPoolConfig->UserType = LocalSystemAppPoolUserType;
        pAppPoolConfig->pUserName = NULL;
        pAppPoolConfig->pUserPassword = NULL;
        pAppPoolConfig->LogonMethod = InteractiveAppPoolLogonMethod;
        pAppPoolConfig->CPUAction =  0;           
        pAppPoolConfig->CPULimit =  0;           
        pAppPoolConfig->CPUResetInterval =  0;           
        pAppPoolConfig->ServerCommand = 0;
        pAppPoolConfig->AutoStart = TRUE;
        pAppPoolConfig->RapidFailProtectionEnabled = FALSE;
        pAppPoolConfig->RapidFailProtectionIntervalMS = 0;
        pAppPoolConfig->RapidFailProtectionMaxCrashes = 0;

    }
    else
    {
        // These asserts has been commented out and handled below, because
        // the catalog is returning a NULL when it expects us to default the
        // value instead of it giving us a the defaulted value.
        // DBG_ASSERT ( pAppPoolValues[ iAPPPOOLS_AppPoolIdentityType ] );
        // DBG_ASSERT ( pAppPoolValues[ iAPPPOOLS_LogonMethod ] );

        DBG_ASSERT ( pAppPoolValues[ iAPPPOOLS_PeriodicRestartTime ] );
        DBG_ASSERT ( pAppPoolValues[ iAPPPOOLS_PeriodicRestartRequests ] );
        DBG_ASSERT ( pAppPoolValues[ iAPPPOOLS_PeriodicRestartMemory ] );
        DBG_ASSERT ( pAppPoolValues[ iAPPPOOLS_MaxProcesses ] );
        DBG_ASSERT ( pAppPoolValues[ iAPPPOOLS_PingingEnabled] );
        DBG_ASSERT ( pAppPoolValues[ iAPPPOOLS_IdleTimeout ] );
        DBG_ASSERT ( pAppPoolValues[ iAPPPOOLS_SMPAffinitized ] );
        DBG_ASSERT ( pAppPoolValues[ iAPPPOOLS_SMPProcessorAffinityMask ] );
        DBG_ASSERT ( pAppPoolValues[ iAPPPOOLS_OrphanWorkerProcess ] );
        DBG_ASSERT ( pAppPoolValues[ iAPPPOOLS_PingInterval ] );
        DBG_ASSERT ( pAppPoolValues[ iAPPPOOLS_PingResponseTime ] );
        DBG_ASSERT ( pAppPoolValues[ iAPPPOOLS_DisallowOverlappingRotation ] );
        DBG_ASSERT ( pAppPoolValues[ iAPPPOOLS_DisallowRotationOnConfigChange ] );

        DBG_ASSERT ( pAppPoolValues[ iAPPPOOLS_CPUAction ] );
        DBG_ASSERT ( pAppPoolValues[ iAPPPOOLS_CPULimit ] );
        DBG_ASSERT ( pAppPoolValues[ iAPPPOOLS_CPUResetInterval ] );

        DBG_ASSERT ( pAppPoolValues[ iAPPPOOLS_AppPoolAutoStart ] );

        DBG_ASSERT ( pAppPoolValues[ iAPPPOOLS_RapidFailProtection ] );
        DBG_ASSERT ( pAppPoolValues[ iAPPPOOLS_RapidFailProtectionInterval ] );
        DBG_ASSERT ( pAppPoolValues[ iAPPPOOLS_RapidFailProtectionMaxCrashes ] );
        // 
        // Setup for FC mode
        //

        pAppPoolConfig->RapidFailProtectionEnabled =
        * ( reinterpret_cast <BOOL*> (( pAppPoolValues[ iAPPPOOLS_RapidFailProtection ] ) ) );

        // It comes in in minutes, but get used in milliseconds, so we convert it here.
        pAppPoolConfig->RapidFailProtectionIntervalMS =
        ( * ( reinterpret_cast <DWORD*> (( pAppPoolValues[ iAPPPOOLS_RapidFailProtectionInterval ] ) ) ) ) 
        * ONE_MINUTE_IN_MILLISECONDS;

        pAppPoolConfig->RapidFailProtectionMaxCrashes =
        * ( reinterpret_cast <DWORD*> (( pAppPoolValues[ iAPPPOOLS_RapidFailProtectionMaxCrashes ] ) ) );

        pAppPoolConfig->PeriodicProcessRestartPeriodInMinutes =
        * ( reinterpret_cast <ULONG*> (( pAppPoolValues[ iAPPPOOLS_PeriodicRestartTime ] ) ) );
    
        pAppPoolConfig->PeriodicProcessRestartRequestCount =
        * ( reinterpret_cast <ULONG*> (( pAppPoolValues[ iAPPPOOLS_PeriodicRestartRequests ] ) ) );

        pAppPoolConfig->PeriodicProcessRestartMemoryUsageInKB =
        * ( reinterpret_cast <ULONG*> (( pAppPoolValues[ iAPPPOOLS_PeriodicRestartMemory ] ) ) );

        pAppPoolConfig->pPeriodicProcessRestartSchedule =
        reinterpret_cast<LPWSTR>( pAppPoolValues[ iAPPPOOLS_PeriodicRestartSchedule ] );

        pAppPoolConfig->MaxSteadyStateProcessCount =
        * ( reinterpret_cast <ULONG*> (( pAppPoolValues[ iAPPPOOLS_MaxProcesses ] ) ) );
    
        pAppPoolConfig->PingingEnabled =
        * ( reinterpret_cast <BOOL*> (( pAppPoolValues[ iAPPPOOLS_PingingEnabled ] ) ) );

        pAppPoolConfig->IdleTimeoutInMinutes =
        * ( reinterpret_cast <ULONG*> (( pAppPoolValues[ iAPPPOOLS_IdleTimeout ] ) ) );
    
        pAppPoolConfig->SMPAffinitized =
        * ( reinterpret_cast <BOOL*> (( pAppPoolValues[ iAPPPOOLS_SMPAffinitized ] ) ) );
    
        pAppPoolConfig->SMPAffinitizedProcessorMask =
        * ( reinterpret_cast <ULONG*> (( pAppPoolValues[ iAPPPOOLS_SMPProcessorAffinityMask ] ) ) );
    
        pAppPoolConfig->OrphanProcessesForDebuggingEnabled =
        * ( reinterpret_cast <BOOL*> (( pAppPoolValues[ iAPPPOOLS_OrphanWorkerProcess ] ) ) );
    
        pAppPoolConfig->PingIntervalInSeconds =
        * ( reinterpret_cast <ULONG*> (( pAppPoolValues[ iAPPPOOLS_PingInterval ] ) ) );

        pAppPoolConfig->PingResponseTimeLimitInSeconds =
        * ( reinterpret_cast <ULONG*> (( pAppPoolValues[ iAPPPOOLS_PingResponseTime ] ) ) );

        pAppPoolConfig->DisallowOverlappingRotation =
        * ( reinterpret_cast <BOOL*> (( pAppPoolValues[ iAPPPOOLS_DisallowOverlappingRotation ] ) ) );

        pAppPoolConfig->pOrphanAction =
        reinterpret_cast <LPWSTR> (pAppPoolValues[ iAPPPOOLS_OrphanAction ]);

        pAppPoolConfig->DisallowRotationOnConfigChanges =
        * ( reinterpret_cast <BOOL*> ( pAppPoolValues[ iAPPPOOLS_DisallowRotationOnConfigChange ] ) );

        //
        // For now we are hard coding these properties, until catalog 
        // passes them to us.
        //
        if ( pAppPoolValues[ iAPPPOOLS_AppPoolIdentityType ] )
        {
            pAppPoolConfig->UserType =
            * ( reinterpret_cast <ULONG*> (( pAppPoolValues[ iAPPPOOLS_AppPoolIdentityType ] ) ) );
        }
        else
        {
            pAppPoolConfig->UserType = LocalSystemAppPoolUserType;
        }

        pAppPoolConfig->pUserName =
        reinterpret_cast <LPWSTR> ( pAppPoolValues[ iAPPPOOLS_WAMUserName ] );

        pAppPoolConfig->pUserPassword =
        reinterpret_cast <LPWSTR> ( pAppPoolValues[ iAPPPOOLS_WAMUserPass ] );
    
        //
        // Catalog is not defaulting this.  I have sent mail to Varsha,
        // but until something changes...
        //
        if ( pAppPoolValues[ iAPPPOOLS_LogonMethod ] )
        {
            pAppPoolConfig->LogonMethod =             
            * ( reinterpret_cast <ULONG*> (( pAppPoolValues[ iAPPPOOLS_LogonMethod ] ) ) );
        }
        else
        {
            pAppPoolConfig->LogonMethod = NetworkClearTextAppPoolLogonMethod;
        }

        pAppPoolConfig->CPUAction =             
                    * ( reinterpret_cast <ULONG*> (( pAppPoolValues[ iAPPPOOLS_CPUAction ] ) ) );

        pAppPoolConfig->CPULimit =             
                    * ( reinterpret_cast <ULONG*> (( pAppPoolValues[ iAPPPOOLS_CPULimit ] ) ) );

        pAppPoolConfig->CPUResetInterval =             
                    * ( reinterpret_cast <ULONG*> (( pAppPoolValues[ iAPPPOOLS_CPUResetInterval ] ) ) );


        if ( pAppPoolValues[ iAPPPOOLS_AppPoolCommand ]  )
        {
            pAppPoolConfig->ServerCommand = 
                    * ( reinterpret_cast <ULONG*> (( pAppPoolValues[ iAPPPOOLS_AppPoolCommand ] ) ) );
        }
        else
        {
            //
            // below we are going to only mark this property 
            // as changed if we actually got a value ( not this 
            // sudo-default value )
            //
            pAppPoolConfig->ServerCommand = 0;
        }


        pAppPoolConfig->AutoStart =
                    * ( reinterpret_cast <BOOL*> (( pAppPoolValues[ iAPPPOOLS_AppPoolAutoStart ] ) ) );

    }


    //
    // Confirm that the values we read are valid. We expect the config
    // store to enforce these and much more, but we'll just double-check 
    // a few things here.
    //

    DBG_ASSERT( ( pAppPoolConfig->StartupTimeLimitInSeconds > 0 ) && ( pAppPoolConfig->StartupTimeLimitInSeconds < MAX_SECONDS_IN_ULONG_OF_MILLISECONDS ) );
    DBG_ASSERT( ( pAppPoolConfig->ShutdownTimeLimitInSeconds > 0 ) && ( pAppPoolConfig->ShutdownTimeLimitInSeconds < MAX_SECONDS_IN_ULONG_OF_MILLISECONDS ) );
    DBG_ASSERT( ( pAppPoolConfig->PingIntervalInSeconds > 0 ) && ( pAppPoolConfig->PingIntervalInSeconds < MAX_SECONDS_IN_ULONG_OF_MILLISECONDS ) );
    DBG_ASSERT( ( pAppPoolConfig->PingResponseTimeLimitInSeconds > 0 ) && ( pAppPoolConfig->PingResponseTimeLimitInSeconds < MAX_SECONDS_IN_ULONG_OF_MILLISECONDS ) );


    //
    // If the caller has asked to see which values specifically have
    // changed, then provide that information.
    //

    if ( pWhatHasChanged )
    {
        //
        // In this case, we better be on a change notify path, where we
        // have the ISimpleTableWrite2 interface, and so the column status
        // information is available.
        //

        DBG_ASSERT( ! InitialRead );


        ZeroMemory( pWhatHasChanged, sizeof( *pWhatHasChanged ) );

        //
        // First remember the properties that are configurable
        // in both forward and backward compatibility mode.
        // 

        pWhatHasChanged->StartupTimeLimitInSeconds = 
        ( ColumnStatusFlags[ iAPPPOOLS_StartupTimeLimit ] & fST_COLUMNSTATUS_CHANGED );

        pWhatHasChanged->ShutdownTimeLimitInSeconds =
        ( ColumnStatusFlags[ iAPPPOOLS_ShutdownTimeLimit ] & fST_COLUMNSTATUS_CHANGED );

        pWhatHasChanged->UlAppPoolQueueLength =
        ( ColumnStatusFlags[ iAPPPOOLS_AppPoolQueueLength ] & fST_COLUMNSTATUS_CHANGED );

        //
        // No set the properties that care whether or not
        // we are in backward compatibility mode.
        // 

        if (GetWebAdminService()->IsBackwardCompatibilityEnabled())
        {
            //
            // Never worry about any changes to any of these
            // properties in backward compatibility mode.
            // 

            pWhatHasChanged->PeriodicProcessRestartPeriodInMinutes = 0;
            pWhatHasChanged->PeriodicProcessRestartRequestCount = 0;
            pWhatHasChanged->MaxSteadyStateProcessCount = 0;
            pWhatHasChanged->PingingEnabled = 0;
            pWhatHasChanged->IdleTimeoutInMinutes = 0;
            pWhatHasChanged->SMPAffinitized =0;
            pWhatHasChanged->SMPAffinitizedProcessorMask = 0;
            pWhatHasChanged->OrphanProcessesForDebuggingEnabled = 0;
            pWhatHasChanged->PingIntervalInSeconds = 0;
            pWhatHasChanged->PingResponseTimeLimitInSeconds =0;
            pWhatHasChanged->DisallowOverlappingRotation = 0;
            pWhatHasChanged->pOrphanAction = 0;
            pWhatHasChanged->DisallowRotationOnConfigChanges = 0;
            pWhatHasChanged->UserType = 0;
            pWhatHasChanged->pUserName = 0;
            pWhatHasChanged->pUserPassword = 0;
            pWhatHasChanged->LogonMethod = 0;
            pWhatHasChanged->CPUAction = 0;
            pWhatHasChanged->CPULimit = 0;
            pWhatHasChanged->CPUResetInterval = 0;
            pWhatHasChanged->ServerCommand = 0;
            pWhatHasChanged->RapidFailProtectionEnabled = 0;
            pWhatHasChanged->RapidFailProtectionIntervalMS = 0;
            pWhatHasChanged->RapidFailProtectionMaxCrashes = 0;

        }
        else
        {
            //
            // Remember what changed in forward compatiblity mode
            // 

            pWhatHasChanged->RapidFailProtectionEnabled =
            ( ColumnStatusFlags[ iAPPPOOLS_RapidFailProtection ] & fST_COLUMNSTATUS_CHANGED );

            pWhatHasChanged->RapidFailProtectionIntervalMS =
            ( ColumnStatusFlags[ iAPPPOOLS_RapidFailProtectionInterval ] & fST_COLUMNSTATUS_CHANGED );

            pWhatHasChanged->RapidFailProtectionMaxCrashes =
            ( ColumnStatusFlags[ iAPPPOOLS_RapidFailProtectionMaxCrashes ] & fST_COLUMNSTATUS_CHANGED );

            pWhatHasChanged->PeriodicProcessRestartPeriodInMinutes =
            ( ColumnStatusFlags[ iAPPPOOLS_PeriodicRestartTime ] & fST_COLUMNSTATUS_CHANGED );

            pWhatHasChanged->PeriodicProcessRestartRequestCount =
            ( ColumnStatusFlags[ iAPPPOOLS_PeriodicRestartRequests ] & fST_COLUMNSTATUS_CHANGED );

            pWhatHasChanged->PeriodicProcessRestartMemoryUsageInKB =
            ( ColumnStatusFlags[ iAPPPOOLS_PeriodicRestartMemory ] & fST_COLUMNSTATUS_CHANGED );

            pWhatHasChanged->pPeriodicProcessRestartSchedule =
            ( ColumnStatusFlags[ iAPPPOOLS_PeriodicRestartSchedule ] & fST_COLUMNSTATUS_CHANGED );

            pWhatHasChanged->MaxSteadyStateProcessCount =
            ( ColumnStatusFlags[ iAPPPOOLS_MaxProcesses ] & fST_COLUMNSTATUS_CHANGED );

            pWhatHasChanged->PingingEnabled =
            ( ColumnStatusFlags[ iAPPPOOLS_PingingEnabled ] & fST_COLUMNSTATUS_CHANGED );

            pWhatHasChanged->IdleTimeoutInMinutes =
            ( ColumnStatusFlags[ iAPPPOOLS_IdleTimeout ] & fST_COLUMNSTATUS_CHANGED );

            pWhatHasChanged->SMPAffinitized =
            ( ColumnStatusFlags[ iAPPPOOLS_SMPAffinitized ] & fST_COLUMNSTATUS_CHANGED );

            pWhatHasChanged->SMPAffinitizedProcessorMask =
            ( ColumnStatusFlags[ iAPPPOOLS_SMPProcessorAffinityMask ] & fST_COLUMNSTATUS_CHANGED );

            pWhatHasChanged->OrphanProcessesForDebuggingEnabled =
            ( ColumnStatusFlags[ iAPPPOOLS_OrphanWorkerProcess ] & fST_COLUMNSTATUS_CHANGED );

            pWhatHasChanged->PingIntervalInSeconds =
            ( ColumnStatusFlags[ iAPPPOOLS_PingInterval ] & fST_COLUMNSTATUS_CHANGED );

            pWhatHasChanged->PingResponseTimeLimitInSeconds =
            ( ColumnStatusFlags[ iAPPPOOLS_PingResponseTime ] & fST_COLUMNSTATUS_CHANGED );

            pWhatHasChanged->DisallowOverlappingRotation =
            ( ColumnStatusFlags[ iAPPPOOLS_DisallowOverlappingRotation ] & fST_COLUMNSTATUS_CHANGED );

            pWhatHasChanged->pOrphanAction =
            ( ColumnStatusFlags[ iAPPPOOLS_OrphanAction ] & fST_COLUMNSTATUS_CHANGED );

            pWhatHasChanged->DisallowRotationOnConfigChanges =
            ( ColumnStatusFlags[ iAPPPOOLS_DisallowRotationOnConfigChange ] & fST_COLUMNSTATUS_CHANGED );

            pWhatHasChanged->UserType =
            ( ColumnStatusFlags[ iAPPPOOLS_AppPoolIdentityType ] & fST_COLUMNSTATUS_CHANGED );

            pWhatHasChanged->pUserName =
            ( ColumnStatusFlags[ iAPPPOOLS_WAMUserName ] & fST_COLUMNSTATUS_CHANGED );

            pWhatHasChanged->pUserPassword =
            ( ColumnStatusFlags[ iAPPPOOLS_WAMUserPass ] & fST_COLUMNSTATUS_CHANGED );

            pWhatHasChanged->LogonMethod = 
            ( ColumnStatusFlags[ iAPPPOOLS_LogonMethod ] & fST_COLUMNSTATUS_CHANGED );

            pWhatHasChanged->CPUAction = 
            ( ColumnStatusFlags[ iAPPPOOLS_CPUAction ] & fST_COLUMNSTATUS_CHANGED );

            pWhatHasChanged->CPULimit = 
            ( ColumnStatusFlags[ iAPPPOOLS_CPULimit ] & fST_COLUMNSTATUS_CHANGED );

            pWhatHasChanged->CPUResetInterval = 
            ( ColumnStatusFlags[ iAPPPOOLS_CPUResetInterval ] & fST_COLUMNSTATUS_CHANGED );

            //
            // If we didn't get a value for the app pool command than ignore whether
            // or not the command changed and assume that it did not change.
            //
            if ( pAppPoolValues[ iAPPPOOLS_AppPoolCommand ]  )
            {
                pWhatHasChanged->ServerCommand =
                ( ColumnStatusFlags[ iAPPPOOLS_AppPoolCommand ] & fST_COLUMNSTATUS_CHANGED );
            }
            else
            {
                pWhatHasChanged->ServerCommand = 0;
            }

        }

    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Read from config store app pool with ID: %S\n",
            *ppAppPoolName
            ));
    }


exit: 

    return hr;

}   // CONFIG_MANAGER::ReadAppPoolConfig



/***************************************************************************++

Routine Description:

    Read all virtual sites listed in the config store.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReadAllVirtualSites(
    )
{

    HRESULT hr = S_OK;
    ISimpleTableRead2 * pISTVirtualSites = NULL;
    ULONG i = 0;
    DWORD VirtualSiteCount = 0;


    //
    // Get the virtual sites table from the config store.
    //

    hr = GetTable( 
                wszTABLE_SITES,
                EXPECTED_VERSION_SITES,
                FALSE,
                reinterpret_cast <VOID**> ( &pISTVirtualSites )
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Getting virtual sites table failed\n"
            ));

        goto exit;
    }


    //
    // Read all the rows.
    //

    for ( i = 0; ; i++ )
    {
    
        hr = CreateVirtualSite(
                    pISTVirtualSites,
                    i,
                    TRUE
                    );

        if ( hr == E_ST_NOMOREROWS )
        {
            hr = S_OK;

            break;
        }
        else if ( FAILED( hr ) )
        {

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Creating virtual site failed\n"
                ));

            goto exit;
        }


        VirtualSiteCount++;

    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
         DBGPRINTF((
             DBG_CONTEXT, 
             "Total number of virtual sites read: %lu\n",
             VirtualSiteCount
             )); 
    } 


exit: 

    if ( pISTVirtualSites != NULL )
    {
        pISTVirtualSites->Release();
        pISTVirtualSites = NULL;
    }


    return hr;

}   // CONFIG_MANAGER::ReadAllVirtualSites

/***************************************************************************++

Routine Description:

    Read global server information from the config store.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReadGlobalData(
    )
{

    HRESULT hr = S_OK;
    ISimpleTableRead2 * pISTGlobal = NULL;
    BOOL BackwardCompatibility = TRUE;
    GLOBAL_SERVER_CONFIG GlobalConfig;

    //
    // Get the global table from the config store.
    //

    hr = GetTable( 
                wszTABLE_GlobalW3SVC,
                EXPECTED_VERSION_GLOBAL,
                FALSE,
                reinterpret_cast <VOID**> ( &pISTGlobal )
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Getting global service table failed\n"
            ));

        goto exit;
    }


    // 
    // There should only be one row to read so that row
    // should be all we need to read.
    //

    hr = ReadGlobalConfig(pISTGlobal, 
                          0,
                          TRUE,         // Initial read
                          &BackwardCompatibility,
                          &GlobalConfig,
                          NULL);
    if ( FAILED(hr) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Reading global data failed.\n"
            ));

        goto exit;
    }

    hr = GetWebAdminService()->SetBackwardCompatibility(BackwardCompatibility);
    if ( FAILED(hr) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Telling the web admin service about BC failed.\n"
            ));

        goto exit;
    }

    hr = GetWebAdminService()->GetUlAndWorkerManager()->ModifyGlobalData(
                                                            &GlobalConfig,
                                                            NULL
                                                            );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Modifying global data failed\n"
            ));

        goto exit;
    }

exit: 

    if ( pISTGlobal != NULL )
    {
        pISTGlobal->Release();
        pISTGlobal = NULL;
    }


    return hr;

}   // CONFIG_MANAGER::ReadGlobalData


/***************************************************************************++

Routine Description:

    Read a virtual site from the config store, and then call the UL&WM to 
    create it.

Arguments:

    pISTAppPools - The table from which to read the virtual site. This is an
    ISimpleTableRead2 if InitialRead is TRUE; but it must be a 
    ISimpleTableWrite2 if InitialRead is FALSE.

    RowIndex - The row number to read from the table.

    InitialRead - TRUE if this is the initial data read, FALSE if it is
    for handling a change notify.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::CreateVirtualSite(
    IN ISimpleTableRead2 * pISTVirtualSites,
    IN ULONG RowIndex,
    IN BOOL InitialRead
    )
{

    HRESULT hr = S_OK;
    DWORD VirtualSiteId = 0;
    VIRTUAL_SITE_CONFIG VirtualSiteConfig;


    DBG_ASSERT( pISTVirtualSites != NULL );


    hr = ReadVirtualSiteConfig(
                pISTVirtualSites,
                RowIndex,
                InitialRead,
                &VirtualSiteId,
                &VirtualSiteConfig,
                NULL
                );

    if ( hr == E_ST_NOMOREROWS )
    {
        // 
        // Only ignore and pass out this return value for
        // create functions.  The create functions are called
        // both on initial setup and on change notifications.
        // The Delete and Modify functions are only called on
        // for change notifications.
        //
        // For change notifications it is a real error 
        // if E_ST_NOMOREROWS is returned.  For the initial
        // setup this is how the loop knows all data has been
        // processed.
        //

        goto exit;
    }
    else if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Error reading a virtual site row\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Creating virtual site with ID: %lu\n",
            VirtualSiteId
            ));
    }


    //
    // Create the virtual site in the UL&WM.
    //

    hr = GetWebAdminService()->GetUlAndWorkerManager()->CreateVirtualSite(
                                                            VirtualSiteId,
                                                            &VirtualSiteConfig
                                                            );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating virtual site failed\n"
            ));

        goto exit;
    }


exit: 

    return hr;

}   // CONFIG_MANAGER::CreateVirtualSite



/***************************************************************************++

Routine Description:

    Read a virtual site from the config store, and then call the UL&WM to 
    delete it.

Arguments:

    pISTVirtualSites - The table from which to read the virtual site. 

    RowIndex - The row number to read from the table.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::DeleteVirtualSite(
    IN ISimpleTableRead2 * pISTVirtualSites,
    IN ULONG RowIndex
    )
{

    HRESULT hr = S_OK;
    DWORD VirtualSiteId = 0;
    VIRTUAL_SITE_CONFIG VirtualSiteConfig;


    DBG_ASSERT( pISTVirtualSites != NULL );


    hr = ReadVirtualSiteConfig(
                pISTVirtualSites,
                RowIndex,
                FALSE,
                &VirtualSiteId,
                &VirtualSiteConfig,
                NULL
                );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Error reading a virtual site row\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Deleting virtual site with ID: %lu\n",
            VirtualSiteId
            ));
    }


    //
    // Delete the virtual site in the UL&WM.
    //

    hr = GetWebAdminService()->GetUlAndWorkerManager()->DeleteVirtualSite( VirtualSiteId );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Deleting virtual site failed\n"
            ));

        goto exit;
    }


exit: 

    return hr;

}   // CONFIG_MANAGER::DeleteVirtualSite



/***************************************************************************++

Routine Description:

    Read a virtual site from the config store, and then call the UL&WM to 
    modify it.

Arguments:

    pISTVirtualSites - The table from which to read the virtual site. 

    RowIndex - The row number to read from the table.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ModifyVirtualSite(
    IN ISimpleTableRead2 * pISTVirtualSites,
    IN ULONG RowIndex
    )
{

    HRESULT hr = S_OK;
    DWORD VirtualSiteId = 0;
    VIRTUAL_SITE_CONFIG VirtualSiteConfig;
    VIRTUAL_SITE_CONFIG_CHANGE_FLAGS WhatHasChanged;


    DBG_ASSERT( pISTVirtualSites != NULL );


    hr = ReadVirtualSiteConfig(
                pISTVirtualSites,
                RowIndex,
                FALSE,
                &VirtualSiteId,
                &VirtualSiteConfig,
                &WhatHasChanged
                );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Error reading a virtual site row\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Modifying virtual site with ID: %lu\n",
            VirtualSiteId
            ));
    }


    //
    // Modify the virtual site in the UL&WM.
    //

    hr = GetWebAdminService()->GetUlAndWorkerManager()->ModifyVirtualSite(
                                                            VirtualSiteId,
                                                            &VirtualSiteConfig,
                                                            &WhatHasChanged
                                                            );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Modifying virtual site failed\n"
            ));

        goto exit;
    }


exit: 

    return hr;

}   // CONFIG_MANAGER::ModifyVirtualSite


/***************************************************************************++

Routine Description:

    Reads the global configuration of the service.

Arguments:

    pISTAppPools - The table from which to read the virtual site. This is an
    ISimpleTableRead2.

    BackwardCompatibility - A pointer to a BOOL that will be set to whether
    or not the system is in backward compatibility mode.

Notes:

    Unlike the other configuration functions this function is only used
    during initial setup of the server.  Since backward compatibility requires
    the user to rotate the server we do not listen for changes on these properties.
    (At this time).

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReadGlobalConfig(
        IN ISimpleTableRead2 * pISTGlobal,
        IN ULONG RowIndex,
        IN BOOL InitialRead,
        OUT BOOL* pBackwardCompatibility,
        OUT GLOBAL_SERVER_CONFIG* pGlobalConfig,
        OUT GLOBAL_SERVER_CONFIG_CHANGE_FLAGS * pWhatHasChanged OPTIONAL
        )
{

    HRESULT hr = S_OK;
    static const ULONG GlobalColumns[] = { 
                            iGlobalW3SVC_StandardAppModeEnabled,
                            iGlobalW3SVC_MaxGlobalBandwidth, 
                            iGlobalW3SVC_MaxGlobalConnections,
                            iGlobalW3SVC_FilterFlags,
                            iGlobalW3SVC_ConnectionTimeout,  
                            iGlobalW3SVC_HeaderWaitTimeout,  
                            iGlobalW3SVC_MinFileKbSec,
                            iGlobalW3SVC_LogInUTF8
                            };

    static const ULONG CountOfGlobalColumns = sizeof( GlobalColumns ) / sizeof( ULONG );

    VOID * pGlobalValues[ cGlobalW3SVC_NumberOfColumns ];
    DWORD ColumnStatusFlags[ cGlobalW3SVC_NumberOfColumns ];

    DBG_ASSERT( pISTGlobal != NULL );

    //
    // BackwardCompatibility is not dealt with on updates.
    //
    DBG_ASSERT( pBackwardCompatibility != NULL || InitialRead == FALSE );
    DBG_ASSERT( pGlobalConfig != NULL );

    //
    // Initialize output parameters.
    //

    // If we don't read it for any reason than the machine
    // assumes that we are in backward compatibility mode.
    if ( pBackwardCompatibility )
    {
        *pBackwardCompatibility = TRUE;
    }

    //
    // Notes on using ISimpleTable:
    //
    // 1. While fetching columns, IST returns pointers to the column values
    // and IST owns all the memory. The pointers are valid for the lifetime 
    // of the IST pointer only. If you want a value to live beyond that, you 
    // need to make a copy.
    // 2. In GetColumnValues, data is returned indexed by the column id in 
    // the array, independent of which columns are retrieved.
    //

    if ( InitialRead )
    {

        //
        // On the initial read of data, we have an ISimpleTableRead2.
        //

        hr = ( reinterpret_cast <ISimpleTableRead2 *> ( pISTGlobal ) )->GetColumnValues(
                        RowIndex,                           // row to read
                        CountOfGlobalColumns,               // count of columns
                        const_cast <ULONG*> ( GlobalColumns ),          // which columns
                        NULL,                               // returned column sizes
                        pGlobalValues                       // returned values
                        );

    }
    else
    {

        //
        // On subsequent change notifies, we have an ISimpleTableWrite2.
        //

        hr = ( reinterpret_cast <ISimpleTableWrite2 *> ( pISTGlobal ) )->GetWriteColumnValues(
                        RowIndex,                           // row to read
                        CountOfGlobalColumns,               // count of columns
                        const_cast <ULONG*> ( GlobalColumns ),          // which columns
                        ColumnStatusFlags,                  // returned column status flags
                        NULL,                               // returned column sizes
                        pGlobalValues                       // returned values
                        );

    }


    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Error reading an global config data\n"
            ));

        goto exit;
    }

    //
    // Get the backward compatibility flag.
    //

    if ( pBackwardCompatibility )
    {
        *pBackwardCompatibility = * ( reinterpret_cast <BOOL*> ( ( pGlobalValues[ iGlobalW3SVC_StandardAppModeEnabled ] ) ) );

        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {

            DBGPRINTF((
                DBG_CONTEXT, 
                "Read from config store global data: BackCompat = %d, %S\n",
                *pBackwardCompatibility,
                (*pBackwardCompatibility ? L"TRUE" : L"FALSE" )
                ));

        }

    }

    DBG_ASSERT ( pGlobalValues[ iGlobalW3SVC_MaxGlobalConnections ] );
    DBG_ASSERT ( pGlobalValues[ iGlobalW3SVC_MaxGlobalBandwidth ] ); 

    DBG_ASSERT ( pGlobalValues[ iGlobalW3SVC_ConnectionTimeout ] ); 
    DBG_ASSERT ( pGlobalValues[ iGlobalW3SVC_HeaderWaitTimeout ] ); 
    DBG_ASSERT ( pGlobalValues[ iGlobalW3SVC_MinFileKbSec ] ); 
    DBG_ASSERT ( pGlobalValues[ iGlobalW3SVC_LogInUTF8 ] ); 
    

    //
    // Get the Max Connections and Max Bandwidth Settings.
    //
    pGlobalConfig->MaxConnections = * ( reinterpret_cast <DWORD*> ( ( pGlobalValues[ iGlobalW3SVC_MaxGlobalConnections ] ) ) );

    pGlobalConfig->MaxBandwidth = * ( reinterpret_cast <DWORD*> ( ( pGlobalValues[ iGlobalW3SVC_MaxGlobalBandwidth ] ) ) );

    //
    // Catalog should not be returning NULL, but for now it is
    // so assume a NULL equal's no flags set.
    //
    if ( pGlobalValues[ iGlobalW3SVC_FilterFlags ] == NULL )
    {
        pGlobalConfig->FilterFlags = 0;
    }
    else
    {
        pGlobalConfig->FilterFlags = * ( reinterpret_cast <DWORD*> ( ( pGlobalValues[ iGlobalW3SVC_FilterFlags ] ) ) );
    }

    pGlobalConfig->ConnectionTimeout = 
            * ( reinterpret_cast <DWORD*> ( ( pGlobalValues[ iGlobalW3SVC_ConnectionTimeout ] ) ) );
    pGlobalConfig->HeaderWaitTimeout =
            * ( reinterpret_cast <DWORD*> ( ( pGlobalValues[ iGlobalW3SVC_HeaderWaitTimeout ] ) ) );
    pGlobalConfig->MinFileKbSec = 
            * ( reinterpret_cast <DWORD*> ( ( pGlobalValues[ iGlobalW3SVC_MinFileKbSec ] ) ) );

    pGlobalConfig->LogInUTF8 = 
            * ( reinterpret_cast <BOOL*> ( ( pGlobalValues[ iGlobalW3SVC_LogInUTF8 ] ) ) );
    

    
    //
    // Dump the data, if we are in debug mode.
    //
    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {

        DBGPRINTF((
            DBG_CONTEXT, 
            "Read from config store global data: \n"
            "     MaxConnections = %u\n"
            "     MaxBandwidth = %u\n"
            "     FilterFlags  = %u\n"
            "     ConnectionTimeout = %u\n"
            "     HeaderWaitTimeout = %u\n"
            "     MinFileKbSec = %u\n"
            "     LogInUTF8 = %u\n",
            pGlobalConfig->MaxConnections,
            pGlobalConfig->MaxBandwidth,
            pGlobalConfig->FilterFlags,
            pGlobalConfig->ConnectionTimeout,
            pGlobalConfig->HeaderWaitTimeout,
            pGlobalConfig->MinFileKbSec,
            pGlobalConfig->LogInUTF8
            ));

    }

    //
    // Now if we need to figure out what has changed.
    //

    if ( pWhatHasChanged )
    {

        //
        // In this case, we better be on a change notify path, where we
        // have the ISimpleTableWrite2 interface, and so the column status
        // information is available.
        //

        DBG_ASSERT( ! InitialRead );


        ZeroMemory( pWhatHasChanged, sizeof( *pWhatHasChanged ) );

        //
        // We don't listen to changes regarding whether or not backward compatibility
        // is enabled.
        //

        pWhatHasChanged->MaxConnections =
        ( ColumnStatusFlags[ iGlobalW3SVC_MaxGlobalConnections ] & fST_COLUMNSTATUS_CHANGED );

        pWhatHasChanged->MaxBandwidth =
        ( ColumnStatusFlags[ iGlobalW3SVC_MaxGlobalBandwidth ] & fST_COLUMNSTATUS_CHANGED );

        pWhatHasChanged->FilterFlags =
        ( ColumnStatusFlags[ iGlobalW3SVC_FilterFlags ] & fST_COLUMNSTATUS_CHANGED );

        pWhatHasChanged->ConnectionTimeout = 
        ( ColumnStatusFlags[ iGlobalW3SVC_ConnectionTimeout ] & fST_COLUMNSTATUS_CHANGED );

        pWhatHasChanged->HeaderWaitTimeout = 
        ( ColumnStatusFlags[ iGlobalW3SVC_HeaderWaitTimeout ] & fST_COLUMNSTATUS_CHANGED );

        pWhatHasChanged->MinFileKbSec = 
        ( ColumnStatusFlags[ iGlobalW3SVC_MinFileKbSec ] & fST_COLUMNSTATUS_CHANGED );

        pWhatHasChanged->LogInUTF8 = 
        ( ColumnStatusFlags[ iGlobalW3SVC_LogInUTF8 ] & fST_COLUMNSTATUS_CHANGED );

        
    }


exit: 

    return hr;

}   // CONFIG_MANAGER::ReadGlobalConfig


/***************************************************************************++

Routine Description:

    Read global data from the config store, and then call the UL&WM to 
    modify it.

Arguments:

    pISTGlobalData - The table from which to read the global data. This is a
    ISimpleTableWrite2 since it is called on notifications only.

    RowIndex - The row number to read from the table.  (Must be zero)

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ModifyGlobalData(
    IN ISimpleTableRead2 * pISTGlobalData,
    IN ULONG RowIndex
    )
{

    HRESULT hr = S_OK;

    GLOBAL_SERVER_CONFIG GlobalConfig;
    GLOBAL_SERVER_CONFIG_CHANGE_FLAGS WhatHasChanged;


    DBG_ASSERT( pISTGlobalData != NULL );

    //
    // Inorder to keep the calls to the different modify routines looking
    // the same we are passing in the RowIndex here, however the RowIndex 
    // should always be zero for the GlobalData table.  It is a major 
    // problem if we have more than one set of global data for the server.
    //
    // DBG_ASSERT( RowIndex == 0 );

    hr = ReadGlobalConfig(
                pISTGlobalData,
                RowIndex,
                FALSE,
                NULL,    // backward compat flag, ignored for updates
                &GlobalConfig,
                &WhatHasChanged
                );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Error reading a global data update \n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Modifying global data\n"
            ));
    }


    //
    // Modify the application in the UL&WM.
    //

    hr = GetWebAdminService()->GetUlAndWorkerManager()->ModifyGlobalData(
                                                            &GlobalConfig,
                                                            &WhatHasChanged
                                                            );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Modifying global data failed\n"
            ));

        goto exit;
    }


exit: 

    return hr;

}   // CONFIG_MANAGER::ModifyGlobalData

/***************************************************************************++

Routine Description:

    Read a single virtual site from the config store.

Arguments:

    pISTAppPools - The table from which to read the virtual site. This is an
    ISimpleTableRead2 if InitialRead is TRUE; but it must be a 
    ISimpleTableWrite2 if InitialRead is FALSE.

    RowIndex - The row number to read from the table.

    InitialRead - TRUE if this is the initial data read, FALSE if it is
    for handling a change notify.

    pVirtualSiteId - Outputs the virtual site id read.

    pVirtualSiteConfig - Outputs the virtual site configuration read.

    pWhatHasChanged - Optionally outputs which particular configuration
    values were changed.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReadVirtualSiteConfig(
    IN ISimpleTableRead2 * pISTVirtualSites,
    IN ULONG RowIndex,
    IN BOOL InitialRead,
    OUT DWORD * pVirtualSiteId,
    OUT VIRTUAL_SITE_CONFIG * pVirtualSiteConfig,
    OUT VIRTUAL_SITE_CONFIG_CHANGE_FLAGS * pWhatHasChanged OPTIONAL
    )
{

    HRESULT hr = S_OK;
    static const ULONG SiteColumns[] = { 
                            iSITES_SiteID,
                            iSITES_Bindings,
                            iSITES_ServerAutoStart,
                            iSITES_ServerCommand,
                            iSITES_ServerComment,
                            iSITES_LogType,
                            iSITES_LogPluginClsid,
                            iSITES_LogFileDirectory,
                            iSITES_LogFilePeriod,
                            iSITES_LogFileTruncateSize,
                            iSITES_LogExtFileFlags,
                            iSITES_MaxBandwidth,  
                            iSITES_MaxConnections,
                            iSITES_ConnectionTimeout,
                            iSITES_LogFileLocaltimeRollover
                            };

    static const ULONG CountOfSiteColumns = sizeof( SiteColumns ) / sizeof( ULONG );
    VOID * pSiteValues[ cSITES_NumberOfColumns ];
    ULONG CountOfBytesOfSiteValues[ cSITES_NumberOfColumns ];
    DWORD ColumnStatusFlags[ cSITES_NumberOfColumns ];


    DBG_ASSERT( pISTVirtualSites != NULL );
    DBG_ASSERT( pVirtualSiteId != NULL );
    DBG_ASSERT( pVirtualSiteConfig != NULL );


    //
    // Initialize output parameters.
    //

    *pVirtualSiteId = 0;

    ZeroMemory( pVirtualSiteConfig, sizeof( *pVirtualSiteConfig ) );

    //
    // Notes on using ISimpleTable:
    //
    // 1. While fetching columns, IST returns pointers to the column values
    // and IST owns all the memory. The pointers are valid for the lifetime 
    // of the IST pointer only. If you want a value to live beyond that, you 
    // need to make a copy.
    // 2. In GetColumnValues, data is returned indexed by the column id in 
    // the array, independent of which columns are retrieved.
    //

    if ( InitialRead )
    {

        //
        // On the initial read of data, we have an ISimpleTableRead2.
        //

        hr = ( reinterpret_cast <ISimpleTableRead2 *> ( pISTVirtualSites ) )->GetColumnValues(
                        RowIndex,                       // row to read
                        CountOfSiteColumns,             // count of columns
                        const_cast <ULONG*> ( SiteColumns ),        // which columns
                        reinterpret_cast <ULONG*> ( CountOfBytesOfSiteValues ),
                                                        // returned column sizes
                        pSiteValues                     // returned values
                        );

    }
    else
    {

        //
        // On subsequent change notifies, we have an ISimpleTableWrite2.
        //

        hr = ( reinterpret_cast <ISimpleTableWrite2 *> ( pISTVirtualSites ) )->GetWriteColumnValues(
                        RowIndex,                       // row to read
                        CountOfSiteColumns,             // count of columns
                        const_cast <ULONG*> ( SiteColumns ),        // which columns
                        ColumnStatusFlags,              // returned column status flags
                        reinterpret_cast <ULONG*> ( CountOfBytesOfSiteValues ),
                                                        // returned column sizes
                        pSiteValues                     // returned values
                        );

    }


    if ( FAILED( hr ) )
    {

        if ( hr != E_ST_NOMOREROWS )
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Error reading a virtual site row\n"
                ));
        }

        goto exit;
    }

    //
    // Just to be on the safe side, validate all DWORD ptrs
    // are not NULL.
    //
    DBG_ASSERT( pSiteValues[ iSITES_SiteID ] );
    DBG_ASSERT( pSiteValues[ iSITES_LogFilePeriod ] );
    DBG_ASSERT( pSiteValues[ iSITES_LogFileTruncateSize ] );
    DBG_ASSERT( pSiteValues[ iSITES_LogExtFileFlags ] );
    DBG_ASSERT( pSiteValues[ iSITES_MaxConnections ] );
    DBG_ASSERT( pSiteValues[ iSITES_MaxBandwidth ] );
    DBG_ASSERT( pSiteValues[ iSITES_ServerAutoStart ] );
    DBG_ASSERT( pSiteValues[ iSITES_ConnectionTimeout ] );
    DBG_ASSERT( pSiteValues[ iSITES_LogFileLocaltimeRollover ] );
    //
    // Get the virtual site id.
    //

    *pVirtualSiteId = * ( reinterpret_cast <ULONG*> ( ( pSiteValues[ iSITES_SiteID ] ) ) );


    //
    // Get the virtual site configuration.
    //

    pVirtualSiteConfig->pBindingsStrings =
    reinterpret_cast <LPWSTR> ( pSiteValues[ iSITES_Bindings ] );

    pVirtualSiteConfig->BindingsStringsCountOfBytes =
    ( CountOfBytesOfSiteValues[ iSITES_Bindings ] );

    pVirtualSiteConfig->Autostart =
    * ( reinterpret_cast <BOOL*> (( pSiteValues[ iSITES_ServerAutoStart ] ) ) );

    // Properties for UL existing on the Default Application
    pVirtualSiteConfig->LogType = *(reinterpret_cast <DWORD*> ( pSiteValues[ iSITES_LogType ]));
    pVirtualSiteConfig->pLogPluginClsid = reinterpret_cast <LPCWSTR> (pSiteValues[ iSITES_LogPluginClsid ]);
    pVirtualSiteConfig->pLogFileDirectory = reinterpret_cast <LPCWSTR> (pSiteValues[ iSITES_LogFileDirectory ]);
    pVirtualSiteConfig->LogFilePeriod = *(reinterpret_cast <DWORD*> (pSiteValues[ iSITES_LogFilePeriod ]));
    pVirtualSiteConfig->LogFileTruncateSize = *(reinterpret_cast <DWORD*> (pSiteValues[ iSITES_LogFileTruncateSize ]));
    pVirtualSiteConfig->LogExtFileFlags = *(reinterpret_cast <DWORD*> (pSiteValues[ iSITES_LogExtFileFlags ]));
    pVirtualSiteConfig->LogFileLocaltimeRollover = *(reinterpret_cast <BOOL*> (pSiteValues[ iSITES_LogFileLocaltimeRollover ] ));
    pVirtualSiteConfig->pServerComment = reinterpret_cast <LPCWSTR> (pSiteValues [ iSITES_ServerComment ]);
    
    pVirtualSiteConfig->MaxConnections = *(reinterpret_cast <DWORD*> (pSiteValues [ iSITES_MaxConnections ]));
    pVirtualSiteConfig->MaxBandwidth = *(reinterpret_cast <DWORD*> (pSiteValues [ iSITES_MaxBandwidth ])); 
    pVirtualSiteConfig->ConnectionTimeout = *(reinterpret_cast <DWORD*> (pSiteValues [ iSITES_ConnectionTimeout ])); 


    //
    // Note: iSITES_ServerCommand is not interesting as site configuration,
    // it is only present for compatibility and only picked up on change
    // notify. See below.
    //


    //
    // If the caller has asked to see which values specifically have
    // changed, then provide that information.
    //

    if ( pWhatHasChanged )
    {

        //
        // In this case, we better be on a change notify path, where we
        // have the ISimpleTableWrite2 interface, and so the column status
        // information is available.
        //

        DBG_ASSERT( ! InitialRead );


        ZeroMemory( pWhatHasChanged, sizeof( *pWhatHasChanged ) );


        pWhatHasChanged->pBindingsStrings =
        ( ColumnStatusFlags[ iSITES_Bindings ] & fST_COLUMNSTATUS_CHANGED );

        pWhatHasChanged->LogType =
        ( ColumnStatusFlags[ iSITES_LogType ] & fST_COLUMNSTATUS_CHANGED );

        pWhatHasChanged->LogFilePeriod =
        ( ColumnStatusFlags[ iSITES_LogFilePeriod ] & fST_COLUMNSTATUS_CHANGED );

        pWhatHasChanged->LogFileTruncateSize =
        ( ColumnStatusFlags[ iSITES_LogFileTruncateSize ] & fST_COLUMNSTATUS_CHANGED );

        pWhatHasChanged->LogExtFileFlags =
        ( ColumnStatusFlags[ iSITES_LogExtFileFlags ] & fST_COLUMNSTATUS_CHANGED );

        pWhatHasChanged->pLogPluginClsid =
        ( ColumnStatusFlags[ iSITES_LogPluginClsid ] & fST_COLUMNSTATUS_CHANGED );

        pWhatHasChanged->pLogFileDirectory =
        ( ColumnStatusFlags[ iSITES_LogFileDirectory ] & fST_COLUMNSTATUS_CHANGED );

        pWhatHasChanged->LogFileLocaltimeRollover =
        ( ColumnStatusFlags[ iSITES_LogFileLocaltimeRollover ] & fST_COLUMNSTATUS_CHANGED );

        pWhatHasChanged->pServerComment =
        ( ColumnStatusFlags[ iSITES_ServerComment ] & fST_COLUMNSTATUS_CHANGED );

        pWhatHasChanged->MaxConnections =
        ( ColumnStatusFlags[ iSITES_MaxConnections ] & fST_COLUMNSTATUS_CHANGED );

        pWhatHasChanged->MaxBandwidth =
        ( ColumnStatusFlags[ iSITES_MaxBandwidth ] & fST_COLUMNSTATUS_CHANGED );

        pWhatHasChanged->ConnectionTimeout =
        ( ColumnStatusFlags[ iSITES_ConnectionTimeout ] & fST_COLUMNSTATUS_CHANGED );
        
        //
        // We ignore changes on the fly to iSITES_ServerAutoStart; it is
        // only relevant at the initial data read. This prevents us from
        // getting confused by change notifies on this property later, 
        // since this is a (rare) example of a property we both write 
        // and read.
        //


        //
        // Compatibility with previous IIS versions: pick up site state
        // change commands. If a server command has been written to the
        // metabase dynamically, then act on it. 
        //

        if ( ( ColumnStatusFlags[ iSITES_ServerCommand ] & fST_COLUMNSTATUS_CHANGED ) &&
             ( pSiteValues[ iSITES_ServerCommand ] != NULL ) )
        {

            hr = ProcessServerCommand(
                        *pVirtualSiteId,
                        ( * ( reinterpret_cast <ULONG*> ( ( pSiteValues[ iSITES_ServerCommand ] ) ) ) )
                        );

            if ( FAILED( hr ) )
            {
            
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Processing server command failed\n"
                    ));

                goto exit;
            }

        }

    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Read from config store virtual site with ID: %lu\n",
            *pVirtualSiteId
            ));
    }


exit: 

    return hr;

}   // CONFIG_MANAGER::ReadVirtualSiteConfig



/***************************************************************************++

Routine Description:

    Process a virtual site control command written to the metabase, for
    compatibility with previous versions of IIS.

Arguments:

    VirtualSiteId - The virtual site.

    ServerCommand - The command read from the metabase.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ProcessServerCommand(
    IN DWORD VirtualSiteId,
    IN DWORD ServerCommand
    )
{

    HRESULT hr = S_OK;
    DWORD NewState = W3_CONTROL_STATE_INVALID;


    //
    // Only process valid command values.
    //

    if ( ( ServerCommand == W3_CONTROL_COMMAND_START ) ||
         ( ServerCommand == W3_CONTROL_COMMAND_STOP ) ||
         ( ServerCommand == W3_CONTROL_COMMAND_PAUSE ) ||
         ( ServerCommand == W3_CONTROL_COMMAND_CONTINUE ) )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Site control command read from metabase: %lu\n",
                ServerCommand
                ));
        }


        //
        // Send the command.
        //

        hr = GetWebAdminService()->GetUlAndWorkerManager()->ControlSite(
                                                                VirtualSiteId,
                                                                ServerCommand,
                                                                &NewState
                                                                );

        if ( FAILED( hr ) )
        {

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Controlling virtual site (via metabase server command compatibility) failed\n"
                ));


            //
            // Ignore any errors.
            //

            hr = S_OK;

        }

    }
    else
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Invalid site control command read from metabase: %lu\n",
                ServerCommand
                ));
        }

    }


    return hr;

}   // CONFIG_MANAGER::ProcessServerCommand

/***************************************************************************++

Routine Description:

        Read all applications listed in the config store.

Arguments:
  
    None

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReadAllApplications(
    )
{

    HRESULT hr = S_OK;
    ISimpleTableRead2 * pISTApplications = NULL;
    ULONG i = 0;
    DWORD ApplicationCount = 0;


    //
    // Get the applications table from the config store.
    //

    hr = GetTable( 
                wszTABLE_APPS,
                EXPECTED_VERSION_APPS,
                FALSE,
                reinterpret_cast <VOID**> ( &pISTApplications )
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Getting applications table failed\n"
            ));

        goto exit;
    }


    //
    // Read all the rows.
    //

    for ( i = 0; ; i++ )
    {

        hr = CreateApplication(
                    pISTApplications,
                    i,
                    TRUE
                    );

        if ( hr == E_ST_NOMOREROWS )
        {
            hr = S_OK;

            break;
        }
        else if ( FAILED( hr ) )
        {

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Creating application failed\n"
                ));

            goto exit;
        }


        ApplicationCount++;

    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
         DBGPRINTF((
             DBG_CONTEXT, 
             "Total number of applications read: %lu\n",
             ApplicationCount
             )); 
    } 


exit: 

    if ( pISTApplications != NULL )
    {
        pISTApplications->Release();
        pISTApplications = NULL;
    }


    return hr;

}   // CONFIG_MANAGER::ReadAllApplications



/***************************************************************************++

Routine Description:

    Read an application from the config store, and then call the UL&WM to 
    create it.

Arguments:

    pISTApplications - The table from which to read the application. This  
    is an ISimpleTableRead2 if InitialRead is TRUE; but it must be a 
    ISimpleTableWrite2 if InitialRead is FALSE.

    RowIndex - The row number to read from the table.

    InitialRead - TRUE if this is the initial data read, FALSE if it is
    for handling a change notify.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::CreateApplication(
    IN ISimpleTableRead2 * pISTApplications,
    IN ULONG RowIndex,
    IN BOOL InitialRead
    )
{

    HRESULT hr = S_OK;
    DWORD VirtualSiteId = 0;
    LPCWSTR pApplicationUrl = NULL;
    APPLICATION_CONFIG ApplicationConfig;


    DBG_ASSERT( pISTApplications != NULL );

    hr = ReadApplicationConfig(
                pISTApplications,
                RowIndex,
                InitialRead,
                &VirtualSiteId,
                &pApplicationUrl,
                &ApplicationConfig,
                NULL
                );

    if ( hr == E_ST_NOMOREROWS )
    {
         // 
        // Only ignore and pass out this return value for
        // create functions.  The create functions are called
        // both on initial setup and on change notifications.
        // The Delete and Modify functions are only called on
        // for change notifications.
        //
        // For change notifications it is a real error 
        // if E_ST_NOMOREROWS is returned.  For the initial
        // setup this is how the loop knows all data has been
        // processed.
        //

        goto exit;
    }
    else if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Error reading an application row\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Creating application of site ID: %lu, with app URL: %S\n",
            VirtualSiteId,
            pApplicationUrl
            ));
    }


    //
    // Create the application in the UL&WM.
    //

    hr = GetWebAdminService()->GetUlAndWorkerManager()->CreateApplication(
                                                            VirtualSiteId,
                                                            pApplicationUrl,
                                                            &ApplicationConfig
                                                            );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating application failed\n"
            ));

        goto exit;
    }


exit: 

    return hr;

}   // CONFIG_MANAGER::CreateApplication



/***************************************************************************++

Routine Description:

    Read an application from the config store, and then call the UL&WM to 
    delete it.

Arguments:

    pISTApplications - The table from which to read the application. This  
    is an ISimpleTableRead2 if InitialRead is TRUE; but it must be a 
    ISimpleTableWrite2 if InitialRead is FALSE.

    RowIndex - The row number to read from the table.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::DeleteApplication(
    IN ISimpleTableRead2 * pISTApplications,
    IN ULONG RowIndex
    )
{

    HRESULT hr = S_OK;
    DWORD VirtualSiteId = 0;
    LPCWSTR pApplicationUrl = NULL;
    APPLICATION_CONFIG ApplicationConfig;


    DBG_ASSERT( pISTApplications != NULL );


    hr = ReadApplicationConfig(
                pISTApplications,
                RowIndex,
                FALSE,
                &VirtualSiteId,
                &pApplicationUrl,
                &ApplicationConfig,
                NULL
                );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Error reading an application row\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Deleting application of site ID: %lu, with app URL: %S\n",
            VirtualSiteId,
            pApplicationUrl
            ));
    }


    //
    // Delete the application in the UL&WM.
    //

    hr = GetWebAdminService()->GetUlAndWorkerManager()->DeleteApplication(
                                                            VirtualSiteId,
                                                            pApplicationUrl
                                                            );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Deleting application failed\n"
            ));

        goto exit;
    }


exit: 

    return hr;

}   // CONFIG_MANAGER::DeleteApplication




/***************************************************************************++

Routine Description:

    Read an application from the config store, and then call the UL&WM to 
    modify it.

Arguments:

    pISTApplications - The table from which to read the application. This  
    is an ISimpleTableRead2 if InitialRead is TRUE; but it must be a 
    ISimpleTableWrite2 if InitialRead is FALSE.

    RowIndex - The row number to read from the table.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ModifyApplication(
    IN ISimpleTableRead2 * pISTApplications,
    IN ULONG RowIndex
    )
{

    HRESULT hr = S_OK;
    DWORD VirtualSiteId = 0;
    LPCWSTR pApplicationUrl = NULL;
    APPLICATION_CONFIG ApplicationConfig;
    APPLICATION_CONFIG_CHANGE_FLAGS WhatHasChanged;


    DBG_ASSERT( pISTApplications != NULL );


    hr = ReadApplicationConfig(
                pISTApplications,
                RowIndex,
                FALSE,
                &VirtualSiteId,
                &pApplicationUrl,
                &ApplicationConfig,
                &WhatHasChanged
                );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Error reading an application row\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Modifying application of site ID: %lu, with app URL: %S\n",
            VirtualSiteId,
            pApplicationUrl
            ));
    }


    //
    // Modify the application in the UL&WM.
    //

    hr = GetWebAdminService()->GetUlAndWorkerManager()->ModifyApplication(
                                                            VirtualSiteId,
                                                            pApplicationUrl,
                                                            &ApplicationConfig,
                                                            &WhatHasChanged
                                                            );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Modifying application failed\n"
            ));

        goto exit;
    }


exit: 

    return hr;

}   // CONFIG_MANAGER::ModifyApplication



/***************************************************************************++

Routine Description:

    Read a single application from the config store.

Arguments:
  
    pISTApplications - The table from which to read the virtual site. This 
    is an ISimpleTableRead2 if InitialRead is TRUE; but it must be a 
    ISimpleTableWrite2 if InitialRead is FALSE.

    RowIndex - The row number to read from the table.

    InitialRead - TRUE if this is the initial data read, FALSE if it is
    for handling a change notify.

    pVirtualSiteId - Outputs the virtual site id read.

    ppApplicationUrl - Outputs the application URL read.

    pApplicationConfig - Outputs the application configuration read.

    pWhatHasChanged - Optionally outputs which particular configuration
    values were changed.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReadApplicationConfig(
    IN ISimpleTableRead2 * pISTApplications,
    IN ULONG RowIndex,
    IN BOOL InitialRead,
    OUT DWORD * pVirtualSiteId,
    OUT LPCWSTR * ppApplicationUrl,
    OUT APPLICATION_CONFIG * pApplicationConfig,
    OUT APPLICATION_CONFIG_CHANGE_FLAGS * pWhatHasChanged OPTIONAL
    )
{

    HRESULT hr = S_OK;
    static const ULONG AppColumns[] = { 
                            iAPPS_SiteID,
                            iAPPS_AppRelativeURL,
                            iAPPS_AppPoolId
                            };
    static const ULONG CountOfAppColumns = sizeof( AppColumns ) / sizeof( ULONG );
    VOID * pAppValues[ cAPPS_NumberOfColumns ];
    DWORD ColumnStatusFlags[ cAPPS_NumberOfColumns ];


    DBG_ASSERT( pISTApplications != NULL );
    DBG_ASSERT( pVirtualSiteId != NULL );
    DBG_ASSERT( ppApplicationUrl != NULL );
    DBG_ASSERT( pApplicationConfig != NULL );


    //
    // Initialize output parameters.
    //

    *pVirtualSiteId = 0;

    *ppApplicationUrl = NULL;

    ZeroMemory( pApplicationConfig, sizeof( *pApplicationConfig ) );


    //
    // Notes on using ISimpleTable:
    //
    // 1. While fetching columns, IST returns pointers to the column values
    // and IST owns all the memory. The pointers are valid for the lifetime 
    // of the IST pointer only. If you want a value to live beyond that, you 
    // need to make a copy.
    // 2. In GetColumnValues, data is returned indexed by the column id in 
    // the array, independent of which columns are retrieved.
    //


    if ( InitialRead )
    {

        //
        // On the initial read of data, we have an ISimpleTableRead2.
        //

        hr = ( reinterpret_cast <ISimpleTableRead2 *> ( pISTApplications ) )->GetColumnValues(
                        RowIndex,                       // row to read
                        CountOfAppColumns,              // count of columns
                        const_cast <ULONG*> ( AppColumns ),         // which columns
                        NULL,                           // returned column sizes
                        pAppValues                      // returned values
                        );

    }
    else
    {

        //
        // On subsequent change notifies, we have an ISimpleTableWrite2.
        //

        hr = ( reinterpret_cast <ISimpleTableWrite2 *> ( pISTApplications ) )->GetWriteColumnValues(
                        RowIndex,                       // row to read
                        CountOfAppColumns,              // count of columns
                        const_cast <ULONG*> ( AppColumns ),         // which columns
                        ColumnStatusFlags,              // returned column status flags
                        NULL,                           // returned column sizes
                        pAppValues                      // returned values
                        );

    }


    if ( FAILED( hr ) )
    {

        if ( hr != E_ST_NOMOREROWS )
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Error reading an application row\n"
                ));
        }

        goto exit;
    }


    //
    // Get the stable app information. 
    //

    *pVirtualSiteId = * ( reinterpret_cast <DWORD*> ( ( pAppValues[ iAPPS_SiteID ] ) ) );

    *ppApplicationUrl = reinterpret_cast <LPWSTR> ( pAppValues[ iAPPS_AppRelativeURL ] );


    //
    // Get the application configuration.
    //

    // If we are in backward compatibility mode than no matter
    // what the applications settings, we want the application
    // to hook into the DefaultAppPool.  So we override that setting
    // here.
    if (GetWebAdminService()->IsBackwardCompatibilityEnabled())
    {
        pApplicationConfig->pAppPoolId = reinterpret_cast <LPWSTR> ( wszDEFAULT_APP_POOL );
    }
    else
    {
        pApplicationConfig->pAppPoolId = reinterpret_cast <LPWSTR> ( pAppValues[ iAPPS_AppPoolId ] );
    }

    //
    // If the caller has asked to see which values specifically have
    // changed, then provide that information.
    //

    if ( pWhatHasChanged )
    {

        //
        // In this case, we better be on a change notify path, where we
        // have the ISimpleTableWrite2 interface, and so the column status
        // information is available.
        //

        DBG_ASSERT( ! InitialRead );


        ZeroMemory( pWhatHasChanged, sizeof( *pWhatHasChanged ) );

        // AppPoolId never changes in backward compatibility mode.
        if (GetWebAdminService()->IsBackwardCompatibilityEnabled())
        {
            pWhatHasChanged->pAppPoolId = 0;
        }
        else
        {
            pWhatHasChanged->pAppPoolId =
            ( ColumnStatusFlags[ iAPPS_AppPoolId ] & fST_COLUMNSTATUS_CHANGED );
        }

    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Read from config store app of site ID: %lu, with app URL: %S\n",
            *pVirtualSiteId,
            *ppApplicationUrl
            ));
    }


exit: 

    return hr;

}   // CONFIG_MANAGER::ReadApplicationConfig



/***************************************************************************++

Routine Description:

    Helper function to obtain ISimpleTable interface pointers.

Arguments:

    pTableName - The desired table. 

    ExpectedVersion - the expected version of the table schema. 

    WriteAccess - If TRUE, then a writable table is desired; if FALSE,
    then a read access table is desired.

    ppISimpleTable - The returned interface pointer to an ISimpleTable 
    interface.

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT
CONFIG_MANAGER::GetTable(
    IN LPCWSTR pTableName,
    IN DWORD ExpectedVersion,
    IN BOOL WriteAccess,
    OUT LPVOID * ppISimpleTable
    )
{

    HRESULT hr = S_OK;
    DWORD TableVersion = 0;
    DWORD LevelOfService = 0;


    DBG_ASSERT( ppISimpleTable != NULL );


    //
    // Initialize output parameters.
    //

    *ppISimpleTable = NULL;


    //
    // Determine the level of service. For writing, it is important to
    // specify fST_LOS_UNPOPULATED for efficiency.
    //

    if ( WriteAccess )
    {
        LevelOfService = fST_LOS_READWRITE | fST_LOS_UNPOPULATED; 
    }
    else
    {
        LevelOfService = 0; 
    }


    //
    // Get the table.
    //

    DBG_ASSERT( m_pISimpleTableDispenser2 != NULL );

    hr = m_pISimpleTableDispenser2->GetTable(
                                        wszDATABASE_IIS,  // database name
                                        pTableName,             // table name
                                        NULL,                   // query data
                                        NULL,                   // query metadata
                                        eST_QUERYFORMAT_CELLS,  // query format
                                        LevelOfService,         // service level
                                        ppISimpleTable          // returned table
                                        );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Getting config table failed\n"
            ));


        //
        // Log an event: the config table is not available, possibly 
        // because config files are missing. 
        //

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_CONFIG_TABLE_FAILURE,         // message id
                0,                                      // count of strings
                NULL,                                   // array of strings
                0                                       // error code
                );


        //
        // CODEWORK To be implemented: if it is file not found, it may be 
        // because someone has nuked the config files (and the *clb* cache).
        // Current behavior is to give up starting the service in this case.
        // Once we have change notify, should we still start the service,
        // and wait for valid config files to appear?
        //


        goto exit;
    }


exit:

    return hr;

}   // CONFIG_MANAGER::GetTable



/***************************************************************************++

Routine Description:

    Register for change notification with the config store. 

Arguments:

    SnapshotId - The config snapshot from which any deltas should be computed.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::RegisterChangeNotify(
    IN DWORD SnapshotId
    )
{

    HRESULT hr = S_OK;
    MultiSubscribe Subscriptions[] = {
        { wszDATABASE_IIS, wszTABLE_APPPOOLS, NULL, 0, eST_QUERYFORMAT_CELLS },
        { wszDATABASE_IIS, wszTABLE_SITES, NULL, 0, eST_QUERYFORMAT_CELLS },
        { wszDATABASE_IIS, wszTABLE_APPS, NULL, 0, eST_QUERYFORMAT_CELLS },
        { wszDATABASE_IIS, wszTABLE_GlobalW3SVC, NULL, 0, eST_QUERYFORMAT_CELLS }
        };


    //
    // Create our callback sink object.
    //

    m_pConfigChangeSink = new CONFIG_CHANGE_SINK();

    if ( m_pConfigChangeSink == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating CONFIG_CHANGE_SINK failed\n"
            ));

        goto exit;
    }

    
    hr = m_pISimpleTableDispenser2->QueryInterface(
                                        IID_ISimpleTableAdvise, 
                                        reinterpret_cast <VOID**> ( &m_pISimpleTableAdvise )
                                        );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Getting simple table advise interface failed\n"
            )); 

        goto exit;
    }


    //
    // Register our callback interface. Note that notifications can start
    // arriving even before this call returns.
    //

    hr = m_pISimpleTableAdvise->SimpleTableAdvise(
                                    m_pConfigChangeSink,    // callback interface
                                    SnapshotId,             // snapshot id
                                    Subscriptions,          // subscription array
                                    sizeof( Subscriptions ) / sizeof( MultiSubscribe ),
                                                            // subscription count
                                    &m_ChangeNotifyCookie   // registration cookie
                                    );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Registering for change notification failed\n"
            ));

        goto exit;
    }

    m_ChangeNotifySinkRegistered = TRUE;


exit:

    return hr;

}   // CONFIG_MANAGER::RegisterChangeNotify



/***************************************************************************++

Routine Description:

    Tear down the change notify apparatus. This can be safely called 
    multiple times. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::UnregisterChangeNotify(
    )
{

    HRESULT hr = S_OK;


    if ( m_ChangeNotifySinkRegistered )
    {

        //
        // Unregister our callback interface. 
        //

        hr = m_pISimpleTableAdvise->SimpleTableUnadvise( m_ChangeNotifyCookie );

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Unregistering for change notification failed\n"
                ));

        }


        m_ChangeNotifySinkRegistered = FALSE;
    }


    return hr;

}   // CONFIG_MANAGER::UnregisterChangeNotify

/***************************************************************************++

Routine Description:

    Configures the metabase to advertise the capabilities of the server. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
VOID
CONFIG_MANAGER::AdvertiseServiceInformationInMB(
    )
{

    HRESULT hr = S_OK;
    IMSAdminBase * pIMSAdminBase = NULL;
    METADATA_HANDLE hW3SVC = NULL;
    DWORD value = 0;
    DWORD productType = 0;
    DWORD capabilities = 0;
    HKEY  hkey = NULL;

    METADATA_RECORD mdrMDData;

    hr = CoCreateInstance( 
                CLSID_MSAdminBase,                  // CLSID
                NULL,                               // controlling unknown
                CLSCTX_SERVER,                      // desired context
                IID_IMSAdminBase,                   // IID
                reinterpret_cast <VOID**> ( &pIMSAdminBase )     // returned interface
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating metabase base object failed\n"
            ));

        goto exit;
    }


    //
    // Open the Sites Key so we can change the app pool
    //
    hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                    L"LM\\W3SVC",
                                    METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                                    30000,  // wait for 30 seconds. ( same as adsi, according to bilal )
                                    &hW3SVC );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Openning the site key failed\n"
            ));

        goto exit;
    }

    //
    // set the version
    //
    value = IIS_SERVER_VERSION_MAJOR;

    mdrMDData.dwMDIdentifier    = MD_SERVER_VERSION_MAJOR;
    mdrMDData.dwMDAttributes    = METADATA_NO_ATTRIBUTES;
    mdrMDData.dwMDUserType      = IIS_MD_UT_SERVER;
    mdrMDData.dwMDDataType      = DWORD_METADATA;
    mdrMDData.dwMDDataLen       = sizeof (DWORD);
    mdrMDData.pbMDData          = reinterpret_cast <BYTE*> ( &value ); 

    hr = pIMSAdminBase->SetData(hW3SVC, IIS_MD_SVC_INFO_PATH_W, &mdrMDData);
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting the major version number failed\n"
            ));

        goto exit;
    }

    value = IIS_SERVER_VERSION_MINOR;

    mdrMDData.dwMDIdentifier    = MD_SERVER_VERSION_MINOR;
    mdrMDData.dwMDAttributes    = METADATA_NO_ATTRIBUTES;
    mdrMDData.dwMDUserType      = IIS_MD_UT_SERVER;
    mdrMDData.dwMDDataType      = DWORD_METADATA;
    mdrMDData.dwMDDataLen       = sizeof (DWORD);
    mdrMDData.pbMDData          = reinterpret_cast <BYTE*> ( &value ); 

    hr = pIMSAdminBase->SetData(hW3SVC, IIS_MD_SVC_INFO_PATH_W, &mdrMDData);
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting the minor version number failed\n"
            ));

        goto exit;
    }

    //
    // set platform type
    //

    switch (IISGetPlatformType()) {

        case PtNtServer:
            productType = INET_INFO_PRODUCT_NTSERVER;
            capabilities = IIS_CAP1_NTS;
            break;
        case PtNtWorkstation:
            productType = INET_INFO_PRODUCT_NTWKSTA;
            capabilities = IIS_CAP1_NTW;
            break;
        case PtWindows95:
            productType = INET_INFO_PRODUCT_WINDOWS95;
            capabilities = IIS_CAP1_W95;
            break;
        default:
            productType = INET_INFO_PRODUCT_UNKNOWN;
            capabilities = IIS_CAP1_W95;
    }

    mdrMDData.dwMDIdentifier    = MD_SERVER_PLATFORM;
    mdrMDData.dwMDAttributes    = METADATA_NO_ATTRIBUTES;
    mdrMDData.dwMDUserType      = IIS_MD_UT_SERVER;
    mdrMDData.dwMDDataType      = DWORD_METADATA;
    mdrMDData.dwMDDataLen       = sizeof (DWORD);
    mdrMDData.pbMDData          = reinterpret_cast <BYTE*> ( &productType ); 

    hr = pIMSAdminBase->SetData(hW3SVC, IIS_MD_SVC_INFO_PATH_W, &mdrMDData);
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting the product type failed\n"
            ));

        goto exit;
    }

    //
    //  Check to see if FrontPage is installed
    //

    if ( !RegOpenKeyExA( HKEY_LOCAL_MACHINE,
                        REG_FP_PATH,
                        0,
                        KEY_READ,
                        &hkey ))
    {
        capabilities |= IIS_CAP1_FP_INSTALLED;

        DBG_REQUIRE( !RegCloseKey( hkey ));
    }

    //
    // In IIS 5.1 we also set the IIS_CAP1_DIGEST_SUPPORT and IIS_CAP1_NT_CERTMAP_SUPPORT
    // based on whether or not domain controllers and active directories were around.  These
    // properties are used by the UI to determine if they should allow the user to enable
    // these options.  In IIS 6.0 we are going to set these to true and let the UI configure
    // systems to use these whether or not the server is setup to support them.  The worker
    // processes should gracefully fail calls, if it is not setup.  This decision is based 
    // on the fact that we don't want to do long running operations during the service startup.
    // TaylorW, SergeiA, Jaroslav and I (EmilyK) have all agreed to this for Beta 2.  It most likely 
    // won't change for RTM if there no issues arise from this.

    capabilities |= IIS_CAP1_DIGEST_SUPPORT;
    capabilities |= IIS_CAP1_NT_CERTMAP_SUPPORT;

    //
    // Set the capabilities flag
    //

    mdrMDData.dwMDIdentifier    = MD_SERVER_CAPABILITIES;
    mdrMDData.dwMDAttributes    = METADATA_NO_ATTRIBUTES;
    mdrMDData.dwMDUserType      = IIS_MD_UT_SERVER;
    mdrMDData.dwMDDataType      = DWORD_METADATA;
    mdrMDData.dwMDDataLen       = sizeof (DWORD);
    mdrMDData.pbMDData          = reinterpret_cast <BYTE*> ( &capabilities ); 

    hr = pIMSAdminBase->SetData(hW3SVC, IIS_MD_SVC_INFO_PATH_W, &mdrMDData);
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting the product type failed\n"
            ));

        goto exit;
    }

exit:

    if ( hW3SVC && pIMSAdminBase )
    {
        DBG_REQUIRE( pIMSAdminBase->CloseKey( hW3SVC ) == S_OK );
        hW3SVC = NULL;
    }

    if (pIMSAdminBase)
    {
       pIMSAdminBase->Release();
       pIMSAdminBase = NULL;
    }

    //
    // In checked mode it would be good to 
    // investigate any failures to this code,
    // but it's not fatal to the server in
    // release mode.
    //
    DBG_ASSERT ( hr == S_OK );

    return;

} // CONFIG_MANAGER::AdvertiseServiceInformationInMB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\config_manager.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    config_manager.h

Abstract:

    The IIS web admin service configuration manager class definition.

Author:

    Seth Pollack (sethp)        5-Jan-1999

Revision History:

--*/



#ifndef _CONFIG_MANAGER_H_
#define _CONFIG_MANAGER_H_



//
// common #defines
//

#define CONFIG_MANAGER_SIGNATURE        CREATE_SIGNATURE( 'CFGM' )
#define CONFIG_MANAGER_SIGNATURE_FREED  CREATE_SIGNATURE( 'cfgX' )

//
// Expected schema versions in the config store.
//

#define EXPECTED_VERSION_APPPOOLS   1
#define EXPECTED_VERSION_SITES      1
#define EXPECTED_VERSION_APPS       1
#define EXPECTED_VERSION_GLOBAL     1


//
// prototypes
//


class CONFIG_MANAGER
{

public:

    CONFIG_MANAGER(
        );

    virtual
    ~CONFIG_MANAGER(
        );

    HRESULT
    Initialize(
        );

    VOID
    Terminate(
        );

    HRESULT
    ProcessConfigChange(
        IN CONFIG_CHANGE * pConfigChange
        );

    HRESULT
    StopChangeProcessing(
        );

    HRESULT
    RehookChangeProcessing(
        );

    HRESULT
    SetVirtualSiteStateAndError(
        IN DWORD VirtualSiteId,
        IN DWORD ServerState,
        IN DWORD Win32Error
        );

    HRESULT
    SetVirtualSiteAutostart(
        IN DWORD VirtualSiteId,
        IN BOOL Autostart
        );

    HRESULT
    SetAppPoolState(
        IN LPCWSTR pAppPoolId,
        IN DWORD ServerState
        );

    HRESULT
    SetAppPoolAutostart(
        IN LPCWSTR pAppPoolId,
        IN BOOL Autostart
        );

private:

    HRESULT
    ReadAllConfiguration(
        );

    HRESULT
    ReadGlobalData(
        );

    HRESULT
    ReadAllAppPools(
        );

    HRESULT
    CreateAppPool(
        IN ISimpleTableRead2 * pISTAppPools,
        IN ULONG RowIndex,
        IN BOOL InitialRead
        );

    HRESULT
    DeleteAppPool(
        IN ISimpleTableRead2 * pISTAppPools,
        IN ULONG RowIndex
        );

    HRESULT
    ModifyAppPool(
        IN ISimpleTableRead2 * pISTAppPools,
        IN ULONG RowIndex
        );

    HRESULT
    ReadAppPoolConfig(
        IN ISimpleTableRead2 * pISTAppPools,
        IN ULONG RowIndex,
        IN BOOL InitialRead,
        OUT LPWSTR * ppAppPoolName,
        OUT APP_POOL_CONFIG * pAppPoolConfig,
        OUT APP_POOL_CONFIG_CHANGE_FLAGS * pWhatHasChanged OPTIONAL
        );

    HRESULT
    ReadAllVirtualSites(
        );

    HRESULT
    CreateVirtualSite(
        IN ISimpleTableRead2 * pISTVirtualSites,
        IN ULONG RowIndex,
        IN BOOL InitialRead
        );

    HRESULT
    DeleteVirtualSite(
        IN ISimpleTableRead2 * pISTVirtualSites,
        IN ULONG RowIndex
        );

    HRESULT
    ModifyVirtualSite(
        IN ISimpleTableRead2 * pISTVirtualSites,
        IN ULONG RowIndex
        );

    HRESULT
    ReadGlobalConfig(
        IN ISimpleTableRead2 * pISTGlobal,
        IN ULONG RowIndex,
        IN BOOL InitialRead,
        OUT BOOL* pBackwardCompatibility,
        OUT GLOBAL_SERVER_CONFIG* pGlobalConfig,
        OUT GLOBAL_SERVER_CONFIG_CHANGE_FLAGS * pWhatHasChanged OPTIONAL
        );

    HRESULT
    ModifyGlobalData(
        IN ISimpleTableRead2 * pISTGlobalData,
        IN ULONG RowIndex
        );

    HRESULT
    ReadVirtualSiteConfig(
        IN ISimpleTableRead2 * pISTVirtualSites,
        IN ULONG RowIndex,
        IN BOOL InitialRead,
        OUT DWORD * pVirtualSiteId,
        OUT VIRTUAL_SITE_CONFIG * pVirtualSiteConfig,
        OUT VIRTUAL_SITE_CONFIG_CHANGE_FLAGS * pWhatHasChanged OPTIONAL
        );

    HRESULT
    ProcessServerCommand(
        IN DWORD VirtualSiteId,
        IN DWORD ServerCommand
        );

    HRESULT
    ReadAllApplications(
        );

    HRESULT
    CreateApplication(
        IN ISimpleTableRead2 * pISTApplications,
        IN ULONG RowIndex,
        IN BOOL InitialRead
        );

    HRESULT
    DeleteApplication(
        IN ISimpleTableRead2 * pISTApplications,
        IN ULONG RowIndex
        );

    HRESULT
    ModifyApplication(
        IN ISimpleTableRead2 * pISTApplications,
        IN ULONG RowIndex
        );

    HRESULT
    ReadApplicationConfig(
        IN ISimpleTableRead2 * pISTApplications,
        IN ULONG RowIndex,
        IN BOOL InitialRead,
        OUT DWORD * pVirtualSiteId,
        OUT LPCWSTR * ppApplicationUrl,
        OUT APPLICATION_CONFIG * pApplicationConfig,
        OUT APPLICATION_CONFIG_CHANGE_FLAGS * pWhatHasChanged OPTIONAL
        );

    HRESULT
    GetTable(
        IN LPCWSTR pTableName,
        IN DWORD ExpectedVersion,
        IN BOOL WriteAccess,
        OUT LPVOID * ppISimpleTable
        );

    HRESULT
    RegisterChangeNotify(
        IN DWORD SnapshotId
        );

    HRESULT
    UnregisterChangeNotify(
        );

    VOID
    AdvertiseServiceInformationInMB(
        );


    DWORD m_Signature;

    ISimpleTableDispenser2 * m_pISimpleTableDispenser2;

    ISimpleTableAdvise * m_pISimpleTableAdvise; 

    ISimpleTableEvent * m_pConfigChangeSink;

    DWORD m_ChangeNotifyCookie;

    BOOL m_ChangeNotifySinkRegistered;

    BOOL m_ProcessConfigChanges;


};  // class CONFIG_MANAGER



#endif  // _CONFIG_MANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\control_api.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    control_api.h

Abstract:

    The IIS web admin service control api class definition.

Author:

    Seth Pollack (sethp)        15-Feb-2000

Revision History:

--*/



#ifndef _CONTROL_API_H_
#define _CONTROL_API_H_



//
// common #defines
//

#define CONTROL_API_SIGNATURE       CREATE_SIGNATURE( 'CAPI' )
#define CONTROL_API_SIGNATURE_FREED CREATE_SIGNATURE( 'capX' )



//
// prototypes
//


class CONTROL_API
    : public IW3Control
{

public:

    CONTROL_API(
        );

    virtual
    ~CONTROL_API(
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    QueryInterface(
        IN REFIID iid,
        OUT VOID ** ppObject
        );

    virtual
    ULONG
    STDMETHODCALLTYPE
    AddRef(
        );

    virtual
    ULONG
    STDMETHODCALLTYPE
    Release(
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    ControlSite(
        IN DWORD SiteId,
        IN DWORD Command,
        OUT DWORD * pNewState
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    QuerySiteStatus(
        IN DWORD SiteId,
        OUT DWORD * pCurrentState
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    GetCurrentMode(
        OUT DWORD * pCurrentMode
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    RecycleAppPool(
        IN LPCWSTR szAppPool
        );

private:

    HRESULT
    MarshallCallToMainWorkerThread(
        IN CONTROL_API_CALL_METHOD Method,
        IN DWORD_PTR Param0 OPTIONAL = 0,
        IN DWORD_PTR Param1 OPTIONAL = 0,
        IN DWORD_PTR Param2 OPTIONAL = 0,
        IN DWORD_PTR Param3 OPTIONAL = 0
        );


    DWORD m_Signature;

    LONG m_RefCount;


};  // class CONTROL_API



#endif  // _CONTROL_API_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\control_api.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    control_api.cxx

Abstract:

    The IIS web admin service control api class implementation. 
    This class receives and processes calls on the control api.

    Threading: Calls arrive on COM threads (i.e., secondary threads), and 
    so work items are posted to process the changes on the main worker thread.

Author:

    Seth Pollack (sethp)        15-Feb-2000

Revision History:

--*/



#include  "precomp.h"

BOOL
IsLocalSystemTheCaller();

/***************************************************************************++

Routine Description:

    Constructor for the CONTROL_API class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONTROL_API::CONTROL_API(
    )
{

    //
    // Set the initial reference count to 1, in order to represent the
    // reference owned by the creator of this instance.
    //

    m_RefCount = 1;

    m_Signature = CONTROL_API_SIGNATURE;

}   // CONTROL_API::CONTROL_API



/***************************************************************************++

Routine Description:

    Destructor for the CONTROL_API class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONTROL_API::~CONTROL_API(
    )
{

    DBG_ASSERT( m_Signature == CONTROL_API_SIGNATURE );

    m_Signature = CONTROL_API_SIGNATURE_FREED;

    DBG_ASSERT( m_RefCount == 0 );


}   // CONTROL_API::~CONTROL_API



/***************************************************************************++

Routine Description:

    Standard IUnknown::QueryInterface.

Arguments:

    iid - The requested interface id.

    ppObject - The returned interface pointer, or NULL on failure.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CONTROL_API::QueryInterface(
    IN REFIID iid,
    OUT VOID ** ppObject
    )
{

    HRESULT hr = S_OK;


    if ( ppObject == NULL )
    {
        hr = E_INVALIDARG;

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "QueryInterface on CONTROL_API object failed, bad pointer\n"
            ));

        goto exit;
    }


    if ( iid == IID_IUnknown || iid == IID_IW3Control )
    {
        *ppObject = reinterpret_cast< IW3Control * > ( this );

        AddRef();
    }
    else
    {
        *ppObject = NULL;
        
        hr = E_NOINTERFACE;

        // we get called for a lot of un supported interfaces
        // we don't want to spew data for all this.

#if 0
        LPWSTR pIID = NULL;

        StringFromCLSID( iid, &pIID );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "QueryInterface on CONTROL_API object failed, IID %S not supported\n",
            pIID
            ));


        if ( pIID )
        {
            CoTaskMemFree (pIID);
            pIID = NULL;
        }

#endif

        goto exit;
    }


exit:

    return hr;

}   // CONTROL_API::QueryInterface



/***************************************************************************++

Routine Description:

    Standard IUnknown::AddRef.

Arguments:

    None.

Return Value:

    ULONG - The new reference count.

--***************************************************************************/

ULONG
STDMETHODCALLTYPE
CONTROL_API::AddRef(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedIncrement( &m_RefCount );


    //
    // The reference count should never have been less than zero; and
    // furthermore once it has hit zero it should never bounce back up;
    // given these conditions, it better be greater than one now.
    //
    
    DBG_ASSERT( NewRefCount > 1 );


    return ( ( ULONG ) NewRefCount );

}   // CONTROL_API::AddRef



/***************************************************************************++

Routine Description:

    Standard IUnknown::Release.

Arguments:

    None.

Return Value:

    ULONG - The new reference count.

--***************************************************************************/

ULONG
STDMETHODCALLTYPE
CONTROL_API::Release(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedDecrement( &m_RefCount );

    // ref count should never go negative
    DBG_ASSERT( NewRefCount >= 0 );

    if ( NewRefCount == 0 )
    {
        // time to go away

        IF_DEBUG( WEB_ADMIN_SERVICE_REFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Reference count has hit zero in CONTROL_API, deleting (ptr: %p)\n",
                this
                ));
        }


        delete this;


    }


    return ( ( ULONG ) NewRefCount );

}   // CONTROL_API::Release



/***************************************************************************++

Routine Description:

    Process a site control request. 

Arguments:

    SiteId - The site to control.

    Command - The command issued.

    pNewState - The returned new state. This may be a pending state if 
    completing the operation might take some time. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CONTROL_API::ControlSite(
    IN DWORD SiteId,
    IN DWORD Command,
    OUT DWORD * pNewState
    )
{

    return E_NOTIMPL;

#if 0

    HRESULT hr = S_OK;


    DBG_ASSERT( ! ON_MAIN_WORKER_THREAD );


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Call received to IW3Control::ControlSite()\n"
            ));
    }


    //
    // Validate parameters.
    //

    if ( pNewState == NULL )
    {
        hr = E_INVALIDARG;

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Invalid parameters passed to control api\n"
            ));

        goto exit;
    }


    //
    // Initialize output parameters.
    //

    *pNewState = W3_CONTROL_STATE_INVALID;


    //
    // Process the call.
    //

    hr = MarshallCallToMainWorkerThread(
                ControlSiteControlApiCallMethod,
                ( DWORD_PTR ) SiteId,
                ( DWORD_PTR ) Command,
                ( DWORD_PTR ) pNewState
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Processing call failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

#endif

}   // CONTROL_API::ControlSite



/***************************************************************************++

Routine Description:

    Process a site status query request. 

Arguments:

    SiteId - The site.

    Command - The command issued.

    pCurrentState - The returned current site state. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CONTROL_API::QuerySiteStatus(
    IN DWORD SiteId,
    OUT DWORD * pCurrentState
    )
{

    return E_NOTIMPL;

#if 0
    HRESULT hr = S_OK;


    DBG_ASSERT( ! ON_MAIN_WORKER_THREAD );


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Call received to IW3Control::QuerySiteStatus()\n"
            ));
    }


    //
    // Validate parameters.
    //

    if ( pCurrentState == NULL )
    {
        hr = E_INVALIDARG;

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Invalid parameters passed to control api\n"
            ));

        goto exit;
    }


    //
    // Initialize output parameters.
    //

    *pCurrentState = W3_CONTROL_STATE_INVALID;


    //
    // Process the call.
    //

    hr = MarshallCallToMainWorkerThread(
                QuerySiteStatusControlApiCallMethod,
                ( DWORD_PTR ) SiteId,
                ( DWORD_PTR ) pCurrentState
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Processing call failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

#endif    
}   // CONTROL_API::QuerySiteStatus



/***************************************************************************++

Routine Description:

    Returns the current process model that the server is running under.

Arguments:

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CONTROL_API::GetCurrentMode(
    OUT DWORD * pCurrentMode
    )
{

    HRESULT hr = S_OK;

    //
    // Security Check, only local system is allowed
    // to call this function.  See comment in the 
    // IsLocalSystemTheCaller function to understand
    // why we do it this way.
    // 
    if ( !IsLocalSystemTheCaller() )
    {
        return E_ACCESSDENIED;
    }

    //
    // Complain if we are asked for the current mode
    // but are not given an appropriate place to store
    // it.
    //
    if ( pCurrentMode == NULL )
    {
        return E_INVALIDARG;
    }

    // Default to BC mode.
    *pCurrentMode = 0;

    //
    // Go ahead and marshall the call to the main thread
    // this will allow for us to do the check and set the
    // current mode variable.
    //
    hr = MarshallCallToMainWorkerThread(
                GetCurrentModeControlApiCallMethod,
                ( DWORD_PTR ) pCurrentMode
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Failed to marshall to the main thread when checking current mode.\n"
            ));

    }

    return hr;

}   // CONTROL_API::GetCurrentMode

/***************************************************************************++

Routine Description:

    Returns the current process model that the server is running under.

Arguments:

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CONTROL_API::RecycleAppPool(
    IN LPCWSTR szAppPool
    )
{

    HRESULT hr = S_OK;

    //
    // Security Check, only local system is allowed
    // to call this function.  See comment in the 
    // IsLocalSystemTheCaller function to understand
    // why we do it this way.
    // 
    if ( !IsLocalSystemTheCaller() )
    {
        return E_ACCESSDENIED;
    }

    //
    // Complain if we are asked for the current mode
    // but are not given an appropriate place to store
    // it.
    //
    if ( szAppPool == NULL )
    {
        return E_INVALIDARG;
    }

    //
    // Go ahead and marshall the call to the main thread
    // this will allow for us to do the check and set the
    // current mode variable.
    //
    hr = MarshallCallToMainWorkerThread(
                RecycleAppPoolControlApiCallMethod,
                ( DWORD_PTR ) szAppPool
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Failed to marshall to the main thread to recycle app pool %S.\n",
            szAppPool
            ));

    }

    return hr;

}   // CONTROL_API::RecycleAppPool

/***************************************************************************++

Routine Description:

    Marshall the call to the main worker thread for processing; then
    return the results.

Arguments:

    Method - The method being called. 

    Param0 ... ParamN - The parameter values for the method. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONTROL_API::MarshallCallToMainWorkerThread(
    IN CONTROL_API_CALL_METHOD Method,
    IN DWORD_PTR Param0 OPTIONAL,
    IN DWORD_PTR Param1 OPTIONAL,
    IN DWORD_PTR Param2 OPTIONAL,
    IN DWORD_PTR Param3 OPTIONAL
    )
{

    HRESULT hr = S_OK;
    CONTROL_API_CALL * pControlApiCall = NULL;


    DBG_ASSERT( ! ON_MAIN_WORKER_THREAD );


    //
    // BUGBUG If we are going to do any internal security checks (beyond
    // DCOM security), for example checking explicitly against the metabase
    // admin ACL, then this is the spot.
    //


    //
    // Create an object to hold the call.
    //

    pControlApiCall = new CONTROL_API_CALL();

    if ( pControlApiCall == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating CONTROL_API_CALL failed\n"
            ));

        GetWebAdminService()->FatalErrorOnSecondaryThread( hr );

        goto exit;
    }


    hr = pControlApiCall->Initialize(
                                Method,
                                Param0,
                                Param1,
                                Param2,
                                Param3
                                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing control api call failed\n"
            ));

        GetWebAdminService()->FatalErrorOnSecondaryThread( hr );

        goto exit;
    }


    //
    // Post to the main worker thread for processing.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "About to create/queue work item for processing control api call, CONTROL_API_CALL (ptr: %p)\n",
            pControlApiCall
            ));
    }


    QueueWorkItemFromSecondaryThread(
        pControlApiCall,
        ProcessCallControlApiCallWorkItem
        );


    //
    // Now that we've queued the call, wait on the per-call event
    // so that we know when the call has been processed. Once this
    // event has been signalled, the work is done, the return code
    // is available, and output parameters have been set.
    //

    DBG_REQUIRE( WaitForSingleObject( pControlApiCall->GetEvent(), INFINITE ) == WAIT_OBJECT_0 );


    //
    // Pull out the return code from the processed call.
    //

    DBG_ASSERT( hr == S_OK );

    hr = pControlApiCall->GetReturnCode();


exit:

    if ( pControlApiCall != NULL )
    {
        pControlApiCall->Dereference();
        pControlApiCall = NULL;
    }

    return hr;

}   // CONTROL_API::MarshallCallToMainWorkerThread

/***************************************************************************++

Routine Description:

    Routine will validate that the local system was actually the identity
    of the person who requested this operation.  Since this is an internal interface
    that is exposed to the public through the wamreg stuff, only wamreg should be
    calling us, and he runs as Local System.

    We can not lock this interface down with AccessPermissions because calling
    CoInitializeSecurity overrides the AccessPermission settings on the AppId and
    svchost.exe calls the CoInitializeSecurity for us and does not let us configure
    the parameters to be sent in for our access permissions.

Arguments:

    None.

Return Value:

    Bool

--***************************************************************************/

BOOL 
IsLocalSystemTheCaller()
{

    HRESULT hr = S_OK;
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // We assume we are not being called by local system until
    // we figure out that we are.
    //
    BOOL fIsLocalSystem = FALSE;
    DWORD dwBytesNeeded = 0;

    BUFFER bufSidAtt(20);
    SID_AND_ATTRIBUTES* pSidAtt = NULL;  

    BOOL fImpersonating = FALSE;
    HANDLE ThreadToken = NULL;

    // 
    // Take on the identity of the caller.
    //
    hr = CoImpersonateClient();
    if ( FAILED ( hr ) ) 
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Failed to CoImpersonateClient to check if local system was calling the interface\n"
            ));

        goto exit;
    }

    fImpersonating = TRUE;

    //
    // We were able to become the client.  Now we need to 
    // figure out who that is.
    //
    if ( !OpenThreadToken( GetCurrentThread(),
                            TOKEN_READ,
                            TRUE,
                            &ThreadToken ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(GetLastError()),
            "Failed to open the thread token\n"
            ));

        goto exit;
    }

    if ( !GetTokenInformation( ThreadToken,
                                  TokenUser,
                                  bufSidAtt.QueryPtr(),
                                  bufSidAtt.QuerySize(),
                                  &dwBytesNeeded ) )
    {
        dwErr = GetLastError();

        if ( dwErr == ERROR_INSUFFICIENT_BUFFER )
        {
            DBG_ASSERT ( dwBytesNeeded > bufSidAtt.QuerySize() );

            // Attempt to resize to the correct size if needed
            if ( !bufSidAtt.Resize( dwBytesNeeded ) )
            {
                DPERROR(( 
                    DBG_CONTEXT,
                    HRESULT_FROM_WIN32(GetLastError()),
                    "Failed to allocate space for token information\n"
                    ));

                goto exit;
            }

            // if we don't succeed here, just fail out.
            if ( !GetTokenInformation( ThreadToken,
                                      TokenUser,
                                      bufSidAtt.QueryPtr(),
                                      bufSidAtt.QuerySize(),
                                      &dwBytesNeeded ) )
            {
                DPERROR(( 
                    DBG_CONTEXT,
                    HRESULT_FROM_WIN32(GetLastError()),
                    "Failed to get token information\n"
                    ));

                goto exit;
            }
        }
        else
        {
            //
            // it didn't fail with insufficient buffer so
            // we don't need to resize, but we do need to spew.
            //
            DPERROR(( 
                DBG_CONTEXT,
                HRESULT_FROM_WIN32(GetLastError()),
                "Failed to get token information\n"
                ));

            goto exit;
        }

    }    
        
    pSidAtt = reinterpret_cast<SID_AND_ATTRIBUTES*>(bufSidAtt.QueryPtr());

    DBG_ASSERT ( pSidAtt->Sid != NULL );
    DBG_ASSERT ( GetWebAdminService()->GetLocalSystemSid() != NULL );

    //
    // At this point we should have the sid to compare.
    //
    if ( EqualSid( pSidAtt->Sid, GetWebAdminService()->GetLocalSystemSid() ) )
    {
        fIsLocalSystem = TRUE;
    }

exit:

    // if we openned the thread token, close it.
    if ( ThreadToken != NULL )
    {
        CloseHandle ( ThreadToken );
        ThreadToken = NULL;
    }

    // if we succeeded in impersonating go back to
    // not impersonating.
    if ( fImpersonating )
    {
        hr = CoRevertToSelf();
        if (FAILED(hr))
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Failed to Revert To Self after checking if local system was calling the interface\n"
                ));
        }

    }

    return fIsLocalSystem;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\control_api_class_factory.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    control_api_class_factory.h

Abstract:

    The IIS web admin service control api class factory class definition.

Author:

    Seth Pollack (sethp)        15-Feb-2000

Revision History:

--*/



#ifndef _CONTROL_API_CLASS_FACTORY_H_
#define _CONTROL_API_CLASS_FACTORY_H_



//
// common #defines
//

#define CONTROL_API_CLASS_FACTORY_SIGNATURE         CREATE_SIGNATURE( 'CACF' )
#define CONTROL_API_CLASS_FACTORY_SIGNATURE_FREED   CREATE_SIGNATURE( 'cacX' )



//
// prototypes
//


class CONTROL_API_CLASS_FACTORY
    : public IClassFactory
{

public:

    CONTROL_API_CLASS_FACTORY(
        );

    virtual
    ~CONTROL_API_CLASS_FACTORY(
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    QueryInterface(
        IN REFIID iid,
        OUT VOID ** ppObject
        );

    virtual
    ULONG
    STDMETHODCALLTYPE
    AddRef(
        );

    virtual
    ULONG
    STDMETHODCALLTYPE
    Release(
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    CreateInstance(
        IN IUnknown * pControllingUnknown,
        IN REFIID iid,
        OUT VOID ** ppObject
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    LockServer(
        IN BOOL Lock
        );


private:


    DWORD m_Signature;

    LONG m_RefCount;


};  // class CONTROL_API_CLASS_FACTORY



#endif  // _CONTROL_API_CLASS_FACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\control_api_call.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    control_api_call.cxx

Abstract:

    The IIS web admin service control api call class implementation. 
    This class is used to queue control api calls to the main worker thread.

    Threading: Control api calls arrive on COM threads (i.e., secondary 
    threads), and so instances of this class are created on secondary threads.
    Actual processing of control api calls happens on the main worker thread.

Author:

    Seth Pollack (sethp)        23-Feb-2000

Revision History:

--*/



#include  "precomp.h"



/***************************************************************************++

Routine Description:

    Constructor for the CONTROL_API_CALL class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONTROL_API_CALL::CONTROL_API_CALL(
    )
{

    //
    // Set the initial reference count to 1, in order to represent the
    // reference owned by the creator of this instance.
    //

    m_RefCount = 1;


    m_Event = NULL;


    m_Method = InvalidControlApiCallMethod;

    m_Param0 = 0;
    m_Param1 = 0;
    m_Param2 = 0;
    m_Param3 = 0;

    m_ReturnCode = S_OK;

    m_Signature = CONTROL_API_CALL_SIGNATURE;

}   // CONTROL_API_CALL::CONTROL_API_CALL



/***************************************************************************++

Routine Description:

    Destructor for the CONTROL_API_CALL class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONTROL_API_CALL::~CONTROL_API_CALL(
    )
{

    DBG_ASSERT( m_Signature == CONTROL_API_CALL_SIGNATURE );

    m_Signature = CONTROL_API_CALL_SIGNATURE_FREED;

    DBG_ASSERT( m_RefCount == 0 );


    if ( m_Event != NULL )
    {
        DBG_REQUIRE( CloseHandle( m_Event ) );
        m_Event = NULL;
    }

}   // CONTROL_API_CALL::~CONTROL_API_CALL



/***************************************************************************++

Routine Description:

    Increment the reference count for this object. Note that this method must
    be thread safe, and must not be able to fail.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
CONTROL_API_CALL::Reference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedIncrement( &m_RefCount );


    //
    // The reference count should never have been less than zero; and
    // furthermore once it has hit zero it should never bounce back up;
    // given these conditions, it better be greater than one now.
    //
    
    DBG_ASSERT( NewRefCount > 1 );


    return;

}   // CONTROL_API_CALL::Reference



/***************************************************************************++

Routine Description:

    Decrement the reference count for this object, and cleanup if the count
    hits zero. Note that this method must be thread safe, and must not be
    able to fail.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
CONTROL_API_CALL::Dereference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedDecrement( &m_RefCount );

    // ref count should never go negative
    DBG_ASSERT( NewRefCount >= 0 );

    if ( NewRefCount == 0 )
    {
        // time to go away

        IF_DEBUG( WEB_ADMIN_SERVICE_REFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Reference count has hit zero in CONTROL_API_CALL instance, deleting (ptr: %p)\n",
                this
                ));
        }


        delete this;


    }


    return;

}   // CONTROL_API_CALL::Dereference



/***************************************************************************++

Routine Description:

    Execute a work item on this object.

Arguments:

    pWorkItem - The work item to execute.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONTROL_API_CALL::ExecuteWorkItem(
    IN const WORK_ITEM * pWorkItem
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( pWorkItem != NULL );


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Executing work item with serial number: %lu in CONTROL_API_CALL (ptr: %p) with operation: %p\n",
            pWorkItem->GetSerialNumber(),
            this,
            pWorkItem->GetOpCode()
            ));
    }


    switch ( pWorkItem->GetOpCode() )
    {

    case ProcessCallControlApiCallWorkItem:

        hr = ProcessCall();

        break;

    default:

        // invalid work item!
        DBG_ASSERT( FALSE );

        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;

    }


    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Executing work item on CONTROL_API_CALL failed\n"
            ));

    }


    return hr;

}   // CONTROL_API_CALL::ExecuteWorkItem



/***************************************************************************++

Routine Description:

    Initialize this instance. 

Arguments:

    Method - The method being called. 

    Param0 ... ParamN - The parameter values for the method. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONTROL_API_CALL::Initialize(
    IN CONTROL_API_CALL_METHOD Method,
    IN DWORD_PTR Param0 OPTIONAL,
    IN DWORD_PTR Param1 OPTIONAL,
    IN DWORD_PTR Param2 OPTIONAL,
    IN DWORD_PTR Param3 OPTIONAL
    )
{

    HRESULT hr = S_OK;


    //
    // Create the event used for signalling the calling thread.
    //

    m_Event = CreateEvent(
                    NULL,                   // default security
                    FALSE,                  // auto-reset
                    FALSE,                  // not signalled to start
                    NULL                    // un-named
                    );

    if ( m_Event == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Creating event failed\n"
            ));

        goto exit;
    }


    //
    // Copy parameters.
    //

    m_Method = Method;

    m_Param0 = Param0;
    m_Param1 = Param1;
    m_Param2 = Param2;
    m_Param3 = Param3;


exit:

    return hr;

}   // CONTROL_API_CALL::Initialize



/***************************************************************************++

Routine Description:

    Process a call, once it has been marshalled to the main worker thread. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONTROL_API_CALL::ProcessCall(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    //
    // If we have turned off control operation processing, then bail out.
    //

    if ( ! GetWebAdminService()->GetConfigAndControlManager()->IsChangeProcessingEnabled() )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Ignoring control operation because we are no longer processing them (CONTROL_API_CALL ptr: %p)\n",
                this
                ));
        }

        goto exit;
    }


    switch ( m_Method )
    {

        case ControlSiteControlApiCallMethod:

            hr = GetWebAdminService()->GetUlAndWorkerManager()->
                    ControlSite(
                        ( DWORD ) m_Param0,
                        ( DWORD ) m_Param1,
                        reinterpret_cast<DWORD*> ( m_Param2 )
                        );

        break;

        case QuerySiteStatusControlApiCallMethod:

            hr = GetWebAdminService()->GetUlAndWorkerManager()->
                    QuerySiteStatus(
                        ( DWORD ) m_Param0,
                        reinterpret_cast<DWORD*> ( m_Param1 )
                        );

        break;

        case GetCurrentModeControlApiCallMethod:

            DBG_ASSERT ( m_Param0 );

            if ( GetWebAdminService()->IsBackwardCompatibilityEnabled() )
            {
                // If we are in shared isolation mode we return 0.
                *(DWORD*)m_Param0 = 0;
            }
            else
            {
                // If we are in full isolation mode we return 1.
                *(DWORD*)m_Param0 = 1;
            }

        break;

        case RecycleAppPoolControlApiCallMethod:

            DBG_ASSERT ( m_Param0 );

            hr = GetWebAdminService()->GetUlAndWorkerManager()->
                    RecycleAppPool(
                        ( LPCWSTR ) m_Param0
                        );

        break;

        default:

            // invalid method!
            DBG_ASSERT( FALSE );

            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;

    }


    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Processing control api call failed\n"
            ));

        goto exit;
    }


exit:

    //
    // Capture the return value, to give to the original calling 
    // thread.
    //

    m_ReturnCode = hr;

    hr = S_OK;


    //
    // Signal the original calling thread that the work is done.
    //

    DBG_REQUIRE( SetEvent( GetEvent() ) );


    return hr;

}   // CONTROL_API_CALL::ProcessCall
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\control_api_call.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    control_api_call.h

Abstract:

    The IIS web admin service control api call class definition.

Author:

    Seth Pollack (sethp)        23-Feb-2000

Revision History:

--*/



#ifndef _CONTROL_API_CALL_H_
#define _CONTROL_API_CALL_H_



//
// common #defines
//

#define CONTROL_API_CALL_SIGNATURE          CREATE_SIGNATURE( 'CCAL' )
#define CONTROL_API_CALL_SIGNATURE_FREED    CREATE_SIGNATURE( 'ccaX' )



//
// structs, enums, etc.
//

// CONTROL_API_CALL work items
typedef enum _CONTROL_API_CALL_WORK_ITEM
{

    //
    // Process a configuration change.
    //
    ProcessCallControlApiCallWorkItem = 1,
    
} CONTROL_API_CALL_WORK_ITEM;


// CONTROL_API_CALL methods
typedef enum _CONTROL_API_CALL_METHOD
{

    InvalidControlApiCallMethod,

    ControlSiteControlApiCallMethod,
    QuerySiteStatusControlApiCallMethod,
    GetCurrentModeControlApiCallMethod,
    RecycleAppPoolControlApiCallMethod,

    MaximumControlApiCallMethod,
    
} CONTROL_API_CALL_METHOD;



//
// prototypes
//


class CONTROL_API_CALL
    : public WORK_DISPATCH
{

public:

    CONTROL_API_CALL(
        );

    virtual
    ~CONTROL_API_CALL(
        );

    virtual
    VOID
    Reference(
        );

    virtual
    VOID
    Dereference(
        );

    virtual
    HRESULT
    ExecuteWorkItem(
        IN const WORK_ITEM * pWorkItem
        );

    HRESULT
    Initialize(
        IN CONTROL_API_CALL_METHOD Method,
        IN DWORD_PTR Param0 OPTIONAL,
        IN DWORD_PTR Param1 OPTIONAL,
        IN DWORD_PTR Param2 OPTIONAL,
        IN DWORD_PTR Param3 OPTIONAL
        );

    inline
    HANDLE
    GetEvent(
        )
        const
    { return m_Event; }

    inline
    HRESULT
    GetReturnCode(
        )
        const
    { return m_ReturnCode; }


private:

    HRESULT
    ProcessCall(
        );


    DWORD m_Signature;

    LONG m_RefCount;


    //
    // The COM call blocks on this event.
    //

    HANDLE m_Event;


    //
    // The method and parameters of the call.
    //

    CONTROL_API_CALL_METHOD m_Method;

    DWORD_PTR m_Param0;
    DWORD_PTR m_Param1;
    DWORD_PTR m_Param2;
    DWORD_PTR m_Param3;


    //
    // The return code passed back from the main worker thread.
    //

    HRESULT m_ReturnCode;


};  // class CONTROL_API_CALL



#endif  // _CONTROL_API_CALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\control_api_class_factory.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    control_api_class_factory.cxx

Abstract:

    The IIS web admin service control api class factory class implementation. 
    This class creates instances of the control api.

    Threading: Calls arrive on COM threads (i.e., secondary threads), and 
    are processed directly on those threads.

Author:

    Seth Pollack (sethp)        15-Feb-2000

Revision History:

--*/



#include  "precomp.h"



/***************************************************************************++

Routine Description:

    Constructor for the CONTROL_API_CLASS_FACTORY class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONTROL_API_CLASS_FACTORY::CONTROL_API_CLASS_FACTORY(
    )
{

    //
    // Set the initial reference count to 1, in order to represent the
    // reference owned by the creator of this instance.
    //

    m_RefCount = 1;

    m_Signature = CONTROL_API_CLASS_FACTORY_SIGNATURE;

}   // CONTROL_API_CLASS_FACTORY::CONTROL_API_CLASS_FACTORY



/***************************************************************************++

Routine Description:

    Destructor for the CONTROL_API_CLASS_FACTORY class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONTROL_API_CLASS_FACTORY::~CONTROL_API_CLASS_FACTORY(
    )
{

    DBG_ASSERT( m_Signature == CONTROL_API_CLASS_FACTORY_SIGNATURE );

    m_Signature = CONTROL_API_CLASS_FACTORY_SIGNATURE_FREED;

    DBG_ASSERT( m_RefCount == 0 );


}   // CONTROL_API_CLASS_FACTORY::~CONTROL_API_CLASS_FACTORY



/***************************************************************************++

Routine Description:

    Standard IUnknown::QueryInterface.

Arguments:

    iid - The requested interface id.

    ppObject - The returned interface pointer, or NULL on failure.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CONTROL_API_CLASS_FACTORY::QueryInterface(
    IN REFIID iid,
    OUT VOID ** ppObject
    )
{

    HRESULT hr = S_OK;


    if ( ppObject == NULL )
    {
        hr = E_INVALIDARG;

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "QueryInterface on CONTROL_API_CLASS_FACTORY object failed, bad pointer\n"
            ));

        goto exit;
    }


    if ( iid == IID_IUnknown || iid == IID_IClassFactory )
    {
        *ppObject = reinterpret_cast<IClassFactory*> ( this );

        AddRef();
    }
    else
    {
        *ppObject = NULL;
        
        hr = E_NOINTERFACE;

        //
        // OLE32 will call looking for this interface when we are trying to disconnect
        // clients and shutdown.  It is fine that we do not support it, it will use
        // the standard marshaler's implementation.  We just don't want to spew an
        // error when nothing really went wrong.
        //
        if ( iid != IID_IMarshal )
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "QueryInterface on CONTROL_API_CLASS_FACTORY object failed, IID not supported\n"
            ));
        }

        goto exit;
    }


exit:

    return hr;

}   // CONTROL_API_CLASS_FACTORY::QueryInterface



/***************************************************************************++

Routine Description:

    Standard IUnknown::AddRef.

Arguments:

    None.

Return Value:

    ULONG - The new reference count.

--***************************************************************************/

ULONG
STDMETHODCALLTYPE
CONTROL_API_CLASS_FACTORY::AddRef(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedIncrement( &m_RefCount );


    //
    // The reference count should never have been less than zero; and
    // furthermore once it has hit zero it should never bounce back up;
    // given these conditions, it better be greater than one now.
    //
    
    DBG_ASSERT( NewRefCount > 1 );


    return ( ( ULONG ) NewRefCount );

}   // CONTROL_API_CLASS_FACTORY::AddRef



/***************************************************************************++

Routine Description:

    Standard IUnknown::Release.

Arguments:

    None.

Return Value:

    ULONG - The new reference count.

--***************************************************************************/

ULONG
STDMETHODCALLTYPE
CONTROL_API_CLASS_FACTORY::Release(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedDecrement( &m_RefCount );

    // ref count should never go negative
    DBG_ASSERT( NewRefCount >= 0 );

    if ( NewRefCount == 0 )
    {
        // time to go away

        IF_DEBUG( WEB_ADMIN_SERVICE_REFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Reference count has hit zero in CONTROL_API_CLASS_FACTORY, deleting (ptr: %p)\n",
                this
                ));
        }


        delete this;


    }


    return ( ( ULONG ) NewRefCount );

}   // CONTROL_API_CLASS_FACTORY::Release



/***************************************************************************++

Routine Description:

    Create a new instance of the control api object. 

Arguments:

    pControllingUnknown - The controlling unknown for aggregation. Must be
    NULL.

    iid - The requested interface id.

    ppObject - The returned interface pointer, or NULL on failure.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CONTROL_API_CLASS_FACTORY::CreateInstance(
    IN IUnknown * pControllingUnknown,
    IN REFIID iid,
    OUT VOID ** ppObject
    )
{

    HRESULT hr = S_OK;
    CONTROL_API * pControlApi = NULL;


    DBG_ASSERT( ! ON_MAIN_WORKER_THREAD );


    //
    // Validate and initialize output parameters.
    //

    if ( ppObject == NULL )
    {
        hr = E_INVALIDARG;

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating control api instance failed, bad pointer\n"
            ));

        goto exit;
    }

    *ppObject = NULL;


    if ( pControllingUnknown != NULL )
    {
        hr = CLASS_E_NOAGGREGATION;

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating control api instance failed, aggregation attempted\n"
            ));

        goto exit;
    }


    //
    // Create the instance.
    //

    pControlApi = new CONTROL_API();

    if ( pControlApi == NULL )
    {
        hr = E_OUTOFMEMORY;
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating CONTROL_API failed\n"
            ));

        goto exit;
    }


    //
    // Note that QueryInterface() will add a reference.
    //

    hr = pControlApi->QueryInterface( iid, ppObject );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "QueryInterface on control api instance failed\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_REFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Created new instance of control api object: %p\n",
            *ppObject
            ));
    }


exit:

    //
    // Release our reference.
    //

    if ( pControlApi != NULL )
    {
        pControlApi->Release();
        pControlApi = NULL; 
    }


    return hr;

}   // CONTROL_API_CLASS_FACTORY::CreateInstance



/***************************************************************************++

Routine Description:

    Lock or unlock the class factory.

Arguments:

    Lock - TRUE to lock, FALSE to unlock.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CONTROL_API_CLASS_FACTORY::LockServer(
    IN BOOL Lock
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ! ON_MAIN_WORKER_THREAD );


    if ( Lock )
    {
        AddRef();
    }
    else
    {
        Release();
    }


    return hr;

}   // CONTROL_API_CLASS_FACTORY::LockServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\ipm_io_s.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    ipm_io_s.cxx

Abstract:

    The IIS web admin service implementation of the IPM
    i/o abstraction layer.

Author:

    Michael Courage (MCourage)      28-Feb-1999

Revision History:

--*/

#include "precomp.h"

/***************************************************************************++

Routine Description:

    Creates an i/o handler
    
Arguments:

    hPipe           - A handle to the named pipe to be handled
    ppPipeIoHandler - receives a pointer to the handler on success
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IO_FACTORY_S::CreatePipeIoHandler(
    IN  HANDLE             hPipe,
    OUT PIPE_IO_HANDLER ** ppPipeIoHandler
    )
{
    HRESULT        hr = S_OK;
    IO_HANDLER_S * pHandler;

    //
    // create the object
    //

    pHandler = new IO_HANDLER_S(hPipe);


    if (pHandler) {
        //
        // first reference keeps object alive
        //
        pHandler->Reference();
        
        //
        // bind handle to completion port
        //
        hr = GetWebAdminService()->GetWorkQueue()->
                    BindHandleToCompletionPort( 
                        hPipe, 
                        0
                        );

        if (SUCCEEDED(hr)) {
            *ppPipeIoHandler = pHandler;
            InterlockedIncrement(&m_cPipes);

            IF_DEBUG( WEB_ADMIN_SERVICE_IPM ) {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "Created IO_HANDLER_S (%x) - m_cPipes = %d\n",
                    pHandler,
                    m_cPipes
                    ));
            }
        } else {
            //
            // get rid of object
            //
            pHandler->Dereference();
        }
    } else {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    return hr;
}


/***************************************************************************++

Routine Description:

    Closes an i/o handler
    
Arguments:

    pPipeIoHandler - pointer to the handler to be closed
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IO_FACTORY_S::ClosePipeIoHandler(
    IN PIPE_IO_HANDLER * pPipeIoHandler
    )
{
    IO_HANDLER_S * pHandler = (IO_HANDLER_S *) pPipeIoHandler;

    if (pPipeIoHandler) {
        InterlockedDecrement(&m_cPipes);
        pHandler->Dereference();

        IF_DEBUG( WEB_ADMIN_SERVICE_IPM ) {
            DBGPRINTF((
                DBG_CONTEXT,
                "Closed IO_HANDLER_S (%x) - m_cPipes = %d\n",
                pPipeIoHandler,
                m_cPipes
                ));
        }

        return S_OK;
    } else {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
}


/***************************************************************************++

Routine Description:

    Connects the pipe to a client
    
Arguments:

    pContext - the context to be notified on completion
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IO_HANDLER_S::Connect(
    IN IO_CONTEXT * pContext,
    IN PVOID        pv
    )
{
    HRESULT        hr = S_OK;
    DWORD          dwConnectError;
    IO_CONTEXT_S * pIoContext;
    WORK_ITEM *    pWorkItem;

    //
    // create a context
    //
    pIoContext = new IO_CONTEXT_S;
    if (pIoContext) {
        pIoContext->m_pContext = pContext;
        pIoContext->m_pv       = pv;
        pIoContext->m_IoType   = IPM_IO_CONNECT;

        //
        // create a WORK_ITEM
        //
        hr = GetWebAdminService()->GetWorkQueue()->GetBlankWorkItem(
                    &pWorkItem
                    );

        if (SUCCEEDED(hr)) {
            pWorkItem->SetOpCode((ULONG_PTR) pIoContext);
            pWorkItem->SetWorkDispatchPointer(this);


            IF_DEBUG( WEB_ADMIN_SERVICE_IPM )
            {
                DBGPRINTF((
                    DBG_CONTEXT, 
                    "About to issue named pipe connect i/o using work item with serial number: %li\n",
                    pWorkItem->GetSerialNumber()
                    ));
            }


            //
            // write to the pipe
            //
            if (!ConnectNamedPipe(
                        GetHandle(),
                        pWorkItem->GetOverlapped()
                        ))
            {
                dwConnectError = GetLastError();

                if (dwConnectError == ERROR_PIPE_CONNECTED) {
                    // the call succeeded inline. Execute the work item now.
                    GetWebAdminService()->GetWorkQueue()->QueueWorkItem(pWorkItem);
                    
                } else if (dwConnectError != ERROR_IO_PENDING) {
                    hr = HRESULT_FROM_WIN32(dwConnectError);

                    GetWebAdminService()->GetWorkQueue()->FreeWorkItem(
                        pWorkItem
                        );
                }
            }
        }
    } else {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    if (FAILED(hr)) {
        delete pIoContext;
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_IPM ) {
        DBGPRINTF((
            DBG_CONTEXT,
            "IO_HANDLER_S::Connect (%x) - hr = %x, pv = %x\n",
            this,
            hr,
            pv
            ));
    }

    return hr;

}


/***************************************************************************++

Routine Description:

    Disconnects the named pipe
    
Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IO_HANDLER_S::Disconnect(
    VOID
    )
{
    HRESULT hr = S_OK;

    if (!CloseHandle(GetHandle())) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_IPM ) {
    DBGPRINTF((
        DBG_CONTEXT,
        "IO_HANDLER_S::Disconnect (%x) - hr = %x\n",
        this,
        hr
        ));
    }

    return hr;
}


/***************************************************************************++

Routine Description:

    Writes data to the pipe
    
Arguments:

    pContext - the context to be notified on completion
    pv       - a parameter passed to the context
    pBuff    - the data to send
    cbBuff   - number of bytes in the data
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IO_HANDLER_S::Write(
    IN IO_CONTEXT * pContext,
    IN PVOID        pv,
    IN const BYTE * pBuff,
    IN DWORD        cbBuff
    )
{
    HRESULT        hr = S_OK;
    IO_CONTEXT_S * pIoContext;
    WORK_ITEM *    pWorkItem;

    //
    // create a context
    //
    pIoContext = new IO_CONTEXT_S;
    if (pIoContext) {
        pIoContext->m_pContext = pContext;
        pIoContext->m_pv       = pv;
        pIoContext->m_IoType   = IPM_IO_WRITE;

        //
        // create a WORK_ITEM
        //
        hr = GetWebAdminService()->GetWorkQueue()->GetBlankWorkItem(
                    &pWorkItem
                    );

        if (SUCCEEDED(hr)) {
            pWorkItem->SetOpCode((ULONG_PTR) pIoContext);
            pWorkItem->SetWorkDispatchPointer(this);


            IF_DEBUG( WEB_ADMIN_SERVICE_IPM )
            {
                DBGPRINTF((
                    DBG_CONTEXT, 
                    "About to issue %d byte named pipe write i/o using work item with serial number: %li\n",
                    cbBuff,
                    pWorkItem->GetSerialNumber()
                    ));
            }


            //
            // write to the pipe
            //
            hr = IpmWriteFile(
                        GetHandle(),
                        (PVOID) pBuff,
                        cbBuff,
                        pWorkItem->GetOverlapped()
                        );
            
            if (FAILED(hr))
            {
                GetWebAdminService()->GetWorkQueue()->FreeWorkItem(
                    pWorkItem
                    );
            }
        }
    } else {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    if (FAILED(hr)) {
        delete pIoContext;
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_IPM ) {
        DBGPRINTF((
            DBG_CONTEXT,
            "IO_HANDLER_S::Write (%x) - hr = %x\n",
            this,
            hr
            ));
    }

    return hr;
}


/***************************************************************************++

Routine Description:

    Reads data from the pipe
    
Arguments:

    pContext - the context to be notified on completion
    pv       - a parameter passed to the context
    pBuff    - the buffer that receives the data
    cbBuff   - size of the buffer
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IO_HANDLER_S::Read(
    IN IO_CONTEXT * pContext,
    IN PVOID        pv,
    IN BYTE *       pBuff,
    IN DWORD        cbBuff
    )
{
    HRESULT        hr = S_OK;
    IO_CONTEXT_S * pIoContext;
    WORK_ITEM *    pWorkItem;

    //
    // create a context
    //
    pIoContext = new IO_CONTEXT_S;
    if (pIoContext) {
        pIoContext->m_pContext = pContext;
        pIoContext->m_pv       = pv;
        pIoContext->m_IoType   = IPM_IO_READ;

        //
        // create a WORK_ITEM
        //
        hr = GetWebAdminService()->GetWorkQueue()->GetBlankWorkItem(
                    &pWorkItem
                    );

        if (SUCCEEDED(hr)) {
            pWorkItem->SetOpCode((ULONG_PTR) pIoContext);
            pWorkItem->SetWorkDispatchPointer(this);


            IF_DEBUG( WEB_ADMIN_SERVICE_IPM )
            {
                DBGPRINTF((
                    DBG_CONTEXT, 
                    "About to issue named pipe read i/o using work item with serial number: %li\n",
                    pWorkItem->GetSerialNumber()
                    ));
            }


            //
            // read from the pipe
            //
            hr = IpmReadFile(
                        GetHandle(),
                        (PVOID) pBuff,
                        cbBuff,
                        pWorkItem->GetOverlapped()
                        );
            
            if (FAILED(hr))
            {
                GetWebAdminService()->GetWorkQueue()->FreeWorkItem(
                    pWorkItem
                    );
            }
        }
    } else {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    if (FAILED(hr)) {
        delete pIoContext;
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_IPM ) {
        DBGPRINTF((
            DBG_CONTEXT,
            "IO_HANDLER_S::Read (%x) - hr = %x\n",
            this,
            hr
            ));
    }
    
    return hr;
}


/***************************************************************************++

Routine Description:

    Handles I/O completions from the completion port
    
Arguments:

    pWorkItem - I/O context object
    
Return Value:

    HRESULT
    
--***************************************************************************/
HRESULT
IO_HANDLER_S::ExecuteWorkItem(
    IN const WORK_ITEM * pWorkItem
    )
{
    IO_CONTEXT_S * pIoContext;
    HRESULT        hrIo;
    DWORD          cbIo;
    HRESULT        hr;

    //
    // get the context object
    //
    pIoContext = (IO_CONTEXT_S *) pWorkItem->GetOpCode();
    DBG_ASSERT( pIoContext->m_dwSignature == IO_CONTEXT_S_SIGNATURE );

    hrIo = pWorkItem->GetIoError();
    cbIo = pWorkItem->GetNumberOfBytesTransferred();


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Executing work item with serial number: %lu in IO_HANDLER_S: %p with IO_CONTEXT_S: %p with operation: %lu - %d %x\n",
            pWorkItem->GetSerialNumber(),
            this,
            pIoContext,
            pIoContext->m_IoType,
            cbIo,
            hrIo
            ));
    }


    //
    // do the notification
    //
    switch (pIoContext->m_IoType) {
    case IPM_IO_WRITE:
        hr = pIoContext->m_pContext->NotifyWriteCompletion(
            pIoContext->m_pv,
            cbIo,
            hrIo
            );
        break;

    case IPM_IO_READ:
        hr = pIoContext->m_pContext->NotifyReadCompletion(
            pIoContext->m_pv,
            cbIo,
            hrIo
            );
        break;

    case IPM_IO_CONNECT:
        hr = pIoContext->m_pContext->NotifyConnectCompletion(
                    pIoContext->m_pv,
                    cbIo,
                    hrIo
                    );
        break;

    default:
        hr = E_FAIL;
        DBG_ASSERT(FALSE);
        break;
    }

    delete pIoContext;


    //
    // Note: any errors in executing work items for named pipe operations 
    // are handled by IPM notifying the worker process's messaging handler 
    // of a failure, which then kicks off localized handling of the problem. 
    // However, none of these errors are considered service fatal, so we 
    // don't want to bubble up errors any further. Therefore, return S_OK.
    //

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Executing IPM work item failed; pressing on...\n"
            ));

        hr = S_OK;
    }


    return hr;
}



/***************************************************************************++

Routine Description:

    Increments the reference count.
    
Arguments:

    None.
    
Return Value:

    None.
    
--***************************************************************************/
VOID
IO_HANDLER_S::Reference(
    VOID
    )
{
    InterlockedIncrement(&m_cRefs);
}


/***************************************************************************++

Routine Description:

    Decrements the reference count. Deletes object when count
    hits zero.
    
Arguments:

    None.
    
Return Value:

    None.
    
--***************************************************************************/
VOID
IO_HANDLER_S::Dereference(
    VOID
    )
{
    LONG cRefs = InterlockedDecrement(&m_cRefs);

    if (!cRefs) {
        IF_DEBUG( WEB_ADMIN_SERVICE_REFCOUNT ) {
            DBGPRINTF((
                DBG_CONTEXT,
                "Deleting IO_HANDLER_S (%x)\n",
                this
                ));
        }

        delete this;
    }
}

//
// end of ipm_io_s.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\job_object.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    job_object.cxx

Abstract:

    This class encapsulates a single job object. 

    Threading: For the class itself, Reference(), Dereference(), and the
    destructor may be called on any thread; all other work is done on the 
    main worker thread.

Author:

    Emily Kruglick (EmilyK)    30-Nov-2000

Revision History:

--*/

#include "precomp.h"


//
// local prototypes
//

//
// Callback function that lets us know
// when the job object interval has expired
// so we can reset the job object.
//
VOID
JobObjectTimerCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    );


/***************************************************************************++

Routine Description:

    Constructor for the JOB_OBJECT class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

JOB_OBJECT::JOB_OBJECT(
    )
{

    //
    // Set the initial reference count to 1, in order to represent the
    // reference owned by the creator of this instance.
    //

    m_RefCount = 1;

    m_pAppPool = NULL;

    m_hJobObject = NULL;

    m_JobObjectTimerHandle = NULL;

    m_pWorkItem = NULL;

    m_State = NotInitalizedJobObjectState; 

    m_Signature = JOB_OBJECT_SIGNATURE;

}   // JOB_OBJECT::JOB_OBJECT



/***************************************************************************++

Routine Description:

    Destructor for the JOB_OBJECT class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

JOB_OBJECT::~JOB_OBJECT(
    )
{

    DBG_ASSERT( m_Signature == JOB_OBJECT_SIGNATURE );

    m_Signature = JOB_OBJECT_SIGNATURE_FREED;

    DBG_ASSERT( m_RefCount == 0 );

    //
    // The app pool should of been Dereferenced in the shutdown call,
    // and should now be NULL.
    //
    DBG_ASSERT ( m_pAppPool == NULL );

    DBG_ASSERT ( m_hJobObject == NULL );

    DBG_ASSERT( m_State == NotInitalizedJobObjectState );

    DBG_ASSERT ( m_JobObjectTimerHandle == NULL );

    DBG_ASSERT ( m_pWorkItem == NULL );

}   // JOB_OBJECT::~JOB_OBJECT



/***************************************************************************++

Routine Description:

    Increment the reference count for this object. Note that this method must 
    be thread safe, and must not be able to fail. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
JOB_OBJECT::Reference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedIncrement( &m_RefCount );


    // 
    // The reference count should never have been less than zero; and
    // furthermore once it has hit zero it should never bounce back up;
    // given these conditions, it better be greater than one now.
    //
    
    DBG_ASSERT( NewRefCount > 1 );


    return;

}   // JOB_OBJECT::Reference



/***************************************************************************++

Routine Description:

    Decrement the reference count for this object, and cleanup if the count 
    hits zero. Note that this method must be thread safe, and must not be
    able to fail. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
JOB_OBJECT::Dereference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedDecrement( &m_RefCount );

    // ref count should never go negative
    DBG_ASSERT( NewRefCount >= 0 );

    if ( NewRefCount == 0 )
    {
        // time to go away

        IF_DEBUG( WEB_ADMIN_SERVICE_REFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Reference count has hit zero in JOB_OBJECT instance, deleting (ptr: %p;)\n",
                this
                ));
        }


        delete this;


    }
    

    return;
    
}   // JOB_OBJECT::Dereference



/***************************************************************************++

Routine Description:

    Execute a work item on this object.

Arguments:

    pWorkItem - The work item to execute.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
JOB_OBJECT::ExecuteWorkItem(
    IN const WORK_ITEM * pWorkItem
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );
    DBG_ASSERT( GetWebAdminService()->IsBackwardCompatibilityEnabled() == FALSE );

    DBG_ASSERT( pWorkItem != NULL );


    IF_DEBUG( WEB_ADMIN_SERVICE_QOS )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Executing work item with serial number: %lu in JOB_OBJECT (ptr: %p) with operation: %p\n",
            pWorkItem->GetSerialNumber(),
            this,
            pWorkItem->GetOpCode()
            ));
    }


    switch ( pWorkItem->GetOpCode() )
    {

        case JobObjectHitLimitWorkItem:

            //
            // We only care about when the worker processes user mode processor time hits
            // the limit we set.  There are several other times that the job objects will 
            // answer back, but we can ignore them.
            //
            // It should also be noted that the job objects store their message id in the
            // size of bytes transferred through the completion port.
            //

            if ( pWorkItem->GetNumberOfBytesTransferred() == 
                                JOB_OBJECT_MSG_END_OF_JOB_TIME )
            {
                hr = ProcessLimitHit();
            }

        break;

        case JobObjectResetTimerFiredWorkItem:
            hr = ProcessTimerFire();
        break;

        case ReleaseWorkItemJobObjectWorkItem:
            hr = ReleaseWorkItem();
        break;

        default:

            // invalid work item!
            DBG_ASSERT( FALSE );
        
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;
        
    }


    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Executing work item on APP_POOL failed\n"
            ));

    }


    return hr;
    
}   // JOB_OBJECT::ExecuteWorkItem



/***************************************************************************++

Routine Description:

    Initialize the job object instance.

Arguments:

    pAppPool - will be refcounted by the app pool when it is passed in to the 
               job object.  will be released by the job object on terminate.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
JOB_OBJECT::Initialize(
    IN APP_POOL* pAppPool
    )
{
    HRESULT hr = S_OK;

    DBG_ASSERT ( pAppPool );
    WORK_ITEM* pWorkItem = NULL; 


    // Grab the app pool and ref count it.
    m_pAppPool = pAppPool;
    m_pAppPool->Reference();

    DBG_ASSERT ( m_pWorkItem == NULL );
    hr = GetWebAdminService()->GetWorkQueue()->GetBlankWorkItem( &m_pWorkItem );
    if ( FAILED( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not create a work item for the job object\n"
            ));

        goto exit;
    }


    //
    // Setup the work dispatch pointer to point to the JOB_OBJECT
    // so we can handle any limits that are hit.
    //
    m_pWorkItem->SetWorkDispatchPointer(this);
    m_pWorkItem->SetOpCode( ( ULONG_PTR ) JobObjectHitLimitWorkItem );
    
    //
    // If shutdown happens before a callback comes in, we will 
    // never get a callback on this work item.
    //
    m_pWorkItem->MarkToNotAutoDelete();

    DBG_ASSERT ( m_hJobObject == NULL );

    m_hJobObject = CreateJobObject( NULL,   // use default security descriptor
                                    NULL ); // don't name the job object.

    if ( m_hJobObject == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating the job object for the app pool failed\n"
            ));

        // Issue, should we log an event and disable job objects?
        
        goto exit;
    }

    // since we are not naming the job object, we should never
    // get a job object that all ready exists.
    DBG_ASSERT ( GetLastError () != ERROR_ALREADY_EXISTS );

    hr = GetWebAdminService()->GetWorkQueue()->
         BindJobToCompletionPort ( m_hJobObject,
                                   m_pWorkItem->GetOverlapped());
    if ( FAILED ( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Binding the job object to the completion port failed\n"
            ));


        goto exit;
    }

    JOBOBJECT_END_OF_JOB_TIME_INFORMATION JobAction;
    
    JobAction.EndOfJobTimeAction = JOB_OBJECT_POST_AT_END_OF_JOB; 
    if ( !SetInformationJobObject( m_hJobObject, 
                                   JobObjectEndOfJobTimeInformation, 
                                   &JobAction,
                                   sizeof ( JobAction ) ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "setting the job action failed\n"
            ));
    
        goto exit;
    }

    m_State = DisabledJobObjectState;

exit:

    IF_DEBUG( WEB_ADMIN_SERVICE_QOS )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Initializing of the job object is returning %08x \n"
            "work_item %08x, job_object %08x\n",
            hr,
            m_pWorkItem ? m_pWorkItem : NULL,
            this
            ));
    }

    //
    // If we fail on any of the above pieces, the 
    // terminate routine will handle the cleanup.
    //
    // Need to verify that it will be called
    // and that the queueing to release the work
    // item will work.

    return hr;
    
}   // JOB_OBJECT::Initialize

/***************************************************************************++

Routine Description:

    Adds a worker process to the job object.

Arguments:

    hWorkerProcess = The worker process to add to the object.

Return Value:

    HRESULT

Note:  We don't remove worker processes from the job object because we assume
       that the worker process will be removed when it is shutdown.

--***************************************************************************/

HRESULT
JOB_OBJECT::AddWorkerProcess(
    IN HANDLE hWorkerProcess
    )
{
    HRESULT hr = S_OK;

    DBG_ASSERT ( hWorkerProcess );

    DBG_ASSERT ( m_hJobObject );

    if ( !AssignProcessToJobObject( m_hJobObject, hWorkerProcess ) )
    {
        //
        // Issue:  If the wp exits to quickly this may fail because the
        //         worker process does not exist anymore.  In this case
        //         this is actually not a failure.
        //

        hr = HRESULT_FROM_WIN32( GetLastError() );
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Adding a worker process to the job object failed\n"
            ));
        
        goto exit;
    }

exit:

    IF_DEBUG( WEB_ADMIN_SERVICE_QOS )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Adding a worker process to the Job Object is returning %08x\n",
            hr
            ));
    }

    return hr;
    
}   // JOB_OBJECT::AddWorkerProcess


/***************************************************************************++

Routine Description:

    Terminates the job object

Arguments:

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
JOB_OBJECT::Terminate(
    )
{
    m_State = ShuttingDownJobObjectState;

    if ( m_pAppPool )
    {
        m_pAppPool->Dereference();
        m_pAppPool = NULL;
    }
    
    // If we are in the middle of timing the job 
    // object we need to cancel the timer now.
    CancelJobObjectTimer();

    if ( m_hJobObject ) 
    {
        CloseHandle( m_hJobObject );
        m_hJobObject = NULL;
    }

    //
    // Mark the queue so we know when we are guaranteed to not
    // get anymore completions for the work item we own.
    //
    QueueWorkItemFromSecondaryThread( (WORK_DISPATCH*) this,
                                      ReleaseWorkItemJobObjectWorkItem );                                     


    IF_DEBUG( WEB_ADMIN_SERVICE_QOS )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Termination of the job object is complete.\n"
            ));
    }


    return S_OK;
    
}   // JOB_OBJECT::Terminate


/***************************************************************************++

Routine Description:

    Sets a set of configuration information for the job object as it 
    relates to the app pool that it belongs to.

Arguments:

    DWORD CpuResetInterval = The amount of time to monitor over.  If the limit
                             hits this value minues the amount of time that has passed
                             for this monitoring session equals the amount of time 
                             that we wait before resetting the monitoring and possibly
                             preforming the action again (assuming the action was not
                             recycling everything).

    DWORD CpuLimit = The amount of processor time the processes can use over the 
                     amount of time defined by the CpuResetInterval.

    DWORD CpuAction = The action to be performed when the limit is reached.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
JOB_OBJECT::SetConfiguration(
    IN DWORD CpuResetInterval,
    IN DWORD CpuLimit,
    IN DWORD CpuAction
    )
{
    HRESULT hr = S_OK;

    //
    // Save the values away.
    //
    m_CpuResetInterval = CpuResetInterval;
    m_CpuLimit = CpuLimit;
    m_CpuAction = CpuAction;

    hr = UpdateJobObjectMonitoring();
    if ( FAILED (hr) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "updating the job object monitoring failed\n"
            ));
    
        goto exit;
    }

exit:
    return hr;

}   // JOB_OBJECT::SetConfiguration

/***************************************************************************++

Routine Description:

    Updates the job object with the current monitoring information.

Arguments:

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
JOB_OBJECT::UpdateJobObjectMonitoring(
    )
{
    HRESULT hr = S_OK;


    DBG_ASSERT ( m_State != NotInitalizedJobObjectState && 
                 m_State != ShuttingDownJobObjectState );

    DBG_ASSERT ( m_pAppPool );

    //
    // Cancel the job object timer before updating 
    // the job object, because the update will start
    // another timer if need be.
    //
    CancelJobObjectTimer();

    // if we disabled the app pool during this last time limit
    // we need to enable the app pool now.  This means that if
    // the configuration changes on a job object that has fired
    // we will pick start the app pool back up when the config
    // changes
    if ( m_State == KillActionFiredJobObjectState )
    {
        hr = m_pAppPool->ProcessStateChangeCommand( MD_APPPOOL_COMMAND_START , FALSE );
        if ( FAILED ( hr ) )
        {
            const WCHAR * EventLogStrings[1];

            EventLogStrings[0] = m_pAppPool->GetAppPoolId();

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_APP_POOL_ENABLE_FAILED,       // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    hr                                       // error code
                    );
        }
        
    }

    //
    // in case we don't set it to monitor.
    m_State = DisabledJobObjectState;

    // llJobLimit is in 100-nanoseconds.

    // CpuLimit is in 1/1000th percent (in other words divide CpuResetInterval by 100,000).
    // CpuResetInterval is in Minutes.
    //
    // The calculation:
    //
    // CpuResetInterval * CpuLimit / 100,000  gives you the amount of minutes of job time.
    // 
    // Now multiply that by:
    //        60 (to get it in seconds)
    //      1000 (to get in in milliseconds)
    //      1000 (to get it in microseconds)
    //      10 (to get in in 100-nanoseconds  (1000 nanoseconds / 100 nanoseconds)
    //
    //
    // All this simplifies out to CpuLimit * CpuResetInterval * 6000.
    //
    // Issue:  Are we looking at overflow problems??

    LONGLONG llJobLimit = m_CpuLimit * m_CpuResetInterval * 6000;

    JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;

    // If the properties are equal to zero then we will simply turn this puppy off
    // by not setting the job limit.

    memset ( &BasicLimitInformation, 0, sizeof ( BasicLimitInformation ) );

    //
    // If the Job Limit is set to zero then we still configure the server
    // because we need to tell it not to monitor the Job Time at all.  In 
    // other words we need to configure it to have LimitFlags = 0.
    //
    if ( llJobLimit > 0 )
    {
        BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_JOB_TIME;

        BasicLimitInformation.PerJobUserTimeLimit.QuadPart = llJobLimit;
    }

    if ( !SetInformationJobObject( m_hJobObject, 
                                   JobObjectBasicLimitInformation, 
                                   &BasicLimitInformation,
                                   sizeof ( BasicLimitInformation ) ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "setting the limit on the job object failed\n"
            ));
    
        goto exit;
    }


    //
    // If we did set a job limit then we need to start a timer
    //
    if ( llJobLimit > 0 )
    {
        m_State = RunningJobObjectState;

        hr = BeginJobObjectTimer();
        if ( FAILED ( hr ) )
        {
            // We are not timing the object, chances are the limit
            // will eventually get hit.

            // The BeginJobObjectTimer has all ready spewed the error.
            goto exit;

        }
    }


exit:

    IF_DEBUG( WEB_ADMIN_SERVICE_QOS )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Updating the job limit is returning %08x\n",
            hr
            ));
    }

    return hr;

}   // JOB_OBJECT::UpdateJobObjectMonitoring

/***************************************************************************++

Routine Description:

    Handles performing the appropriate action when a job object hits it's limit.
    This will also resetup monitoring if need be.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
JOB_OBJECT::ProcessLimitHit(
    )
{
    //
    // Make sure we don't attempt to log if we have all ready 
    // released the app pool.
    if ( m_State != RunningJobObjectState || m_pAppPool == NULL )
    {
        return S_OK;
    }

    m_State = HitConstraintJobObjectState;

    const WCHAR * EventLogStrings[1];

    EventLogStrings[0] = m_pAppPool->GetAppPoolId();

    GetWebAdminService()->GetEventLog()->
        LogEvent(
            WAS_EVENT_JOB_LIMIT_HIT,       // message id
            sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                    // count of strings
            EventLogStrings,                        // array of strings
            0                                       // error code
            );

    if ( m_CpuAction == KillJobObjectAction )
    {
        m_State = KillActionFiredJobObjectState;

        HRESULT hr = m_pAppPool->ProcessStateChangeCommand( MD_APPPOOL_COMMAND_STOP 
                                                          , FALSE );
        if ( FAILED ( hr ) )
        {
            const WCHAR * EventLogStrings[1];

            EventLogStrings[0] = m_pAppPool->GetAppPoolId();

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_APP_POOL_DISABLE_FAILED,       // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    hr                                       // error code
                    );
        }

    }

    return S_OK;
}

/***************************************************************************++

Routine Description:

    Handles the resetting the job object monitoring since the amount
    of time to monitor over has been hit.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
JOB_OBJECT::ProcessTimerFire(
    )
{
    //
    // Tell the job object about the limit again to refresh it.
    //
    return UpdateJobObjectMonitoring();
}

/***************************************************************************++

Routine Description:

    Lets go of the work item we are holding for the life of this object.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
JOB_OBJECT::ReleaseWorkItem(
    )
{
    WORK_ITEM* pTemp = m_pWorkItem;

    DBG_ASSERT ( ShuttingDownJobObjectState == m_State );

    //
    // If we have a work item we can safely release it now
    // because we have verified that the job object will not
    // be using it.
    //
    // The work item may hold the last refernce on the job object
    // so be ready for the job object to go away.
    //
    m_pWorkItem = NULL;
    m_State = NotInitalizedJobObjectState;

    if ( pTemp ) 
    {
        GetWebAdminService()->GetWorkQueue()->FreeWorkItem( pTemp );
    }


    return S_OK;
}

/***************************************************************************++

Routine Description:

    Start a timer to monitor the length of time the job object has to monitor
    before the limit should be reset.

Arguments:

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
JOB_OBJECT::BeginJobObjectTimer(
    )
{

    HRESULT hr = S_OK;
    NTSTATUS Status = STATUS_SUCCESS;


    DBG_ASSERT( GetWebAdminService()->GetSharedTimerQueue() != NULL );

    DBG_ASSERT( m_JobObjectTimerHandle == NULL );

    IF_DEBUG( WEB_ADMIN_SERVICE_QOS )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Beginning job object timer\n"
            ));
    }

    Status = RtlCreateTimer(
                    GetWebAdminService()->GetSharedTimerQueue(),
                                                                        // timer queue
                    &m_JobObjectTimerHandle,                            // returned timer handle
                    JobObjectTimerCallback,                             // callback function
                    this,                                               // context
                    m_CpuResetInterval * ONE_MINUTE_IN_MILLISECONDS,    // initial firing time
                    0,                                      // subsequent firing period
                    WT_EXECUTEINWAITTHREAD                  // execute callback directly
                    );

    if ( ! NT_SUCCESS ( Status ) )
    {
        hr = HRESULT_FROM_NT( Status );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not create job object timer\n"
            ));

    }

    return hr;

}   // JOB_OBJECT::BeginJobObjectTimer


/***************************************************************************++

Routine Description:

    Stop the job object timer, if present

Arguments:

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
JOB_OBJECT::CancelJobObjectTimer(
    )
{

    HRESULT hr = S_OK;
    NTSTATUS Status = STATUS_SUCCESS;


    DBG_ASSERT( GetWebAdminService()->GetSharedTimerQueue() != NULL );


    //
    // If the timer is not present, we're done here.
    //

    if ( m_JobObjectTimerHandle == NULL )
    {
        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Cancelling job object timer\n"
            ));
    }


    //
    // Note that we wait for any running timer callbacks to finish.
    //

    Status = RtlDeleteTimer(
                    GetWebAdminService()->GetSharedTimerQueue(),
                                                          // the owning timer queue
                    m_JobObjectTimerHandle,             // timer to cancel
                    INVALID_HANDLE_VALUE                  // wait for callbacks to finish
                    );

    if ( ! NT_SUCCESS ( Status ) )
    {
        hr = HRESULT_FROM_NT( Status );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not cancel job object timer\n"
            ));

        goto exit;
    }

    m_JobObjectTimerHandle = NULL;


exit:

    return hr;

}   // JOB_OBJECT::CancelJobObjectTimer

/***************************************************************************++

Routine Description:

    The callback function let's us know when the reset interval 
    for the job limit has been exceeded.  Whether or not we have 
    hit the limit, we need to reset the job object.

Arguments:

    Context - A context value, used to pass the "this" pointer of the
    JOB_OBJECT object.

    Ignored - Ignored.

Return Value:

    None.

--***************************************************************************/

VOID
JobObjectTimerCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    )
{

    UNREFERENCED_PARAMETER( Ignored );

    DBG_ASSERT ( Context != NULL );

    JOB_OBJECT* pJobObject = reinterpret_cast<JOB_OBJECT*>( Context );

    DBG_ASSERT ( pJobObject->CheckSignature() );

    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "About to create/queue work item for Job "
            "Object limit to be reset (ptr: %p)\n",
            pJobObject
            ));
    }


    QueueWorkItemFromSecondaryThread(
        reinterpret_cast<WORK_DISPATCH*>( Context ),
        JobObjectResetTimerFiredWorkItem
        );


    return;

}   // PerfCounterTimerCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\ipm_io_s.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    ipm_io_s.h

Abstract:

    The IIS web admin service header for the IPM i/o abstraction layer.

Author:

    Michael Courage (MCourage)      28-Feb-1999

Revision History:

--*/


#ifndef _IPM_IO_S_H_
#define _IPM_IO_S_H_

class IO_FACTORY_S
    : public IO_FACTORY
{
public:
    IO_FACTORY_S(
        VOID
        ) : m_cPipes(0)
    {}
    
    virtual
    ~IO_FACTORY_S(
        VOID
        )
    { DBG_ASSERT(m_cPipes == 0); }

    virtual
    HRESULT
    CreatePipeIoHandler(
        IN  HANDLE             hPipe,
        OUT PIPE_IO_HANDLER ** ppPipeIoHandler
        );

    virtual
    HRESULT
    ClosePipeIoHandler(
        IN PIPE_IO_HANDLER * pPipeIoHandler
        );

private:
    LONG              m_cPipes;
};


class IO_HANDLER_S
    : public PIPE_IO_HANDLER,
      public WORK_DISPATCH
{
public:
    IO_HANDLER_S(
        IN HANDLE hPipe
        ) : PIPE_IO_HANDLER(hPipe)
    { m_cRefs = 0; }

    virtual
    ~IO_HANDLER_S(
        VOID
        )
    { }

    //
    // PIPE_IO_HANDLER methods
    //
    
    virtual
    HRESULT
    Connect(
        IN IO_CONTEXT * pContext,
        IN PVOID        pv
        );

    virtual
    HRESULT
    Disconnect(
        VOID
        );

    virtual
    HRESULT
    Write(
        IN IO_CONTEXT * pContext,
        IN PVOID        pv,
        IN const BYTE * pBuff,
        IN DWORD        cbBuff
        );

    virtual
    HRESULT
    Read(
        IN IO_CONTEXT * pContext,
        IN PVOID        pv,
        IN BYTE       * pBuff,
        IN DWORD        cbBuff
        );


    //
    // WORK_DISPATCH methods
    //
    virtual
    VOID
    Reference(
        );

    virtual
    VOID
    Dereference(
        );

    virtual
    HRESULT
    ExecuteWorkItem(
        IN const WORK_ITEM * pWorkItem
        );

private:
    LONG m_cRefs;
};

enum IPM_IO_TYPE_S {
    IPM_IO_READ,
    IPM_IO_WRITE,
    IPM_IO_CONNECT
};

#define IO_CONTEXT_S_SIGNATURE          CREATE_SIGNATURE( 'IOCS' )
#define IO_CONTEXT_S_SIGNATURE_FREED    CREATE_SIGNATURE( 'xios' )
typedef struct _IO_CONTEXT_S
{
    _IO_CONTEXT_S()
    { m_dwSignature = IO_CONTEXT_S_SIGNATURE; }

    ~_IO_CONTEXT_S()
    { m_dwSignature = IO_CONTEXT_S_SIGNATURE_FREED; }

    DWORD         m_dwSignature;
    IO_CONTEXT *  m_pContext;
    PVOID         m_pv;
    IPM_IO_TYPE_S m_IoType;
} IO_CONTEXT_S;


#endif  // _IPM_IO_S_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\job_object.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    job_object.h

Abstract:

    The IIS web admin service job object class definition.

Author:

    Emily Kruglick (emilyk)        30-Nov-2000

Revision History:

--*/


#ifndef _JOB_OBJECT_H_
#define _JOB_OBJECT_H_



//
// forward references
//




//
// common #defines
//

#define JOB_OBJECT_SIGNATURE       CREATE_SIGNATURE( 'JOBO' )
#define JOB_OBJECT_SIGNATURE_FREED CREATE_SIGNATURE( 'jobX' )


//
// structs, enums, etc.
//


// job object states
typedef enum _JOB_OBJECT_STATE
{

    //
    // The object is not yet initialized or
    // it was in use but has been shutdown.
    //
    NotInitalizedJobObjectState = 0,

    //
    // The job object exists but we are not currently
    // using it.
    DisabledJobObjectState,

    //
    // The job object is running (waiting for a problem)
    //
    RunningJobObjectState,

    //
    // The job object hit the time constraint.
    //
    HitConstraintJobObjectState,

    //
    // Hit the contraint and disabled
    KillActionFiredJobObjectState,

    //
    // Job object is in the middle of shutting down
    ShuttingDownJobObjectState,



} JOB_OBJECT_STATE;

// JOB_OBJECT work items
typedef enum _JOB_OBJECT_WORK_ITEM
{

    //
    // Hit the limit and need to do the 
    // appropriate action.
    //
    JobObjectHitLimitWorkItem = 1,

    //
    // Timer fired, time to reset the 
    // job object.
    //
    JobObjectResetTimerFiredWorkItem,

    //
    // It is ok to release the work item
    // for this job object.
    ReleaseWorkItemJobObjectWorkItem 
    
} JOB_OBJECT_WORK_ITEM;

// job object actions
typedef enum _JOB_OBJECT_ACTION
{

    //
    // Just log
    LogJobObjectAction = 0,

    //
    // Log & Shutdown the app pool
    KillJobObjectAction,

    //
    // Log & Turn on tracing
    TraceJobObjectAction,

    //
    // Log & throttle back the processes
    ThrottleJobObjectAction

} JOB_OBJECT_ACTION;

//
// prototypes
//

class JOB_OBJECT
    : public WORK_DISPATCH
{

public:

    JOB_OBJECT(
        );

    virtual
    ~JOB_OBJECT(
        );

    virtual
    VOID
    Reference(
        );

    virtual
    VOID
    Dereference(
        );

    virtual
    HRESULT
    ExecuteWorkItem(
        IN const WORK_ITEM * pWorkItem
        );

    HRESULT
    Initialize(
        IN APP_POOL* pAppPool
        );

    HRESULT
    Terminate(
        );

    HRESULT
    SetConfiguration(
        DWORD CpuResetInterval,
        DWORD CpuLimit,
        DWORD CpuAction
        );

    HRESULT
    AddWorkerProcess(
        IN HANDLE hWorkerProcess
        );

    BOOL
    CheckSignature(
        )
    { 
        return ( m_Signature == JOB_OBJECT_SIGNATURE ); 
    }

private:

    HRESULT
    ProcessLimitHit(
        );

    HRESULT
    ProcessTimerFire(
        );

    HRESULT
    ReleaseWorkItem(
        );

    HRESULT
    UpdateJobObjectMonitoring(
        );

    HRESULT
    BeginJobObjectTimer(
        );

    HRESULT
    CancelJobObjectTimer(
        );

    DWORD m_Signature;

    LONG m_RefCount;

    JOB_OBJECT_STATE m_State;

    //
    // Parent application pool to use
    // to perform any necessary actions in
    // the case that the limit is hit.
    //
    APP_POOL* m_pAppPool;

    //
    // The amount of time to monitor over.  If the limit
    // hits this value minues the amount of time that has passed
    // for this monitoring session equals the amount of time 
    // that we wait before resetting the monitoring and possibly
    // preforming the action again (assuming the action was not
    // recycling everything).
    //
    DWORD m_CpuResetInterval;

    //
    // The amount of processor time the processes can use over the 
    // amount of time defined by the CpuResetInterval.
    // 
    DWORD m_CpuLimit;

    // 
    // The action to be performed when the limit is reached.
    // 
    DWORD m_CpuAction;

    //
    // The job object that this class uses to be notified when
    // limits are hit.
    //
    HANDLE m_hJobObject;

    //
    // The handle for the Job Object timer.
    //
    HANDLE m_JobObjectTimerHandle;

    //
    // Work item for job object call backs.
    //
    WORK_ITEM* m_pWorkItem; 


};  // class JOB_OBJECT



#endif  // _JOB_OBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\low_memory_detector.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    low_memory_detector.cxx

Abstract:

    The IIS web admin service low memory detector class implementation. 
    This class is used to monitor whether the system is in a severe low
    resource state.

    Threading: Always called on the main worker thread.

Author:

    Seth Pollack (sethp)        5-Jan-2000

Revision History:

--*/



#include  "precomp.h"



//
// local prototypes
//

VOID
LowMemoryRecoveryTimerCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    );



/***************************************************************************++

Routine Description:

    Constructor for the LOW_MEMORY_DETECTOR class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

LOW_MEMORY_DETECTOR::LOW_MEMORY_DETECTOR(
    )
{

    //
    // Set the initial reference count to 1, in order to represent the
    // reference owned by the creator of this instance.
    //

    m_RefCount = 1;


    m_LowMemoryCheckPassedTickCount = 0;

    m_InLowMemoryStateAtLastCheck = FALSE;

    m_LowMemoryRecoveryTimerHandle = NULL;

    m_Signature = LOW_MEMORY_DETECTOR_SIGNATURE;

}   // LOW_MEMORY_DETECTOR::LOW_MEMORY_DETECTOR



/***************************************************************************++

Routine Description:

    Destructor for the LOW_MEMORY_DETECTOR class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

LOW_MEMORY_DETECTOR::~LOW_MEMORY_DETECTOR(
    )
{

    DBG_ASSERT( m_Signature == LOW_MEMORY_DETECTOR_SIGNATURE );

    m_Signature = LOW_MEMORY_DETECTOR_SIGNATURE_FREED;

    DBG_ASSERT( m_RefCount == 0 );

    DBG_ASSERT( m_LowMemoryRecoveryTimerHandle == NULL );

}   // LOW_MEMORY_DETECTOR::~LOW_MEMORY_DETECTOR



/***************************************************************************++

Routine Description:

    Increment the reference count for this object. Note that this method must
    be thread safe, and must not be able to fail.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
LOW_MEMORY_DETECTOR::Reference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedIncrement( &m_RefCount );


    //
    // The reference count should never have been less than zero; and
    // furthermore once it has hit zero it should never bounce back up;
    // given these conditions, it better be greater than one now.
    //
    
    DBG_ASSERT( NewRefCount > 1 );


    return;

}   // LOW_MEMORY_DETECTOR::Reference



/***************************************************************************++

Routine Description:

    Decrement the reference count for this object, and cleanup if the count
    hits zero. Note that this method must be thread safe, and must not be
    able to fail.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
LOW_MEMORY_DETECTOR::Dereference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedDecrement( &m_RefCount );

    // ref count should never go negative
    DBG_ASSERT( NewRefCount >= 0 );

    if ( NewRefCount == 0 )
    {
        // time to go away

        IF_DEBUG( WEB_ADMIN_SERVICE_REFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Reference count has hit zero in LOW_MEMORY_DETECTOR, deleting (ptr: %p)\n",
                this
                ));
        }


        delete this;


    }


    return;

}   // LOW_MEMORY_DETECTOR::Dereference



/***************************************************************************++

Routine Description:

    Execute a work item on this object.

Arguments:

    pWorkItem - The work item to execute.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
LOW_MEMORY_DETECTOR::ExecuteWorkItem(
    IN const WORK_ITEM * pWorkItem
    )
{

    HRESULT hr = S_OK;
    BOOL StillInLowMemoryCondition = FALSE;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( pWorkItem != NULL );


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Executing work item with serial number: %lu in LOW_MEMORY_DETECTOR (ptr: %p) with operation: %p\n",
            pWorkItem->GetSerialNumber(),
            this,
            pWorkItem->GetOpCode()
            ));
    }


    switch ( pWorkItem->GetOpCode() )
    {

    case LowMemoryRecoveryLowMemoryWorkItem:

        //
        // See if we are still in a low memory condition. If we are no longer
        // in that condition, this call will notify the rest of the system.
        //

        StillInLowMemoryCondition = IsSystemInLowMemoryCondition();

        break;

    default:

        // invalid work item!
        DBG_ASSERT( FALSE );

        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;

    }


    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Executing work item on LOW_MEMORY_DETECTOR failed\n"
            ));

    }


    return hr;

}   // LOW_MEMORY_DETECTOR::ExecuteWorkItem



/***************************************************************************++

Routine Description:

    Begin termination of this object. Tell all referenced or owned entities 
    which may hold a reference to this object to release that reference 
    (and not take any more), in order to break reference cycles. 

    Note that this function may cause the instance to delete itself; 
    instance state should not be accessed when unwinding from this call. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
LOW_MEMORY_DETECTOR::Terminate(
    )
{

    //
    // Cancel the low memory recovery timer, if present.
    //

    DBG_REQUIRE( SUCCEEDED( CancelLowMemoryRecoveryTimer() ) );


    return;
    
}   // LOW_MEMORY_DETECTOR::Terminate



/***************************************************************************++

Routine Description:

    Determine if the system is in a low memory condition. 

Arguments:

    None.

Return Value:

    BOOL - TRUE if the system is in a low memory condition, FALSE if not.

--***************************************************************************/

BOOL
LOW_MEMORY_DETECTOR::IsSystemInLowMemoryCondition(
    )
{

    BOOL LowMemory = FALSE; 
    BOOL Success = TRUE;
    MEMORYSTATUSEX MemoryStatus;
    HRESULT hr = S_OK;
    SIZE_T BigAllocationSize = 0;
    VOID * pBigAllocation = NULL;
    DWORD TickCount = 0;
    DWORDLONG LowMemoryFactor = 0;


    //
    // If we've passed a low memory check very recently, then don't bother
    // checking again now. Note that tick counts are in milliseconds.
    // Tick counts roll over every 49.7 days, but the arithmetic operation
    // works correctly anyways in this case.
    //

    TickCount = GetTickCount();

    if ( ( TickCount - m_LowMemoryCheckPassedTickCount ) < LOW_MEMORY_RECENT_CHECK_WINDOW )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_LOW_MEM )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Low memory check skipped because we've passed recently\n"
                ));
        }

        goto exit;
    }


    //
    // Choose which low memory standard to use for the check, based on
    // whether we are currently in a low memory condition or not. Having
    // two different factors provides hysteresis, to curtail rapid 
    // bouncing in and out of the low memory state. 
    //

    LowMemoryFactor = ( m_InLowMemoryStateAtLastCheck ? LOW_MEMORY_FACTOR_RECOVERY : LOW_MEMORY_FACTOR );


    ZeroMemory( &MemoryStatus, sizeof( MemoryStatus ) );
    MemoryStatus.dwLength = sizeof( MemoryStatus );
    

    Success = GlobalMemoryStatusEx( &MemoryStatus );

    if ( ! Success )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Retreiving global memory status failed\n"
            ));

        //
        // If we can't even do this, we must be in some kind of
        // bad low resource state.
        //

        LowMemory = TRUE;

        goto exit;
    }


    //
    // Sanity check on the data from GlobalMemoryStatusEx(). There is a Win2k
    // bug i found that causes bogus values for ullAvailPageFile to be returned
    // when the system is really hammered. silviuc from the NT team has put a
    // fix into Whistler, and is looking into getting this into a Win2k service
    // pack (3/14/00). 
    //
    // BUGBUG Temporary workaround for this fix below. Once we can depend on 
    // the fix, revert to this assert:
    //    DBG_ASSERT( MemoryStatus.ullAvailPageFile <= MemoryStatus.ullTotalPageFile );
    //

    if ( MemoryStatus.ullAvailPageFile > MemoryStatus.ullTotalPageFile )
    {
        //
        // We hit the bug! Assume we are in the low memory state.
        //

        LowMemory = TRUE;

        goto exit;
    }


    //
    // See if less than ( 1 / LowMemoryFactor ) of the total page file 
    // space is available.
    //

    if ( MemoryStatus.ullAvailPageFile < ( MemoryStatus.ullTotalPageFile / LowMemoryFactor ) )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_LOW_MEM )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Attempting to allocate memory to grow page file\n"
                ));
        }

        //
        // Free page file space is low. However, the page file itself
        // may have room to grow before it hits it's maximum configured
        // size. Try to force this by making an allocation bigger than
        // the available page file space (say, twice as big; but cap it
        // at a big allocation size). Note that the maximum allocation
        // size must be less than the maximum 32 bit number, so that
        // the size will be valid on 32 bit (non 64 bit) systems.
        //
        
        DBG_ASSERT( LOW_MEMORY_MAX_ALLOC_SIZE <= MAX_ULONG );

        BigAllocationSize = ( SIZE_T ) MIN( MemoryStatus.ullAvailPageFile * 2, LOW_MEMORY_MAX_ALLOC_SIZE );


        pBigAllocation = GlobalAlloc( GMEM_FIXED, BigAllocationSize );

        if ( pBigAllocation == NULL )
        {
        
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Allocating memory to grow page file failed\n"
                ));

            //
            // If we can't even do this, we must be in some kind of
            // bad low resource state.
            //

            LowMemory = TRUE;

            goto exit;

        }
        else
        {
        
            //
            // Allocating succeeded. Free the memory, and then check
            // again to see if we still appear to be in a low memory
            // condition. 
            //

            DBG_REQUIRE( GlobalFree( pBigAllocation ) == NULL );


            ZeroMemory( &MemoryStatus, sizeof( MemoryStatus ) );
            MemoryStatus.dwLength = sizeof( MemoryStatus );


            Success = GlobalMemoryStatusEx( &MemoryStatus );

            if ( ! Success )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() ); 

                DPERROR((
                    DBG_CONTEXT,
                    hr,
                    "Retreiving global memory status failed\n"
                    ));

                //
                // If we can't even do this, we must be in some kind of
                // bad low resource state.
                //

                LowMemory = TRUE;

                goto exit;
            }


            //
            // Sanity check on the data from GlobalMemoryStatusEx(). There is a Win2k
            // bug i found that causes bogus values for ullAvailPageFile to be returned
            // when the system is really hammered. silviuc from the NT team has put a
            // fix into Whistler, and is looking into getting this into a Win2k service
            // pack (3/14/00). 
            //
            // BUGBUG Temporary workaround for this fix below. Once we can depend on 
            // the fix, revert to this assert:
            //    DBG_ASSERT( MemoryStatus.ullAvailPageFile <= MemoryStatus.ullTotalPageFile );
            //

            if ( MemoryStatus.ullAvailPageFile > MemoryStatus.ullTotalPageFile )
            {
                //
                // We hit the bug! Assume we are in the low memory state.
                //

                LowMemory = TRUE;

                goto exit;
            }


            //
            // See if less than ( 1 / LowMemoryFactor ) of the total page file 
            // space is available.
            //

            if ( MemoryStatus.ullAvailPageFile < ( MemoryStatus.ullTotalPageFile / LowMemoryFactor ) )
            {
            
                //
                // Even after trying to grow the page file, things look grim.
                //

                LowMemory = TRUE;

                goto exit;

            }

        }

    }


    //
    // If we made it here, then we are not in a low memory condition.
    // Remember that we passed so that we don't have to check again
    // in the very near future. 
    //

    DBG_ASSERT( ! LowMemory );

    m_LowMemoryCheckPassedTickCount = TickCount;


    IF_DEBUG( WEB_ADMIN_SERVICE_LOW_MEM )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Low memory check passed; page file available: %I64u; page file total: %I64u\n",
            MemoryStatus.ullAvailPageFile,
            MemoryStatus.ullTotalPageFile
            ));
    }


    if ( m_InLowMemoryStateAtLastCheck )
    {

        DBG_REQUIRE( SUCCEEDED( LeavingLowMemoryCondition() ) );

    }


exit:

    if ( LowMemory )
    {

        //
        // Note that potentially MemoryStatus was not even filled in; in
        // this case we'll just report zeros.
        //

        IF_DEBUG( WEB_ADMIN_SERVICE_LOW_MEM )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Low memory condition!!! page file available: %I64u; page file total: %I64u\n",
                MemoryStatus.ullAvailPageFile,
                MemoryStatus.ullTotalPageFile
                ));
        }


        if ( ! m_InLowMemoryStateAtLastCheck )
        {

            DBG_REQUIRE( SUCCEEDED( EnteringLowMemoryCondition() ) );

        }

    }


    return LowMemory;

}   // LOW_MEMORY_DETECTOR::IsSystemInLowMemoryCondition



/***************************************************************************++

Routine Description:

    Respond to the fact that we have entered the low memory condition.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
LOW_MEMORY_DETECTOR::EnteringLowMemoryCondition(
    )
{

    HRESULT hr = S_OK;


    IF_DEBUG( WEB_ADMIN_SERVICE_LOW_MEM )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Entering low memory condition!\n"
            ));
    }


    DBG_ASSERT( m_InLowMemoryStateAtLastCheck == FALSE );


    m_InLowMemoryStateAtLastCheck = TRUE;


    //
    // We're just entering the low memory state, where at last check
    // we were still ok memory-wise. So report the change of affairs.
    //

    //
    // Log an event: the system is in a very low memory condtion.
    //

    GetWebAdminService()->GetEventLog()->
        LogEvent(
            WAS_EVENT_VERY_LOW_MEMORY,              // message id
            0,                                      // count of strings
            NULL,                                   // array of strings
            0                                       // error code
            );


    //
    // Start a timer that will check periodically whether we have emerged 
    // from the low memory condition. We need the timer, because otherwise
    // we are not guaranteed that we will get tickled to even check whether
    // conditions have improved. 
    //

    hr = BeginLowMemoryRecoveryTimer();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Starting low memory recovery timer failed\n"
            ));

        //
        // If this happens, then we may never get tickled to emerge from 
        // this state once the resource situation improves. However, if
        // we can't even create the timer, chances are that the machine
        // isn't going to recover anyways.
        //

        //
        // CODEWORK Any way to improve this? 
        //

        goto exit;
    }


exit:

    return hr;

}   // LOW_MEMORY_DETECTOR::EnteringLowMemoryCondition



/***************************************************************************++

Routine Description:

    Respond to the fact that we have left the low memory condition.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
LOW_MEMORY_DETECTOR::LeavingLowMemoryCondition(
    )
{

    HRESULT hr = S_OK;
    static DWORD TimesCalledOnStack = 0;

    //
    // Need to keep track if we are currently in a stack that is coming from
    // this function.  If we are then we can not attempt to recover in that we
    // will fail because we all ready locked the app pool table.  So if we have
    // are starting to recurse, simply don't do anything.  The timer will still
    // fire later and will take us out of this situation.
    //
    TimesCalledOnStack++;

    DBG_ASSERT( TimesCalledOnStack == 1 );


    IF_DEBUG( WEB_ADMIN_SERVICE_LOW_MEM )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Leaving low memory condition!\n"
            ));
    }


    DBG_ASSERT( m_InLowMemoryStateAtLastCheck == TRUE );


    m_InLowMemoryStateAtLastCheck = FALSE;


    //
    // Log an event: the system has left the very low memory condtion.
    //

    GetWebAdminService()->GetEventLog()->
        LogEvent(
            WAS_EVENT_VERY_LOW_MEMORY_RECOVERERY,   // message id
            0,                                      // count of strings
            NULL,                                   // array of strings
            0                                       // error code
            );


    hr = CancelLowMemoryRecoveryTimer();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Cancelling low memory recovery timer failed\n"
            ));

        goto exit;
    }


    //
    // Notify the UL&WM that we have left the low memory condition.
    //

    hr = GetWebAdminService()->GetUlAndWorkerManager()->LeavingLowMemoryCondition();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Informing UL&WM that we have left the low memory condition failed\n"
            ));

        goto exit;
    }


exit:

    TimesCalledOnStack--;

    return hr;

}   // LOW_MEMORY_DETECTOR::LeavingLowMemoryCondition




/***************************************************************************++

Routine Description:

    Start the low memory recovery timer.

Arguments:

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
LOW_MEMORY_DETECTOR::BeginLowMemoryRecoveryTimer(
    )
{

    HRESULT hr = S_OK;
    NTSTATUS Status = STATUS_SUCCESS;


    DBG_ASSERT( GetWebAdminService()->GetSharedTimerQueue() != NULL );

    DBG_ASSERT( m_LowMemoryRecoveryTimerHandle == NULL );


    IF_DEBUG( WEB_ADMIN_SERVICE_LOW_MEM )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Beginning low memory recovery check timer\n"
            ));
    }


    Status = RtlCreateTimer(
                    GetWebAdminService()->GetSharedTimerQueue(),
                                                            // timer queue
                    &m_LowMemoryRecoveryTimerHandle,        // returned timer handle
                    LowMemoryRecoveryTimerCallback,         // callback function
                    this,                                   // context
                    LOW_MEMORY_RECOVERY_CHECK_TIMER_PERIOD, // initial firing time
                    LOW_MEMORY_RECOVERY_CHECK_TIMER_PERIOD, // subsequent firing period
                    WT_EXECUTEINWAITTHREAD                  // execute callback directly
                    );

    if ( ! NT_SUCCESS ( Status ) )
    {
        hr = HRESULT_FROM_NT( Status );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not create low memory recovery timer\n"
            ));

    }


    return hr;

}   // LOW_MEMORY_DETECTOR::BeginLowMemoryRecoveryTimer



/***************************************************************************++

Routine Description:

    Stop the low memory recovery timer, if present.

Arguments:

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
LOW_MEMORY_DETECTOR::CancelLowMemoryRecoveryTimer(
    )
{

    HRESULT hr = S_OK;
    NTSTATUS Status = STATUS_SUCCESS;


    DBG_ASSERT( GetWebAdminService()->GetSharedTimerQueue() != NULL );


    //
    // If the timer is not present, we're done here.
    //

    if ( m_LowMemoryRecoveryTimerHandle == NULL )
    {
        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_LOW_MEM )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Cancelling low memory recovery check timer\n"
            ));
    }


    //
    // Note that we wait for any running timer callbacks to finish.
    // Otherwise, there could be a race where the callback runs after
    // this worker process instance has been deleted, and so gives out
    // a bad pointer.
    //

    Status = RtlDeleteTimer(
                    GetWebAdminService()->GetSharedTimerQueue(),
                                                    // the owning timer queue
                    m_LowMemoryRecoveryTimerHandle, // timer to cancel
                    ( HANDLE ) -1                   // wait for callbacks to finish
                    );

    if ( ! NT_SUCCESS ( Status ) )
    {
        hr = HRESULT_FROM_NT( Status );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not cancel low memory recovery timer\n"
            ));

        goto exit;
    }

    m_LowMemoryRecoveryTimerHandle = NULL;


exit:

    return hr;

}   // LOW_MEMORY_DETECTOR::CancelLowMemoryRecoveryTimer



/***************************************************************************++

Routine Description:

    The callback function invoked by the low memory recover timer. It simply
    posts a work item for the main worker thread.

Arguments:

    Context - A context value, used to pass the "this" pointer of the
    LOW_MEMORY_DETECTOR object.

    Ignored - Ignored.

Return Value:

    None.

--***************************************************************************/

VOID
LowMemoryRecoveryTimerCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    )
{

    UNREFERENCED_PARAMETER( Ignored );

    DBG_ASSERT ( Context != NULL );

    LOW_MEMORY_DETECTOR* pDetector = reinterpret_cast<LOW_MEMORY_DETECTOR*>( Context );
    
    DBG_ASSERT ( pDetector->CheckSignature() );

    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "About to create/queue work item for low memory recovery check on low memory detector (ptr: %p)\n",
            pDetector
            ));
    }


    QueueWorkItemFromSecondaryThread(
        reinterpret_cast<WORK_DISPATCH*>( Context ),
        LowMemoryRecoveryLowMemoryWorkItem
        );


    return;

}   // LowMemoryRecoveryTimerCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\low_memory_detector.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    low_memory_detector.h

Abstract:

    The IIS web admin service low memory detector class definition.

Author:

    Seth Pollack (sethp)        5-Jan-2000

Revision History:

--*/



#ifndef _LOW_MEMORY_DETECTOR_H_
#define _LOW_MEMORY_DETECTOR_H_



//
// common #defines
//

#define LOW_MEMORY_DETECTOR_SIGNATURE       CREATE_SIGNATURE( 'LMEM' )
#define LOW_MEMORY_DETECTOR_SIGNATURE_FREED CREATE_SIGNATURE( 'lmeX' )


//
// BUGBUG Review these settings. 
//

// 
// If less than ( 1 / LOW_MEMORY_FACTOR ) of the page file space is free,
// then we consider ourselves in a low memory condition. 
//

#define LOW_MEMORY_FACTOR 12
// 
// We require that ( 1 / LOW_MEMORY_FACTOR_RECOVERY ) of the page file space 
// become free, in order to consider ourselves recovered from a low memory 
// condition. LOW_MEMORY_FACTOR_RECOVERY should always be < LOW_MEMORY_FACTOR,
// in order to create hysteresis (to prevent rapid bouncing in and out of the
// low memory state). 
//

#define LOW_MEMORY_FACTOR_RECOVERY 10


#define LOW_MEMORY_MAX_ALLOC_SIZE 0x10000000

#define LOW_MEMORY_RECENT_CHECK_WINDOW ( 1 * ONE_SECOND_IN_MILLISECONDS )   // 1 second

#define LOW_MEMORY_RECOVERY_CHECK_TIMER_PERIOD ( 60 * ONE_SECOND_IN_MILLISECONDS )  // 60 seconds



//
// structs, enums, etc.
//

// LOW_MEMORY_DETECTOR work items
typedef enum _LOW_MEMORY_DETECTOR_WORK_ITEM
{

    //
    // See if we are still in a low memory state.
    //
    LowMemoryRecoveryLowMemoryWorkItem = 1,
    
} LOW_MEMORY_DETECTOR_WORK_ITEM;



//
// prototypes
//


class LOW_MEMORY_DETECTOR
    : public WORK_DISPATCH
{

public:

    LOW_MEMORY_DETECTOR(
        );

    virtual
    ~LOW_MEMORY_DETECTOR(
        );

    virtual
    VOID
    Reference(
        );

    virtual
    VOID
    Dereference(
        );

    virtual
    HRESULT
    ExecuteWorkItem(
        IN const WORK_ITEM * pWorkItem
        );

    VOID
    Terminate(
        );

    BOOL
    IsSystemInLowMemoryCondition(
        );

    BOOL
    HaveEnteredLowMemoryCondition(
        )
    {
        return ( m_InLowMemoryStateAtLastCheck );
    }

    BOOL
    CheckSignature(
        )
    { 
        return  ( m_Signature == LOW_MEMORY_DETECTOR_SIGNATURE ); 
    }

private:

    HRESULT
    EnteringLowMemoryCondition(
        );

    HRESULT
    LeavingLowMemoryCondition(
        );

    HRESULT
    BeginLowMemoryRecoveryTimer(
        );

    HRESULT
    CancelLowMemoryRecoveryTimer(
        );


    DWORD m_Signature;

    LONG m_RefCount;

    DWORD m_LowMemoryCheckPassedTickCount;

    BOOL m_InLowMemoryStateAtLastCheck;

    // low memory recovery check timer
    HANDLE m_LowMemoryRecoveryTimerHandle;


};  // class LOW_MEMORY_DETECTOR



#endif  // _LOW_MEMORY_DETECTOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\main.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    main.h

Abstract:

    The IIS web admin service header for the service bootstrap code.

Author:

    Seth Pollack (sethp)        04-Nov-1998

Revision History:

--*/


#ifndef _MAIN_H_
#define _MAIN_H_



//
// forward references
//

class WEB_ADMIN_SERVICE;



//
// registry paths
//


//
// helper functions
//

//
// Access the global web admin service pointer.
//

WEB_ADMIN_SERVICE *
GetWebAdminService(
    );

//
// common, service-wide #defines
//

#define MAX_STRINGIZED_ULONG_CHAR_COUNT 11      // "4294967295", including the terminating null

#define MAX_ULONG 0xFFFFFFFF

#define SECONDS_PER_MINUTE 60

#define ONE_SECOND_IN_MILLISECONDS 1000

#define ONE_MINUTE_IN_MILLISECONDS ( SECONDS_PER_MINUTE * ONE_SECOND_IN_MILLISECONDS )

#define MAX_MINUTES_IN_ULONG_OF_MILLISECONDS ( MAX_ULONG / ( SECONDS_PER_MINUTE * ONE_SECOND_IN_MILLISECONDS ) )

#define MAX_SECONDS_IN_ULONG_OF_MILLISECONDS ( MAX_ULONG / ONE_SECOND_IN_MILLISECONDS )


#define MIN( a, b ) ( (a) < (b) ? (a) : (b) )
#define MAX( a, b ) ( (a) > (b) ? (a) : (b) )



#endif  // _MAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\main.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    main.cxx

Abstract:

    Main service entry points for for the IIS web admin service.

Author:

    Seth Pollack (sethp)        22-Jul-1998

Revision History:

--*/



#include "precomp.h"



//
// global variables
//


// debug support
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();


//
// Global pointer to the service object. Should not be used directly
// outside of this file; use GetWebAdminService() instead.
//

WEB_ADMIN_SERVICE *g_pWebAdminService = NULL;



/***************************************************************************++

Routine Description:

    The dll entry point. Used to set up debug libraries, etc.

Arguments:

    DllHandle - The dll module handle for this dll. Does not need to be
    closed.

    Reason - The dll notification reason.

    pReserved - Reserved, not used.

Return Value:

    BOOL

--***************************************************************************/

extern "C"
BOOL
WINAPI
DllMain(
    HINSTANCE DllHandle,
    DWORD Reason,
    LPVOID pReserved
    )
{

    BOOL Success = TRUE;
    HRESULT hr = S_OK;


    UNREFERENCED_PARAMETER( pReserved );


    switch ( Reason )
    {

    case DLL_PROCESS_ATTACH:

        CREATE_DEBUG_PRINT_OBJECT( WEB_ADMIN_SERVICE_NAME_A );

        LOAD_DEBUG_FLAGS_FROM_REG_STR( REGISTRY_KEY_W3SVC_PARAMETERS_A, 0 );

        DBG_OPEN_MEMORY_LOG();

        Success = VALID_DEBUG_PRINT_OBJECT();

        if ( ! Success )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Debug print object is not valid\n"
                ));

            goto exit;
        }


        Success = DisableThreadLibraryCalls( DllHandle );

        if ( ! Success )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Disabling thread library calls failed\n"
                ));

            goto exit;
        }

        break;

    case DLL_PROCESS_DETACH:

        //
        // If this DLL is being invoked because of REGSVR32, then we will
        // not have created the service.
        //

        if ( g_pWebAdminService != NULL )
        {
            //
            // We are now completely done with service execution.
            //

            g_pWebAdminService->Dereference();

            g_pWebAdminService = NULL;
        }

        DELETE_DEBUG_PRINT_OBJECT();

        break;

    default:

        break;

    }


exit:

    return Success;

}   // DllMain



/***************************************************************************++

Routine Description:

    The main entry point called by svchost, the service hosting exe. This
    function conforms to the LPSERVICE_MAIN_FUNCTIONW prototype.

    This function is called on a thread spun for us by the service controller.
    We take this thread and make it into our "main worker thread" for service
    execution.

Arguments:

    ArgumentCount - Count of command line arguments.

    ArgumentValues - Array of command line argument strings.

Return Value:

    None.

--***************************************************************************/

VOID
ServiceMain(
    IN DWORD ArgumentCount,
    IN LPWSTR * ArgumentValues
    )
{

    HRESULT hr = S_OK;


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "ServiceMain entrypoint called\n"
            ));
    }


    //
    // We're not expecting any command line arguments besides the
    // service name.
    //

    DBG_ASSERT( ArgumentCount == 1 );
    DBG_ASSERT( ArgumentValues != NULL );
    DBG_ASSERT( _wcsicmp( ArgumentValues[0], WEB_ADMIN_SERVICE_NAME_W ) == 0 );


    //
    // Ensure that on service re-start we are truly re-initialized.
    //

    DBG_ASSERT( g_pWebAdminService == NULL );


    g_pWebAdminService = new WEB_ADMIN_SERVICE;

    if ( g_pWebAdminService == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Allocating WEB_ADMIN_SERVICE failed\n"
            ));

        //
        // Error handling note: If we were not able to even create the web
        // admin service object, we are dead in the water. The SCM will
        // eventually time out and clean up.
        //

        goto exit;
    }


    g_pWebAdminService->ExecuteService();


exit:

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Service exiting\n"
            ));
    }


    return;

}   // ServiceMain



/***************************************************************************++

Routine Description:

    Return the global web admin service instance. May be called by any thread.

Arguments:

    None.

Return Value:

    The global web admin service instance.

--***************************************************************************/

WEB_ADMIN_SERVICE *
GetWebAdminService(
    )
{

    DBG_ASSERT( g_pWebAdminService != NULL );

    return g_pWebAdminService;

}   // GetWebAdminService
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\messaging_handler.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    messaging_handler.cxx

Abstract:

    This class encapsulates the message handling functionality (over IPM)
    that is used by a worker process. 

    Threading: Always called on the main worker thread, except the 
    destructor, which may be called on any thread.

Author:

    Seth Pollack (sethp)        02-Mar-1999

Revision History:

--*/



#include "precomp.h"


/***************************************************************************++

Routine Description:

    Constructor for the MESSAGING_HANDLER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

MESSAGING_HANDLER::MESSAGING_HANDLER(
    )
{


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    m_pPipe = NULL;

    m_pWorkerProcess = NULL; 

    m_Signature = MESSAGING_HANDLER_SIGNATURE;

}   // MESSAGING_HANDLER::MESSAGING_HANDLER



/***************************************************************************++

Routine Description:

    Destructor for the MESSAGING_HANDLER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

MESSAGING_HANDLER::~MESSAGING_HANDLER(
    )
{

    DBG_ASSERT( m_Signature == MESSAGING_HANDLER_SIGNATURE );

    m_Signature = MESSAGING_HANDLER_SIGNATURE_FREED;

    DBG_ASSERT( m_pPipe == NULL );

    DBG_ASSERT( m_pWorkerProcess == NULL );



}   // MESSAGING_HANDLER::~MESSAGING_HANDLER



/***************************************************************************++

Routine Description:

    Initialize this instance.

Arguments:

    pWorkerProcess - The parent worker process object of this instance. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
MESSAGING_HANDLER::Initialize(
    IN WORKER_PROCESS * pWorkerProcess
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    hr = GetWebAdminService()->GetMessageGlobal()->CreateMessagePipe(
                                                        this,
                                                        &m_pPipe
                                                        );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating message pipe failed\n"
            ));

        goto exit;
    }


    DBG_ASSERT( m_pPipe != NULL );


    //
    // Since we have set up a pipe, we need to reference our parent 
    // WORKER_PROCESS, so that while there are any outstanding i/o
    // operations on the pipe, we won't go away. We'll Dereference
    // later, when the pipe gets cleaned up.
    //

    m_pWorkerProcess = pWorkerProcess;
    m_pWorkerProcess->Reference();


exit:

    return hr;
    
}   // MESSAGING_HANDLER::Initialize



/***************************************************************************++

Routine Description:

    Begin termination of this object. Tell all referenced or owned entities 
    which may hold a reference to this object to release that reference 
    (and not take any more), in order to break reference cycles. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
MESSAGING_HANDLER::Terminate(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    //
    // Cleanup the pipe, if present.
    //

    if ( m_pPipe != NULL )
    {

        hr = GetWebAdminService()->GetMessageGlobal()->DisconnectMessagePipe( m_pPipe );

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Disconnecting pipe failed\n"
                ));

        }


        //
        // Set the pipe to NULL, so that we don't try to initiate any new
        // work on it now. 
        //
        // Note however that we won't dereference the owning worker process
        // instance until any work that is currently outstanding finishes.
        // We know this to be the case once we get the PipeDisconnected()
        // notification. 
        //

        m_pPipe = NULL;

    }

}   // MESSAGING_HANDLER::Terminate



/***************************************************************************++

Routine Description:

    Accept an incoming message.

Arguments:

    pMessage - The arriving message.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
MESSAGING_HANDLER::AcceptMessage(
    IN const MESSAGE * pMessage
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pMessage != NULL );


    IF_DEBUG( WEB_ADMIN_SERVICE_IPM )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "MESSAGING_HANDLER::AcceptMessage called (WORKER_PROCESS ptr: %p; pid: %lu; realpid: %lu)\n",
            m_pWorkerProcess,
            m_pWorkerProcess->GetProcessId(),
            m_pWorkerProcess->GetRegisteredProcessId()
            ));
    }


    switch ( pMessage->GetOpcode() )
    {

    case IPM_OP_PING_REPLY:

        hr = HandlePingReply( pMessage );
        
        break;


    case IPM_OP_WORKER_REQUESTS_SHUTDOWN:

        hr = HandleShutdownRequest( pMessage );
        
        break;

    case IPM_OP_SEND_COUNTERS:

        hr = HandleCounters( pMessage );

        break;

    case IPM_OP_HRESULT:

        hr = HandleHresult( pMessage );

        break;

    default:

        //
        // invalid opcode!
        //

        DBG_ASSERT( FALSE );
            
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;
            
    }


    return hr;

}   // MESSAGING_HANDLER::AcceptMessage



/***************************************************************************++

Routine Description:

    Handle the fact that the pipe has been connected by the worker process.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
MESSAGING_HANDLER::PipeConnected(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( m_pWorkerProcess != NULL );
    
    DBG_ASSERT( m_pPipe != NULL );


    IF_DEBUG( WEB_ADMIN_SERVICE_IPM )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "MESSAGING_HANDLER::PipeConnected called (WORKER_PROCESS ptr: %p; pid: %lu; realpid: %lu)\n",
            m_pWorkerProcess,
            m_pWorkerProcess->GetProcessId(),
            m_pWorkerProcess->GetRegisteredProcessId()
            ));
    }


    hr = m_pWorkerProcess->WorkerProcessRegistrationReceived( m_pPipe->GetRemotePid() );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Processing worker process registration failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // MESSAGING_HANDLER::PipeConnected



/***************************************************************************++

Routine Description:

    Handle the fact that the pipe has disconnected. The pipe object will
    self-destruct after returning from this call. 

Arguments:

    Error - The return code associated with the disconnect. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
MESSAGING_HANDLER::PipeDisconnected(
    IN HRESULT Error
    )
{

    HRESULT hr = S_OK;
    WORKER_PROCESS * pWorkerProcess = NULL;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( m_pWorkerProcess != NULL );


    IF_DEBUG( WEB_ADMIN_SERVICE_IPM )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "MESSAGING_HANDLER::PipeDisconnected called (WORKER_PROCESS ptr: %p; pid: %lu; realpid: %lu)\n",
            m_pWorkerProcess,
            m_pWorkerProcess->GetProcessId(),
            m_pWorkerProcess->GetRegisteredProcessId()
            ));
    }


    //
    // If the parameter Error contains a failed HRESULT, this method
    // is being called because something went awry in communication 
    // with the worker process. In this case, we notify the 
    // WORKER_PROCESS.  
    //

    if ( FAILED( Error ) )
    {
    
        hr = m_pWorkerProcess->IpmErrorOccurred( Error );

            if ( FAILED( hr ) )
            {
            
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Notifying WORKER_PROCESS instance of ipm error failed\n"
                    ));

            }

    }


    //
    // This notification means that the pipe is dead, and that there
    // are no longer any outstanding i/o operations pending on it. 
    // Therefore we can now dereference our parent WORKER_PROCESS, as 
    // there is no danger of getting further pipe i/o. 
    //

    pWorkerProcess = m_pWorkerProcess; 
    m_pWorkerProcess = NULL; 

    pWorkerProcess->Dereference();


    //
    // Note: that may have been our last reference (since this object 
    // instance is a member object of the worker process instance), so don't 
    // do any more work here.
    //


    return hr;

}   // MESSAGING_HANDLER::PipeDisconnected



/***************************************************************************++

Routine Description:

    Tell the messaging infrastructure which connecting worker process 
    instance to hook up to this message handler.

Arguments:

    RegistrationId - The registration id, used by the IPM layer to
    associate the correct process with this messaging handler instance.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
MESSAGING_HANDLER::AcceptMessagePipeConnection(
    IN DWORD RegistrationId
    )
{

    HRESULT hr = S_OK;
    STRU PipeName;
    

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    if ( m_pPipe == NULL )
    {
        //
        // The pipe is not valid; it may have self-destructed due to error.
        // Bail out.
        //

        hr = ERROR_PIPE_NOT_CONNECTED;
        
        goto exit;
    }


    //
    // Set up a STRU with the pipename, as required by the IPM api. 
    //

    hr = PipeName.Copy( IPM_NAMED_PIPE_NAME );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Copying string failed\n"
            ));

        goto exit;
    }


    hr = GetWebAdminService()->GetMessageGlobal()->AcceptMessagePipeConnection(
                                                        PipeName,
                                                        RegistrationId,
                                                        m_pPipe
                                                        );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Accepting message pipe connection failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // MESSAGING_HANDLER::ConnectMessagePipe



/***************************************************************************++

Routine Description:

    Ping the worker process to check if it is still responsive. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
MESSAGING_HANDLER::SendPing(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    if ( m_pPipe == NULL )
    {
        //
        // The pipe is not valid; it may have self-destructed due to error.
        // Bail out.
        //

        hr = ERROR_PIPE_NOT_CONNECTED;
        
        goto exit;
    }


    hr = m_pPipe->WriteMessage(
                        IPM_OP_PING,        // opcode
                        0,                  // data length
                        NULL                // pointer to data
                        );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Sending ping message to worker process failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // MESSAGING_HANDLER::SendPing

/***************************************************************************++

Routine Description:

    RequestCounters from the worker process. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
MESSAGING_HANDLER::RequestCounters(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    if ( m_pPipe == NULL )
    {
        //
        // The pipe is not valid; it may have self-destructed due to error.
        // Bail out.
        //

        hr = ERROR_PIPE_NOT_CONNECTED;
        
        goto exit;
    }


    hr = m_pPipe->WriteMessage(
                        IPM_OP_REQUEST_COUNTERS,    // opcode
                        0,                  // data length
                        NULL                // pointer to data
                        );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Requesting Counters message to worker process failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // MESSAGING_HANDLER::RequestCounters


/***************************************************************************++

Routine Description:

    Tell the worker process to initiate clean shutdown. 

Arguments:

    ShutdownTimeLimitInMilliseconds - Number of milliseconds that this 
    worker process has in which to complete clean shutdown. If this time 
    is exceeded, the worker process will be terminated. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
MESSAGING_HANDLER::SendShutdown(
    IN BOOL ShutdownImmediately
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    if ( m_pPipe == NULL )
    {
        //
        // The pipe is not valid; it may have self-destructed due to error.
        // Bail out.
        //

        hr = ERROR_PIPE_NOT_CONNECTED;
        
        goto exit;
    }

    hr = m_pPipe->WriteMessage(
                        IPM_OP_SHUTDOWN,                // opcode
                        sizeof( ShutdownImmediately ),
                                                        // data length
                        reinterpret_cast<BYTE*>( &ShutdownImmediately )
                                                        // pointer to data
                        );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Sending shutdown message to worker process failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // MESSAGING_HANDLER::SendShutdown



/***************************************************************************++

Routine Description:

    Handle a ping reply message from the worker process. 

Arguments:

    pMessage - The arriving message.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
MESSAGING_HANDLER::HandlePingReply(
    IN const MESSAGE * pMessage
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pMessage != NULL );


    //
    // Validate the message data. 
    // Not expecting any message body.
    //

    if ( pMessage->GetDataLen() != 0 )
    {

        //
        // Malformed message! Assert on debug builds; on retail builds,
        // ignore the message.
        //

        DBG_ASSERT( FALSE );

        goto exit;
    }


    hr = m_pWorkerProcess->PingReplyReceived();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Processing ping reply failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // MESSAGING_HANDLER::HandlePingReply

/***************************************************************************++

Routine Description:

    Handle a message containing counter information from a worker process

Arguments:

    pMessage - The arriving message.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
MESSAGING_HANDLER::HandleCounters(
    IN const MESSAGE * pMessage
    )
{


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pMessage != NULL );

    //
    // Tell the worker process to handle it's counters.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {

        DBGPRINTF((
            DBG_CONTEXT, 
            "Receiving Perf Count Message with length %d\n",
            pMessage->GetDataLen()
            ));

    }

    m_pWorkerProcess->RecordCounters(pMessage->GetDataLen(),
                                             pMessage->GetData());

    return S_OK;

}   // MESSAGING_HANDLER::HandleCounters

/***************************************************************************++

Routine Description:

    Handle a message containing an hresult from a worker process

Arguments:

    pMessage - The arriving message.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
MESSAGING_HANDLER::HandleHresult(
    IN const MESSAGE * pMessage
    )
{
    HRESULT hr = S_OK;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pMessage != NULL );

    //
    // Tell the worker process to handle it's counters.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_IPM )
    {

        DBGPRINTF((
            DBG_CONTEXT, 
            "Receiving hresult message with length %d\n",
            pMessage->GetDataLen()
            ));

    }

    DBG_ASSERT ( pMessage->GetDataLen() == sizeof ( HRESULT ) );

    if ( pMessage->GetDataLen() != sizeof ( HRESULT ) )
    {
        return E_FAIL;
    }

    //
    // All this casting is caused by Jeff's desire for us to use
    // the C++ casting mechanisms.  First you have to cast away
    // the const ness, and then you need to change the type.
    //
    BYTE *pMessTemp = const_cast < BYTE* >( pMessage->GetData() );

    HRESULT* phTemp =  reinterpret_cast< HRESULT* > ( pMessTemp );

    hr = m_pWorkerProcess->HandleHresult(*phTemp);
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Failed to handle the hresult from the worker process correctly \n"
            ));

        goto exit;

    }

exit:

    return hr;

}   // MESSAGING_HANDLER::HandleHresult

/***************************************************************************++

Routine Description:

    Handle a shutdown request message from the worker process. 

Arguments:

    pMessage - The arriving message.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
MESSAGING_HANDLER::HandleShutdownRequest(
    IN const MESSAGE * pMessage
    )
{

    HRESULT hr = S_OK;
    IPM_WP_SHUTDOWN_MSG ShutdownRequestReason = IPM_WP_MINIMUM;
    

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pMessage != NULL );


    //
    // Validate the message data. 
    // We are expecting a message body containing a value from the 
    // IPM_WP_SHUTDOWN_MSG enum.
    //

    if ( ( pMessage->GetDataLen() != sizeof( IPM_WP_SHUTDOWN_MSG ) ) ||
         ( pMessage->GetData() == NULL ) )
    {

        //
        // Malformed message! Assert on debug builds; on retail builds,
        // ignore the message.
        //

        DBG_ASSERT( FALSE );

        goto exit;
    }


    ShutdownRequestReason = ( IPM_WP_SHUTDOWN_MSG ) ( * ( pMessage->GetData() ) ); 


    if ( ( ShutdownRequestReason <= IPM_WP_MINIMUM ) ||
         ( ShutdownRequestReason >= IPM_WP_MAXIMUM ) )
    {

        //
        // Malformed message! Assert on debug builds; on retail builds,
        // ignore the message.
        //

        DBG_ASSERT( FALSE );

        goto exit;
    }


    hr = m_pWorkerProcess->ShutdownRequestReceived( ShutdownRequestReason );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Processing shutdown request failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // MESSAGING_HANDLER::HandleShutdownRequest

/***************************************************************************++

Routine Description:

    Send Worker Process Recycler related parameter

Arguments:

    SendPeriodicProcessRestartPeriodInMinutes

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
MESSAGING_HANDLER::SendPeriodicProcessRestartPeriodInMinutes(
    IN DWORD PeriodicProcessRestartPeriodInMinutes
    )
{
    return SendMessage(
               IPM_OP_PERIODIC_PROCESS_RESTART_PERIOD_IN_MINUTES,
               sizeof( PeriodicProcessRestartPeriodInMinutes ),
               (PBYTE) &PeriodicProcessRestartPeriodInMinutes
               );

}   // MESSAGING_HANDLER::SendPeriodicProcessRestartPeriodInMinutes

/***************************************************************************++

Routine Description:

    Send Worker Process Recycler related parameter

Arguments:

    PeriodicProcessRestartRequestCount

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
MESSAGING_HANDLER::SendPeriodicProcessRestartRequestCount(
    IN DWORD PeriodicProcessRestartRequestCount
    )
{
    return SendMessage(
               IPM_OP_PERIODIC_PROCESS_RESTART_REQUEST_COUNT,
               sizeof( PeriodicProcessRestartRequestCount ),
               (PBYTE) &PeriodicProcessRestartRequestCount
               );
}   // MESSAGING_HANDLER::SendPeriodicProcessRestartRequestCount

/***************************************************************************++

Routine Description:

    Send Worker Process Recycler related parameter

Arguments:

    pPeriodicProcessRestartSchedule

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
MESSAGING_HANDLER::SendPeriodicProcessRestartSchedule(
    IN LPWSTR pPeriodicProcessRestartSchedule
    )
{
    return SendMessage(
               IPM_OP_PERIODIC_PROCESS_RESTART_SCHEDULE,
               GetMultiszByteLength( pPeriodicProcessRestartSchedule ),
               (PBYTE) pPeriodicProcessRestartSchedule
               );
}   // MESSAGING_HANDLER::SendPeriodicProcessRestartSchedule 


/***************************************************************************++

Routine Description:

    Send Worker Process Recycler related parameter

Arguments:

    PeriodicProcessRestartMemoryUsageInKB

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
MESSAGING_HANDLER::SendPeriodicProcessRestartMemoryUsageInKB(
    IN DWORD PeriodicProcessRestartMemoryUsageInKB
    )
{
    return SendMessage(
               IPM_OP_PERIODIC_PROCESS_RESTART_MEMORY_USAGE_IN_KB,
               sizeof( PeriodicProcessRestartMemoryUsageInKB ),
               (PBYTE) &PeriodicProcessRestartMemoryUsageInKB
               );
}   // MESSAGING_HANDLER::SendPeriodicProcessRestartMemoryUsageInKB


/***************************************************************************++

Routine Description:

    Send Message - wrapper of pipe's WriteMessage()
    It performs some validations before making WriteMessage() call
    
Arguments:
    opcode      - opcode
    dwDataLen,  - data length
    pbData      - pointer to data

    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
MESSAGING_HANDLER::SendMessage(
    IN enum IPM_OPCODE  opcode,
    IN DWORD            dwDataLen,
    IN BYTE *           pbData 
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    if ( m_pPipe == NULL )
    {
        //
        // The pipe is not valid; it may have self-destructed due to error.
        // Bail out.
        //

        hr = ERROR_PIPE_NOT_CONNECTED;
        
        goto exit;
    }

    hr = m_pPipe->WriteMessage(
                        opcode,        // opcode
                        dwDataLen,     // data length
                        pbData         // pointer to data
                        );

    if ( FAILED( hr ) )
    {
    
        DBGPRINTF(( 
            DBG_CONTEXT,
            "Sending message %d to worker process failed. hr =0x%x\n",
            opcode,
            hr
            ));

        goto exit;
    }


exit:

    return hr;

}   // MESSAGING_HANDLER::SendMessage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\messaging_handler.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    messaging_handler.h

Abstract:

    The IIS web admin service message handling class definition. This
    is used for interacting with the IPM (inter-process messaging) support, 
    in order to send and receive messages, and so forth. 

Author:

    Seth Pollack (sethp)        02-Mar-1999

Revision History:

--*/


#ifndef _MESSAGING_HANDLER_H_
#define _MESSAGING_HANDLER_H_



//
// forward references
//

class WORKER_PROCESS;



//
// common #defines
//

#define MESSAGING_HANDLER_SIGNATURE        CREATE_SIGNATURE( 'MSGH' )
#define MESSAGING_HANDLER_SIGNATURE_FREED  CREATE_SIGNATURE( 'msgX' )



//
// prototypes
//

class MESSAGING_HANDLER
    : public MESSAGE_LISTENER
{

public:

    MESSAGING_HANDLER(
       );

    virtual
    ~MESSAGING_HANDLER(
        );

    HRESULT
    Initialize(
        IN WORKER_PROCESS * pWorkerProcess
        );

    VOID
    Terminate(
        );


    //
    // MESSAGE_LISTENER methods.
    //
    
    virtual
    HRESULT
    AcceptMessage(
        IN const MESSAGE * pMessage
        );

    virtual
    HRESULT
    PipeConnected(
        );
        
    virtual
    HRESULT
    PipeDisconnected(
        IN HRESULT Error
        );


    //
    // Connection handshaking.
    //

    HRESULT
    AcceptMessagePipeConnection(
        IN DWORD RegistrationId
        );


    //
    // Messages to send.
    //

    HRESULT
    SendPing(
        );

    HRESULT
    RequestCounters(
        );

    HRESULT
    SendShutdown(
        IN BOOL ShutdownImmediately
        );

    HRESULT
    SendPeriodicProcessRestartPeriodInMinutes(
        IN DWORD PeriodicProcessRestartPeriodInMinutes
        );

    HRESULT
    SendPeriodicProcessRestartRequestCount(
        IN DWORD PeriodicProcessRestartRequestCount
        );
        
    HRESULT
    SendPeriodicProcessRestartSchedule(
        IN LPWSTR pPeriodicProcessRestartSchedule
        );

    HRESULT
    SendPeriodicProcessRestartMemoryUsageInKB(
        IN DWORD PeriodicProcessRestartMemoryUsageInKB
        );

    //
    // Handle received messages. 
    //

    HRESULT
    HandlePingReply(
        IN const MESSAGE * pMessage
        );

    HRESULT
    HandleShutdownRequest(
        IN const MESSAGE * pMessage
        );

    HRESULT
    HandleCounters(
        IN const MESSAGE * pMessage
        );

    HRESULT
    HandleHresult(
        IN const MESSAGE * pMessage
        );

private:

    HRESULT
    SendMessage(
        IN enum IPM_OPCODE  opcode,
        IN DWORD            dwDataLen,
        IN BYTE *           pbData 
        );

    DWORD m_Signature;

    MESSAGE_PIPE * m_pPipe;

    WORKER_PROCESS * m_pWorkerProcess;


};  // class MESSAGING_HANDLER



#endif  // _MESSAGING_HANDLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\perf_virtual_site.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    perf_virtual_site.cxx

Abstract:

    This class encapsulates a single virtual site entry
    used for tracking specific information about the virtual
    sites performance counters. 

    Threading: All threads

Author:

    Emily Kruglick (emilyk)        30-Aug-2000

Revision History:

--*/



#include "precomp.h"


/***************************************************************************++

Routine Description:

    Constructor for the PERF_VIRTUAL_SITE class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

PERF_VIRTUAL_SITE::PERF_VIRTUAL_SITE(
    )
{

    m_Signature = PERF_VIRTUAL_SITE_SIGNATURE;

    m_VirtualSiteId = INVALID_PERF_VIRTUAL_SITE_ID;

    memset ( m_VirtualSiteName, 0, MAX_INSTANCE_NAME * sizeof(WCHAR));

    m_MemoryReference = 0;

    m_Visited = TRUE;

    m_ListEntry.Flink = NULL;
    m_ListEntry.Blink = NULL; 

}   // PERF_VIRTUAL_SITE::PERF_VIRTUAL_SITE



/***************************************************************************++

Routine Description:

    Destructor for the PERF_VIRTUAL_SITE class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/
PERF_VIRTUAL_SITE::~PERF_VIRTUAL_SITE(
    )
{

    DBG_ASSERT( m_Signature == PERF_VIRTUAL_SITE_SIGNATURE );

    m_Signature = PERF_VIRTUAL_SITE_SIGNATURE_FREED;

}   // PERF_VIRTUAL_SITE::~PERF_VIRTUAL_SITE

/***************************************************************************++

Routine Description:

    Initialize the virtual site instance.

Arguments:

    VirtualSiteId - ID for the virtual site.

    MemoryReference - The memory reference number from the start of the 
                           memory mapped chunk to the site instance
                           information.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
PERF_VIRTUAL_SITE::Initialize(
    IN DWORD VirtualSiteId,
    IN DWORD MemoryReference
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    HRESULT hr = S_OK;

    m_VirtualSiteId = VirtualSiteId;
    m_MemoryReference = MemoryReference;

    wsprintf(m_VirtualSiteName, L"W3SVC%d", m_VirtualSiteId);

    return hr;
    
}   // PERF_VIRTUAL_SITE::Initialize

/***************************************************************************++

Routine Description:

    A static class method to "upcast" from the list LIST_ENTRY 
    pointer of a PERF_VIRTUAL_SITE to the PERF_VIRTUAL_SITE as a whole.

Arguments:

    pListEntry - A pointer to the m_ListEntry member of a 
    PERF_VIRTUAL_SITE.

Return Value:

    The pointer to the containing PERF_VIRTUAL_SITE.

--***************************************************************************/

// note: static!
PERF_VIRTUAL_SITE *
PERF_VIRTUAL_SITE::PerfVirtualSiteFromListEntry(
    IN const LIST_ENTRY * pListEntry
)
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    PERF_VIRTUAL_SITE * pPerfVirtualSite = NULL;

    DBG_ASSERT( pListEntry != NULL );

    //  get the containing structure, then verify the signature
    pPerfVirtualSite = CONTAINING_RECORD(
                            pListEntry,
                            PERF_VIRTUAL_SITE,
                            m_ListEntry
                            );

    DBG_ASSERT( pPerfVirtualSite->m_Signature == PERF_VIRTUAL_SITE_SIGNATURE );

    return pPerfVirtualSite;

}   // PERF_VIRTUAL_SITE::VirtualSiteFromDeleteListEntry



#if DBG
/***************************************************************************++

Routine Description:

    Dump out key internal data structures.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
PERF_VIRTUAL_SITE::DebugDump(
    )
{
    //
    // Output the site id, and its set of URL prefixes.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "********Virtual site id: %lu; Url prefixes:\n",
            GetVirtualSiteId()
            ));
    }

    return;
    
}   // PERF_VIRTUAL_SITE::DebugDump
#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\perf_virtual_site.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    perf_virtual_site.h

Abstract:

    The is the performance virtual site class definition,
    it is used to hold information about virtual sites that 
    pertains to performance counters.  These objects are available
    on any thread dealing with performance counters. 

Author:

    Emily Kruglick (emilyk)        30-Aug-2000

Revision History:

--*/


#ifndef _PERF_VIRTUAL_SITE_H_
#define _PERF_VIRTUAL_SITE_H_



//
// common #defines
//

#define PERF_VIRTUAL_SITE_SIGNATURE          CREATE_SIGNATURE( 'PVSE' )
#define PERF_VIRTUAL_SITE_SIGNATURE_FREED    CREATE_SIGNATURE( 'pvsX' )

#define INVALID_PERF_VIRTUAL_SITE_ID 0
//
// structs, enums, etc.
//



//
// prototypes
//

class PERF_VIRTUAL_SITE
{

public:

    PERF_VIRTUAL_SITE(
        );

    ~PERF_VIRTUAL_SITE(
        );

    HRESULT
    Initialize(
        IN DWORD VirtualSiteId,
        IN DWORD MemoryReference
        );

    inline
    DWORD
    GetVirtualSiteId(
        )
        const
    { return m_VirtualSiteId; }

    inline
    LPWSTR
    GetVirtualSiteName(
        )
        const
    { return (LPWSTR) m_VirtualSiteName; }

    inline
    DWORD
    GetMemoryReference(
        )
        const
    { return m_MemoryReference; }

    inline
    BOOL
    IsNotActive(
        )
    {
        return m_Visited;
    }

    inline
    VOID
    SetActive(
        BOOL fIsActive
        )
    {
        m_Visited = fIsActive;
    }

    inline
    PLIST_ENTRY
    GetListEntry(
        )
    { 
        return &m_ListEntry; 
    }

    static
    PERF_VIRTUAL_SITE *
    PerfVirtualSiteFromListEntry(
        IN const LIST_ENTRY * pListEntry
        );


#if DBG
    VOID
    DebugDump(
        );

#endif  // DBG


private:
  
    DWORD m_Signature;

    DWORD m_VirtualSiteId;

    DWORD m_MemoryReference;

    WCHAR m_VirtualSiteName[MAX_INSTANCE_NAME];

    //
    // used for building a list of VIRTUAL_SITEs to delete
    // ones that no longer exist.
    //
    LIST_ENTRY m_ListEntry;

    //
    // Tells if we saw this on the last walk of the virtual
    // site.
    //

    BOOL       m_Visited;


};  // class PERF_VIRTUAL_SITE



#endif  // _PERF_VIRTUAL_SITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\perf_manager.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    perf_manager.cxx

Abstract:

    This class manages all the performance counters for W3SVC.

Author:

    Emily Kruglick (EmilyK)       29-Aug-2000

Revision History:

Alignment Notes:

  ( need a place to keep this info so it will live here )

  Coming from UL the data all comes in aligned using structures so
  we do not worry about aligning that data.

  Coming from WP the sites data does not need to be aligned
  because it does not contain ULongs so we do not worry about it. 
  However the Global data ( that follows the sites must start on a
  8 byte boundary, so we do align for it ( see below ) ).

  Going out to perf counters we align by making sure that each
  counter set is divisable by 8 byte.  If a counter gets added
  that would throw this off, we will also add a bogus field.



--*/



#include "precomp.h"
#include "perfcount.h"
#include <Aclapi.h>


//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Mapping of properties from the input struct to the display struct.
//
typedef struct _PROP_MAP
{
    DWORD PropDisplayOffset;
    DWORD PropInputId;
} PROP_MAP;

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Mapping of properties in the display struct
//
typedef struct _PROP_MAX_DESC
{
    ULONG SafetyOffset;
    ULONG DisplayOffset;
    ULONG size;
} PROP_MAX_DESC;


//
// Macros
//


//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Macro defining the max fileds for cache counters
//
#define DECLARE_MAX_GLOBAL(Counter)  \
        {   \
        FIELD_OFFSET( GLOBAL_MAX_DATA, Counter ),\
        FIELD_OFFSET( W3_GLOBAL_COUNTER_BLOCK, Counter ),\
        RTL_FIELD_SIZE( W3_GLOBAL_COUNTER_BLOCK, Counter )\
    }

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Macro defining the mapping of worker process cache counters
// to their display offset.
//
#define WPGlobalMapMacro(display_counter, wp_counter)  \
    { FIELD_OFFSET ( W3_GLOBAL_COUNTER_BLOCK, display_counter), WPGlobalCtrs ## wp_counter }


//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Macro defining the mapping of ul cache counters
// to their display offset.
//
#define ULGlobalMapMacro(display_counter, wp_counter)  \
    { FIELD_OFFSET ( W3_GLOBAL_COUNTER_BLOCK, display_counter), HttpGlobalCounter ## wp_counter }

//
// Global variables
//

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
//
// Mapping of GLOBAL MAX Fields as they are passed in from
// the perf manager to how the fields are displayed out.
//
PROP_MAX_DESC g_aIISGlobalMaxDescriptions[] =
{
    DECLARE_MAX_GLOBAL ( MaxFileCacheMemoryUsage )
};
DWORD g_cIISGlobalMaxDescriptions = sizeof( g_aIISGlobalMaxDescriptions ) / sizeof( PROP_MAX_DESC );

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
//
// Mapping of performance counter data from the form it comes in
// as to the form that it goes out to perfmon as.
//
PROP_MAP g_aIISWPGlobalMappings[] =
{
    WPGlobalMapMacro (CurrentFilesCached, CurrentFilesCached),
    WPGlobalMapMacro (TotalFilesCached, TotalFilesCached),
    WPGlobalMapMacro (FileCacheHits, FileCacheHits),
    WPGlobalMapMacro (FileCacheHitRatio, FileCacheHits),
    WPGlobalMapMacro (FileCacheMisses, FileCacheMisses),
    WPGlobalMapMacro (FileCacheHitRatio, FileCacheMisses),
    WPGlobalMapMacro (FileCacheFlushes, FileCacheFlushes),
    WPGlobalMapMacro (CurrentFileCacheMemoryUsage, CurrentFileCacheMemoryUsage),
    WPGlobalMapMacro (MaxFileCacheMemoryUsage, MaxFileCacheMemoryUsage),
    WPGlobalMapMacro (ActiveFlushedFiles, ActiveFlushedFiles),
    WPGlobalMapMacro (TotalFlushedFiles, TotalFlushedFiles),
    WPGlobalMapMacro (CurrentUrisCached, CurrentUrisCached),
    WPGlobalMapMacro (TotalUrisCached, TotalUrisCached),
    WPGlobalMapMacro (UriCacheHits, UriCacheHits),
    WPGlobalMapMacro (UriCacheHitRatio, UriCacheHits),
    WPGlobalMapMacro (UriCacheMisses, UriCacheMisses),
    WPGlobalMapMacro (UriCacheHitRatio, UriCacheMisses),
    WPGlobalMapMacro (UriCacheFlushes, UriCacheFlushes),
    WPGlobalMapMacro (TotalFlushedUris, TotalFlushedUris),
    WPGlobalMapMacro (CurrentBlobsCached, CurrentBlobsCached),
    WPGlobalMapMacro (TotalBlobsCached, TotalBlobsCached),
    WPGlobalMapMacro (BlobCacheHits, BlobCacheHits),
    WPGlobalMapMacro (BlobCacheHitRatio, BlobCacheHits),
    WPGlobalMapMacro (BlobCacheMisses, BlobCacheMisses),
    WPGlobalMapMacro (BlobCacheHitRatio, BlobCacheMisses),
    WPGlobalMapMacro (BlobCacheFlushes, BlobCacheFlushes),
    WPGlobalMapMacro (TotalFlushedBlobs, TotalFlushedBlobs)
};
DWORD g_cIISWPGlobalMappings = sizeof( g_aIISWPGlobalMappings ) / sizeof( PROP_MAP );

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
//
// Mapping of performance counter data from the form it comes in
// as to the form that it goes out to perfmon as.
//
PROP_MAP g_aIISULGlobalMappings[] =
{
    ULGlobalMapMacro (UlCurrentUrisCached, CurrentUrisCached),
    ULGlobalMapMacro (UlTotalUrisCached, TotalUrisCached),
    ULGlobalMapMacro (UlUriCacheHits, UriCacheHits),
    ULGlobalMapMacro (UlUriCacheHitRatio, UriCacheHits),
    ULGlobalMapMacro (UlUriCacheMisses, UriCacheMisses),
    ULGlobalMapMacro (UlUriCacheHitRatio, UriCacheMisses),
    ULGlobalMapMacro (UlUriCacheFlushes, UriCacheFlushes),
    ULGlobalMapMacro (UlTotalFlushedUris, TotalFlushedUris)
};
DWORD g_cIISULGlobalMappings = sizeof( g_aIISULGlobalMappings ) / sizeof( PROP_MAP );

//
// local prototypes
//

//
// Callback function that runs when the 
// counters timer fires.
//
VOID
PerfCounterTimerCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    );

//
// Callback function that runs when we
// have run out of time to gather the 
// perf counters.
//
VOID
PerfCounterGatheringTimerCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    );

//
// Launched on a separate thread to wait on perf
// counter requests.
//
DWORD WINAPI 
PerfCountPing(
    LPVOID lpParameter
    );

HRESULT
AdjustProcessSecurityToAllowPowerUsersToWait(
    );

//
// Public PERF_MANAGER functions
//

/***************************************************************************++

Routine Description:

    Constructor for the PERF_MANAGER class.

Arguments:

    None

Return Value:

    None.

--***************************************************************************/

PERF_MANAGER::PERF_MANAGER(
    )
{


    m_State = UninitializedPerfManagerState;

    m_hWASPerfCountEvent = NULL;

    m_hPerfCountThread = NULL;

    m_NumProcessesToWaitFor = 0;

    //
    // Set the initial reference count to 1, in order to represent the
    // reference owned by the creator of this instance.
    //

    m_RefCount = 1;

    m_PerfCountThreadId = 0;

    m_PerfCounterTimerHandle = NULL;

    m_PerfCounterGatheringTimerHandle = NULL;

    memset ( &m_MaxGlobalCounters, 0, sizeof( GLOBAL_MAX_DATA ) );

    memset ( &m_GlobalCounters, 0, sizeof( W3_GLOBAL_COUNTER_BLOCK ) );

    m_GlobalCounters.PerfCounterBlock.ByteLength = sizeof (W3_GLOBAL_COUNTER_BLOCK);

    m_pHttpSiteBuffer = NULL;

    m_HttpSiteBufferLen = 0;

    m_NextValidOffset = 0;

    m_InstanceInfoHaveChanged = FALSE;

    m_Signature = PERF_MANAGER_SIGNATURE;

}   // PERF_MANAGER::PERF_MANAGER



/***************************************************************************++

Routine Description:

    Destructor for the PERF_MANAGER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

PERF_MANAGER::~PERF_MANAGER(
    )
{

    DBG_ASSERT( m_Signature == PERF_MANAGER_SIGNATURE );

    m_Signature = PERF_MANAGER_SIGNATURE_FREED;

    DBG_ASSERT ( m_State == UninitializedPerfManagerState ||
                 m_State == TerminallyIllPerfManagerState ||
                 m_State == TerminatingPerfManagerState );
    //
    // Terminate will have Canceled any timers,
    // but we will assert just to make sure terminate
    // got a chance to do it's job.
    //

    DBG_ASSERT ( m_PerfCounterTimerHandle == NULL );

    DBG_ASSERT ( m_PerfCounterGatheringTimerHandle == NULL );

    //
    // This means we are waiting for the thread to exit
    //
    if ( m_hPerfCountThread != NULL )
    {
        WaitForSingleObject (m_hPerfCountThread, INFINITE );
        CloseHandle ( m_hPerfCountThread );
        m_hPerfCountThread = NULL;
    }

    //
    // Since we have finished waiting for the thread
    // to signal we must be done with this event.
    //
    if ( m_hWASPerfCountEvent != NULL )
    {
        CloseHandle ( m_hWASPerfCountEvent );
        m_hWASPerfCountEvent = NULL;
    }

    if ( m_pHttpSiteBuffer != NULL )
    {
        m_HttpSiteBufferLen = 0;

        delete[] m_pHttpSiteBuffer;
        m_pHttpSiteBuffer = NULL;
    }


}   // PERF_MANAGER::~PERF_MANAGER


/***************************************************************************++

Routine Description:

    Increment the reference count for this object. Note that this method must
    be thread safe, and must not be able to fail.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
PERF_MANAGER::Reference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedIncrement( &m_RefCount );

    //
    // The reference count should never have been less than zero; and
    // furthermore once it has hit zero it should never bounce back up;
    // given these conditions, it better be greater than one now.
    //
    
    DBG_ASSERT( NewRefCount > 1 );


    return;

}   // PERF_MANAGER::Reference



/***************************************************************************++

Routine Description:

    Decrement the reference count for this object, and cleanup if the count
    hits zero. Note that this method must be thread safe, and must not be
    able to fail.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
PERF_MANAGER::Dereference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedDecrement( &m_RefCount );

    // ref count should never go negative
    DBG_ASSERT( NewRefCount >= 0 );

    if ( NewRefCount == 0 )
    {
        // time to go away

        IF_DEBUG( WEB_ADMIN_SERVICE_REFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Reference count has hit zero in PERF_MANAGER instance, deleting (ptr: %p; )\n",
                this
                ));
        }


        delete this;


    }


    return;

}   // PERF_MANAGER::Dereference



/***************************************************************************++

Routine Description:

    Execute a work item on this object.

Arguments:

    pWorkItem - The work item to execute.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
PERF_MANAGER::ExecuteWorkItem(
    IN const WORK_ITEM * pWorkItem
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( pWorkItem != NULL );

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Executing work item with serial number: %lu "
            "in PERF_MANAGER (ptr: %p; ) with operation: %p\n",
            pWorkItem->GetSerialNumber(),
            this,
            pWorkItem->GetOpCode()
            ));
    }


    switch ( pWorkItem->GetOpCode() )
    {

    case PerfCounterPingFiredWorkItem:
        hr = ProcessPerfCounterPingFired();
        break;

    case PerfCounterGatheringTimerFiredWorkItem:
        hr = ProcessPerfCounterGatheringTimerFired();
        break;

    default:

        // invalid work item!
        DBG_ASSERT( FALSE );

        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;

    }

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Executing work item on PERF_MANAGER failed\n"
            ));

    }

    return hr;

}   // PERF_MANAGER::ExecuteWorkItem

/***************************************************************************++

Routine Description:

    Initialize the performance counter manager.  Including setting up 
    the first blocks of shared memory for the ctr libraries to use one their
    first requests for our data.  The counters on the first request will 
    all be zero however.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
PERF_MANAGER::Initialize(
        )
{

    HRESULT hr = S_OK;
    DWORD   dwErr = ERROR_SUCCESS;
    DWORD   NumVirtualSites = 0;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT ( m_State == UninitializedPerfManagerState );

    // 
    // Initialize the controller for write access.
    //
    dwErr = m_SharedManager.Initialize(TRUE);
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );
        goto exit;
    }

    // 
    // Initialize the counter sets for tracking
    // the cache and site counters.
    //
    dwErr = m_SharedManager.CreateNewCounterSet(
                                     SITE_COUNTER_SET
                                     );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto exit;
    }

    dwErr = m_SharedManager.CreateNewCounterSet(
                                     GLOBAL_COUNTER_SET
                                     );
    if ( dwErr != ERROR_SUCCESS  )
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto exit;
    }

    //
    // For the global counters we also need to have
    // the memory setup.  The sites memory will be 
    // established in the CompleteCounterUpdate call.
    //

    hr = m_SharedManager.ReallocSharedMemIfNeccessary ( GLOBAL_COUNTER_SET , 1 );
    if ( FAILED ( hr ) )
    {
        //
        // If we fail to re-allocate memory, 
        // then we can not really go on, because
        // we never try again to allocate the 
        // global perf counter files.
        //

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Error allocating global shared memory. "
            "Turning off perf counter publishing, "
            "you must restart w3svc to reactivate them\n"
            ));

        goto exit;
    }

    //
    // Change the state so we will be able to call
    // the completion routine and initialize the memory
    // to zeros.
    //
    m_State = GatheringPerfManagerState;

    //
    // Now tell ourselves that we are done gathering
    // and we are ready to publish the counters.  This
    // will publish all zero's but atleast the page will
    // have the instance information that it needs.
    //
    CompleteCounterUpdate();
    
    hr = AdjustProcessSecurityToAllowPowerUsersToWait();
    if (FAILED (hr))
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to adjust process security thread \n"
            ));

        goto exit;
    }

    //
    // Launch the thread that will wait for pings to tell
    // it to refresh counters.
    //
    hr = LaunchPerfCounterWaitingThread();
    if (FAILED (hr))
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to launch the perf counter waiting thread \n"
            ));

        goto exit;
    }

    //
    // Setup a timer that will remind us every so often to
    // gather counters, whether or not we are being asked
    // to publish them.
    //
    hr = BeginPerfCounterTimer();
    if (FAILED (hr))
    {
        //
        // If we fail, we will log an event, but we will still 
        // continue to deliver counters because if no process 
        // crash they will be accurate.
        //

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_PERF_COUNTER_TIMER_FAILURE,               // message id
                0,                                            // count of strings
                NULL,                                         // array of strings
                hr                                            // error code
                );

        hr = S_OK;
    }

exit:

    if ( FAILED (hr) )
    {
        m_State = TerminallyIllPerfManagerState;
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {

        DBGPRINTF((
            DBG_CONTEXT, 
            "Initializing the Perf Manager is returning: %x\n",
            hr
            ));

    }

    return hr;

}   // PERF_MANAGER::Initialize


/***************************************************************************++

Routine Description:

    Routine will go through the blob of data provide by a worker process
    and will determine what counters need to be updated.  
    It will then update those counters.

Arguments:

    IN DWORD MessageLength - Number of bytes in the blob following.
    IN LPVOID MessageData  - The data that will be merged with the counters.

Return Value:

    VOID

--***************************************************************************/
VOID 
PERF_MANAGER::RecordCounters(
    IN DWORD MessageLength,
    IN const BYTE* pMessageData
    )
{
    //
    // Counters can come in while we are not gathering, however
    // we should make sure counters don't come in when we are not
    // gathering or idle.
    //
    DBG_ASSERT ( m_State == GatheringPerfManagerState ||
                 m_State == IdlePerfManagerState );

    //
    // MessageLength can be zero if a sick worker process is 
    // just trying to take himself out of the count of worker processes
    // to wait on.
    //

    if ( MessageLength != 0 )
    {
        IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Received message with length %d\n",
                MessageLength
                ));
        }

        // First piece of the message is the number of instances.
        // Second piece will be an instances data.
        // Use the instances data to identify the instance and then
        // let the aggregation code add the counters in for that instance.

        DBG_ASSERT(pMessageData);

        //
        // Validate that we at least have the number of counters in the message.
        //
        DBG_ASSERT( MessageLength >= sizeof(DWORD) );

        DWORD NumInstances = *((DWORD*)pMessageData);

        //
        // Next reference the first set of site counters.
        //
        IISWPSiteCounters* pSiteCounters = 
                    (IISWPSiteCounters*)(((LPBYTE) pMessageData ) + sizeof(DWORD));

        IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Message contains %d sites\n",
                *(DWORD*)pMessageData
                ));
        }

        //
        // Loop through all instances processing the counters into 
        // the virtual site objects.
        //
        for (DWORD i = 0; i < NumInstances; i++, pSiteCounters++)
        {
            //
            // Make sure there is enough message left to really contain
            // the site counter information.  It is really bad if we think
            // we have more instances than we do data.
            //
            DBG_ASSERT (MessageLength >= 
                        sizeof(DWORD) + sizeof(IISWPSiteCounters) * (i + 1));

            //
            // Debug mode printing of counter values.
            //
            DumpWPSiteCounters(pSiteCounters);

            //
            // Once we have verified we have enough room, we can then
            // process the counters.
            //
            FindAndAggregateSiteCounters( WPCOUNTERS, 
                                          pSiteCounters->SiteID, 
                                          pSiteCounters );       
        }

        //
        // Following sites will be the global counters.
        //
        IISWPGlobalCounters* pGlobalCounters = (IISWPGlobalCounters*) 
                                               ( (LPBYTE) pMessageData 
                                                + sizeof(DWORD)
                                                + (NumInstances * sizeof (IISWPSiteCounters)));

        //
        // Global counters contain some ULONGLONG values so we align it to
        // ULONGLONG and that is how the wp sends in the value too
        //
        pGlobalCounters = (IISWPGlobalCounters *)(((DWORD_PTR)pGlobalCounters + 7) & ~7);

        IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "pGlobalCounters = %x, sizeof(IISWPGlobalCounters) = %d, pMessageData = %x\n",
                pGlobalCounters,
                sizeof(IISWPGlobalCounters),
                pMessageData
                ));
        }

        //
        // Make sure we have exactly enough space left for the global counters to exist.
        // 
        DBG_ASSERT ( ((LPBYTE)pGlobalCounters  
                    + sizeof(IISWPGlobalCounters) 
                     - (LPBYTE)pMessageData) 
                     == MessageLength );
      
        //
        // Debug mode printing of the counters.
        //
        DumpWPGlobalCounters( pGlobalCounters );

        //
        // Things look good, go ahead and add in the global
        // counter values.
        //

        AggregateGlobalCounters ( WPCOUNTERS, (LPVOID) pGlobalCounters );
    }

    // 
    // Once done with recording the counters we need to decrement
    // the number of worker processe we are waiting on.  This is done
    // whether or not counters were received because we could just be
    // attempting to take a sick wp out of the waiting loop.
    //

    DecrementWaitingProcesses();

} // End of PERF_MANAGER::RecordCounters

/***************************************************************************++

Routine Description:

    Terminates the perf manager.  This function will tell the waiting thread
    to terminate and will clean up the perf virtual site table.  However it will
    not wait for the waiting thread to terminate.  That is left for the destructor.

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_MANAGER::Terminate()
{
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT ( m_State == GatheringPerfManagerState ||
                 m_State == IdlePerfManagerState );

    //
    // Note:  There is no guarantee that initialize was called
    //        before this is called, so do not assume anything
    //        has been setup in here.
    //

    m_State = TerminatingPerfManagerState;

    //
    // While CancelPerfCounterTimer will return an hresult, all
    // we would do with it is write some debug spew, and the Cancel
    // routine has all ready written that spew, so we will just
    // ignore it's return value.
    //
    CancelPerfCounterTimer();

    //
    // If we have launched a gathering counter, then we need to 
    // cancel it as well since we are shutting down.
    //
    CancelPerfCounterGatheringTimer();

    if ( m_hWASPerfCountEvent )
    {
        //
        // We will ping the event so we can stop 
        // waiting for requests for data.  The fact
        // that we are in the terminating state will
        // have free up the thread to exit.
        //
        if (!SetEvent(m_hWASPerfCountEvent))
        {
            DPERROR((
                DBG_CONTEXT,
                GetLastError(),
                "Failed to set the event to tell the perf counter thread to complete \n"
                ));
        }

    }

    //
    // Tell the shared memory that the memory it has is no longer valid, but
    // don't give it new memory.  This will cause it to start returning nothing.
    // It will also leave it in a state to return data if we come up data later.
    //

    m_SharedManager.StopPublishing();

    //
    // The destructors will let go of all shared memory.
    //
} // end PERF_MANAGER::Terminate

/***************************************************************************++

Routine Description:

    Copies in the the counter information for a particular instance
    of the counters represented by the VirtualSite that is passed in.

Arguments:

    IN VIRTUAL_SITE* pVirtualSite - A pointer to the VirtualSite
                                    that we are working with.

    IN BOOL          StructChanged - Tells if we need to relay the instance
                                     header information as well as resetting
                                     the offset for the site.

    IN ULONG*        pMemoryOffset - Used to figure out where the counter's
                                      information actually goes in the files.

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_MANAGER::SetupVirtualSite(
    IN VIRTUAL_SITE* pVirtualSite
    )
{

    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    // verify that we are actually gathering and thus
    // should be publishing.
    DBG_ASSERT ( m_State == GatheringPerfManagerState );

    // Make sure we have a virtual site to work with.
    DBG_ASSERT( pVirtualSite != NULL );

    //
    // If the structure changed then we need to 
    // save the new memory offset with the virtual
    // site, so we won't have to figure it out again
    // until the next structural change.
    //
    if ( m_InstanceInfoHaveChanged ) 
    {
        pVirtualSite->SetMemoryOffset( m_NextValidOffset );
    }


    LPWSTR pServerComment = NULL;
    if ( pVirtualSite->CheckAndResetServerCommentChanged() || m_InstanceInfoHaveChanged )
    {
        // Write in the server comment.
        pServerComment = pVirtualSite->GetVirtualSiteName();
    }

    // 
    // Setup the Instance Counter Information
    // This will copy in the instance name, as well as setting
    // up the instance header block.  It will also copy
    // over the counter values.
    // 

    m_SharedManager.CopyInstanceInformation( 
                                  SITE_COUNTER_SET
                                , pServerComment
                                , pVirtualSite->GetMemoryOffset()
                                , pVirtualSite->GetCountersPtr()
                                , pVirtualSite->GetDisplayMap()
                                , pVirtualSite->GetSizeOfDisplayMap()
                                , m_InstanceInfoHaveChanged 
                                , &m_NextValidOffset );


}

/***************************************************************************++

Routine Description:

    Routine will setup the _Total Instance for sites.

Arguments:

    IN BOOL          StructChanged - Tells if we need to relay the instance
                                     header information.

    IN ULONG*        pMemoryOffset - Used to figure out where the counter's
                                      information actually goes in the files.

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_MANAGER::SetupTotalSite(
    IN BOOL          StructChanged
    )
{

    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    // we are publishing so counters so we had better be in 
    // the gathering state.
    DBG_ASSERT ( m_State == GatheringPerfManagerState );

    //
    // remember if we are dealing with a structural change.
    //
    m_InstanceInfoHaveChanged = StructChanged;

    // 
    // Setup the Instance Counter Information
    // This will copy in the instance name, as well as zero'ing
    // all the counter values and correctly adjusting byte lengths
    // in the data header.
    //
    // Note, unlike the instance case in the function above
    // we do not pass counters here.  They will be aggregated
    // from the specific instance counters.
    // 
    m_SharedManager.CopyInstanceInformation( 
                                  SITE_COUNTER_SET
                                , L"_Total"
                                , 0       // the _TotalSite is always the 0 offset.
                                , NULL
                                , NULL
                                , 0
                                , m_InstanceInfoHaveChanged 
                                , &m_NextValidOffset );


}

//
// Private PERF_MANAGER functions
//


/***************************************************************************++

Routine Description:

    Routine determines where the global counters came from and
    aggregates them into the correct holding block.

Arguments:

    COUNTER_SOURCE_ENUM CounterSource - Identifier of the where
                                        the counters are coming from. (WP or UL)
    IN LPVOID pCountersToAddIn - Cache counters in either the Wp or UL structure.

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_MANAGER::AggregateGlobalCounters(
    COUNTER_SOURCE_ENUM CounterSource, 
    IN LPVOID pCountersToAddIn
    )
{
    //
    // Validate that we are in a mode where we can 
    // receive counters.
    //
    DBG_ASSERT ( m_State == GatheringPerfManagerState ||
                 m_State == IdlePerfManagerState );

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    HTTP_PROP_DESC* pInputPropDesc = NULL;
    PROP_MAP*       pPropMap = NULL;
    DWORD           MaxCounters = 0;

    //
    // Choose the appropriate counter definitions
    // to navigate through the counters and aggregate
    // them into the display counters.
    //
    if ( CounterSource == WPCOUNTERS )
    {
        pInputPropDesc = aIISWPGlobalDescription;
        pPropMap = g_aIISWPGlobalMappings;
        MaxCounters = sizeof ( g_aIISWPGlobalMappings ) / sizeof ( PROP_MAP ); 
    }
    else
    {
        DBG_ASSERT ( CounterSource == ULCOUNTERS );

        pInputPropDesc = aIISULGlobalDescription;
        pPropMap = g_aIISULGlobalMappings;
        MaxCounters = sizeof ( g_aIISULGlobalMappings ) / sizeof ( PROP_MAP ); 
    }

    //
    // Retrieve a pointer to the global counters structure
    // that holds the counters before they go to shared memory.
    //
    LPVOID pCounterBlock = &m_GlobalCounters;

    DWORD PropInputId = 0;

    for (  DWORD PropDisplayId = 0; 
            PropDisplayId < MaxCounters; 
            PropDisplayId++ )
    {
        // 
        // Figure out for this display entry what the
        // entry in the incoming mapping array is.
        //
        PropInputId = pPropMap[PropDisplayId].PropInputId;

        //
        // Depending on the size of the property we are
        // dealing with, handle the update.
        //
        if ( pInputPropDesc[PropInputId].Size == sizeof( DWORD ) )
        {

            DWORD* pDWORDToUpdate = (DWORD*) ( (LPBYTE) pCounterBlock 
                                + pPropMap[PropDisplayId].PropDisplayOffset );

            DWORD* pDWORDToUpdateWith =  (DWORD*) ( (LPBYTE) pCountersToAddIn 
                                + pInputPropDesc[PropInputId].Offset );

            //
            // Based on current configuration of the system.  
            // This is happinging on the main thread.
            // which means that more than one can not happen 
            // at the same time so it does not need to be
            // an interlocked exchange.
            //

            *pDWORDToUpdate = *pDWORDToUpdate + *pDWORDToUpdateWith;


        }
        else
        {
            DBG_ASSERT ( pInputPropDesc[PropInputId].Size == 
                                                    sizeof( ULONGLONG ) );

            ULONGLONG* pQWORDToUpdate = (ULONGLONG*) ( (LPBYTE) pCounterBlock 
                               + pPropMap[PropDisplayId].PropDisplayOffset );

            ULONGLONG* pQWORDToUpdateWith =  
                                    (ULONGLONG*) ( (LPBYTE) pCountersToAddIn 
                                      + pInputPropDesc[PropInputId].Offset );

            //
            // Based on current configuration of the system.  
            // This is happinging on the main thread.
            // which means that more than one can not happen 
            // at the same time so it does not need to be
            // an interlocked exchange.
            //


            *pQWORDToUpdate = *pQWORDToUpdate + *pQWORDToUpdateWith;

        }
            
    }

}  // End of AggregateGlobalCounters

/***************************************************************************++

Routine Description:

    Routine will look up a particular site's counter block and will
    aggregate in the counters for that block.

Arguments:

    IN IISWPSiteCounters* pCounters - counters to add in.

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_MANAGER::FindAndAggregateSiteCounters(
    COUNTER_SOURCE_ENUM CounterSource,
    DWORD SiteId,
    IN LPVOID pCounters
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT ( m_State == GatheringPerfManagerState ||
                 m_State == IdlePerfManagerState );

    DBG_ASSERT ( SiteId != 0 );
    //
    // The virtual site returned is not ref counted so it is only
    // valid to use during this work item, on the main thread.
    //
    VIRTUAL_SITE* pVirtualSite = GetWebAdminService()->
                                GetUlAndWorkerManager()->
                                GetVirtualSite(SiteId);

    //
    // It is completely possible to get counters for a Site we no longer
    // think exists.  If this is the case then we simply ignore the counters.
    //
    if ( pVirtualSite )
    {
        pVirtualSite->AggregateCounters ( CounterSource, pCounters );
    }

}


/***************************************************************************++

Routine Description:

    Whenever a worker process that we are waiting for responds with perf
    counters, we decrement the number of waiting processes.  If the count
    hits zero than we know we can go ahead and publish the counters.  If 
    a worker process responds that we are not waiting for, we may still 
    process the counters, but we do not affect the overall count, nor can it
    trigger us to publish counters.

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/
VOID 
PERF_MANAGER::DecrementWaitingProcesses(
    )
{ 
    //
    // If we get a report on counters and are not
    // in the gathering state, then it really doesn't 
    // matter to our count, so don't bother changing it.
    //
    if ( m_State == GatheringPerfManagerState )
    {
        m_NumProcessesToWaitFor--;

        if ( m_NumProcessesToWaitFor == 0 )
        {
            CompleteCounterUpdate();
        }
    }
}


/***************************************************************************++

Routine Description:

    Launches the perf counter waiting thread that will let us know
    when the perf library wants counters refreshed.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
PERF_MANAGER::LaunchPerfCounterWaitingThread(
    )
{
    HRESULT hr = S_OK;
    DWORD   dwErr = ERROR_SUCCESS;

    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
    PSID psidPowerUser = NULL;
    PSID psidSystemOperator = NULL;
    PSID psidLocalSystem = NULL;
    PSID psidAdmin = NULL;
    PACL pACL = NULL;

    EXPLICIT_ACCESS ea[4];   // Setup four explicit access objects

    SECURITY_DESCRIPTOR sd = {0};
    SECURITY_ATTRIBUTES sa = {0};

    //
    // This is called right after our initalization sets up the first
    // blocks of counter memory.  It will leave it in the Idle state
    // before calling this.
    //
    DBG_ASSERT ( m_State == IdlePerfManagerState );

    //
    // Handle setting up security for the request perf counter
    // event.  Power Users will be allowed to write to the event
    // so they can Set / Reset the event.  Local System will have
    // full access.
    //

    //
    // Get a sid that represents the Administrators group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinAdministratorsSid,
                                        &psidAdmin );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32(dwErr);

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating Administrator SID failed\n"
            ));

        goto exit;
    }

    //
    // Get a sid that represents the POWER_USERS group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinPowerUsersSid,
                                        &psidPowerUser );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32(dwErr);

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating Power User SID failed\n"
            ));

        goto exit;
    }


    //
    // Get a sid that represents the SYSTEM_OPERATORS group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinSystemOperatorsSid, 
                                        &psidSystemOperator );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32(dwErr);

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating System Operators SID failed\n"
            ));

        goto exit;
    }

    
    //
    // Get a sid that represents LOCAL_SYSTEM.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinLocalSystemSid,
                                        &psidLocalSystem );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32(dwErr);

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating Local System SID failed\n"
            ));

        goto exit;
    }
    
    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    // The ACE will allow Everyone read access to the key.

    ZeroMemory(&ea, sizeof(ea));

    //
    // Setup POWER_USERS for read access.
    //
    SetExplicitAccessSettings(  &(ea[0]), 
                                EVENT_MODIFY_STATE,
                                SET_ACCESS,
                                psidPowerUser );

    //
    // Setup Administrators for read access.
    //
    SetExplicitAccessSettings(  &(ea[1]), 
                                EVENT_MODIFY_STATE,
                                SET_ACCESS,
                                psidAdmin );

    //
    // Setup System Operators for read access.
    //
    SetExplicitAccessSettings(  &(ea[2]), 
                                EVENT_MODIFY_STATE,
                                SET_ACCESS,
                                psidSystemOperator );
  
    //
    // Setup Local System for all access.
    //
    SetExplicitAccessSettings(  &(ea[3]), 
                                EVENT_ALL_ACCESS,
                                SET_ACCESS,
                                psidLocalSystem );
    //
    // Create a new ACL that contains the new ACEs.
    //
    dwErr = SetEntriesInAcl(sizeof(ea)/sizeof(EXPLICIT_ACCESS), ea, NULL, &pACL);
    if ( dwErr != ERROR_SUCCESS ) 
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting ACE's into ACL failed.\n"
            ));

        goto exit;
    }

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) 
    {  
        hr = HRESULT_FROM_WIN32(GetLastError());
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing the security descriptor failed\n"
            ));

        goto exit;
    } 

    if (!SetSecurityDescriptorDacl(&sd, 
            TRUE,     // fDaclPresent flag   
            pACL, 
            FALSE))   // not a default DACL 
    {  
        hr = HRESULT_FROM_WIN32(GetLastError());
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting the DACL on the security descriptor failed\n"
            ));

        goto exit;
    } 

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle = FALSE;

    m_hWASPerfCountEvent = CreateEvent(&sa, TRUE, FALSE, COUNTER_EVENT_W);
    if ( ( GetLastError() == ERROR_ALREADY_EXISTS )
           || m_hWASPerfCountEvent == NULL )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        //
        // Since the perf lib will be letting go of events and memorys when 
        // we shutdown, we do not expect it to every hold this event open.
        // Therefore if we can't create it then we don't trust to use it.
        //
        // Someone else may create it for us, but then they will just receive
        // the pings for needing new counters.
        //
        // Needs Security Review.

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating perf counter event failed.\n"
            ));

        // eventually should log an error to the event log
        // this will disable counters completely.
        goto exit;

    }
    
    m_hPerfCountThread = CreateThread(   NULL           // use current threads security
                                        , 0             // use default stack size
                                        , &PerfCountPing
                                        , this          // pass this object in.
                                        , 0             // don't create suspended
                                        , &m_PerfCountThreadId);
    if (m_hPerfCountThread == NULL)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError());
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not spin up thread to wait for event\n"
            ));

        goto exit;
    }

exit:
    
    //
    // Clean up the security handles used.
    //

    //
    // Function will only free if the 
    // variable is set.  And it will set
    // the variable to NULL once it is done.
    //
    FreeWellKnownSid(&psidPowerUser);
    FreeWellKnownSid(&psidSystemOperat