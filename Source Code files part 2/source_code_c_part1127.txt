 install section.
    //
    if(!(InstallSection = pSetupGetField(LineContext, 3))) {
        return GetLastError();
    }

    //
    // Locate the service install section.
    //
    hInf = LineContext->Inf;

    //
    // Retrieve the required values from this section.  Don't do validation on them--leave
    // that up to the Service Control Manager.
    //
    if(!SetupFindFirstLine(hInf, InstallSection, pszServiceType, &InstallSectionContext) ||
       !SetupGetIntField(&InstallSectionContext, 1, (PINT)&ServiceType)) {
        return ERROR_BAD_SERVICE_INSTALLSECT;
    }

    if(!SetupFindFirstLine(hInf, InstallSection, pszStartType, &InstallSectionContext) ||
       !SetupGetIntField(&InstallSectionContext, 1, (PINT)&StartType)) {
        return ERROR_BAD_SERVICE_INSTALLSECT;
    }

    if(!SetupFindFirstLine(hInf, InstallSection, pszErrorControl, &InstallSectionContext) ||
       !SetupGetIntField(&InstallSectionContext, 1, (PINT)&ErrorControl)) {
        return ERROR_BAD_SERVICE_INSTALLSECT;
    }

    BinaryInSysRoot = FALSE;
    if(SetupFindFirstLine(hInf, InstallSection, pszServiceBinary, &InstallSectionContext) &&
       (ServiceBinary = pSetupGetField(&InstallSectionContext, 1)) && *ServiceBinary) {
        //
        // Compare the initial part of this path with the WindowsDirectory path.  If they're
        // the same, then we strip off that part (including the dividing backslash), and use
        // the rest of the path for the subsequent calls to SCM.  This allows SCM to assign
        // the special path to the binary, that is accessible, at any time (i.e, boot-loader on).
        //
        ActualBinary = ServiceBinary;

        PathLen = lstrlen(WindowsDirectory);
        MYASSERT(PathLen);

        //
        // Make sure that the it is possible for the WindowsDirectory to fit in the ServiceBinary
        // path string.
        //
        if(PathLen < lstrlen(ServiceBinary)) {
            //
            // There will never be a trailing backslash in the WindowsDirectory path, unless the
            // installation is at the root of a drive (e.g., C:\).  Check this, just to be
            // on the safe side.
            //
            // DBCS-unfriendly code ahead.  This isn't a problem in the ANSI version of
            // setupapi presently, because there's no such thing as service installation on Win9x.
            //
            b = (WindowsDirectory[PathLen - 1] == TEXT('\\'));

            if(b || (ServiceBinary[PathLen] == TEXT('\\'))) {
                //
                // The path prefix is in the right format--now we need to see if the two
                // paths actually match. Copy just the prefix part to another buffer, so
                // that we can do the comparison.
                //
                CopyMemory(ServiceBinaryBuffer, ServiceBinary, PathLen * sizeof(TCHAR));
                ServiceBinaryBuffer[PathLen] = TEXT('\0');

                if(!lstrcmpi(WindowsDirectory, ServiceBinaryBuffer)) {
                    //
                    // We have a match--take the relative part of the path (relative to SystemRoot),
                    // and do one of the following:
                    //
                    // 1. If it's a driver, simply use the relative part (no preceding backslash).
                    // This tells the bootloader/NtLoadDriver that the path is relative to the
                    // SystemRoot, so the driver can be loaded no matter what phase it's loaded in.
                    //
                    // 2. If it's a Win32 service, prepend a %SystemRoot%, so that the service will
                    // still be able to start if the drive letter mappings change.
                    //
                    ServiceBinary += PathLen;
                    if(!b) {
                        ServiceBinary++;
                    }

                    if(ServiceType & SERVICE_WIN32) {
                        CopyMemory(ServiceBinaryBuffer, pszSystemRoot, sizeof(pszSystemRoot) - sizeof(TCHAR));
                        lstrcpy(ServiceBinaryBuffer + CSTRLEN(pszSystemRoot), ServiceBinary);
                        ServiceBinary = ServiceBinaryBuffer;
                    }

                    BinaryInSysRoot = TRUE;
                }
            }
        }

    } else {
        return ERROR_BAD_SERVICE_INSTALLSECT;
    }

    //
    // If this is a driver, then it has to be located under SystemRoot.
    //
    if(ServiceType & (SERVICE_KERNEL_DRIVER | SERVICE_FILE_SYSTEM_DRIVER)) {
        if(!BinaryInSysRoot) {
            //
            // service install section is wrong, driver path is bad
            //
            return ERROR_BAD_SERVICE_INSTALLSECT;
        }
#ifdef UNICODE
        if(DevInst) {
            if(!FileExists(ActualBinary,NULL)) {
                //
                // service install section is wrong, it doesn't point to existing
                // binary
                //
                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_ERROR,
                    MSG_LOG_MISSING_DRIVER,
                    NULL,
                    ServiceName,
                    ActualBinary
                    );
                return ERROR_BAD_SERVICE_INSTALLSECT;
            }
            if(!IsNativeDriver(ActualBinary)) {
                //
                // oh oh, we've come this far, only to find that we're going to try and use
                // a non-native or bad driver
                //
                // we might be able to revert original binary if there was one
                //
                if(pSetupRestoreLastKnownGoodFile(ActualBinary,0,LogContext)
                   && IsNativeDriver(ActualBinary)) {
                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_ERROR,
                        MSG_LOG_REVERTED_BAD_DRIVER,
                        NULL,
                        ServiceName,
                        ActualBinary
                        );
                } else {
                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_ERROR,
                        MSG_LOG_HAVE_BAD_DRIVER,
                        NULL,
                        ServiceName,
                        ActualBinary
                        );
                }
                return ERROR_DRIVER_NONNATIVE;
            }
        }
#endif
    }
    //
    // if this is a boot start driver, we need a reboot for it to start running
    //
    if (StartType == SERVICE_BOOT_START) {
        NeedsReboot = TRUE;
    }

    //
    // Now check for the other, optional, parameters.
    //
    if(SetupFindFirstLine(hInf, InstallSection, pszDisplayName, &InstallSectionContext)) {
        if((DisplayName = pSetupGetField(&InstallSectionContext, 1)) && !(*DisplayName)) {
            DisplayName = NULL;
        }
    }

    if(SetupFindFirstLine(hInf, InstallSection, pszLoadOrderGroup, &InstallSectionContext)) {
        if((LoadOrderGroup = pSetupGetField(&InstallSectionContext, 1)) && !(*LoadOrderGroup)) {
            LoadOrderGroup = NULL;
        }
    }

    if(SetupFindFirstLine(hInf, InstallSection, pszSecurity, &InstallSectionContext)) {
        if((Security = pSetupGetField(&InstallSectionContext, 1)) && !(*Security)) {
            Security = NULL;
        }
    }

    if(SetupFindFirstLine(hInf, InstallSection, pszDescription, &InstallSectionContext)) {
        if((Description = pSetupGetField(&InstallSectionContext, 1)) && !(*Description)) {
            Description = NULL;
        }
    }

    //
    // Only retrieve the StartName parameter for kernel-mode drivers and win32 services.
    //
    if(ServiceType & (SERVICE_KERNEL_DRIVER | SERVICE_FILE_SYSTEM_DRIVER | SERVICE_WIN32)) {

        if(SetupFindFirstLine(hInf, InstallSection, pszStartName, &InstallSectionContext)) {
            if((StartName = pSetupGetField(&InstallSectionContext, 1)) &&
               !(*StartName)) {

                StartName = NULL;
            }
        }
    }

    //
    // We now need to retrieve the multi-sz list of dependencies.  This requires memory allocation,
    // so we include everything from here on out in try/except, so that we can do proper clean-up
    // in case we encounter an inpage error.
    //
    DependenciesBuffer = NULL;
    SCMHandle = ServiceHandle = NULL;
    SCLock = NULL;
    hKeyService = hKeyEventLog = NULL;
    Err = NO_ERROR;
    NewService = FALSE;
    ServiceConfig = NULL;
    try {

        if(!(DependenciesBuffer = GetMultiSzFromInf(hInf, InstallSection, pszDependencies, &b)) && b) {
            //
            // Then we failed to retrieve a dependencies list because of an out-of-memory error.
            //
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        //
        // We've now retrieved all parameters necessary to create a service.
        //
        if(!(SCMHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS))) {
            Err = GetLastError();
            WriteLogEntry(
                LogContext,
                DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                MSG_LOG_ADDSERVSCM_ERROR,
                NULL);
            WriteLogError(
                LogContext,
                DRIVER_LOG_ERROR,
                Err);
            goto clean0;
        }

        //
        // Only generate a tag for this service if it has a load order group, and is a kernel or
        // filesystem driver.
        //
        ServiceHasTag = (LoadOrderGroup &&
                         (ServiceType & (SERVICE_KERNEL_DRIVER | SERVICE_FILE_SYSTEM_DRIVER)));

        NewTag = ServiceHasTag ? &TagId : NULL;

        ServiceHandle = CreateService(SCMHandle,
                                      ServiceName,
                                      DisplayName,
                                      SERVICE_CHANGE_CONFIG,
                                      ServiceType,
                                      StartType,
                                      ErrorControl,
                                      ServiceBinary,
                                      LoadOrderGroup,
                                      NewTag,
                                      DependenciesBuffer,
                                      StartName,
                                      NULL
                                     );
        if(ServiceHandle) {
            NewService = TRUE;
            NewSvcNameNode.Next = NULL;
            NewSvcNameNode.DeleteEventLog = FALSE;
            lstrcpy(NewSvcNameNode.Name, ServiceName);

#ifdef UNICODE
            if( Security ){
                //
                // Log security being set.
                //
                if( NO_ERROR != (Err = pSetupCallSCE( ST_SCE_SERVICES, ServiceName, NULL, Security, StartType, NULL )) ) {
                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                        MSG_LOG_ADDSERVSECURE_ERROR,
                        NULL,
                        ServiceName
                        );
                    WriteLogError(
                        LogContext,
                        DRIVER_LOG_ERROR,
                        Err);

                    goto clean0;
                }
            }
#endif

            WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_VERBOSE,
                        MSG_LOG_ADDSERVCREATE_OK,
                        NULL,
                        ServiceName
                        );

        } else {
            //
            // If we were unable to create the service, then check to see if the service already
            // exists.  If so, all we need to do is change the configuration parameters in the
            // service.
            //
            if((Err = GetLastError()) != ERROR_SERVICE_EXISTS) {

                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                    MSG_LOG_ADDSERVCREATE_ERROR,
                    NULL,
                    ServiceName
                    );
                WriteLogError(
                    LogContext,
                    DRIVER_LOG_ERROR,
                    Err);

                goto clean0;
            }

            //
            // Lock the service database.
            //
            if(NO_ERROR != (Err = pAcquireSCMLock(SCMHandle, &SCLock, LogContext))) {
                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                    MSG_LOG_ADDSERVLOCK_ERROR,
                    NULL
                    );
                WriteLogError(
                    LogContext,
                    DRIVER_LOG_ERROR,
                    Err);
                goto clean0;
            }

            if(!(ServiceHandle = OpenService(SCMHandle, ServiceName, SERVICE_ALL_ACCESS))) {
                Err = GetLastError();
                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                    MSG_LOG_ADDSERVOPEN_ERROR,
                    NULL,
                    ServiceName
                    );
                WriteLogError(
                    LogContext,
                    DRIVER_LOG_ERROR,
                    Err);
                goto clean0;
            }

            if((Err = pSetupRetrieveServiceConfig(ServiceHandle, &ServiceConfig)) != NO_ERROR) {
                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                    MSG_LOG_ADDSERVCONFIG_ERROR,
                    NULL,
                    ServiceName
                    );
                WriteLogError(
                    LogContext,
                    DRIVER_LOG_ERROR,
                    Err);
                //
                // Make sure our ServiceConfig pointer is still NULL.
                //
                ServiceConfig = NULL;
                goto clean0;
            }

            //
            // Since this is an existing driver, then it may already have a perfectly good tag.  If
            // so, we don't want to disturb it.
            //
            if(ServiceHasTag) {

                if(ServiceConfig->lpLoadOrderGroup && *(ServiceConfig->lpLoadOrderGroup)) {
                    //
                    // The service already has a load order group specified.
                    // Check to see whether the load order group 'noclobber'
                    // flag is set.
                    //
                    if(ServiceInstallFlags & SPSVCINST_NOCLOBBER_LOADORDERGROUP) {
                        //
                        // We should leave the existing load order group as-is.
                        // We do this by replacing the INF-specified one with the
                        // previously-existing one.  That way, our code below will
                        // still generate a tag if necessary.
                        //
                        LoadOrderGroup = ServiceConfig->lpLoadOrderGroup;
                    }

                    if(!lstrcmpi(ServiceConfig->lpLoadOrderGroup, LoadOrderGroup) && ServiceConfig->dwTagId) {
                        //
                        // The load order group hasn't changed, and there's already a tag assigned, so
                        // leave it alone.
                        //
                        NewTag = NULL;
                        TagId = ServiceConfig->dwTagId;
                    }
                }
            }

            if(ServiceInstallFlags & SPSVCINST_NOCLOBBER_DISPLAYNAME) {
                //
                // If the service already has a display name, then we don't want
                // to overwrite it.
                //
                if(ServiceConfig->lpDisplayName && *(ServiceConfig->lpDisplayName)) {
                    DisplayName = NULL;

                }
            }

            if(ServiceInstallFlags & SPSVCINST_NOCLOBBER_DEPENDENCIES) {
                //
                // If the service already has a dependencies list, then we don't
                // want to overwrite it.
                //
                if(ServiceConfig->lpDependencies && *(ServiceConfig->lpDependencies)) {
                    MyFree(DependenciesBuffer);
                    DependenciesBuffer = NULL;
                }
            }

            if(!ChangeServiceConfig(ServiceHandle,
                                    ServiceType,
                                    (ServiceInstallFlags & SPSVCINST_NOCLOBBER_STARTTYPE)
                                        ? SERVICE_NO_CHANGE : StartType,
                                    (ServiceInstallFlags & SPSVCINST_NOCLOBBER_ERRORCONTROL)
                                        ? SERVICE_NO_CHANGE : ErrorControl,
                                    ServiceBinary,
                                    LoadOrderGroup,
                                    NewTag,
                                    DependenciesBuffer,
                                    StartName,
                                    TEXT(""),
                                    DisplayName)) {

                Err = GetLastError();
                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                    MSG_LOG_ADDSERVCHANGE_ERROR,
                    NULL,
                    ServiceName
                    );
                WriteLogError(
                    LogContext,
                    DRIVER_LOG_ERROR,
                    Err);
                goto clean0;
            } else {
                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_VERBOSE,
                    MSG_LOG_ADDSERVCHANGE_OK,
                    NULL,
                    ServiceName
                    );

            }
#ifdef UNICODE
            if( Security && (ServiceInstallFlags & SPSVCINST_CLOBBER_SECURITY)){
                //
                // Set/log security
                // in this scenario, service was already running
                // so don't fail if we can't change security
                //
                if( NO_ERROR != (Err = pSetupCallSCE( ST_SCE_SERVICES,
                                                        ServiceName,
                                                        NULL,
                                                        Security,
                                                        (ServiceInstallFlags & SPSVCINST_NOCLOBBER_STARTTYPE)
                                                           ? ServiceConfig->dwStartType
                                                           : StartType,
                                                        NULL )) ) {
                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                        MSG_LOG_ADDSERVSECURE_ERROR,
                        NULL,
                        ServiceName
                        );
                    WriteLogError(
                        LogContext,
                        DRIVER_LOG_ERROR,
                        Err);

                    //goto clean0;
                }
            }
#endif


        }

        //
        // we've added/updated the service, now handle the description, which is an oddball
        // parameter since it's a new parameter and isn't present in the prior calls.
        //
        //
        // we ignore failure at this point since this won't effect operation of the service.
        //
#ifdef UNICODE
        if ((NewService && Description) || ((ServiceInstallFlags & SPSVCINST_NOCLOBBER_DESCRIPTION) == 0)) {
            SERVICE_DESCRIPTION ServiceDescription;

            ServiceDescription.lpDescription = (LPTSTR)Description;
            ChangeServiceConfig2(ServiceHandle, SERVICE_CONFIG_DESCRIPTION,&ServiceDescription);

        }
#endif


        //
        // We've successfully created/updated the service.  If this service has a load order group
        // tag, then make sure it's in the appropriate GroupOrderList entry.
        //
        // (We ignore failure here, since the service should still work just fine without this.)
        //
        if(ServiceHasTag) {
            pSetupAddTagToGroupOrderListEntry(LoadOrderGroup,
                                        TagId,
                                        ServiceInstallFlags & SPSVCINST_TAGTOFRONT);
        }

        //
        // Now process any AddReg and DelReg entries found in this service install section.
        //
        CopyMemory(RegistryPath, pszServicesRegPath, sizeof(pszServicesRegPath));
        pSetupConcatenatePaths(RegistryPath,
                         ServiceName,
                         SIZECHARS(RegistryPath),
                         NULL
                        );
        if((Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               RegistryPath,
                               0,
                               KEY_READ | KEY_WRITE,
                               &hKeyService)) != ERROR_SUCCESS) {
            goto clean0;
        }

        ZeroMemory(&RegContext, sizeof(RegContext));
        RegContext.UserRootKey = hKeyService;

        if((Err = pSetupInstallRegistry(hInf, InstallSection, &RegContext)) != NO_ERROR) {
            goto clean0;
        }

        //
        // Now, see if the INF also specifies an EventLog installation section.  If so, create a
        // key under HKLM\System\CurrentControlSet\Services\EventLog\System for that service, and
        // run the registry modification lines in the specified install section.
        //
        if((InstallSection = pSetupGetField(LineContext, 4)) && *InstallSection) {
            //
            // Get the (optional) event log type and event log name strings.
            //
            if(!(EventLogType = pSetupGetField(LineContext, 5)) || !(*EventLogType)) {
                EventLogType = pszSystem;
            }

            if(!(EventLogName = pSetupGetField(LineContext, 6)) || !(*EventLogName)) {
                EventLogName = ServiceName;
            }

            //
            // We already have the services database registry path in our registry path buffer.  All
            // we need to do is add the \EventLog\<EventLogType>\<EventLogName> part.
            //
            CopyMemory(RegistryPath + CSTRLEN(REGSTR_PATH_SERVICES),
                       pszEventLog,
                       sizeof(pszEventLog)
                      );
            pSetupConcatenatePaths(RegistryPath,
                             EventLogType,
                             SIZECHARS(RegistryPath),
                             NULL
                            );
            pSetupConcatenatePaths(RegistryPath,
                             EventLogName,
                             SIZECHARS(RegistryPath),
                             NULL
                            );

            if((Err = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                     RegistryPath,
                                     0,
                                     NULL,
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_READ | KEY_WRITE,
                                     NULL,
                                     &hKeyEventLog,
                                     &EventLogKeyDisposition)) != ERROR_SUCCESS) {
                goto clean0;
            }

            if(EventLogKeyDisposition == REG_CREATED_NEW_KEY) {
                NewSvcNameNode.DeleteEventLog = TRUE;
                lstrcpy(NewSvcNameNode.EventLogType, EventLogType);
                lstrcpy(NewSvcNameNode.EventLogName, EventLogName);
            }

            ZeroMemory(&RegContext, sizeof(RegContext));
            RegContext.UserRootKey = hKeyEventLog;

            if((Err = pSetupInstallRegistry(hInf, InstallSection, &RegContext)) != NO_ERROR) {
                goto clean0;
            }
        }

        //
        // Service entry (and optional EventLog entry) were successfully installed.  If the
        // AddService flags field in the INF included the SPSVCINST_ASSOCSERVICE flag, _and_
        // the caller supplied us with a non-zero DevInst handle, then we need to set the
        // device instance's 'Service' property to indicate that it is associated with this
        // service.
        //
        if(DevInst && (ServiceInstallFlags & SPSVCINST_ASSOCSERVICE)) {

            CM_Set_DevInst_Registry_Property(DevInst,
                                             CM_DRP_SERVICE,
                                             ServiceName,
                                             (lstrlen(ServiceName) + 1) * sizeof(TCHAR),
                                             0
                                            );
        }

        //
        // If a new service was created, then link a new service name node into the list we
        // were passed in.  Don't fret about the case where we can't allocate a node--it just
        // means we won't know about this new service in case clean-up is required later.
        //
        if(NewService) {

            if(TmpNode = MyMalloc(sizeof(SVCNAME_NODE))) {

                lstrcpy(TmpNode->Name, NewSvcNameNode.Name);
                if(TmpNode->DeleteEventLog = NewSvcNameNode.DeleteEventLog) {
                    lstrcpy(TmpNode->EventLogType, NewSvcNameNode.EventLogType);
                    lstrcpy(TmpNode->EventLogName, NewSvcNameNode.EventLogName);
                }

                TmpNode->Next = *SvcListHead;
                *SvcListHead = TmpNode;
            }
        }

clean0: ; // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // If our exception was an AV, then use Win32 invalid param error, otherwise, assume it was
        // an inpage error dealing with a mapped-in file.
        //
        Err = (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) ? ERROR_INVALID_PARAMETER : ERROR_READ_FAULT;

        //
        // Access the following variables so that the compiler will respect our statement ordering
        // w.r.t. these values.  Otherwise, we can't be sure that we know whether or not their
        // corresponding resources should be freed.
        //
        DependenciesBuffer = DependenciesBuffer;
        hKeyService = hKeyService;
        hKeyEventLog = hKeyEventLog;
        ServiceHandle = ServiceHandle;
        SCLock = SCLock;
        SCMHandle = SCMHandle;
        NewService = NewService;
        ServiceConfig = ServiceConfig;
    }

    if(ServiceConfig) {
        MyFree(ServiceConfig);
    }
    if(DependenciesBuffer) {
        MyFree(DependenciesBuffer);
    }
    if(hKeyService) {
        RegCloseKey(hKeyService);
    }
    if(hKeyEventLog) {
        RegCloseKey(hKeyEventLog);
    }
    if(ServiceHandle) {
        CloseServiceHandle(ServiceHandle);
    }
    if(SCLock) {
        UnlockServiceDatabase(SCLock);
    }
    if(SCMHandle) {
        CloseServiceHandle(SCMHandle);
    }


    if (Err != NO_ERROR) {
        if (NewService) {
            //
            // Then we failed part-way through, and need to clean up the service (and
            // possibly event log entry) we created.
            //
            DeleteServicesInList(&NewSvcNameNode,LogContext);
        }
    } else {
        if (NeedsReboot) {
            SetLastError(ERROR_SUCCESS_REBOOT_REQUIRED);
        }
    }

    return Err;
}


DWORD
pSetupRetrieveServiceConfig(
    IN  SC_HANDLE               ServiceHandle,
    OUT LPQUERY_SERVICE_CONFIG *ServiceConfig
    )
/*++

Routine Description:

    This routine allocates a buffer for the specified service's configuration parameters,
    and retrieves those parameters into the buffer.  The caller is responsible for freeing
    the buffer.

Arguments:

    ServiceHandle - supplies a handle to the service being queried

    ServiceConfig - supplies the address of a QUERY_SERVICE_CONFIG pointer that receives
        the address of the allocated buffer containing the requested information.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is a Win32 error code.

Remarks:

    The pointer whose address is contained in ServiceConfig is guaranteed to be NULL upon
    return if any error occurred.

--*/
{
    DWORD ServiceConfigSize = 0, Err;

    MYASSERT(ServiceConfig);
    *ServiceConfig = NULL;

    while(TRUE) {

        if(QueryServiceConfig(ServiceHandle, *ServiceConfig, ServiceConfigSize, &ServiceConfigSize)) {
            MYASSERT(*ServiceConfig);
            return NO_ERROR;
        } else {

            Err = GetLastError();

            if(*ServiceConfig) {
                MyFree(*ServiceConfig);
            }

            if(Err == ERROR_INSUFFICIENT_BUFFER) {
                //
                // Allocate a larger buffer, and try again.
                //
                if(!(*ServiceConfig = MyMalloc(ServiceConfigSize))) {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
            } else {
                *ServiceConfig = NULL;
                return Err;
            }
        }
    }
}

#ifdef UNICODE
DWORD
RetrieveServiceConfig2(
    IN  SC_HANDLE               ServiceHandle,
    IN  DWORD                   Level,
    OUT LPBYTE                  *Buffer
    )
/*++

Routine Description:

    This routine allocates a buffer for the specified service's configuration parameters,
    and retrieves those parameters into the buffer.  The caller is responsible for freeing
    the buffer.

Arguments:

    ServiceHandle - supplies a handle to the service being queried

    Level         - specifies the information to query

    Buffer        - supplies the address of an opaque address to the buffer containing the info.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is a Win32 error code.

Remarks:

    The pointer whose address is contained in Buffer is guaranteed to be NULL upon
    return if any error occurred.

--*/
{

    DWORD ServiceConfigSize = 0, Err;

    *Buffer = NULL;

    while(TRUE) {

        if(QueryServiceConfig2(ServiceHandle, Level, *Buffer, ServiceConfigSize, &ServiceConfigSize)) {
            MYASSERT(*Buffer);
            return NO_ERROR;
        } else {

            Err = GetLastError();

            if(*Buffer) {
                MyFree(*Buffer);
            }

            if(Err == ERROR_INSUFFICIENT_BUFFER) {
                //
                // Allocate a larger buffer, and try again.
                //
                if(!(*Buffer = MyMalloc(ServiceConfigSize))) {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
            } else {
                *Buffer = NULL;
                return Err;
            }
        }
    }
}
#endif


DWORD
pSetupAddTagToGroupOrderListEntry(
    IN PCTSTR LoadOrderGroup,
    IN DWORD  TagId,
    IN BOOL   MoveToFront
    )
/*++

Routine Description:

    This routine first creates the specified LoadOrderGroup value entry under

        HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\GroupOrderList

    if the value doesn't already exist.  The routine then inserts the specified
    tag into the list.  If MoveToFront is TRUE, the tag is inserted at the front
    of the list (or moved to the front of the list if it was already present in
    the list).  If MoveToFront is FALSE, then the new tag is inserted at the end
    of the list, or left where it is if it already exists in the list.

Arguments:

    LoadOrderGroup - Specifies the name of the LoadOrderGroup to insert this new
        tag into.

    TagId - Specifies the tag ID to be inserted into the list.

    MoveToFront - If TRUE, place the tag at the front of the list.  If FALSE, then
        append the tag to the end of the list, unless it was already there, in which
        case it is left where it was.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is a Win32 error code.

--*/
{
    DWORD Err;
    HKEY hKey;
    PDWORD GroupOrderList, p;
    DWORD GroupOrderListSize, DataType, ExtraBytes, i, NumElements;

    if((Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           pszGroupOrderListPath,
                           0,
                           KEY_ALL_ACCESS,
                           &hKey)) != ERROR_SUCCESS) {
        return Err;
    }

    Err = QueryRegistryValue(hKey,
                             LoadOrderGroup,
                             (PVOID)(&GroupOrderList),
                             &DataType,
                             &GroupOrderListSize
                            );

    if(Err == NO_ERROR) {
        //
        // Validate the list, and fix it if it's broken.
        //
        if(GroupOrderListSize < sizeof(DWORD)) {
            if(GroupOrderList) {
                MyFree(GroupOrderList);
            }

            if(GroupOrderList = MyMalloc(sizeof(DWORD))) {
                *GroupOrderList = 0;
                GroupOrderListSize = sizeof(DWORD);
            } else {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }
        } else {
            if(ExtraBytes = GroupOrderListSize % sizeof(DWORD)) {
                if(p = MyRealloc(GroupOrderList, GroupOrderListSize + (sizeof(DWORD) - ExtraBytes))) {
                    GroupOrderList = p;
                    ZeroMemory((PBYTE)GroupOrderList + GroupOrderListSize, ExtraBytes);
                    GroupOrderListSize += ExtraBytes;
                } else {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean1;
                }
            }
        }

        MYASSERT(!(GroupOrderListSize % sizeof(DWORD)));

        //
        // We now have a list that's at least in the correct format.  Now validate the list count,
        // and adjust if necessary.
        //
        NumElements = (GroupOrderListSize / sizeof(DWORD)) - 1;

        if(*GroupOrderList != NumElements) {
            if(*GroupOrderList > NumElements) {
                *GroupOrderList = NumElements;
            } else {
                NumElements = *GroupOrderList;
                GroupOrderListSize = (NumElements + 1) * sizeof(DWORD);
            }
        }

    } else {
        //
        // If we ran out of memory, then bail, otherwise, just assume
        // there wasn't a list to retrieve.
        //
        if(Err == ERROR_NOT_ENOUGH_MEMORY) {
            goto clean0;
        } else {
            //
            // Allocate a list containing no tags.
            //
            if(GroupOrderList = MyMalloc(sizeof(DWORD))) {
                *GroupOrderList = 0;
                GroupOrderListSize = sizeof(DWORD);
            } else {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }
        }
    }

    //
    // Now we have a valid group order list to manipulate.
    //
    for(i = 0; i < *GroupOrderList; i++) {
        if(GroupOrderList[i + 1] == TagId) {
            //
            // Tag already exists in the list.
            //
            break;
        }
    }

    if(i == *GroupOrderList) {
        //
        // Then we didn't find the tag in the list.  Add it either to the front, or
        // the end, depending on the 'MoveToFront' flag.
        //
        if(p = MyRealloc(GroupOrderList, GroupOrderListSize + sizeof(DWORD))) {
            GroupOrderList = p;
            GroupOrderListSize += sizeof(DWORD);
        } else {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean1;

        }

        if(MoveToFront) {
            MoveMemory(&(GroupOrderList[2]), &(GroupOrderList[1]), *GroupOrderList * sizeof(DWORD));
            GroupOrderList[1] = TagId;
        } else {
            GroupOrderList[*GroupOrderList + 1] = TagId;
        }

        (*GroupOrderList)++;

    } else if(MoveToFront && i) {
        MoveMemory(&(GroupOrderList[2]), &(GroupOrderList[1]), i * sizeof(DWORD));
        GroupOrderList[1] = TagId;
    }

    //
    // Now write the value back to the registry.
    //
    Err = RegSetValueEx(hKey,
                        LoadOrderGroup,
                        0,
                        REG_BINARY,
                        (PBYTE)GroupOrderList,
                        GroupOrderListSize
                       );

clean1:
    MyFree(GroupOrderList);

clean0:
    RegCloseKey(hKey);

    return Err;
}


DWORD
pSetupRunLegacyInf(
    IN DEVINST DevInst,
    IN HWND    OwnerWindow,
    IN PCTSTR  InfFileName,
    IN PCTSTR  InfOptionName,
    IN PCTSTR  InfLanguageName,
    IN HINF    InfHandle
    )
/*++

Routine Description:

    This routine build a command line, loads the legacy setup dll, and starts
    the INF interpreter.

Arguments:

    DevInst - supplies the CM device instance handle for the device being installed.

    OwnerWindow - supplies the parent window for any UI that this INF generates.

    InfFileName - supplies the name of the INF file to be interpreted.

    InfOptionName - supplies the name of the INF section to execute.

    InfLanguageName - supplies the name of the language the INF should use for any UI
        (e.g., prompting, etc.)

    InfHandle - supplies a handle to the legacy INF being installed from.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is a Win32 error code.
    Note that this says nothing about what the INF actually did, merely that we were
    actually able to launch the INF.

--*/
{
    HINSTANCE LegacySetupDllModule;
    LEGACY_INF_INTERP_PROC pfnLegacyInfInterpret;
    LEGACY_INF_GETSVCLIST_PROC pfnLegacyInfGetModifiedSvcList;
    DWORD Err;
    TCHAR TempBuffer[MAX_PATH];
    PCTSTR LegacySourcePath;
    PTSTR CmdLine, AssociatedService;
    UINT CmdLineSize, BufSize;
    PSTR AnsiLine;
    PCSTR AnsiSourcePath;
    PCSTR AnsiInfFileName;
    BOOL b;
    INT InterpResult;
    CONFIGRET cr;
    BOOL OnlyFreeSetupDllOnce = TRUE;
    BOOL FreeSourceRoot;
    DWORD InfSourceMediaType;
    SPFUSIONINSTANCE spFusionInstance;
#ifdef UNICODE
    CHAR AnsiBuffer[2*MAX_PATH];    // allow room for full Unicode->DBCS expansion,
                                    // just to be on the safe side
#endif

    spFusionEnterContext(NULL,&spFusionInstance);

    if(!(LegacySetupDllModule = LoadLibrary(TEXT("SETUPDLL")))) {
        spFusionLeaveContext(&spFusionInstance);
        return GetLastError();
    }

    if(!(pfnLegacyInfInterpret =
             (LEGACY_INF_INTERP_PROC)GetProcAddress(LegacySetupDllModule,
                                                    "LegacyInfInterpret"))) {
        Err = GetLastError();
        goto clean0;
    }

    if(!(pfnLegacyInfGetModifiedSvcList =
             (LEGACY_INF_GETSVCLIST_PROC)GetProcAddress(LegacySetupDllModule,
                                                        "LegacyInfGetModifiedSvcList"))) {
        Err = GetLastError();
        goto clean0;
    }

#ifdef UNICODE
    //
    // Convert the Unicode INF filename to ANSI
    //
    WideCharToMultiByte(CP_ACP,
                        0,
                        InfFileName,
                        -1,
                        AnsiBuffer,
                        sizeof(AnsiBuffer),
                        NULL,
                        NULL
                       );

    AnsiInfFileName = AnsiBuffer;

#else // else not UNICODE

    //
    // Filename is already ANSI--no conversion necessary.
    //
    AnsiInfFileName = InfFileName;

#endif // else not UNICODE

    FreeSourceRoot = FALSE;
    if(LegacySourcePath = pSetupGetDefaultSourcePath(InfHandle, SRCPATH_USEPNFINFORMATION, &InfSourceMediaType)) {
        //
        // If the INF is from the internet, just use the default OEM source path (A:\) instead.
        //
        if(InfSourceMediaType == SPOST_URL) {
            MyFree(LegacySourcePath);
            LegacySourcePath = NULL;
        } else {
            FreeSourceRoot = TRUE;
        }
    }

    if(!LegacySourcePath) {
        //
        // Fall back to default OEM source path.
        //
        LegacySourcePath = pszOemInfDefaultPath;
    }

    //
    // Build the command line to be passed to the legacy INF interpreter.
    //
    CmdLineSize = 1;
    BufSize = 1024;
    if(CmdLine = MyMalloc(BufSize * sizeof(TCHAR))) {
        *CmdLine = TEXT('\0');
    } else {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean1;
    }

    if(!(CmdLine = pSetupCmdLineAppendString(CmdLine,
                                             TEXT("STF_WINDOWSPATH"),
                                             WindowsDirectory,
                                             &CmdLineSize,
                                             &BufSize))) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean1;
    }

    lstrcpyn(TempBuffer, WindowsDirectory, 3);
    if(!(CmdLine = pSetupCmdLineAppendString(CmdLine,
                                             TEXT("STF_NTDRIVE"),
                                             TempBuffer,
                                             &CmdLineSize,
                                             &BufSize))) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean1;
    }

    if(!(CmdLine = pSetupCmdLineAppendString(CmdLine,
                                             TEXT("STF_NTPATH"),
                                             SystemDirectory,
                                             &CmdLineSize,
                                             &BufSize))) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean1;
    }

    if(!(CmdLine = pSetupCmdLineAppendString(CmdLine,
                                             TEXT("STF_WINDOWSSYSPATH"),
                                             SystemDirectory,
                                             &CmdLineSize,
                                             &BufSize))) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean1;
    }

    if(!(CmdLine = pSetupCmdLineAppendString(CmdLine,
                                             TEXT("LEGACY_DODEVINSTALL"),
                                             TEXT("YES"),
                                             &CmdLineSize,
                                             &BufSize))) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean1;
    }

    if(!(CmdLine = pSetupCmdLineAppendString(CmdLine,
                                             TEXT("LEGACY_DI_LANG"),
                                             InfLanguageName,
                                             &CmdLineSize,
                                             &BufSize))) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean1;
    }

    if(!(CmdLine = pSetupCmdLineAppendString(CmdLine,
                                             TEXT("LEGACY_DI_OPTION"),
                                             InfOptionName,
                                             &CmdLineSize,
                                             &BufSize))) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean1;
    }

    if(!(CmdLine = pSetupCmdLineAppendString(CmdLine,
                                             TEXT("LEGACY_DI_SRCDIR"),
                                             LegacySourcePath,
                                             &CmdLineSize,
                                             &BufSize))) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean1;
    }

#ifdef UNICODE

    //
    // Allocate the correct amount of space for the ANSI version of the
    // command line. Leave room for DBCS chars if there are any.
    //
    if(!(AnsiLine = MyMalloc(CmdLineSize * 2 * sizeof(CHAR)))) {
        MyFree(CmdLine);
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean1;
    }

    //
    // Convert the command line from UNICODE to ANSI
    //
    WideCharToMultiByte(CP_ACP,
                        0,
                        CmdLine,
                        CmdLineSize,
                        AnsiLine,
                        2 * CmdLineSize * sizeof(CHAR),
                        NULL,
                        NULL
                       );

    MyFree(CmdLine);

    //
    // Convert the Unicode source path to ANSI.
    //
    if(!(AnsiSourcePath = pSetupUnicodeToAnsi(LegacySourcePath))) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean2;
    }

    if(FreeSourceRoot) {
        MyFree(LegacySourcePath);
    }

    //
    // Assign the new buffer back to LegacySourcePath, since that is the pointer that
    // we will be freeing later.
    //
    LegacySourcePath = (PCTSTR)AnsiSourcePath;

    //
    // Regardless of whether or not the original source path needed to be freed, the new
    // ANSI one will always need to be freed.
    //
    FreeSourceRoot = TRUE;


#else // else not UNICODE

    //
    // Since everything's already ANSI, no memory allocation/conversion is necessary.
    //
    AnsiLine = CmdLine;
    AnsiSourcePath = LegacySourcePath;

#endif // else not UNICODE

    //
    // OK, now we're ready to call the old setup command line parser.  (Do this within
    // a try/except, in case setupdll falls over.)
    //
    try {
        Err = pfnLegacyInfInterpret(OwnerWindow,
                                    AnsiInfFileName,
                                    "InstallOption",
                                    AnsiLine,
                                    (PSTR)TempBuffer,
                                    sizeof(TempBuffer),
                                    &InterpResult,
                                    AnsiSourcePath)
              ? NO_ERROR
              : ERROR_NOT_ENOUGH_MEMORY;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) ? ERROR_INVALID_DATA : ERROR_READ_FAULT;
    }

    if(Err == NO_ERROR) {
        //
        // We successfully ran the interpreter, so we know that we need to loop on a call to
        // FreeLibrary until setupdll goes away.
        //
        OnlyFreeSetupDllOnce = FALSE;
    } else {
        goto clean2;
    }

    //
    // The interpreter successfully ran the INF.  Now we need to find out what the result was.
    //
    // NOTE:  It seems that most legacy INFs aren't very good about distinguishing between
    // SETUP_ERROR_USERCANCEL and SETUP_ERROR_GENERAL.  Therefore, we can't reliably set
    // our error to indicate that the user cancelled (as opposed to some other INF problem).
    // Since almost all of the failures we'll encounter are because the user cancelled, we
    // simply lump both these errors into the same category, and return ERROR_CANCELLED in
    // both cases.
    //
    if(InterpResult != SETUP_ERROR_SUCCESS) {
        Err = ERROR_CANCELLED;
        goto clean2;
    }

    //
    // We successfully installed the legacy INF option.  Now we need to find out what services
    // got installed as a result of this, so that we can associate the device instance we're
    // installing with its controlling service.
    //
    try {
        Err = pfnLegacyInfGetModifiedSvcList(NULL, 0, &BufSize);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_NO_MORE_ITEMS;
    }

    //
    // Since we didn't pass this routine a buffer, then it should always fail.
    //
    MYASSERT(Err != NO_ERROR);

    if(Err == ERROR_NO_MORE_ITEMS) {
        //
        // No service modifications were performed by this INF.  This may be OK, since there may
        // be a default service for this device's class.  Consider our legacy INF installation a
        // success (at least, for now).
        //
        Err = NO_ERROR;
        goto clean2;
    }

    MYASSERT(Err == ERROR_INSUFFICIENT_BUFFER);  // the only other reason we should be failing.

    //
    // Allocate a buffer of the size necessary, and call this routine again to retrieve the service
    // list.  (Re-use AnsiLine to store the ANSI multi-sz list.)
    //
    MyFree(AnsiLine);

    if(!(AnsiLine = MyMalloc(BufSize * sizeof(CHAR)))) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean2;
    }

    try {
        Err = pfnLegacyInfGetModifiedSvcList(AnsiLine, BufSize, &BufSize);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_NO_MORE_ITEMS;
    }

    if(Err != NO_ERROR) {
        //
        // The only time this should ever happen is if we hit an exception in setupdll.
        // We'll ignore the error.
        //
        Err = NO_ERROR;
        goto clean2;
    }

#ifdef UNICODE

    //
    // Convert this multi-sz list to Unicode.
    //
    if(!(CmdLine = MyMalloc(BufSize * sizeof(WCHAR)))) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean2;
    }

    if(!MultiByteToWideChar(CP_ACP,
                            MB_PRECOMPOSED,
                            AnsiLine,
                            BufSize * sizeof(CHAR),
                            CmdLine,
                            BufSize)) {

        Err = GetLastError();
        MyFree(CmdLine);
        goto clean2;
    }

    //
    // Free the ANSI buffer, and set it equal to the Unicode one, so that we can free the same
    // memory in both the ANSI and Unicode cases.
    //
    MyFree(AnsiLine);
    AnsiLine = (PSTR)CmdLine;

#else // else not UNICODE

    //
    // We're not Unicode, so the ANSI list we have is just fine.
    //
    CmdLine = AnsiLine;

#endif // else not UNICODE

    //
    // OK, we now have the proper TCHAR-ized form of the multi-sz list.  Process the services
    // listed therein, and return the one that should be associated with this device instance.
    //
    if(AssociatedService = DoServiceModsForLegacyInf(CmdLine)) {
        //
        // Make the association between the service and the device.
        //
        if((cr = CM_Set_DevInst_Registry_Property(DevInst,
                                                  CM_DRP_SERVICE,
                                                  AssociatedService,
                                                  (lstrlen(AssociatedService) + 1) * sizeof(TCHAR),
                                                  0)) != CR_SUCCESS) {
            if(cr == CR_INVALID_DEVINST) {
                Err = ERROR_NO_SUCH_DEVINST;
            } else {
                Err = ERROR_INVALID_DATA;
            }
        }
    }

clean2:

    if(AnsiLine) {
        MyFree(AnsiLine);
    }

clean1:

    if(FreeSourceRoot) {
        MyFree(LegacySourcePath);
    }

clean0:
    //
    // Clean up
    //
    while(GetModuleFileName(LegacySetupDllModule, TempBuffer, SIZECHARS(TempBuffer))) {
        FreeLibrary(LegacySetupDllModule);
        if(OnlyFreeSetupDllOnce) {
            break;
        }
    }
    spFusionLeaveContext(&spFusionInstance);

    return Err;
}


PTSTR
pSetupCmdLineAppendString(
    IN     PTSTR  CmdLine,
    IN     PCTSTR Key,
    IN     PCTSTR Value,   OPTIONAL
    IN OUT PUINT  StrLen,
    IN OUT PUINT  BufSize
    )

/*++

Routine Description:

    Forms a new (multi-sz) command line by appending a list of arguments to
    the current command line. For example:

        CmdLine = SpSetupCmdLineAppendString(
                    CmdLine,
                    "STF_PRODUCT",
                    "NTWKSTA"
                    );

    would append "STF_PRODUCT\0NTWKSTA\0\0" to CmdLine.

Arguments:

    CmdLine - Original CmdLine, to be appended to.  THIS BUFFER MUST CONTAIN
        AT LEAST A SINGLE NULL CHARACTER!

    Key - Key identifier

    Value - Value of Key

    StrLen - How long the current string in -- save on strlens

    BufSize - Size of Current Buffer

Returns:

    Pointer to the new string, or NULL if out-of-memory (in that case, the
    original CmdLine buffer is freed).

--*/

{
    PTSTR Ptr;
    UINT NewLen;

    //
    // Handle special cases so we don't end up with empty strings.
    //
    if(!Value || !(*Value)) {
        Value = TEXT("\"\"");
    }

    //
    // "\0" -> 1 chars
    // "\0\0" -> 2 char
    // but we have to back up 1 character...
    //
    NewLen = (*StrLen + 2 + lstrlen(Key) + lstrlen(Value));

    //
    // Allocate more space if necessary.
    //
    if(NewLen >= *BufSize) {
        //
        // Grow the current buffer
        //
        *BufSize += 1024;

        if(Ptr = MyRealloc(CmdLine, (*BufSize) * sizeof(TCHAR))) {
            CmdLine = Ptr;
        } else {
            //
            // Free the memory here so the caller doesn't have to worry about it.
            //
            MyFree(CmdLine);
            return NULL;
        }
    }


    Ptr = &(CmdLine[*StrLen-1]);
    lstrcpy(Ptr, Key);
    Ptr = &(CmdLine[*StrLen+lstrlen(Key)]);
    lstrcpy(Ptr, Value);
    CmdLine[NewLen-1] = TEXT('\0');

    //
    // Update the length of the buffer that we are using
    //
    *StrLen = NewLen;

    return CmdLine;
}


PTSTR
DoServiceModsForLegacyInf(
    IN PTSTR ServiceList
    )
/*++

Routine Description:

    This routine processes the multi-sz list of service names it is given as
    input, ensuring that each one is tagged appropriately.  It also keeps track
    of which one is the first to load, based on its start type and membership in
    one of the load order groups listed under HKLM\System\CCS\Control\ServiceGroupOrder.
    The one that is first to load is returned.

Arguments:

    ServiceList - supplies the address of a character buffer containing a
        multi-sz list of service names to be processed.

Returns:

    Pointer to the service within the list that should be associated with the
    device instance, or NULL if we don't find a suitable service.

--*/
{
    PTSTR CurServiceName, ServiceGroupOrderList, CurGroupName;
    DWORD ServiceGroupIndex;
    TCHAR NullChar;
    DWORD RegDataType, RegDataSize;
    PTSTR AssocServiceName = NULL;
    SC_HANDLE SCMHandle, ServiceHandle;
    SC_LOCK SCLock;
    LPQUERY_SERVICE_CONFIG ServiceConfig;
    DWORD NewTag;
    DWORD AssocStartType = SERVICE_DISABLED;
    DWORD AssocGroupIndex = DWORD_MAX;
    HKEY hKey;

    if(!(SCMHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS))) {
        return NULL;
    }

    //
    // Retrieve the 'List' multi-sz value entry under HKLM\System\CCS\Control\ServiceGroupOrder.
    //
    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszServiceGroupOrderPath, 0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        if(QueryRegistryValue(hKey, TEXT("List"), &ServiceGroupOrderList, &RegDataType, &RegDataSize) != NO_ERROR) {
            //
            // Couldn't retrieve the list--set up an empty list.
            //
            NullChar = TEXT('\0');
            ServiceGroupOrderList = &NullChar;
        } else {
            //
            // If the value entry was present, but zero-length, then setup an
            // emtpy list.
            //
            if(!ServiceGroupOrderList) {
                NullChar = TEXT('\0');
                ServiceGroupOrderList = &NullChar;
            }
        }

        RegCloseKey(hKey);

    } else {
        //
        // Couldn't open the ServiceGroupOrder key--set up an empty list.
        //
        NullChar = TEXT('\0');
        ServiceGroupOrderList = &NullChar;
    }

    for(CurServiceName = ServiceList;
        *CurServiceName;
        CurServiceName += (lstrlen(CurServiceName) + 1)) {
        //
        // Open this service.
        //
        if(!(ServiceHandle = OpenService(SCMHandle, CurServiceName, SERVICE_ALL_ACCESS))) {
            //
            // We couldn't access the service--possibly because it doesn't exist anymore.
            // Continue on with the next service.
            //
            continue;
        }

        //
        // Now retrieve the configuration for this service.
        //
        if(pSetupRetrieveServiceConfig(ServiceHandle, &ServiceConfig) != NO_ERROR) {
            //
            // There's not a lot we can do without knowing the service's configuration,
            // either.  Again, we'll just skip this service and continue with the next one.
            //
            goto clean0;
        }

        //
        // If this service is marked as disabled, then we don't care about it.
        //
        if(ServiceConfig->dwStartType == SERVICE_DISABLED) {
            goto clean1;
        }

        //
        // If this service has a load order group, and is a kernel or filesystem
        // driver, then make sure that it has a tag.
        //
        if(ServiceConfig->lpLoadOrderGroup && *(ServiceConfig->lpLoadOrderGroup) &&
           (ServiceConfig->dwServiceType & (SERVICE_KERNEL_DRIVER | SERVICE_FILE_SYSTEM_DRIVER))) {
            //
            // This service needs a tag--does it have one???
            //
            if(!(NewTag = ServiceConfig->dwTagId)) {
                //
                // Attempt to lock the service database before generating a tag.  We'll go ahead
                // and make the change, even if this fails.
                //
                pAcquireSCMLock(SCMHandle, &SCLock, NULL);

                if(!ChangeServiceConfig(ServiceHandle,
                                        SERVICE_NO_CHANGE,
                                        SERVICE_NO_CHANGE,
                                        SERVICE_NO_CHANGE,
                                        NULL,
                                        ServiceConfig->lpLoadOrderGroup, // have to specify this to generate new tag.
                                        &NewTag,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL)) {
                    NewTag = 0;
                }

                if(SCLock) {
                    UnlockServiceDatabase(SCLock);
                }
            }

            //
            // Make sure that the tag exists in the service's corresponding GroupOrderList entry.
            //
            if(NewTag) {
                pSetupAddTagToGroupOrderListEntry(ServiceConfig->lpLoadOrderGroup, NewTag, FALSE);
            }
        }

        //
        // Determine the index that this service's load group occupies in the multi-sz ServiceGroupOrder
        // list we retrieved above.
        //
        if(ServiceConfig->lpLoadOrderGroup) {

            for(CurGroupName = ServiceGroupOrderList, ServiceGroupIndex = 0;
                *CurGroupName;
                CurGroupName += (lstrlen(CurGroupName) + 1), ServiceGroupIndex++) {

                if(!lstrcmpi(CurGroupName, ServiceConfig->lpLoadOrderGroup)) {
                    break;
                }
            }

            if(!(*CurGroupName)) {
                //
                // Then we didn't find this group in our list--give it the maximum index value.
                //
                ServiceGroupIndex = DWORD_MAX;
            }

        } else {
            //
            // This service isn't a member of a group--give it the maximum index value.
            //
            ServiceGroupIndex = DWORD_MAX;
        }

        //
        // Finally, determine if this service loads before any services we've encountered so far,
        // and if so, then make it our new choice for associated service.
        //
        if(ServiceConfig->dwStartType < AssocStartType) {
            //
            // Then this service loads in an earlier load phase, so we're guaranteed it loads before
            // any drivers we've previously seen.
            //
            AssocServiceName = CurServiceName;
            AssocStartType = ServiceConfig->dwStartType;
            AssocGroupIndex = ServiceGroupIndex;

        } else if(ServiceConfig->dwStartType == AssocStartType) {
            //
            // This service starts in the same load phase as the current selection, so we need to
            // compare the group load order indices to see if this one comes earlier.
            //
            if(ServiceGroupIndex < AssocGroupIndex) {
                AssocServiceName = CurServiceName;
                AssocGroupIndex = ServiceGroupIndex;
            }
        }

clean1:
        MyFree(ServiceConfig);

clean0:
        CloseServiceHandle(ServiceHandle);
    }

    if(ServiceGroupOrderList != &NullChar) {
        MyFree(ServiceGroupOrderList);
    }

    CloseServiceHandle(SCMHandle);

    return AssocServiceName;
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiGetActualSectionToInstallA(
    IN  HINF    InfHandle,
    IN  PCSTR   InfSectionName,
    OUT PSTR    InfSectionWithExt,     OPTIONAL
    IN  DWORD   InfSectionWithExtSize,
    OUT PDWORD  RequiredSize,          OPTIONAL
    OUT PSTR   *Extension              OPTIONAL
    )
{
    return SetupDiGetActualSectionToInstallExA(InfHandle,
                                               InfSectionName,
                                               NULL,
                                               InfSectionWithExt,
                                               InfSectionWithExtSize,
                                               RequiredSize,
                                               Extension,
                                               NULL
                                              );
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupDiGetActualSectionToInstallW(
    IN  HINF    InfHandle,
    IN  PCWSTR  InfSectionName,
    OUT PWSTR   InfSectionWithExt,     OPTIONAL
    IN  DWORD   InfSectionWithExtSize,
    OUT PDWORD  RequiredSize,          OPTIONAL
    OUT PWSTR  *Extension              OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(InfSectionName);
    UNREFERENCED_PARAMETER(InfSectionWithExt);
    UNREFERENCED_PARAMETER(InfSectionWithExtSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    UNREFERENCED_PARAMETER(Extension);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiGetActualSectionToInstall(
    IN  HINF    InfHandle,
    IN  PCTSTR  InfSectionName,
    OUT PTSTR   InfSectionWithExt,     OPTIONAL
    IN  DWORD   InfSectionWithExtSize,
    OUT PDWORD  RequiredSize,          OPTIONAL
    OUT PTSTR  *Extension              OPTIONAL
    )

/*++

Routine Description:

    (See description of SetupDiGetActualSectionToInstallEx)

--*/

{
    return SetupDiGetActualSectionToInstallEx(InfHandle,
                                              InfSectionName,
                                              NULL,
                                              InfSectionWithExt,
                                              InfSectionWithExtSize,
                                              RequiredSize,
                                              Extension,
                                              NULL
                                             );
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiGetActualSectionToInstallExA(
    IN  HINF                    InfHandle,
    IN  PCSTR                   InfSectionName,
    IN  PSP_ALTPLATFORM_INFO_V2 AlternatePlatformInfo, OPTIONAL
    OUT PSTR                    InfSectionWithExt,     OPTIONAL
    IN  DWORD                   InfSectionWithExtSize,
    OUT PDWORD                  RequiredSize,          OPTIONAL
    OUT PSTR                   *Extension,             OPTIONAL
    IN  PVOID                   Reserved
    )
{
    PWSTR infsectionname;
    DWORD rc;
    BOOL b;
    PWSTR extension;
    UINT CharOffset,i;
    PSTR p;
    DWORD requiredsize;
    WCHAR newsection[MAX_SECT_NAME_LEN];
    PSTR ansi;

    rc = pSetupCaptureAndConvertAnsiArg(InfSectionName,&infsectionname);
    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    b = SetupDiGetActualSectionToInstallExW(
            InfHandle,
            infsectionname,
            AlternatePlatformInfo,
            newsection,
            MAX_SECT_NAME_LEN,
            &requiredsize,
            &extension,
            Reserved
            );

    rc = GetLastError();

    if(b) {

        if(ansi = pSetupUnicodeToAnsi(newsection)) {

            requiredsize = lstrlenA(ansi)+1;

            if(RequiredSize) {
                try {
                    *RequiredSize = requiredsize;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    rc = ERROR_INVALID_PARAMETER;
                    b = FALSE;
                }
            }

            if(b && InfSectionWithExt) {

                if(requiredsize <= InfSectionWithExtSize) {

                    if(!lstrcpyA(InfSectionWithExt,ansi)) {
                        //
                        // lstrcpy faulted, so InfSectionWithExt must be bad
                        //
                        rc = ERROR_INVALID_PARAMETER;
                        b = FALSE;
                    }
                } else {
                    rc = ERROR_INSUFFICIENT_BUFFER;
                    b = FALSE;
                }
            }

            if(b && Extension) {

                if(extension && InfSectionWithExt) {
                    //
                    // We need to figure out where the extension is
                    // in the converted string. To be DBCS safe we will
                    // count characters forward to find it.
                    //
                    CharOffset = (UINT)(extension - newsection);
                    p = InfSectionWithExt;
                    for(i=0; i<CharOffset; i++) {
                        p = CharNextA(p);
                    }
                } else {
                    p = NULL;
                }

                try {
                    *Extension = p;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    b = FALSE;
                    rc = ERROR_INVALID_PARAMETER;
                }
            }

            MyFree(ansi);

        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            b = FALSE;
        }
    }

    MyFree(infsectionname);
    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupDiGetActualSectionToInstallExW(
    IN  HINF                    InfHandle,
    IN  PCWSTR                  InfSectionName,
    IN  PSP_ALTPLATFORM_INFO_V2 AlternatePlatformInfo, OPTIONAL
    OUT PWSTR                   InfSectionWithExt,     OPTIONAL
    IN  DWORD                   InfSectionWithExtSize,
    OUT PDWORD                  RequiredSize,          OPTIONAL
    OUT PWSTR                  *Extension,             OPTIONAL
    IN  PVOID                   Reserved
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(InfSectionName);
    UNREFERENCED_PARAMETER(AlternatePlatformInfo);
    UNREFERENCED_PARAMETER(InfSectionWithExt);
    UNREFERENCED_PARAMETER(InfSectionWithExtSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    UNREFERENCED_PARAMETER(Extension);
    UNREFERENCED_PARAMETER(Reserved);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiGetActualSectionToInstallEx(
    IN  HINF                    InfHandle,
    IN  PCTSTR                  InfSectionName,
    IN  PSP_ALTPLATFORM_INFO_V2 AlternatePlatformInfo, OPTIONAL
    OUT PTSTR                   InfSectionWithExt,     OPTIONAL
    IN  DWORD                   InfSectionWithExtSize,
    OUT PDWORD                  RequiredSize,          OPTIONAL
    OUT PTSTR                  *Extension,             OPTIONAL
    IN  PVOID                   Reserved
    )
/*++

Routine Description:

    This API finds the appropriate install section to be used when installing
    a device from a Win95-style device INF.  Refer to the documentation for
    SetupDiInstallDevice for details on how this determination is made.

Arguments:

    InfHandle - Supplies the handle of the INF to be installed from.

    InfSectionName - Supplies the name of the install section, as specified by
        the driver node being installed.

    AlternatePlatformInfo - Optionally, supplies alternate platform information
        to be used in selecting the section.  Presently, only the Platform and
        ProcessorArchitecture fields are used in formulating the section
        decoration.  (NOTE: caller may actually pass in a V1 struct instead--
        this is fine, as the fields we care about are shared in common between
        the V1 and V2 structs.)

    InfSectionWithExt - Optionally, supplies the address of a character buffer
        that receives the actual install section name that should be used
        during installation.  If this parameter is NULL, then
        InfSectionWithExtSize must be zero.  In that case, the caller is only
        interested in retrieving the required buffer size, so the API will
        return TRUE, and RequiredSize (if supplied), will be set to the size,
        in characters, necessary to store the actual install section name.

    InfSectionWithExtSize - Supplies the size, in characters, of the
        InfSectionWithExt buffer.

    RequiredSize - Optionally, supplies the address of a variable that receives
        the size, in characters, required to store the actual install section
        name (including terminating NULL).

    Extension - Optionally, supplies the address of a variable that receives a
        pointer to the extension (including '.'), or NULL if no extension is to
        be used.  The pointer points to the extension within the caller-
        supplied buffer.  If the InfSectionWithExt buffer is not supplied, then
        this variable will not be filled in.

    Reserved - Must be NULL.

Returns:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    Presently, the only possible failures are ERROR_INVALID_PARAMETER
    (bad caller-supplied pointers), and ERROR_INSUFFICIENT_BUFFER (if the
    caller-supplied buffer isn't large enough).  If we fall back to the
    baseline (i.e., non-decorated) section name, then we simply return it,
    without verifying that the section actually exists.

--*/
{
    TCHAR TempInfSectionName[MAX_SECT_NAME_LEN];
    DWORD SectionNameLen = (DWORD)lstrlen(InfSectionName);
    DWORD ExtBufferLen;
    BOOL ExtFound = TRUE;
    DWORD Err = NO_ERROR;
    DWORD Platform;
    PCTSTR NtArchSuffix;
    DWORD  NtArchSuffixSize;

    if(Reserved) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if(SectionNameLen >= MAX_SECT_NAME_LEN) {
        SetLastError(ERROR_SECTION_NAME_TOO_LONG);
        return FALSE;
    }

    //
    // Both V1 and V2 SP_ALTPLATFORM_INFO structures share a common layout for
    // the first 6 fields (including Platform and ProcessorArchitecture, which
    // are the ones we're interested in here).  Thus, all we need to do is
    // verify that the cbSize field is one of the two valid values.
    //
    if(AlternatePlatformInfo) {

        if((AlternatePlatformInfo->cbSize != sizeof(SP_ALTPLATFORM_INFO_V2)) &&
           (AlternatePlatformInfo->cbSize != sizeof(SP_ALTPLATFORM_INFO_V1))) {

            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }

    CopyMemory(TempInfSectionName, InfSectionName, SectionNameLen * sizeof(TCHAR));

    Platform = AlternatePlatformInfo ? AlternatePlatformInfo->Platform
                                     : OSVersionInfo.dwPlatformId;

    if(Platform == VER_PLATFORM_WIN32_NT) {
        //
        // We're running on NT, so first try the NT architecture-specific
        // extension, then the generic NT extension.
        //
        if(AlternatePlatformInfo) {

            switch(AlternatePlatformInfo->ProcessorArchitecture) {

                case PROCESSOR_ARCHITECTURE_INTEL :
                    NtArchSuffix = pszNtX86Suffix;
                    NtArchSuffixSize = sizeof(pszNtX86Suffix);
                    break;

                case PROCESSOR_ARCHITECTURE_ALPHA :
                    NtArchSuffix = pszNtAlphaSuffix;
                    NtArchSuffixSize = sizeof(pszNtAlphaSuffix);
                    break;

                case PROCESSOR_ARCHITECTURE_IA64 :
                    NtArchSuffix = pszNtIA64Suffix;
                    NtArchSuffixSize = sizeof(pszNtIA64Suffix);
                    break;

                case PROCESSOR_ARCHITECTURE_ALPHA64 :
                    NtArchSuffix = pszNtAXP64Suffix;
                    NtArchSuffixSize = sizeof(pszNtAXP64Suffix);
                    break;

                case PROCESSOR_ARCHITECTURE_AMD64 :
                    NtArchSuffix = pszNtAMD64Suffix;
                    NtArchSuffixSize = sizeof(pszNtAMD64Suffix);
                    break;

                default:
                    //
                    // Unknown/invalid architecture
                    //
                    SetLastError(ERROR_INVALID_PARAMETER);
                    return FALSE;
            }

        } else {
            NtArchSuffix = pszNtPlatformSuffix;
            NtArchSuffixSize = sizeof(pszNtPlatformSuffix);
        }

        if(NtArchSuffixSize <=
               sizeof(TempInfSectionName) - (SectionNameLen * sizeof(TCHAR))) {

            CopyMemory(&(TempInfSectionName[SectionNameLen]),
                       NtArchSuffix,
                       NtArchSuffixSize
                      );

            if(SetupGetLineCount(InfHandle, TempInfSectionName) != -1) {
                goto clean0;
            }

            //
            // We know the ".NT" suffix is always guaranteed to be shorter than
            // any of the ".NT<architecture>" suffixes, thus we know this will
            // fit in our MAX_SECT_NAME_LEN buffer.  (Note: if the OS/arch.
            // decoration is too big, then we won't even try the simple OS
            // decoration.  To do otherwise might be misleading, as we'd select
            // a "<reallylongsectionname>.NT" section, even though the INF
            // (erroneously) contains a "<reallylongsectionname>.NTx86" section
            // that doesn't fit.)
            //
            CopyMemory(&(TempInfSectionName[SectionNameLen]),
                       pszNtSuffix,
                       sizeof(pszNtSuffix)
                      );

            if(SetupGetLineCount(InfHandle, TempInfSectionName) != -1) {
                goto clean0;
            }
        }

    } else {
        //
        // We're running on Windows 95, so try the Windows-specific extension
        //
        if(sizeof(pszWinSuffix) <=
               sizeof(TempInfSectionName) - (SectionNameLen * sizeof(TCHAR))) {

            CopyMemory(&(TempInfSectionName[SectionNameLen]),
                       pszWinSuffix,
                       sizeof(pszWinSuffix)
                      );
            if(SetupGetLineCount(InfHandle, TempInfSectionName) != -1) {
                goto clean0;
            }
        }
    }

    //
    // If we get to here, then we found no applicable extensions.  We'll just use
    // the install section specified.
    //
    TempInfSectionName[SectionNameLen] = TEXT('\0');
    ExtFound = FALSE;

clean0:
    //
    // Now, determine whether the caller-supplied buffer is large enough to contain
    // the section name.
    //
    ExtBufferLen = lstrlen(TempInfSectionName) + 1;

    //
    // Guard the rest of the routine in try/except, since we're dealing with caller-supplied
    // memory.
    //
    try {
        if(RequiredSize) {
            *RequiredSize = ExtBufferLen;
        }
        if(InfSectionWithExt) {
            if(ExtBufferLen > InfSectionWithExtSize) {
                Err = ERROR_INSUFFICIENT_BUFFER;
            } else {
                CopyMemory(InfSectionWithExt, TempInfSectionName, ExtBufferLen * sizeof(TCHAR));
                if(Extension) {
                    *Extension = ExtFound ? InfSectionWithExt + SectionNameLen : NULL;
                }
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


BOOL
pSetupInfIsFromOemLocation(
    IN PCTSTR InfFileName,
    IN BOOL   InfDirectoryOnly
    )
/*++

Routine Description:

    This routine determines whether the specified INF came from one of the directories
    in our INF search path list.  This list can also be limited to just the %windir%\Inf
    directory.

Arguments:

    InfFileName - Supplies the fully-qualified path of the INF file.

    InfDirectoryOnly - If TRUE, then consider the INF to be from an OEM location if it is
        not in the %windir%\Inf directory (i.e., ignore any other directories in the INF
        search path).

Returns:

    If the file is from an OEM location (i.e., _not_ in our INF search path list), then
    the return value is TRUE.  Otherwise, it is FALSE.

--*/
{
    PCTSTR CharPos, DirTruncPos;
    INT DirectoryPathLen, CurSearchPathLen;

    //
    // First, retrieve just the directory path part of the specified filename.
    //
    CharPos = pSetupGetFileTitle(InfFileName);
    DirTruncPos = CharPrev(InfFileName, CharPos);

    //
    // (We know pSetupGetFileTitle will never return a pointer to a path separator character,
    // so the following check is valid.)
    //
    if(*DirTruncPos == TEXT('\\')) {
        //
        // If this is in a root directory (e.g., "A:\"), then we don't want to strip off
        // the trailing backslash.
        //
        if(((DirTruncPos - InfFileName) != 2) || (*CharNext(InfFileName) != TEXT(':'))) {
            CharPos = DirTruncPos;
        }
    }

    DirectoryPathLen = (int)(CharPos - InfFileName);

    //
    // Now, see if this directory matches any of the ones in our search path list.
    //
    if(InfDirectoryOnly) {
        CharPos = InfDirectory;
    } else {
        CharPos = InfSearchPaths;
    }

    do {
        //
        // If the current search path ends in a backslash, we want to strip it off.
        //
        CurSearchPathLen = lstrlen(CharPos);

        if((DirectoryPathLen == CurSearchPathLen) &&
           !_tcsnicmp(CharPos, InfFileName, CurSearchPathLen)) {
            //
            // We've found this directory in our list--we can return.
            //
            return FALSE;
        }

        if(InfDirectoryOnly) {
            //
            // We're only supposed to consider the %windir%\Inf directory--that failed,
            // so we're done.
            //
            break;
        } else {
            //
            // Move on to next component of INF search path.
            //
            CharPos += (CurSearchPathLen + 1);
        }

    } while(*CharPos);

    //
    // If we get to here, then we didn't find the directory in our search path list.
    // Therefore, it's from an OEM location.
    //
    return TRUE;
}

BOOL
WINAPI
SetupDiInstallDeviceInterfaces(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    Default handler for DIF_INSTALLINTERFACES.

    This routine will install any device interface specified in an
    [<InstallSec>.Interfaces] section, where <InstallSec> is the install
    section name for the selected driver node, potentially decorated with
    an OS/architecture-specific extension (e.g., "InstallSec.NTAlpha.Interfaces").

    Presently, only "AddInterface" lines in this section are processed.  Their
    format is as follows:

        AddInterface = <InterfaceClassGuid> [, [<RefString>] [, [<InstallSection>] [, <Flags>]]]

    (There are currently no flags defined for the <Flags> field--must be zero.)

    If the interface class specified by <InterfaceClassGuid> is not already
    installed in the system, we will install it.  An INF can optionally specify
    installation actions to be done when this interface class is installed (just
    like it can do for class installers via a [ClassInstall32] section.  It does
    this by including an [InterfaceInstall32] section with an entry for the
    interface class to be installed.  This section name does not allow os/architecture-
    specific decoration.  Instead, the install sections referenced by lines within
    this section are processed with decoration rules.  Thus, it is possible to have
    an install entry for interface class <x> that applies to both Win9x and NT, and
    have another install entry for interface class <y> that behaves differently
    depending on whether we're running on Win9x or NT.

    The format of an entry in the [InterfaceInstall32] section is as follows:

        <InterfaceClassGuid> = <InstallSection> [, <Flags>]

    (There are currently no flags defined for the <Flags> field--must be zero.)

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        a device information element whose device interfaces are to be installed.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure for which
        device interfaces are to be installed.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    If no driver is selected (i.e., this is a null-driver installation), then
    this routine does nothing.

--*/

{
    return _SetupDiInstallInterfaceDevices(DeviceInfoSet,
                                           DeviceInfoData,
                                           TRUE,
                                           INVALID_HANDLE_VALUE,
                                           INVALID_HANDLE_VALUE
                                          );
}


BOOL
_SetupDiInstallInterfaceDevices(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN BOOL             DoFullInstall,
    IN HINF             hDeviceInf,     OPTIONAL
    IN HSPFILEQ         UserFileQ       OPTIONAL
    )
/*++

Routine Description:

    Worker routine for both SetupDiInstallInterfaceDevices and SetupDiInstallDriverFiles.

    See the description of SetupDiInstallInterfaceDevices for more information.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        a device information element whose interface devices are to be installed.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure for which
        interface devices are to be installed.

    DoFullInstall - If TRUE, then the interface devices will be fully installed.
        Otherwise, only the required files are copied.

    hDeviceInf - Optionally, supplies a handle to the INF for which installation
        is being performed.  If this handle is not supplied, the INF specified in
        the selected driver node will be opened.  If this handle is not supplied,
        this parameter must be set to INVALID_HANDLE_VALUE.

    UserFileQ - Optionally, supplies a file queue where file operations should be added.
        If this handle is not supplied, then the queue associated with this devinfo
        element will be used (if the DI_NOVCP flag is set), or one will be automatically
        generated and committed.  If this handle is not supplied, this parameter must
        be set to INVALID_HANDLE_VALUE.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    During GUI-mode setup on Windows NT, quiet-install behavior is always
    employed in the absence of a user-supplied file queue, regardless of
    whether the device information element has the DI_QUIETINSTALL flag set.

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err, ScanQueueResult;
    PDEVINFO_ELEM DevInfoElem;
    HWND hwndParent;
    PTSTR szInfFileName, szInfSectionName;
    TCHAR InfSectionWithExt[MAX_SECT_NAME_LEN];
    DWORD InfSectionWithExtLength;
    INFCONTEXT InterfaceDeviceInstallLine, InterfaceClassInstallLine;
    TCHAR InterfaceGuidString[GUID_STRING_LEN];
    DWORD InstallFlags;
    GUID InterfaceGuid;
    HKEY hKeyInterfaceClass, hKeyDeviceClassesRoot, hKeyInterfaceDevice;
    PINTERFACE_CLASS_TO_INSTALL InterfacesToInstall, InterfaceInstallNode, CurInterfaceInstallNode;
    DWORD RegDisposition;
    BOOL NeedToInstallInterfaceClass;
    TCHAR InterfaceInstallSection[MAX_SECT_NAME_LEN];
    BOOL DoFileCopying;
    BOOL CloseUserFileQ;
    BOOL FreeMsgHandlerContext;
    PSP_FILE_CALLBACK MsgHandler;
    PVOID MsgHandlerContext;
    BOOL MsgHandlerIsNativeCharWidth;
    TCHAR RefString[MAX_PATH];
    SP_DEVICE_INTERFACE_DATA InterfaceDeviceData;
    PCTSTR UndecoratedInstallSection;
    BOOL CloseInfHandle;
    PTSTR NeedsSectionList, CurInstallSection;
    BOOL b;
    INT FileQueueNeedsReboot;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    BOOL NoProgressUI;
    DWORD slot_section = 0;
    TCHAR szNewName[MAX_PATH];
    BOOL OemInfFileToCopy = FALSE;

    //
    // A device information element must be specified.
    //
    if(!DeviceInfoData) {
        Err = ERROR_INVALID_PARAMETER;
        goto clean1;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        Err = ERROR_INVALID_HANDLE;
        goto clean1;
    }

    LogContext = pDeviceInfoSet->InstallParamBlock.LogContext;

    Err = NO_ERROR;
    hKeyDeviceClassesRoot = hKeyInterfaceClass = hKeyInterfaceDevice = INVALID_HANDLE_VALUE;
    InterfacesToInstall = InterfaceInstallNode = NULL;
    CloseUserFileQ = FALSE;
    FreeMsgHandlerContext = FALSE;
    CloseInfHandle = FALSE;
    NeedsSectionList = NULL;

    try {

        if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                     DeviceInfoData,
                                                     NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // This routine can't install a non-native driver
        //
        if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_ALTPLATFORM_DRVSEARCH) {

            Err = ERROR_INVALID_FLAGS;
            goto clean0;
        }

        //
        // set the LogContext for this function
        //
        LogContext = DevInfoElem->InstallParamBlock.LogContext;

        //
        // If there's no driver selected (i.e., this is a null driver install), or we're
        // using a legacy INF, then there's nothing for us to do.
        //
        if(!(DevInfoElem->SelectedDriver) ||
            (DevInfoElem->SelectedDriver->Flags & DNF_LEGACYINF)) {

            goto clean0;
        }

        //
        // Make sure we only use the devinfo element's window if it's valid.
        //
        if(hwndParent = DevInfoElem->InstallParamBlock.hwndParent) {
           if(!IsWindow(hwndParent)) {
                hwndParent = NULL;
           }
        }

        //
        // Ignore the DI_NOFILECOPY flag if we're doing a copy-only installation--that's
        // what setupx does.
        //
        if(DoFileCopying = (!(DevInfoElem->InstallParamBlock.Flags & DI_NOFILECOPY) || !DoFullInstall)) {

            if(UserFileQ == INVALID_HANDLE_VALUE) {

                if(DevInfoElem->InstallParamBlock.Flags & DI_NOVCP) {
                    //
                    // We must have a user-supplied file queue.
                    //
                    MYASSERT(DevInfoElem->InstallParamBlock.UserFileQ);
                    UserFileQ = DevInfoElem->InstallParamBlock.UserFileQ;
                } else {
                    //
                    // Create our own queue.
                    //
                    if((UserFileQ = SetupOpenFileQueue()) != INVALID_HANDLE_VALUE) {
                        CloseUserFileQ = TRUE;

                    } else {
                        //
                        // SetupOpenFileQueue sets actual error
                        //
                        Err = GetLastError();
                        goto clean0;
                    }
                }
                //
                // Maybe replace the file queue's log context with the DevInfoElem's
                //
                InheritLogContext(LogContext,
                    &((PSP_FILE_QUEUE) UserFileQ)->LogContext);

            }
        }

        szInfFileName = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                 DevInfoElem->SelectedDriver->InfFileName
                                                );

        szInfSectionName = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                    DevInfoElem->SelectedDriver->InfSectionName
                                                   );

        if(hDeviceInf == INVALID_HANDLE_VALUE) {

            if((hDeviceInf = SetupOpenInfFile(szInfFileName,
                                              NULL,
                                              INF_STYLE_WIN4,
                                              NULL)) == INVALID_HANDLE_VALUE) {
                Err = GetLastError();
                goto clean0;
            }

            CloseInfHandle = TRUE;
        }

        //
        // Find out the 'real' install section we should be using (i.e., the potentially
        // OS/architecture-specific one.
        //
        if(!SetupDiGetActualSectionToInstall(hDeviceInf,
                                             szInfSectionName,
                                             InfSectionWithExt,
                                             SIZECHARS(InfSectionWithExt),
                                             &InfSectionWithExtLength,
                                             NULL
                                             )) {
            Err = GetLastError();
            goto clean0;
        }

        //
        // Now append the ".Interfaces" extension to the install section name to find
        // the interface install section to run.
        //
        CopyMemory(&(InfSectionWithExt[InfSectionWithExtLength - 1]),
                   pszInterfacesSectionSuffix,
                   sizeof(pszInterfacesSectionSuffix)
                  );

        if(slot_section == 0) {
            //
            // we haven't done anything about logging section yet...
            //
            slot_section = AllocLogInfoSlotOrLevel(LogContext,DRIVER_LOG_VERBOSE,FALSE);
            //
            // Say what section is about to be installed.
            //
            WriteLogEntry(LogContext,
                slot_section,
                MSG_LOG_INSTALLING_SECTION_FROM,
                NULL,
                InfSectionWithExt,
                szInfFileName);
        }

        //
        // Append the layout INF, if necessary.
        //
        if(DoFileCopying) {
            SetupOpenAppendInfFile(NULL, hDeviceInf, NULL);
        }

        //
        // Append-load any included INFs specified in an "include=" line in our
        // install section.
        //
        AppendLoadIncludedInfs(hDeviceInf, szInfFileName, InfSectionWithExt, DoFileCopying);

        NeedsSectionList = GetMultiSzFromInf(hDeviceInf, InfSectionWithExt, TEXT("needs"), &b);

        if(!NeedsSectionList && b) {
            //
            // Out of memory!
            //
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        //
        // Process the "AddInterface" lines in this section, as well as those contained with any
        // sections referenced in the "needs=" entry in this section.
        //
        for(CurInstallSection = InfSectionWithExt;
            (CurInstallSection && *CurInstallSection);
            CurInstallSection = (CurInstallSection == InfSectionWithExt)
                                ? NeedsSectionList
                                : (CurInstallSection + lstrlen(CurInstallSection) + 1))
        {
            if(SetupFindFirstLine(hDeviceInf, CurInstallSection, pszAddInterface, &InterfaceDeviceInstallLine)) {

                do {
                    //
                    // Retrieve the interface class GUID for this interface device.
                    //
                    if(!SetupGetStringField(&InterfaceDeviceInstallLine,
                                            1,
                                            InterfaceGuidString,
                                            SIZECHARS(InterfaceGuidString),
                                            NULL))
                    {
                        Err = ERROR_BAD_INTERFACE_INSTALLSECT;
                        goto clean0;
                    }

                    if(NO_ERROR != pSetupGuidFromString(InterfaceGuidString, &InterfaceGuid)) {
                        Err = ERROR_BAD_INTERFACE_INSTALLSECT;
                        goto clean0;
                    }

                    //
                    // Next, we need to check and see if the specified interface class is already present.
                    // If not, we'll need to install it, too.
                    //
                    NeedToInstallInterfaceClass = FALSE;

                    hKeyInterfaceClass = SetupDiOpenClassRegKeyEx(&InterfaceGuid,
                                                                  KEY_READ,
                                                                  DIOCR_INTERFACE,
                                                                  NULL,
                                                                  NULL
                                                                 );

                    if(hKeyInterfaceClass != INVALID_HANDLE_VALUE) {
                        //
                        // OK, this interface class already exists.  We don't need to install it.
                        //
                        RegCloseKey(hKeyInterfaceClass);
                        hKeyInterfaceClass = INVALID_HANDLE_VALUE;

                    } else {
                        //
                        // This interface class isn't currently installed.  Check to see if we've
                        // already encountered this class (and added it to our list of interface
                        // classes to install).
                        //
                        for(CurInterfaceInstallNode = InterfacesToInstall;
                            CurInterfaceInstallNode;
                            CurInterfaceInstallNode = CurInterfaceInstallNode->Next)
                        {
                            if(IsEqualGUID(&InterfaceGuid, &(CurInterfaceInstallNode->InterfaceGuid))) {
                                //
                                // The installation of this interface class is already in our
                                // 'to do' list.
                                //
                                break;
                            }
                        }

                        if(!CurInterfaceInstallNode) {
                            NeedToInstallInterfaceClass = TRUE;
                        }
                    }

                    if(NeedToInstallInterfaceClass) {
                        //
                        // Look for this interface class GUID in the INF's [InterfaceInstall32] section
                        // (if present).
                        //
                        if(SetupFindFirstLine(hDeviceInf,
                                              pszInterfaceInstall32,
                                              InterfaceGuidString,
                                              &InterfaceClassInstallLine)) {
                            //
                            // Get the name of the install section for this interface class.
                            //
                            if((UndecoratedInstallSection = pSetupGetField(&InterfaceClassInstallLine, 1))
                               && !(*UndecoratedInstallSection))
                            {
                                UndecoratedInstallSection = NULL;
                            }

                            if(!UndecoratedInstallSection) {
                                *InterfaceInstallSection = TEXT('\0');
                            } else {
                                //
                                // Get the (potentially) os/architecture-specific install section.
                                //
                                PTSTR SectionExtension;

                                if(!SetupDiGetActualSectionToInstall(hDeviceInf,
                                                                 UndecoratedInstallSection,
                                                                 InterfaceInstallSection,
                                                                 SIZECHARS(InterfaceInstallSection),
                                                                 NULL,
                                                                 &SectionExtension
                                                                 )) {
                                    Err = GetLastError();
                                    goto clean0;
                                }
                                //
                                // If this is the undecorated name, then make sure that the section actually exists.
                                //
                                if(!SectionExtension && (SetupGetLineCount(hDeviceInf, InterfaceInstallSection) == -1)) {
                                    WriteLogEntry(LogContext,
                                        DRIVER_LOG_ERROR,
                                        MSG_LOG_NOSECTION,
                                        NULL,
                                        InterfaceInstallSection);
                                    Err = ERROR_SECTION_NOT_FOUND;
                                    goto clean0;
                                }
                            }

                            if(!SetupGetIntField(&InterfaceClassInstallLine, 2, (PINT)&InstallFlags)) {
                                InstallFlags = 0;
                            }

                        } else {
                            *InterfaceInstallSection = TEXT('\0');
                            InstallFlags = 0;
                        }

                        //
                        // At this point, we just want to queue up any file operations required.
                        //
                        if(DoFileCopying && *InterfaceInstallSection) {

                            Err = pSetupInstallFiles(hDeviceInf,
                                                     NULL,
                                                     InterfaceInstallSection,
                                                     NULL,
                                                     NULL,
                                                     NULL,
                                                     SP_COPY_NEWER_OR_SAME | SP_COPY_LANGUAGEAWARE |
                                                         ((DevInfoElem->InstallParamBlock.Flags & DI_NOBROWSE) ? SP_COPY_NOBROWSE : 0),
                                                     NULL,
                                                     UserFileQ,
                                                     TRUE
                                                    );

                            if(Err != NO_ERROR) {
                                goto clean0;
                            }
                        }

                        //
                        // Now add a node onto our 'to do' list of interface classes to install.
                        //
                        if(InterfaceInstallNode = MyMalloc(sizeof(INTERFACE_CLASS_TO_INSTALL))) {

                            CopyMemory(&(InterfaceInstallNode->InterfaceGuid),
                                       &InterfaceGuid,
                                       sizeof(InterfaceGuid)
                                      );

                            lstrcpy(InterfaceInstallNode->InstallSection, InterfaceInstallSection);
                            InterfaceInstallNode->Flags = InstallFlags;

                            InterfaceInstallNode->Next = InterfacesToInstall;
                            InterfacesToInstall = InterfaceInstallNode;

                            //
                            // Now set newly allocated node pointer to NULL, so we won't try
                            // to free it if we hit an exception.
                            //
                            InterfaceInstallNode = NULL;

                        } else {
                            Err = ERROR_NOT_ENOUGH_MEMORY;
                            goto clean0;
                        }
                    }

                    //
                    // Now queue up any file operations for this particular device interface.
                    //
                    if(DoFileCopying
                       && SetupGetStringField(&InterfaceDeviceInstallLine,
                                           3,
                                           InterfaceInstallSection,
                                           SIZECHARS(InterfaceInstallSection),
                                           NULL)
                       && *InterfaceInstallSection)
                    {
                        Err = pSetupInstallFiles(hDeviceInf,
                                                 NULL,
                                                 InterfaceInstallSection,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 SP_COPY_NEWER_OR_SAME | SP_COPY_LANGUAGEAWARE |
                                                     ((DevInfoElem->InstallParamBlock.Flags & DI_NOBROWSE)? SP_COPY_NOBROWSE : 0),
                                                 NULL,
                                                 UserFileQ,
                                                 TRUE
                                                );

                        if(Err != NO_ERROR) {
                            goto clean0;
                        }
                    }

                } while(SetupFindNextMatchLine(&InterfaceDeviceInstallLine, pszAddInterface, &InterfaceDeviceInstallLine));
            }
        }

        //
        // Mark the queue as a device install queue (and make sure there's a
        // catalog node representing our device INF in the queue).
        //
        if(DoFileCopying) {
            MYASSERT(UserFileQ && (UserFileQ != INVALID_HANDLE_VALUE));
            Err = MarkQueueForDeviceInstall(UserFileQ,
                                            hDeviceInf,
                                            pStringTableStringFromId(
                                                pDeviceInfoSet->StringTable,
                                                DevInfoElem->SelectedDriver->DrvDescription)
                                           );
        }

        //
        // At this point, we have queued up all the files that need to be
        // copied.  If we weren't given a user-supplied queue, then commit our
        // queue now.
        //
        if(CloseUserFileQ) {

            if(Err == NO_ERROR) {
                //
                // Determine whether the queue actually needs to be committed.
                //
                // ScanQueueResult can have 1 of 3 values:
                //
                // 0: Some files were missing--must commit queue.
                //
                // 1: All files to be copied are already present and valid,
                //    and the queue is empty--skip committing queue.
                //
                // 2: All files to be copied are present/valid, but
                //    del/ren/backup queues not empty--must commit queue.
                //    The copy queue will have been emptied, so only
                //    del/ren/backup functions will be performed.
                //
                // (jamiehun) see previous case of SetupScanFileQueue for a
                // discussion of DI_FLAGSEX_PREINSTALLBACKUP handling.
                //
                if(!SetupScanFileQueue(UserFileQ,
                                       SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_PRUNE_COPY_QUEUE,
                                       hwndParent,
                                       NULL,
                                       NULL,
                                       &ScanQueueResult)) {
                    //
                    // SetupScanFileQueue should really never fail when you
                    // don't ask it to call a callback routine, but if it does,
                    // just go ahead and commit the queue.
                    //
                    ScanQueueResult = 0;
                }
            }

            if((Err == NO_ERROR) && (ScanQueueResult != 1)) {
                //
                // We need to commit this file queue.  Figure out what message
                // handler to use.
                //
                if(DevInfoElem->InstallParamBlock.InstallMsgHandler) {
                    MsgHandler = DevInfoElem->InstallParamBlock.InstallMsgHandler;
                    MsgHandlerContext = DevInfoElem->InstallParamBlock.InstallMsgHandlerContext;
                    MsgHandlerIsNativeCharWidth = DevInfoElem->InstallParamBlock.InstallMsgHandlerIsNativeCharWidth;
                } else {

                    NoProgressUI = (GuiSetupInProgress || (DevInfoElem->InstallParamBlock.Flags & DI_QUIETINSTALL));

                    if(MsgHandlerContext = SetupInitDefaultQueueCallbackEx(
                                              hwndParent,
                                              (NoProgressUI ? INVALID_HANDLE_VALUE : NULL),
                                              0,
                                              0,
                                              NULL))
                    {
                        FreeMsgHandlerContext = TRUE;
                        MsgHandler = SetupDefaultQueueCallback;
                        MsgHandlerIsNativeCharWidth = TRUE;
                    } else {
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }

                //
                // Copy enqueued files.
                //
                if(Err == NO_ERROR) {

                    //
                    // Call _SetupVerifyQueuedCatalogs separately (i.e., don't
                    // let it happen automatically as a result of committing
                    // the queue that happens below).  We do this beforehand so
                    // that we know what unique name was generated when an OEM
                    // INF was installed into %windir%\Inf (in case we need to
                    // delete the INF/PNF/CAT files later if we encounter an
                    // error).
                    //
                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_TIME,
                        MSG_LOG_BEGIN_INTFC_VERIFY_CAT_TIME,
                        NULL);       // text message

                    Err = _SetupVerifyQueuedCatalogs(
                              hwndParent,
                              UserFileQ,
                              (VERCAT_INSTALL_INF_AND_CAT |
                               ((DevInfoElem->SelectedDriver->Flags & DNF_INET_DRIVER)
                                    ? VERCAT_PRIMARY_DEVICE_INF_FROM_INET : 0)),
                              szNewName,
                              &OemInfFileToCopy
                             );

                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_TIME,
                        MSG_LOG_END_INTFC_VERIFY_CAT_TIME,
                        NULL);       // text message

                    if(Err == NO_ERROR) {

                        if(_SetupCommitFileQueue(hwndParent,
                                                 UserFileQ,
                                                 MsgHandler,
                                                 MsgHandlerContext,
                                                 MsgHandlerIsNativeCharWidth
                                                 )) {
                            //
                            // Check to see whether a reboot is required as a
                            // result of committing the queue (i.e., because files
                            // were in use, or the INF requested a reboot).
                            //
                            FileQueueNeedsReboot = SetupPromptReboot(UserFileQ, NULL, TRUE);
                            //
                            // This should never fail...
                            //
                            MYASSERT(FileQueueNeedsReboot != -1);

                            if(FileQueueNeedsReboot) {
                                SetDevnodeNeedsRebootProblem(DevInfoElem, pDeviceInfoSet,
                                                             MSG_LOG_REBOOT_REASON_INUSE);
                            }

                        } else {
                            Err = GetLastError();
                        }
                    }
                }
            }

            //
            // Close our file queue handle.
            //
            SetupCloseFileQueue(UserFileQ);
            CloseUserFileQ = FALSE;

            //
            // Terminate the default queue callback, if it was created.
            //
            if(FreeMsgHandlerContext) {
                SetupTermDefaultQueueCallback(MsgHandlerContext);
                FreeMsgHandlerContext = FALSE;
            }

            if(Err != NO_ERROR) {
                goto clean0;
            }
        }

        //
        // If all we were asked to do was copy files, then we're done.
        //
        if(!DoFullInstall) {
            goto clean0;
        }

        //
        // Now go through our list of interface classes to install, and install
        // each one.
        //
        if(CurInterfaceInstallNode = InterfacesToInstall) {
            //
            // Open a handle to the root of the DeviceClasses registry branch.
            //
            hKeyDeviceClassesRoot = SetupDiOpenClassRegKeyEx(NULL,
                                                             KEY_ALL_ACCESS,
                                                             DIOCR_INTERFACE,
                                                             NULL,
                                                             NULL
                                                            );

            if(hKeyDeviceClassesRoot == INVALID_HANDLE_VALUE) {
                Err = GetLastError();
                goto clean0;
            }

            do {
                //
                // Presently, the flags field, if present, must be zero.
                //
                if(CurInterfaceInstallNode->Flags) {
                    Err = ERROR_INVALID_FLAGS;
                    goto clean0;
                }

                pSetupStringFromGuid(&(CurInterfaceInstallNode->InterfaceGuid),
                                     InterfaceGuidString,
                                     SIZECHARS(InterfaceGuidString)
                                    );

                Err = RegCreateKeyEx(hKeyDeviceClassesRoot,
                                     InterfaceGuidString,
                                     0,
                                     NULL,
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_ALL_ACCESS,
                                     NULL,
                                     &hKeyInterfaceClass,
                                     &RegDisposition
                                    );

                if(Err != ERROR_SUCCESS) {
                    //
                    // Ensure that the registry handle is still invalid, so we won't try
                    // to close it.
                    //
                    hKeyInterfaceClass = INVALID_HANDLE_VALUE;
                    goto clean0;
                }

                //
                // Now run the INF section for this newly-created key.
                //
                if(!SetupInstallFromInfSection(NULL,
                                               hDeviceInf,
                                               CurInterfaceInstallNode->InstallSection,
                                               SPINST_INIFILES
                                               | SPINST_REGISTRY
                                               | SPINST_INI2REG
                                               | SPINST_BITREG
                                               | SPINST_REGSVR
                                               | SPINST_UNREGSVR
                                               | SPINST_PROFILEITEMS,
                                               hKeyInterfaceClass,
                                               NULL,
                                               0,
                                               NULL,
                                               NULL,
                                               INVALID_HANDLE_VALUE,
                                               NULL))
                {
                    Err = GetLastError();
                    //
                    // Normally, we would want to clean up this newly-created key.
                    // However, the kernel-mode IoRegisterDeviceClassAssociation API
                    // will quite happily create the class key if it doesn't exist.
                    // Thus, a driver might have registered a device while we were
                    // trying to run the INF, and if we deleted the key that might
                    // really mess things up.  Thus, we'll leave this alone.  Since
                    // we should never see a failure with this call, this isn't a big
                    // deal anyway.
                    //
                }

                RegCloseKey(hKeyInterfaceClass);
                hKeyInterfaceClass = INVALID_HANDLE_VALUE;

                if(Err != NO_ERROR) {
                    goto clean0;
                }

                CurInterfaceInstallNode = CurInterfaceInstallNode->Next;

            } while(CurInterfaceInstallNode);
        }

        //
        // At this point, we've done everything except for actually registering the
        // interface devices and (potentially) running INFs against their registry keys.
        // Do that now...
        //
        InterfaceDeviceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

        for(CurInstallSection = InfSectionWithExt;
            (CurInstallSection && *CurInstallSection);
            CurInstallSection = (CurInstallSection == InfSectionWithExt)
                                ? NeedsSectionList
                                : (CurInstallSection + lstrlen(CurInstallSection) + 1))
        {
            if(SetupFindFirstLine(hDeviceInf, CurInstallSection, pszAddInterface, &InterfaceDeviceInstallLine)) {

                do {
                    //
                    // Retrieve the interface class GUID for this interface device.  (There's
                    // no need to check the return status of these two calls, since we've already
                    // done this once, and they were fine.
                    //
                    SetupGetStringField(&InterfaceDeviceInstallLine,
                                        1,
                                        InterfaceGuidString,
                                        SIZECHARS(InterfaceGuidString),
                                        NULL
                                       );
                    pSetupGuidFromString(InterfaceGuidString, &InterfaceGuid);

                    if(!SetupGetStringField(&InterfaceDeviceInstallLine,
                                            2,
                                            RefString,
                                            SIZECHARS(RefString),
                                            NULL))
                    {
                        *RefString = TEXT('\0');
                    }

                    if(!SetupGetStringField(&InterfaceDeviceInstallLine,
                                            3,
                                            InterfaceInstallSection,
                                            SIZECHARS(InterfaceInstallSection),
                                            NULL))
                    {
                        *InterfaceInstallSection = TEXT('\0');
                    }

                    if(!SetupGetIntField(&InterfaceDeviceInstallLine, 4, (PINT)&InstallFlags)) {
                        InstallFlags = 0;
                    }

                    //
                    // (Presently, no flags are defined--field, if present, must be zero.
                    //
                    if(InstallFlags) {
                        Err = ERROR_INVALID_FLAGS;
                        goto clean0;
                    }

                    //
                    // OK, we have all the information we need to create this interface device.
                    //
                    if(!SetupDiCreateDeviceInterface(DeviceInfoSet,
                                                     DeviceInfoData,
                                                     &InterfaceGuid,
                                                     (*RefString) ? RefString : NULL,
                                                     0,
                                                     &InterfaceDeviceData)) {
                        Err = GetLastError();
                        goto clean0;
                    }

                    if(*InterfaceInstallSection) {
                        //
                        // Run the INF against this interface device's registry key.
                        //
                        hKeyInterfaceDevice = SetupDiCreateDeviceInterfaceRegKey(DeviceInfoSet,
                                                                                 &InterfaceDeviceData,
                                                                                 0,
                                                                                 KEY_ALL_ACCESS,
                                                                                 INVALID_HANDLE_VALUE,
                                                                                 NULL
                                                                                );

                        if(hKeyInterfaceDevice == INVALID_HANDLE_VALUE) {
                            Err = GetLastError();
                            goto clean0;
                        }

                        //
                        // Now run the INF section for this newly-created key.
                        //
                        if(!SetupInstallFromInfSection(NULL,
                                                       hDeviceInf,
                                                       InterfaceInstallSection,
                                                       SPINST_INIFILES
                                                       | SPINST_REGISTRY
                                                       | SPINST_INI2REG
                                                       | SPINST_BITREG
                                                       | SPINST_REGSVR
                                                       | SPINST_UNREGSVR
                                                       | SPINST_PROFILEITEMS,
                                                       hKeyInterfaceDevice,
                                                       NULL,
                                                       0,
                                                       NULL,
                                                       NULL,
                                                       INVALID_HANDLE_VALUE,
                                                       NULL))
                        {
                            Err = GetLastError();
                        }

                        RegCloseKey(hKeyInterfaceDevice);
                        hKeyInterfaceDevice = INVALID_HANDLE_VALUE;

                        if(Err != NO_ERROR) {
                            goto clean0;
                        }
                    }

                } while(SetupFindNextMatchLine(&InterfaceDeviceInstallLine, pszAddInterface, &InterfaceDeviceInstallLine));
            }
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;

        if(hKeyInterfaceClass != INVALID_HANDLE_VALUE) {
            RegCloseKey(hKeyInterfaceClass);
        }

        if(hKeyInterfaceDevice != INVALID_HANDLE_VALUE) {
            RegCloseKey(hKeyInterfaceDevice);
        }

        if(InterfaceInstallNode) {
            MyFree(InterfaceInstallNode);
        }

        if(FreeMsgHandlerContext) {
            SetupTermDefaultQueueCallback(MsgHandlerContext);
        }
        if(CloseUserFileQ) {
            SetupCloseFileQueue(UserFileQ);
        }

        //
        // Reference the following variables so the compiler will respect statement
        // ordering w.r.t. assignment.
        //
        InterfacesToInstall = InterfacesToInstall;
        CloseInfHandle = CloseInfHandle;
        NeedsSectionList = NeedsSectionList;
        OemInfFileToCopy = OemInfFileToCopy;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    for(CurInterfaceInstallNode = InterfacesToInstall;
        CurInterfaceInstallNode;
        CurInterfaceInstallNode = InterfacesToInstall) {

        InterfacesToInstall = CurInterfaceInstallNode->Next;
        MyFree(CurInterfaceInstallNode);
    }

    if(hKeyDeviceClassesRoot != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKeyDeviceClassesRoot);
    }

    if(CloseInfHandle) {
        MYASSERT(hDeviceInf != INVALID_HANDLE_VALUE);
        SetupCloseInfFile(hDeviceInf);
    }

    if(NeedsSectionList) {
        MyFree(NeedsSectionList);
    }

clean1:
    if (Err == NO_ERROR) {
        //
        // give a +ve affirmation of Success
        //
        WriteLogEntry(
            LogContext,
            DoFullInstall ? DRIVER_LOG_INFO : DRIVER_LOG_VERBOSE,
            MSG_LOG_INSTALLEDINTERFACES,
            NULL);
    } else {
        //
        // indicate failed, display error
        //
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
            MSG_LOG_INSTALLINTERFACES_ERROR,
            NULL);
        WriteLogError(
            LogContext,
            DRIVER_LOG_ERROR,
            Err);

        //
        // If we copied the OEM INF into the INF directory under a newly-
        // generated name, delete it now.
        //
        if(OemInfFileToCopy) {
            pSetupUninstallOEMInf(szNewName, LogContext, SUOI_FORCEDELETE, NULL);
        }
    }

    if (slot_section) {
        ReleaseLogInfoSlot(LogContext,slot_section);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}

BOOL
pSetupGetSourceMediaTypeFromPnf(
    PCTSTR InfName,
    PDWORD SourceMediaType
    )

/*++

Routine Description:

    This function will get the Source Media Type from the PNF for a given INF
    file.  If the INF does not have a PNF file then the API will fail.

Arguments:

    InfFileName - Supplies the full path of the INF that we will get the source
        media type from it's PNF.


    SourceMediaType - Supplies a pointer that will be filled in the the source
        media type from the PNF.

Return Value:

    TRUE if the INF has a PNF and we are able to get a valid source media type
    FALSE if their is no PNF for this INF.

Remarks:


--*/

{
    PLOADED_INF Inf;
    BOOL PnfWasUsed;
    WIN32_FIND_DATA  InfFileData;
    UINT ErrorLineNumber;
    BOOL bReturn = FALSE;

    if (FileExists(InfName, &InfFileData)) {

        if(LoadInfFile(InfName,
                   &InfFileData,
                   INF_STYLE_WIN4,
                   LDINF_FLAG_IGNORE_VOLATILE_DIRIDS,
                   NULL,
                   NULL,
                   NULL,
                   NULL,
                   NULL,
                   &Inf,
                   &ErrorLineNumber,
                   &PnfWasUsed) == NO_ERROR) {

            if (PnfWasUsed) {

                //
                // We were able to open the INF with a PNF.  Now get the
                // InfSourceMediaType.
                //
                LockInf(Inf);
                *SourceMediaType = Inf->InfSourceMediaType;
                UnlockInf(Inf);

                bReturn = TRUE;
            }

            FreeInfFile(Inf);
        }
    }

    return bReturn;
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupCopyOEMInfA(
    IN  PCSTR   SourceInfFileName,
    IN  PCSTR   OEMSourceMediaLocation,         OPTIONAL
    IN  DWORD   OEMSourceMediaType,
    IN  DWORD   CopyStyle,
    OUT PSTR    DestinationInfFileName,         OPTIONAL
    IN  DWORD   DestinationInfFileNameSize,
    OUT PDWORD  RequiredSize,                   OPTIONAL
    OUT PSTR   *DestinationInfFileNameComponent OPTIONAL
    )
{
    PWSTR UnicodeSourceInfFileName, UnicodeOEMSourceMediaLocation, UnicodeFileNameComponent;
    WCHAR UnicodeDestinationInfFileName[MAX_PATH];
    PSTR AnsiDestinationInfFileName;
    DWORD AnsiRequiredSize;
    DWORD rc;
    BOOL b;
    DWORD CharOffset, i;
    PSTR p;
    WCHAR SourceInfCatalogName[MAX_PATH];
    WCHAR CatalogFilenameOnSystem[MAX_PATH];
    BOOL DifferentOriginalName;
    TCHAR OriginalInfName[MAX_PATH];
    HINF hInf;
    DWORD CodeSigningPolicy;
    BOOL UseOriginalInfName;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    PSP_ALTPLATFORM_INFO_V2 ValidationPlatform;

    rc = pSetupCaptureAndConvertAnsiArg(SourceInfFileName,
                                        &UnicodeSourceInfFileName
                                       );
    if(rc != NO_ERROR) {
        SetLastError(rc);
        return FALSE;
    }

    //
    // Open the specified INF.
    //
    hInf = SetupOpenInfFile(UnicodeSourceInfFileName,
                            NULL,
                            INF_STYLE_OLDNT | INF_STYLE_WIN4,
                            NULL
                           );

    if(hInf == INVALID_HANDLE_VALUE) {
        rc = GetLastError();
        MyFree(UnicodeSourceInfFileName);
        SetLastError(rc);
        return FALSE;
    }

    ValidationPlatform = NULL;

    //
    // GetCodeSigningPolicyForInf() presently can generate an unhandled
    // exception, so guard the code below in try/except to protect ourselves...
    //
    try {

        if(NO_ERROR != InheritLogContext(((PLOADED_INF)hInf)->LogContext,
                                         &LogContext)) {
            LogContext = NULL;
        }

        //
        // Retrieve the CatalogFile entry (if present) from this INF's version
        // section.
        //
        rc = pGetInfOriginalNameAndCatalogFile(
                 (PLOADED_INF)hInf,
                 NULL,
                 &DifferentOriginalName,
                 OriginalInfName,
                 SIZECHARS(OriginalInfName),
                 SourceInfCatalogName,
                 SIZECHARS(SourceInfCatalogName),
                 NULL // always native OS/arch (ver doesn't matter for CatalogFile=)
                );

        if(rc == NO_ERROR) {
            CodeSigningPolicy = GetCodeSigningPolicyForInf(LogContext,
                                                           hInf,
                                                           &ValidationPlatform,
                                                           &UseOriginalInfName
                                                          );

            if(UseOriginalInfName) {
                //
                // If we're looking at an exception INF, make sure it's under its
                // original name.
                //
                if(DifferentOriginalName) {
                    rc = ERROR_INVALID_CLASS;
                }
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // If we hit an AV, then use invalid parameter error, otherwise, assume
        // an inpage error when dealing with a mapped-in file (e.g., in the
        // call to GetCodeSigningPolicyForInf).
        //
        rc = (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) ? ERROR_INVALID_PARAMETER : ERROR_READ_FAULT;
    }

    //
    // We're done with the INF handle
    //
    SetupCloseInfFile(hInf);

    if(rc == NO_ERROR) {
        if(OEMSourceMediaLocation) {
            rc = pSetupCaptureAndConvertAnsiArg(OEMSourceMediaLocation,
                                                &UnicodeOEMSourceMediaLocation
                                               );
        } else {
            UnicodeOEMSourceMediaLocation = NULL;
        }
    }

    if(rc != NO_ERROR) {
        MyFree(UnicodeSourceInfFileName);
        if(ValidationPlatform) {
            MyFree(ValidationPlatform);
        }
        SetLastError(rc);
        return FALSE;
    }

    b = _SetupCopyOEMInf(UnicodeSourceInfFileName,
                         UnicodeOEMSourceMediaLocation,
                         OEMSourceMediaType,
                         CopyStyle,
                         UnicodeDestinationInfFileName,
                         SIZECHARS(UnicodeDestinationInfFileName),
                         NULL,
                         &UnicodeFileNameComponent,
                         (DifferentOriginalName ? OriginalInfName
                                                : pSetupGetFileTitle(UnicodeSourceInfFileName)),
                         (*SourceInfCatalogName ? SourceInfCatalogName : NULL),
                         NULL,  // no HWND for UI!
                         NULL,
                         CodeSigningPolicy,
                         SCOI_NO_ERRLOG_IF_INF_ALREADY_PRESENT |
                          (UseOriginalInfName ? SCOI_KEEP_INF_AND_CAT_ORIGINAL_NAMES : 0),
                         NULL,
                         ValidationPlatform,
                         NULL,
                         CatalogFilenameOnSystem,
                         LogContext, // either made-up or thread log context
                         NULL
                        );
    rc = GetLastError();

    if(b || (rc == ERROR_FILE_EXISTS)) {

        if(DestinationInfFileName || RequiredSize) {

            if(AnsiDestinationInfFileName = pSetupUnicodeToAnsi(UnicodeDestinationInfFileName)) {

                AnsiRequiredSize = lstrlenA(AnsiDestinationInfFileName) + 1;

                if(RequiredSize) {
                    try {
                        *RequiredSize = AnsiRequiredSize;
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        b = FALSE;
                        rc = ERROR_INVALID_PARAMETER;
                    }
                }

                if((b || (rc == ERROR_FILE_EXISTS)) && DestinationInfFileName) {

                    if(AnsiRequiredSize <= DestinationInfFileNameSize) {
                        if(!lstrcpyA(DestinationInfFileName, AnsiDestinationInfFileName)) {
                            //
                            // lstrcpy faulted; DestinationInfFileName must be bad
                            //
                            b = FALSE;
                            rc = ERROR_INVALID_PARAMETER;
                        } else if(DestinationInfFileNameComponent) {
                            //
                            // We need to figure out where the extension is
                            // in the converted string. To be DBCS safe we will
                            // count characters forward to find it.
                            //
                            CharOffset = (DWORD)(UnicodeFileNameComponent - UnicodeDestinationInfFileName);
                            p = DestinationInfFileName;
                            for(i = 0; i < CharOffset; i++) {
                                p = CharNextA(p);
                            }

                            try {
                                *DestinationInfFileNameComponent = p;
                            } except(EXCEPTION_EXECUTE_HANDLER) {
                                b = FALSE;
                                rc = ERROR_INVALID_PARAMETER;
                            }
                        }
                    } else {
                        rc = ERROR_INSUFFICIENT_BUFFER;
                        b = FALSE;
                    }
                }

                MyFree(AnsiDestinationInfFileName);

            } else {
                b = FALSE;
                rc = ERROR_NOT_ENOUGH_MEMORY;
            }

        } else {
            //
            // It would be dumb to request the filename part of the destination INF path when
            // the path itself wasn't requested, but let's make sure we set this to NULL if
            // that happens.
            //
            if(DestinationInfFileNameComponent) {
                try {
                    *DestinationInfFileNameComponent = NULL;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    b = FALSE;
                    rc = ERROR_INVALID_PARAMETER;
                }
            }
        }
    }

    MyFree(UnicodeSourceInfFileName);
    if(UnicodeOEMSourceMediaLocation) {
        MyFree(UnicodeOEMSourceMediaLocation);
    }
    if(ValidationPlatform) {
        MyFree(ValidationPlatform);
    }
    DeleteLogContext(LogContext);

    SetLastError(rc);
    return b;
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupCopyOEMInfW(
    IN  PCWSTR  SourceInfFileName,
    IN  PCWSTR  OEMSourceMediaLocation,         OPTIONAL
    IN  DWORD   OEMSourceMediaType,
    IN  DWORD   CopyStyle,
    OUT PWSTR   DestinationInfFileName,         OPTIONAL
    IN  DWORD   DestinationInfFileNameSize,
    OUT PDWORD  RequiredSize,                   OPTIONAL
    OUT PWSTR  *DestinationInfFileNameComponent OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(SourceInfFileName);
    UNREFERENCED_PARAMETER(OEMSourceMediaLocation);
    UNREFERENCED_PARAMETER(OEMSourceMediaType);
    UNREFERENCED_PARAMETER(CopyStyle);
    UNREFERENCED_PARAMETER(DestinationInfFileName);
    UNREFERENCED_PARAMETER(DestinationInfFileNameSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    UNREFERENCED_PARAMETER(DestinationInfFileNameComponent);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}
#endif

BOOL
WINAPI
SetupCopyOEMInf(
    IN  PCTSTR  SourceInfFileName,
    IN  PCTSTR  OEMSourceMediaLocation,         OPTIONAL
    IN  DWORD   OEMSourceMediaType,
    IN  DWORD   CopyStyle,
    OUT PTSTR   DestinationInfFileName,         OPTIONAL
    IN  DWORD   DestinationInfFileNameSize,
    OUT PDWORD  RequiredSize,                   OPTIONAL
    OUT PTSTR  *DestinationInfFileNameComponent OPTIONAL
    )
/*++

Routine Description:

    This API copies an INF into %windir%\Inf, giving it a unique name if it
    doesn't already exist there.  We determine whether the INF already exists
    in the INF directory as follows:

    1.  All INFs of the form "OEM*.INF" are enumerated, and any that have the
        same file size as that of our INF are binary-compared with it.

    2.  We also look for the INF using its source filename.  If a file of the
        same name exists, and is the same size as that of our INF, we
        binary-compare the two to see if they are identical.

    If the INF already exists (by either of the two criteria described above),
    then we will further check to see if the INF specifies a CatalogFile= entry
    in its version section.  If so, we will see if that catalog is already
    installed (using the INF's %windir%\Inf primary filename with a ".CAT"
    extension).  If there is a catalog installed, but it isn't the same as the
    catalog associated with the source INF, then we won't consider that INF to
    be a match, and we'll keep enumerating looking for a match.  This means
    it's possible to have multiple identical INFs contained in %windir%\Inf,
    each having its own unique catalog.  (In general, this shouldn't happen,
    since driver package updates should also update the DriverVer information
    in the INF, thus you wouldn't get identical INFs in the first place.)  If
    we don't find an existing match (i.e., both INF and CAT), then we'll
    install the INF and CAT under a new, unique name.

    OEM INFs that don't specify a CatalogFile= entry are considered invalid
    w.r.t. digital signature verification.

    In cases where the INF must be copied to %windir%\Inf (i.e., it wasn't
    already there), we'll report any digital signature verification failures
    (based on applicable policy).

    If we decide that the INF/CAT files already exist, then we will use that
    name, and our replacement behavior is based on the caller-specified
    CopyStyle flags.  (NOTE: Replacement behavior here refers solely to the
    source media information stored in the PNF.  We will not blow away existing
    INFs/PNFs/CATs under any circumstances.)

Arguments:

    SourceInfFileName - Specifies the full path to the INF to be copied.

    OEMSourceMediaLocation - Specifies source location information to be stored
        in the precompiled INF (.PNF), thus allowing the system to go to the
        correct location for files when installing from this INF.  This location
        information is specific to the source media type specified.

    OEMSourceMediaType - Specifies the type of source media that the location
        information references.  May be one of the following values:

        SPOST_NONE - No source media information should be stored in the PNF
                     file.  (OEMSourceMediaLocation is ignored in this case.)

        SPOST_PATH - OEMSourceMediaLocation contains a path to the source media.
                     For example, if the media is on a floppy, this path might
                     be "A:\". If OEMSourceMediaLocation is NULL, then the path
                     is assumed to be the path where the INF is located (unless
                     the INF has a corresponding PNF in that location, in which
                     case that PNF's source media information will be
                     transferred to the destination PNF).

        SPOST_URL  - OEMSourceMediaLocation contains a URL indicating the
                     internet location where the INF/driver files were retrieved
                     from.  If OEMSourceMediaLocation is NULL, then it is
                     assumed that the default Code Download Manager location was
                     used.

    CopyStyle - Specifies flags that control how the INF is copied into the INF
        directory.  May be a combination of the following flags (all other
        SP_COPY_* flags are ignored).

        SP_COPY_DELETESOURCE - Delete source file on successful copy.

        SP_COPY_REPLACEONLY  - Copy only if this file already exists in the INF
                               directory.  This could be used to update the
                               source location information for an existing INF.

        SP_COPY_NOOVERWRITE  - Copy only if this files doesn't already exist in
                               the INF directory.  If the INF _does_ already
                               exist, this API will fail with GetLastError
                               returning ERROR_FILE_EXISTS.  In this case, the
                               destination INF file information output buffers
                               will be filled in for the existing INF's filename.

        SP_COPY_OEMINF_CATALOG_ONLY - Don't copy the INF into %windir%\Inf--just
                                      install its corresponding catalog file.
                                      If this flag is specified, then the
                                      destination filename information will only
                                      be filled out upon successful return if
                                      the INF is already in the Inf directory.

        SP_COPY_OEM_F6_INF - The Inf was installed by the user during textmode
                             setup using F6.

    DestinationInfFileName - Optionally, supplies a character buffer that
        receives the name that the INF was assigned when it was copied into the
        INF directory.  If the SP_COPY_NOOVERWRITE flag is specified, and the
        API fails with ERROR_FILE_EXISTS, then this buffer will contain the name
        of the existing INF.

        If the SP_COPY_OEMINF_CATALOG_ONLY flag was specified, then this buffer
        will only be filled in with a destination INF filename if the INF is
        already in the INF directory.  Otherwise, this buffer will be set to the
        empty string.

    DestinationInfFileNameSize - Specifies the size, in characters, of the
        DestinationInfFileName buffer, or zero if the buffer is not specified.
        If DestinationInfFileName is specified, and this buffer size is less
        than the size required to return the destination INF name (including
        full path), then this API will fail, and GetLastError will return
        ERROR_INSUFFICIENT_BUFFER.

    RequiredSize - Optionally, supplies the address of a variable that receives
        the size (in characters) required to store the destination INF file name
        (including terminating NULL.

        If the SP_COPY_OEMINF_CATALOG_ONLY flag was specified, then this
        variable will only receive a string length if the INF is already in the
        INF directory.  Otherwise, this variable will be set to zero.

    DestinationInfFileNameComponent - Optionally, supplies the address of a
        character pointer that is set, upon successful return (or
        ERROR_FILE_EXISTS), to point to the beginning of the filename component
        of the path stored in DestinationInfFileName.

        If the SP_COPY_OEMINF_CATALOG_ONLY flag was specified, then the
        DestinationInfFileName may be an empty string (see above).  In that case
        this character pointer will be set to NULL upon successful return.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    TCHAR SourceInfCatalogName[MAX_PATH];
    TCHAR CatalogFilenameOnSystem[MAX_PATH];
    DWORD rc;
    BOOL DifferentOriginalName;
    TCHAR OriginalInfName[MAX_PATH];
    HINF hInf;
    DWORD CodeSigningPolicy;
    BOOL UseOriginalInfName;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    PSP_ALTPLATFORM_INFO_V2 ValidationPlatform;

    //
    // Open the specified INF.
    //
    hInf = SetupOpenInfFile(SourceInfFileName,
                            NULL,
                            INF_STYLE_OLDNT | INF_STYLE_WIN4,
                            NULL
                           );

    if(hInf == INVALID_HANDLE_VALUE) {
        //
        // last error already set.
        //
        return FALSE;
    }

    ValidationPlatform = NULL;

    //
    // GetCodeSigningPolicyForInf() presently can generate an unhandled
    // exception, so guard the code below in try/except to protect ourselves...
    //
    try {

        if(NO_ERROR != InheritLogContext(((PLOADED_INF)hInf)->LogContext,
                                         &LogContext)) {
            LogContext = NULL;
        }

        //
        // Retrieve the CatalogFile entry (if present) from this INF's version
        // section.
        //
        rc = pGetInfOriginalNameAndCatalogFile(
                 NULL,
                 SourceInfFileName,
                 &DifferentOriginalName,
                 OriginalInfName,
                 SIZECHARS(OriginalInfName),
                 SourceInfCatalogName,
                 SIZECHARS(SourceInfCatalogName),
                 NULL // always native OS/arch (ver doesn't matter for CatalogFile=)
                );

        if(rc == NO_ERROR) {
            CodeSigningPolicy = GetCodeSigningPolicyForInf(LogContext,
                                                           hInf,
                                                           &ValidationPlatform,
                                                           &UseOriginalInfName
                                                          );

            if(UseOriginalInfName) {
                //
                // If we're looking at an exception INF, make sure it's under its
                // original name.
                //
                if(DifferentOriginalName) {
                    rc = ERROR_INVALID_CLASS;
                }
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // If we hit an AV, then use invalid parameter error, otherwise, assume
        // an inpage error when dealing with a mapped-in file (e.g., in the
        // call to GetCodeSigningPolicyForInf).
        //
        rc = (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) ? ERROR_INVALID_PARAMETER : ERROR_READ_FAULT;
    }

    //
    // We're done with the INF handle
    //
    SetupCloseInfFile(hInf);

    if(rc != NO_ERROR) {
        goto final;
    }

    if(_SetupCopyOEMInf(SourceInfFileName,
                        OEMSourceMediaLocation,
                        OEMSourceMediaType,
                        CopyStyle,
                        DestinationInfFileName,
                        DestinationInfFileNameSize,
                        RequiredSize,
                        DestinationInfFileNameComponent,
                        (DifferentOriginalName ? OriginalInfName
                                               : pSetupGetFileTitle(SourceInfFileName)),
                        (*SourceInfCatalogName ? SourceInfCatalogName : NULL),
                        NULL,    // no HWND for UI!
                        NULL,
                        CodeSigningPolicy,
                        SCOI_NO_ERRLOG_IF_INF_ALREADY_PRESENT |
                         (UseOriginalInfName ? SCOI_KEEP_INF_AND_CAT_ORIGINAL_NAMES : 0),
                        NULL,
                        ValidationPlatform,
                        NULL,
                        CatalogFilenameOnSystem,
                        LogContext, // either made-up or thread log context
                        NULL
                        )) {
        rc = NO_ERROR;
    } else {
        rc = GetLastError();
    }

final:

    if(ValidationPlatform) {
        MyFree(ValidationPlatform);
    }
    DeleteLogContext(LogContext);

    if(rc != NO_ERROR) {
        SetLastError(rc);
        return FALSE;
    } else {
        return TRUE;
    }
}


BOOL
_SetupCopyOEMInf(
    IN     PCTSTR                  SourceInfFileName,
    IN     PCTSTR                  OEMSourceMediaLocation,          OPTIONAL
    IN     DWORD                   OEMSourceMediaType,
    IN     DWORD                   CopyStyle,
    OUT    PTSTR                   DestinationInfFileName,          OPTIONAL
    IN     DWORD                   DestinationInfFileNameSize,
    OUT    PDWORD                  RequiredSize,                    OPTIONAL
    OUT    PTSTR                  *DestinationInfFileNameComponent, OPTIONAL
    IN     PCTSTR                  SourceInfOriginalName,
    IN     PCTSTR                  SourceInfCatalogName,            OPTIONAL
    IN     HWND                    Owner,
    IN     PCTSTR                  DeviceDesc,                      OPTIONAL
    IN     DWORD                   DriverSigningPolicy,
    IN     DWORD                   Flags,
    IN     PCTSTR                  AltCatalogFile,                  OPTIONAL
    IN     PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,                 OPTIONAL
    OUT    PDWORD                  DriverSigningError,              OPTIONAL
    OUT    PTSTR                   CatalogFilenameOnSystem,
    IN     PSETUP_LOG_CONTEXT      LogContext,
    IN OUT HCATADMIN              *hCatAdmin                        OPTIONAL
    )
/*++

Routine Description:

    (See SetupCopyOEMInf)

Arguments:

    (See SetupCopyOEMInf)

    SourceInfOriginalName - supplies the simple filename (no path) that this INF
        originally had.  This will typically be the same as its current name,
        except in cases where there's a valid PNF for that INF, and the PNF
        specifies a different original name.

    SourceInfCatalogName - Optionally, supplies the simple filename of the
        catalog file specified by the OEM INF via a CatalogFile= entry in its
        [Version] section.  If this parameter is not specified, then the INF
        doesn't specify an associated catalog.  (NOTE: One may still be used if
        the AltCatalogFile parameter is specified.

    Owner - supplies window handle to be used for any UI related to digital
        signature verification failures.

    DeviceDesc - Optionally, supplies the device description to be used in the
        digital signature verification error dialogs that may be popped up.

    DriverSigningPolicy - supplies the driver signing policy currently in
        effect.  Used when calling pSetupHandleFailedVerification, if necessary.

    Flags - supplies flags which alter the behavior of the routine.  May be a
        combination of the following values:

        SCOI_NO_UI_ON_SIGFAIL - indicates whether user should be prompted (per
                                DriverSigningPolicy) if a digital signature
                                failure is encountered.  Used when calling
                                pSetupHandleFailedVerification, if necessary.

        SCOI_NO_ERRLOG_ON_MISSING_CATALOG - if there's a signature verification
                                            failure due to the INF lacking a
                                            CatalogFile= entry, then that error
                                            will be ignored if this flag is set
                                            (no UI will be given, and no log
                                            entry will be generated).

        SCOI_NO_ERRLOG_IF_INF_ALREADY_PRESENT - If we discover that the INF
                                                already exists in %windir%\Inf,
                                                then don't popup any UI and
                                                don't even generate an error
                                                log entry.

        SCOI_KEEP_INF_AND_CAT_ORIGINAL_NAMES - Install the INF and CAT under
                                               their original (current) names
                                               (i.e., don't generate a unique
                                               oem<n>.inf/cat name).  Used only
                                               for exception INFs.

        SCOI_ABORT_IF_UNSIGNED - If the INF is unsigned (and user wants to copy
                                 it anyway, or policy is Ignore), then _don't_
                                 copy the INF and instead return the error
                                 ERROR_SET_SYSTEM_RESTORE_POINT.  This gives
                                 the caller a chance to set a system restore
                                 point prior to installing the unsigned package.

        SCOI_TRY_UPDATE_PNF    - If an existing PNF cannot be updated, don't
                                 consider it fatal.

    AltCatalogFile - Optionally, supplies the name of a catalog file to be
        installed and used for verification of the INF in cases where the INF
        doesn't specify a CatalogFile= entry (i.e., when the
        SourceInfCatalogName parameter is not specified.

    AltPlatformInfo - Optionally, supplies alternate platform information to be
        used in digital signature verification instead of the default (native)
        platform info.

    DriverSigningError - Optionally, supplies the address of a variable that
        receives the error encountered when attempting to verify the digital
        signature of either the INF or associated catalog.  If no digital
        signature problems were encountered, this is set to NO_ERROR.  (Note
        that this value can come back as NO_ERROR, yet _SetupCopyOEMInf still
        failed for some other reason).

    CatalogFilenameOnSystem - Receives the fully-qualified path of the catalog
        file within the catalog store where this INF's catalog file was
        installed to. This buffer should be at least MAX_PATH bytes (ANSI
        version) or chars (Unicode version).

    LogContext - supplies a LogContext to be passed to GetNewInfName.

    hCatAdmin - optionally, supplies the address of an HCATADMIN handle.  If
        the handle pointed to is NULL, a handle will be acquired (if possible)
        via CryptCATAdminAcquireContext and returned to the caller.  If the
        handle pointed to is non-NULL, then that handle will be used for any
        validation done via this routine.  If the pointer itself is NULL, then
        an hCatAdmin will be acquired for the duration of this call, and
        released before returning.

        NOTE: it is the caller's responsibility to free the crypto context
        handle returned by this routine by calling CryptCATAdminReleaseContext.
        This handle may be opened in either success or failure cases, so the
        caller must check for non-NULL returned handle in both cases.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    TCHAR NewName[MAX_PATH];
    DWORD TempRequiredSize, Err;
    NEWINF_COPYTYPE CopyNeeded;
    WIN32_FIND_DATA FindData;
    PLOADED_INF PrecompiledNewInf;
    UINT ErrorLineNumber;
    TCHAR TempOemSourceMediaLocation[MAX_PATH];
    PTSTR TempCharPtr;
    BOOL AlternateCatInstalled;
    DWORD TempDriverSigningError;
    DWORD DefaultSourceMediaType;
    HINF hInf;

    if (DriverSigningError) {
        *DriverSigningError = NO_ERROR;
    }
    //
    // If the DestinationInfFileName buffer is NULL, the size had better be
    // zero.  Also, make sure the caller passed us a valid OEMSourceMediaType.
    //
    if((!DestinationInfFileName && DestinationInfFileNameSize) ||
       (OEMSourceMediaType >= SPOST_MAX))
    {
        MYASSERT(!DriverSigningError);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // If we're installing an exception INF, it's illegal to request that we
    // not copy the INF.
    //
    if((Flags & SCOI_KEEP_INF_AND_CAT_ORIGINAL_NAMES) &&
       (CopyStyle & SP_COPY_OEMINF_CATALOG_ONLY))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    Err = NO_ERROR;
    CopyNeeded = NewInfCopyNo;
    AlternateCatInstalled = FALSE;
    TempCharPtr = NULL;
    hInf = INVALID_HANDLE_VALUE;

    try {
        //
        // Check to see if the INF is already in the %windir%\Inf directory, and
        // create a uniquely-named, zero-length placeholder file if it isn't.
        //
        Err = GetNewInfName(Owner,
                            SourceInfFileName,
                            SourceInfOriginalName,
                            SourceInfCatalogName,
                            NewName,
                            SIZECHARS(NewName),
                            &TempRequiredSize,
                            &CopyNeeded,
                            CopyStyle & SP_COPY_REPLACEONLY,
                            DeviceDesc,
                            DriverSigningPolicy,
                            Flags,
                            AltCatalogFile,
                            AltPlatformInfo,
                            &TempDriverSigningError,
                            CatalogFilenameOnSystem,
                            LogContext,
                            hCatAdmin
                           );

        if(DriverSigningError) {
            *DriverSigningError = TempDriverSigningError;
        }

        if(Err != NO_ERROR) {
            //
            // Value of CopyNeeded parameter is undefined upon error, but we do
            // know that no clean-up will be necessary if GetNewInfName fails.
            //
            CopyNeeded = NewInfCopyNo;

            //
            // If we were only trying to get the catalog installed, and the
            // failure was for some reason _other_ than a digital signature
            // verification failure (e.g., we couldn't create the placeholder
            // INF in %windir%\Inf), then we want to treat this as if it were
            // a signature verification failure.  Since we aren't trying to
            // install the full INF, this implies that we aren't doing a device
            // install, thus the policy is going to be non-driver-signing
            // policy.  This has the default of "Ignore", which is fortunate,
            // since the dialog complains about an unsigned driver package when
            // in fact we don't really know whether or not the package is
            // unsigned--all we know is that we couldn't install its catalog,
            // even if it had one.
            //
            // Note: if the user clicks the "More Info..." button, we will tell
            // them that the catalog installation failed, and what a possible
            // cause might be (e.g., no write access to Windows directory).
            //
            if((CopyStyle & SP_COPY_OEMINF_CATALOG_ONLY) &&
               (TempDriverSigningError == NO_ERROR)) {

                if(SourceInfCatalogName) {
                    //
                    // Typical case (INF specified a catalog), give the user
                    // some indication (via codesigning popup based on policy)
                    // about what went wrong...
                    //
                    if(pSetupHandleFailedVerification(
                           Owner,
                           SetupapiVerifyCatalogInstallProblem,
                           SourceInfCatalogName,
                           DeviceDesc,
                           DriverSigningPolicy,
                           (Flags & SCOI_NO_UI_ON_SIGFAIL),
                           Err,
                           LogContext,
                           NULL,
                           NULL))
                    {
                        TempDriverSigningError = Err;
                        if(DriverSigningError) {
                            *DriverSigningError = TempDriverSigningError;
                        }

                        //
                        // The user wants to proceed with the unsigned
                        // installation (or policy is Ignore, so they weren't
                        // even informed).  If the caller wants a chance to set
                        // a system restore point prior to doing any unsigned
                        // installations, then we abort now with a "special"
                        // error code that tells them what to do...
                        //
                        if(Flags & SCOI_ABORT_IF_UNSIGNED) {
                            Err = ERROR_SET_SYSTEM_RESTORE_POINT;
                        } else {
                            //
                            // We should consider the operation a success, even
                            // though we couldn't install the catalog.
                            //
                            Err = NO_ERROR;
                        }
                    }

                } else {
                    //
                    // Unlikely scenario (INF didn't specify a catalog, yet we
                    // were called with SP_COPY_OEMINF_CATALOG_ONLY???), just
                    // ignore the issue, generate a setupapi.log entry, and
                    // proceed...
                    //
                    WriteLogEntry(LogContext,
                                  SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                                  MSG_LOG_FAILED_INF_INSTALL,
                                  NULL,
                                  SourceInfFileName
                                 );

                    WriteLogError(LogContext,
                                  SETUP_LOG_ERROR,
                                  Err
                                 );

                    TempDriverSigningError = Err;
                    if(DriverSigningError) {
                        *DriverSigningError = TempDriverSigningError;
                    }

                    Err = NO_ERROR;
                }

                if(Err == NO_ERROR) {
                    //
                    // In this case, we don't have a filename to return to the
                    // caller.
                    //
                    if(RequiredSize) {
                        *RequiredSize = 0;
                    }
                    if(DestinationInfFileName && DestinationInfFileNameSize) {
                        *DestinationInfFileName = TEXT('\0');
                    }
                    if(DestinationInfFileNameComponent) {
                        *DestinationInfFileNameComponent = NULL;
                    }
                }
            }

            goto clean0;
        }

        //
        // OK, we have a filename to copy to, now copy the file (if necessary),
        // unless the caller doesn't want to overwrite the existing file.
        //
        if(CopyNeeded != NewInfCopyNo) {

            //
            // We either created a new zero-length placeholder file ourselves,
            // or we found an existing placeholder that we could use.
            //
            // Copy our INF over the top of this placeholder file, unless the
            // caller specified the SP_COPY_OEMINF_CATALOG_ONLY flag, in which
            // case we want to leave the zero-length file as-is (and mark it
            // hidden), so that no other OEM INFs can subsequently get this name
            // (hence causing namespace collisions for the catalog files).
            //
            if(!(CopyStyle & SP_COPY_OEMINF_CATALOG_ONLY)) {

                //
                // Reset the existing file's attributes prior to attempting the
                // copy.
                //
                SetFileAttributes(NewName, FILE_ATTRIBUTE_NORMAL);

                if(!CopyFile(SourceInfFileName, NewName, FALSE)) {
                    Err = GetLastError();
                    goto clean0;
                }
            } else {
                //
                // If we didn't encounter a driver signing error, or if the
                // zero-length file was already present, then just make sure
                // it's marked as hidden.
                //
                if((TempDriverSigningError == NO_ERROR) || (CopyNeeded == NewInfCopyZeroLength)) {
                    //
                    // Mark the zero-length file as hidden.
                    //
                    SetFileAttributes(NewName, FILE_ATTRIBUTE_HIDDEN);
                } else {
                    //
                    // Delete the newly-created zero-length placeholder INF,
                    // because it serves no purpose.
                    //
                    SetFileAttributes(NewName, FILE_ATTRIBUTE_NORMAL);
                    DeleteFile(NewName);
                }

                //
                // Since we only have a zero-length placeholder (or possibly, no
                // placeholder at all if catalog installation failed), we
                // shouldn't return a filename to the caller.
                //
                if(RequiredSize) {
                    *RequiredSize = 0;
                }
                if(DestinationInfFileName && DestinationInfFileNameSize) {
                    *DestinationInfFileName = TEXT('\0');
                }
                if(DestinationInfFileNameComponent) {
                    *DestinationInfFileNameComponent = NULL;
                }
                //
                // We're done!
                //
                goto clean0;
            }

        } else {
            //
            // If the original INF name and the new INF name are different, then
            // we know this wasn't an alternate catalog-only install.
            //
            AlternateCatInstalled = !lstrcmpi(SourceInfFileName, NewName);

            if((CopyStyle & SP_COPY_NOOVERWRITE) && !AlternateCatInstalled) {
                //
                // OK, the INF already exists in the INF directory, and the
                // caller has specified that they _do not_ want to wipe out the
                // existing PNF.  We may need to return back the name of the
                // existing INF if they requested it, however.
                //
                Err = ERROR_FILE_EXISTS;
            }
        }

        //
        // If we get to here, then the INF exists in %windir%\Inf, and we either
        // have no error, or ERROR_FILE_EXISTS.  Next, we need to store the name
        // of the INF in the caller's buffer (if supplied).
        //
        if(RequiredSize) {
            *RequiredSize = TempRequiredSize;
        }

        if(DestinationInfFileName) {
            if(DestinationInfFileNameSize >= TempRequiredSize) {
                CopyMemory(DestinationInfFileName, NewName, TempRequiredSize * sizeof(TCHAR));
                //
                // If requested by the caller, return a pointer to the filename
                // part of this path.
                //
                if(DestinationInfFileNameComponent) {
                    *DestinationInfFileNameComponent = (PTSTR)pSetupGetFileTitle(DestinationInfFileName);
                }
            } else {
                Err = ERROR_INSUFFICIENT_BUFFER;
            }
        } else {
            //
            // Nobody should be requesting a pointer to the filename component of
            // the path when they don't supply us a buffer to store the full path.
            // If anyone does do this, make sure we set the pointer to NULL.
            //
            if(DestinationInfFileNameComponent) {
                *DestinationInfFileNameComponent = NULL;
            }
        }

        if((Err != NO_ERROR) || AlternateCatInstalled) {
            goto clean0;
        }

        //
        // If the code calling this API claims that this INF is from the Internet we
        // first want to check if there is a PNF for this INF and that the PNF agrees
        // that this INF is from the Internet.  If the PNF says the INF is from a location
        // other than the Internet then we will change the OEMSourceMediaType to this
        // other media type.  We will also set teh OEMSourceMediaLocation to NULL.  This has
        // the desired affect of us falling through the next if statement which will read the
        // SourceMediaLocation from the PNF instead of the current INF location.
        // If their is no PNF for the given INF then we just leave OEMSourceMediaType alone.
        //
        if (OEMSourceMediaType == SPOST_URL) {

            if (pSetupGetSourceMediaTypeFromPnf(SourceInfFileName, &DefaultSourceMediaType) &&
                 (DefaultSourceMediaType != SPOST_URL)) {

                OEMSourceMediaType = DefaultSourceMediaType;
                OEMSourceMediaLocation = NULL;
            }
        }

        if(!OEMSourceMediaLocation && (OEMSourceMediaType == SPOST_PATH)) {
            //
            // The caller wants to store the OEM source path, but they didn't
            // provide us with one to use.  Thus, we'll use the path where the
            // INF existed (unless there's a valid PNF there, in which case
            // we'll use its SPOST_PATH information, if it has any).
            // pSetupGetDefaultSourcePath() does just what we want.
            //
            hInf = SetupOpenInfFile(SourceInfFileName,
                                    NULL,
                                    INF_STYLE_WIN4 | INF_STYLE_OLDNT,
                                    NULL
                                   );

            if(hInf == INVALID_HANDLE_VALUE) {
                Err = GetLastError();
                MYASSERT(Err != NO_ERROR);
                goto clean0;
            }

            TempCharPtr = pSetupGetDefaultSourcePath(hInf, SRCPATH_USEINFLOCATION, &DefaultSourceMediaType);

            //
            // We don't need the INF handle anymore.
            //
            SetupCloseInfFile(hInf);
            hInf = INVALID_HANDLE_VALUE;

            MYASSERT(DefaultSourceMediaType == SPOST_PATH);

            if(TempCharPtr) {
                lstrcpy(TempOemSourceMediaLocation, TempCharPtr);
                OEMSourceMediaLocation = TempOemSourceMediaLocation;
                //
                // We no longer need the buffer allocated for us by
                // pSetupGetDefaultSourcePath.
                //
                MyFree(TempCharPtr);
                //
                // Reset this pointer so we won't try to free it should we
                // subsequently encounter an exception.
                //
                TempCharPtr = NULL;
            } else {
                Err = GetLastError();
                MYASSERT(Err != NO_ERROR);
                goto clean0;
            }
        }

        if(!FileExists(NewName, &FindData)) {
            Err = GetLastError();
            goto clean0;
        }

        Err = LoadInfFile(NewName,
                          &FindData,
                          INF_STYLE_WIN4 | INF_STYLE_OLDNT,
                          LDINF_FLAG_ALWAYS_TRY_PNF
                          | LDINF_FLAG_REGENERATE_PNF
                          | ((Flags & SCOI_TRY_UPDATE_PNF) ? LDINF_FLAG_ALLOW_PNF_SHARING_LOCK : 0)
                          | ((OEMSourceMediaType == SPOST_URL) ? LDINF_FLAG_SRCPATH_IS_URL : 0)
                          | ((CopyStyle & SP_COPY_OEM_F6_INF) ? LDINF_FLAG_OEM_F6_INF : 0),
                          NULL,
                          (OEMSourceMediaType == SPOST_NONE) ? NULL : OEMSourceMediaLocation,
                          (lstrcmpi(SourceInfOriginalName, pSetupGetFileTitle(NewName))
                              ? SourceInfOriginalName
                              : NULL),
                          NULL,
                          LogContext,
                          &PrecompiledNewInf,
                          &ErrorLineNumber,
                          NULL
                         );

        if(Err != NO_ERROR) {
            goto clean0;
        }

        //
        // The INF was successfully precompiled.
        //
        FreeInfFile(PrecompiledNewInf);

        //
        // Finally, delete the source INF file if the caller requested it.
        //
        if(CopyStyle & SP_COPY_DELETESOURCE) {
            DeleteFile(SourceInfFileName);
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        if(TempCharPtr) {
            MyFree(TempCharPtr);
        }
        if(hInf != INVALID_HANDLE_VALUE) {
            SetupCloseInfFile(hInf);
        }
        //
        // Reference the following variable so the compiler will respect statement
        // ordering w.r.t. assignment.
        //
        CopyNeeded = CopyNeeded;
    }

    if((Err != NO_ERROR) && (CopyNeeded == NewInfCopyYes)) {
        //
        // We encountered an error, after GetNewInfName created a new, unique
        // INF for us.  Delete it now.
        //
        // (Note: we don't do clean-up when GetNewInfName found an existing,
        // zero-length file for us to use, even if we may have subsequently
        // copied the 'real' INF over the top of it.  Since we believed the
        // existing file to be a duplicate of our OEM INF, this should be OK--
        // the worst that's going to happen is that an INF that was once zero-
        // length is now a full-blown INF after SetupCopyOEMInf encountered an
        // error.)
        //
        pSetupUninstallOEMInf(NewName, LogContext, SUOI_FORCEDELETE, NULL);

        //
        // NTRAID#256075-2000/08/18-JamieHun Handle Rollback of INF/PNF/CAT files
        //
        // If we were installing an exception INF and encountered an
        // error, we may have already blown away a previous INF/CAT.  In the
        // future, we might want to look into doing a backup on the old INF/CAT
        // before installing the new INF/CAT over the top of them.
        //
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupUninstallOEMInfA(
    IN PCSTR InfFileName,
    IN DWORD Flags,
    IN PVOID Reserved
    )
{
    DWORD Err;
    PCWSTR UnicodeInfFileName;
    BOOL b;

    Err = pSetupCaptureAndConvertAnsiArg(InfFileName, &UnicodeInfFileName);

    if(Err != NO_ERROR) {
        SetLastError(Err);
        return FALSE;
    }

    b = SetupUninstallOEMInfW(UnicodeInfFileName, Flags, Reserved);
    Err = GetLastError();

    MyFree(UnicodeInfFileName);

    SetLastError(Err);
    return b;
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupUninstallOEMInfW(
    IN PCWSTR InfFileName,
    IN DWORD  Flags,
    IN PVOID  Reserved
    )
{
    UNREFERENCED_PARAMETER(InfFileName);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(Reserved);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}
#endif


BOOL
WINAPI
SetupUninstallOEMInf(
    IN PCTSTR InfFileName,
    IN DWORD  Flags,
    IN PVOID  Reserved
    )

/*++

Routine Description:

    This API uninstalls the specified INF file, and deletes the associated
    .PNF and .CAT files, if they exist.

    The default behavior of this API is to first verify that there are no
    other devices, live or phantom, that are using this INF.  If another
    device is using this INF then it will not be uninstalled. This behavior
    can be overwritten by the SUOI_FORCEDELETE flag.

Arguments:

    InfFileName - Supplies the simple filename (no path) of the INF to be
        uninstalled.

    Flags - Supplies flags that alter the behavior of this API.
        SUOI_FORCEDELETE - forces the INF, PNF, and CAT to be uninstalled, even
        if another device is using this INF.

    Reserved - Reserved for future use.  Must be NULL.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    DWORD Err;
    TCHAR InfFullPath[MAX_PATH];

    if(Flags & ~(SUOI_FORCEDELETE)) {
        SetLastError(ERROR_INVALID_FLAGS);
        return FALSE;
    }

    if(Reserved) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    try {
        //
        // INF filename must not contain path
        //
        if(InfFileName != pSetupGetFileTitle(InfFileName)) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // Look for specified INF in %windir%\Inf...
        //
        lstrcpyn(InfFullPath, InfDirectory,SIZECHARS(InfFullPath));
        pSetupConcatenatePaths(InfFullPath,
                               InfFileName,
                               SIZECHARS(InfFullPath),
                               NULL
                              );

        if(!pSetupFileExists(InfFullPath, NULL)) {
            Err = GetLastError();
            goto clean0;
        }

        pSetupUninstallOEMInf(InfFullPath, NULL, Flags, &Err);

clean0:
        ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiRegisterCoDeviceInstallers(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )

/*++

Routine Description:

    Default handler for DIF_REGISTER_COINSTALLERS

    This routine will install any (device-specific) co-installers specified
    in an [<InstallSec>.CoInstallers] section, where <InstallSec> is the install
    section name for the selected driver node, potentially decorated with
    an OS/architecture-specific extension (e.g., "InstallSec.NTAlpha.CoInstallers").

    AddReg entries listed in a CoInstallers section use the device's driver key
    for their HKR.  To register a device-specific co-installer, a REG_MULTI_SZ entry
    titled "CoInstallers32" must be written to the driver key.  Each entry in this list
    has the following format:

        dll[,procname]

    where dll is the name of the module to load and procname is an optional entry
    point name.  If procname is not specified, then the entry point name
    "CoDeviceInstall" will be used.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        a device information element for whom co-installers are to be registered.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure for whom
        co-installers are to be registered.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    If no driver is selected (i.e., this is a null-driver installation), then
    this routine does nothing.

--*/

{
    return _SetupDiRegisterCoDeviceInstallers(DeviceInfoSet,
                                              DeviceInfoData,
                                              TRUE,
                                              INVALID_HANDLE_VALUE,
                                              INVALID_HANDLE_VALUE
                                             );
}


BOOL
_SetupDiRegisterCoDeviceInstallers(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN BOOL             DoFullInstall,
    IN HINF             hDeviceInf,     OPTIONAL
    IN HSPFILEQ         UserFileQ       OPTIONAL
    )
/*++

Routine Description:

    Worker routine for both SetupDiRegisterCoDeviceInstallers and SetupDiInstallDriverFiles.

    See the description of SetupDiRegisterCoDeviceInstallers for more information.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        a device information element for whom co-installers are to be registered.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure for whom
        co-installers are to be registered.

    DoFullInstall - If TRUE (non-zero), then the co-installers are completely registered,
        otherwise, only files are copied.

    hDeviceInf - Optionally, supplies a handle to the INF for which installation
        is being performed.  If this handle is not supplied, the INF specified in
        the selected driver node will be opened.  If this handle is not supplied,
        this parameter must be set to INVALID_HANDLE_VALUE.

    UserFileQ - Optionally, supplies a file queue where file operations should be added.
        If this handle is not supplied, then the queue associated with this devinfo
        element will be used (if the DI_NOVCP flag is set), or one will be automatically
        generated and committed.  If this handle is not supplied, this parameter must
        be set to INVALID_HANDLE_VALUE.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    During GUI-mode setup on Windows NT, quiet-install behavior is always
    employed in the absence of a user-supplied file queue, regardless of
    whether the device information element has the DI_QUIETINSTALL flag set.

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    DWORD Err, ScanQueueResult;
    PDEVINFO_ELEM DevInfoElem;
    HWND hwndParent;
    BOOL CloseUserFileQ;
    PTSTR szInfFileName, szInfSectionName;
    TCHAR InfSectionWithExt[MAX_SECT_NAME_LEN];
    DWORD InfSectionWithExtLength;
    BOOL FreeMsgHandlerContext;
    PSP_FILE_CALLBACK MsgHandler;
    PVOID MsgHandlerContext;
    BOOL MsgHandlerIsNativeCharWidth, DeleteDrvRegKey;
    HKEY hkDrv;
    BOOL CloseInfHandle;
    BOOL DoFileCopying;
    INT FileQueueNeedsReboot;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    DWORD slot_section = 0;
    BOOL NoProgressUI;
    TCHAR szNewName[MAX_PATH];
    BOOL OemInfFileToCopy = FALSE;

    //
    // A device information element must be specified.
    //
    if(!DeviceInfoData) {
        Err = ERROR_INVALID_PARAMETER;
        goto clean1;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        Err = ERROR_INVALID_HANDLE;
        goto clean1;
    }

    LogContext = pDeviceInfoSet->InstallParamBlock.LogContext;

    Err = NO_ERROR;
    hDeviceInf = INVALID_HANDLE_VALUE;
    CloseUserFileQ = FALSE;
    FreeMsgHandlerContext = FALSE;
    hkDrv = INVALID_HANDLE_VALUE;
    DeleteDrvRegKey = FALSE;
    CloseInfHandle = FALSE;

    try {

        if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                     DeviceInfoData,
                                                     NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // This routine can't install a non-native driver
        //
        if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_ALTPLATFORM_DRVSEARCH) {

            Err = ERROR_INVALID_FLAGS;
            goto clean0;
        }

        //
        // set the LogContext for this function
        //
        LogContext = DevInfoElem->InstallParamBlock.LogContext;

        //
        // If there's no driver selected (i.e., this is a null driver install), or we're
        // using a legacy INF, then there's nothing for us to do.
        //
        if(!(DevInfoElem->SelectedDriver) ||
            (DevInfoElem->SelectedDriver->Flags & DNF_LEGACYINF)) {

            goto clean0;
        }

        //
        // Make sure we only use the devinfo element's window if it's valid.
        //
        if(hwndParent = DevInfoElem->InstallParamBlock.hwndParent) {
           if(!IsWindow(hwndParent)) {
                hwndParent = NULL;
           }
        }

        szInfFileName = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                 DevInfoElem->SelectedDriver->InfFileName
                                                );

        szInfSectionName = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                    DevInfoElem->SelectedDriver->InfSectionName
                                                   );

        if(hDeviceInf == INVALID_HANDLE_VALUE) {

            if((hDeviceInf = SetupOpenInfFile(szInfFileName,
                                              NULL,
                                              INF_STYLE_WIN4,
                                              NULL)) == INVALID_HANDLE_VALUE) {
                Err = GetLastError();
                goto clean0;
            }

            CloseInfHandle = TRUE;
        }
        //
        // see if we should give the INF the same LogContext as the DevInfoElem
        //
        InheritLogContext(LogContext,
            &((PLOADED_INF) hDeviceInf)->LogContext);

        slot_section = AllocLogInfoSlot(LogContext,FALSE);

        //
        // Find out the 'real' install section we should be using (i.e., the potentially
        // OS/architecture-specific one.
        //
        if(!SetupDiGetActualSectionToInstall(hDeviceInf,
                                             szInfSectionName,
                                             InfSectionWithExt,
                                             SIZECHARS(InfSectionWithExt),
                                             &InfSectionWithExtLength,
                                             NULL
                                             )) {
            Err = GetLastError();
            goto clean0;
        }

        //
        // Now append the ".CoInstallers" extension to the install section name to find
        // the co-installer INF section to run.
        //
        CopyMemory(&(InfSectionWithExt[InfSectionWithExtLength - 1]),
                   pszCoInstallersSectionSuffix,
                   sizeof(pszCoInstallersSectionSuffix)
                  );

        //
        // Figure out whether we need to do file copying.  (Ignore the DI_NOFILECOPY
        // flag if we're doing a copy-only installation--that's what setupx does.)
        //
        DoFileCopying = (!(DevInfoElem->InstallParamBlock.Flags & DI_NOFILECOPY) || !DoFullInstall);

        //
        // Append the layout INF, if necessary.
        //
        if(DoFileCopying) {
            SetupOpenAppendInfFile(NULL, hDeviceInf, NULL);
        }

        //
        // Append-load any included INFs specified in an "include=" line in our
        // install section.
        //
        AppendLoadIncludedInfs(hDeviceInf, szInfFileName, InfSectionWithExt, DoFileCopying);

        //
        // Now copy the files, if necessary.
        //
        if(DoFileCopying) {

            if(UserFileQ == INVALID_HANDLE_VALUE) {
                //
                // If the DI_NOVCP flag is set, then just queue up the file
                // copy/rename/delete operations.  Otherwise, perform the
                // actions.
                //
                if(DevInfoElem->InstallParamBlock.Flags & DI_NOVCP) {
                    //
                    // We must have a user-supplied file queue.
                    //
                    MYASSERT(DevInfoElem->InstallParamBlock.UserFileQ);
                    UserFileQ = DevInfoElem->InstallParamBlock.UserFileQ;
                } else {
                    //
                    // Since we may need to check the queued files to determine whether file copy
                    // is necessary, we have to open our own queue, and commit it ourselves.
                    //
                    if((UserFileQ = SetupOpenFileQueue()) != INVALID_HANDLE_VALUE) {
                        CloseUserFileQ = TRUE;

                    } else {
                        //
                        // SetupOpenFileQueue sets actual error
                        //
                        Err = GetLastError();
                        goto clean0;
                    }
                }
            }
            //
            // See if we should replace the file queue's log context with the
            // DevInfoElem's
            //
            InheritLogContext(LogContext,
                &((PSP_FILE_QUEUE) UserFileQ)->LogContext);

            WriteLogEntry(LogContext,
                slot_section,
                MSG_LOG_COINSTALLER_REGISTRATION,
                NULL,
                InfSectionWithExt);

            Err = InstallFromInfSectionAndNeededSections(NULL,
                                                         hDeviceInf,
                                                         InfSectionWithExt,
                                                         SPINST_FILES,
                                                         NULL,
                                                         NULL,
                                                         SP_COPY_NEWER_OR_SAME | SP_COPY_LANGUAGEAWARE |
                                                             ((DevInfoElem->InstallParamBlock.Flags & DI_NOBROWSE) ? SP_COPY_NOBROWSE : 0),
                                                         NULL,
                                                         NULL,
                                                         INVALID_HANDLE_VALUE,
                                                         NULL,
                                                         UserFileQ
                                                        );

            //
            // Mark the queue as a device install queue (and make sure there's a
            // catalog node representing our device INF in the queue).
            //
            Err = MarkQueueForDeviceInstall(UserFileQ,
                                            hDeviceInf,
                                            pStringTableStringFromId(
                                                pDeviceInfoSet->StringTable,
                                                DevInfoElem->SelectedDriver->DrvDescription)
                                           );

            //
            // At this point, we have queued up all the files that need to be copied.  If
            // we weren't given a user-supplied queue, then commit our queue now.
            //
            if(CloseUserFileQ) {

                if(Err == NO_ERROR) {
                    //
                    // Determine whether the queue actually needs to be
                    // committed.
                    //
                    // ScanQueueResult can have 1 of 3 values:
                    //
                    // 0: Some files were missing--must commit queue.
                    //
                    // 1: All files to be copied are already present and
                    //    queue is empty--skip committing queue.
                    //
                    // 2: All files to be copied are present, but
                    //    del/ren/backup queues not empty--must commit
                    //    queue. The copy queue will have been emptied, so
                    //    only del/ren/backup functions will be performed.
                    //
                    // (jamiehun) see previous case of SetupScanFileQueue
                    // for a discussion of DI_FLAGSEX_PREINSTALLBACKUP
                    // handling.
                    //
                    if(!SetupScanFileQueue(UserFileQ,
                                           SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_PRUNE_COPY_QUEUE,
                                           hwndParent,
                                           NULL,
                                           NULL,
                                           &ScanQueueResult)) {
                        //
                        // SetupScanFileQueue should really never fail when
                        // you don't ask it to call a callback routine, but
                        // if it  does, just go ahead and commit the queue.
                        //
                        ScanQueueResult = 0;
                    }
                }

                if((Err == NO_ERROR) && (ScanQueueResult != 1)) {
                    //
                    // We need to commit this file queue.  Figure out what
                    // message handler to use.
                    //
                    if(DevInfoElem->InstallParamBlock.InstallMsgHandler) {
                        MsgHandler = DevInfoElem->InstallParamBlock.InstallMsgHandler;
                        MsgHandlerContext = DevInfoElem->InstallParamBlock.InstallMsgHandlerContext;
                        MsgHandlerIsNativeCharWidth = DevInfoElem->InstallParamBlock.InstallMsgHandlerIsNativeCharWidth;
                    } else {

                        NoProgressUI = (GuiSetupInProgress || (DevInfoElem->InstallParamBlock.Flags & DI_QUIETINSTALL));

                        if(MsgHandlerContext = SetupInitDefaultQueueCallbackEx(
                                                  hwndParent,
                                                  (NoProgressUI ? INVALID_HANDLE_VALUE : NULL),
                                                  0,
                                                  0,
                                                  NULL))
                        {
                            FreeMsgHandlerContext = TRUE;
                            MsgHandler = SetupDefaultQueueCallback;
                            MsgHandlerIsNativeCharWidth = TRUE;
                        } else {
                            Err = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }

                    //
                    // Copy enqueued files.
                    //
                    if(Err == NO_ERROR) {
                        //
                        // Call _SetupVerifyQueuedCatalogs separately (i.e.,
                        // don't let it happen automatically as a result of
                        // committing the queue that happens below).  We do
                        // this beforehand so that we know what unique name was
                        // generated when an OEM INF was installed into
                        // %windir%\Inf (in case we need to delete the
                        // INF/PNF/CAT files later if we encounter an error).
                        //
                        WriteLogEntry(
                            LogContext,
                            DRIVER_LOG_TIME,
                            MSG_LOG_BEGIN_COINST_VERIFY_CAT_TIME,
                            NULL);       // text message

                        Err = _SetupVerifyQueuedCatalogs(
                                  hwndParent,
                                  UserFileQ,
                                  (VERCAT_INSTALL_INF_AND_CAT |
                                   ((DevInfoElem->SelectedDriver->Flags & DNF_INET_DRIVER)
                                        ? VERCAT_PRIMARY_DEVICE_INF_FROM_INET : 0)),
                                  szNewName,
                                  &OemInfFileToCopy
                                 );

                        WriteLogEntry(
                            LogContext,
                            DRIVER_LOG_TIME,
                            MSG_LOG_END_COINST_VERIFY_CAT_TIME,
                            NULL);       // text message

                        if(Err == NO_ERROR) {

                            if(_SetupCommitFileQueue(hwndParent,
                                                     UserFileQ,
                                                     MsgHandler,
                                                     MsgHandlerContext,
                                                     MsgHandlerIsNativeCharWidth
                                                     )) {
                                //
                                // Check to see whether a reboot is required as a
                                // result of committing the queue (i.e., because
                                // files were in use, or the INF requested a reboot).
                                //
                                FileQueueNeedsReboot = SetupPromptReboot(UserFileQ, NULL, TRUE);
                                //
                                // This should never fail...
                                //
                                MYASSERT(FileQueueNeedsReboot != -1);

                                if(FileQueueNeedsReboot) {
                                    SetDevnodeNeedsRebootProblem(DevInfoElem, pDeviceInfoSet,
                                                                 MSG_LOG_REBOOT_REASON_INUSE);
                                }

                            } else {
                                Err = GetLastError();
                            }
                        }
                    }
                }

                //
                // Close our file queue handle.
                //
                SetupCloseFileQueue(UserFileQ);
                CloseUserFileQ = FALSE;

                //
                // Terminate the default queue callback, if it was created.
                //
                if(FreeMsgHandlerContext) {
                    SetupTermDefaultQueueCallback(MsgHandlerContext);
                    FreeMsgHandlerContext = FALSE;
                }

                if(Err != NO_ERROR) {
                    goto clean0;
                }
            }
        }

        //
        // If all we were asked to do was copy files, then we're done.
        //
        if(!DoFullInstall ||
           (DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_NO_DRVREG_MODIFY)) {

            goto clean0;
        }

        //
        // Open/create the Driver Reg Key.
        //
        if((hkDrv = SetupDiOpenDevRegKey(DeviceInfoSet,
                                         DeviceInfoData,
                                         DICS_FLAG_GLOBAL,
                                         0,
                                         DIREG_DRV,
                                         KEY_READ | KEY_WRITE)) == INVALID_HANDLE_VALUE) {
            //
            // Assume the driver key doesn't already exist--try to create it.
            //
            if((hkDrv = SetupDiCreateDevRegKey(DeviceInfoSet,
                                               DeviceInfoData,
                                               DICS_FLAG_GLOBAL,
                                               0,
                                               DIREG_DRV,
                                               NULL,
                                               NULL)) != INVALID_HANDLE_VALUE) {
                //
                // We successfully created the driver key.  Set a flag so we'll know
                // to delete it in case we hit an error and need to clean up.
                //
                DeleteDrvRegKey = TRUE;
            } else {
                Err = GetLastError();
                goto clean0;
            }
        }

        //
        // We don't pass a msg handler so no need to worry about ansi
        // vs. unicode issues here.
        //
        Err = InstallFromInfSectionAndNeededSections(NULL,
                                                     hDeviceInf,
                                                     InfSectionWithExt,
                                                     SPINST_INIFILES
                                                     | SPINST_REGISTRY
                                                     | SPINST_INI2REG
                                                     | SPINST_BITREG
                                                     | SPINST_REGSVR
                                                     | SPINST_UNREGSVR
                                                     | SPINST_PROFILEITEMS,
                                                     hkDrv,
                                                     NULL,
                                                     0,
                                                     NULL,
                                                     NULL,
                                                     INVALID_HANDLE_VALUE,
                                                     NULL,
                                                     NULL
                                                    );
        if(Err == NO_ERROR) {
            //
            // Registering co-installers invalidates our existing co-installer
            // list.  Reset this list (migrating the module handles to the devinfo
            // set's list of "things to clean up later".
            // (NOTE: SetupDiCallClassInstaller also does this when its handling
            // DIF_REGISTER_COINSTALLERS, but since we can't be guaranteed we're
            // being called in the context of SetupDiCallClassInstaller, we have
            // to do this ourselves as well.)
            //
            Err = InvalidateHelperModules(DeviceInfoSet,
                                          DeviceInfoData,
                                          IHM_COINSTALLERS_ONLY
                                         );
        }

clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;

        if(FreeMsgHandlerContext) {
            SetupTermDefaultQueueCallback(MsgHandlerContext);
        }
        if(CloseUserFileQ) {
            SetupCloseFileQueue(UserFileQ);
        }
        //
        // Reference the following variables so the compiler will respect our statement
        // ordering w.r.t. assignment.
        //
        DeleteDrvRegKey = DeleteDrvRegKey;
        CloseInfHandle = CloseInfHandle;
        OemInfFileToCopy = OemInfFileToCopy;
    }


    if(hkDrv != INVALID_HANDLE_VALUE) {
        RegCloseKey(hkDrv);
        if((Err != NO_ERROR) && DeleteDrvRegKey) {
            SetupDiDeleteDevRegKey(DeviceInfoSet,
                                   DeviceInfoData,
                                   DICS_FLAG_GLOBAL | DICS_FLAG_CONFIGGENERAL,
                                   0,
                                   DIREG_DRV
                                  );

            CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst, CM_DRP_DRIVER, NULL, 0, 0,pDeviceInfoSet->hMachine);
        }
    }

    if(CloseInfHandle) {
        MYASSERT(hDeviceInf != INVALID_HANDLE_VALUE);
        SetupCloseInfFile(hDeviceInf);
    }

clean1:
    if (Err == NO_ERROR) {
        //
        // give a +ve affirmation of Success
        //
        WriteLogEntry(
            LogContext,
            DoFullInstall ? DRIVER_LOG_INFO : DRIVER_LOG_VERBOSE,
            MSG_LOG_REGISTEREDCOINSTALLERS,
            NULL);
    } else {
        //
        // indicate failed, display error
        //
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
            MSG_LOG_REGISTERCOINSTALLERS_ERROR,
            NULL);
        WriteLogError(
            LogContext,
            DRIVER_LOG_ERROR,
            Err);

        //
        // If we copied the OEM INF into the INF directory under a newly-
        // generated name, delete it now.
        //
        if(OemInfFileToCopy) {
            pSetupUninstallOEMInf(szNewName, LogContext, SUOI_FORCEDELETE, NULL);
        }
    }

    if (slot_section) {
        ReleaseLogInfoSlot(LogContext,slot_section);
    }

    if (pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiSelectBestCompatDrv(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    Default handler for DIF_SELECTBESTCOMPATDRV

    This routine will select the best driver from the device information element's
    compatible driver list.

    This function will enumerate through all of the drivers and find the one with
    the Best Rank (this is the lowest Rank number).  If there are multiple drivers
    with the same Best Rank then we will take the driver with the newest DriverDate.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the element for which the best compatible driver is to be selected.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure for
        which the best compatible driver is to be selected.  This element must
        already have a (non-empty) compatible driver list built for it, or this
        API will fail and GetLastError will return ERROR_NO_COMPAT_DRIVERS.

        This is an IN OUT parameter because the class GUID for the device will be
        updated to reflect the class of the selected driver.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINSTALL_PARAMS DriverInstallParams;
    DWORD BestRank, BasicBestRank;
    DWORDLONG BestDriverVersion, BasicBestDriverVersion;
    DWORD MemberIndex;
    INT BestMemberIndex, BasicBestMemberIndex;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    DWORD Err = NO_ERROR;
    PDEVINFO_ELEM DevInfoElem = NULL;
    FILETIME BestDriverDate, BasicBestDriverDate;

    BestRank = BasicBestRank = RANK_NO_MATCH;
    BestMemberIndex = BasicBestMemberIndex = -1;
    BestDriverVersion = BasicBestDriverVersion = 0;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        Err = ERROR_INVALID_HANDLE;
        goto clean1;
    }

    LogContext = pDeviceInfoSet->InstallParamBlock.LogContext;

    if(DeviceInfoData
       && (DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                     DeviceInfoData,
                                                     NULL))!=NULL) {
        LogContext = DevInfoElem->InstallParamBlock.LogContext;
    }

    //
    //Enumerate through all of the drivers and find the Best Rank
    //
    MemberIndex = 0;

    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

    while (SetupDiEnumDriverInfo(DeviceInfoSet,
                                 DeviceInfoData,
                                 SPDIT_COMPATDRIVER,
                                 MemberIndex,
                                 &DriverInfoData)) {

        DriverInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);

        if ((SetupDiGetDriverInstallParams(DeviceInfoSet,
                                           DeviceInfoData,
                                           &DriverInfoData,
                                           &DriverInstallParams))) {

            if(DriverInstallParams.Flags & DNF_BAD_DRIVER) {
                //
                // This driver was marked as bad--we don't want to use it, but
                // we should log an informational message as to why it wasn't
                // considered.
                //
                SP_DRVINFO_DETAIL_DATA Data;
                Data.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

                if(SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                              DeviceInfoData,
                                              &DriverInfoData,
                                              &Data,
                                              Data.cbSize,
                                              NULL) ||
                        (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_INFO,
                        MSG_LOG_SELECTBEST_BAD_DRIVER,
                        NULL,
                        Data.DrvDescription,
                        Data.InfFileName,
                        Data.SectionName
                        );
                }

            } else if(DriverInstallParams.Flags & DNF_BASIC_DRIVER) {
                //
                // This driver is flagged as a "basic functionality" driver.
                // We'll keep track of the best such driver we encounter, but
                // we'll only use a basic driver if there exists no non-basic
                // signed drivers.
                //
                if(DriverInstallParams.Rank <= BasicBestRank) {

                    if(BasicBestMemberIndex == -1) {
                        //
                        // This is the first acceptable basic driver we've
                        // encountered...
                        //
                        BasicBestDriverDate = DriverInfoData.DriverDate;
                        BasicBestMemberIndex = (INT)MemberIndex;
                        BasicBestDriverVersion = DriverInfoData.DriverVersion;

                    } else {
                        
                        if((DriverInstallParams.Rank < BasicBestRank) ||
                           (CompareFileTime(&BasicBestDriverDate, &(DriverInfoData.DriverDate)) == -1)) {
                            //
                            // If this new driver has a better (smaller) Rank than
                            // the current Best Driver or it has a newer date then
                            // make it the Best Driver.
                            //
                            BasicBestDriverDate = DriverInfoData.DriverDate;
                            BasicBestMemberIndex = (INT)MemberIndex;
                            BasicBestDriverVersion = DriverInfoData.DriverVersion;
                        } else if ((DriverInstallParams.Rank == BasicBestRank) &&
                                   (CompareFileTime(&BasicBestDriverDate, &(DriverInfoData.DriverDate)) == 0) &&
                                   (DriverInfoData.DriverVersion > BasicBestDriverVersion)) {
                            //
                            // If the Rank and DriverDate of the new driver
                            // are identical to the current Best driver,
                            // then check if the new driver has a newer 
                            // DriverVersion and if so make it the Best Driver.
                            //
                            BasicBestDriverDate = DriverInfoData.DriverDate;
                            BasicBestMemberIndex = (INT)MemberIndex;
                            BasicBestDriverVersion = DriverInfoData.DriverVersion;
                        }
                    }

                    BasicBestRank = DriverInstallParams.Rank;
                }

            } else {
                //
                // This isn't a basic driver.  If it's the best one we've seen,
                // remember it.
                //
                if(DriverInstallParams.Rank <= BestRank) {

                    if(BestMemberIndex == -1) {
                        //
                        // This is the first acceptable non-basic driver we've
                        // encountered...
                        //
                        BestDriverDate = DriverInfoData.DriverDate;
                        BestMemberIndex = (INT)MemberIndex;
                        BestDriverVersion = DriverInfoData.DriverVersion;

                    } else {
                        //
                        // If this new driver has a better (smaller) Rank than
                        // the current Best Driver or it has a newer date then
                        // make it the Best Driver.
                        //
                        if((DriverInstallParams.Rank < BestRank) ||
                           (CompareFileTime(&BestDriverDate, &(DriverInfoData.DriverDate)) == -1)) {

                            BestDriverDate = DriverInfoData.DriverDate;
                            BestMemberIndex = (INT)MemberIndex;
                            BestDriverVersion = DriverInfoData.DriverVersion;
                        } else if ((DriverInstallParams.Rank == BestRank) &&
                                   (CompareFileTime(&BestDriverDate, &(DriverInfoData.DriverDate)) == 0) &&
                                   (DriverInfoData.DriverVersion > BestDriverVersion)) {
                            //
                            // If the Rank and DriverDate of the new driver
                            // are identical to the current Best driver,
                            // then check if the new driver has a newer 
                            // DriverVersion and if so make it the Best Driver.
                            //
                            BestDriverDate = DriverInfoData.DriverDate;
                            BestMemberIndex = (INT)MemberIndex;
                            BestDriverVersion = DriverInfoData.DriverVersion;
                        }
                    }

                    BestRank = DriverInstallParams.Rank;
                }
            }
        }

        MemberIndex++;
    }

    //
    // If BestRank and BasicBestRank still equal RANK_NO_MATCH then we don't
    // have any compatible drivers
    //
    if((BestRank == RANK_NO_MATCH) && (BasicBestRank == RANK_NO_MATCH)) {
        Err = ERROR_NO_COMPAT_DRIVERS;
        goto clean1;
    }

    //
    // Select best driver from among basic and full-featured offerings as
    // follows:
    //
    // 1.  Full-featured, signed driver
    // 2.  Basic signed driver
    // 3.  Best rank/newest date between full-featured and basic unsigned
    //     driver (note: it will be rare that we encounter a basic unsigned
    //     driver since this will typically be used only for our in-box
    //     offerings, which are always signed)
    //
    if(BestRank < DRIVER_UNTRUSTED_RANK) {
        MemberIndex = (DWORD)BestMemberIndex;
    } else if(BasicBestRank < DRIVER_UNTRUSTED_RANK) {
        MemberIndex = (DWORD)BasicBestMemberIndex;
    } else {

        if(BestRank < BasicBestRank) {
            MemberIndex = (DWORD)BestMemberIndex;
        } else if(BasicBestRank < BestRank) {
            MemberIndex = (DWORD)BasicBestMemberIndex;
        } else {
            //
            // We have both a basic driver and full-featured one, both of which
            // are unsigned, and both of which are equivalently ranked.  Pick
            // the newer one.  In the unlikely event that they're the same
            // date, pick the full-featured one.
            //
            // We have both a basic driver and full-featured one, both of which
            // are unsigned, and both of which are equivalently ranked. If the 
            // driver dates are the same,  then pick the one with the newer 
            // driver version, otherwise pick the one with the newest date.  
            // In the unlikely event that the DriverDate and DriverVersion are 
            // the same, pick the full-featured one.
            //
            if (CompareFileTime(&BestDriverDate, &BasicBestDriverDate) == 0) {
                //
                // Driver dates are the same, so take the one with the newest
                // driver version.
                //
                if (BasicBestDriverVersion > BestDriverVersion) {
                    MemberIndex = (DWORD)BasicBestMemberIndex;
                } else {
                    MemberIndex = (DWORD)BestMemberIndex;
                }
            } else if(CompareFileTime(&BestDriverDate, &BasicBestDriverDate) == -1) {
                MemberIndex = (DWORD)BasicBestMemberIndex;
            } else {
                MemberIndex = (DWORD)BestMemberIndex;
            }
        }
    }

    //
    // (Re-)retrieve the driver info data for the best driver we found.
    //
    if(!SetupDiEnumDriverInfo(DeviceInfoSet,
                              DeviceInfoData,
                              SPDIT_COMPATDRIVER,
                              MemberIndex,
                              &DriverInfoData)) {
        //
        // We should never see this error, since we retrieved this driver node
        // just moments ago, and we have the HDEVINFO locked, so no one could
        // have deleted it out from under us.
        //
        Err = GetLastError();
        goto clean1;
    }

    if(!SetupDiSetSelectedDriver(DeviceInfoSet,
                                 DeviceInfoData,
                                 &DriverInfoData)) {
        Err = GetLastError();
    }

clean1:

    if(Err == NO_ERROR) {
        //
        // give a +ve affirmation of Success
        //
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_INFO,
            MSG_LOG_SELECTEDBEST,
            NULL);

        //
        // If we had a basic driver but didn't use it, log an information entry
        //
        if((BasicBestMemberIndex != -1) &&
           (BasicBestMemberIndex != (INT)MemberIndex)) {

            if(SetupDiEnumDriverInfo(DeviceInfoSet,
                                     DeviceInfoData,
                                     SPDIT_COMPATDRIVER,
                                     (DWORD)BasicBestMemberIndex,
                                     &DriverInfoData)) {

                SP_DRVINFO_DETAIL_DATA Data;
                Data.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

                if(SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                              DeviceInfoData,
                                              &DriverInfoData,
                                              &Data,
                                              Data.cbSize,
                                              NULL) ||
                        (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {

                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_INFO,
                        MSG_LOG_SELECTBEST_BASIC_DRIVER_SKIPPED,
                        NULL,
                        Data.DrvDescription,
                        Data.InfFileName,
                        Data.SectionName
                        );
                }
            }
        }

    } else {
        //
        // indicate failed, display error
        //
        WriteLogEntry(
            LogContext,
            ((Err == ERROR_NO_COMPAT_DRIVERS) ?
                DRIVER_LOG_WARNING :
                DRIVER_LOG_ERROR)
             | SETUP_LOG_BUFFER,
            MSG_LOG_SELECTBEST_ERROR,
            NULL);
        WriteLogError(
            LogContext,
            ((Err == ERROR_NO_COMPAT_DRIVERS) ?
                DRIVER_LOG_WARNING :
                DRIVER_LOG_ERROR),
            Err);
    }

    if (pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);

}


BOOL
RetrieveAllDriversForDevice(
    IN  PDEVINFO_ELEM  DevInfoElem,
    OUT PTSTR          *DriverList,
    IN  DWORD          Flags,
    IN  HMACHINE       hMachine
    )
/*++

Routine Description:

    This routine returns a multi-sz list of all filter drivers (both upper and
    lower, class-specific and device-specific) for the specified device information
    element.

Arguments:

    DevInfoElem - Specifies the device information element whose list of filter
        drivers are to be retrieved.

    DriverList - If this routine returns TRUE (i.e., there was at least one
        filter driver for this device), then this pointer is filled in to point
        to a newly-allocated buffer containing a multi-sz list of all filters
        associated with this device.  If we encountered an out-of-memory error,
        this pointer will be set to NULL.

    Flags - can be one of the following:

        RADFD_FLAG_FUNCTION_DRIVER - include the function driver in the
            DriverList return value.

        RADFD_FLAG_DEVICE_UPPER_FILTERS - include the device upper filters in
            the DriverList return value.

        RADFD_FLAG_DEVICE_LOWER_FILTERS - include the device lower filters in
            the DriverList return value.

        RADFD_FLAG_CLASS_UPPER_FILTERS - include the class upper filters in the
            DriverList return value.

        RADFD_FLAG_CLASS_LOWER_FILTERS - include the class lower filters in the
            DriverList return value.

        RADFD_FLAG_DEVICE_FILTERS - include both the device upper and lower
            filters in the DriverList return value.

        RADFD_FLAG_CLASS_FILTERS include both the class upper and lower filters
            in the DriverList return value.


Return Value:

    If there is at least one filter driver for the specified device (or we couldn't
    tell because we ran out of memory), the return value is TRUE.
    Otherwise, it is FALSE.

--*/
{
    PTSTR Buffer, NewBuffer, CurPos, p;
    DWORD BufferSize, UsedSize, RequiredSize;
    DWORD i, NumLists, Err;
    CONFIGRET cr;
    DWORD RegDataType;
    HKEY hk;
    ULONG ulProperty;

    *DriverList = NULL;

    BufferSize = 1024 * sizeof(TCHAR);  // start out with a reasonably-sized buffer.
    Buffer = MyMalloc(BufferSize);
    if(Buffer) {
        UsedSize = 0;
        CurPos = Buffer;
    } else {
        //
        // We really don't know whether there were any filters for this device, but
        // if we return TRUE, the NULL DriverList OUT parameter will signal to the
        // caller that we encountered an out-of-memory condition.
        //
        return TRUE;
    }

    //
    // Attempt to open the class key so we can retrieve the class-specific filter lists.
    //
    hk = SetupDiOpenClassRegKey(&(DevInfoElem->ClassGuid), KEY_READ);
    NumLists = (hk == INVALID_HANDLE_VALUE) ? 3 : 5;

    //
    // First, retrieve the UpperFilters and LowerFilters device properties (i.e.,
    // the device-specific filters).
    //
    for(i = 0; i < NumLists; i++) {

        RequiredSize = 0;

        while(TRUE) {
            //
            // Do we need a larger buffer?
            //
            if(RequiredSize > (BufferSize - UsedSize)) {
                BufferSize = UsedSize + RequiredSize;
                NewBuffer = MyRealloc(Buffer, BufferSize);
                if(NewBuffer) {
                    //
                    // Adjust our current position pointer.
                    //
                    CurPos = NewBuffer + (CurPos - Buffer);
                    Buffer = NewBuffer;
                } else {
                    MyFree(Buffer);
                    if(hk != INVALID_HANDLE_VALUE) {
                        RegCloseKey(hk);
                    }
                    return TRUE;
                }
            } else {
                RequiredSize = BufferSize - UsedSize;
            }

            if(i < 3) {
                //
                // Then we're retrieving the device-specific lists.
                //
                if (i == 0) {
                    //
                    // Check to see if we need to include the function driver
                    //
                    if (!(Flags & RADFD_FLAG_FUNCTION_DRIVER)) {
                        //
                        // Skip the function driver.
                        //
                        break;
                    }
                    ulProperty = CM_DRP_SERVICE;
                } else if (i == 1) {
                    //
                    // Check to see if we need to include the device lower filters.
                    //
                    if (!(Flags & RADFD_FLAG_DEVICE_LOWER_FILTERS)) {
                        //
                        // Skip the device lower filters.
                        //
                        break;
                    }
                    ulProperty = CM_DRP_LOWERFILTERS;
                } else {
                    //
                    // Check to see if we need to include the device upper filters.
                    //
                    if (!(Flags & RADFD_FLAG_DEVICE_UPPER_FILTERS)) {
                        //
                        // Skip the device upper filters.
                        //
                        break;
                    }
                    ulProperty = CM_DRP_UPPERFILTERS;
                }

                cr = CM_Get_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                      ulProperty,
                                                      NULL,
                                                      CurPos,
                                                      &RequiredSize,
                                                      0,
                                                      hMachine);
                switch(cr) {
                    case CR_SUCCESS :
                        Err = ERROR_SUCCESS;
                        break;

                    case CR_BUFFER_SMALL :
                        Err = ERROR_MORE_DATA;
                        break;

                    default :
                        Err = ERROR_INVALID_DATA; // any old error will do.
                        break;
                }

            } else {
                //
                // We're retrieving the class-specific lists.
                //
                if (i == 3) {
                    //
                    // Check to see if we need to include the class lower filters
                    //
                    if (!(Flags & RADFD_FLAG_CLASS_LOWER_FILTERS)) {
                        //
                        // Skip the class lower filters.
                        //
                        break;
                    }
                } else {
                    //
                    // Check to see if we need to include the class upper filters.
                    //
                    if (!(Flags & RADFD_FLAG_CLASS_UPPER_FILTERS)) {
                        //
                        // Skip the class upper filters.
                        //
                        break;
                    }
                }

                Err = RegQueryValueEx(hk,
                                      ((i == 3) ? pszLowerFilters : pszUpperFilters),
                                      NULL,
                                      &RegDataType,
                                      (PBYTE)CurPos,
                                      &RequiredSize
                                     );
            }

            if(Err == ERROR_SUCCESS) {
                //
                // Walk through the service names in the multi-sz list we just retrieved to find
                // the end (just in case someone screwed up when saving out this list and didn't
                // size it properly, etc.)
                //
                // (We use _tcslen instead of strlen, so it'll generate an exception if the list
                // isn't double-null terminated and we go off into la-la land.)
                //
                p = CurPos;

                try {

                    while(*CurPos) {

                        CurPos += _tcslen(CurPos);

                        if(CurPos >= (PTSTR)((PBYTE)Buffer + BufferSize)) {
                            //
                            // We found a list that wasn't properly double-null terminated, but
                            // it didn't cause an exception.
                            //
                            CurPos = p;
                            *CurPos = TEXT('\0');
                            break;

                        } else {
                            CurPos++;

                            if(CurPos == (PTSTR)((PBYTE)Buffer + BufferSize)) {
                                //
                                // Reallocate the buffer to accommodate a terminating null (which the
                                // list we retrieved didn't provide).
                                //
                                BufferSize += sizeof(TCHAR);
                                NewBuffer = MyRealloc(Buffer, BufferSize);
                                if(!NewBuffer) {
                                    MyFree(Buffer);
                                    Buffer = NULL;
                                    goto clean0;
                                }

                                //
                                // Adjust CurPos to point to same location in reallocated buffer.
                                //
                                CurPos = NewBuffer + (CurPos - Buffer);
                                Buffer = NewBuffer;
                                *CurPos = TEXT('\0');
                            } else if (i == 0) {
                                //
                                // This is the SPDRP_SERVICE case, which returns a REG_SZ and
                                // not a multi-sz string.  So tack on an ending NULL.
                                //
                                *CurPos = TEXT('\0');
                            }
                        }

                        p = CurPos;
                    }
clean0:
                    ;   // nothing to do.

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    MYASSERT(CurPos != p);
                    CurPos = p;
                    *CurPos = TEXT('\0');
                }

                if(!Buffer) {
                    //
                    // We needed to resize the buffer to fix an improperly-terminated list, but
                    // we ran out of memory.
                    //
                    if(hk != INVALID_HANDLE_VALUE) {
                        RegCloseKey(hk);
                    }
                    return TRUE;
                }

                UsedSize = (DWORD)((PBYTE)CurPos - (PBYTE)Buffer) + sizeof(TCHAR);

                MYASSERT(UsedSize <= BufferSize);

                break;

            } else if(Err != ERROR_MORE_DATA) {
                //
                // We failed for some reason other than buffer-too-small.  Move on to the
                // next filter driver list.
                //
                break;
            }
        }
    }

    if(hk != INVALID_HANDLE_VALUE) {
        RegCloseKey(hk);
    }

    if(UsedSize) {
        //
        // We retrieved a list of services to return to the caller.
        //
        *DriverList = Buffer;
        return TRUE;
    }

    MYASSERT(Buffer);
    MyFree(Buffer);

    return FALSE;
}


BOOL
RetrieveAllDevNodesSharingDriversWithDevice(
    IN  PDEVINFO_ELEM  DevInfoElem,
    OUT PTSTR          *Drivers,
    OUT PDEVNODE       *DevNodes,
    OUT ULONG          *NumberOfDevNodes,
    IN  HMACHINE       hMachine
    )
/*++

Routine Description:

    This routine returns a multi-sz list of all the devnodes that share a
    driver with the specified device. This includes the device's function driver
    and all filter drivers (both upper and lower, class-specific and device-
    specific).

    This routine returns a multi-sz list of all filter drivers (both upper and
    lower device-specific) for the specified device information
    element.

Arguments:

    DevInfoElem - Specifies the device information element.

    Drivers -

    DevNodes -

    NumberOfDevNodes -

Return Value:

    TRUE unless there is an unexpected error such as out of memory.

--*/
{
    DWORD Err = ERROR_SUCCESS;
    PTSTR p, Buffer = NULL;
    ULONG BufferSize = 1024;
    PTSTR DriversList = NULL, CurDriver;
    DEVNODE DevNode;
    PDEVNODE NewBuffer, ArrayOfDevNodes;
    ULONG DevNodeArraySize = 10;
    ULONG i;
    CONFIGRET cr;

    *NumberOfDevNodes = 0;

    try {
        //
        // Allocate an array of devnodes.  Start with 10 and we will grow it below
        // if we have more.
        //
        if ((ArrayOfDevNodes = MyMalloc(DevNodeArraySize * sizeof(DEVNODE))) == NULL) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        //
        // Always include the devnode that was passed in.
        //
        ArrayOfDevNodes[*NumberOfDevNodes] = DevInfoElem->DevInst;
        (*NumberOfDevNodes)++;

        //
        // Now get a list of all the filter drivers (both upper and lower
        // device-specific) that this device is using and
        // then add any devnode using one of these services to our list.
        //
        if (RetrieveAllDriversForDevice(DevInfoElem,
                                        &DriversList,
                                        RADFD_FLAG_FUNCTION_DRIVER | RADFD_FLAG_DEVICE_FILTERS,
                                        hMachine)) {
            //
            // We need a buffer when we call CM_Get_Device_ID_list_Ex, we will
            // start with a 1024 buffer and grow it as needed.
            //
            Buffer = MyMalloc(BufferSize * sizeof(TCHAR));
            if (!Buffer) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }

            //
            // Enumerate through all the filters and build up a list of drivers
            // they are using.
            //
            for (CurDriver=DriversList; *CurDriver; CurDriver+=(lstrlen(CurDriver)+1)) {
                while ((cr = CM_Get_Device_ID_List_Ex(
                                            CurDriver,
                                            Buffer,
                                            BufferSize,
                                            CM_GETIDLIST_FILTER_SERVICE |
                                            CM_GETIDLIST_DONOTGENERATE,
                                            hMachine
                                            )) == CR_BUFFER_SMALL) {
                    //
                    // If the buffer is too small then we need to reallocate a
                    // larger one.
                    //
                    PTSTR TempBuffer;

                    CM_Get_Device_ID_List_Size_Ex(&BufferSize,
                                                  CurDriver,
                                                  CM_GETIDLIST_FILTER_SERVICE,
                                                  hMachine);

                    TempBuffer = MyRealloc(Buffer, BufferSize * sizeof(TCHAR));

                    if (TempBuffer) {
                        Buffer = TempBuffer;
                    } else {
                        //
                        // We couldn't create a larger buffer!
                        //
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        goto clean0;
                    }
                }

                if (cr == CR_SUCCESS) {
                    //
                    // Enumerate through all the device instance Ids and add them
                    // to the list of devnodes.
                    //
                    for (p=Buffer; *p; p+=(lstrlen(p)+1)) {
                        if (CM_Locate_DevInst_Ex(&DevNode,
                                                 p,
                                                 0,
                                                 hMachine
                                                 ) == CR_SUCCESS) {
                            //
                            // Check to see if this devnode already exists in
                            // our list.
                            //
                            for (i=0; i<*NumberOfDevNodes; i++) {
                                if (ArrayOfDevNodes[i] == DevNode) {
                                    break;
                                }
                            }

                            if (i == *NumberOfDevNodes) {
                                //
                                // Check to see if we need to increase our devnode array.
                                //
                                if (DevNodeArraySize <= *NumberOfDevNodes) {
                                    DevNodeArraySize += 10;
                                    NewBuffer = MyRealloc(ArrayOfDevNodes, DevNodeArraySize * sizeof(DEVNODE));

                                    if (NewBuffer) {
                                        ArrayOfDevNodes = NewBuffer;
                                    } else {
                                        Err = ERROR_NOT_ENOUGH_MEMORY;
                                        goto clean0;
                                    }
                                }

                                ArrayOfDevNodes[*NumberOfDevNodes] = DevNode;
                                (*NumberOfDevNodes)++;
                            }
                        }
                    }
                } else {
                    //
                    // We got another error back so we will fail.
                    //
                    Err = ERROR_INVALID_DATA;
                    goto clean0;
                }
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;

        //
        // Access the following variables, so that the compiler will respect our
        // statement ordering w.r.t. their assignment.
        //
        Buffer = Buffer;
        ArrayOfDevNodes = ArrayOfDevNodes;
        DriversList = DriversList;
    }

clean0:

    if (Buffer) {
        MyFree(Buffer);
    }

    if (Err == ERROR_SUCCESS) {
        *DevNodes = ArrayOfDevNodes;
        *Drivers = DriversList;
    } else {
        //
        // If we failed then free all the memory and set the pointers
        // to NULL.
        //
        if (ArrayOfDevNodes) {
            MyFree(ArrayOfDevNodes);
            *DevNodes = NULL;
        }

        if (DriversList) {
            MyFree(DriversList);
            *Drivers = NULL;
        }
    }

    return (Err == ERROR_SUCCESS);
}


BOOL
AnyServicesLoaded(
    IN  PCTSTR              ServiceNameList,
    OUT PTSTR               LoadedService,      OPTIONAL
    IN  ULONG               LoadedServiceSize
    )
/*++

Routine Description:

    This routine will determine if any of the services passed in our currently
    loaded.

Arguments:

    ServiceNameList - multi-sz list of service names.

    LoadedService - buffer that will receive the service the first service in
        the list that is still loaded into memory. This value is only valid
        if the API returns TRUE.

    LoadedServiceSize - size of the LoadedService buffer.

Return Value:

    TRUE if any of the services in the list are loaded, FALSE if none of them
    are currently loaded.

--*/
{
#ifdef UNICODE
    NTSTATUS Status;
    BOOL bObjectIsLoaded = FALSE;
    DWORD BufSize = 1024;
    PUCHAR Buffer = NULL;
    UNICODE_STRING UnicodeStringDriver;
    UNICODE_STRING UnicodeStringService;
    OBJECT_ATTRIBUTES Attributes;
    HANDLE DirectoryHandle = INVALID_HANDLE_VALUE;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    POBJECT_NAME_INFORMATION NameInfo;
    ULONG Context = 0;
    ULONG ReturnedLength;
    PTSTR CurServiceName;

    try {

        if (LoadedService) {
            LoadedService[0] = TEXT('\0');
        }

        //
        // If no services were passed in then just leave.
        //
        if (!ServiceNameList) {
            goto clean0;
        }

        Buffer = MyMalloc(BufSize);

        if (!Buffer) {
            goto clean0;
        }

        ZeroMemory(Buffer, BufSize);

        RtlInitUnicodeString(&UnicodeStringDriver, TEXT("\\Driver"));

        InitializeObjectAttributes(&Attributes,
                                   &UnicodeStringDriver,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                   );

        Status = NtOpenDirectoryObject(&DirectoryHandle,
                                       DIRECTORY_QUERY,
                                       &Attributes
                                       );

        if (!NT_SUCCESS(Status)) {
            goto clean0;
        }

        //
        // Get the actual name of the object directory object.
        //
        NameInfo = (POBJECT_NAME_INFORMATION)Buffer;
        if (!NT_SUCCESS(Status = NtQueryObject(DirectoryHandle,
                                               ObjectNameInformation,
                                               NameInfo,
                                               BufSize,
                                               (PULONG)NULL))) {
            goto clean0;
        }

        //
        // Grab the driver objects in chuncks instead of one at a time.
        //
        for (Status = NtQueryDirectoryObject(DirectoryHandle,
                                             Buffer,
                                             BufSize,
                                             FALSE,
                                             FALSE,
                                             &Context,
                                             &ReturnedLength
                                             );
             NT_SUCCESS(Status) && !bObjectIsLoaded;
             Status = NtQueryDirectoryObject(DirectoryHandle,
                                             Buffer,
                                             BufSize,
                                             FALSE,
                                             FALSE,
                                             &Context,
                                             &ReturnedLength
                                             )) {
            if (!NT_SUCCESS(Status)) {
                break;
            }

            DirInfo = (POBJECT_DIRECTORY_INFORMATION)Buffer;

            while (TRUE) {
                //
                // Check if there is another record. If there isn't, then get out
                // of the loop now.
                //
                if (DirInfo->Name.Length == 0) {
                    break;
                }

                for (CurServiceName=(PTSTR)ServiceNameList;
                     *CurServiceName;
                     CurServiceName+=(lstrlen(CurServiceName)+1)) {

                    RtlInitUnicodeString(&UnicodeStringService, CurServiceName);

                    if (RtlCompareUnicodeString(&UnicodeStringService, &(DirInfo->Name), TRUE) == 0) {
                        bObjectIsLoaded = TRUE;

                        if (LoadedService) {
                            lstrcpyn(LoadedService, CurServiceName, LoadedServiceSize);
                        }

                        break;
                    }
                }

                //
                // If one of the drivers is loaded then just stop now.
                //
                if (bObjectIsLoaded) {
                    break;
                }

                DirInfo = (POBJECT_DIRECTORY_INFORMATION)(((PUCHAR)DirInfo) +
                                                          sizeof(OBJECT_DIRECTORY_INFORMATION));
            }

            ZeroMemory(Buffer, BufSize);
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        bObjectIsLoaded = TRUE;

        //
        // Access the following variables, so that the compiler will respect our
        // statement ordering w.r.t. their assignment.
        //
        Buffer = Buffer;
    }

clean0:
    if (DirectoryHandle != INVALID_HANDLE_VALUE) {
        NtClose(DirectoryHandle);
    }

    if (Buffer) {
        MyFree(Buffer);
    }

    return bObjectIsLoaded;
#else
    return TRUE;
#endif
}

VOID
RestartSingleDevice(
    IN  PDEVINFO_ELEM       DevInfoElem,
    IN  PDEVICE_INFO_SET    pDeviceInfoSet,
    IN  BOOL                NullDriverInstall,
    IN  PSETUP_LOG_CONTEXT  LogContext
    )
/*++

Routine Description:


Arguments:

    DevInfoElem -

    pDeviceInfoSet -

    NullDriverInstall -

    LogContext -

Return Value:


--*/
{
#ifdef UNICODE
    DWORD DevInstCapabilities;
    ULONG cbData;
    ULONG ulStatus, ulProblem;
    TCHAR DeviceFullID[MAX_DEVICE_ID_LEN];

    //
    // Retrieve the device's capabilities.  We need to know whether the device is
    // capable of being driven 'raw' (i.e., without a function driver).
    //
    cbData = sizeof(DevInstCapabilities);
    if(CR_SUCCESS != CM_Get_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                      CM_DRP_CAPABILITIES,
                                                      NULL,
                                                      &DevInstCapabilities,
                                                      &cbData,
                                                      0,
                                                      pDeviceInfoSet->hMachine))
    {
        DevInstCapabilities = 0;
    }

    //
    // If the device instance has a problem but is not disabled. Just
    // restart it. This should be 90% of the cases.
    //
    if((CM_Get_DevInst_Status_Ex(&ulStatus, &ulProblem, DevInfoElem->DevInst,
                                 0,pDeviceInfoSet->hMachine) == CR_SUCCESS) &&
       ((ulStatus & DN_HAS_PROBLEM) || !(ulStatus & DN_DRIVER_LOADED))) {

        //
        // Poke at Config Manager to make it load the driver.
        //
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_TIME,
            MSG_LOG_BEGIN_RESTART_TIME,
            NULL);       // text message

        CM_Setup_DevInst_Ex(DevInfoElem->DevInst, CM_SETUP_DEVINST_READY, pDeviceInfoSet->hMachine);

        WriteLogEntry(
            LogContext,
            DRIVER_LOG_TIME,
            MSG_LOG_END_RESTART_TIME,
            NULL);       // text message

        //
        // If we're installing a 'real' driver (i.e., not null), or if the device is
        // raw-capable, then we want to check and see if the device actually started as
        // a result of CM_Setup_DevInst.  If not, a reboot is in order.  (There's no need
        // to check when we're doing a null driver install for a non-raw devnode.  We know
        // it can't start, and we definitely don't want to generate a 'need reboot' popup
        // in this case!)
        //
        if(!NullDriverInstall || (DevInstCapabilities & CM_DEVCAP_RAWDEVICEOK)) {
            CheckIfDevStarted(DevInfoElem, pDeviceInfoSet);
        }

    } else {

        CONFIGRET cr;
        TCHAR VetoName[MAX_PATH];
        PNP_VETO_TYPE VetoType;

        //
        // If there is a device instance with no problem, then we
        // should remove it (to unload the current drivers off of
        // it), and then call CM_Setup_DevInst on it.  If the
        // device instance refuses to remove, then set the flags
        // that say we need to reboot.
        //
        // NOTE:  In Win9x, virtual removal of a devnode (e.g., to
        // unload the driver(s) for it), resulted in the devnode's
        // deletion.  Thus, on Win9x, it was necessary to
        // re-enumerate the devnode's parent to cause the devnode
        // to be re-created (and subsequently started).  This is
        // inefficient, especially if we're dealing with a root-
        // enumerated device (hence requiring a reenumeration of
        // the entire tree).  Since the device installer
        // functionality of setupapi will apparently never be used
        // on Win9x, we can optimize this such that we just call
        // CM_Setup_DevInst on this devnode.  We know it didn't
        // actually go away, because devnodes only go away on NT
        // when their underlying hardware is physically removed.
        //
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_TIME,
            MSG_LOG_BEGIN_REMOVE_TIME,
            NULL);       // text message

        cr = CM_Query_And_Remove_SubTree_Ex(DevInfoElem->DevInst,
                                            &VetoType,
                                            VetoName,
                                            SIZECHARS(VetoName),
                                            (DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_NOUIONQUERYREMOVE)
                                                ? CM_REMOVE_UI_NOT_OK
                                                : CM_REMOVE_UI_OK,
                                            pDeviceInfoSet->hMachine
                                           );


        WriteLogEntry(
            LogContext,
            DRIVER_LOG_TIME,
            MSG_LOG_END_REMOVE_TIME,
            NULL);       // text message

        if(cr == CR_SUCCESS) {
            WriteLogEntry(
                LogContext,
                DRIVER_LOG_TIME,
                MSG_LOG_BEGIN_RESTART_TIME,
                NULL);       // text message

            CM_Setup_DevInst_Ex(DevInfoElem->DevInst,
                                CM_SETUP_DEVINST_READY,
                                pDeviceInfoSet->hMachine
                               );

            WriteLogEntry(
                LogContext,
                DRIVER_LOG_TIME,
                MSG_LOG_END_RESTART_TIME,
                NULL);       // text message


            //
            // If we're installing a 'real' driver (i.e., not null),
            // or if the device is raw-capable, then we want to
            // check and see if the device actually started as a
            // result of CM_Setup_DevInst.  If not, a reboot is in
            // order.  (There's no need to check when we're doing a
            // null driver install for a non-raw devnode.  We know
            // it can't start, and we definitely don't want to
            // generate a 'need reboot' popup in this case!)
            //
            if(!NullDriverInstall || (DevInstCapabilities & CM_DEVCAP_RAWDEVICEOK)) {

                CheckIfDevStarted(DevInfoElem,pDeviceInfoSet);
            }
        } else {
            //
            // If the failure was due to a veto, then log
            // information about who vetoed us.
            //
            // SPLOG-- write out a log entry
            //
            if(cr == CR_REMOVE_VETOED) {
                if( CM_Get_Device_ID(DevInfoElem->DevInst,
                                 DeviceFullID,
                                 SIZECHARS(DeviceFullID),
                                 0
                                ) == CR_SUCCESS ) {
                    _WriteVetoLogEntry(
                        LogContext,
                        DRIVER_LOG_WARNING,
                        MSG_LOG_REMOVE_VETOED_IN_INSTALL,
                        DeviceFullID,
                        VetoName,
                        VetoType);
                }
            }

            //
            // If the failure was due to the device not being there,
            // then prompting for reboot isn't going to help
            // anything (plus, you can't set a problem on a non-
            // existent devnode anyway).  This could happen, for
            // example, if the user plugged in a USB mouse, then
            // unplugged it again before we got a chance to
            // complete the device installation.  In this case,
            // we'll just ignore the failure and continue on.
            //
            if(cr != CR_INVALID_DEVNODE) {

                SetDevnodeNeedsRebootProblemWithArg2(DevInfoElem,
                                                     pDeviceInfoSet,
                                                     MSG_LOG_REBOOT_REASON_QR_VETOED,
                                                     cr,
                                                     (ULONG_PTR)_MapCmRetToString(cr)
                                                     );
            }
        }
    }
#else
    //
    // For ANSI just set the reboot flag.
    //
    CM_Set_DevInst_Problem_Ex(DevInfoElem->DevInst,
                              CM_PROB_NEED_RESTART,
                              CM_SET_DEVINST_PROBLEM_OVERRIDE,
                              pDeviceInfoSet->hMachine);
#endif
}


VOID
RestartAllDevicesUsingDrivers(
    IN  PDEVINFO_ELEM       DevInfoElem,
    IN  PDEVICE_INFO_SET    pDeviceInfoSet,
    IN  BOOL                NullDriverInstall,
    IN  PSETUP_LOG_CONTEXT  LogContext
    )
/*++

Routine Description:


Arguments:

    DevInfoElem -

    pDeviceInfoSet -

    NullDriverInstall -

    LogContext -

Return Value:


--*/
{
#ifdef UNICODE
    BOOL bNeedReboot = FALSE;
    PTSTR CurDriver, DriverList = NULL;
    PDEVNODE DevNodeList = NULL;
    ULONG NumberOfDevNodes, LastDevNodeStopped, i;
    ULONG ulStatus, ulProblem;
    PBOOL DevNodeStartedList = NULL;
    TCHAR DeviceFullID[MAX_DEVICE_ID_LEN];
    TCHAR LoadedService[MAX_SERVICE_NAME_LEN];
    CONFIGRET cr;

    try {
        if (RetrieveAllDevNodesSharingDriversWithDevice(DevInfoElem,
                                                        &DriverList,
                                                        &DevNodeList,
                                                        &NumberOfDevNodes,
                                                        pDeviceInfoSet->hMachine)) {
            //
            // Allocate an array of BOOLs so we can remember if each devnode was
            // started before we tried to unload all of the drivers.
            //
            if (NumberOfDevNodes) {
                DevNodeStartedList = MyMalloc(NumberOfDevNodes * sizeof(BOOL));
                if (!DevNodeStartedList) {
                    bNeedReboot = TRUE;
                    goto clean0;
                }
            }

            //
            // First we will enumerate through all of the devices and remember
            // if they were started before we remove/restart them all.  We need
            // to do this step first since we don't have any devnode dependency
            // information so stopping the first one could affect one of the
            // others in the list.
            //
            for (i=0; i<NumberOfDevNodes; i++) {
                if((CM_Get_DevInst_Status_Ex(&ulStatus, &ulProblem, DevNodeList[i],
                                             0,pDeviceInfoSet->hMachine) == CR_SUCCESS) &&
                   (!(ulStatus & DN_HAS_PROBLEM) && (ulStatus & DN_DRIVER_LOADED))) {

                    DevNodeStartedList[i] = TRUE;
                } else {
                    DevNodeStartedList[i] = FALSE;
                }
            }

            //
            // Next stop all of the devnodes that are using one of the drivers
            // associated with our new device.
            //
            for (i=0; i<NumberOfDevNodes; i++) {
                //
                // Remember the last devnode that we tried to stop.
                //
                LastDevNodeStopped = i;

                if(CM_Get_Device_ID(DevNodeList[i],
                                    DeviceFullID,
                                    SIZECHARS(DeviceFullID),
                                    0
                                    ) != CR_SUCCESS ) {
                    DeviceFullID[0] = TEXT('\0');
                }

                //
                // Only attempt to stop the device if it is currently started.
                //
                if((CM_Get_DevInst_Status_Ex(&ulStatus, &ulProblem, DevNodeList[i],
                                             0,pDeviceInfoSet->hMachine) == CR_SUCCESS) &&
                   (!(ulStatus & DN_HAS_PROBLEM) && (ulStatus & DN_DRIVER_LOADED))) {
                    //
                    // Since the devnode is started we need to query remove it.
                    //
                    TCHAR VetoName[MAX_PATH];
                    PNP_VETO_TYPE VetoType;

                    //
                    // Remove the devnode (to unload the current drivers off of
                    // it).  If the device instance refuses to remove, then set
                    // the flags that say we need to reboot.
                    //
                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_TIME,
                        MSG_LOG_BEGIN_REMOVE_TIME_DEVICE,
                        NULL,
                        DeviceFullID);

                    cr = CM_Query_And_Remove_SubTree_Ex(DevNodeList[i],
                                                        &VetoType,
                                                        VetoName,
                                                        SIZECHARS(VetoName),
                                                        CM_REMOVE_NO_RESTART |
                                                        (DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_NOUIONQUERYREMOVE)
                                                            ? CM_REMOVE_UI_NOT_OK
                                                            : CM_REMOVE_UI_OK,
                                                        pDeviceInfoSet->hMachine
                                                       );


                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_TIME,
                        MSG_LOG_END_REMOVE_TIME_DEVICE,
                        NULL,
                        DeviceFullID);

                    if(cr != CR_SUCCESS) {
                        //
                        // If the failure was due to a veto, then log
                        // information about who vetoed us.
                        //
                        // SPLOG-- write out a log entry
                        //
                        if(cr == CR_REMOVE_VETOED) {
                            _WriteVetoLogEntry(
                                LogContext,
                                DRIVER_LOG_WARNING,
                                MSG_LOG_REMOVE_VETOED_IN_INSTALL,
                                DeviceFullID,
                                VetoName,
                                VetoType);
                        }

                        //
                        // If the failure was due to the device not being there,
                        // then prompting for reboot isn't going to help
                        // anything (plus, you can't set a problem on a non-
                        // existent devnode anyway).  This could happen, for
                        // example, if the user plugged in a USB mouse, then
                        // unplugged it again before we got a chance to
                        // complete the device installation.  In this case,
                        // we'll just ignore the failure and continue on.
                        //
                        if(cr != CR_INVALID_DEVNODE) {

                            bNeedReboot = TRUE;

                            WriteLogEntry(
                                LogContext,
                                DRIVER_LOG_WARNING,  // should this be a warning?
                                MSG_LOG_REBOOT_REASON_QR_VETOED,
                                NULL,
                                cr,
                                (ULONG_PTR)_MapCmRetToString(cr),
                                DeviceFullID);
                        }
                    }
                }

                //
                // Don't bother stopping the rest of the drivers if we need a reboot
                //
                if (bNeedReboot) {
                    break;
                }
            }

            if (!bNeedReboot) {
                //
                // Verify that all of the drivers have unloaded.  If just one did not
                // unload then we need to prompt for a reboot.
                //
                if (AnyServicesLoaded(DriverList, LoadedService, SIZECHARS(LoadedService))) {
                    bNeedReboot = TRUE;

                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_WARNING,
                        MSG_LOG_REBOOT_REASON_DRIVER_LOADED,
                        NULL,
                        LoadedService);
                }
            }

            //
            // Now start up all the devices that we stopped.
            //
            for (i=0; i<=LastDevNodeStopped; i++) {
                if(CM_Get_Device_ID(DevNodeList[i],
                                    DeviceFullID,
                                    SIZECHARS(DeviceFullID),
                                    0
                                    ) != CR_SUCCESS ) {
                    DeviceFullID[0] = TEXT('\0');
                }

                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_TIME,
                    MSG_LOG_BEGIN_RESTART_TIME_DEVICE,
                    NULL,
                    DeviceFullID);

                CM_Setup_DevInst_Ex(DevNodeList[i],
                                    CM_SETUP_DEVNODE_READY,
                                    pDeviceInfoSet->hMachine);

                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_TIME,
                    MSG_LOG_END_RESTART_TIME_DEVICE,
                    NULL,
                    DeviceFullID);
            }

            //
            // Finally make one last pass through all the devnodes and verify
            // that the ones that were started initially are started now.
            // If the devnode wasn't started initially then it is OK that it
            // isn't started now.
            //
            // This last pass can be skipped if we already need a reboot, since
            // it is simply a verification pass.
            //
            if (!bNeedReboot) {
                for (i=0; i<NumberOfDevNodes; i++) {
                    if (DevNodeStartedList[i]) {
                        if(CM_Get_Device_ID(DevNodeList[i],
                                            DeviceFullID,
                                            SIZECHARS(DeviceFullID),
                                            0
                                            ) != CR_SUCCESS ) {
                            DeviceFullID[0] = TEXT('\0');
                        }

                        if ((cr = CM_Get_DevNode_Status_Ex(&ulStatus, &ulProblem, DevNodeList[i],
                                                      0, pDeviceInfoSet->hMachine)) == CR_SUCCESS) {
                            if (!(ulStatus & DN_STARTED)) {
                                //
                                // This device was started before and now it isn't started,
                                // so a reboot is needed.
                                //
                                bNeedReboot = TRUE;

                                if (ulStatus & DN_HAS_PROBLEM) {
                                    //
                                    // The device now has a problem when it was
                                    // working fine before.  Log the problem.
                                    //
                                    WriteLogEntry(
                                        LogContext,
                                        DRIVER_LOG_WARNING,
                                        MSG_LOG_REBOOT_REASON_DEVHASPROBLEM,
                                        NULL,
                                        (DWORD)ulProblem,
                                        _MapCmProbToString((DWORD)ulProblem),
                                        DeviceFullID);
                                } else if (ulStatus & DN_PRIVATE_PROBLEM) {
                                    //
                                    // some private problem, change into need reboot
                                    // and log private problem
                                    //
                                    WriteLogEntry(
                                        LogContext,
                                        DRIVER_LOG_WARNING,
                                        MSG_LOG_REBOOT_REASON_PRIVATEPROBLEM,
                                        NULL,
                                        NULL,
                                        NULL,
                                        DeviceFullID);
                                } else {
                                    //
                                    // not started for some other reason
                                    // indicate reboot required and log this issue
                                    //
                                    WriteLogEntry(
                                        LogContext,
                                        DRIVER_LOG_WARNING,
                                        MSG_LOG_REBOOT_REASON_NOTSTARTED,
                                        NULL,
                                        NULL,
                                        NULL,
                                        DeviceFullID);
                                }
                            }
                        } else {
                            bNeedReboot = TRUE;

                            WriteLogEntry(
                                LogContext,
                                DRIVER_LOG_WARNING,
                                MSG_LOG_REBOOT_REASON_DEVHASPROBLEM,
                                NULL,
                                cr,
                                (ULONG_PTR)_MapCmRetToString(cr),
                                DeviceFullID);
                        }
                    }
                }
            }
        } else {
            //
            // If we can't get the list of drivers for some reason then just
            // set the needs reboot flag.
            //
            bNeedReboot = TRUE;
        }

        if (!bNeedReboot) {
            //
            // At this point we need to check that the device that we just installed
            // is actually started, unless it is a NULL driver install.
            //
            DWORD DevInstCapabilities;
            ULONG cbData;

            cbData = sizeof(DevInstCapabilities);
            if(CR_SUCCESS != CM_Get_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                              CM_DRP_CAPABILITIES,
                                                              NULL,
                                                              &DevInstCapabilities,
                                                              &cbData,
                                                              0,
                                                              pDeviceInfoSet->hMachine))
            {
                DevInstCapabilities = 0;
            }

            if(!NullDriverInstall || (DevInstCapabilities & CM_DEVCAP_RAWDEVICEOK)) {

                CheckIfDevStarted(DevInfoElem,pDeviceInfoSet);
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        bNeedReboot = TRUE;

        //
        // Access the following variables, so that the compiler will respect our
        // statement ordering w.r.t. their assignment.
        //
        DriverList = DriverList;
        DevNodeList = DevNodeList;
        DevNodeStartedList = DevNodeStartedList;
    }

clean0:



    if (DriverList) {
        MyFree(DriverList);
    }

    if (DevNodeList) {
        MyFree(DevNodeList);
    }

    if (DevNodeStartedList) {
        MyFree(DevNodeStartedList);
    }

    if (bNeedReboot) {
        CM_Set_DevInst_Problem_Ex(DevInfoElem->DevInst,
                                  CM_PROB_NEED_RESTART,
                                  CM_SET_DEVINST_PROBLEM_OVERRIDE,
                                  pDeviceInfoSet->hMachine);
    }
#else
    //
    // For ANSI just set the reboot flag.
    //
    CM_Set_DevInst_Problem_Ex(DevInfoElem->DevInst,
                              CM_PROB_NEED_RESTART,
                              CM_SET_DEVINST_PROBLEM_OVERRIDE,
                              pDeviceInfoSet->hMachine);
#endif
}



VOID
AppendLoadIncludedInfs(
    IN HINF   hDeviceInf,
    IN PCTSTR InfFileName,
    IN PCTSTR InfSectionName,
    IN BOOL   AppendLayoutInfs
    )
/*++

Routine Description:

    This routine processes the "include=" line in the specified section of the
    specified INF.  For each filename entry on this line, it attempts to append-load
    that file to the supplied INF (first, from the location where the original INF
    was located, and if that fails, then using the default INF search path).

Arguments:

    hDeviceInf - supplies a handle to the INF containing the section specified by
        InfSectionName.  Upon return, this INF handle will also contain any additional
        INFs that were append-loaded based on INFs listed in the "include=" entry of
        the InfSectionName section.

    InfFileName - supplies the full path of the INF whose handle was supplied in
        the hDeviceInf parameter.  The path component is used in an attempt to first
        locate the specified included INFs in the same location as that of the original
        INF.

    InfSectionName - supplies the name of the section containing an "include=" line
        whose fields are simply filenames of INFs to be append loaded to the original
        INF whose handle is supplied in the hDeviceInf parameter.

    AppendLayoutInfs - if non-zero (TRUE), then we will attempt to append-load the
        corresponding layout INF for each included INF.

Return Value:

    none.

--*/
{
    TCHAR DefaultInfPath[MAX_PATH];
    PTSTR FileNamePos;
    INFCONTEXT InfContext;
    DWORD FieldIndex;
    BOOL b;

    //
    // Store the full directory path to where the supplied INF is located, so we
    // can first attempt to append-load the included INFs from that same directory.
    //
    lstrcpyn(DefaultInfPath, InfFileName, SIZECHARS(DefaultInfPath));
    FileNamePos = (PTSTR)pSetupGetFileTitle(DefaultInfPath);

    if(SetupFindFirstLine(hDeviceInf, InfSectionName, TEXT("include"), &InfContext)) {

        for(FieldIndex = 1;
            SetupGetStringField(&InfContext,
                                FieldIndex,
                                FileNamePos,
                                (DWORD)((DefaultInfPath + SIZECHARS(DefaultInfPath)) - FileNamePos),
                                NULL);
            FieldIndex++)
        {
            //
            // Try full path and if that fails just use the inf name
            // and let the open routine try to locate the inf.
            // Ignore errors. We'll catch them later, during the install phases.
            //
            b = SetupOpenAppendInfFile(DefaultInfPath, hDeviceInf, NULL);
            if(!b) {
                b = SetupOpenAppendInfFile(FileNamePos, hDeviceInf, NULL);
            }

            //
            // If we successfully append-loaded the included INF, and if we're also
            // supposed to be append-loading any associated layout INFs, then do that
            // now.
            //
            if(b && AppendLayoutInfs) {
                SetupOpenAppendInfFile(NULL, hDeviceInf, NULL);
            }
        }
    }
}


DWORD
InstallFromInfSectionAndNeededSections(
    IN HWND              Owner,             OPTIONAL
    IN HINF              InfHandle,
    IN PCTSTR            SectionName,
    IN UINT              Flags,
    IN HKEY              RelativeKeyRoot,   OPTIONAL
    IN PCTSTR            SourceRootPath,    OPTIONAL
    IN UINT              CopyFlags,
    IN PSP_FILE_CALLBACK MsgHandler,
    IN PVOID             Context,           OPTIONAL
    IN HDEVINFO          DeviceInfoSet,     OPTIONAL
    IN PSP_DEVINFO_DATA  DeviceInfoData,    OPTIONAL
    IN HSPFILEQ          UserFileQ          OPTIONAL
    )
/*++

Routine Description:

    This routine calls SetupInstallFromInfSection for the specified install section,
    as well as for any additional sections specified in a "needs=" line contained in
    that section.

Arguments:

    Same as for SetupInstallFromInfSection, except for UserFileQ.  If UserFileQ is
    non-NULL, then we will only install files (via pSetupInstallFiles) using this
    file queue.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is a Win32 error code
    indicating the cause of the failure.

--*/
{
    DWORD FieldIndex, Err;
    INFCONTEXT InfContext;
    BOOL NeedsEntriesToProcess;
    TCHAR SectionToInstall[MAX_SECT_NAME_LEN];

    lstrcpyn(SectionToInstall, SectionName, SIZECHARS(SectionToInstall));

    NeedsEntriesToProcess = SetupFindFirstLine(InfHandle,
                                               SectionName,
                                               TEXT("needs"),
                                               &InfContext
                                              );

    Err = NO_ERROR;

    for(FieldIndex = 0; (!FieldIndex || NeedsEntriesToProcess); FieldIndex++) {

        if(FieldIndex) {
            //
            // Get next section name on "needs=" line to be processed.
            //
            if(!SetupGetStringField(&InfContext,
                                    FieldIndex,
                                    SectionToInstall,
                                    SIZECHARS(SectionToInstall),
                                    NULL)) {
                //
                // We've exhausted all the extra sections we needed to install.
                //
                break;
            }
        }

        if(UserFileQ) {
            //
            // The caller supplied their own file queue, so all we can do is copy
            // files.  Make sure that file copying is all they want, and that they
            // gave us a valid file queue handle.
            //
            MYASSERT(Flags == SPINST_FILES);
            MYASSERT(UserFileQ != INVALID_HANDLE_VALUE);

            Err = pSetupInstallFiles(InfHandle,
                                     NULL,
                                     SectionToInstall,
                                     SourceRootPath,
                                     MsgHandler,
                                     Context,
                                     CopyFlags,
                                     Owner,
                                     UserFileQ,
                                     TRUE
                                    );

        } else {
            //
            // The caller didn't supply their own file queue, so we can just use
            // SetupInstallFromInfSection.
            //
            if(!_SetupInstallFromInfSection(Owner,
                                            InfHandle,
                                            SectionToInstall,
                                            Flags,
                                            RelativeKeyRoot,
                                            SourceRootPath,
                                            CopyFlags,
                                            MsgHandler,
                                            Context,
                                            DeviceInfoSet,
                                            DeviceInfoData,
                                            TRUE,
                                            NULL)) {
                Err = GetLastError();
                break;
            }
        }
    }

    return Err;
}

DWORD
pSetupCopyRelatedInfs(
    IN HINF   hInf,
    IN PCTSTR InfFileName,                  OPTIONAL
    IN PCTSTR InfSectionName,
    IN DWORD  OEMSourceMediaType,
    IN PSETUP_LOG_CONTEXT LogContext        OPTIONAL
    )
/*++

Routine Description:

    This routine processes "CopyINF" directives in the DDInstall section of the
    primary INF.
    CopyINF is not processed under following cases:
        Primary INF is in driver search path
        The CopyINF is specified in an included section.

Arguments:

    hInf - supplies a handle to the INF containing the section specified by
        InfSectionName.

    InfFileName - supplies the full path of the INF whose handle was supplied in
        the hDeviceInf parameter.  The path component is used in an attempt to
        locate the specified INFs. If not specified, we try to get this from hInf

    InfSectionName - supplies the name of the section containing "CopyINF=" lines.

    OEMSourceMediaType - Specifies the type of source media that the location
        information references.  May be one of the following values:

        SPOST_NONE - No source media information should be stored in the PNF
                     file.  (OEMSourceMediaLocation is ignored in this case.)

        SPOST_PATH - OEMSourceMediaLocation contains a path to the source media.
                     For example, if the media is on a floppy, this path might
                     be "A:\". If OEMSourceMediaLocation is NULL, then the path
                     is assumed to be the path where the INF is located (unless
                     the INF has a corresponding PNF in that location, in which
                     case that PNF's source media information will be
                     transferred to the destination PNF).

        SPOST_URL  - OEMSourceMediaLocation contains a URL indicating the
                     internet location where the INF/driver files were retrieved
                     from.  If OEMSourceMediaLocation is NULL, then it is
                     assumed that the default Code Download Manager location was
                     used.
              
    LogContext - used for logging. If not specified, we get this from hInf

Return Value:

    none.

--*/
{
    INFCONTEXT CopyInfLineContext;
    TCHAR CombinedPath[MAX_PATH*2];
    TCHAR FullSourcePath[MAX_PATH];
    PTSTR Title;
    PCTSTR Field;
    PCTSTR SourcePath;
    DWORD Status;
    DWORD FieldCount;
    DWORD FieldIndex;
    DWORD RetVal;
    PLOADED_INF pInf = NULL;

    if(hInf == NULL || InfSectionName == NULL) {
        return ERROR_INVALID_PARAMETER;
    }
    pInf = (PLOADED_INF)hInf;
    if(!LockInf(pInf)) {
        return ERROR_INVALID_HANDLE;
    }
    if(!LogContext) {
        LogContext = pInf->LogContext;
    }
    if(!InfFileName) {
        InfFileName = pInf->VersionBlock.Filename;
    }
    //
    // if primary INF is from OEM location, then process CopyINF directives
    // note that if the INF is in search path, we ignore CopyINF
    // we also ignore CopyINF's pulled in from other INF's (ie, don't process
    // Include/Needs).
    //
    if(!pSetupInfIsFromOemLocation(InfFileName, FALSE)) {
        //
        // Primary INF is on search path, ignore CopyINF directives
        //
        Status = NO_ERROR;
        goto final;
    }

    lstrcpyn(CombinedPath,InfFileName,MAX_PATH);
    Title = (PTSTR)pSetupGetFileTitle(CombinedPath);
    if (!Title) {
        //
        // shouldn't happen
        //
        MYASSERT(Title);
        Status = ERROR_INVALID_PARAMETER;
        goto final;
    }

    //
    // we look for keyword "CopyInf" in the install section
    //
    if (SetupFindFirstLine(hInf,
                           InfSectionName,
                           SZ_KEY_COPYINF,
                           &CopyInfLineContext)) {

        PSETUP_LOG_CONTEXT SavedLogContext = NULL;
        BOOL ChangedThreadLogContext = SetThreadLogContext(LogContext,&SavedLogContext);
        //
        // we've pushed log context so SetupCopyOemInf will log correctly
        //

        do {
            //
            // CopyInf = a.inf,b.inf,c.inf...
            // a.inf will be at index 1.
            //
            FieldCount = SetupGetFieldCount(&CopyInfLineContext);
            for(FieldIndex = 1;FieldIndex<=FieldCount;FieldIndex++) {

                Status = NO_ERROR;

                Field = pSetupGetField(&CopyInfLineContext,FieldIndex);
                lstrcpyn(Title,Field,MAX_PATH);

                //
                // we have a listed INF, obtain canonical pathname
                // for this INF
                // (note that we assume the INF is relative
                //  to original INF and is typically just a filename)
                //
                RetVal = GetFullPathName(CombinedPath,
                                         MAX_PATH,
                                         FullSourcePath,
                                         NULL);
                if (RetVal == 0 || RetVal > MAX_PATH) {
                    SourcePath = CombinedPath;
                } else {
                    SourcePath = FullSourcePath;
                }

                if(!SetupCopyOEMInf(FullSourcePath,
                                NULL,
                                OEMSourceMediaType,
                                0,
                                NULL,
                                0,
                                NULL,
                                NULL)) {
                    Status = GetLastError();
                }

                if (Status != NO_ERROR) {
                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                        MSG_LOG_COPYINF_ERROR,
                        NULL,
                        FullSourcePath);
                    WriteLogError(
                        LogContext,
                        DRIVER_LOG_ERROR,
                        Status);

                } else {
                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_INFO,
                        MSG_LOG_COPYINF_OK,
                        NULL,
                        FullSourcePath);
                }
            }

        } while (SetupFindNextMatchLine(&CopyInfLineContext,
                                        SZ_KEY_COPYINF,
                                        &CopyInfLineContext));

        if (ChangedThreadLogContext) {
            //
            // restore thread log context
            //
            SetThreadLogContext(SavedLogContext,NULL);
        }
    }
    Status = NO_ERROR;

final:
    if(pInf) {
        UnlockInf(pInf);
    }
    return Status;
}

VOID
SetDevnodeNeedsRebootProblemWithArg2(
    IN PDEVINFO_ELEM DevInfoElem,
    IN PDEVICE_INFO_SET pDevInfoSet,
    IN DWORD    Reason,                  OPTIONAL
    IN ULONG_PTR Arg1,                   OPTIONAL
    IN ULONG_PTR Arg2                    OPTIONAL
    )
/*++

Routine Description:

    This routine sets DI_NEEDREBOOT,
     sets the problem of the specified devnode to be CM_PROB_NEED_RESTART
     and logs information about why we did this

Arguments:

    DevInfoElem  )_ identify the devnode with the problem
    DevInfoSet   )

    Reason - Supplies a string resource ID for logging the reason a reboot is
        required.  If this is 0, nothing will be logged.

    Arg1/Arg2 - optional arguments %1 and %2 of the logged message


Return Value:

    none.

--*/
{
    TCHAR   szDevID[MAX_DEVICE_ID_LEN];
    CONFIGRET cr;

    DevInfoElem->InstallParamBlock.Flags |= DI_NEEDREBOOT;

    if((cr = CM_Get_Device_ID_Ex(DevInfoElem->DevInst,
                     szDevID,
                     SIZECHARS(szDevID),
                     0,
                     pDevInfoSet->hMachine)) != CR_SUCCESS) {
        szDevID[0] = TEXT('\0');
    }

    CM_Set_DevInst_Problem_Ex(DevInfoElem->DevInst,
                              CM_PROB_NEED_RESTART,
                              CM_SET_DEVINST_PROBLEM_OVERRIDE,
                              pDevInfoSet->hMachine);

    if (Reason) {
        //
        // if the caller gave a reason, log why a reboot is required
        //
        WriteLogEntry(
            DevInfoElem->InstallParamBlock.LogContext,
            DRIVER_LOG_WARNING,  // should this be a warning?
            Reason,
            NULL,
            Arg1,
            Arg2,
            szDevID);
    }
}


DWORD
MarkQueueForDeviceInstall(
    IN HSPFILEQ QueueHandle,
    IN HINF     DeviceInfHandle,
    IN PCTSTR   DeviceDesc       OPTIONAL
    )
/*++

Routine Description:

    This routine adds catalog info entries (if not already present) into a file
    queue for the INFs represented by the supplied INF handle.  It also marks
    the first INF's catalog entry (whether newly-created or not) with a flag
    indicating that this is the 'primary' device INF for this installation.  It
    then sets a flag in the queue indicating that the behavior when subsequently
    calling _SetupVerifyQueuedCatalogs should be to copy the INF into the
    %windir%\Inf directory (as opposed to merely creating a zero-length file
    there of the correct name so that the catfile's name is guaranteed unique).
    Finally, it retrieves the driver signing policy and associates it with the
    queue (up until this point, the queue has associated with it the non-driver
    signing policy).

Arguments:

    QueueHandle - supplies a handle to the file queue to be marked as a device
        install file queue.

    DeviceInfHandle - supplies a handle to the device INF upon which this
        installation is based.  In addition to the "primary" device INF, this
        handle may also contain one or more append-loaded INFs.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is a Win32 error
    code indicating the cause of the failure.

--*/
{
    PSP_FILE_QUEUE Queue;
    TCHAR TempBuffer[MAX_PATH];
    LONG InfStringId, CatStringId, OriginalInfStringId;
    PLOADED_INF pInf;
    DWORD Err;
    PTSTR InfDeviceDesc;
    PSPQ_CATALOG_INFO CatalogNode, PrevCatalogNode, NewCatalogNode;
    BOOL DifferentOriginalName;
    TCHAR OriginalInfName[MAX_PATH];
    BOOL UnlockInf;
    BOOL UseOriginalInfName;

    //
    // Queue handle is actually a pointer to the queue structure.
    //
    Queue = (PSP_FILE_QUEUE)QueueHandle;

    NewCatalogNode = NULL;
    Err = NO_ERROR;
    InfDeviceDesc = NULL;
    UnlockInf = FALSE;

    try {

        if(LockInf((PLOADED_INF)DeviceInfHandle)) {
            UnlockInf = TRUE;
        } else {
            Err = ERROR_INVALID_HANDLE;
            goto clean0;
        }

        //
        // We want to process each INF in the LOADED_INF list...
        //
        for(pInf = (PLOADED_INF)DeviceInfHandle; pInf; pInf = pInf->Next) {
            //
            // First, get the (potentially decorated) CatalogFile= entry from
            // the version block of this INF member, as well as the INF's
            // original name (if different from the INF's current name).
            //
            Err = pGetInfOriginalNameAndCatalogFile(
                      pInf,
                      NULL,
                      &DifferentOriginalName,
                      OriginalInfName,
                      SIZECHARS(OriginalInfName),
                      TempBuffer,
                      SIZECHARS(TempBuffer),
                      NULL // always native OS/arch (ver doesn't matter for CatalogFile=)
                     );

            if(Err != NO_ERROR) {
                goto clean0;
            }

            if(DifferentOriginalName) {
                //
                // Add the INF's original (simple) filename to our string table.
                //
                OriginalInfStringId = pSetupStringTableAddString(
                                          Queue->StringTable,
                                          OriginalInfName,
                                          STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                         );

                if(OriginalInfStringId == -1) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean0;
                }

            } else {
                //
                // INF's original name is the same as its present name.
                //
                OriginalInfStringId = -1;
            }

            if(*TempBuffer) {

                CatStringId = pSetupStringTableAddString(Queue->StringTable,
                                                   TempBuffer,
                                                   STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                                  );
                if(CatStringId == -1) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean0;
                }
            } else {
                //
                // This INF doesn't have a CatalogFile= entry.
                //
                CatStringId = -1;
            }

            //
            // Now, get the INF's full path.
            //
            lstrcpyn(TempBuffer, pInf->VersionBlock.Filename, SIZECHARS(TempBuffer));
            InfStringId = pSetupStringTableAddString(Queue->StringTable,
                                               TempBuffer,
                                               STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                              );
            if(InfStringId == -1) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }

            //
            // Now search for an existing catalog node (there'll typically be
            // one unless the device INF doesn't copy any files, such as a
            // modem INF).
            //
            for(PrevCatalogNode=NULL, CatalogNode=Queue->CatalogList;
                CatalogNode;
                CatalogNode=CatalogNode->Next) {

                if(CatalogNode->InfFullPath == InfStringId) {
                    //
                    // Already in there. No need to create a new node.
                    // Break out here, with CatalogNode pointing at the
                    // proper node for this catalog file.
                    //
                    // In this case, PrevCatalogNode should not be used later,
                    // but it shouldn't need to be used, since we won't be
                    // adding anything new onto the list of catalog nodes.
                    //
                    // NOTE: Our alternate catalog should be correct because
                    // either (a) the altplatform info was in effect when the
                    // INF was added, or (b) the altplatform info was applied
                    // after the INF's addition, and it was updated at that
                    // time.
                    //
                    MYASSERT(CatalogNode->CatalogFileFromInf == CatStringId);
                    MYASSERT(CatalogNode->InfOriginalName == OriginalInfStringId);
                    break;
                }

                //
                // PrevCatalogNode will end up pointing to the final node
                // currently in the linked list, in the case where we need
                // to allocate a new node. This is useful so we don't have to
                // traverse the list again later when we add the new catalog
                // node to the list for this queue.
                //
                PrevCatalogNode = CatalogNode;
            }

            //
            // If we didn't find an existing catalog node, then add one now.
            //
            if(!CatalogNode) {
                //
                // Need to create a new catalog node.
                //
                NewCatalogNode = MyMalloc(sizeof(SPQ_CATALOG_INFO));
                if(!NewCatalogNode) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean0;
                }
                ZeroMemory(NewCatalogNode, sizeof(SPQ_CATALOG_INFO));
                NewCatalogNode->CatalogFileFromInf = CatStringId;
                NewCatalogNode->InfOriginalName = OriginalInfStringId;
                NewCatalogNode->InfFullPath = InfStringId;
                NewCatalogNode->InfFinalPath = -1;
                NewCatalogNode->AltCatalogFileFromInfPending = -1;

                //
                // If this queue has alternate platform info associated with
                // it, then we need to retrieve the alternate catalog to be
                // used for digital signature verification.
                //
                if(Queue->Flags & FQF_USE_ALT_PLATFORM) {

                    if(pSetupGetCatalogFileValue(&(pInf->VersionBlock),
                                                 TempBuffer,
                                                 SIZECHARS(TempBuffer),
                                                 &(Queue->AltPlatformInfo))) {

                        NewCatalogNode->AltCatalogFileFromInf =
                            pSetupStringTableAddString(Queue->StringTable,
                                                       TempBuffer,
                                                       STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                                      );
                        if(NewCatalogNode->AltCatalogFileFromInf == -1) {
                            Err = ERROR_NOT_ENOUGH_MEMORY;
                            goto clean0;
                        }

                    } else {
                        //
                        // This INF doesn't have a CatalogFile= entry.
                        //
                        NewCatalogNode->AltCatalogFileFromInf = -1;
                    }

                } else {
                    //
                    // No alternate platform info associated with the queue at
                    // this time.
                    //
                    NewCatalogNode->AltCatalogFileFromInf = -1;
                }

                if(Queue->CatalogList) {
                    PrevCatalogNode->Next = NewCatalogNode;
                } else {
                    Queue->CatalogList = NewCatalogNode;
                }
                //
                // Reset NewCatalogNode so we won't try to free it in case we
                // encounter a subsequent error.
                //
                CatalogNode = NewCatalogNode;
                NewCatalogNode = NULL;

                //
                // We've successfully added a new, as yet unvalidated, catalog
                // node.  We must therefore reset the  the "catalog
                // verifications done" flags so that we'll redo them later.
                //
                Queue->Flags &= ~(FQF_DID_CATALOGS_OK | FQF_DID_CATALOGS_FAILED);
            }

            if(pInf == (PLOADED_INF)DeviceInfHandle) {
                //
                // At this point, CatalogNode points to the node representing
                // the device INF upon which this device installation is based.
                // Mark this node as such, so that _SetupVerifyQueuedCatalogs
                // can return the INF's new name if it's an OEM INF.
                //
                CatalogNode->Flags |= CATINFO_FLAG_PRIMARY_DEVICE_INF;
            }
        }

        if(!(Queue->Flags & FQF_DEVICE_INSTALL)) {
            //
            // This queue wasn't previously known to be a device install queue,
            // so it's possible the catalog nodes have already been verified
            // subject to non-driver signing policy.  Further, it's possible
            // (albeit unlikely) that a non-device INF was passed into this
            // routine, and that a catalog node for that INF already existed in
            // our catalog list.  In that case, one of our "catalog
            // verifications done" flags would be set, but would not have been
            // cleared above since we didn't add any catalog nodes.  All of
            // this discussion simply to justify that we really do need to
            // clear the bits here too...  :-(
            //
            Queue->Flags &= ~(FQF_DID_CATALOGS_OK | FQF_DID_CATALOGS_FAILED);

            //
            // Note:  We don't clear the CATINFO_FLAG_NEWLY_COPIED flags for any
            // of the catalog nodes, because we want to make sure we re-use
            // those same names when re-doing verification (e.g., maybe the
            // first time around the INF was installed into %windir%\Inf as a
            // zero-length file--we want to re-use the same filename to now hold
            // our INF).
            //

            //
            // Since we previously didn't know this was a device install queue,
            // we shouldn't have a ValidationPlatform.  Make sure that's the
            // case, because the call below would blow away any we had (thus
            // causing a memory leak).
            //
            MYASSERT(!(Queue->ValidationPlatform));

            //
            // Retrieve the codesigning policy in effect for this device (thus
            // replacing the default non-driver signing policy that was
            // associated with the queue when it was originally created).
            //
            IsInfForDeviceInstall(Queue->LogContext,
                                  NULL,
                                  (PLOADED_INF)DeviceInfHandle,
                                  (DeviceDesc ? NULL : &InfDeviceDesc),
                                  &(Queue->ValidationPlatform),
                                  &(Queue->DriverSigningPolicy),
                                  &UseOriginalInfName
                                 );

            if(UseOriginalInfName) {
                Queue->Flags |= FQF_KEEP_INF_AND_CAT_ORIGINAL_NAMES;
            }

            //
            // If the caller supplied us with a device description (or we got
            // one from IsInfForDeviceInstall), attempt to add that string to
            // the queue's string table in case we need to give a digital
            // signature verification failure popup for this queue.
            //
            //
            // NOTE: When adding the following string to the string table, we
            // cast away its CONST-ness to avoid a compiler warning.  Since we
            // are adding it case-sensitively, we are guaranteed it will not be
            // modified.
            //
            if(DeviceDesc) {
                Queue->DeviceDescStringId = pSetupStringTableAddString(Queue->StringTable,
                                                                 (PTSTR)DeviceDesc,
                                                                 STRTAB_CASE_SENSITIVE
                                                                );
            } else if(InfDeviceDesc) {
                //
                // Use the more generic description based on the device's class
                //
                Queue->DeviceDescStringId = pSetupStringTableAddString(Queue->StringTable,
                                                                 InfDeviceDesc,
                                                                 STRTAB_CASE_SENSITIVE
                                                                );
            }

            //
            // Set a flag in the queue that indicates this is for a device
            // installation.  If we're doing a native platform installation
            // (i.e., the FQF_USE_ALT_PLATFORM isn't set), then this also
            // causes us to copy the INF into %windir%\Inf instead of merely
            // creating a zero-length placeholder file there upon which the
            // corresponding CAT file's installation is based.
            //
            Queue->Flags |= FQF_DEVICE_INSTALL;

        } else {
            //
            // This queue has previously been marked as a device install queue.
            // However, we still want to update the device description, if the
            // caller supplied one.
            //
            if(DeviceDesc) {
                Queue->DeviceDescStringId = pSetupStringTableAddString(Queue->StringTable,
                                                                 (PTSTR)DeviceDesc,
                                                                 STRTAB_CASE_SENSITIVE
                                                                );
            }
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // If we hit an AV, then use invalid parameter error, otherwise, assume
        // an inpage error when dealing with a mapped-in file.
        //
        Err = (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION)
              ? ERROR_INVALID_PARAMETER
              : ERROR_READ_FAULT;

        //
        // Access the following variables, so that the compiler will respect our
        // statement ordering w.r.t. their assignment.
        //
        UnlockInf = UnlockInf;
        NewCatalogNode = NewCatalogNode;
    }

    if(UnlockInf) {
        UnlockInf((PLOADED_INF)DeviceInfHandle);
    }

    if(NewCatalogNode) {
        MyFree(NewCatalogNode);
    }

    if(InfDeviceDesc) {
        MyFree(InfDeviceDesc);
    }

    return Err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\devres.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    devres.c

Abstract:

    Routines for displaying resource dialogs.

Author:

    Paula Tomlinson (paulat) 7-Feb-1996

Revision History:

    Jamie Hunter (jamiehun) 19-Mar-1998

--*/

#include "precomp.h"
#pragma hdrstop

//
// Private Prototypes
//


//
// Global Data
//

static INTERFACE_TYPE ResourcePickerReadOnlyInterfaces[] = {
    //
    // List of interface-types that we don't want user to edit properties of
    //

    PCIBus,

    //
    // End of list
    //
    InterfaceTypeUndefined
};

static const BOOL ResTypeEditable[ResType_MAX+1] = {
    //
    // lists resource types that are shown and are editable
    FALSE,  // ResType_None
    TRUE,   // ResType_Mem
    TRUE,   // ResType_IO
    TRUE,   // ResType_DMA
    TRUE,   // ResType_IRQ
    FALSE,  // ResType_DoNotUse
    FALSE   // ResType_BusNumber
};

#if (ResType_MAX+1) != 7
#error Fix SetupAPI devres.c, ResType_MAX has changed
#endif

//
// HELP ID's
//
static const DWORD DevResHelpIDs[]=
{
    IDC_DEVRES_ICON,            IDH_NOHELP,     // "Low (%d)" (Static)
    IDC_DEVRES_DEVDESC,         IDH_NOHELP,
    IDC_DEVRES_SETTINGSTATE,    IDH_DEVMGR_RESOURCES_SETTINGS,
    IDC_DEVRES_SETTINGSLIST,    IDH_DEVMGR_RESOURCES_SETTINGS,
    IDC_DEVRES_LCTEXT,          IDH_DEVMGR_RESOURCES_BASEDON,
    IDC_DEVRES_LOGCONFIGLIST,   IDH_DEVMGR_RESOURCES_BASEDON,
    IDC_DEVRES_CHANGE,          IDH_DEVMGR_RESOURCES_CHANGE,
    IDC_DEVRES_USESYSSETTINGS,  IDH_DEVMGR_RESOURCES_AUTO,
    IDC_DEVRES_CONFLICTDEVTEXT, IDH_DEVMGR_RESOURCES_CONFLICTS,
    IDC_DEVRES_CONFLICTINFOLIST,    IDH_DEVMGR_RESOURCES_CONFLICTS,
    IDC_DEVRES_MFPARENT,        IDH_DEVMGR_RESOURCES_PARENT,
    IDC_DEVRES_MFPARENT_DESC,   IDH_DEVMGR_RESOURCES_PARENT,
    IDC_DEVRES_MAKEFORCED,      IDH_DEVMGR_RESOURCES_SETMANUALLY,
    0, 0
};

//
// HACKHACK (jamiehun)
// after we've changed UI from a MakeForced, we post this message to get back control of keyboard
//

#define WM_USER_FOCUS           (WM_USER+101)


//
// API to obtain a resource-picker page
//

HPROPSHEETPAGE
GetResourceSelectionPage(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
{
    LPDMPROP_DATA     pdmData;
    PROPSHEETPAGE     PropPage;

    //
    // private data
    // anything we "do" here must be "undone" in pResourcePickerPropPageCallback
    //
    pdmData = (LPDMPROP_DATA)MyMalloc(sizeof(DMPROP_DATA));
    if (pdmData == NULL) {
        return NULL;
    }
    ZeroMemory(pdmData,sizeof(DMPROP_DATA));

    pdmData->hDevInfo      = DeviceInfoSet;
    pdmData->lpdi          = DeviceInfoData;

    //
    // validate expectations
    //
    MYASSERT(pdmData->hDevInfo != NULL);
    MYASSERT(pdmData->lpdi != NULL);
    MYASSERT(pdmData->lpdi->DevInst != 0);

    ZeroMemory(&PropPage,sizeof(PropPage));

    //
    // create the Resources Property Page
    //
    PropPage.dwSize        = sizeof(PROPSHEETPAGE);
    PropPage.dwFlags       = PSP_DEFAULT | PSP_USECALLBACK;
    PropPage.hInstance     = MyDllModuleHandle;
    PropPage.pszTemplate   = MAKEINTRESOURCE(IDD_DEF_DEVRESOURCE_PROP);
    PropPage.pszIcon       = NULL;
    PropPage.pszTitle      = NULL;
    PropPage.pfnDlgProc    = pResourcePickerDlgProc;
    PropPage.lParam        = (LPARAM)pdmData;
    PropPage.pfnCallback   = pResourcePickerPropPageCallback;
#ifdef _UNICODE
    PropPage.dwFlags      |= PSP_USEFUSIONCONTEXT;
    PropPage.hActCtx       = NULL;
#endif

    return CreatePropertySheetPage(&PropPage);

} // GetResourceSelectionPage


//
// CreatePropertySheetPage - callback function
//
UINT CALLBACK pResourcePickerPropPageCallback(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp
)
/*++

Routine Description:

    Callback to handle cleanup of the property sheet

Arguments:

   Standard PropSheetPageProc arguments.

Return Value:

   Standard PropSheetPageProc return.

--*/
{
    switch (uMsg) {
        //case PSPCB_ADDREF:
        //    break;

        case PSPCB_CREATE:
            break;

        case PSPCB_RELEASE:
            //
            // release the memory we've previously allocated, outside of the actual dialog
            //
            if (ppsp->lParam != 0) {
                LPDMPROP_DATA pdmData = (LPDMPROP_DATA)(ppsp->lParam);

                MyFree(pdmData);
            }
            break;
    }

    return TRUE;

}

//
// Main dialog proceedure
//


INT_PTR
CALLBACK
pResourcePickerDlgProc(
   HWND   hDlg,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   )

/*++

Routine Description:

    This routine provides the dialog box procedure for the main resource
    picker property page. MEMPHIS COMPATIBLE.

Arguments:

   Standard dialog box procedure arguments.

Return Value:

   Standard dialog box procedure return.

--*/

{
    LPDMPROP_DATA   lpdmpd = NULL;

    if (message == WM_INITDIALOG) {
        lpdmpd = (LPDMPROP_DATA)((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)lpdmpd);
    } else {
        lpdmpd = (LPDMPROP_DATA)GetWindowLongPtr(hDlg, DWLP_USER);
    }

    switch (message) {

        //
        // initialize
        //
        case WM_INITDIALOG: {

            HICON           hIcon = NULL;
            int             iIcon = 0, iIndex = 0;
            ULONG           ulSize;
            PDEVICE_INFO_SET pDeviceInfoSet;
            HMACHINE        hMachine;

            lpdmpd->himlResourceImages = NULL;
            lpdmpd->CurrentLC = 0;
            lpdmpd->CurrentLCType = 0;
            lpdmpd->MatchingLC = 0;
            lpdmpd->MatchingLCType = 0;
            lpdmpd->SelectedLC = 0;
            lpdmpd->SelectedLCType = 0;
            lpdmpd->hDlg = hDlg;
            lpdmpd->dwFlags = 0;

            hMachine = pGetMachine(lpdmpd);

            lpdmpd->dwFlags |= DMPROP_FLAG_CHANGESSAVED; // Nothing to save yet

            //
            // NOTE: On Windows95, since lc info is in memory, they first
            // call CM_Setup_DevNode with CM_SETUP_WRITE_LOG_CONFS flag so
            // that in-memory lc data is flushed to the registry at this
            // point.
            //

            //
            // Init the Resource's image list.
            //
            lpdmpd->himlResourceImages = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
                                                  GetSystemMetrics(SM_CYSMICON),
                                                  ILC_MASK, // | ILC_SHARED,
                                                  1,
                                                  1);
            //
            // add icons to image list
            //
            for (iIcon = IDI_RESOURCEFIRST;iIcon < IDI_RESOURCELAST;++iIcon) {
                //
                // resource icon
                //
                hIcon = LoadIcon(MyDllModuleHandle, MAKEINTRESOURCE(iIcon));
                iIndex = ImageList_AddIcon(lpdmpd->himlResourceImages, hIcon);
            }

            for (iIcon = IDI_RESOURCEOVERLAYFIRST;iIcon <= IDI_RESOURCEOVERLAYLAST;++iIcon) {
                //
                // overlay icon
                //
                hIcon = LoadIcon(MyDllModuleHandle, MAKEINTRESOURCE(iIcon));
                iIndex = ImageList_AddIcon(lpdmpd->himlResourceImages, hIcon);

                //
                // Tag this icon as an overlay icon (the first index is an
                // index into the image list (specifies the icon), the
                // second index is just an index to assign to each mask
                // (starting with 1).
                //
                ImageList_SetOverlayImage(lpdmpd->himlResourceImages,
                                          iIndex,
                                          iIcon-IDI_RESOURCEOVERLAYFIRST+1);
            }

            if(pInitDevResourceDlg(lpdmpd)) {
                lpdmpd->dwFlags &= ~DMPROP_FLAG_CHANGESSAVED; // need to save (prob because there was no config)
            }

            if (!(lpdmpd->dwFlags & DMPROP_FLAG_NO_RESOURCES)) {
                pShowConflicts(lpdmpd);
            }
            if (GuiSetupInProgress) {
                //
                // occasionally legacy devices cause resource-picker popup during setup
                // we do this here instead of create prop sheet, since I don't trust
                // people to cleanup on fail. At least here is less risky
                // clean this up in WM_DESTROY
                //
                lpdmpd->hDialogEvent = CreateEvent(NULL,TRUE,FALSE,SETUP_HAS_OPEN_DIALOG_EVENT);
                if (lpdmpd->hDialogEvent) {
                   SetEvent(lpdmpd->hDialogEvent);
                }
            } else {
                lpdmpd->hDialogEvent = NULL;
            }
            break;
        }


        //
        // cleanup
        //
        case WM_DESTROY: {

            HICON    hIcon;
            LOG_CONF LogConf;
            LONG     nItems, n;
            HWND     hList =  GetDlgItem(hDlg, IDC_DEVRES_SETTINGSLIST);
            int    Count, i;

            //
            // Clean up the ICON resource usage
            //
            if ((hIcon = (HICON)LOWORD(SendDlgItemMessage(hDlg,
                         IDC_DEVRES_ICON, STM_GETICON, 0, 0L)))) {
                DestroyIcon(hIcon);
            }

            //
            // free the LC handles that were saved in the combobox data
            //
            nItems = (LONG)SendDlgItemMessage(hDlg, IDC_DEVRES_LOGCONFIGLIST,
                                            CB_GETCOUNT, 0, 0L);

            for (n = 0; n < nItems ; n++) {
                LogConf = (LOG_CONF)SendDlgItemMessage(hDlg,
                                        IDC_DEVRES_LOGCONFIGLIST,
                                        CB_GETITEMDATA, n, 0L);
                CM_Free_Log_Conf_Handle(LogConf);
            }

            if (lpdmpd->CurrentLC != 0) {
                CM_Free_Log_Conf_Handle(lpdmpd->CurrentLC);
            }

            ListView_DeleteAllItems(hList); // this will destroy all data

            if (lpdmpd->himlResourceImages) {
                ImageList_Destroy(lpdmpd->himlResourceImages);
            }

            if (lpdmpd->hDialogEvent) {
                //
                // we were holding up setup, now let setup proceed
                //
                ResetEvent(lpdmpd->hDialogEvent);
                CloseHandle(lpdmpd->hDialogEvent);
                lpdmpd->hDialogEvent = NULL;
            }
            // MyFree(lpdmpd); - do this in pResourcePickerPropPageCallback instead
            break;
        }

        case WM_COMMAND:
            //
            // old-style controls
            //

            switch(LOWORD(wParam)) {
                case IDC_DEVRES_USESYSSETTINGS: {
                    //
                    // consider resource settings to have changed
                    //
                    lpdmpd->dwFlags &= ~DMPROP_FLAG_CHANGESSAVED;
                    PropSheet_Changed(GetParent(hDlg), hDlg);

                    if (IsDlgButtonChecked(hDlg, (int)wParam)) {
                        //
                        // Revert back to allocated display, if any
                        //
                        lpdmpd->dwFlags |= DMPROP_FLAG_USESYSSETTINGS;
                        pSelectLogConf(lpdmpd,(LOG_CONF)0,ALLOC_LOG_CONF,TRUE);
                    } else {
                        //
                        // Allow editing
                        //
                        lpdmpd->dwFlags &= ~DMPROP_FLAG_USESYSSETTINGS;
                    }
                    pShowUpdateEdit(lpdmpd);           // update controls

                    break;
                }

                case IDC_DEVRES_LOGCONFIGLIST: {
                    //
                    // drop-down list action
                    //
                    switch (HIWORD(wParam)) {
                        case CBN_SELENDOK: {
                            ULONG    ulIndex = 0;
                            int      iItem;
                            LOG_CONF SelLC;
                            HWND     hwndLC = GetDlgItem(hDlg, IDC_DEVRES_LOGCONFIGLIST);

                            //
                            // If there is not a Log Config selected, then bail
                            //
                            iItem = (int)SendMessage(hwndLC, CB_GETCURSEL, 0, 0);
                            if(iItem != CB_ERR) {
                                SelLC = (LOG_CONF)SendMessage(hwndLC,CB_GETITEMDATA, (WPARAM)iItem,(LPARAM)0);
                            } else {
                                SelLC = (LOG_CONF)0;
                            }
                            if(SelLC != lpdmpd->SelectedLC) {
                                pSelectLogConf(lpdmpd,SelLC,lpdmpd->ConfigListLCType,FALSE);
                            }
                            //
                            // I prob don't need this here, but I'm playing safe!
                            //
                            lpdmpd->dwFlags &= ~DMPROP_FLAG_CHANGESSAVED;
                            break;
                        }
                    }
                    break;
                }

                case IDC_DEVRES_CHANGE: {
                    //
                    // change selected setting
                    //
                    pChangeCurrentResSetting(lpdmpd);
                    break;
                }

                case IDC_DEVRES_MAKEFORCED: {
                    //
                    // possibly allow editing (after we've shown message)
                    // when we get here, always show a configuration
                    //

                    if(lpdmpd->dwFlags & DMPROP_FLAG_FORCEDONLY) {
                        lpdmpd->dwFlags &= ~DMPROP_FLAG_CHANGESSAVED; // need to save
                    }
                    pShowViewAllEdit(lpdmpd);
                    //
                    // select in the first available config to edit
                    //
                    pSelectLogConf(lpdmpd,(LOG_CONF)0,ALLOC_LOG_CONF,TRUE);

                    //
                    // ensure we have reasonable focus for accessability
                    //
                    PostMessage(hDlg,WM_USER_FOCUS,IDC_DEVRES_SETTINGSLIST,0);
                    break;
                }

                default:
                    break;
            }
            break;

        case WM_USER_FOCUS:
            //
            // change focus to DlgItem wParam
            //
            SetFocus(GetDlgItem(hDlg,(int)wParam));
            return TRUE;

        case WM_NOTIFY: {
            //
            // new controls & property codes
            //
            NMHDR * pHdr = (NMHDR*)lParam;

            switch (pHdr->code) {

                case PSN_SETACTIVE: {

                    HICON           hIcon = NULL, hOldIcon = NULL;
                    TCHAR           szString[MAX_PATH];
                    ULONG           ulSize = 0;
                    HMACHINE        hMachine;

                    hMachine = pGetMachine(lpdmpd);


                    //
                    // Set the ICON and device description
                    //
                    if (SetupDiLoadClassIcon(&lpdmpd->lpdi->ClassGuid, &hIcon, NULL)) {

                        if ((hOldIcon = (HICON)LOWORD(SendDlgItemMessage(hDlg, IDC_DEVRES_ICON,
                                                                         STM_SETICON,
                                                                         (WPARAM)hIcon, 0L)))) {
                            DestroyIcon(hOldIcon);
                        }
                    }

                    //
                    // First try to get the device's friendly name, then fall back to its description,
                    // and finally, use the "Unknown Device" description.
                    //
                    ulSize = MAX_PATH * sizeof(TCHAR);
                    if (CM_Get_DevInst_Registry_Property_Ex(lpdmpd->lpdi->DevInst,
                                                         CM_DRP_FRIENDLYNAME,
                                                         NULL, (LPBYTE)szString,
                                                         &ulSize, 0,hMachine) != CR_SUCCESS) {

                        ulSize = MAX_PATH * sizeof(TCHAR);
                        if (CM_Get_DevInst_Registry_Property_Ex(lpdmpd->lpdi->DevInst,
                                                             CM_DRP_DEVICEDESC,
                                                             NULL, (LPBYTE)szString,
                                                             &ulSize, 0,hMachine) != CR_SUCCESS) {

                            LoadString(MyDllModuleHandle, IDS_DEVNAME_UNK, szString, MAX_PATH);
                        }
                    }
                    SetDlgItemText(hDlg, IDC_DEVRES_DEVDESC, szString);
                    break;
                }

                case PSN_APPLY:  {
                    BOOL      bRet = FALSE;
                    //
                    // If there were Changes and they haven't been saved,
                    // then save them.
                    // consider some special cases as "haven't been saved"
                    //
                    if((lpdmpd->CurrentLC == 0) && (lpdmpd->dwFlags&DMPROP_FLAG_FIXEDCONFIG)) {
                        lpdmpd->dwFlags &= ~DMPROP_FLAG_CHANGESSAVED;
                    }

                    switch(pOkToSave(lpdmpd)) {
                        case IDNO:
                            //
                            // proceed without saving
                            //
                            bRet = TRUE;
                            break;
                        case IDCANCEL:
                            //
                            // don't proceed
                            //
                            bRet = FALSE;
                            break;
                        case IDYES:
                            //
                            // proceed and save
                            //
                            bRet = pSaveDevResSettings(lpdmpd);
                            #if 0
                            if (bRet) {
                                if ((lpdmpd->lpdi)->Flags &  DI_NEEDREBOOT) {
                                    PropSheet_RebootSystem(GetParent(hDlg));
                                } else if ((lpdmpd->lpdi)->Flags &  DI_NEEDRESTART) {
                                    PropSheet_RestartWindows(GetParent(hDlg));
                                }
                            #endif
                            if (bRet) {
                                //
                                // This page doesn't support roll-back, if we saved
                                // something then we're committed, disable the cancel
                                // botton.
                                //
                                PropSheet_CancelToClose(GetParent(hDlg));
                            }
                            break;
                        default:
                            MYASSERT(FALSE /* pOkToSave returned invalid value */);
                            bRet = FALSE;
                            break;
                    }

                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, bRet ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE);
                    return TRUE;
                }

                case LVN_DELETEALLITEMS:
                    if (pHdr->idFrom == IDC_DEVRES_SETTINGSLIST) {
                        return FALSE;   // we want LVN_DELETEITEM messages
                    }
                    break;

                case LVN_DELETEITEM: {
                    LPNMLISTVIEW pListView = (LPNMLISTVIEW)pHdr;
                    if (pHdr->idFrom == IDC_DEVRES_SETTINGSLIST) {
                        PITEMDATA   pItemData = (PITEMDATA)(LPVOID)(pListView->lParam);
                        //
                        // when an item is deleted, destroy associated data
                        //
                        if (pItemData->MatchingResDes) {
                            CM_Free_Res_Des_Handle(pItemData->MatchingResDes);
                        }
                        MyFree(pItemData);
                    }
                    break;
                }
                    EnableWindow(GetDlgItem(hDlg, IDC_DEVRES_CHANGE), FALSE);
                    break;

                case LVN_ITEMCHANGED:
                    //
                    // If the item change is comming from the resource
                    // list, and there is a logconfig to be edited:
                    //
                    if (pHdr->idFrom == IDC_DEVRES_SETTINGSLIST) {
                        //
                        // see if we should enable resource change
                        //
                        pCheckEnableResourceChange(lpdmpd);
                    }
                    break;

                case NM_DBLCLK:
                    //
                    // If the double click is from the SETTINGS list
                    // AND the DEVRES_CHANGE button is enabled, then
                    // allow the change.
                    //
                    if (pHdr->idFrom == IDC_DEVRES_SETTINGSLIST) {
                        //
                        // this routine should check that we can change settings
                        //
                        pChangeCurrentResSetting(lpdmpd);
                    }
                    break;
            }
            break;
        }

        case WM_SYSCOLORCHANGE: {

            HWND hChildWnd = GetWindow(hDlg, GW_CHILD);

            while (hChildWnd != NULL) {
                SendMessage(hChildWnd, WM_SYSCOLORCHANGE, wParam, lParam);
                hChildWnd = GetWindow(hChildWnd, GW_HWNDNEXT);
            }
            break;
        }

        case WM_HELP:      // F1
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, DEVRES_HELP, HELP_WM_HELP, (ULONG_PTR)DevResHelpIDs);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND)wParam, DEVRES_HELP, HELP_CONTEXTMENU, (ULONG_PTR)DevResHelpIDs);
            break;
   }

   return FALSE;

}

//
// Helper functions
//

HMACHINE
pGetMachine(
    LPDMPROP_DATA   lpdmpd
    )
/*++

Routine Description:

    Retrieve Machine Handle

Arguments:

    lpdmpd - Property Data

Return Value:

    handle

--*/
{
    HMACHINE hMachine;
    PDEVICE_INFO_SET pDeviceInfoSet;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdmpd->hDevInfo))) {
        return NULL;
    }
    hMachine = pDeviceInfoSet->hMachine;
    UnlockDeviceInfoSet(pDeviceInfoSet);
    return hMachine;
}

BOOL
pInitDevResourceDlg(
    LPDMPROP_DATA   lpdmpd
    )
/*++

Routine Description:

    This routine intializes the main resource picker property page.
    MEMPHIS COMPATIBLE.

Arguments:


Return Value:

    TRUE if "not saved"

--*/

{
    HWND            hDlg = lpdmpd->hDlg;
    CONFIGRET       Status = CR_SUCCESS;
    BOOL            bHasCurrent = FALSE;
    BOOL            bShowCurrent = FALSE;
    BOOL            bHasForced = FALSE;
    BOOL            bNoForcedConfig = FALSE;
    BOOL            bNeedsForcedConfig = FALSE;
    BOOL            bHasConfigList = FALSE;
    LV_COLUMN       LvCol;
    HWND            hWndList = NULL;
    TCHAR           szString[MAX_PATH], szTemp[MAX_PATH], szConfigType[MAX_PATH],
                    szConfig[MAX_PATH];
    ULONG           ulIndex = 0, ulSize = 0, DevStatus = 0, DevProblem = 0;
    DWORD           BusType = (DWORD)(-1);
    LOG_CONF        LogConf;
    DWORD           dwPriority = 0;
    WORD            wItem;
    ULONG           ConfigFlags;
    HMACHINE        hMachine = NULL;
    PDEVICE_INFO_SET pDeviceInfoSet;
    int             iIndex;
    BOOL            bHasPrivs = FALSE;
    //
    // Set initial control states
    //
    pHideAllControls(lpdmpd);

    //
    // determine priv token
    // security checks are visual only
    // real security checks are done in umpnpmgr
    //

    bHasPrivs = pSetupDoesUserHavePrivilege(SE_LOAD_DRIVER_NAME);

    hMachine = pGetMachine(lpdmpd);

    //
    // retrieves current configuration, if any
    //
    bHasCurrent = pGetCurrentConfig(lpdmpd);

    //
    // We sometimes get called to show this page even if the device
    // doesn't consume any resources. Check for that case and if so, just
    // display an informational message and disable everything else.
    //

    if (!pDevRequiresResources(lpdmpd->lpdi->DevInst,hMachine)) {

        //
        // This device has no resources
        //
        pShowViewNoResources(lpdmpd);
        lpdmpd->dwFlags |= DMPROP_FLAG_NO_RESOURCES;
        goto Final;
    }

    //
    // Initialize the ListView control
    //
    hWndList = GetDlgItem(hDlg, IDC_DEVRES_SETTINGSLIST);
    LvCol.mask = LVCF_TEXT;

    if (LoadString(MyDllModuleHandle, IDS_RESOURCETYPE, szString, MAX_PATH)) {
        LvCol.pszText = (LPTSTR)szString;
        ListView_InsertColumn(hWndList, 0, (LV_COLUMN FAR *)&LvCol);
    }

    if (LoadString(MyDllModuleHandle, IDS_RESOURCESETTING, szString, MAX_PATH)) {
        LvCol.pszText = (LPTSTR)szString;
        ListView_InsertColumn(hWndList, 1, (LV_COLUMN FAR *)&LvCol);
    }

    ListView_SetImageList(hWndList,lpdmpd->himlResourceImages, LVSIL_SMALL);
    //
    // Get DevStatus & DevProblem here, we may use this info further down
    //
    if (CM_Get_DevNode_Status_Ex(&DevStatus, &DevProblem, lpdmpd->lpdi->DevInst,
                              0,hMachine) != CR_SUCCESS) {
        //
        // we should never get here, show this as a problem
        //
        lpdmpd->dwFlags |= DMPROP_FLAG_HASPROBLEM;
    } else if (DevStatus & DN_HAS_PROBLEM) {
        //
        // cache problem flag away
        //
        lpdmpd->dwFlags |= DMPROP_FLAG_HASPROBLEM;
    } else if (DevStatus & DN_PRIVATE_PROBLEM) {
        //
        // driver indicates problem
        // for now, do same as above
        //
        lpdmpd->dwFlags |= DMPROP_FLAG_HASPROBLEM;
    }

    if (bIsMultiFunctionChild(lpdmpd->lpdi,hMachine)) {
        //
        // If this is a MultiFunction Child, disable all change controls, put up
        // special text, and show the alloc config
        //
        pShowViewMFReadOnly(lpdmpd,FALSE);
        goto Final;
    }

    //
    // begin with read-only view, assuming settings are system
    //
    lpdmpd->dwFlags |= DMPROP_FLAG_USESYSSETTINGS;

    if (CM_Get_First_Log_Conf_Ex(NULL,
                                    lpdmpd->lpdi->DevInst,
                                    FORCED_LOG_CONF,
                                    hMachine) == CR_SUCCESS) {
        //
        // the user currently has a forced config
        //
        lpdmpd->dwFlags &= ~DMPROP_FLAG_USESYSSETTINGS;
        bHasForced = TRUE;
    }

    bShowCurrent = pShowViewReadOnly(lpdmpd,bHasPrivs);
    if (!bHasPrivs || hMachine) {
        //
        // if we don't have enough priv's
        // or we're displaying resources of a remote machine
        // bottle out here
        // we'll either be displaying current resources
        // or displaying a problem
        //
        goto Final;
    }
    if(!bHasForced) {
        //
        // Check bus we're using
        // to see if it's one of the read-only displays
        //
        ulSize = sizeof(BusType);
        if (CM_Get_DevInst_Registry_Property_Ex(lpdmpd->lpdi->DevInst,
                                             CM_DRP_LEGACYBUSTYPE,
                                             NULL, (LPBYTE)&BusType,
                                             &ulSize, 0,hMachine) != CR_SUCCESS) {
            BusType = (DWORD)InterfaceTypeUndefined;
        }

        if (BusType != (DWORD)InterfaceTypeUndefined) {
            int InterfaceItem;

            for(InterfaceItem = 0; ResourcePickerReadOnlyInterfaces[InterfaceItem] != InterfaceTypeUndefined; InterfaceItem++) {
                if (BusType == (DWORD)ResourcePickerReadOnlyInterfaces[InterfaceItem]) {
                    //
                    // Bus is one that we do not allow forced configs
                    // we can skip all the funky code below
                    //
                    // this is a good thing for 64-bit PCI
                    //
                    goto Final;
                }
            }
        }
    }

    //
    // Retrieve alternate configurations for this device
    //
    if (bHasCurrent) {
        //
        // Current config (if any) is indicated with zero handle
        //
        LoadString(MyDllModuleHandle, IDS_CURRENTCONFIG, szString, MAX_PATH);

        iIndex = (int)SendDlgItemMessage(hDlg, IDC_DEVRES_LOGCONFIGLIST,
                                         CB_ADDSTRING, (WPARAM)0, (LPARAM)(LPSTR)szString);
        SendDlgItemMessage(hDlg, IDC_DEVRES_LOGCONFIGLIST, CB_SETITEMDATA,(WPARAM)iIndex, (LPARAM)0);
        SendDlgItemMessage(hDlg, IDC_DEVRES_LOGCONFIGLIST, CB_SETCURSEL,(WPARAM)0, (LPARAM)0);
    }
    //
    // now fill in alternate configurations
    // override preferred over basic (in that order)
    // don't use Filtered, filtered might remove configs that require reboot
    // but they are fine to have here
    //
    if(CM_Get_First_Log_Conf_Ex(&LogConf,lpdmpd->lpdi->DevInst,OVERRIDE_LOG_CONF,hMachine) == CR_SUCCESS) {
        lpdmpd->ConfigListLCType = OVERRIDE_LOG_CONF;
        LoadString(MyDllModuleHandle, IDS_OVERRIDECONFIG, szConfigType, MAX_PATH);
        bHasConfigList = TRUE;
    } else if(CM_Get_First_Log_Conf_Ex(&LogConf,lpdmpd->lpdi->DevInst,BASIC_LOG_CONF,hMachine) == CR_SUCCESS) {
        lpdmpd->ConfigListLCType = BASIC_LOG_CONF;
        LoadString(MyDllModuleHandle, IDS_BASICCONFIG, szConfigType, MAX_PATH);
        bHasConfigList = TRUE;
    } else {
        //
        // If there are no alternate configs, we cannot allow a forced config
        //
        bNoForcedConfig = TRUE; // cannot force
        bHasConfigList = FALSE;
        lpdmpd->ConfigListLCType = BASIC_LOG_CONF;
        lpdmpd->dwFlags |= DMPROP_FLAG_SINGLE_CONFIG;
    }
    if(bHasConfigList) {

        ulIndex = 0;
        if (!pConfigHasNoAlternates(lpdmpd,LogConf)) {
            //
            // first configuration has more than one alternative
            //
            lpdmpd->dwFlags &= ~DMPROP_FLAG_SINGLE_CONFIG;
        } else {
            //
            // begin with the assumption there is a single fixed 'basic' config
            // we will generally be proved wrong
            //
            lpdmpd->dwFlags |= DMPROP_FLAG_SINGLE_CONFIG;
        }

        while (Status == CR_SUCCESS) {
            //
            // Add this config to the Combobox
            //
            wsprintf(szTemp, TEXT("%s %04u"), szConfigType, ulIndex);

            wItem = (WORD)SendDlgItemMessage(hDlg, IDC_DEVRES_LOGCONFIGLIST,
                                             CB_ADDSTRING, 0,
                                             (LPARAM)(LPSTR)szTemp);

            //
            // Save the log config handle as the item data in the combobox
            //
            SendDlgItemMessage(hDlg, IDC_DEVRES_LOGCONFIGLIST, CB_SETITEMDATA,
                               wItem, (LPARAM)LogConf);

            //
            // Get the next config
            //
            Status = CM_Get_Next_Log_Conf_Ex(&LogConf, LogConf, 0,hMachine);
            ulIndex++;
        }

        if (ulIndex > 1) {
            //
            // there is more than one config
            //
            lpdmpd->dwFlags &= ~DMPROP_FLAG_SINGLE_CONFIG;
        }

        if (lpdmpd->dwFlags & DMPROP_FLAG_SINGLE_CONFIG) {
            bNoForcedConfig = TRUE;
        }

        if (bHasCurrent) {
            //
            // try to find a matching LC now, and if we could find one,
            // re-load current display (this applies editable ranges to the resources)
            //
            if(pFindMatchingAllocConfig(lpdmpd)) {
                pLoadCurrentConfig(lpdmpd,TRUE);
            }
        }
    } else {
    }
    //
    // Get ConfigFlags here, we may use this info further down
    //
    ulSize = sizeof(ConfigFlags);
    if (CM_Get_DevInst_Registry_Property_Ex(lpdmpd->lpdi->DevInst,
                                         CM_DRP_CONFIGFLAGS,
                                         NULL, (LPBYTE)&ConfigFlags,
                                         &ulSize, 0,hMachine) != CR_SUCCESS) {
        ConfigFlags = 0;
    }
    if (ConfigFlags & CONFIGFLAG_NEEDS_FORCED_CONFIG) {
        //
        // registry says that we need a forced config
        // registry can only say this to us once
        //
        bNeedsForcedConfig = TRUE;
        ConfigFlags &= ~CONFIGFLAG_NEEDS_FORCED_CONFIG;
        CM_Set_DevInst_Registry_Property_Ex(lpdmpd->lpdi->DevInst,
                                         CM_DRP_CONFIGFLAGS,
                                         (LPBYTE)&ConfigFlags,
                                         sizeof(ConfigFlags),
                                         0,
                                         hMachine);
    }

    //
    // determine if it can be software-config'd or not
    // we need to do this prior to any initial display
    //
    dwPriority = pGetMinLCPriority(lpdmpd->lpdi->DevInst, lpdmpd->ConfigListLCType,hMachine);
    if (dwPriority < LCPRI_HARDRECONFIG) {
        //
        // doesn't need to be manually configured
        //
        lpdmpd->dwFlags &= ~DMPROP_FLAG_FORCEDONLY;
    } else {
        //
        // this cannot be software config'd
        // FORCEDONLY & bNoForcedConfig is a quandry, shouldn't happen
        //
        lpdmpd->dwFlags |= DMPROP_FLAG_FORCEDONLY;
        if(!bHasConfigList) {
            MYASSERT(bHasConfigList);
        } else {
            MYASSERT(!bNoForcedConfig);
            bNoForcedConfig = FALSE;
        }
    }

    //
    // Try to determine initial display
    //
    // we've already covered pShowViewNoResources (no actual or potential configs)
    // and pShowViewMFReadOnly (it's a multi-function device)
    //
    // we're currently showing as pShowViewReadOnly
    //
    // some cases....
    // (1) show forced config, don't allow auto-config (config flags say requires forced)
    // (2) show forced config, allow auto-config
    // (3) don't show any config, but maybe show a forced-config button
    // (4) auto-config, don't allow forced config
    // (5) show auto-config, allow forced-config
    //
    if (bNeedsForcedConfig) {
        if (!bHasConfigList) {
            MYASSERT(bHasConfigList);
            bNeedsForcedConfig = FALSE;
        } else {
            MYASSERT(!bNoForcedConfig);
            bNoForcedConfig = FALSE;
            if (bHasForced) {
                //
                // already got one, but we'll go through the motions
                // we'll show what we have, allow user to change it
                // but we wont needlessly save it
                //
                bNeedsForcedConfig = FALSE;
            }
            //
            // caller said that device must have forced config, so go immediately there
            // = case (1) unless we've otherwise said we cannot have a forced config
            //
            lpdmpd->dwFlags |= DMPROP_FLAG_FORCEDONLY;
            pSelectLogConf(lpdmpd,(LOG_CONF)0,ALLOC_LOG_CONF,TRUE);
            pShowViewAllEdit(lpdmpd);
            goto Final;
        }
    }
    if ((!bShowCurrent) || (lpdmpd->dwFlags & DMPROP_FLAG_HASPROBLEM)) {
        //
        //  determine between pShowViewNoAlloc and pShowViewNeedForced
        //
        if (bNoForcedConfig) {
            //
            // there is a problem - device doesn't currently have a current configuration
            // but we don't have the option of letting them set forced config
            // so this ends up display only (tough-luck scenario)
            // if there are current resources, show them
            //
            pShowViewReadOnly(lpdmpd,FALSE);
        } else {
            //
            // we show the problem and we give the user
            // an option to force config
            //
            pShowViewNeedForced(lpdmpd);
        }
        goto Final;
    }
    if (!bHasConfigList) {
        //
        // If we have a current config, but no basic configs, we just display what we have
        // and don't give option to edit
        //
        pShowViewReadOnly(lpdmpd,FALSE);
        goto Final;
    }
    if ((lpdmpd->dwFlags & DMPROP_FLAG_USESYSSETTINGS) && bNoForcedConfig) {
        //
        // we can't force a bNoForcedConfig item - display only
        //
        pShowViewReadOnly(lpdmpd,FALSE);
        goto Final;
    }
    //
    // we already have and will be displaying a current config
    //
    pShowViewAllEdit(lpdmpd);
    bNeedsForcedConfig = (BOOL)!bHasCurrent; // rarely, if ever, will this return TRUE

  Final:

    return bNeedsForcedConfig;

} // InitDevResourceDlg

PITEMDATA
pGetResourceToChange(
    IN  LPDMPROP_DATA   lpdmpd,
    OUT int             *pCur
    )
/*++

Routine Description:

    Gets resource to change
    NULL if we cannot change resource

Arguments:

    lpdmpd = dialog data
    pCur = (out) index

Return Value:

    PITEMDATA saved for selected resource

--*/
{
    HWND     hList =  GetDlgItem(lpdmpd->hDlg, IDC_DEVRES_SETTINGSLIST);
    PITEMDATA pItemData = NULL;
    int     iCur;

    //
    // first check the obvious
    //
    if (lpdmpd->dwFlags & DMPROP_FLAG_VIEWONLYRES) {
        //
        // no editing allowed
        //
        return NULL;
    }
    if (lpdmpd->dwFlags & DMPROP_FLAG_USESYSSETTINGS) {
        //
        // showing system settings
        //
        return NULL;
    }


    //
    // Check if there is a selected item.
    // If yes, then activate the change button
    // if the LC allows editing.
    //
    iCur = (int)ListView_GetNextItem(hList,-1, LVNI_SELECTED);
    if (iCur == LB_ERR) {
        //
        // no selection
        //
        return NULL;
    }
    pItemData = (PITEMDATA)pGetListViewItemData(hList, iCur, 0);
    if (pItemData == NULL) {
        //
        // shouldn't happen
        //
        MYASSERT(pItemData);
        return NULL;
    }
    if (pItemData->bFixed) {
        //
        // this is an un-editable setting
        //
        return NULL;
    }
    if (pItemData->MatchingResDes == (RES_DES)0) {
        //
        // should be caught by bFixed
        //
        MYASSERT(pItemData->MatchingResDes != (RES_DES)0);
        return NULL;
    }
    //
    // we're happy
    //
    if (pCur) {
        *pCur = iCur;
    }
    return pItemData;
}

VOID
pCheckEnableResourceChange(
    LPDMPROP_DATA   lpdmpd
    )
/*++

Routine Description:

    enables/disable change button

Arguments:


Return Value:

    none

--*/
{
#if 0 // this seems to confuse people
    EnableWindow(GetDlgItem(lpdmpd->hDlg, IDC_DEVRES_CHANGE),
                    pGetResourceToChange(lpdmpd,NULL)!=NULL);
#endif // 0

    //
    // show this button enabled if we are in EDIT mode
    //
    EnableWindow(GetDlgItem(lpdmpd->hDlg, IDC_DEVRES_CHANGE),
                 (lpdmpd->dwFlags & DMPROP_FLAG_VIEWONLYRES)==0 &&
                 (lpdmpd->dwFlags & DMPROP_FLAG_USESYSSETTINGS)==0);
}

BOOL
pDevHasConfig(
    DEVINST     DevInst,
    ULONG       ulConfigType,
    HMACHINE    hMachine
    )

/*++

Routine Description:

    This routine determines whether a log config of the specified type
    exists for this device instance.
    MEMPHIS COMPATIBLE.

Arguments:

    DevInst         Device instance to query log configs for.

    ulConfigType    Specifies the type of log conf to check for the presense of.

Return Value:

   TRUE if the device has a config of that type and FALSE if it does not.

--*/

{
    BOOL bRet = (CM_Get_First_Log_Conf_Ex(NULL, DevInst, ulConfigType,hMachine) == CR_SUCCESS);
    return bRet;

} // DevHasConfig

DWORD
pGetMinLCPriority(
    IN DEVINST DevInst,
    IN ULONG   ulConfigType,
    IN HMACHINE hMachine
    )

/*++

Routine Description:

    This routine returns the minimum priority value of all log confs of the
    specified type for this device. MEMPHIS COMPATIBLE.

Arguments:

    DevInst         Device instance to query log configs for.

    ulConfigType    Specifies the type of log conf.

Return Value:

   Returns the minimum priority value found or LCPRI_LASTSOFTCONFIG if no priorities
   are found.

--*/

{
    CONFIGRET Status = CR_SUCCESS;
    ULONG priority, minPriority = MAX_LCPRI;
    LOG_CONF LogConf, tempLC;
    BOOL FoundOneLogConfWithPriority = FALSE;

    //
    // Walk through each log conf of this type for this device and
    // save the smallest value.
    //

    Status = CM_Get_First_Log_Conf_Ex(&LogConf, DevInst, ulConfigType,hMachine);
    while (Status == CR_SUCCESS) {

        if (CM_Get_Log_Conf_Priority_Ex(LogConf, &priority, 0,hMachine) == CR_SUCCESS) {
            FoundOneLogConfWithPriority = TRUE;
            minPriority = min(minPriority, priority);
        }

        tempLC = LogConf;
        Status = CM_Get_Next_Log_Conf_Ex(&LogConf, LogConf, 0,hMachine);
        CM_Free_Log_Conf_Handle(tempLC);
    }

    if(FoundOneLogConfWithPriority) {
        return minPriority;
    } else {
        //
        // None of the LogConfigs had an associated priority. This is common on
        // NT, because the bus drivers don't specify ConfigMgr-style priorities
        // when responding to IRQ_MN_QUERY_RESOURCE_REQUIREMENTS.  Since these
        // cases are all PnP bus drivers, however, it is most correct to specify
        // these LogConfigs as soft-settable.
        //
        return LCPRI_LASTSOFTCONFIG;
    }

} // GetMinLCPriority

BOOL
pDevRequiresResources(
    DEVINST DevInst,
    HMACHINE hMachine
    )
{
    if (CM_Get_First_Log_Conf_Ex(NULL, DevInst, BASIC_LOG_CONF,hMachine) == CR_SUCCESS) {
        return TRUE;
    }

    if (CM_Get_First_Log_Conf_Ex(NULL, DevInst, FILTERED_LOG_CONF,hMachine) == CR_SUCCESS) {
        return TRUE;
    }

    if (CM_Get_First_Log_Conf_Ex(NULL, DevInst, OVERRIDE_LOG_CONF,hMachine) == CR_SUCCESS) {
        return TRUE;
    }

    if (CM_Get_First_Log_Conf_Ex(NULL, DevInst, FORCED_LOG_CONF,hMachine) == CR_SUCCESS) {
        return TRUE;
    }

    if (CM_Get_First_Log_Conf_Ex(NULL, DevInst, BOOT_LOG_CONF,hMachine) == CR_SUCCESS) {
        return TRUE;
    }

    if (CM_Get_First_Log_Conf_Ex(NULL, DevInst, ALLOC_LOG_CONF,hMachine) == CR_SUCCESS) {
        return TRUE;
    }

    return FALSE;

} // DevRequiresResources

BOOL
pGetCurrentConfig(
    IN OUT  LPDMPROP_DATA lpdmpd
    )

/*++

Routine Description:

    This routine determines the current known configuration
    current configs are either forced, alloc or boot configs.

Arguments:

    lpdmpd          Property data.

Return Value:

   TRUE if we set the current config

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet;
    HMACHINE         hMachine;
    ULONG            Status;
    ULONG            Problem;

    MYASSERT(lpdmpd!=NULL);
    MYASSERT(lpdmpd->lpdi!=NULL);
    MYASSERT(lpdmpd->CurrentLC==0);
    MYASSERT(lpdmpd->lpdi->DevInst!=0);

    if (lpdmpd==NULL ||
        lpdmpd->lpdi==NULL ||
        lpdmpd->lpdi->DevInst==0) {
        return FALSE;
    }

    lpdmpd->dwFlags &= ~DMPROP_FLAG_DISPLAY_MASK;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdmpd->hDevInfo))) {
            return FALSE;
    }

    hMachine = pDeviceInfoSet->hMachine;

    UnlockDeviceInfoSet (pDeviceInfoSet);

    if (CM_Get_DevNode_Status_Ex(&Status, &Problem, lpdmpd->lpdi->DevInst,
                              0,hMachine) != CR_SUCCESS) {
        Problem = 0;
        Status = 0;
    } else if((Status & DN_HAS_PROBLEM)==0) {
        //
        // If this device is running, does this devinst have a ALLOC log config?
        //
        if (CM_Get_First_Log_Conf_Ex(&lpdmpd->CurrentLC,
                                     lpdmpd->lpdi->DevInst,
                                     ALLOC_LOG_CONF,
                                     hMachine) == CR_SUCCESS) {

            lpdmpd->dwFlags |= DMPROP_FLAG_DISPLAY_ALLOC;
            lpdmpd->CurrentLCType = ALLOC_LOG_CONF;
            return TRUE;
        }
    }
    //
    // If no config so far, does it have a FORCED log config?
    //

    if (CM_Get_First_Log_Conf_Ex(&lpdmpd->CurrentLC,
                                    lpdmpd->lpdi->DevInst,
                                    FORCED_LOG_CONF,
                                    hMachine) == CR_SUCCESS) {

        lpdmpd->dwFlags |= DMPROP_FLAG_DISPLAY_FORCED;
        lpdmpd->CurrentLCType = FORCED_LOG_CONF;
        return TRUE;
    }

    //
    // if there's a hardware-disabled problem, boot-config isn't valid
    //
    if(((Status & DN_HAS_PROBLEM)==0) || (Problem != CM_PROB_HARDWARE_DISABLED)) {
        //
        // Does it have a BOOT log config?
        //
        if (CM_Get_First_Log_Conf_Ex(&lpdmpd->CurrentLC,
                                        lpdmpd->lpdi->DevInst,
                                        BOOT_LOG_CONF,
                                        hMachine) == CR_SUCCESS) {

            lpdmpd->dwFlags |= DMPROP_FLAG_DISPLAY_BOOT;
            lpdmpd->CurrentLCType = BOOT_LOG_CONF;
            return TRUE;
        }
    }

    return FALSE;
}

void
pGetHdrValues(
    IN  LPBYTE      pData,
    IN  RESOURCEID  ResType,
    OUT PULONG64    pulValue,
    OUT PULONG64    pulLen,
    OUT PULONG64    pulEnd,
    OUT PULONG      pulFlags
    )
{
    switch (ResType) {

        case ResType_Mem: {

            PMEM_RESOURCE  pMemData = (PMEM_RESOURCE)pData;

            *pulValue = pMemData->MEM_Header.MD_Alloc_Base;
            *pulLen   = (pMemData->MEM_Header.MD_Alloc_End -
                        pMemData->MEM_Header.MD_Alloc_Base + 1);
            *pulEnd   = pMemData->MEM_Header.MD_Alloc_End;
            *pulFlags = pMemData->MEM_Header.MD_Flags;
            break;
        }

        case ResType_IO: {

            PIO_RESOURCE   pIoData = (PIO_RESOURCE)pData;

            *pulValue = pIoData->IO_Header.IOD_Alloc_Base;
            *pulLen   = (pIoData->IO_Header.IOD_Alloc_End -
                        pIoData->IO_Header.IOD_Alloc_Base + 1);
            *pulEnd   = pIoData->IO_Header.IOD_Alloc_End;
            *pulFlags = pIoData->IO_Header.IOD_DesFlags;
            break;
        }

        case ResType_DMA: {

            PDMA_RESOURCE  pDmaData = (PDMA_RESOURCE)pData;

            *pulValue = pDmaData->DMA_Header.DD_Alloc_Chan;
            *pulLen   = 1;
            *pulEnd   = *pulValue;
            *pulFlags = pDmaData->DMA_Header.DD_Flags;
            break;
        }

        case ResType_IRQ: {

            DEVRES_PIRQ_RESOURCE  pIrqData = (DEVRES_PIRQ_RESOURCE)pData;

            *pulValue = pIrqData->IRQ_Header.IRQD_Alloc_Num;
            *pulLen   = 1;
            *pulEnd   = *pulValue;
            *pulFlags = pIrqData->IRQ_Header.IRQD_Flags;
            break;
        }
    }

    if(*pulEnd < *pulValue) {
        //
        // filter out bad/zero-length range
        //
        *pulLen = 0;
    }

    return;

} // GetHdrValues

void
pGetRangeValues(
    IN  LPBYTE      pData,
    IN  RESOURCEID  ResType,
    IN  ULONG       ulIndex,
    OUT PULONG64    pulValue, OPTIONAL
    OUT PULONG64    pulLen, OPTIONAL
    OUT PULONG64    pulEnd, OPTIONAL
    OUT PULONG64    pulAlign, OPTIONAL
    OUT PULONG      pulFlags OPTIONAL
    )
{
    //
    // keep local copies
    // we transfer to parameters at end
    //
    ULONG64 ulValue;
    ULONG64 ulLen;
    ULONG64 ulEnd;
    ULONG64 ulAlign;
    ULONG ulFlags;

    switch (ResType) {

        case ResType_Mem: {

            PMEM_RESOURCE  pMemData = (PMEM_RESOURCE)pData;

            ulValue = pMemData->MEM_Data[ulIndex].MR_Min;
            ulLen   = pMemData->MEM_Data[ulIndex].MR_nBytes;
            ulEnd   = pMemData->MEM_Data[ulIndex].MR_Max;
            ulFlags = pMemData->MEM_Data[ulIndex].MR_Flags;
            ulAlign = pMemData->MEM_Data[ulIndex].MR_Align;
            break;
        }

        case ResType_IO:  {

            PIO_RESOURCE   pIoData = (PIO_RESOURCE)pData;

            ulValue = pIoData->IO_Data[ulIndex].IOR_Min;
            ulLen   = pIoData->IO_Data[ulIndex].IOR_nPorts;
            ulEnd   = pIoData->IO_Data[ulIndex].IOR_Max;
            ulFlags = pIoData->IO_Data[ulIndex].IOR_RangeFlags;
            ulAlign = pIoData->IO_Data[ulIndex].IOR_Align;
            break;
        }

        case ResType_DMA: {

            PDMA_RESOURCE  pDmaData = (PDMA_RESOURCE)pData;

            ulValue = pDmaData->DMA_Data[ulIndex].DR_Min;
            ulLen   = 1;
            ulEnd   = ulValue;
            ulFlags = pDmaData->DMA_Data[ulIndex].DR_Flags;
            ulAlign = 1;
            break;
        }

        case ResType_IRQ: {

            DEVRES_PIRQ_RESOURCE  pIrqData = (DEVRES_PIRQ_RESOURCE)pData;

            ulValue = pIrqData->IRQ_Data[ulIndex].IRQR_Min;
            ulLen   = 1;
            ulEnd   = ulValue;
            ulFlags = pIrqData->IRQ_Data[ulIndex].IRQR_Flags;
            ulAlign = 1;
            break;
        }
    }

    if(ulEnd < ulValue) {
        //
        // filter out bad/zero-length range
        //
        ulLen = 0;
    }

    pAlignValues(&ulValue, ulValue, ulLen, ulEnd, ulAlign,1);

    //
    // copy return parameters
    //
    if (pulValue) {
        *pulValue = ulValue;
    }
    if (pulLen) {
        *pulLen = ulLen;
    }
    if (pulEnd) {
        *pulEnd = ulEnd;
    }
    if (pulAlign) {
        *pulAlign = ulAlign;
    }
    if (pulFlags) {
        *pulFlags = ulFlags;
    }


    return;

}

BOOL
pAlignValues(
    IN OUT PULONG64  pulValue,
    IN     ULONG64   ulStart,
    IN     ULONG64   ulLen,
    IN     ULONG64   ulEnd,
    IN     ULONG64   ulAlignment,
    IN     int       Increment
    )
{
    ULONG64 NtAlign = ~ulAlignment + 1;   // convert from mask to modulus
    ULONG64 Value;
    ULONG64 Upp;
    ULONG64 Remainder;

    Value = *pulValue;

    if (NtAlign == 0) {
        return FALSE;   // bogus alignment value
    }

    if (NtAlign != 1 && Increment != 0) {
        //
        // see if we are aligned
        //

        Remainder = Value % NtAlign;

        if (Remainder != 0) {
            //
            // need to re-align
            //
            if (Increment>0) {
                //
                // Return the first valid aligned value greater than this value
                //
                Value += NtAlign - Remainder;

                if (Value <= *pulValue) {
                    //
                    // overflow detected
                    //
                    return FALSE;
                }

            } else {
                //
                // Return the first valid aligned value less than this value
                //
                Value -= Remainder;
                //
                // we never overflow going down, since zero is a common denominator
                // of alignment
                //
            }

        }
    }

    //
    // now check boundaries
    //

    if (Value < ulStart) {
        return FALSE;
    }

    Upp = Value+ulLen-1;
    if (Upp < Value) {
        //
        // catch overflow error
        //
        return FALSE;
    }
    if (Upp > ulEnd) {
        return FALSE;
    }

    //
    // set newly aligned value
    //

    *pulValue = Value;

    return TRUE;

}

void
pFormatResString(
    LPDMPROP_DATA lpdmpd,
    LPTSTR      lpszString,
    ULONG64     ulVal,
    ULONG64     ulLen,
    RESOURCEID  ResType
    )
{
    if (ulLen == 0) {
        wsprintf(lpszString, szNoValue);
    } else if ((ResType == ResType_DMA) || (ResType == ResType_IRQ)) {
        wsprintf(lpszString, szOneDecNoConflict, (UINT)ulVal);
    } else if (ResType == ResType_IO) {
        wsprintf(lpszString, szTwoWordHexNoConflict, (ULONG)ulVal,
                 (ULONG)(ulVal + ulLen - 1));
    } else if (lpdmpd && (lpdmpd->dwFlags & DMPROP_FLAG_64BIT_RANGE)) {
        wsprintf(lpszString, szTwo64bitHexNoConflict, (ULONG64)ulVal,
                 (ULONG64)(ulVal + ulLen - 1));
    } else {
        wsprintf(lpszString, szTwoDWordHexNoConflict, (ULONG)ulVal,
                 (ULONG)(ulVal + ulLen - 1));
    }

}

BOOL
pUnFormatResString(
    LPTSTR      lpszString,
    PULONG64    pulVal,
    PULONG64    pulEnd,
    RESOURCEID  ridResType
    )
{
    BOOL     bRet = FALSE;
    LPTSTR   lpszTemp = NULL;
    LPTSTR   lpszTemp2 = NULL;
    LPTSTR   lpszCopy;

    // ISSUE-2000/02/03 Fix pUnFormatResString bugs
    //
    // - extend this to handling DWORDLONG values
    // - use correct Prev/Next functions for parsing string
    //

    //
    // Allocate space for, and make a copy of the input string
    //
    lpszCopy = MyMalloc((lstrlen(lpszString)+1) * sizeof(TCHAR));

    if (lpszCopy == NULL) {
        return FALSE;
    }

    lstrcpy(lpszCopy, lpszString);

    //
    // Locate the dash if there is one, and convert the white space prev to
    // the dash to a NULL. (ie 0200 - 0400 while be 0200)
    //
    lpszTemp = lpszCopy;
    while ((*lpszTemp != '-') && (*lpszTemp != '\0')) {
        lpszTemp++; // AnsiNext?
    }

    if (*lpszTemp != '\0') {
        lpszTemp2 = lpszTemp-1;
        ++lpszTemp;
    }

    //
    // Search back to set the NULL for the Value
    //
    if (lpszTemp2 != NULL) {
        while ((*lpszTemp2 == ' ') || (*lpszTemp2 == '\t'))
            lpszTemp2--; // AnsiPrev?
        *(lpszTemp2+1)= '\0';
    }

    //
    // Convert the first entry
    //
    if (pConvertEditText(lpszCopy, pulVal, ridResType)) {
        //
        // If there is a second entry, convert it, otherwise assume a length
        // of one.
        //
        if (*lpszTemp != '\0') {
            if (pConvertEditText(lpszTemp, pulEnd,ridResType)) {
                bRet = TRUE;
            }
        } else {
            *pulEnd = *pulVal;
            bRet = TRUE;
        }
    }

    MyFree(lpszCopy);
    return bRet;

}

BOOL
pConvertEditText(
    LPTSTR      lpszConvert,
    PULONG64    pulVal,
    RESOURCEID  ridResType
    )
{
    LPTSTR   lpConvert;

    if ((ridResType == ResType_Mem) || (ridResType == ResType_IO)) {
        *pulVal = _tcstoul(lpszConvert, &lpConvert, (WORD)16);
    } else {
        *pulVal = _tcstoul(lpszConvert, &lpConvert, (WORD)10);
    }

    if (lpConvert == lpszConvert+lstrlen(lpszConvert)) {
        return TRUE;
    } else {
        return FALSE;
    }

} // ConvertEditText

void
pWarnResSettingNotEditable(
    HWND    hDlg,
    WORD    idWarning
    )
{
    TCHAR    szTitle[MAX_PATH];
    TCHAR    szMessage[MAX_PATH * 2];

    //
    // Give some warning Messages.  If there is no logconfig,
    // then we cannot edit any settings, if there is, then
    // just the setting they are choosing is not editable.
    //
    LoadString(MyDllModuleHandle, IDS_DEVRES_NOMODIFYTITLE, szTitle, MAX_PATH);
    LoadString(MyDllModuleHandle, idWarning, szMessage, MAX_PATH * 2);
    MessageBox(hDlg, szMessage, szTitle, MB_OK | MB_TASKMODAL | MB_ICONEXCLAMATION);

} // WarnResSettingsNotEditable

int
pWarnNoSave(
    HWND    hDlg,
    WORD    idWarning
    )
/*++

Routine Description:

    Warn that the settings will not be saved

Arguments:

Return Value:

    IDCANCEL = don't proceed
    IDOK/IDYES/IDNO = proceed without saving

--*/
{
    TCHAR    szTitle[MAX_PATH];
    TCHAR    szMessage[MAX_PATH * 2];
    int      res;

    //
    // Give a warning message of why we can't save settings
    //
    LoadString(MyDllModuleHandle, IDS_MAKE_FORCED_TITLE, szTitle, MAX_PATH);
    LoadString(MyDllModuleHandle, idWarning, szMessage, MAX_PATH * 2);

    //res = MessageBox(hDlg, szMessage, szTitle, MB_OKCANCEL | MB_TASKMODAL | MB_ICONEXCLAMATION);
    //return res;
    res = MessageBox(hDlg, szMessage, szTitle, MB_OK | MB_TASKMODAL | MB_ICONEXCLAMATION);
    return IDCANCEL;
}

LPVOID
pGetListViewItemData(
    HWND hList,
    int iItem,
    int iSubItem
    )
{
    LV_ITEM lviItem;

    lviItem.mask = LVIF_PARAM;
    lviItem.iItem = iItem;
    lviItem.iSubItem = iSubItem;

    if (ListView_GetItem(hList, &lviItem)) {
        return (LPVOID)lviItem.lParam;
    } else {
        return NULL;
    }

} // GetListViewItemData

BOOL
pSaveDevResSettings(
    LPDMPROP_DATA   lpdmpd
    )

/*++

Routine Description:

    This routine saves the resources based on the users selections.
    MEMPHIS COMPATIBLE.

Arguments:

    lpdmpd          Property data.

Return Value:

   Returns TRUE if the function succeeded and FALSE if it failed.

--*/

{
    HWND        hDlg = lpdmpd->hDlg;
    HWND        hList =  GetDlgItem(hDlg, IDC_DEVRES_SETTINGSLIST);

    CONFIGRET   Status = CR_SUCCESS;
    LOG_CONF    ForcedLogConf;
    RES_DES     ResDes, ResDesTemp, ResDes1;
    RESOURCEID  ResType;
    ULONG       ulSize = 0, ulCount = 0, i = 0, iCur = 0;
    LPBYTE      pData = NULL;
    PITEMDATA   pItemData = NULL;
    BOOL        bRet = TRUE;
    SP_PROPCHANGE_PARAMS PropChangeParams;
    HMACHINE        hMachine = pGetMachine(lpdmpd);

    if ((lpdmpd->dwFlags & DMPROP_FLAG_USESYSSETTINGS)!=0) {

        //-------------------------------------------------------------------
        // If the user checked the "Use Automatic Settings" checkbox, then
        // delete any Boot/Forced configs, otherwise write the current settings
        // as a forced config.
        //-------------------------------------------------------------------

        if (CM_Get_First_Log_Conf_Ex(&ForcedLogConf, lpdmpd->lpdi->DevInst,
                                     FORCED_LOG_CONF,hMachine) == CR_SUCCESS) {
            CM_Free_Log_Conf_Ex(ForcedLogConf, 0,hMachine);
            CM_Free_Log_Conf_Handle(ForcedLogConf);
        }

        // Let the helper modules (class installer/co-installers) get in on the act...
        //
        PropChangeParams.ClassInstallHeader.cbSize          = sizeof(SP_CLASSINSTALL_HEADER);
        PropChangeParams.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;

        PropChangeParams.StateChange = DICS_PROPCHANGE;
        PropChangeParams.Scope       = DICS_FLAG_GLOBAL;
        // no need to set PropChangeParams.HwProfile, since this is a global property change.

        DoInstallActionWithParams(DIF_PROPERTYCHANGE,
                                  lpdmpd->hDevInfo,
                                  lpdmpd->lpdi,
                                  (PSP_CLASSINSTALL_HEADER)&PropChangeParams,
                                  sizeof(PropChangeParams),
                                  INSTALLACTION_CALL_CI
                                  );
    } else {

        //-------------------------------------------------------------------
        // The Use Automatic Settings is not selected.
        //-------------------------------------------------------------------

        bRet = pSaveCustomResSettings(lpdmpd,hMachine);
    }

    return bRet;
}

BOOL
pSaveCustomResSettings(
    LPDMPROP_DATA   lpdmpd,
    IN HMACHINE     hMachine
    )

/*++

Routine Description:

    This routine saves custom (user edited) resources. MEMPHIS COMPATIBLE but
    extracted from Memphis version of SaveDevResSetting().

Arguments:

    lpdmpd      Property data.

Return Value:

   Returns TRUE if the function succeeded and FALSE if it failed.

--*/

{
    HWND        hDlg = lpdmpd->hDlg;

    TCHAR       szWarn[MAX_MSG_LEN];
    TCHAR       szTitle[MAX_MSG_LEN];
    TCHAR       szTemp[MAX_MSG_LEN];
    DWORD       dwPriority, dwLCPri;
    LOG_CONF    ForcedLogConf;
    RES_DES     ResDes;
    HWND        hList = GetDlgItem(hDlg, IDC_DEVRES_SETTINGSLIST);
    PITEMDATA   pItemData = NULL;
    LONG        iCur;
    BOOL        bRet = FALSE;
    SP_PROPCHANGE_PARAMS PropChangeParams;
    DWORD       HardReconfigFlag;
    SP_DEVINSTALL_PARAMS DevInstallParams;
    PRESDES_ENTRY pResList = NULL, pResDesEntry = NULL, pTemp = NULL;
    PITEMDATA_LISTNODE ItemDataList = NULL, ItemDataListEntry, ItemDataListEnd = NULL;
    PGENERIC_RESOURCE pGenRes;
    ULONG       i, ulFlags;
    ULONG64     ulValue, ulLen, ulEnd;
    LOG_CONF    LogConf;
    ULONG       ulSize;
    ULONG       ulConfigFlags;
    HCURSOR     hOldCursor;
    BOOL        UsingMatch = FALSE;

    LogConf = lpdmpd->SelectedLC;
    if (LogConf == 0) {
        LogConf = lpdmpd->MatchingLC;
        UsingMatch = TRUE;
    }
    if (LogConf == 0) {
        LogConf = lpdmpd->CurrentLC;
        UsingMatch = FALSE;
    }
    if (LogConf == 0) {
        //MYASSERT(FALSE);
        return FALSE;
    }
    //
    // form the "warning - do you want to continue" message
    //
    if(!LoadString(MyDllModuleHandle, IDS_MAKE_FORCED_TITLE, szTitle, MAX_MSG_LEN)) {
        szTitle[0]=TEXT('\0');
    }
    if(!LoadString(MyDllModuleHandle, IDS_FORCEDCONFIG_WARN1, szWarn, MAX_MSG_LEN)) {
        szWarn[0]=TEXT('\0');
    }
    if(LoadString(MyDllModuleHandle, IDS_FORCEDCONFIG_WARN2, szTemp, MAX_MSG_LEN)) {
        lstrcat(szWarn, szTemp);
    }
    if(LoadString(MyDllModuleHandle, IDS_FORCEDCONFIG_WARN3, szTemp, MAX_MSG_LEN)) {
        lstrcat(szWarn, szTemp);
    }
    if(LoadString(MyDllModuleHandle, IDS_FORCEDCONFIG_WARN4, szTemp, MAX_MSG_LEN)) {
        lstrcat(szWarn, szTemp);
    }

    //
    // If the LCPRI is soft configurable, and the user chooses YES to the
    // warning, then save the new config.  If the LCPRI is not soft
    // configurable, just save with no warning
    //
    dwLCPri = pGetMinLCPriority(lpdmpd->lpdi->DevInst, lpdmpd->ConfigListLCType,hMachine);

    if (((dwLCPri >= LCPRI_DESIRED) && (dwLCPri <= LCPRI_LASTSOFTCONFIG)) &&
          (MessageBox(hDlg, szWarn, szTitle, MB_YESNO|MB_ICONEXCLAMATION) == IDNO)) {
        //
        // user doesn't want to change anything
        //
        bRet = FALSE;

    } else {
        //
        // We're still using the selected basic LC, but use the range index
        // embedded in the listview control
        // ISSUE-2000/02/03-JamieHun Selected Basic LC, check if user overrode
        // Need to check the value to see if a user overrode it (is this possible?)
        //
        bRet = TRUE;

        if (CM_Get_First_Log_Conf_Ex(&ForcedLogConf, lpdmpd->lpdi->DevInst,
                                  FORCED_LOG_CONF,hMachine) == CR_SUCCESS) {
            CM_Free_Log_Conf_Ex(ForcedLogConf, 0,hMachine);
            CM_Free_Log_Conf_Handle(ForcedLogConf);
        }

        //
        // Save the current choices as the forced config
        //
        CM_Add_Empty_Log_Conf_Ex(&ForcedLogConf, lpdmpd->lpdi->DevInst, LCPRI_FORCECONFIG,
                              FORCED_LOG_CONF | PRIORITY_EQUAL_FIRST,hMachine);

        pGetResDesDataList(LogConf, &pResList, FALSE,hMachine);
        pResDesEntry = pResList;

        if (UsingMatch && (lpdmpd->dwFlags & DMPROP_FLAG_MATCH_OUT_OF_ORDER)) {
            //
            // The resource descriptors are out-of-order.  Maintain the original ordering.
            //
            // First, build up a linked list of the data in the listview resource items.
            //
            iCur = (int)ListView_GetNextItem(hList, -1, LVNI_ALL);

            while (iCur != -1) {

                pItemData = (PITEMDATA)pGetListViewItemData(hList, iCur, 0);
                if (pItemData) {
                    //
                    // Allocate an item data list node for this data.
                    //
                    ItemDataListEntry = MyMalloc(sizeof(ITEMDATA_LISTNODE));
                    if (!ItemDataListEntry) {
                        bRet = FALSE;
                        goto clean0;
                    }

                    ItemDataListEntry->ItemData = pItemData;
                    ItemDataListEntry->Next = NULL;

                    //
                    // Append this new item to the end of our list.
                    //
                    if (ItemDataListEnd) {
                        ItemDataListEnd->Next = ItemDataListEntry;
                    } else {
                        ItemDataList = ItemDataListEntry;
                    }
                    ItemDataListEnd = ItemDataListEntry;
                }

                iCur = (int)ListView_GetNextItem(hList, iCur, LVNI_ALL);
            }

            //
            // Now loop through each resdes entry, writing each one out.  For each one, check
            // to see if it has a corresponding entry in our listview item data list.
            //
            while (pResDesEntry) {
                pGenRes = (PGENERIC_RESOURCE)pResDesEntry->ResDesData;

                for(ItemDataListEntry = ItemDataList, ItemDataListEnd = NULL;
                    ItemDataListEntry;
                    ItemDataListEnd = ItemDataListEntry, ItemDataListEntry = ItemDataListEntry->Next)
                {
                    if(pResDesEntry->ResDesType == ItemDataListEntry->ItemData->ResType) {

                        for (i = 0; i < pGenRes->GENERIC_Header.GENERIC_Count; i++) {

                            pGetRangeValues(pResDesEntry->ResDesData, pResDesEntry->ResDesType, i,
                                           &ulValue, &ulLen, &ulEnd, NULL, &ulFlags);

                            if ((ItemDataListEntry->ItemData->ulLen == ulLen) &&
                                (ItemDataListEntry->ItemData->ulValue >= ulValue) &&
                                (ItemDataListEntry->ItemData->ulEnd <= ulEnd)) {
                                //
                                // We found the matching resource descriptor.  Write this out.
                                //
                                pWriteValuesToForced(ForcedLogConf,
                                                    ItemDataListEntry->ItemData->ResType,
                                                    ItemDataListEntry->ItemData->RangeCount,
                                                    ItemDataListEntry->ItemData->MatchingResDes,
                                                    ItemDataListEntry->ItemData->ulValue,
                                                    ItemDataListEntry->ItemData->ulLen,
                                                    ItemDataListEntry->ItemData->ulEnd,
                                                    hMachine );
                                //
                                // Remove this item from our list.
                                //
                                if (ItemDataListEnd) {
                                    ItemDataListEnd->Next = ItemDataListEntry->Next;
                                } else {
                                    ItemDataList = ItemDataListEntry->Next;
                                }
                                MyFree(ItemDataListEntry);

                                break;
                            }
                        }

                        if(i < pGenRes->GENERIC_Header.GENERIC_Count) {
                            //
                            // Then we broke out of the loop early, which means we found a match
                            // already.
                            //
                            break;
                        }
                    }
                }

                //
                // If we didn't find a match, then go ahead and write out the non-arbitrated
                // resdes.
                //
                if (!ItemDataListEntry) {
                    pWriteResDesRangeToForced(ForcedLogConf,
                                             pResDesEntry->ResDesType,
                                             0,
                                             0,
                                             pResDesEntry->ResDesData,
                                             hMachine);
                }

                pResDesEntry = (PRESDES_ENTRY)pResDesEntry->Next;
            }

        } else {

            iCur = (int)ListView_GetNextItem(hList, -1, LVNI_ALL);

            while (iCur != -1) {

                pItemData = (PITEMDATA)pGetListViewItemData(hList, iCur, 0);

                if (pItemData) {

                    // retrieve values

                    while (pResDesEntry &&
                           (pItemData->ResType != pResDesEntry->ResDesType)) {
                        //
                        // write out any preceding non arbitrated resources
                        //
                        pWriteResDesRangeToForced(ForcedLogConf,
                                                 pResDesEntry->ResDesType,
                                                 0,
                                                 0,
                                                 pResDesEntry->ResDesData,
                                                 hMachine);

                        pResDesEntry = (PRESDES_ENTRY)pResDesEntry->Next;
                    }
                    if (pGetMatchingResDes(pItemData->ulValue,
                                          pItemData->ulLen,
                                          pItemData->ulEnd,
                                          pItemData->ResType,
                                          LogConf,
                                          &ResDes,
                                          hMachine)) {
                        //
                        // Write the first range as the chosen forced resource
                        //
                        pWriteValuesToForced(ForcedLogConf, pItemData->ResType,
                                            pItemData->RangeCount, ResDes,
                                            pItemData->ulValue,
                                            pItemData->ulLen,
                                            pItemData->ulEnd,
                                            hMachine);
                    }
                }

                if (pResDesEntry) {
                    pResDesEntry = (PRESDES_ENTRY)pResDesEntry->Next;
                } else {
                    MYASSERT(pResDesEntry);
                }
                iCur = (int)ListView_GetNextItem(hList, iCur, LVNI_ALL);
            }

            while (pResDesEntry) {
                //
                // write out any subsequent non arbitrated resources
                //
                pWriteResDesRangeToForced(ForcedLogConf,
                                         pResDesEntry->ResDesType,
                                         0,
                                         0,
                                         pResDesEntry->ResDesData,
                                         hMachine);

                pResDesEntry = (PRESDES_ENTRY)pResDesEntry->Next;
            }
        }

        CM_Free_Log_Conf_Handle(ForcedLogConf);

        //
        // consider clearing problem flags
        //
        ulSize = sizeof(ulConfigFlags);
        if (CM_Get_DevInst_Registry_Property_Ex(lpdmpd->lpdi->DevInst,
                                             CM_DRP_CONFIGFLAGS,
                                             NULL, (LPBYTE)&ulConfigFlags,
                                             &ulSize, 0,hMachine) == CR_SUCCESS) {
            if ((ulConfigFlags & CONFIGFLAG_PARTIAL_LOG_CONF) != 0) {
                //
                // have flag(s) to change
                // CONFIGFLAG_PARTIAL_LOG_CONF should be cleared - we should have written a complete config now
                //
                ulConfigFlags &= ~ (CONFIGFLAG_PARTIAL_LOG_CONF);
                CM_Set_DevInst_Registry_Property_Ex(lpdmpd->lpdi->DevInst,
                                                 CM_DRP_CONFIGFLAGS,
                                                 (LPBYTE)&ulConfigFlags,
                                                 sizeof(ulConfigFlags),
                                                 0,
                                                 hMachine);
            }

        }

        //
        // Give the class installer/co-installers a crack at the propchange process.
        //
        PropChangeParams.ClassInstallHeader.cbSize          = sizeof(SP_CLASSINSTALL_HEADER);
        PropChangeParams.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;

        PropChangeParams.StateChange = DICS_PROPCHANGE;
        PropChangeParams.Scope       = DICS_FLAG_GLOBAL;
        // no need to set PropChangeParams.HwProfile, since this is a global property change.

        DoInstallActionWithParams(DIF_PROPERTYCHANGE,
                                  lpdmpd->hDevInfo,
                                  lpdmpd->lpdi,
                                  (PSP_CLASSINSTALL_HEADER)&PropChangeParams,
                                  sizeof(PropChangeParams),
                                  INSTALLACTION_CALL_CI | INSTALLACTION_NO_DEFAULT
                                 );

        //
        // Check the Priority of this LC.  If it is greater
        // than LCPRI_LASTSOFTCONFIG, then we need to reboot
        // otherwise try the dynamic changestate route.
        //

        if (CM_Get_Log_Conf_Priority_Ex(LogConf, &dwPriority, 0,hMachine) != CR_SUCCESS) {
            dwPriority = LCPRI_LASTSOFTCONFIG;
        }

        if (dwPriority <= LCPRI_LASTSOFTCONFIG) {
            //
            // Do the default action for SoftConfigable devices, which
            // will attempt to restart the device with the new config
            // This could take a while so use an hourglass
            //
            hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DoInstallActionWithParams(DIF_PROPERTYCHANGE,
                                      lpdmpd->hDevInfo,
                                      lpdmpd->lpdi,
                                      (PSP_CLASSINSTALL_HEADER)&PropChangeParams,
                                      sizeof(PropChangeParams),
                                      0  // don't call class-installer, just do default action
                                     );
            SetCursor(hOldCursor);
            HardReconfigFlag = 0;

        } else if((dwPriority > LCPRI_LASTSOFTCONFIG) && (dwPriority <= LCPRI_RESTART)) {
            HardReconfigFlag = DI_NEEDRESTART;
        } else {
            HardReconfigFlag = DI_NEEDREBOOT;
        }

        lpdmpd->dwFlags |= DMPROP_FLAG_CHANGESSAVED;

        //
        // Properties have changed, so set flags to indicate if restart/reboot is required,
        // and to tell DevMgr to re-init the UI.
        //
        DevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if(SetupDiGetDeviceInstallParams(lpdmpd->hDevInfo,
                                         lpdmpd->lpdi,
                                         &DevInstallParams)) {

            DevInstallParams.Flags |= (HardReconfigFlag | DI_PROPERTIES_CHANGE);

            SetupDiSetDeviceInstallParams(lpdmpd->hDevInfo,
                                          lpdmpd->lpdi,
                                          &DevInstallParams
                                         );
        }

        //
        // If we need to reboot, then set a problem on the device that indicates this (in case
        // the user doesn't listen to us, we want to flag this devnode so that the user will see
        // that this devnode needs a reboot if they go into DevMgr, etc.)
        //
        if(HardReconfigFlag) {
            PDEVICE_INFO_SET pDeviceInfoSet;
            PDEVINFO_ELEM DevInfoElem;

            if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdmpd->hDevInfo))) {
                //
                // We'd better be able to access this device information set!
                // In case we couldn't don't bother trying to set the needs-reboot problem,
                // because the whole mess is invalid!
                //
                MYASSERT(pDeviceInfoSet);
            } else {

                try {
                    DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet, lpdmpd->lpdi, NULL);
                    //
                    // We'd better be able to find this element!
                    //
                    MYASSERT(DevInfoElem);
                    //
                    // In case we can't find it, don't try to set any problem on the devnode.
                    //
                    if(DevInfoElem) {

                        SetDevnodeNeedsRebootProblem(DevInfoElem,
                                                     pDeviceInfoSet,
                                                     MSG_LOG_REBOOT_DEVRES
                                                    );
                    }
                } finally {
                    UnlockDeviceInfoSet(pDeviceInfoSet);
                }
            }

        }
    }

clean0:

    while (ItemDataList) {
        ItemDataListEntry = ItemDataList->Next;
        MyFree(ItemDataList);
        ItemDataList = ItemDataListEntry;
    }

    pDeleteResDesDataList(pResList);

    return bRet;

} // SaveCustomResSettings

BOOL
pWriteResDesRangeToForced(
    IN LOG_CONF     ForcedLogConf,
    IN RESOURCEID   ResType,
    IN ULONG        RangeIndex,
    IN RES_DES      RD,             OPTIONAL
    IN LPBYTE       ResDesData,     OPTIONAL
    IN HMACHINE     hMachine        OPTIONAL
    )
{
    RES_DES ResDes;
    ULONG   ulSize;
    LPBYTE  pData = NULL;
    BOOL Success = FALSE;


    if ((RD == 0) && (ResDesData == NULL)) {
        return FALSE;   // pass in data or handle!
    }

    if (!ResDesData) {

        if (CM_Get_Res_Des_Data_Size_Ex(&ulSize, RD, DEVRES_WIDTH_FLAGS,hMachine) != CR_SUCCESS) {
            return FALSE;
        }

        pData = MyMalloc(ulSize);
        if (pData == NULL) {
            return FALSE;
        }

        if (CM_Get_Res_Des_Data_Ex(RD, pData, ulSize, DEVRES_WIDTH_FLAGS,hMachine) != CR_SUCCESS) {
            MyFree(pData);
            return FALSE;
        }
    } else {
        pData = ResDesData;
    }

    //
    // convert the first range data into hdr data
    //
    switch (ResType) {

        case ResType_Mem: {

            PMEM_RESOURCE pMemData = (PMEM_RESOURCE)pData;
            PMEM_RESOURCE pForced = (PMEM_RESOURCE)MyMalloc(sizeof(MEM_RESOURCE));
            if (!pForced) {
                break;
            }

            pForced->MEM_Header.MD_Count      = 0;
            pForced->MEM_Header.MD_Type       = MType_Range;
            pForced->MEM_Header.MD_Alloc_Base = pMemData->MEM_Data[RangeIndex].MR_Min;
            pForced->MEM_Header.MD_Alloc_End  = pMemData->MEM_Data[RangeIndex].MR_Min +
                                                pMemData->MEM_Data[RangeIndex].MR_nBytes - 1;
            pForced->MEM_Header.MD_Flags      = pMemData->MEM_Data[RangeIndex].MR_Flags;
            pForced->MEM_Header.MD_Reserved   = 0;

            Success = CM_Add_Res_Des_Ex(NULL,
                                        ForcedLogConf,
                                        ResType_Mem,
                                        pForced,
                                        sizeof(MEM_RESOURCE),
                                        DEVRES_WIDTH_FLAGS,
                                        hMachine) == CR_SUCCESS;
            MyFree(pForced);
            break;
        }

        case ResType_IO:  {

            PIO_RESOURCE pIoData = (PIO_RESOURCE)pData;
            PIO_RESOURCE pForced = (PIO_RESOURCE)MyMalloc(sizeof(IO_RESOURCE));
            if (!pForced) {
                break;
            }

            pForced->IO_Header.IOD_Count      = 0;
            pForced->IO_Header.IOD_Type       = IOType_Range;
            pForced->IO_Header.IOD_Alloc_Base = pIoData->IO_Data[RangeIndex].IOR_Min;
            pForced->IO_Header.IOD_Alloc_End  = pIoData->IO_Data[RangeIndex].IOR_Min +
                                                pIoData->IO_Data[RangeIndex].IOR_nPorts - 1;
            pForced->IO_Header.IOD_DesFlags   = pIoData->IO_Data[RangeIndex].IOR_RangeFlags;

            Success = CM_Add_Res_Des_Ex(NULL,
                                        ForcedLogConf,
                                        ResType_IO,
                                        pForced,
                                        sizeof(IO_RESOURCE),
                                        DEVRES_WIDTH_FLAGS,
                                        hMachine) == CR_SUCCESS;
            MyFree(pForced);
            break;
        }

        case ResType_DMA: {

            PDMA_RESOURCE pDmaData = (PDMA_RESOURCE)pData;
            PDMA_RESOURCE pForced = (PDMA_RESOURCE)MyMalloc(sizeof(DMA_RESOURCE));
            if (!pForced) {
                break;
            }

            pForced->DMA_Header.DD_Count      = 0;
            pForced->DMA_Header.DD_Type       = DType_Range;
            pForced->DMA_Header.DD_Flags      = pDmaData->DMA_Data[RangeIndex].DR_Flags;
            pForced->DMA_Header.DD_Alloc_Chan = pDmaData->DMA_Data[RangeIndex].DR_Min;

            Success = CM_Add_Res_Des_Ex(NULL,
                                        ForcedLogConf,
                                        ResType_DMA,
                                        pForced,
                                        sizeof(DMA_RESOURCE),
                                        DEVRES_WIDTH_FLAGS,
                                        hMachine) == CR_SUCCESS;
            MyFree(pForced);
            break;
        }

        case ResType_IRQ: {

            DEVRES_PIRQ_RESOURCE pIrqData = (DEVRES_PIRQ_RESOURCE)pData;
            DEVRES_PIRQ_RESOURCE pForced = (DEVRES_PIRQ_RESOURCE)MyMalloc(sizeof(DEVRES_IRQ_RESOURCE));
            if (!pForced) {
                break;
            }

            pForced->IRQ_Header.IRQD_Count     = 0;
            pForced->IRQ_Header.IRQD_Type      = IRQType_Range;
            pForced->IRQ_Header.IRQD_Flags     = pIrqData->IRQ_Data[RangeIndex].IRQR_Flags;
            pForced->IRQ_Header.IRQD_Alloc_Num = pIrqData->IRQ_Data[RangeIndex].IRQR_Min;
            pForced->IRQ_Header.IRQD_Affinity  = (DEVRES_AFFINITY)(-1);

            Success = CM_Add_Res_Des_Ex(NULL,
                                        ForcedLogConf,
                                        ResType_IRQ,
                                        pForced,
                                        sizeof(DEVRES_IRQ_RESOURCE),
                                        DEVRES_WIDTH_FLAGS,
                                        hMachine) == CR_SUCCESS;
            MyFree(pForced);
            break;
        }

        case ResType_BusNumber: {

            PBUSNUMBER_RESOURCE pBusData = (PBUSNUMBER_RESOURCE)pData;
            PBUSNUMBER_RESOURCE pForced = (PBUSNUMBER_RESOURCE)MyMalloc(sizeof(BUSNUMBER_RESOURCE));
            if (!pForced) {
                break;
            }

            pForced->BusNumber_Header.BUSD_Count      = 0;
            pForced->BusNumber_Header.BUSD_Type       = BusNumberType_Range;
            pForced->BusNumber_Header.BUSD_Flags      = pBusData->BusNumber_Data[RangeIndex].BUSR_Flags;
            pForced->BusNumber_Header.BUSD_Alloc_Base = pBusData->BusNumber_Data[RangeIndex].BUSR_Min;
            pForced->BusNumber_Header.BUSD_Alloc_End  = pBusData->BusNumber_Data[RangeIndex].BUSR_Min +
                                                  pBusData->BusNumber_Data[RangeIndex].BUSR_nBusNumbers;

            Success = CM_Add_Res_Des_Ex(NULL,
                                        ForcedLogConf,
                                        ResType_BusNumber,
                                        pForced,
                                        sizeof(BUSNUMBER_RESOURCE),
                                        DEVRES_WIDTH_FLAGS,
                                        hMachine) == CR_SUCCESS;
            MyFree(pForced);
            break;
        }

        case ResType_DevicePrivate: {

            PDEVPRIVATE_RESOURCE pPrvData = (PDEVPRIVATE_RESOURCE)pData;
            PDEVPRIVATE_RESOURCE pForced = (PDEVPRIVATE_RESOURCE)MyMalloc(sizeof(DEVPRIVATE_RESOURCE));
            if (!pForced) {
                break;
            }

            pForced->PRV_Header.PD_Count = 0;
            pForced->PRV_Header.PD_Type  = PType_Range;
            pForced->PRV_Header.PD_Data1 = pPrvData->PRV_Data[RangeIndex].PR_Data1;
            pForced->PRV_Header.PD_Data2 = pPrvData->PRV_Data[RangeIndex].PR_Data2;
            pForced->PRV_Header.PD_Data3 = pPrvData->PRV_Data[RangeIndex].PR_Data3;
            pForced->PRV_Header.PD_Flags = 0;

            Success = CM_Add_Res_Des_Ex(NULL,
                                        ForcedLogConf,
                                        ResType_DevicePrivate,
                                        pForced,
                                        sizeof(DEVPRIVATE_RESOURCE),
                                        DEVRES_WIDTH_FLAGS,
                                        hMachine) == CR_SUCCESS;
            MyFree(pForced);
            break;
        }

        case ResType_PcCardConfig: {

            Success = CM_Add_Res_Des_Ex(NULL,
                                        ForcedLogConf,
                                        ResType_PcCardConfig,
                                        pData,
                                        sizeof(PCCARD_RESOURCE),
                                        DEVRES_WIDTH_FLAGS,
                                        hMachine);
            break;
        }
    }

    if (pData != ResDesData) {
        MyFree(pData);
    }

    return Success;

} // WriteResDesRangeToForced

BOOL
pWriteValuesToForced(
    IN LOG_CONF     ForcedLogConf,
    IN RESOURCEID   ResType,
    IN ULONG        RangeIndex,
    IN RES_DES      RD,
    IN ULONG64      ulValue,
    IN ULONG64      ulLen,
    IN ULONG64      ulEnd,
    IN HMACHINE     hMachine
    )
{
    RES_DES ResDes;
    ULONG   ulSize;
    LPBYTE  pData = NULL;
    BOOL Success = FALSE;


    if (CM_Get_Res_Des_Data_Size_Ex(&ulSize, RD, DEVRES_WIDTH_FLAGS,hMachine) != CR_SUCCESS) {
        return FALSE;
    }

    pData = MyMalloc(ulSize);
    if (pData == NULL) {
        return FALSE;
    }

    if (CM_Get_Res_Des_Data_Ex(RD, pData, ulSize, DEVRES_WIDTH_FLAGS,hMachine) != CR_SUCCESS) {
        MyFree(pData);
        return FALSE;
    }

    //
    // convert the first range data into hdr data
    //
    switch (ResType) {

        case ResType_Mem: {

            PMEM_RESOURCE pMemData = (PMEM_RESOURCE)pData;
            PMEM_RESOURCE pForced = (PMEM_RESOURCE)MyMalloc(sizeof(MEM_RESOURCE));
            if (!pForced) {
                break;
            }

            pForced->MEM_Header.MD_Count      = 0;
            pForced->MEM_Header.MD_Type       = MType_Range;
            pForced->MEM_Header.MD_Alloc_Base = ulValue;
            pForced->MEM_Header.MD_Alloc_End  = ulEnd;
            pForced->MEM_Header.MD_Flags      = pMemData->MEM_Data[RangeIndex].MR_Flags;
            pForced->MEM_Header.MD_Reserved   = 0;

            Success = CM_Add_Res_Des_Ex(NULL,
                                        ForcedLogConf,
                                        ResType_Mem,
                                        pForced,
                                        sizeof(MEM_RESOURCE),
                                        DEVRES_WIDTH_FLAGS,
                                        hMachine) == CR_SUCCESS;
            MyFree(pForced);
            break;
        }

        case ResType_IO:  {

            PIO_RESOURCE pIoData = (PIO_RESOURCE)pData;
            PIO_RESOURCE pForced = (PIO_RESOURCE)MyMalloc(sizeof(IO_RESOURCE));
            if (!pForced) {
                break;
            }

            pForced->IO_Header.IOD_Count      = 0;
            pForced->IO_Header.IOD_Type       = IOType_Range;
            pForced->IO_Header.IOD_Alloc_Base = ulValue;
            pForced->IO_Header.IOD_Alloc_End  = ulEnd;
            pForced->IO_Header.IOD_DesFlags   = pIoData->IO_Data[RangeIndex].IOR_RangeFlags;

            Success = CM_Add_Res_Des_Ex(NULL,
                                        ForcedLogConf,
                                        ResType_IO,
                                        pForced,
                                        sizeof(IO_RESOURCE),
                                        DEVRES_WIDTH_FLAGS,
                                        hMachine) == CR_SUCCESS;
            MyFree(pForced);
            break;
        }

        case ResType_DMA: {

            PDMA_RESOURCE pDmaData = (PDMA_RESOURCE)pData;
            PDMA_RESOURCE pForced = (PDMA_RESOURCE)MyMalloc(sizeof(DMA_RESOURCE));
            if (!pForced) {
                break;
            }

            pForced->DMA_Header.DD_Count      = 0;
            pForced->DMA_Header.DD_Type       = DType_Range;
            pForced->DMA_Header.DD_Flags      = pDmaData->DMA_Data[RangeIndex].DR_Flags;
            pForced->DMA_Header.DD_Alloc_Chan = (ULONG)ulValue;

            Success = CM_Add_Res_Des_Ex(NULL,
                                        ForcedLogConf,
                                        ResType_DMA,
                                        pForced,
                                        sizeof(DMA_RESOURCE),
                                        DEVRES_WIDTH_FLAGS,
                                        hMachine) == CR_SUCCESS;
            MyFree(pForced);
            break;
        }

        case ResType_IRQ: {

            DEVRES_PIRQ_RESOURCE pIrqData = (DEVRES_PIRQ_RESOURCE)pData;
            DEVRES_PIRQ_RESOURCE pForced = (DEVRES_PIRQ_RESOURCE)MyMalloc(sizeof(DEVRES_IRQ_RESOURCE));
            if (!pForced) {
                break;
            }

            pForced->IRQ_Header.IRQD_Count     = 0;
            pForced->IRQ_Header.IRQD_Type      = IRQType_Range;
            pForced->IRQ_Header.IRQD_Flags     = pIrqData->IRQ_Data[RangeIndex].IRQR_Flags;
            pForced->IRQ_Header.IRQD_Alloc_Num = (ULONG)ulValue;
            pForced->IRQ_Header.IRQD_Affinity  = (DEVRES_AFFINITY)(-1);

            Success = CM_Add_Res_Des_Ex(NULL,
                                        ForcedLogConf,
                                        ResType_IRQ,
                                        pForced,
                                        sizeof(DEVRES_IRQ_RESOURCE),
                                        DEVRES_WIDTH_FLAGS,
                                        hMachine) == CR_SUCCESS;
            MyFree(pForced);
            break;
        }

        case ResType_BusNumber: {

            PBUSNUMBER_RESOURCE pBusData = (PBUSNUMBER_RESOURCE)pData;
            PBUSNUMBER_RESOURCE pForced = (PBUSNUMBER_RESOURCE)MyMalloc(sizeof(BUSNUMBER_RESOURCE));
            if (!pForced) {
                break;
            }

            pForced->BusNumber_Header.BUSD_Count      = 0;
            pForced->BusNumber_Header.BUSD_Type       = BusNumberType_Range;
            pForced->BusNumber_Header.BUSD_Flags      = pBusData->BusNumber_Data[RangeIndex].BUSR_Flags;
            pForced->BusNumber_Header.BUSD_Alloc_Base = (ULONG)ulValue;
            pForced->BusNumber_Header.BUSD_Alloc_End  = (ULONG)ulEnd;

            Success = CM_Add_Res_Des_Ex(NULL,
                                        ForcedLogConf,
                                        ResType_BusNumber,
                                        pForced,
                                        sizeof(BUSNUMBER_RESOURCE),
                                        DEVRES_WIDTH_FLAGS,
                                        hMachine) == CR_SUCCESS;
            MyFree(pForced);
            break;
        }

        case ResType_DevicePrivate: {
            break;
        }

        case ResType_PcCardConfig: {
            break;
        }
    }

    if (pData) {
        MyFree(pData);
    }
    return Success;

} // WriteValuesToForced

BOOL
MakeResourceData(
    OUT LPBYTE     *ppResourceData,
    OUT PULONG     pulSize,
    IN  RESOURCEID ResType,
    IN  ULONG64    ulValue,
    IN  ULONG64    ulLen,
    IN  ULONG      ulFlags
    )
{
    BOOL bStatus = TRUE;

    try {

        switch (ResType) {

            case ResType_Mem: {

                PMEM_RESOURCE p;

                *pulSize = sizeof(MEM_RESOURCE);
                if (ppResourceData) {
                    *ppResourceData = MyMalloc(*pulSize);
                    p = (PMEM_RESOURCE)(*ppResourceData);
                    if (!p) {
                        bStatus = FALSE;
                        break;
                    }

                    p->MEM_Header.MD_Count      = 0;
                    p->MEM_Header.MD_Type       = MType_Range;
                    p->MEM_Header.MD_Alloc_Base = ulValue;
                    p->MEM_Header.MD_Alloc_End  = ulValue + ulLen - 1;
                    p->MEM_Header.MD_Flags      = ulFlags;
                    p->MEM_Header.MD_Reserved   = 0;
                }
                break;
            }

            case ResType_IO:  {

                PIO_RESOURCE p;

                *pulSize = sizeof(IO_RESOURCE);
                if (ppResourceData) {
                    *ppResourceData = MyMalloc(*pulSize);
                    p = (PIO_RESOURCE)(*ppResourceData);
                    if (!p) {
                        bStatus = FALSE;
                        break;
                    }

                    p->IO_Header.IOD_Count      = 0;
                    p->IO_Header.IOD_Type       = IOType_Range;
                    p->IO_Header.IOD_Alloc_Base = ulValue;
                    p->IO_Header.IOD_Alloc_End  = ulValue + ulLen - 1;
                    p->IO_Header.IOD_DesFlags   = ulFlags;
                }
                break;
            }

            case ResType_DMA: {

                PDMA_RESOURCE p;

                *pulSize = sizeof(DMA_RESOURCE);
                if (ppResourceData) {
                    *ppResourceData = MyMalloc(*pulSize);
                    p = (PDMA_RESOURCE)(*ppResourceData);
                    if (!p) {
                        bStatus = FALSE;
                        break;
                    }

                    p->DMA_Header.DD_Count      = 0;
                    p->DMA_Header.DD_Type       = DType_Range;
                    p->DMA_Header.DD_Flags      = ulFlags;
                    p->DMA_Header.DD_Alloc_Chan = (ULONG)ulValue;
                }
                break;
            }

            case ResType_IRQ: {

                DEVRES_PIRQ_RESOURCE p;

                *pulSize = sizeof(DEVRES_IRQ_RESOURCE);
                if (ppResourceData) {
                    *ppResourceData = MyMalloc(*pulSize);
                    p = (DEVRES_PIRQ_RESOURCE)(*ppResourceData);
                    if (!p) {
                        bStatus = FALSE;
                        break;
                    }

                    p->IRQ_Header.IRQD_Count     = 0;
                    p->IRQ_Header.IRQD_Type      = IRQType_Range;
                    p->IRQ_Header.IRQD_Flags     = ulFlags;
                    p->IRQ_Header.IRQD_Alloc_Num = (ULONG)ulValue;
                    p->IRQ_Header.IRQD_Affinity  = (DEVRES_AFFINITY)(-1); // for any processor
                }
                break;
            }

            default:
                //
                // ResTypeEditable or ResType_MAX may be wrong if this ASSERT's
                //
                MYASSERT(FALSE);
                bStatus = FALSE;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bStatus = FALSE;
    }

    return bStatus;

} // MakeResourceData


BOOL
pShowWindow(
    IN HWND hWnd,
    IN int nShow
    )
/*++

Routine Description:

    A variation of ShowWindow that enables/disables window

Arguments:

    (See ShowWindow)
    hWnd  - handle of window to show
    nShow - typically SW_HIDE or SW_SHOW

Return Value:

    success status of ShowWindow

--*/
{
    EnableWindow(hWnd,nShow!=SW_HIDE);
    return ShowWindow(hWnd,nShow);
}


BOOL
pEnableWindow(
    IN HWND hWnd,
    IN BOOL Enable
    )
/*++

Routine Description:

    A variation of EnableWindow that only enables a window if it is visible

Arguments:

    (See EnableWindow)
    hWnd  - handle of window to enable/disable
    Enable - TRUE enables window (if window visible) FALSE disables window

Return Value:

    success status of EnableWindow

--*/
{
    //
    // I had to use GetWindowLong, as IsWindowVisible also checks parent flag
    // and parent is hidden until dialog is initialized
    //
    if((GetWindowLong(hWnd,GWL_STYLE) & WS_VISIBLE) == FALSE) {
        Enable = FALSE;
    }
    return EnableWindow(hWnd,Enable);
}

BOOL
pGetResDesDataList(
    IN LOG_CONF LogConf,
    IN OUT PRESDES_ENTRY *pResList,
    IN BOOL bArbitratedOnly,
    IN HMACHINE hMachine
    )
/*++

Routine Description:

    Creates a list of resource descriptors for further processing

Arguments:

    LogConf  - log config of interest
    pResList - list out
    bArbitratedOnly - filter out non-arbitrated resources
    hMachine - machine that LogConf is on

Return Value:

   None.

--*/
{
    BOOL bStatus = TRUE;
    CONFIGRET Status = CR_SUCCESS;
    PRESDES_ENTRY pHead = NULL, pEntry = NULL, pPrevious = NULL, pTemp = NULL;
    RES_DES     ResDes;
    RESOURCEID  ResType;
    ULONG       ulSize;
    LPBYTE      pData = NULL;

    //
    // Retrieve each res des in this log conf
    //

    Status = CM_Get_Next_Res_Des_Ex(&ResDes, LogConf, ResType_All, &ResType, 0,hMachine);

    while (Status == CR_SUCCESS) {

        if (bArbitratedOnly && (ResType <= ResType_None || ResType > ResType_MAX)) {
            goto NextResDes;
        }
        if (bArbitratedOnly && ResTypeEditable[ResType] == FALSE) {
            goto NextResDes;
        }

        if (CM_Get_Res_Des_Data_Size_Ex(&ulSize, ResDes, DEVRES_WIDTH_FLAGS,hMachine) != CR_SUCCESS) {
            CM_Free_Res_Des_Handle(ResDes);
            bStatus = FALSE;
            goto Clean0;
        }

        if (ulSize>0) {
            pData = MyMalloc(ulSize);
            if (pData == NULL) {
                CM_Free_Res_Des_Handle(ResDes);
                bStatus = FALSE;
                goto Clean0;
            }

            if (CM_Get_Res_Des_Data_Ex(ResDes, pData, ulSize, DEVRES_WIDTH_FLAGS,hMachine) != CR_SUCCESS) {
                CM_Free_Res_Des_Handle(ResDes);
                MyFree(pData);
                bStatus = FALSE;
                goto Clean0;
            }
        } else {
            pData = NULL;
        }

        //
        // Allocate a node for this res des and attach it to the list
        //

        pEntry = MyMalloc(sizeof(RESDES_ENTRY));
        if (pEntry == NULL) {
            CM_Free_Res_Des_Handle(ResDes);
            MyFree(pData);
            bStatus = FALSE;
            goto Clean0;
        }

        pEntry->ResDesData = pData;
        pEntry->ResDesType = ResType;
        pEntry->ResDesDataSize = ulSize;
        pEntry->ResDesHandle = ResDes;
        pEntry->Next = NULL;
        pEntry->CrossLink = NULL;

        if (!pHead) {
            pHead = pEntry;             // first entry
        }

        if (pPrevious) {
            pPrevious->Next = pEntry; // attach to previous entry
        }

        pPrevious = pEntry;

        //
        // Get next res des in LogConf
        //
    NextResDes:

        Status = CM_Get_Next_Res_Des_Ex(&ResDes, ResDes, ResType_All, &ResType, 0,hMachine);
    }

    bStatus = TRUE;

    Clean0:

    if (!bStatus) {
        pDeleteResDesDataList(pHead);
    } else {
        *pResList = pHead;
    }

    return bStatus;

} // GetResDesDataList

VOID
pDeleteResDesDataList(
    IN PRESDES_ENTRY pResList
    )
/*++

Routine Description:

    Deletes memory used by RESDES list

Arguments:

    pResList - list returned by GetResDesDataList

Return Value:

   None.

--*/
{
    PRESDES_ENTRY pTemp;
    while (pResList) {
        pTemp = pResList;
        pResList = (PRESDES_ENTRY)pResList->Next;
        if (pTemp->ResDesData) {
            MyFree(pTemp->ResDesData);
        }
        if (pTemp->ResDesHandle) {
            CM_Free_Res_Des_Handle(pTemp->ResDesHandle);
        }
        MyFree(pTemp);
    }
}

VOID
pHideAllControls(
    IN LPDMPROP_DATA lpdmpd
    )
/*++

Routine Description:

    Hide (and disable) all controls - start off with a clean slate
    Only Icon & device description will be visible

Arguments:

    hDlg = dialog handle of controls
    lpdmpd = property data

Return Value:

    none

--*/
{
    HWND hDlg = lpdmpd->hDlg;

    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_SETTINGSTATE), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_NO_RESOURCES_TEXT), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_SETTINGSLIST), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_NOALLOCTEXT), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_LCTEXT), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_LOGCONFIGLIST), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_NO_CHANGE_TEXT ), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_USESYSSETTINGS), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CHANGE), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_MAKEFORCED), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_MFPARENT), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_MFPARENT_DESC), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CONFLICTDEVTEXT), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CONFLICTINFOLIST), SW_HIDE);

    lpdmpd->dwFlags |= DMPROP_FLAG_VIEWONLYRES;
}

VOID
pShowViewNoResources(
    IN LPDMPROP_DATA lpdmpd
    )
/*++

Routine Description:

    Show page indicating this device has no resources

Arguments:

    hDlg = dialog handle of controls
    lpdmpd = property data

Return Value:

    none

--*/
{
    HWND hDlg = lpdmpd->hDlg;
    TCHAR           szString[MAX_PATH];

    pHideAllControls(lpdmpd); // all hidden and disabled
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_NO_RESOURCES_TEXT), SW_SHOW);   // show and enable text
    LoadString(MyDllModuleHandle, IDS_DEVRES_NO_RESOURCES, szString, MAX_PATH);
    SetDlgItemText(hDlg, IDC_DEVRES_NO_RESOURCES_TEXT, szString);
}

BOOL
pShowViewMFReadOnly(
    IN LPDMPROP_DATA lpdmpd,
    IN BOOL HideIfProb
    )
/*++

Routine Description:

    Show page apropriate for multifunction card that cannot be edited
    Resource settings are visible

Arguments:

    hDlg = dialog handle of controls
    lpdmpd = property data

Return Value:

    none

--*/
{
    TCHAR           szString[MAX_PATH];
    DEVNODE         dnParent;
    ULONG           ulSize;
    HWND hDlg = lpdmpd->hDlg;
    HMACHINE        hMachine = pGetMachine(lpdmpd);

    pHideAllControls(lpdmpd); // all hidden and disabled
    //pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_LCTEXT), SW_SHOW);   // show config information
    //pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_LOGCONFIGLIST), SW_SHOW); // show
    //pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CONFLICTDEVTEXT), SW_SHOW); // show conflict information space
    //pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CONFLICTINFOLIST), SW_SHOW);
    //
    // indicate we cannot change as it's multi-function
    //
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_NO_CHANGE_TEXT), SW_SHOW);
    if (LoadString(MyDllModuleHandle, IDS_DEVRES_NO_CHANGE_MF, szString, MAX_PATH)) {
        SetDlgItemText(hDlg, IDC_DEVRES_NO_CHANGE_TEXT,  szString);
    }
    //
    // for parent description
    //
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_MFPARENT), SW_SHOW);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_MFPARENT_DESC), SW_SHOW);
    //
    // Get the Parent's Description.
    //
    LoadString(MyDllModuleHandle, IDS_DEVNAME_UNK, szString, MAX_PATH);

    if (lpdmpd->lpdi->DevInst) {

        if (CM_Get_Parent_Ex(&dnParent, lpdmpd->lpdi->DevInst, 0,hMachine)
                          == CR_SUCCESS) {


            //
            // First, try to retrieve friendly name, then fall back to device description.
            //
            ulSize = MAX_PATH * sizeof(TCHAR);
            if(CM_Get_DevNode_Registry_Property_Ex(dnParent, CM_DRP_FRIENDLYNAME,
                                                NULL, szString, &ulSize, 0,hMachine) != CR_SUCCESS) {

                ulSize = MAX_PATH * sizeof(TCHAR);
                CM_Get_DevNode_Registry_Property_Ex(dnParent, CM_DRP_DEVICEDESC,
                                                 NULL, szString, &ulSize, 0,hMachine);
            }
        }
    }

    SetDlgItemText(hDlg, IDC_DEVRES_MFPARENT_DESC, szString);

    //
    // load and display current config (if any)
    // return FALSE if no current config
    //
    return pLoadCurrentConfig(lpdmpd,HideIfProb);
}

BOOL
pShowViewReadOnly(
    IN LPDMPROP_DATA lpdmpd,
    IN BOOL HideIfProb
    )
/*++

Routine Description:

    Show page of resources, don't allow editing, don't show editing controls

Arguments:

    hDlg = dialog handle of controls
    lpdmpd = property data

Return Value:

    none

--*/
{
    HWND hDlg = lpdmpd->hDlg;

    pHideAllControls(lpdmpd); // all hidden and disabled
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_LCTEXT), SW_SHOW);   // show
    EnableWindow(GetDlgItem(hDlg, IDC_DEVRES_LCTEXT), FALSE);
    ShowWindow(GetDlgItem(hDlg, IDC_DEVRES_LOGCONFIGLIST), SW_SHOW); // shown disabled
    EnableWindow(GetDlgItem(hDlg, IDC_DEVRES_LOGCONFIGLIST), FALSE);
    ShowWindow(GetDlgItem(hDlg, IDC_DEVRES_USESYSSETTINGS), SW_SHOW); // shown disabled
    EnableWindow(GetDlgItem(hDlg, IDC_DEVRES_USESYSSETTINGS), FALSE);
    ShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CHANGE), SW_SHOW); // shown disabled
    EnableWindow(GetDlgItem(hDlg, IDC_DEVRES_CHANGE), FALSE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CONFLICTDEVTEXT), SW_SHOW); // show conflict information space
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CONFLICTINFOLIST), SW_SHOW);

    //
    // will indicate if we're showing system settings or forced settings
    //
    CheckDlgButton(hDlg, IDC_DEVRES_USESYSSETTINGS, (lpdmpd->dwFlags & DMPROP_FLAG_USESYSSETTINGS ) ? TRUE : FALSE);

    //
    // load and display current config (if any)
    // return FALSE if no current config
    //
    return pLoadCurrentConfig(lpdmpd,HideIfProb);
}

VOID
pShowViewNoAlloc(
    IN LPDMPROP_DATA lpdmpd
    )
/*++

Routine Description:

    Modify the middle part of the control to indicate there is a problem (and there isn't much we can do about it)

Arguments:

    hDlg = dialog handle of controls
    lpdmpd = property data

Return Value:

    none

--*/
{
    HWND hDlg = lpdmpd->hDlg;

    //
    // hide all middle controls
    //
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_LCTEXT), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_LOGCONFIGLIST), SW_HIDE);
    //pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_NO_CHANGE_TEXT ), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_USESYSSETTINGS), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CHANGE), SW_HIDE);
    //pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_MAKEFORCED), SW_HIDE);
    lpdmpd->dwFlags |= DMPROP_FLAG_VIEWONLYRES;

    //pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_NO_CHANGE_TEXT), SW_SHOW);  // this may say why
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_MAKEFORCED), SW_HIDE);

    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CONFLICTDEVTEXT), SW_HIDE); // no alloc, so hide this header & textbox
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CONFLICTINFOLIST), SW_HIDE);
}

VOID
pShowViewNeedForced(
    IN LPDMPROP_DATA lpdmpd
    )
/*++

Routine Description:

    Modify the middle part of the control to indicate a forced config is required

Arguments:

    hDlg = dialog handle of controls
    lpdmpd = property data

Return Value:

    none

--*/
{
    HWND hDlg = lpdmpd->hDlg;

    pShowViewNoAlloc(lpdmpd);
    //
    // show what we need for make forced config
    //
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_NO_CHANGE_TEXT), SW_SHOW);  // this may say why
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_MAKEFORCED), SW_SHOW);
}

VOID
pShowViewAllEdit(
    IN LPDMPROP_DATA lpdmpd
    )
/*++

Routine Description:

    Allow editing

Arguments:

    lpdmpd = property data

Return Value:

    none

--*/
{
    HWND hDlg = lpdmpd->hDlg;

    //
    // show middle controls for editing
    //
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_LCTEXT), SW_SHOW);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_LOGCONFIGLIST), SW_SHOW);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_NO_CHANGE_TEXT ), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_USESYSSETTINGS), SW_SHOW);
    ShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CHANGE), SW_SHOW); // shown, but disabled
    EnableWindow(GetDlgItem(hDlg, IDC_DEVRES_CHANGE), FALSE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_MAKEFORCED), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CONFLICTDEVTEXT), SW_SHOW); // show conflict information space
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CONFLICTINFOLIST), SW_SHOW);

    pShowUpdateEdit(lpdmpd);
}

VOID
pShowUpdateEdit(
    IN LPDMPROP_DATA lpdmpd
    )
/*++

Routine Description:

    Allow editing

Arguments:

    lpdmpd = property data

Return Value:

    none

--*/
{
    HWND hDlg = lpdmpd->hDlg;

    //
    // modify editing status - we can edit
    //
    lpdmpd->dwFlags &= ~DMPROP_FLAG_VIEWONLYRES;

    if(lpdmpd->dwFlags & DMPROP_FLAG_FORCEDONLY) {
        //
        // in this case, we will never be able to use system settings
        //
        lpdmpd->dwFlags &= ~ DMPROP_FLAG_USESYSSETTINGS;
        EnableWindow(GetDlgItem(hDlg, IDC_DEVRES_USESYSSETTINGS), FALSE);
    }
    //
    // indicate if it's system settings or not
    //
    CheckDlgButton(hDlg, IDC_DEVRES_USESYSSETTINGS,
                    (lpdmpd->dwFlags & DMPROP_FLAG_USESYSSETTINGS)?TRUE:FALSE);
    //
    // we can change logconfiglist if it's not system settings
    //
    EnableWindow(GetDlgItem(hDlg, IDC_DEVRES_LCTEXT), (lpdmpd->dwFlags & DMPROP_FLAG_USESYSSETTINGS)?FALSE:TRUE);
    EnableWindow(GetDlgItem(hDlg, IDC_DEVRES_LOGCONFIGLIST), (lpdmpd->dwFlags & DMPROP_FLAG_USESYSSETTINGS)?FALSE:TRUE);
    //
    // change "Change Settings" button
    //
    pCheckEnableResourceChange(lpdmpd);
}

BOOL
pLoadCurrentConfig(
    IN LPDMPROP_DATA lpdmpd,
    BOOL HideIfProb
    )
/*++

Routine Description:

    Modify the top part, to show current configuration, if any

Arguments:

    hDlg = dialog handle of controls
    lpdmpd = property data

Return Value:

    TRUE if we're showing current config

--*/
{
    TCHAR    szMessage[MAX_PATH];
    ULONG    Problem;
    ULONG    Status;
    HWND hDlg = lpdmpd->hDlg;
    HMACHINE hMachine = pGetMachine(lpdmpd);
    BOOL     DoLoadConfig = FALSE;

    lpdmpd->SelectedLC = 0;
    lpdmpd->SelectedLCType = lpdmpd->CurrentLCType;

    if (lpdmpd->CurrentLC != 0) {
        DoLoadConfig = TRUE;
    }
    if(HideIfProb && (lpdmpd->dwFlags & DMPROP_FLAG_HASPROBLEM)) {
        //
        // if there's a problem and HideIfProb is TRUE, don't bother showing current config
        //
        DoLoadConfig = FALSE;
    }
    if (DoLoadConfig) {
        //
        // load in current configuration
        //
        pLoadConfig(lpdmpd,lpdmpd->CurrentLC,lpdmpd->CurrentLCType);
        return TRUE;
    }
    //
    // case where there is no suitable configuration
    //
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_NO_RESOURCES_TEXT), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_SETTINGSLIST), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_LCTEXT), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_LOGCONFIGLIST), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_USESYSSETTINGS), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CHANGE), SW_HIDE);
    pShowViewNoAlloc(lpdmpd);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_SETTINGSTATE), SW_SHOW);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_NOALLOCTEXT), SW_SHOW);

    //
    // explain why there is a problem
    // goes into NOALLOCTEXT
    //
    LoadString(MyDllModuleHandle, IDS_DEVRES_NOALLOC_PROBLEM, szMessage, MAX_PATH);

    //
    // consider being more descriptive
    //
    if ((lpdmpd->lpdi->DevInst==0)
        || (CM_Get_DevNode_Status_Ex(&Status, &Problem, lpdmpd->lpdi->DevInst,
                                      0,hMachine) != CR_SUCCESS)) {
        Status = 0;
        Problem = 0;
    }

    if ((Status & DN_HAS_PROBLEM)!=0) {

        switch (Problem) {
            case CM_PROB_DISABLED:
            case CM_PROB_HARDWARE_DISABLED:
                LoadString(MyDllModuleHandle, IDS_DEVRES_NOALLOC_DISABLED, szMessage, MAX_PATH);
                break;

            case CM_PROB_NORMAL_CONFLICT:
                LoadString(MyDllModuleHandle, IDS_DEVRES_NORMAL_CONFLICT, szMessage, MAX_PATH);
                break;
            default:
                break;
        }
    }
    SetDlgItemText(hDlg, IDC_DEVRES_NOALLOCTEXT, szMessage);

    return FALSE; // display in NoAlloc state
}

BOOL
pConfigHasNoAlternates(
    LPDMPROP_DATA lpdmpd,
    LOG_CONF testLC
    )
/*++

Routine Description:

    A Basic config could be restrictive "these are the set of resources to use"
    This determines if the basic config passed is such a config

Arguments:

    testLC = basic config to test

Return Value:

    TRUE if it's a singular config

--*/
{
    HMACHINE      hMachine = NULL;
    PRESDES_ENTRY pConfigValues = NULL;
    PRESDES_ENTRY pValue = NULL;
    BOOL          bSuccess = TRUE;
    ULONG64       ulValue = 0, ulLen = 0, ulEnd = 0;
    ULONG         ulFlags = 0;
    PGENERIC_RESOURCE pGenRes = NULL;

    hMachine = pGetMachine(lpdmpd);
    pGetResDesDataList(testLC, &pConfigValues, TRUE, hMachine); // arbitratable resources
    for(pValue = pConfigValues;pValue;pValue = pValue->Next) {
        //
        // is this a singular value?
        //
        pGenRes = (PGENERIC_RESOURCE)(pValue->ResDesData);
        if(pGenRes->GENERIC_Header.GENERIC_Count != 1) {
            //
            // more than one entry - not singular
            //
            bSuccess = FALSE;
            break;
        }
        pGetRangeValues(pValue->ResDesData, pValue->ResDesType, 0, &ulValue, &ulLen, &ulEnd, NULL, &ulFlags);
        if (ulValue+(ulLen-1) != ulEnd) {
            //
            // not singular
            //
            bSuccess = FALSE;
            break;
        }
    }
    pDeleteResDesDataList(pConfigValues);

    return bSuccess;
}

BOOL
pLoadConfig(
    LPDMPROP_DATA lpdmpd,
    LOG_CONF forceLC,
    ULONG forceLCType
    )
/*++

Routine Description:

    Display a configuration

Arguments:

    hDlg = dialog handle of controls
    lpdmpd = property data
    forceLC = LogConf to display
    forceLCType = type for LogConf

Return Value:

    TRUE if config loaded

--*/
{
    HWND hDlg = lpdmpd->hDlg;
    CONFIGRET   Status = CR_SUCCESS;
    HWND        hWndList;
    LV_ITEM     lviItem;
    TCHAR       szTemp[MAX_PATH];
    int         iNewItem = 0;
    ULONG       ulSize,ulFlags;
    ULONG64     ulValue, ulLen, ulEnd, ulAlign;
    ULONG64     ulMaxMem = 0;
    ULONG       ulRange;
    LPBYTE      pData = NULL;
    RES_DES     ResDes;
    RESOURCEID  ResType;
    PITEMDATA   pItemData = NULL;
    HMACHINE    hMachine = NULL;
    PDEVICE_INFO_SET pDeviceInfoSet;
    BOOL        RetCode = FALSE;
    PRESDES_ENTRY pKnownValues = NULL;
    PRESDES_ENTRY pShowValues = NULL;
    PRESDES_ENTRY pShowEntry = NULL;
    BOOL        bFixedConfig = FALSE;
    BOOL        bNoMatch;
    BOOL        bFixed;
    ULONG       MatchLevel = NO_LC_MATCH;


    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_SETTINGSTATE), SW_SHOW);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_NO_RESOURCES_TEXT), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_SETTINGSLIST), SW_SHOW);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_NOALLOCTEXT), SW_HIDE);

    hWndList = GetDlgItem(hDlg, IDC_DEVRES_SETTINGSLIST);
    SendMessage(hWndList, WM_SETREDRAW, (WPARAM)FALSE, 0);
    ListView_DeleteAllItems(hWndList);

    lpdmpd->dwFlags |= DMPROP_FLAG_FIXEDCONFIG; // until we determine there is at least one setting we can edit


    if (forceLC == 0) {
        forceLC = lpdmpd->CurrentLC;
        forceLCType = lpdmpd->CurrentLCType;
    }
    if (forceLC == 0) {
        MYASSERT(FALSE);
        goto Final;
    }
    hMachine = pGetMachine(lpdmpd);

    //
    // setup values that will remain the same each time I add an item
    //
    lviItem.mask     = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    lviItem.pszText  = szTemp;          // reuse the szTemp buffer
    lviItem.iSubItem = 0;
    lviItem.iImage   = IDI_RESOURCE - IDI_RESOURCEFIRST;

    pGetResDesDataList(forceLC, &pShowValues, TRUE, hMachine); // editable resources
    if (forceLCType == BOOT_LOG_CONF || forceLCType == FORCED_LOG_CONF || forceLCType == ALLOC_LOG_CONF) {
        bFixedConfig = TRUE;
        if (forceLC == lpdmpd->CurrentLC && lpdmpd->MatchingLC != 0) {
            //
            // we're displaying CurrentLC, use flags & resdes's from matching LC where possible
            //
            if (pGetResDesDataList(lpdmpd->MatchingLC, &pKnownValues, TRUE, hMachine)) {
                //
                // match-up currentLC with some matching LC, so we can use flags/ranges from matching LC
                //
                MatchLevel = pMergeResDesDataLists(pShowValues,pKnownValues,NULL);
            }
        }
    } else if (lpdmpd->CurrentLC != 0) {
        //
        // the config we're displaying may allow ranges of values
        // we're going to try and match up what we are displaying to current config
        //
        if (pGetResDesDataList(lpdmpd->CurrentLC, &pKnownValues, TRUE, hMachine)) {
            //
            // try and use current values where possible
            //
            MatchLevel = pMergeResDesDataLists(pKnownValues,pShowValues,NULL);
        }
    }

    pShowEntry = pShowValues;

    while (pShowEntry) {
        bNoMatch = FALSE;
        bFixed = FALSE;
        ResDes = (RES_DES)0;
        ResType = pShowEntry->ResDesType;
        ulRange = 0;

        if (bFixedConfig) {
            //
            // we've got a current config
            //
            pGetHdrValues(pShowEntry->ResDesData, pShowEntry->ResDesType, &ulValue, &ulLen, &ulEnd, &ulFlags);
            if((ResType ==ResType_Mem) && (ulEnd > ulMaxMem)) {
                //
                // base our memory display on the fixed-config only
                //
                ulMaxMem = ulEnd;
            }
            if (pShowEntry->CrossLink) {
                //
                // use range's res-des
                //
                ResDes = pShowEntry->CrossLink->ResDesHandle;
                pShowEntry->CrossLink->ResDesHandle = (RES_DES)0;
                //
                // allow adjustment based on nearest basic config
                //
                pGetMatchingRange(ulValue,ulLen,pShowEntry->CrossLink->ResDesData, pShowEntry->CrossLink->ResDesType,&ulRange,&bFixed,NULL);
            } else {
                //
                // no range res-des
                //
                ResDes = (RES_DES)0;
                //
                // indicate that this is a non-adjustable value
                //
                bFixed = TRUE;
            }
        } else {
            //
            // we've got resource-ranges
            //
            if (pShowEntry->CrossLink) {
                //
                // take current settings from what we merged in
                //
                pGetHdrValues(pShowEntry->CrossLink->ResDesData, pShowEntry->CrossLink->ResDesType, &ulValue, &ulLen, &ulEnd, &ulFlags);
            } else {
                //
                // just take first range
                //
                pGetRangeValues(pShowEntry->ResDesData, pShowEntry->ResDesType, 0, &ulValue, &ulLen, &ulEnd, &ulAlign, &ulFlags);
            }
            //
            // range check if this is a memory resource - find highest memory value
            //
            if(ResType ==ResType_Mem) {
                ULONG64 HighVal;
                ULONG64 HighLen;
                if(LocateClosestValue(pShowEntry->ResDesData, pShowEntry->ResDesType,(ULONG64)(-1),ulLen, 0 ,&HighVal,&HighLen,NULL)) {
                    HighVal += HighLen-1;
                    if(HighVal > ulMaxMem) {
                        ulMaxMem = ulEnd;
                    }
                }
            }

            pGetMatchingRange(ulValue,ulLen,pShowEntry->ResDesData, pShowEntry->ResDesType,&ulRange,&bFixed,&ulFlags);
            //
            // use res-des from range
            //
            ResDes = pShowEntry->ResDesHandle;
            pShowEntry->ResDesHandle = (RES_DES)0;

            if (pShowEntry->CrossLink == NULL && bFixed == FALSE) {
                //
                // unknown value
                //
                bNoMatch = TRUE;
            }
        }

        if (ulLen>0) {
            //
            // Write first column text field (uses szTemp, lParam is res type)
            //
            LoadString(MyDllModuleHandle, IDS_RESOURCE_BASE + ResType, szTemp, MAX_PATH);
            ulRange = 0;

            pItemData = (PITEMDATA)MyMalloc(sizeof(ITEMDATA));
            if (pItemData != NULL) {
                pItemData->ResType = ResType;
                pItemData->MatchingResDes = ResDes;
                pItemData->RangeCount = ulRange;
                pItemData->ulValue = ulValue;                   // selected value
                pItemData->ulLen = ulLen;
                pItemData->ulEnd = ulValue + ulLen - 1;
                pItemData->ulFlags = ulFlags;
                pItemData->bValid = !bNoMatch;                  // if no chosen value
                pItemData->bFixed = bFixed;
            }
            if (bFixed == FALSE) {
                //
                // we have at least one editable value
                //
                lpdmpd->dwFlags &= ~DMPROP_FLAG_FIXEDCONFIG;
            }

            lviItem.iItem = iNewItem;
            lviItem.lParam = (LPARAM)pItemData;
            ListView_InsertItem(hWndList, &lviItem);

            //
            // Write second column text field (uses szTemp, lParam is res handle)
            //
            if (bNoMatch) {
                pFormatResString(lpdmpd,szTemp, 0, 0, ResType);
            } else {
                pFormatResString(lpdmpd,szTemp, ulValue, ulLen, ResType);
            }
            ListView_SetItemText(hWndList, iNewItem, 1, szTemp);

            ++iNewItem;
        }
        pShowEntry = pShowEntry->Next;
    }

    if(ulMaxMem > 0xFFFFFFFF) {
        //
        // an excuse to require 64-bit address range
        //
        lpdmpd->dwFlags |= DMPROP_FLAG_64BIT_RANGE;
    }

    SendMessage(hWndList, WM_SETREDRAW, (WPARAM)TRUE, 0);

    RetCode = TRUE;

Final:

    pDeleteResDesDataList(pKnownValues);
    pDeleteResDesDataList(pShowValues);

    //
    // initialize listview headings here
    //
    ListView_SetColumnWidth(hWndList, 0, LVSCW_AUTOSIZE_USEHEADER);
    ListView_SetColumnWidth(hWndList, 1, LVSCW_AUTOSIZE_USEHEADER);
    //
    // change "Change Settings" button
    //
    pCheckEnableResourceChange(lpdmpd);

    return RetCode;
}

BOOL
bIsMultiFunctionChild(
    PSP_DEVINFO_DATA lpdi,
    HMACHINE         hMachine
    )
/*++

Routine Description:

    Returns flag indicating if this is a child of a
    multifunction device
Arguments:

Return Value:

    TRUE if MF child

--*/
{
    ULONG   Status;
    ULONG   ProblemNumber;

    if (lpdi->DevInst) {

        if (CM_Get_DevNode_Status_Ex(&Status, &ProblemNumber,
                                  lpdi->DevInst, 0,hMachine) == CR_SUCCESS) {
            //
            // If the passed in dev is not an MF child, then it is the top
            // level MF_Parent
            //
            if (Status & DN_MF_CHILD) {
                return TRUE;
            } else {
                return FALSE;
            }
        }
    }

    return FALSE;

}

VOID
pSelectLogConf(
    LPDMPROP_DATA lpdmpd,
    LOG_CONF forceLC,
    ULONG forceLCType,
    BOOL Always
)
/*++

Routine Description:

    Selects a LogConf, showing the config in the LC control

Arguments:

Return Value:

    TRUE if MF child

--*/
{
    HWND hDlg = lpdmpd->hDlg;
    int count;
    int i;
    LOG_CONF LogConf;

    if (Always == FALSE && forceLC == lpdmpd->SelectedLC) {
        //
        // selection remains the same
        //
        return;
    }

    count = (int)SendDlgItemMessage(hDlg, IDC_DEVRES_LOGCONFIGLIST,CB_GETCOUNT, (WPARAM)0, (LPARAM)0);
    if (count == 0) {
        MYASSERT(FALSE/*shouldn't get here*/);
        pLoadCurrentConfig(lpdmpd,FALSE);
        return;
    }

    if (forceLC == 0 && lpdmpd->CurrentLC == 0) {
        //
        // no currentLC, so select first default
        //
        forceLC = (LOG_CONF)SendDlgItemMessage(hDlg, IDC_DEVRES_LOGCONFIGLIST,
                                               CB_GETITEMDATA, (WPARAM)0, (LPARAM)0);
        if (forceLC == (LOG_CONF)0) {
            MYASSERT(FALSE/*shouldn't get here*/);
            pLoadCurrentConfig(lpdmpd,FALSE);
            return;
        }
        forceLCType = lpdmpd->ConfigListLCType;
    }

    for (i=0;i<count;i++) {
        LogConf = (LOG_CONF)SendDlgItemMessage(hDlg, IDC_DEVRES_LOGCONFIGLIST,
                                               CB_GETITEMDATA, (WPARAM)i, (LPARAM)0);
        if (LogConf == forceLC) {
            //
            // set these first so we don't recurse around
            //
            lpdmpd->SelectedLC = forceLC;
            lpdmpd->SelectedLCType = forceLCType;
            //
            // change dialog to reflect new selection
            //
            SendDlgItemMessage(hDlg, IDC_DEVRES_LOGCONFIGLIST,CB_SETCURSEL, (WPARAM)i, (LPARAM)0);
            pLoadConfig(lpdmpd,forceLC,forceLCType);
            pShowConflicts(lpdmpd);
            return;
        }
    }
    SendDlgItemMessage(hDlg, IDC_DEVRES_LOGCONFIGLIST,CB_SETCURSEL, (WPARAM)(-1), (LPARAM)0);
    pLoadConfig(lpdmpd,forceLC,forceLCType);
    pShowConflicts(lpdmpd);
}


VOID
pChangeCurrentResSetting(
    IN LPDMPROP_DATA lpdmpd
    )
/*++

Routine Description:

    Brings up edit dialog to change currently selected resource

Arguments:

Return Value:

    none

--*/
{
    HWND                hDlg = lpdmpd->hDlg;
    RESOURCEEDITINFO    rei;
    HWND                hList =  GetDlgItem(hDlg, IDC_DEVRES_SETTINGSLIST);
    int                 iCur;
    PITEMDATA           pItemData = NULL;
    LV_ITEM             lviItem;
    GENERIC_RESOURCE    GenResInfo;
    PDEVICE_INFO_SET    pDeviceInfoSet;
    BOOL                changed = FALSE;
    TCHAR               szTemp[MAX_PATH];

    pItemData = pGetResourceToChange(lpdmpd,&iCur);
    if (pItemData == NULL) {
        //
        // we cannot edit this resource for some reason, give the user a hint
        // and maybe I'll get less ear-ache "I cannot change the settings"
        //
        if ((lpdmpd->dwFlags & DMPROP_FLAG_VIEWONLYRES)!=0 ||
                (lpdmpd->dwFlags & DMPROP_FLAG_USESYSSETTINGS)!=0) {
            //
            // editing not allowed - prob double-clicked on settings
            //
            return;
        }
        if (lpdmpd->dwFlags & DMPROP_FLAG_FIXEDCONFIG) {
            pWarnResSettingNotEditable(hDlg, IDS_DEVRES_NOMODIFYALL);
        } else {
            //
            // see if user needs to select a resource
            //
            iCur = (int)ListView_GetNextItem(hList,-1, LVNI_SELECTED);
            if (iCur == LB_ERR) {
                //
                // no selection
                //
                pWarnResSettingNotEditable(hDlg, IDS_DEVRES_NOMODIFYSELECT);
            } else {
                //
                // resource is just not editable
                //
                pWarnResSettingNotEditable(hDlg, IDS_DEVRES_NOMODIFYSINGLE);
            }
        }
        goto clean0;
    }

    ZeroMemory(&rei,sizeof(rei));
    rei.hMachine = pGetMachine(lpdmpd);
    rei.KnownLC = lpdmpd->CurrentLC;
    rei.MatchingBasicLC = lpdmpd->MatchingLC;
    rei.SelectedBasicLC = lpdmpd->SelectedLC;
    rei.lpdi = lpdmpd->lpdi;
    rei.dwPropFlags = lpdmpd->dwFlags;
    rei.bShareable = FALSE;
    rei.ridResType = pItemData->ResType;
    rei.ResDes = pItemData->MatchingResDes;
    rei.ulCurrentVal = pItemData->ulValue;
    rei.ulCurrentLen = pItemData->ulLen;
    rei.ulCurrentEnd = pItemData->ulEnd;
    rei.ulCurrentFlags = pItemData->ulFlags;
    rei.ulRangeCount = pItemData->RangeCount;
    rei.pData = NULL;

    if (DialogBoxParam(MyDllModuleHandle,
                       MAKEINTRESOURCE(IDD_EDIT_RESOURCE),
                       hDlg,
                       EditResourceDlgProc,
                       (LPARAM)(PRESOURCEEDITINFO)&rei) != IDOK) {
        goto clean0;
    }
    //
    // Update The Current Resource settings to Future
    // Settings, and update the Conflict list.
    //
    pItemData->ulValue = rei.ulCurrentVal;
    pItemData->ulLen = rei.ulCurrentLen;
    pItemData->ulEnd = rei.ulCurrentEnd;
    pItemData->ulFlags = rei.ulCurrentFlags;
    pItemData->RangeCount = rei.ulRangeCount;
    pItemData->bValid = TRUE; // indicate that user has explicitly changed this value

    pFormatResString(lpdmpd,szTemp,
                    rei.ulCurrentVal,
                    rei.ulCurrentLen,
                    rei.ridResType);

    ListView_SetItemText(hList, iCur, 1, szTemp);
    pShowConflicts(lpdmpd);

    //
    // clear the flag for saving changes
    //
    lpdmpd->dwFlags &= ~DMPROP_FLAG_CHANGESSAVED;
    PropSheet_Changed(GetParent(hDlg), hDlg);

clean0:
    ;
}

VOID
pShowConflicts(
    IN LPDMPROP_DATA lpdmpd
    )
/*++

Routine Description:

    Selects a LogConf, showing the config in the LC control

Arguments:

Return Value:

    TRUE if MF child

--*/
{
    HWND        hDlg = lpdmpd->hDlg;
    CONFIGRET   Status = CR_SUCCESS;
    LPVOID      vaArray[4];
    TCHAR       szTemp[MAX_PATH+4], szBuffer[MAX_PATH+16], szSetting[MAX_PATH];
    TCHAR       szFormat[MAX_PATH], szItemFormat[MAX_PATH];
    TCHAR       szUnavailable[MAX_PATH];
    LPTSTR      pszConflictList = NULL, pszConflictList2 = NULL;
    ULONG       ulSize = 0, ulLength, ulBufferLen, ulNewLength;
    ULONG       ulStartOffset = 0;
    int         Count = 0, i = 0;
    PITEMDATA   pItemData = NULL;
    LPBYTE      pResourceData = NULL;
    HWND        hwndResList = GetDlgItem(hDlg, IDC_DEVRES_SETTINGSLIST);
    HMACHINE    hMachine;
    ULONG       ConflictCount = 0;
    ULONG       ConflictIndex = 0;
    CONFLICT_LIST ConflictList = 0;
    PDEVICE_INFO_SET pDeviceInfoSet;
    CONFLICT_DETAILS ConflictDetails;
    BOOL        ReservedResource = FALSE;
    BOOL        AnyReportedResources = FALSE;
    BOOL        AnyBadResources = FALSE;
    PCONFLICT_EXCEPTIONS pConflictExceptions = NULL;
    //
    // number of resources listed
    //
    Count = ListView_GetItemCount(hwndResList);
    if (Count <= 0) {
       goto Clean0;
    }

    //
    // initial buffer that holds the strings
    // with all the conflict info in them
    //
    ulBufferLen = 2048;
    ulLength = 0;

    pszConflictList = MyMalloc(ulBufferLen * sizeof(TCHAR));
    if (pszConflictList == NULL) {
        goto Clean0;
    }
    pszConflictList[0] = 0;

    //
    // obtain machine
    //
    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdmpd->hDevInfo))) {
        goto Clean0;
    }
    hMachine = pDeviceInfoSet->hMachine;
    UnlockDeviceInfoSet (pDeviceInfoSet);

    //
    // do these once - these format strings use %1!s! type formats (FormatMessage)
    //
    LoadString(MyDllModuleHandle, IDS_CONFLICT_FMT, szFormat, MAX_PATH);
    LoadString(MyDllModuleHandle, IDS_CONFLICT_UNAVAILABLE, szUnavailable, MAX_PATH);

    //
    // for every listed resource
    //

    for (i = 0; i < Count; i++) {

        ConflictList = 0;
        ConflictCount = 0;

        //
        // get the resource we're about to test
        //
        pItemData = (PITEMDATA)pGetListViewItemData(hwndResList, i, 0);
        if (pItemData == NULL || pItemData->bValid == FALSE) {
            //
            // for whatever reason, we don't want to show conflict information on this resource
            //
            ListView_SetItemState(hwndResList, i,
                                  INDEXTOOVERLAYMASK(0),
                                  LVIS_OVERLAYMASK);
            goto NextResource;
        }

        //
        // this is set to indicate conflict not reported, but is reserved
        //
        ReservedResource = FALSE;

        //
        // need resource-data for determining conflict
        //
        if (MakeResourceData(&pResourceData, &ulSize,
                             pItemData->ResType,
                             pItemData->ulValue,
                             pItemData->ulLen,
                             pItemData->ulFlags)) {

            Status = CM_Query_Resource_Conflict_List(&ConflictList,
                                                        lpdmpd->lpdi->DevInst,
                                                        pItemData->ResType,
                                                        pResourceData,
                                                        ulSize,
                                                        DEVRES_WIDTH_FLAGS,
                                                        hMachine);

            if (Status != CR_SUCCESS) {
                //
                // on the unlikely event of an error, remember an error occurred
                //
                ConflictList = 0;
                ConflictCount =  0;
                AnyBadResources = TRUE;
            } else {
                //
                // find out how many things conflicted
                //
                Status = CM_Get_Resource_Conflict_Count(ConflictList,&ConflictCount);
                if (Status != CR_SUCCESS) {
                    MYASSERT(Status == CR_SUCCESS);
                    ConflictCount =  0;
                    AnyBadResources = TRUE;
                }
            }
            if(ConflictCount && (lpdmpd->dwFlags & DMPROP_FLAG_SINGLE_CONFIG) && !(lpdmpd->dwFlags & DMPROP_FLAG_HASPROBLEM)) {
                //
                // NTRAID#166214-2000/08/19-JamieHun Conflict Supression Hack
                //
                // rules are
                //   (1) device doesn't have a problem
                //   (2) device can only have one configuration (ie, there's no basic config, or the basic config is singular)
                //   (3) it has a ResourcePickerExceptions string, and that string indicates that the exception is allowed for the specific conflict

                if(pConflictExceptions==NULL) {
                    pConflictExceptions = pLoadConflictExceptions(lpdmpd);
                }

                if (pConflictExceptions) {

                    BOOL muted = TRUE;
                    //
                    // count from 0 (first conflict) through to ConflictCount (excl)
                    //
                    for(ConflictIndex = 0; ConflictIndex < ConflictCount; ConflictIndex ++) {
                        //
                        // obtain details for this conflict
                        //
                        ZeroMemory(&ConflictDetails,sizeof(ConflictDetails));
                        ConflictDetails.CD_ulSize = sizeof(ConflictDetails);
                        ConflictDetails.CD_ulMask = CM_CDMASK_DEVINST | CM_CDMASK_DESCRIPTION | CM_CDMASK_FLAGS;
                        Status = CM_Get_Resource_Conflict_Details(ConflictList,ConflictIndex,&ConflictDetails);
                        if (Status == CR_SUCCESS) {
                            if (!pIsConflictException(lpdmpd,pConflictExceptions,ConflictDetails.CD_dnDevInst,ConflictDetails.CD_szDescription,pItemData->ResType,pItemData->ulValue,pItemData->ulLen)) {
                                muted = FALSE;
                                break;
                            }
                        }
                    }
                    if(muted) {
                        ConflictCount = 0;
                    }
                }
            }
            if (ConflictCount || ReservedResource) {
                ulStartOffset = ulLength;  // record start in case we decide to backtrack
                AnyReportedResources = TRUE; // say we reported at least one problem

            TreatAsReserved:

                ulLength = ulStartOffset;
                pszConflictList[ulLength] = 0;
                //
                // we're going to mark the resource as a problem
                //

                ListView_GetItemText(hwndResList, i, 1, szSetting, MAX_PATH);


                switch (pItemData->ResType) {
                    case ResType_Mem:
                        LoadString(MyDllModuleHandle, IDS_MEMORY_FULL, szBuffer, MAX_PATH);
                        break;
                    case ResType_IO:
                        LoadString(MyDllModuleHandle, IDS_IO_FULL, szBuffer, MAX_PATH);
                        break;
                    case ResType_DMA:
                        LoadString(MyDllModuleHandle, IDS_DMA_FULL, szBuffer, MAX_PATH);
                        break;
                    case ResType_IRQ:
                        LoadString(MyDllModuleHandle, IDS_IRQ_FULL, szBuffer, MAX_PATH);
                        break;
                    default:
                        MYASSERT(FALSE);
                }

                if ( ReservedResource == FALSE) {

                    //
                    // count from 0 (header) 1 (first conflict) through to ConflictCount
                    //
                    for(ConflictIndex = 0; ConflictIndex <= ConflictCount; ConflictIndex ++) {
                        if (ConflictIndex == 0) {
                            //
                            // first pass through, do header message
                            //
                            vaArray[0] = szBuffer;
                            vaArray[1] = szSetting;
                            FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY ,
                                                szFormat,
                                                0,0,
                                                szTemp,MAX_PATH,
                                                (va_list*)vaArray); // FORMAT_MESSAGE_ARGUMENT_ARRAY

                        } else {

                            //
                            // obtain details for this conflict
                            //
                            ZeroMemory(&ConflictDetails,sizeof(ConflictDetails));
                            ConflictDetails.CD_ulSize = sizeof(ConflictDetails);
                            ConflictDetails.CD_ulMask = CM_CDMASK_DEVINST | CM_CDMASK_DESCRIPTION | CM_CDMASK_FLAGS;

                            Status = CM_Get_Resource_Conflict_Details(ConflictList,ConflictIndex-1,&ConflictDetails);
                            if (Status == CR_SUCCESS) {
                                if ((ConflictDetails.CD_ulFlags & CM_CDFLAGS_RESERVED) != 0) {
                                    //
                                    // treat as reserved - backtrack
                                    //
                                    ReservedResource = TRUE;
                                    goto TreatAsReserved;
                                } else {
                                    if (ConflictDetails.CD_szDescription[0] == 0) {
                                        //
                                        // treat as reserved - backtrack
                                        //
                                        ReservedResource = TRUE;
                                        goto TreatAsReserved;
                                    }
                                    wsprintf(szBuffer,TEXT("  %s\r\n"),ConflictDetails.CD_szDescription);
                                }
                            } else {
                                //
                                // treat as reserved
                                //
                                ReservedResource = TRUE;
                                goto TreatAsReserved;
                            }
                            lstrcpyn(szTemp,szBuffer,MAX_PATH);
                        }

                        ulNewLength = ulLength + lstrlen(szTemp);   // excluding terminating NUL

                        if ((ulNewLength+1) < ulBufferLen) {
                            //
                            // need to allocate more space - we'll double it and add some more every time
                            //
                            pszConflictList2 = MyRealloc(pszConflictList,(ulBufferLen+ulNewLength+1)  * sizeof(TCHAR));
                            if (pszConflictList2 != NULL) {
                                //
                                // succeeded in resizing buffer
                                //
                                pszConflictList = pszConflictList2;
                                ulBufferLen = ulBufferLen+ulNewLength+1;
                            }
                        }
                        if ((ulNewLength+1) < ulBufferLen) {
                            lstrcpy(pszConflictList + ulLength , szTemp);
                            ulLength = ulNewLength;
                        }

                    }
                } else {
                    //
                    // there is some other problem with resource
                    //

                    vaArray[0] = szBuffer;
                    vaArray[1] = szSetting;
                    FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY ,
                                        szUnavailable,
                                        0,0,
                                        szTemp,MAX_PATH,
                                        (va_list*)vaArray); // FORMAT_MESSAGE_ARGUMENT_ARRAY

                    ulNewLength = ulLength + lstrlen(szTemp);   // excluding terminating NUL

                    if ((ulNewLength+1) < ulBufferLen) {
                        //
                        // need to allocate more space - we'll double it and add some more every time
                        //
                        pszConflictList2 = MyRealloc(pszConflictList,(ulBufferLen+ulNewLength+1)  * sizeof(TCHAR));
                        if (pszConflictList2 != NULL) {
                            //
                            // succeeded in resizing buffer
                            //
                            pszConflictList = pszConflictList2;
                            ulBufferLen = ulBufferLen+ulNewLength+1;
                        }
                    }
                    if ((ulNewLength+1) < ulBufferLen) {
                        lstrcpy(pszConflictList + ulLength , szTemp);
                        ulLength = ulNewLength;
                    }
                }

                //
                // Set the Conflict Overlay for this resource.
                //
                ListView_SetItemState(hwndResList, i,
                               INDEXTOOVERLAYMASK(IDI_CONFLICT - IDI_RESOURCEOVERLAYFIRST + 1),
                               LVIS_OVERLAYMASK);

            } else {
                //
                // resource is (aparently) working fine
                //
                ListView_SetItemState(hwndResList, i,
                                      INDEXTOOVERLAYMASK(0),
                                      LVIS_OVERLAYMASK);
            }

            if (ConflictList) {
                CM_Free_Resource_Conflict_Handle(ConflictList);
            }

            if (pResourceData != NULL) {
                MyFree(pResourceData);
            }
        } else {
            //
            // couldn't make the resource descriptor
            AnyBadResources = TRUE;
        }

        NextResource:
            ;
    }


Clean0:
    ;

    //
    // If there were any conflicts, put the list in the multiline edit box.
    //
    if (AnyReportedResources) {
        SetDlgItemText(hDlg, IDC_DEVRES_CONFLICTINFOLIST, pszConflictList);
    } else if (AnyBadResources) {
        //
        // this would most likely occur on
        // (1) running this on 95/98 (shouldn't happen)
        // (2) using new setupapi on old cfgmgr32
        //
        LoadString(MyDllModuleHandle, IDS_CONFLICT_GENERALERROR, szBuffer, MAX_PATH);
        SetDlgItemText(hDlg, IDC_DEVRES_CONFLICTINFOLIST, szBuffer);
    } else {
        LoadString(MyDllModuleHandle, IDS_DEVRES_NOCONFLICTDEVS, szBuffer, MAX_PATH);
        SetDlgItemText(hDlg, IDC_DEVRES_CONFLICTINFOLIST, szBuffer);
    }
    if(pszConflictList != NULL) {
        MyFree(pszConflictList);
    }
    if (pConflictExceptions != NULL) {
        pFreeConflictExceptions(pConflictExceptions);
    }

    return;

}

int
pOkToSave(
    IN LPDMPROP_DATA lpdmpd
    )
/*++

Routine Description:

    Check to see if there's something the user hasn't done

Arguments:

Return Value:

    IDYES = save settings
    IDNO  = don't save settings
    IDCANCEL = don't exit

--*/
{
    HWND        hDlg = lpdmpd->hDlg;
    HWND        hList = GetDlgItem(hDlg, IDC_DEVRES_SETTINGSLIST);
    int         iCur;
    int         nRes;
    PITEMDATA   pItemData;

    if (lpdmpd->dwFlags & DMPROP_FLAG_NO_RESOURCES) {
        //
        // no changes - because there are no resources
        //
        return IDNO;
    }
    if (lpdmpd->dwFlags & DMPROP_FLAG_CHANGESSAVED) {
        //
        // no changes
        //
        return IDNO;
    }
    if (lpdmpd->dwFlags & DMPROP_FLAG_USESYSSETTINGS) {
        //
        // always ok to "use sys settings"
        //
        return IDYES;
    }
    //
    // user is forcing a config - let's see if all settings are valid
    //
    //
    // The resource descriptors are out-of-order.  Maintain the original ordering.
    //
    // First, build up a linked list of the data in the listview resource items.
    //
    iCur = (int)ListView_GetNextItem(hList, -1, LVNI_ALL);

    while (iCur >= 0) {

        pItemData = (PITEMDATA)pGetListViewItemData(hList, iCur, 0);
        if (pItemData) {
            if (pItemData->bValid == FALSE) {
                //
                // we've got an invalid entry - can't save
                //
                nRes = pWarnNoSave(hDlg,IDS_FORCEDCONFIG_PARTIAL);
                if (nRes != IDOK) {
                    return IDCANCEL;
                }
                return IDNO;
            }
        }

        iCur = (int)ListView_GetNextItem(hList, iCur, LVNI_ALL);
    }

    //
    // everything checks out
    //

    return IDYES;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\devoem.c ===
/*++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name:

    devoem.c

Abstract:

    Device Installer functions for dealing with OEM drivers.

Author:

    Lonny McMichael (lonnym) 10-Aug-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


BOOL
WINAPI
SetupDiAskForOEMDisk(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )
/*++

Routine Description:

    This routine displays a dialog asking for the path to an OEM install disk.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device being installed.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure for the device being installed.  If this parameter is not
        specified, then the driver being installed is associated with the
        global class driver list of the device information set itself.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the user cancels the dialog, the return value is FALSE, and GetLastError
    will return ERROR_CANCELLED.
    If the function fails, the return value is FALSE, and GetLastError returns
    an ERROR_* code.

Remarks:

    This routine will allow browsing of local and network drives for OEM install
    files.

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    TCHAR Title[MAX_TITLE_LEN];
    PDEVINSTALL_PARAM_BLOCK dipb;
    TCHAR PathBuffer[MAX_PATH];
    UINT PromptResult;
    LONG DriverPathId;

    //
    // Make sure we're running interactively.
    //
    if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
        SetLastError(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION);
        return FALSE;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        if(DeviceInfoData) {
            //
            // Then we are to prompt for an OEM driver for a particular device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }
            dipb = &(DevInfoElem->InstallParamBlock);
        } else {
            dipb = &(pDeviceInfoSet->InstallParamBlock);
        }

        if(!LoadString(MyDllModuleHandle,
                       IDS_OEMTITLE,
                       Title,
                       SIZECHARS(Title))) {
            Title[0] = TEXT('\0');
        }

        PromptResult = SetupPromptForDisk(dipb->hwndParent,
                                          (*Title) ? Title : NULL,
                                          NULL,
                                          pszOemInfDefaultPath,
                                          pszInfWildcard,
                                          NULL,
                                          IDF_OEMDISK | IDF_NOCOMPRESSED | IDF_NOSKIP,
                                          PathBuffer,
                                          SIZECHARS(PathBuffer),
                                          NULL
                                         );

        if(PromptResult == DPROMPT_CANCEL) {
            Err = ERROR_CANCELLED;
        } else {
            //
            // A choice was made--replace old path with new one.
            //
            if((DriverPathId = pStringTableAddString(
                                   pDeviceInfoSet->StringTable,
                                   PathBuffer,
                                   STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                   NULL,0)) == -1) {

                Err = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                dipb->DriverPath = DriverPathId;

            }
        }


clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiSelectOEMDrv(
    IN     HWND             hwndParent,    OPTIONAL
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )
/*++

Routine Description:

    This routine selects a driver for a device using an OEM path supplied by
    the user.

Arguments:

    hwndParent - Optionally, supplies a window handle that will be the parent
        of any dialogs created during this routine.  This parameter may be
        used to override the hwndParent field in the install parameters block
        of the specified device information set or element.

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device being installed.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure for the device being installed.  If this parameter is not
        specified, then the driver being installed is associated with the
        global class driver list of the device information set itself.

        This is an IN OUT parameter because the class GUID of this device
        information element will be updated upon return to reflect the class
        of the most-compatible driver found, if a compatible driver list was
        built.

Return Value:

    If the function succeeds (i.e., a driver is selected successfully), the
    return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    This routine will first ask the user for the OEM path, and will then call
    the class installer to select a driver from that OEM path.

--*/

{
    DWORD Err;

    //
    // Make sure we're running interactively.
    //
    if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
        SetLastError(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION);
        return FALSE;
    }

    Err = SelectOEMDriver(hwndParent, DeviceInfoSet, DeviceInfoData, FALSE);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


DWORD
SelectOEMDriver(
    IN     HWND             hwndParent,     OPTIONAL
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN     BOOL             IsWizard
    )
/*++

Routine Description:

    This is the worker routine that actually allows for the selection of an OEM driver.

Arguments:

    hwndParent - Optionally, supplies the window handle that is to be the parent for any
        selection UI.  If this parameter is not supplied, then the hwndParent field of
        the devinfo set or element will be used.

    DeviceInfoSet - Supplies the handle of the device info set for which an OEM driver
        selection is to be performed.

    DeviceInfoData - Optionally, supplies the address of the device information element to
        select a driver for.  If this parameter is not supplied, then an OEM driver for
        the global class driver list will be selected.

        If a compatible driver was found for this device, the device information element
        will have its class GUID updated upon return to reflect the device's new class.

    IsWizard - Specifies whether this routine is being called in the context of a select
        device wizard page.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is an ERROR_* code.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem = NULL;
    PDEVINSTALL_PARAM_BLOCK dipb;
    DWORD Err = NO_ERROR;
    HWND hwndSave;
    LONG DriverPathSave;
    DWORD DriverPathFlagsSave;
    BOOL bRestoreHwnd = FALSE, bRestoreDriverPath = FALSE, bUnlockDevInfoElem = FALSE;
    BOOL bDontSave = FALSE;
    UINT NewClassDriverCount;
    UINT NewCompatDriverCount;
    BOOL bAskAgain = TRUE;
    TCHAR Title[MAX_TITLE_LEN];
    DWORD SavedFlags;
    HCURSOR hOldCursor;

    PDRIVER_NODE lpOrgCompat;
    PDRIVER_NODE lpOrgCompatTail;
    UINT         OrgCompatCount;
    PDRIVER_NODE lpOrgClass;
    PDRIVER_NODE lpOrgClassTail;
    UINT         OrgClassCount;
    PDRIVER_NODE lpOrgSel;
    DWORD        dwOrgSelType;
    DWORD        dwOrgFlags;
    DWORD        dwOrgFlagsEx;
    BOOL         bRestoreDeviceInfo = FALSE;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        MYASSERT(FALSE);
        return ERROR_INVALID_HANDLE;
    }

    try {

        if(DeviceInfoData) {
            //
            // Then we're working with a particular device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }

            //
            // If the DevInfoElem isn't already locked, then lock it now, because
            // we're going to be calling the class installer, and we don't want to
            // allow it to delete this element!
            //
            if(!(DevInfoElem->DiElemFlags & DIE_IS_LOCKED)) {
                DevInfoElem->DiElemFlags |= DIE_IS_LOCKED;
                bUnlockDevInfoElem = TRUE;
            }

            dipb = &(DevInfoElem->InstallParamBlock);

        } else {
            dipb = &(pDeviceInfoSet->InstallParamBlock);
        }

        //
        // Make this selection window the parent window for OEM stuff
        //
        if(hwndParent) {
            hwndSave = dipb->hwndParent;
            dipb->hwndParent = hwndParent;
            bRestoreHwnd = TRUE;
        }

        //
        // Don't assume there is no old OEM path.  Save old one and
        // pretend there is no old one in case of cancel.
        //
        DriverPathSave = dipb->DriverPath;
        dipb->DriverPath = -1;

        //
        // Clear the DI_ENUMSINGLEINF flag, because we're going to be getting
        // a path to a directory, _not_ to an individual INF.  Also, clear the
        // DI_COMPAT_FROM_CLASS flag, because we don't want to build the compatible
        // driver list based on any class driver list.
        //
        DriverPathFlagsSave = dipb->Flags & (DI_ENUMSINGLEINF | DI_COMPAT_FROM_CLASS);
        dipb->Flags &= ~(DI_ENUMSINGLEINF | DI_COMPAT_FROM_CLASS);
        bRestoreDriverPath = TRUE;

        //
        // DO NOT break out of the following while loop unless bAskAgain is set to FALSE.
        // There is a check after this loop that assumes that if bAskAgain is still TRUE,
        // then an error occurred in SetupDiAskForOEMDisk, and GetLastError() is called
        // to determine what that error was.
        //
        while(bAskAgain && SetupDiAskForOEMDisk(DeviceInfoSet, DeviceInfoData)) {

            bAskAgain = FALSE;

            //
            // Save the Original List info, in case we get
            // an empty list on the user's selected path.
            //
            // (Note: we don't attempt to save/restore our driver enumeration
            // hints.)
            //
            if(!bDontSave) {

                if(DevInfoElem) {
                    lpOrgCompat     = DevInfoElem->CompatDriverHead;
                    lpOrgCompatTail = DevInfoElem->CompatDriverTail;
                    OrgCompatCount  = DevInfoElem->CompatDriverCount;

                    lpOrgClass      = DevInfoElem->ClassDriverHead;
                    lpOrgClassTail  = DevInfoElem->ClassDriverTail;
                    OrgClassCount   = DevInfoElem->ClassDriverCount;

                    lpOrgSel        = DevInfoElem->SelectedDriver;
                    dwOrgSelType    = DevInfoElem->SelectedDriverType;
                } else {
                    lpOrgClass      = pDeviceInfoSet->ClassDriverHead;
                    lpOrgClassTail  = pDeviceInfoSet->ClassDriverTail;
                    OrgClassCount   = pDeviceInfoSet->ClassDriverCount;

                    lpOrgSel        = pDeviceInfoSet->SelectedClassDriver;
                    dwOrgSelType    = lpOrgSel ? SPDIT_CLASSDRIVER : SPDIT_NODRIVER;
                }

                dwOrgFlags = dipb->Flags;
                dwOrgFlagsEx = dipb->FlagsEx;

                bRestoreDeviceInfo = TRUE;
            }

            if(DevInfoElem) {
                DevInfoElem->CompatDriverHead = DevInfoElem->CompatDriverTail = NULL;
                DevInfoElem->CompatDriverCount = 0;
                DevInfoElem->CompatDriverEnumHint = NULL;
                DevInfoElem->CompatDriverEnumHintIndex = INVALID_ENUM_INDEX;

                DevInfoElem->ClassDriverHead = DevInfoElem->ClassDriverTail = NULL;
                DevInfoElem->ClassDriverCount = 0;
                DevInfoElem->ClassDriverEnumHint = NULL;
                DevInfoElem->ClassDriverEnumHintIndex = INVALID_ENUM_INDEX;

                DevInfoElem->SelectedDriver = NULL;
                DevInfoElem->SelectedDriverType = SPDIT_NODRIVER;
            } else {
                lpOrgCompat     = NULL; // just so we won't ever try to free this list.

                pDeviceInfoSet->ClassDriverHead = pDeviceInfoSet->ClassDriverTail = NULL;
                pDeviceInfoSet->ClassDriverCount = 0;
                pDeviceInfoSet->ClassDriverEnumHint = NULL;
                pDeviceInfoSet->ClassDriverEnumHintIndex = INVALID_ENUM_INDEX;

                pDeviceInfoSet->SelectedClassDriver = NULL;
            }

            SavedFlags = dipb->Flags & (DI_SHOWOEM | DI_NODI_DEFAULTACTION);

            dipb->Flags   &= ~(DI_DIDCOMPAT | DI_DIDCLASS | DI_MULTMFGS | DI_SHOWOEM);
            dipb->FlagsEx &= ~(DI_FLAGSEX_DIDINFOLIST | DI_FLAGSEX_DIDCOMPATINFO);

            if(IsWizard) {
                //
                // We don't want default action taken in the wizard case.
                //
                dipb->Flags |= DI_NODI_DEFAULTACTION;
            }

            //
            // Unlock the HDEVINFO before handling the Select Device.  Otherwise, our
            // multi-threaded dialog will deadlock!
            //
            UnlockDeviceInfoSet(pDeviceInfoSet);
            pDeviceInfoSet = NULL;

            if(_SetupDiCallClassInstaller(DIF_SELECTDEVICE,
                                          DeviceInfoSet,
                                          DeviceInfoData,
                                          CALLCI_LOAD_HELPERS | CALLCI_CALL_HELPERS)) {
                Err = NO_ERROR;
            } else {
                Err = GetLastError();
            }

            //
            // Now, re-acquire the lock on our device information set.
            //
            if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
                //
                // we should never get here - could be indicative of
                // class/co-installer messing up
                //
                MYASSERT(pDeviceInfoSet);
                if (Err == NO_ERROR) {
                    Err = ERROR_INVALID_HANDLE;
                }
            }

            //
            // Restore the saved flags.
            //
            dipb->Flags = (dipb->Flags & ~(DI_SHOWOEM | DI_NODI_DEFAULTACTION)) | SavedFlags;

            //
            // If the class installer returned ERROR_DI_DO_DEFAULT, then
            // they either did not process the DIF_SELECTDEVICE, or they
            // have setup our device info structure with an OEM INF.
            //
            switch(Err) {

                case ERROR_DI_DO_DEFAULT :
                    //
                    // This case is only handled if we're in a wizard.  Otherwise, send it down
                    // for default processing.
                    //
                    if(!IsWizard) {
                        goto DefaultHandling;
                    }

                    //
                    // This will be the most likely return, since we are not allowing the
                    // default handler to be called.  So we will build a new class Drv list
                    // If it is empty we will ask again, otherwise we will accept the new
                    // selection and go on.
                    //
                    hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

                    SetupDiBuildDriverInfoList(DeviceInfoSet,
                                               DeviceInfoData,
                                               SPDIT_CLASSDRIVER
                                              );

                    SetupDiBuildDriverInfoList(DeviceInfoSet,
                                               DeviceInfoData,
                                               SPDIT_COMPATDRIVER
                                              );

                    SetCursor(hOldCursor);

                    if(DevInfoElem) {
                        NewClassDriverCount = DevInfoElem->ClassDriverCount;
                        NewCompatDriverCount = DevInfoElem->CompatDriverCount;
                    } else {
                        NewClassDriverCount = pDeviceInfoSet->ClassDriverCount;
                        NewCompatDriverCount = 0;
                    }

                    if(!NewClassDriverCount && !NewCompatDriverCount) {
                        //
                        // Error.
                        //
                        if(!LoadString(MyDllModuleHandle,
                                       IDS_SELECT_DEVICE,
                                       Title,
                                       SIZECHARS(Title))) {
                            *Title = TEXT('\0');
                        }

                        FormatMessageBox(MyDllModuleHandle,
                                         NULL,
                                         MSG_NO_DEVICEINFO_ERROR,
                                         Title,
                                         MB_OK | MB_TASKMODAL
                                        );

                        bDontSave = TRUE;

                        //
                        // Clean up anything that happened to get put in here.
                        //
                        if(DevInfoElem &&
                           (DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_DIDCOMPATINFO)) {
                            //
                            // The class installer built a compatible driver list--kill it here.
                            //
                            DestroyDriverNodes(DevInfoElem->CompatDriverHead, pDeviceInfoSet);

                            DevInfoElem->CompatDriverHead = DevInfoElem->CompatDriverTail = NULL;
                            DevInfoElem->CompatDriverCount = 0;
                            DevInfoElem->InstallParamBlock.Flags   &= ~DI_DIDCOMPAT;
                            DevInfoElem->InstallParamBlock.FlagsEx &= ~DI_FLAGSEX_DIDCOMPATINFO;

                            DevInfoElem->SelectedDriver = NULL;
                            DevInfoElem->SelectedDriverType = SPDIT_NODRIVER;
                        }
                        dipb->DriverPath = -1;

                        bAskAgain = TRUE;
                        break;
                    }
                    //
                    // Allow to fall through to handling of NO_ERROR which does clean-up for us.
                    //

                case NO_ERROR :
                    //
                    // Destroy the original lists
                    //
                    if(bRestoreDeviceInfo) {
                        DestroyDriverNodes(lpOrgCompat, pDeviceInfoSet);
                        DereferenceClassDriverList(pDeviceInfoSet, lpOrgClass);

                        bRestoreDeviceInfo = FALSE;
                    }

                    bRestoreDriverPath = FALSE;
                    break;

                case ERROR_DI_BAD_PATH :
                    //
                    // Pop up an error messagebox, then go try again.
                    //
                    if(!LoadString(MyDllModuleHandle,
                                   IDS_SELECT_DEVICE,
                                   Title,
                                   SIZECHARS(Title))) {
                        *Title = TEXT('\0');
                    }

                    FormatMessageBox(MyDllModuleHandle,
                                     NULL,
                                     MSG_NO_DEVICEINFO_ERROR,
                                     Title,
                                     MB_OK | MB_TASKMODAL
                                    );

                    bDontSave = TRUE;
                    dipb->DriverPath = -1;
                    bAskAgain = TRUE;

                    //
                    // Allow to fall through to default processing to delete the current
                    // driver list(s).
                    //

                default :
DefaultHandling:
                    //
                    // Destroy the current driver list(s).
                    //
                    if(DevInfoElem) {

                        DestroyDriverNodes(DevInfoElem->CompatDriverHead, pDeviceInfoSet);
                        DevInfoElem->CompatDriverHead = DevInfoElem->CompatDriverTail = NULL;
                        DevInfoElem->CompatDriverCount = 0;

                        DereferenceClassDriverList(pDeviceInfoSet, DevInfoElem->ClassDriverHead);
                        DevInfoElem->ClassDriverHead = DevInfoElem->ClassDriverTail = NULL;
                        DevInfoElem->ClassDriverCount = 0;

                        DevInfoElem->SelectedDriver = NULL;
                        DevInfoElem->SelectedDriverType = SPDIT_NODRIVER;

                    } else if(pDeviceInfoSet) {

                        DereferenceClassDriverList(pDeviceInfoSet, pDeviceInfoSet->ClassDriverHead);
                        pDeviceInfoSet->ClassDriverHead = pDeviceInfoSet->ClassDriverTail = NULL;
                        pDeviceInfoSet->ClassDriverCount = 0;

                        pDeviceInfoSet->SelectedClassDriver = NULL;
                    }
            }
        }

        if(bAskAgain) {
            //
            // Then SetupDiAskForOEMDisk failed.  Retrieve the error code.
            //
            Err = GetLastError();
        }

clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = GetLastError();
        //
        // Access the following variables so that the compiler will respect
        // the statement ordering in the try clause.
        //
        bRestoreDeviceInfo = bRestoreDeviceInfo;
        bUnlockDevInfoElem = bUnlockDevInfoElem;
        bRestoreHwnd = bRestoreHwnd;
        bRestoreDriverPath = bRestoreDriverPath;
        pDeviceInfoSet = pDeviceInfoSet;
    }

    //
    // If we need to restore any state, then we must make sure that we have the HDEVINFO
    // locked.
    //
    if(bRestoreDeviceInfo || bUnlockDevInfoElem || bRestoreHwnd || bRestoreDriverPath) {

        if(!pDeviceInfoSet && !(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            //
            // shouldn't get here, indicative of class/co-installer messing up
            //
            MYASSERT(pDeviceInfoSet);
            if (Err == NO_ERROR) {
                Err = ERROR_INVALID_HANDLE;
            }
        } else {
            try {
                //
                // If necessary, restore the original list(s).
                //
                if(bRestoreDeviceInfo) {

                    if(DevInfoElem) {

                        DestroyDriverNodes(DevInfoElem->CompatDriverHead, pDeviceInfoSet);
                        DevInfoElem->CompatDriverHead = lpOrgCompat;
                        DevInfoElem->CompatDriverTail = lpOrgCompatTail;
                        DevInfoElem->CompatDriverCount = OrgCompatCount;
                        lpOrgCompat = NULL;

                        DereferenceClassDriverList(pDeviceInfoSet, DevInfoElem->ClassDriverHead);
                        DevInfoElem->ClassDriverHead = lpOrgClass;
                        DevInfoElem->ClassDriverTail = lpOrgClassTail;
                        DevInfoElem->ClassDriverCount = OrgClassCount;
                        lpOrgClass = NULL;

                        DevInfoElem->SelectedDriver = lpOrgSel;
                        DevInfoElem->SelectedDriverType = dwOrgSelType;

                    } else {

                        DereferenceClassDriverList(pDeviceInfoSet, pDeviceInfoSet->ClassDriverHead);
                        pDeviceInfoSet->ClassDriverHead = lpOrgClass;
                        pDeviceInfoSet->ClassDriverTail = lpOrgClassTail;
                        pDeviceInfoSet->ClassDriverCount = OrgClassCount;
                        lpOrgClass = NULL;

                        pDeviceInfoSet->SelectedClassDriver = lpOrgSel;
                    }

                    dipb->Flags = dwOrgFlags;
                    dipb->FlagsEx = dwOrgFlagsEx;
                }

                //
                // If we locked the DevInfoElem just for this API, then unlock it now.
                //
                if(bUnlockDevInfoElem) {
                    MYASSERT(DevInfoElem);
                    DevInfoElem->DiElemFlags &= ~DIE_IS_LOCKED;
                }

                //
                // If the install param block needs its parent hwnd restored, do so now.
                //
                if(bRestoreHwnd) {
                    dipb->hwndParent = hwndSave;
                }

                //
                // Likewise, restore the old driver path if necessary.
                //
                if(bRestoreDriverPath) {
                    dipb->DriverPath = DriverPathSave;
                    dipb->Flags |= DriverPathFlagsSave;
                }

                ;   // nothing to do

            } except(EXCEPTION_EXECUTE_HANDLER) {

                if(bRestoreDeviceInfo) {
                    //
                    // If we hit an exception before we got a chance to restore any of our stored-away
                    // driver lists, then clean those up here.
                    //
                    if(DevInfoElem) {
                        if(lpOrgCompat) {
                            DestroyDriverNodes(lpOrgCompat, pDeviceInfoSet);
                        }
                        if(lpOrgClass) {
                            DereferenceClassDriverList(pDeviceInfoSet, lpOrgClass);
                        }
                    } else {
                        if(lpOrgClass) {
                            DereferenceClassDriverList(pDeviceInfoSet, lpOrgClass);
                        }
                    }
                }
            }
        }
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    return Err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\devres2.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    devres2.c

Abstract:

    Utility routines for resource matching

Author:

    Jamie Hunter (jamiehun) 9-July-1998

--*/

#include "precomp.h"
#pragma hdrstop

PRDE_LIST
pRDEList_Alloc()
/*++

Routine Description:

    Allocates a list-entry node

Arguments:

Return Value:

   PRDE_LIST entry

--*/
{
    PRDE_LIST Node;

    Node = (PRDE_LIST)MyMalloc(sizeof(RDE_LIST));
    if (Node == NULL) {
        return NULL;
    }
    Node->Prev = Node;
    Node->Next = Node;
    Node->Entry = NULL;
    return Node;
}

VOID
pRDEList_AddHead(
    IN OUT PRDE_LIST pList,
    IN PRDE_LIST Node
                 )
/*++

Routine Description:

    Adds a node to head of list

Arguments:

    pList =  pointer to list
    Node  =  node to add

Return Value:

   none

--*/
{
    MYASSERT(Node);
    MYASSERT(Node->Prev == Node);
    MYASSERT(Node->Next == Node);
    MYASSERT(pList);

    Node->Prev = pList;
    Node->Next = pList->Next;
    Node->Next->Prev = Node;
    pList->Next = Node; // Head
}

VOID
pRDEList_AddTail(
    IN OUT PRDE_LIST pList,
    IN PRDE_LIST Node
                 )
/*++

Routine Description:

    Adds a node to tail of list

Arguments:

    pList =  pointer to list
    Node  =  node to add

Return Value:

   none

--*/
{
    MYASSERT(Node);
    MYASSERT(Node->Prev == Node);
    MYASSERT(Node->Next == Node);
    MYASSERT(pList);

    Node->Next = pList;
    Node->Prev = pList->Prev;
    Node->Prev->Next = Node;
    pList->Prev = Node; // Tail
}

VOID
pRDEList_Remove(
    IN PRDE_LIST Node
                 )
/*++

Routine Description:

    Removes a node from list that node is member of

Arguments:

    Node  =  node to remove

Return Value:

   none

--*/
{
    MYASSERT(Node);

    if (Node->Prev == Node && Node->Next == Node) {
        //
        // already removed
        //
        return;
    }

    Node->Prev->Next = Node->Next;
    Node->Next->Prev = Node->Prev;
    Node->Next = Node;
    Node->Prev = Node;
}

PRDE_LIST
pRDEList_Find(
    IN PRDE_LIST pList,
    IN PRESDES_ENTRY pItem
    )
/*++

Routine Description:

    Looks for pItem in pList

Arguments:

    pList = list to search
    pItem = item to search for

Return Value:

   Node entry, or NULL

--*/
{
    PRDE_LIST Node;

    MYASSERT(pList);
    MYASSERT(pItem);

    Node = pList->Next; // head
    while (Node != pList) {
        if (Node->Entry == pItem) {
            return Node;
        }
        Node = Node->Next;
    }
    return NULL;
}


VOID
pRDEList_Destroy(
    IN PRDE_LIST pList
                 )
/*++

Routine Description:

    Destroy pList and everything on pList

Arguments:

    pList = list to destroy

Return Value:

   Node entry, or NULL

--*/
{
    PRDE_LIST Node,Next;

    if (pList == NULL) {
        return;
    }

    Node = pList; // head
    do
    {
        Next = Node->Next;
        MyFree(Node);       // this will free pList first, and then everything else on same list
        Node = Next;
    }
    while (Node != pList);
}

BOOL
pGetMatchingRange(
    IN ULONG64  ulKnownValue,
    IN ULONG64  ulKnownLen,
    IN LPBYTE   pData,
    IN RESOURCEID ResType,
    OUT PULONG  pRange,
    OUT PBOOL   pExact,
    OUT PULONG  pFlags
    )
/*++

Routine Description:

    Finds range index for resource inside ResDes

Arguments:

    ulKnownValue - base address
    ulKnownLen - length of resources
    pData/ResType - resource data we're comparing with
    pRange - output range index
    pExact - output true if there is only one range
    pFlags - output flags from matching range

Return Value:

   BOOL if match

--*/
{
    PGENERIC_RESOURCE pGenRes = NULL;
    ULONG64 ulValue = 0, ulLen = 0, ulEnd = 0;
    ULONG ulFlags = 0, i;

    pGenRes = (PGENERIC_RESOURCE)pData;

    for (i = 0; i < pGenRes->GENERIC_Header.GENERIC_Count; i++) {

        pGetRangeValues(pData, ResType, i, &ulValue, &ulLen, &ulEnd, NULL, &ulFlags);
        if (ulLen != ulKnownLen) {
            continue;
        }

        if ((ulKnownValue >= ulValue) &&
            ((ulKnownValue + ulLen - 1) <= ulEnd)) {

            if (pRange != NULL) {
                *pRange = i;
            }
            //
            // consider exact case
            //
            if (pExact != NULL) {
                if (pGenRes->GENERIC_Header.GENERIC_Count==1 && ulValue == ulKnownValue && (ulKnownValue + ulLen - 1) == ulEnd) {
                    *pExact = TRUE;
                }
            }
            if (pFlags != NULL) {
                //
                // want nearest flags
                //
                *pFlags = ulFlags;
            }

            return TRUE;
        }
    }
    if (pRange != NULL) {
        *pRange = 0;
    }
    return FALSE;
}


ULONG
pTryMatch(
    IN OUT PRESDES_ENTRY pKnown,
    IN OUT PRDE_LIST pResList,
    IN OUT PULONG pDepth
    )
/*++

Routine Description:

    Looks for best match of remaining requirements in
    remaining available resources
    returns number of matched requirements

Arguments:

    pKnown - requirements list (what is remaining)
    pResList - list of available resources

Return Value:

   Node entry, or NULL

--*/
{
    ULONG ThisBest = 0;
    ULONG MyBest = 0;
    PRDE_LIST pIterator = NULL;
    PRESDES_ENTRY pRange;
    ULONG64  ulValue, ulLen, ulEnd;
    ULONG  ulFlags;
    BOOL Exact = FALSE;
    ULONG Best = 0;
    PRDE_LIST pBestRes = NULL;
    BOOL BadMatch = FALSE;
    BOOL Prune = FALSE;
    BOOL NoRemaining = TRUE;

    MYASSERT(pDepth);
    *pDepth = 0;

    if (pKnown == NULL) {
        //
        // end recursion
        //
        return 0;
    }
    pKnown->CrossLink = NULL;

    //
    // we're looking for a match in pResList for pKnown
    // case (1) get a "Best" for if we decide not to match
    // case (2) get a "Best" for exact match, and chose between (1) and (2) if one exists
    // case (3) get a "Best" for each possible range match and choose best between (1) and all (3)
    //

    //
    // consider case(1) - what the results would be if we wasn't able to fit anything in
    //
    //Best = pTryMatch(pKnown->Next,pResList,pDepth);
    //pBestRes = NULL;

    pGetHdrValues(pKnown->ResDesData, pKnown->ResDesType, &ulValue, &ulLen, &ulEnd, &ulFlags);

    //
    // consider case(2) and (3) together
    //
    for(pIterator = pResList->Next;pIterator!=pResList;pIterator = pIterator->Next) {
        //
        // iterate through remaining resources
        //
        pRange = pIterator->Entry;
        if (pRange == NULL) {
            //
            // this has been used
            //
            continue;
        }
        if (pRange->ResDesType != pKnown->ResDesType) {
            //
            // not the kind of resource i'm looking for
            //
            continue;
        }
        NoRemaining = FALSE;
        if(pGetMatchingRange(ulValue, ulLen,pRange->ResDesData, pRange->ResDesType,NULL,&Exact,NULL)) {
            pIterator->Entry = NULL; // eliminate this range
            ThisBest = pTryMatch(pKnown->Next,pResList,pDepth); // match the rest, with us using this resource-range
            pIterator->Entry = pRange;
            if ((ThisBest > Best) || (pBestRes == NULL)) {
                //
                // the current best match (or first match if pBestRes == NULL)
                //
                pKnown->CrossLink = pRange;
                pBestRes = pIterator;
                Best = ThisBest;
                MyBest = 1;
                BadMatch = FALSE;
            } else {
                //
                // need to re-do best match
                //
                BadMatch = TRUE;
            }
            if (Exact || (*pDepth == ThisBest)) {
                //
                // prune - we're either exact, or got a perfect match
                //
                Prune = TRUE;
                goto Final;
            }
        }
    }

    if (NoRemaining) {
        //
        // I have no resources remaining I can use - consider this as good as a match
        // but we need to continue up the tree
        //
        Best = pTryMatch(pKnown->Next,pResList,pDepth); // match the rest, with us using this resource-range
        MyBest = TRUE;
        BadMatch = FALSE;
        goto Final;
    }

    //
    // if we get here we've:
    // (1) found a flexable match, but wasn't able to match everyone above us, or
    // (2) not found any match
    // note that if last best was n with us matching and this best is n+1 without
    // then we don't lose the best
    // consider if overall we'd do any better if we gave up our resources to someone else
    //
    if((pBestRes == NULL) || ((Best+MyBest) < *pDepth)) {
        //
        // if we had a match, only worth checking if we could increase best by more than MyBest
        // note that *pDepth is only valid if pBestRes != NULL
        //
        ThisBest = pTryMatch(pKnown->Next,pResList,pDepth);
        if ((ThisBest > (Best+MyBest)) || (pBestRes == NULL)) {
            //
            // the current best match
            //
            pKnown->CrossLink = NULL;
            pBestRes = NULL;
            Best = ThisBest;
            MyBest = 0;
            BadMatch = FALSE;
        } else {
            //
            // need to re-do best match
            //
            BadMatch = TRUE;
        }
    }

Final:

    if (BadMatch) {
        //
        // We had a bad-match since our last good match
        //
        if (pBestRes) {
            pRange = pBestRes->Entry; // the range we determined was our best bet
            pBestRes->Entry = NULL; // eliminate this range
            Best = pTryMatch(pKnown->Next,pResList,pDepth); // match the rest, with us using this resource-range
            pBestRes->Entry = pRange;
            pKnown->CrossLink = pRange;
            MyBest = 1;
        } else {
            Best = pTryMatch(pKnown->Next,pResList,pDepth); // match the rest, with us not using this resource range
            pKnown->CrossLink = NULL;
            MyBest = 0;
        }
    }

    //
    // if we found a match, we've saved it in pKnown->CrossLink
    // return Best+0 if it's better we don't fit our resource in, Best+1 otherwise
    // returns *pDepth = Best+1 if everyone (me up) fit their resources in
    //

    (*pDepth)++; // increment to include me
    return Best+MyBest; // MyBest = 1 if I managed to match my resource (or no resources left), Best = everyone to the right of me
}

ULONG
pMergeResDesDataLists(
    IN OUT PRESDES_ENTRY pKnown,
    IN OUT PRESDES_ENTRY pTest,
    OUT PULONG pMatchCount
    )
/*++

Routine Description:

    Map entries in pKnown into pTest
    as best as possible

Arguments:

    pKnown - list of known values
    pTest - list of ranges
    pMatchCount - set to be number of resources matched

Return Value:

    NO_LC_MATCH  if no correlation (not a single known matches)
    LC_MATCH_SUPERSET if at least one known matches, but some known's don't
    LC_MATCH_SUBSET if all known matches, but there are some range-items unmatched
    LC_MATCH if all known matches and all range-items match
    ORDERED_LC_MATCH if match, and match is in order

    pKnown->CrossLink entries point to matching entries in pTest
    pTest->CrossLink entries point to matching entries in pKnown

--*/
{
    PRDE_LIST pResList = NULL;
    PRDE_LIST Node;
    PRESDES_ENTRY pKnownEntry;
    PRESDES_ENTRY pTestEntry;
    ULONG Success = NO_LC_MATCH;
    ULONG Depth = 0;
    BOOL SomeKnownMatched = FALSE;
    BOOL SomeKnownUnMatched = FALSE;
    BOOL SomeTestMatched = FALSE;
    BOOL SomeTestUnMatched = FALSE;
    BOOL Ordered = TRUE;
    ULONG MatchCount = 0;

    if (pKnown == NULL) {
        goto Final;
    }

    //
    // reset
    //
    for(pKnownEntry = pKnown; pKnownEntry != NULL ;pKnownEntry = pKnownEntry->Next) {
        pKnownEntry->CrossLink = NULL;
    }

    for(pTestEntry = pTest; pTestEntry != NULL ;pTestEntry = pTestEntry->Next) {
        pTestEntry->CrossLink = NULL;
    }

    pResList = pRDEList_Alloc();

    if (pResList == NULL) {
        goto Final;
    }

    //
    // make all resources available
    // this gives us a work list without destroying original list
    //
    for(pTestEntry = pTest; pTestEntry != NULL ;pTestEntry = pTestEntry->Next) {
        Node = pRDEList_Alloc();

        if (Node == NULL) {
            goto Final;
        }
        Node->Entry = pTestEntry;
        pRDEList_AddTail(pResList,Node);
    }

    MatchCount = pTryMatch(pKnown,pResList,&Depth);

    if (MatchCount ==0) {
        //
        // no match
        //
        goto Final;
    }

    //
    // pKnown now has it's Cross-Link's set to determine success of this match
    //
    // consider NO_LC_MATCH, LC_MATCH_SUPERSET and ORDERED_LC_MATCH cases
    //

    pKnownEntry = pKnown;
    pTestEntry = pTest;

    while (pKnownEntry) {
        if (pKnownEntry->CrossLink == NULL) {
            SomeKnownUnMatched = TRUE;
        } else {
            SomeKnownMatched = TRUE;    // we have at least one matched
            pKnownEntry->CrossLink->CrossLink = pKnownEntry; // cross-link test entries
            if (pKnownEntry->CrossLink != pTestEntry) {
                Ordered = FALSE;        // ordered compare lost
            } else {
                pTestEntry = pTestEntry->Next; // goto next test for ordered
            }
        }
        pKnownEntry = pKnownEntry->Next;
    }
    if (Ordered && pTestEntry != NULL) {
        Ordered = FALSE;
    }

    if (SomeKnownUnMatched) {
        if (SomeKnownMatched) {
            Success = LC_MATCH_SUPERSET;
        }
        goto Final;
    }

    if (Ordered) {
        Success = ORDERED_LC_MATCH;
        goto Final;
    }

    //
    // consider between LC_MATCH_SUBSET and LC_MATCH
    //
    pTestEntry = pTest;

    while (pTestEntry) {
        if (pTestEntry->CrossLink == NULL) {
            //
            // the first NULL CrossLink entry makes Known a Subset of Test
            Success = LC_MATCH_SUBSET;
            goto Final;
        }
        pTestEntry = pTestEntry->Next;
    }
    //
    // if we get here, there is an exact match
    //
    Success = LC_MATCH;

  Final:
    pRDEList_Destroy(pResList);

    if (pMatchCount != NULL) {
        *pMatchCount = MatchCount;
    }

    return Success;
}

ULONG
pCompareLogConf(
    IN LOG_CONF KnownLogConf,
    IN LOG_CONF TestLogConf,
    IN HMACHINE hMachine,
    OUT PULONG pMatchCount
    )

/*++

Routine Description:

    This routine compares two log confs and returns info about how well
    they match.
    This simply uses the pMergeResDesDataLists function to get match status

Arguments:

   KnownLogConf = First log conf to compare (fixed values)
   TestConfType = Second log conf to compare (range values)
   hMachine = Machine to compare on
   pMatchCount = number of resources matched

Return Value:

    As pMergeResDesDataLists

--*/

{
    PRESDES_ENTRY pKnownResList = NULL, pTestResList = NULL;
    ULONG Status;

    //
    // Retrieve the resources for each log conf
    //

    if (!pGetResDesDataList(KnownLogConf, &pKnownResList, TRUE,hMachine)) {
        if (pMatchCount) {
            *pMatchCount = 0;
        }
        return NO_LC_MATCH;
    }

    if (!pGetResDesDataList(TestLogConf, &pTestResList, TRUE,hMachine)) {
        pDeleteResDesDataList(pKnownResList);
        if (pMatchCount) {
            *pMatchCount = 0;
        }
        return NO_LC_MATCH;
    }

    Status = pMergeResDesDataLists(pKnownResList,pTestResList,pMatchCount);

    pDeleteResDesDataList(pKnownResList);
    pDeleteResDesDataList(pTestResList);

    return Status;
}

BOOL
pFindMatchingAllocConfig(
    IN  LPDMPROP_DATA lpdmpd
    )
{
    HWND     hDlg = lpdmpd->hDlg;
    ULONG    ulBasicLC = 0;
    ULONG    ulBasicCount = 0;
    BOOL     bFoundCorrectLC = FALSE;
    LOG_CONF LogConf;
    ULONG    lastMatchStatus = NO_LC_MATCH, bestMatchStatus = NO_LC_MATCH;
    UINT lastMatchCount;
    UINT bestMatchCount = 0;
    HMACHINE hMachine;

    hMachine = pGetMachine(lpdmpd);

    lpdmpd->MatchingLC = (LOG_CONF)0;
    lpdmpd->MatchingLCType = BASIC_LOG_CONF;

    //
    // Load the values associated with the allocated config in the list box,
    // but associate each with the resource requirements descriptor that it
    // originated from. To do this, we have to match the allocated config
    // with the basic/filtered config it is based on.
    //
    // NOTE: if we got here, then we know that an known config of some kind
    // exists (passed in as param) and that at least one basic/filtered config
    // exists. Further more, we know that the combobox has already been
    // filled in with a list of any basic/filtered configs and the lc handle
    // associated with them.
    //

    ulBasicCount = (ULONG)SendDlgItemMessage(hDlg,IDC_DEVRES_LOGCONFIGLIST,CB_GETCOUNT,
                                                        (WPARAM)0,(LPARAM)0);
    if (ulBasicCount == (ULONG)LB_ERR) {
        return FALSE;
    }

    for (ulBasicLC = 0 ; ulBasicLC < ulBasicCount; ulBasicLC++) {
        //
        // Retrieve the log conf handle
        //

        LogConf = (LOG_CONF)SendDlgItemMessage(hDlg, IDC_DEVRES_LOGCONFIGLIST,
                                               CB_GETITEMDATA, ulBasicLC, 0L);

        if (LogConf != 0) {
            //
            // Determine how good a match this requirements list is.
            //

            lastMatchStatus = pCompareLogConf(lpdmpd->CurrentLC, LogConf,hMachine,&lastMatchCount);
            if ((lastMatchStatus > bestMatchStatus)
                ||  ((bestMatchStatus == lastMatchStatus) && lastMatchCount > bestMatchCount)) {
                bestMatchCount = lastMatchCount;
                bestMatchStatus =lastMatchStatus;
                lpdmpd->MatchingLC = LogConf;
            }
        }
    }

    if (bestMatchStatus == NO_LC_MATCH || bestMatchStatus == LC_MATCH_SUBSET) {
        //
        // this doesn't follow any valid config
        //
        return FALSE;
    }

    lpdmpd->dwFlags &= ~(DMPROP_FLAG_PARTIAL_MATCH|DMPROP_FLAG_MATCH_OUT_OF_ORDER);
    if (bestMatchStatus != ORDERED_LC_MATCH) {
        //
        // If match status isn't ORDERED_LC_MATCH, then ordering of the resource descriptors
        // didn't match up.  Set a flag to indicate this, so that later on we'll know to handle
        // this specially.
        //
        lpdmpd->dwFlags |= DMPROP_FLAG_MATCH_OUT_OF_ORDER;
    } else if (bestMatchStatus < LC_MATCH) {
        //
        // match is partial
        //
        lpdmpd->dwFlags |= DMPROP_FLAG_PARTIAL_MATCH;
    }
    return TRUE;

} // LoadMatchingAllocConfig

BOOL
pGetMatchingResDes(
    IN ULONG64    ulKnownValue,
    IN ULONG64    ulKnownLen,
    IN ULONG64    ulKnownEnd,
    IN RESOURCEID ResType,
    IN LOG_CONF   MatchingLogConf,
    OUT PRES_DES  pMatchingResDes,
    IN HMACHINE   hMachine
    )
/*++

Routine Description:

    This returns a res des that matches the specified values.
    used by pSaveCustomResSettings

Arguments:

    ulKnownValue    Starting resource value to match against

    ulKnownLen      Length of resource to match against

    ResType         Type of resource to match against

    MatchnigLogConf Log conf to retreive potential matching res des from

    pMatchingResDes Supplies a pointer that on return contains a matching
                    res des if any.

Return Value:

   None.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    RESOURCEID  Res;
    RES_DES     ResDes, ResDesTemp;
    ULONG64     ulValue = 0, ulLen = 0, ulEnd = 0;
    ULONG       ulSize, ulFlags = 0, i;
    PGENERIC_RESOURCE   pGenRes;
    BOOL        bMatch = FALSE;
    LPBYTE      pData = NULL;


    //
    // The MatchingLogConf is a requirements list. Loop through each res des
    // in the matching log conf until we find a res des that matches the
    // known res des values.
    //
    Status = CM_Get_Next_Res_Des_Ex(&ResDes, MatchingLogConf, ResType, &Res, 0,hMachine);

    while (Status == CR_SUCCESS) {
        //
        // Get res des data
        //
        if (CM_Get_Res_Des_Data_Size_Ex(&ulSize, ResDes, CM_RESDES_WIDTH_64,hMachine) != CR_SUCCESS) {
            CM_Free_Res_Des_Handle(ResDes);
            break;
        }

        pData = MyMalloc(ulSize);
        if (pData == NULL) {
            CM_Free_Res_Des_Handle(ResDes);
            break;
        }

        if (CM_Get_Res_Des_Data_Ex(ResDes, pData, ulSize, DEVRES_WIDTH_FLAGS,hMachine) != CR_SUCCESS) {
            CM_Free_Res_Des_Handle(ResDes);
            MyFree(pData);
            break;
        }

        if(pGetMatchingRange(ulKnownValue,ulKnownLen,pData,ResType,NULL,NULL,NULL)) {
            *pMatchingResDes = ResDes;
            bMatch = TRUE;
            MyFree(pData);
            goto MatchFound;
        }

        //
        // Get next res des in log conf
        //
        ResDesTemp = ResDes;
        Status = CM_Get_Next_Res_Des_Ex(&ResDes, ResDesTemp,
                                     ResType, &Res, 0,hMachine);

        CM_Free_Res_Des_Handle(ResDesTemp);
        MyFree(pData);
    }

    MatchFound:

    return bMatch;

} // GetMatchingResDes



//
// NTRAID#166214-2000/08/19-JamieHun Conflict Supression Hack
// this stuff needs to be fixed proper
//

PTSTR
pGetRegString(
    IN HKEY hKey,
    IN PCTSTR regval
    )
/*++

Routine Description:

    Obtain and return a registry string allocated by MyMalloc
    return NULL if we couldn't retrieve string

Arguments:

    hKey - key to retrieve string from
    regval - value to retrieve

Return Value:

    copy of registry string, may be free'd with MyFree

--*/
{
    DWORD dwSize;
    DWORD dwType;
    PTSTR pSz;
    LONG res;

    dwType = 0;
    dwSize = 0;
    res = RegQueryValueEx(hKey,regval,NULL,&dwType,(PBYTE)NULL,&dwSize);
    if (res != ERROR_SUCCESS) {
        return NULL;
    }
    if (dwType != REG_SZ) {
        return NULL;
    }
    pSz = MyMalloc(dwSize);
    if (pSz == NULL) {
        return NULL;
    }
    res = RegQueryValueEx(hKey,regval,NULL,&dwType,(PBYTE)pSz,&dwSize);
    if (res != ERROR_SUCCESS) {
        MyFree(pSz);
        return NULL;
    }
    return pSz;
}

VOID
pFillCETags(
    IN PCONFLICT_EXCEPTIONS pExceptions,
    IN PCE_TAGS pTags,
    PTSTR pSz
    )
/*++

Routine Description:

    parse a list of tags into CE_TAGS structure
    adding the strings into the string table en-route
    note that this structure will be flexable and allow ',' or ';' seperator
    however when used in Exceptions string, we've already eliminated any ';'

    format is:
    <tag>,<tag>,<tag> or <tag>;<tag>;<tag>

Arguments:

    pExceptions - context information
    pTags - tag structure to fill in

Return Value:

    none

--*/
{
    static CE_TAGS DummyEntry = { -1 }; // if we write a new string, negative size count means this isn't a devnode entry

    MYASSERT(pTags->nTags == 0);

    while(pSz[0] && pTags->nTags < MAX_CE_TAGS) {
        if(pSz[0]==TEXT(',')||pSz[0]==TEXT(';')||pSz[0]<=TEXT(' ')) {
            pSz++;
        } else {
            PTSTR pOldSz = pSz;
            PTSTR pLastSpace = NULL;
            LONG id;
            while (pSz[0] && pSz[0]!=TEXT(';')&& pSz[0]!=TEXT(',')) {
                if (pSz[0]<=TEXT(' ')) {
                    if (pLastSpace==NULL) {
                        pLastSpace = pSz;
                    }
                } else {
                    pLastSpace = NULL;
                }
                pSz++;
            }
            //
            // pSz points to '\0', ';' or ','
            // pLastSpace points to any trailing WS
            // pOldSz points to start of string
            //
            if(pLastSpace==NULL) {
                pLastSpace = pSz;
            }
            if (pSz[0]) {
                pSz++;
            }
            pLastSpace[0]=TEXT('\0');
            //
            // pSz points to next string, pOldSz points to this string
            // add string to string table, place in list of tags
            //
            id = pSetupStringTableAddStringEx(pExceptions->ceTagMap,pOldSz,STRTAB_CASE_INSENSITIVE|STRTAB_BUFFER_WRITEABLE,&DummyEntry,sizeof(DummyEntry));
            if (id>=0) {
                pTags->Tag[pTags->nTags++] = id;
            }
        }
    }
}

PCE_ENTRY
pScanConflictExceptionEntry(
    IN PCONFLICT_EXCEPTIONS pExceptions,
    PTSTR pSz
    )
/*++

Routine Description:

    obtains conflict exception info from string

    format is:
    (1)  <tags>          - always ignore tag for any type of conflict
    (2)  <rt>:<tags>     - ignore tag for <rt> resource type
    (3)  <rt>@x:<tags>   - IRQ/DMA - specfic
    (4)  <rt>@x-y:<tags> - IO/MEM - range

    <tags>  are a comma-sep list of tags <tag>,<tag>,<tag>

Arguments:

    pExceptions - context information
    pSz - string to parse

Return Value:

    CE_ENTRY structure if this is a valid descriptor

--*/
{
    PTSTR brk;
    PCE_ENTRY pEntry;
    TCHAR rt[5];
    int c;

    while (pSz[0] && pSz[0]<=TEXT(' ')) {
        pSz++;
    }
    if (!pSz[0]) {
        return NULL;
    }

    pEntry = MyMalloc(sizeof(CE_ENTRY));

    if (pEntry == NULL) {
        return NULL;
    }
    ZeroMemory(pEntry,sizeof(CE_ENTRY));

    brk = _tcschr(pSz,TEXT(':'));

    if(!brk) {
        //
        // treat as tags only
        //
        pEntry->resType = ResType_None;
    } else {
        //
        // determine resource type
        //
        for(c=0;_istalpha(pSz[0]) && c<(sizeof(rt)/sizeof(TCHAR)-1);c++,pSz++) {
            rt[c] = (TCHAR)_totupper(pSz[0]);
        }
        rt[c] = 0;
        while (pSz[0] && pSz[0]<=TEXT(' ')) {
            pSz++;
        }
        if (pSz[0]!=TEXT(':') && pSz[0]!=TEXT('@')) {
            MyFree(pEntry);
            return NULL;
        } else if (lstrcmp(rt,CE_RES_IO)==0) {
            pEntry->resType = ResType_IO;
        } else if (lstrcmp(rt,CE_RES_MEM)==0) {
            pEntry->resType = ResType_Mem;
        } else if (lstrcmp(rt,CE_RES_IRQ)==0) {
            pEntry->resType = ResType_IRQ;
        } else if (lstrcmp(rt,CE_RES_DMA)==0) {
            pEntry->resType = ResType_DMA;
        } else {
            MyFree(pEntry);
            return NULL;
        }
        if (pSz[0]!=TEXT('@')) {
            //
            // no range follows
            //
            pEntry->resStart = (ULONG64)0;
            pEntry->resEnd = (ULONG64)(-1);
        } else {
            //
            // @x[-y]:
            //
            ULONG x;
            ULONG y;
            PTSTR i;

            pSz++; // past @

            while (pSz[0] && pSz[0]<=TEXT(' ')) {
                pSz++;
            }
            i = pSz;
            x = _tcstoul(pSz,&i,0);
            if (i==pSz) {
                MyFree(pEntry);
                return NULL;
            }
            pSz = i;
            while (pSz[0] && pSz[0]<=TEXT(' ')) {
                pSz++;
            }
            if (pSz[0]==TEXT('-')) {
                //
                // -y
                //
                pSz++;
                while (pSz[0] && pSz[0]<=TEXT(' ')) {
                    pSz++;
                }
                i = pSz;
                y = _tcstoul(pSz,&i,0);
                if (i==pSz || y<x) {
                    MyFree(pEntry);
                    return NULL;
                }
                pSz = i;
                while (pSz[0] && pSz[0]<=TEXT(' ')) {
                    pSz++;
                }
            } else {
                y = x;
            }
            pEntry->resStart = x;
            pEntry->resEnd = y;
        }
        if (pSz[0] != TEXT(':')) {
            MyFree(pEntry);
            return NULL;
        }
        pSz ++; // skip past colon
    }
    //
    // at this point, expect a list of tags
    // each tag terminated by a comma
    //
    pFillCETags(pExceptions,&pEntry->tags,pSz);
    if (!pEntry->tags.nTags) {
        MyFree(pEntry);
        return NULL;
    }
    return pEntry;
}

PCONFLICT_EXCEPTIONS pLoadConflictExceptions(
    IN LPDMPROP_DATA lpdmpd
    )
/*++

Routine Description:

    Load the string "ResourcePickerExceptions" if any
    create a context structure for eliminating false conflicts
    this is one huge hack.

Arguments:

    lpdmpd - Context data

Return Value:

    CONFLICT_EXCEPTIONS structure, if "active" contains a string table and a list of resource exceptions

--*/
{
    PCONFLICT_EXCEPTIONS pExceptions;
    PCE_ENTRY pEntry;
    BOOL bStatus;
    HKEY hDevRegKey;
    PTSTR pSz;
    PTSTR pScanSz;
    PTSTR pOldSz;
    PCE_TAGS pTags;

    //
    // we always create the structure, so we will avoid looking for registry info every time
    //
    pExceptions = MyMalloc(sizeof(CONFLICT_EXCEPTIONS));
    if (pExceptions == NULL) {
        return NULL;
    }
    ZeroMemory(pExceptions,sizeof(CONFLICT_EXCEPTIONS));

    hDevRegKey = SetupDiOpenDevRegKey(lpdmpd->hDevInfo,lpdmpd->lpdi,DICS_FLAG_GLOBAL,0,DIREG_DRV,KEY_READ);
    if (hDevRegKey == INVALID_HANDLE_VALUE) {
        //
        // can't find key, no conflict elimination
        //
        return pExceptions;
    }
    pSz = pGetRegString(hDevRegKey,REGSTR_VAL_RESOURCE_PICKER_EXCEPTIONS);
    RegCloseKey(hDevRegKey);
    if(pSz == NULL) {
        //
        // can't find key, no conflict elimination
        //
        return pExceptions;
    }

    //
    // now parse the string creating our context to eliminate false conflicts
    //

    pExceptions->ceTagMap = pSetupStringTableInitializeEx(sizeof(CE_TAGS),0);
    if (pExceptions->ceTagMap == NULL) {
        MyFree(pSz);
        return pExceptions;
    }

    pScanSz = pSz;

    while (pScanSz[0]) {
        if (pScanSz[0] == TEXT(';')) {
            pScanSz ++;
        } else {
            pOldSz = pScanSz;
            while (pScanSz[0] && pScanSz[0] != TEXT(';')) {
                pScanSz++;
            }
            if (pScanSz[0]) {
                pScanSz[0] = 0;
                pScanSz++;
            }
            pEntry = pScanConflictExceptionEntry(pExceptions,pOldSz);
            if (pEntry) {
                pEntry->Next = pExceptions->exceptions;
                pExceptions->exceptions = pEntry;
            }
        }
    }

    MyFree(pSz);
    return pExceptions;
}

VOID pFreeConflictExceptions(
    IN PCONFLICT_EXCEPTIONS pExceptions
    )
/*++

Routine Description:

    Releases memory used by PCONFLICT_EXCEPTIONS

Arguments:

    pExceptions     structure to release

Return Value:

   None.

--*/
{
    //
    // free the list
    //
    while (pExceptions->exceptions) {
        PCE_ENTRY pEntry = pExceptions->exceptions;
        pExceptions->exceptions = pEntry->Next;
        MyFree(pEntry);
    }
    //
    // free the string table
    //
    if (pExceptions->ceTagMap) {
        pSetupStringTableDestroy(pExceptions->ceTagMap);
    }
    MyFree(pExceptions);
}

BOOL pIsConflictException(
    IN LPDMPROP_DATA lpdmpd,
    IN PCONFLICT_EXCEPTIONS pExceptions,
    IN DEVINST devConflict,
    IN PCTSTR resDesc,
    IN RESOURCEID resType,
    IN ULONG64 resValue,
    IN ULONG64 resLength
    )
/*++

Routine Description:

    Load the string "ResourcePickerExceptions" if any
    create a context structure for eliminating false conflicts
    this is one huge hack.

Arguments:

    lpdmpd - Context data
    pExceptions - Cache of information
    devConflict - DEVINST that's shown to be conflicting with us, -1 if "unavailable" (tag = *)
    resType - type of resource that we tested
    resValue - value of resource that we tested
    resLength - length of resource that we tested

Return Value:

    TRUE if this is an exception

--*/
{
    HMACHINE hMachine;
    TCHAR DevNodeName[MAX_DEVNODE_ID_LEN];
    CE_TAGS tags;
    PCE_ENTRY pEntry;
    LONG tagent;
    LONG n,m;
    ULONG64 resEnd = resValue+(resLength-1);
    PTSTR pSz;
    HKEY hKey;

    //
    // if we're not doing any exceptions, get out ASAP
    //
    if (pExceptions->exceptions == NULL) {
        return FALSE;
    }

    hMachine = pGetMachine(lpdmpd);
    //
    // handle "reserved" case first
    //
    if (devConflict != -1) {
        //
        // obtain device instance string
        //
        if(CM_Get_Device_ID_Ex(devConflict,DevNodeName,MAX_DEVNODE_ID_LEN,0,hMachine)!=CR_SUCCESS) {
            devConflict = -1;
        }
    }
    if (devConflict == -1) {
        if (resDesc && resDesc[0]) {
            lstrcpy(DevNodeName,resDesc);
        } else {
            lstrcpy(DevNodeName,CE_TAG_RESERVED);
        }
    } else {
    }
    //
    // is this a brand-new devnodename ?
    //
    tags.nTags = 0;
    tagent = pSetupStringTableLookUpStringEx(pExceptions->ceTagMap,DevNodeName,STRTAB_CASE_INSENSITIVE|STRTAB_BUFFER_WRITEABLE,&tags,sizeof(tags));
    if(tagent<0 || tags.nTags<0) {
        //
        // this particular devnode hasn't been processed before, ouch time
        //
        ZeroMemory(&tags,sizeof(tags)); // default reserved case
        if (devConflict != -1) {
            //
            // we need to get regkey for this devnode
            // I could do this via setupapi, or cfgmgr
            // for efficiency, I'm going latter route
            //
            if(CM_Open_DevNode_Key_Ex(devConflict,
                     KEY_READ,
                     0,
                     RegDisposition_OpenExisting,
                     &hKey,
                     CM_REGISTRY_SOFTWARE,
                     hMachine) == CR_SUCCESS) {

                pSz = pGetRegString(hKey,REGSTR_VAL_RESOURCE_PICKER_TAGS);
                RegCloseKey(hKey);

                if (pSz) {
                    //
                    // now fill in tags
                    //
                    pFillCETags(pExceptions,&tags,pSz);
                    MyFree(pSz);
                }
            }
        }
        //
        // now write this back into the string table
        // this time, non-negative nTags indicates we've processed this once
        // we will re-write the extra-data
        //
        tagent = pSetupStringTableAddStringEx(pExceptions->ceTagMap,DevNodeName,STRTAB_CASE_INSENSITIVE|STRTAB_BUFFER_WRITEABLE|STRTAB_NEW_EXTRADATA,&tags,sizeof(tags));
    }
    if (tagent<0) {
        //
        // if this happens, we have other problems (out of memory)
        //
        return FALSE;
    }

    //
    // go through our list of exceptions
    // an exception that mentions tagent, or any of tags associated with tagent (in tags) is rejected
    // the policy in this routine is make this an exception if we can
    //

    for(pEntry=pExceptions->exceptions;pEntry;pEntry=pEntry->Next) {

        if (pEntry->resType != ResType_None) {
            //
            // we need to validate the resource
            //
            if (pEntry->resType != resType ||
                    pEntry->resStart > resValue ||
                    pEntry->resEnd < resEnd) {
                continue;
            }
        }
        for (n=0;n<pEntry->tags.nTags;n++) {
            if (pEntry->tags.Tag[n] == tagent) {
                MYTRACE((DPFLTR_ERROR_LEVEL, TEXT("Setup: Eliminated false conflict with %s type=%u, start=0x%08x, len=0x%08x\n"),DevNodeName,resType,resValue,resLength));
                return TRUE;    // hit (devnode itself, where devnode may also be "*")
            }
            for (m=0;m<tags.nTags;m++) {
                if (pEntry->tags.Tag[n] == tags.Tag[m]) {
                    MYTRACE((DPFLTR_ERROR_LEVEL, TEXT("Setup: Eliminated false conflict with %s (via tag %s) type=%u, start=0x%08x, len=0x%08x\n"),DevNodeName,pStringTableStringFromId(pExceptions->ceTagMap,tags.Tag[m]),resType,resValue,resLength));
                    return TRUE;    // hit on one of associated tags
                }
            }
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\devreg.c ===
/*++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name:

    devreg.c

Abstract:

    Device Installer routines for registry storage/retrieval.

Author:

    Lonny McMichael (lonnym) 1-July-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// Private function prototypes
//
DWORD
pSetupOpenOrCreateDevRegKey(
    IN  PDEVICE_INFO_SET DeviceInfoSet,
    IN  PDEVINFO_ELEM    DevInfoElem,
    IN  DWORD            Scope,
    IN  DWORD            HwProfile,
    IN  DWORD            KeyType,
    IN  BOOL             Create,
    IN  REGSAM           samDesired,
    OUT PHKEY            hDevRegKey
    );

BOOL
pSetupFindUniqueKey(
    IN HKEY   hkRoot,
    IN LPTSTR SubKey,
    IN ULONG  SubKeyLength
    );

DWORD
pSetupOpenOrCreateInterfaceDeviceRegKey(
    IN  HKEY                      hInterfaceClassKey,
    IN  PDEVICE_INFO_SET          DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA InterfaceDeviceData,
    IN  BOOL                      Create,
    IN  REGSAM                    samDesired,
    OUT PHKEY                     hInterfaceDeviceKey
    );

DWORD
pSetupDeleteInterfaceDeviceKey(
    IN HKEY                      hInterfaceClassKey,
    IN PDEVICE_INFO_SET          DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA InterfaceDeviceData
    );


HKEY
WINAPI
SetupDiOpenClassRegKey(
    IN CONST GUID *ClassGuid, OPTIONAL
    IN REGSAM      samDesired
    )
/*++

Routine Description:

    This API opens the installer class registry key or a specific class
    installer's subkey.

Arguments:

    ClassGuid - Optionally, supplies a pointer to the GUID of the class whose
        key is to be opened.  If this parameter is NULL, then the root of the
        class tree will be opened.

    samDesired - Specifies the access you require for this key.

Return Value:

    If the function succeeds, the return value is a handle to an opened registry
    key.

    If the function fails, the return value is INVALID_HANDLE_VALUE.  To get
    extended error information, call GetLastError.

Remarks:

    This API _will not_ create a registry key if it doesn't already exist.

    The handle returned from this API must be closed by calling RegCloseKey.

    To get at the interface class (DeviceClasses) branch, or to access the
    registry on a remote machine, use SetupDiOpenClassRegKeyEx.

--*/
{
    return SetupDiOpenClassRegKeyEx(ClassGuid, samDesired, DIOCR_INSTALLER, NULL, NULL);
}


#ifdef UNICODE
//
// ANSI version
//
HKEY
WINAPI
SetupDiOpenClassRegKeyExA(
    IN CONST GUID *ClassGuid,   OPTIONAL
    IN REGSAM      samDesired,
    IN DWORD       Flags,
    IN PCSTR       MachineName, OPTIONAL
    IN PVOID       Reserved
    )
{
    PCWSTR UnicodeMachineName;
    DWORD rc;
    HKEY hk;

    hk = INVALID_HANDLE_VALUE;

    if(MachineName) {
        rc = pSetupCaptureAndConvertAnsiArg(MachineName, &UnicodeMachineName);
    } else {
        UnicodeMachineName = NULL;
        rc = NO_ERROR;
    }

    if(rc == NO_ERROR) {

        hk = SetupDiOpenClassRegKeyExW(ClassGuid,
                                       samDesired,
                                       Flags,
                                       UnicodeMachineName,
                                       Reserved
                                      );
        rc = GetLastError();

        if(UnicodeMachineName) {
            MyFree(UnicodeMachineName);
        }
    }

    SetLastError(rc);
    return hk;
}
#else
//
// Unicode version
//
HKEY
WINAPI
SetupDiOpenClassRegKeyExW(
    IN CONST GUID *ClassGuid,   OPTIONAL
    IN REGSAM      samDesired,
    IN DWORD       Flags,
    IN PCWSTR      MachineName, OPTIONAL
    IN PVOID       Reserved
    )
{
    UNREFERENCED_PARAMETER(ClassGuid);
    UNREFERENCED_PARAMETER(samDesired);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(MachineName);
    UNREFERENCED_PARAMETER(Reserved);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif


HKEY
WINAPI
SetupDiOpenClassRegKeyEx(
    IN CONST GUID *ClassGuid,   OPTIONAL
    IN REGSAM      samDesired,
    IN DWORD       Flags,
    IN PCTSTR      MachineName, OPTIONAL
    IN PVOID       Reserved
    )
/*++

Routine Description:

    This API opens the root of either the installer or the interface class registry
    branch, or a specified class subkey under one of these branches.

    If the root key is requested, it will be created if not already present (i.e.,
    you're always guaranteed to get a handle to the root unless a registry error
    occurs).

    If a particular class subkey is requested, it will be returned if present.
    Otherwise, this API will return ERROR_INVALID_CLASS.

Arguments:

    ClassGuid - Optionally, supplies a pointer to the GUID of the class whose
        key is to be opened.  If this parameter is NULL, then the root of the
        class tree will be opened.  This GUID is either an installer class or
        an interface class depending on the Flags argument.

    samDesired - Specifies the access you require for this key.

    Flags - Specifies which registry branch the key is to be opened for.  May
        be one of the following values:

        DIOCR_INSTALLER - Open the class installer (Class) branch.
        DIOCR_INTERFACE - Open the interface class (DeviceClasses) branch.

    MachineName - If specified, this value indicates the remote machine where
        the key is to be opened.

    Reserved - Reserved for future use--must be NULL.

Return Value:

    If the function succeeds, the return value is a handle to an opened registry
    key.

    If the function fails, the return value is INVALID_HANDLE_VALUE.  To get
    extended error information, call GetLastError.

Remarks:

    The handle returned from this API must be closed by calling RegCloseKey.

--*/
{
    HKEY hk;
    CONFIGRET cr;
    DWORD Err = NO_ERROR;
    HMACHINE hMachine = NULL;

    //
    // Make sure the user didn't pass us anything in the Reserved parameter.
    //
    if(Reserved) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    //
    // Validate the flags (really, just an enum for now, but treated as
    // flags for future extensibility).
    //
    if((Flags & ~(DIOCR_INSTALLER | DIOCR_INTERFACE)) ||
       ((Flags != DIOCR_INSTALLER) && (Flags != DIOCR_INTERFACE))) {

        SetLastError(ERROR_INVALID_FLAGS);
        return INVALID_HANDLE_VALUE;
    }

    try {

        if(MachineName) {

            if(CR_SUCCESS != (cr = CM_Connect_Machine(MachineName, &hMachine))) {
                //
                // Make sure machine handle is still invalid, so we won't
                // try to disconnect later.
                //
                hMachine = NULL;
                Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                goto clean0;
            }
        }

        if((cr = CM_Open_Class_Key_Ex((LPGUID)ClassGuid,
                                      NULL,
                                      samDesired,
                                      ClassGuid ? RegDisposition_OpenExisting
                                                : RegDisposition_OpenAlways,
                                      &hk,
                                      (Flags & DIOCR_INSTALLER) ? CM_OPEN_CLASS_KEY_INSTALLER
                                                                : CM_OPEN_CLASS_KEY_INTERFACE,
                                      hMachine)) != CR_SUCCESS)
        {
            if(cr == CR_NO_SUCH_REGISTRY_KEY) {
                Err = ERROR_INVALID_CLASS;
            } else {
                Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
            }
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        //
        // Reference the following variable(s) so the compiler will respect our statement
        // ordering w.r.t. assignment.
        //
        hMachine = hMachine;
    }

    if(hMachine) {
        CM_Disconnect_Machine(hMachine);
    }

    SetLastError(Err);
    return (Err == NO_ERROR) ? hk : INVALID_HANDLE_VALUE;
}


#ifdef UNICODE
//
// ANSI version
//
HKEY
WINAPI
SetupDiCreateDevRegKeyA(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Scope,
    IN DWORD            HwProfile,
    IN DWORD            KeyType,
    IN HINF             InfHandle,      OPTIONAL
    IN PCSTR            InfSectionName  OPTIONAL
    )
{
    DWORD rc;
    PWSTR name;
    HKEY h;

    if(InfSectionName) {
        rc = pSetupCaptureAndConvertAnsiArg(InfSectionName,&name);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(INVALID_HANDLE_VALUE);
        }
    } else {
        name = NULL;
    }

    h = SetupDiCreateDevRegKeyW(
            DeviceInfoSet,
            DeviceInfoData,
            Scope,
            HwProfile,
            KeyType,
            InfHandle,
            name
            );

    rc = GetLastError();

    if(name) {
        MyFree(name);
    }
    SetLastError(rc);
    return(h);
}
#else
//
// Unicode stub
//
HKEY
WINAPI
SetupDiCreateDevRegKeyW(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Scope,
    IN DWORD            HwProfile,
    IN DWORD            KeyType,
    IN HINF             InfHandle,      OPTIONAL
    IN PCWSTR           InfSectionName  OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceInfoData);
    UNREFERENCED_PARAMETER(Scope);
    UNREFERENCED_PARAMETER(HwProfile);
    UNREFERENCED_PARAMETER(KeyType);
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(InfSectionName);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(INVALID_HANDLE_VALUE);
}
#endif

HKEY
WINAPI
SetupDiCreateDevRegKey(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Scope,
    IN DWORD            HwProfile,
    IN DWORD            KeyType,
    IN HINF             InfHandle,      OPTIONAL
    IN PCTSTR           InfSectionName  OPTIONAL
    )
/*++

Routine Description:

    This routine creates a registry storage key for device-specific configuration
    information, and returns a handle to the key.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        information about the device instance whose registry configuration storage
        key is to be created.

    DeviceInfoData - Supplies a pointer to a SP_DEVINFO_DATA structure indicating
        the device instance to create the registry key for.

    Scope - Specifies the scope of the registry key to be created.  This determines
        where the information is actually stored--the key created may be one that is
        global (i.e., constant regardless of current hardware profile) or hardware
        profile-specific.  May be one of the following values:

        DICS_FLAG_GLOBAL - Create a key to store global configuration information.

        DICS_FLAG_CONFIGSPECIFIC - Create a key to store hardware profile-specific
                                   information.

    HwProfile - Specifies the hardware profile to create a key for, if the Scope parameter
        is set to DICS_FLAG_CONFIGSPECIFIC.  If this parameter is 0, then the key
        for the current hardware profile should be created (i.e., in the Class branch
        under HKEY_CURRENT_CONFIG).  If Scope is DICS_FLAG_GLOBAL, then this parameter
        is ignored.

    KeyType - Specifies the type of registry storage key to be created.  May be one of
        the following values:

        DIREG_DEV - Create a hardware registry key for the device.  This is the key for
            storage of driver-independent configuration information.  (This key is in
            the device instance key in the Enum branch.

        DIREG_DRV - Create a software, or driver, registry key for the device.  (This key
            is located in the class branch.)

    InfHandle - Optionally, supplies the handle of an opened INF file containing an
        install section to be executed for the newly-created key.  If this parameter is
        specified, then InfSectionName must be specified as well.

    InfSectionName - Optionally, supplies the name of an install section in the INF
        file specified by InfHandle.  This section will be executed for the newly
        created key. If this parameter is specified, then InfHandle must be specified
        as well.

Return Value:

    If the function succeeds, the return value is a handle to a newly-created
    registry key where private configuration data pertaining to this device
    instance may be stored/retrieved.

    If the function fails, the return value is INVALID_HANDLE_VALUE.  To get
    extended error information, call GetLastError.

Remarks:

    The handle returned from this routine must be closed by calling RegCloseKey.

    The specified device instance must have been previously registered (i.e.,
    if it was created via SetupDiCreateDeviceInfo, then SetupDiRegisterDeviceInfo
    must have been subsequently called.)

    During GUI-mode setup on Windows NT, quiet-install behavior is always
    employed in the absence of a user-supplied file queue, regardless of
    whether the device information element has the DI_QUIETINSTALL flag set.

--*/

{
    HKEY hk = INVALID_HANDLE_VALUE;
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    PSP_FILE_CALLBACK MsgHandler;
    PVOID MsgHandlerContext;
    BOOL MsgHandlerIsNativeCharWidth;
    BOOL NoProgressUI;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return INVALID_HANDLE_VALUE;
    }

    Err = NO_ERROR;

    try {
        //
        // Get a pointer to the element for the specified device
        // instance.
        //
        if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                     DeviceInfoData,
                                                     NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // Create the requested registry storage key.
        //
        if((Err = pSetupOpenOrCreateDevRegKey(pDeviceInfoSet,
                                              DevInfoElem,
                                              Scope,
                                              HwProfile,
                                              KeyType,
                                              TRUE,
                                              KEY_ALL_ACCESS,
                                              &hk)) != NO_ERROR) {
            goto clean0;
        }

        //
        // We successfully created the storage key, now run an INF install
        // section against it (if specified).
        //
        if(InfHandle && (InfHandle != INVALID_HANDLE_VALUE) && InfSectionName) {
            //
            // If a copy msg handler and context haven't been specified, then use
            // the default one.
            //
            if(DevInfoElem->InstallParamBlock.InstallMsgHandler) {
                MsgHandler        = DevInfoElem->InstallParamBlock.InstallMsgHandler;
                MsgHandlerContext = DevInfoElem->InstallParamBlock.InstallMsgHandlerContext;
                MsgHandlerIsNativeCharWidth = DevInfoElem->InstallParamBlock.InstallMsgHandlerIsNativeCharWidth;
            } else {

                NoProgressUI = (GuiSetupInProgress || (DevInfoElem->InstallParamBlock.Flags & DI_QUIETINSTALL));

                if(!(MsgHandlerContext = SetupInitDefaultQueueCallbackEx(
                                             DevInfoElem->InstallParamBlock.hwndParent,
                                             (NoProgressUI ? INVALID_HANDLE_VALUE : NULL),
                                             0,
                                             0,
                                             NULL))) {

                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean0;
                }
                MsgHandler = SetupDefaultQueueCallback;
                MsgHandlerIsNativeCharWidth = TRUE;
            }

            if(!_SetupInstallFromInfSection(DevInfoElem->InstallParamBlock.hwndParent,
                                            InfHandle,
                                            InfSectionName,
                                            SPINST_ALL,
                                            hk,
                                            NULL,
                                            0,
                                            MsgHandler,
                                            MsgHandlerContext,
                                            ((KeyType == DIREG_DEV) ? DeviceInfoSet
                                                                    : INVALID_HANDLE_VALUE),
                                            ((KeyType == DIREG_DEV) ? DeviceInfoData
                                                                    : NULL),
                                            MsgHandlerIsNativeCharWidth,
                                            NULL
                                           )) {
                Err = GetLastError();
            }

            //
            // If we used the default msg handler, release the default context now.
            //
            if(!DevInfoElem->InstallParamBlock.InstallMsgHandler) {
                SetupTermDefaultQueueCallback(MsgHandlerContext);
            }
        }

clean0:
        ; // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    if(Err == NO_ERROR) {
        return hk;
    } else {
        if(hk != INVALID_HANDLE_VALUE) {
            RegCloseKey(hk);
        }
        SetLastError(Err);
        return INVALID_HANDLE_VALUE;
    }
}


HKEY
WINAPI
SetupDiOpenDevRegKey(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Scope,
    IN DWORD            HwProfile,
    IN DWORD            KeyType,
    IN REGSAM           samDesired
    )
/*++

Routine Description:

    This routine opens a registry storage key for device-specific configuration
    information, and returns a handle to the key.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        information about the device instance whose registry configuration storage
        key is to be opened.

    DeviceInfoData - Supplies a pointer to a SP_DEVINFO_DATA structure indicating
        the device instance to open the registry key for.

    Scope - Specifies the scope of the registry key to be opened.  This determines
        where the information is actually stored--the key opened may be one that is
        global (i.e., constant regardless of current hardware profile) or hardware
        profile-specific.  May be one of the following values:

        DICS_FLAG_GLOBAL - Open a key to store global configuration information.

        DICS_FLAG_CONFIGSPECIFIC - Open a key to store hardware profile-specific
                                   information.

    HwProfile - Specifies the hardware profile to open a key for, if the Scope parameter
        is set to DICS_FLAG_CONFIGSPECIFIC.  If this parameter is 0, then the key
        for the current hardware profile should be opened (i.e., in the Class branch
        under HKEY_CURRENT_CONFIG).  If Scope is SPDICS_FLAG_GLOBAL, then this parameter
        is ignored.

    KeyType - Specifies the type of registry storage key to be opened.  May be one of
        the following values:

        DIREG_DEV - Open a hardware registry key for the device.  This is the key for
            storage of driver-independent configuration information.  (This key is in
            the device instance key in the Enum branch.

        DIREG_DRV - Open a software (i.e., driver) registry key for the device.  (This key
            is located in the class branch.)

    samDesired - Specifies the access you require for this key.

Return Value:

    If the function succeeds, the return value is a handle to an opened registry
    key where private configuration data pertaining to this device instance may be
    stored/retrieved.

    If the function fails, the return value is INVALID_HANDLE_VALUE.  To get
    extended error information, call GetLastError.

Remarks:

    The handle returned from this routine must be closed by calling RegCloseKey.

    The specified device instance must have been previously registered (i.e., if it
    was created via SetupDiCreateDeviceInfo, then SetupDiRegisterDeviceInfo must have
    been subsequently called.)

--*/

{
    HKEY hk;
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return INVALID_HANDLE_VALUE;
    }

    Err = NO_ERROR;

    try {
        //
        // Get a pointer to the element for the specified device
        // instance.
        //
        if(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                   DeviceInfoData,
                                                   NULL)) {
            //
            // Open the requested registry storage key.
            //
            Err = pSetupOpenOrCreateDevRegKey(pDeviceInfoSet,
                                              DevInfoElem,
                                              Scope,
                                              HwProfile,
                                              KeyType,
                                              FALSE,
                                              samDesired,
                                              &hk
                                             );
        } else {
            Err = ERROR_INVALID_PARAMETER;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return (Err == NO_ERROR) ? hk : INVALID_HANDLE_VALUE;
}


DWORD
pSetupOpenOrCreateDevRegKey(
    IN  PDEVICE_INFO_SET pDeviceInfoSet,
    IN  PDEVINFO_ELEM    DevInfoElem,
    IN  DWORD            Scope,
    IN  DWORD            HwProfile,
    IN  DWORD            KeyType,
    IN  BOOL             Create,
    IN  REGSAM           samDesired,
    OUT PHKEY            hDevRegKey
    )
/*++

Routine Description:

    This routine creates or opens a registry storage key for the specified
    device information element, and returns a handle to the opened key.

Arguments:

    DeviceInfoSet - Supplies a pointer to the device information set containing
        the element for which a registry storage key is to be created/opened.

    DevInfoElem - Supplies a pointer to the device information element for
        which a registry storage key is to be created/opened.

    Scope - Specifies the scope of the registry key to be created/opened.  This determines
        where the information is actually stored--the key created may be one that is
        global (i.e., constant regardless of current hardware profile) or hardware
        profile-specific.  May be one of the following values:

        DICS_FLAG_GLOBAL - Create/open a key to store global configuration information.

        DICS_FLAG_CONFIGSPECIFIC - Create/open a key to store hardware profile-specific
                                   information.

    HwProfile - Specifies the hardware profile to create/open a key for, if the Scope parameter
        is set to DICS_FLAG_CONFIGSPECIFIC.  If this parameter is 0, then the key
        for the current hardware profile should be created/opened (i.e., in the Class branch
        under HKEY_CURRENT_CONFIG).  If Scope is SPDICS_FLAG_GLOBAL, then this parameter
        is ignored.

    KeyType - Specifies the type of registry storage key to be created/opened.  May be one of
        the following values:

        DIREG_DEV - Create/open a hardware registry key for the device.  This is the key for
            storage of driver-independent configuration information.  (This key is in
            the device instance key in the Enum branch.

        DIREG_DRV - Create/open a software, or driver, registry key for the device.  (This key
            is located in the class branch.)

    Create - Specifies whether the key should be created if doesn't already exist.

    samDesired - Specifies the access you require for this key.

    hDevRegKey - Supplies the address of a variable that receives a handle to the
        requested registry key.  (This variable will only be written to if the
        handle is successfully opened.)

Return Value:

    If the function is successful, the return value is NO_ERROR, otherwise, it is
    the ERROR_* code indicating the error that occurred.

Remarks:

    If a software key is requested (DIREG_DRV), and there isn't already a 'Driver'
    value entry, then one will be created.  This entry is of the form:

        <ClassGUID>\<instance>

    where <instance> is a base-10, 4-digit number that is unique within that class.

--*/

{
    ULONG RegistryBranch;
    CONFIGRET cr;
    DWORD Err, Disposition;
    HKEY hk, hkClass;
    TCHAR DriverKey[GUID_STRING_LEN + 5];   // Eg, {4d36e978-e325-11ce-bfc1-08002be10318}\0000
    ULONG DriverKeyLength;
    TCHAR EmptyString = TEXT('\0');

    //
    // Under Win95, the class key uses the class name instead of its GUID.  The maximum
    // length of a class name is less than the length of a GUID string, but put a check
    // here just to make sure that this assumption remains valid.
    //
#if MAX_CLASS_NAME_LEN > MAX_GUID_STRING_LEN
#error MAX_CLASS_NAME_LEN is larger than MAX_GUID_STRING_LEN--fix DriverKey!
#endif

    //
    // Figure out what flags to pass to CM_Open_DevInst_Key
    //
    switch(KeyType) {

        case DIREG_DEV :
            RegistryBranch = CM_REGISTRY_HARDWARE;
            break;

        case DIREG_DRV :
            //
            // This key may only be opened if the device instance has been registered.
            //
            if(!(DevInfoElem->DiElemFlags & DIE_IS_REGISTERED)) {
                return ERROR_DEVINFO_NOT_REGISTERED;
            }

            //
            // Retrieve the 'Driver' registry property which indicates where the
            // storage key is located in the class branch.
            //
            DriverKeyLength = sizeof(DriverKey);
            if((cr = CM_Get_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                      CM_DRP_DRIVER,
                                                      NULL,
                                                      DriverKey,
                                                      &DriverKeyLength,
                                                      0,
                                                      pDeviceInfoSet->hMachine)) != CR_SUCCESS) {

                if(cr != CR_NO_SUCH_VALUE) {
                    return (cr == CR_INVALID_DEVINST) ? ERROR_NO_SUCH_DEVINST
                                                      : ERROR_INVALID_DATA;
                } else if(!Create) {
                    return ERROR_KEY_DOES_NOT_EXIST;
                }

                //
                // The Driver entry doesn't exist, and we should create it.
                //
                hk = INVALID_HANDLE_VALUE;
                if(CM_Open_Class_Key_Ex(NULL,
                                     NULL,
                                     KEY_ALL_ACCESS,
                                     RegDisposition_OpenAlways,
                                     &hkClass,
                                     0,
                                     pDeviceInfoSet->hMachine) != CR_SUCCESS) {
                    //
                    // This shouldn't fail.
                    //
                    return ERROR_INVALID_DATA;
                }

                try {
                    //
                    // Find a unique key name under this class key.
                    //
                    DriverKeyLength = SIZECHARS(DriverKey);
                    if(CM_Get_Class_Key_Name_Ex(&(DevInfoElem->ClassGuid),
                                             DriverKey,
                                             &DriverKeyLength,
                                             0,
                                             pDeviceInfoSet->hMachine) != CR_SUCCESS) {

                        Err = ERROR_INVALID_CLASS;
                        goto clean0;
                    }
                    DriverKeyLength--;  // don't want to include terminating NULL.

                    while(pSetupFindUniqueKey(hkClass, DriverKey, DriverKeyLength)) {

                        if((Err = RegCreateKeyEx(hkClass,
                                                 DriverKey,
                                                 0,
                                                 &EmptyString,
                                                 REG_OPTION_NON_VOLATILE,
                                                 KEY_ALL_ACCESS,
                                                 NULL,
                                                 &hk,
                                                 &Disposition)) == ERROR_SUCCESS) {
                            //
                            // Everything's great, unless the Disposition indicates
                            // that the key already existed.  That means that someone
                            // else claimed the key before we got a chance to.  In
                            // that case, we close this key, and try again.
                            //
                            if(Disposition == REG_OPENED_EXISTING_KEY) {
                                RegCloseKey(hk);
                                hk = INVALID_HANDLE_VALUE;
                                //
                                // Truncate off the class instance part, to be replaced
                                // with a new instance number the next go-around.
                                //
                                DriverKey[GUID_STRING_LEN - 1] = TEXT('\0');
                            } else {
                                break;
                            }
                        } else {
                            hk = INVALID_HANDLE_VALUE;
                            break;
                        }
                    }

                    if(Err != NO_ERROR) {   // NO_ERROR == ERROR_SUCCESS
                        goto clean0;
                    }

                    //
                    // Set the device instance's 'Driver' registry property to reflect the
                    // new software registry storage location.
                    //
                    CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                     CM_DRP_DRIVER,
                                                     DriverKey,
                                                     sizeof(DriverKey),
                                                     0,
                                                     pDeviceInfoSet->hMachine);


clean0:             ;   // nothing to do

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    Err = ERROR_INVALID_PARAMETER;
                    //
                    // Access the hk variable so that the compiler will respect
                    // the statement ordering in the try clause.
                    //
                    hk = hk;
                }

                if(hk != INVALID_HANDLE_VALUE) {
                    RegCloseKey(hk);
                }

                RegCloseKey(hkClass);

                if(Err != NO_ERROR) {
                    return Err;
                }
            }

            RegistryBranch = CM_REGISTRY_SOFTWARE;
            break;

        default :
            return ERROR_INVALID_FLAGS;
    }

    if(Scope == DICS_FLAG_CONFIGSPECIFIC) {
        RegistryBranch |= CM_REGISTRY_CONFIG;
    } else if(Scope != DICS_FLAG_GLOBAL) {
        return ERROR_INVALID_FLAGS;
    }

    cr = CM_Open_DevInst_Key_Ex(DevInfoElem->DevInst,
                             samDesired,
                             HwProfile,
                             (Create ? RegDisposition_OpenAlways : RegDisposition_OpenExisting),
                             &hk,
                             RegistryBranch,
                             pDeviceInfoSet->hMachine);
    if(cr == CR_SUCCESS) {
        *hDevRegKey = hk;
        Err = NO_ERROR;
    } else {

        switch(cr) {

            case CR_INVALID_DEVINST :
                Err = ERROR_NO_SUCH_DEVINST;
                break;

            case CR_NO_SUCH_REGISTRY_KEY :
                Err = ERROR_KEY_DOES_NOT_EXIST;
                break;

            default :
                Err = ERROR_INVALID_DATA;
        }
    }

    return Err;
}


BOOL
WINAPI
_SetupDiGetDeviceRegistryProperty(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            Property,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize         OPTIONAL
#ifdef UNICODE
    IN ,BOOL             Ansi
#endif
    )
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    CONFIGRET cr;
    ULONG CmRegProperty, PropLength;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {
        //
        // Get a pointer to the element for the specified device
        // instance.
        //
        if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                     DeviceInfoData,
                                                     NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        if(Property < SPDRP_MAXIMUM_PROPERTY) {
            CmRegProperty = (ULONG)SPDRP_TO_CMDRP(Property);
        } else {
            Err = ERROR_INVALID_REG_PROPERTY;
            goto clean0;
        }

        PropLength = PropertyBufferSize;
#ifdef UNICODE
        if(Ansi) {
            cr = CM_Get_DevInst_Registry_Property_ExA(
                    DevInfoElem->DevInst,
                    CmRegProperty,
                    PropertyRegDataType,
                    PropertyBuffer,
                    &PropLength,
                    0,
                    pDeviceInfoSet->hMachine);
        } else
#endif
        cr = CM_Get_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                              CmRegProperty,
                                              PropertyRegDataType,
                                              PropertyBuffer,
                                              &PropLength,
                                              0,
                                              pDeviceInfoSet->hMachine);

        if((cr == CR_SUCCESS) || (cr == CR_BUFFER_SMALL)) {

            if(RequiredSize) {
                *RequiredSize = PropLength;
            }
        }

        if(cr != CR_SUCCESS) {

            switch(cr) {

                case CR_INVALID_DEVINST :
                    Err = ERROR_NO_SUCH_DEVINST;
                    break;

                case CR_INVALID_PROPERTY :
                    Err = ERROR_INVALID_REG_PROPERTY;
                    break;

                case CR_BUFFER_SMALL :
                    Err = ERROR_INSUFFICIENT_BUFFER;
                    break;

                default :
                    Err = ERROR_INVALID_DATA;
            }
        }

clean0:
        ; // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return (Err == NO_ERROR);
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiGetDeviceRegistryPropertyA(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            Property,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize         OPTIONAL
    )
{
    BOOL b;

    b = _SetupDiGetDeviceRegistryProperty(
            DeviceInfoSet,
            DeviceInfoData,
            Property,
            PropertyRegDataType,
            PropertyBuffer,
            PropertyBufferSize,
            RequiredSize,
            TRUE
            );

    return(b);
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupDiGetDeviceRegistryPropertyW(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            Property,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize         OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceInfoData);
    UNREFERENCED_PARAMETER(Property);
    UNREFERENCED_PARAMETER(PropertyRegDataType);
    UNREFERENCED_PARAMETER(PropertyBuffer);
    UNREFERENCED_PARAMETER(PropertyBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiGetDeviceRegistryProperty(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            Property,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize         OPTIONAL
    )
/*++

Routine Description:

    This routine retrieves the specified property from the Plug & Play device
    storage location in the registry.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        information about the device instance to retrieve a Plug & Play registry
        property for.

    DeviceInfoData - Supplies a pointer to a SP_DEVINFO_DATA structure indicating
        the device instance to retrieve the Plug & Play registry property for.

    Property - Supplies an ordinal specifying the property to be retrieved.  Refer
        to sdk\inc\setupapi.h for a complete list of properties that may be retrieved.

    PropertyRegDataType - Optionally, supplies the address of a variable that
        will receive the data type of the property being retrieved.  This will
        be one of the standard registry data types (REG_SZ, REG_BINARY, etc.)

    PropertyBuffer - Supplies the address of a buffer that receives the property
        data.

    PropertyBufferSize - Supplies the length, in bytes, of PropertyBuffer.

    RequiredSize - Optionally, supplies the address of a variable that receives
        the number of bytes required to store the requested property in the buffer.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.  If the supplied buffer was not large enough
    to hold the requested property, the error will be ERROR_INSUFFICIENT_BUFFER,
    and RequiredSize will specify how large the buffer needs to be.

--*/

{
    BOOL b;

    b = _SetupDiGetDeviceRegistryProperty(
            DeviceInfoSet,
            DeviceInfoData,
            Property,
            PropertyRegDataType,
            PropertyBuffer,
            PropertyBufferSize,
            RequiredSize
#ifdef UNICODE
           ,FALSE
#endif
            );

    return(b);
}



BOOL
WINAPI
_SetupDiSetDeviceRegistryProperty(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData,
    IN     DWORD            Property,
    IN     CONST BYTE*      PropertyBuffer,    OPTIONAL
    IN     DWORD            PropertyBufferSize
#ifdef UNICODE
    IN    ,BOOL             Ansi
#endif
    )
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    CONFIGRET cr;
    ULONG CmRegProperty;
    GUID ClassGuid;
    BOOL ClassGuidSpecified;
    TCHAR ClassName[MAX_CLASS_NAME_LEN];
    DWORD ClassNameLength;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {
        //
        // Get a pointer to the element for the specified device
        // instance.
        //
        if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                     DeviceInfoData,
                                                     NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // Make sure the property code is in-range, and is not SPDRP_CLASS
        // (the Class property is not settable directly, and is automatically
        // updated when the ClassGUID property changes).
        //
        if((Property < SPDRP_MAXIMUM_PROPERTY) && (Property != SPDRP_CLASS)) {
            CmRegProperty = (ULONG)SPDRP_TO_CMDRP(Property);
        } else {
            Err = ERROR_INVALID_REG_PROPERTY;
            goto clean0;
        }

        //
        // If the property we're setting is ClassGUID, then we need to check to
        // see whether the new GUID is different from the current one.  If there's
        // no change, then we're done.
        //
        if(CmRegProperty == CM_DRP_CLASSGUID) {

            if(!PropertyBuffer) {
                //
                // Then the intent is to reset the device's class GUID.  Make
                // sure they passed us a buffer length of zero.
                //
                if(PropertyBufferSize) {
                    Err = ERROR_INVALID_PARAMETER;
                    goto clean0;
                }

                ClassGuidSpecified = FALSE;

            } else {

#ifdef UNICODE
                //
                // If we're being called from the ANSI API then we need
                // to convert the ANSI string representation of the GUID
                // to Unicode before we convert the string to an actual GUID.
                //
                PCWSTR UnicodeGuidString;

                if(Ansi) {
                    UnicodeGuidString = pSetupAnsiToUnicode((PCSTR)PropertyBuffer);
                    if(!UnicodeGuidString) {
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        goto clean0;
                    }
                } else {
                    UnicodeGuidString = (PCWSTR)PropertyBuffer;
                }
                Err = pSetupGuidFromString(UnicodeGuidString,&ClassGuid);
                if(UnicodeGuidString != (PCWSTR)PropertyBuffer) {
                    MyFree(UnicodeGuidString);
                }
                if(Err != NO_ERROR) {
                    goto clean0;
                }
#else
                if((Err = pSetupGuidFromString((PCTSTR)PropertyBuffer, &ClassGuid)) != NO_ERROR) {
                    goto clean0;
                }
#endif
                ClassGuidSpecified = TRUE;
            }

            if(IsEqualGUID(&(DevInfoElem->ClassGuid),
                           (ClassGuidSpecified ? &ClassGuid
                                               : &GUID_NULL))) {
                //
                // No change--nothing to do.
                //
                goto clean0;
            }

            //
            // We're changing the class of this device.  First, make sure that the
            // set containing this device doesn't have an associated class (otherwise,
            // we'll suddenly have a device whose class doesn't match the set's class).
            //
            if(pDeviceInfoSet->HasClassGuid) {
                Err = ERROR_CLASS_MISMATCH;
            } else {
                Err = InvalidateHelperModules(DeviceInfoSet, DeviceInfoData, 0);
            }

            if(Err != NO_ERROR) {
                goto clean0;
            }

            //
            // Everything seems to be in order.  Before going any further, we need to
            // delete any software keys associated with this device, so we don't leave
            // orphans in the registry when we change the device's class.
            //
            pSetupDeleteDevRegKeys(DevInfoElem->DevInst,
                                   DICS_FLAG_GLOBAL | DICS_FLAG_CONFIGSPECIFIC,
                                   (DWORD)-1,
                                   DIREG_DRV,
                                   TRUE
                                  );
            //
            // Now delete the Driver property for this device...
            //
            CM_Set_DevInst_Registry_Property(DevInfoElem->DevInst,
                                             CM_DRP_DRIVER,
                                             NULL,
                                             0,
                                             0
                                            );
        }

#ifdef UNICODE
        if(Ansi) {
            cr = CM_Set_DevInst_Registry_PropertyA(
                    DevInfoElem->DevInst,
                    CmRegProperty,
                    (PVOID)PropertyBuffer,
                    PropertyBufferSize,
                    0
                    );
        } else
#endif
        cr = CM_Set_DevInst_Registry_Property(DevInfoElem->DevInst,
                                              CmRegProperty,
                                              (PVOID)PropertyBuffer,
                                              PropertyBufferSize,
                                              0
                                             );
        if(cr == CR_SUCCESS) {
            //
            // If we were setting the device's ClassGUID property, then we need to
            // update its Class name property as well.
            //
            if(CmRegProperty == CM_DRP_CLASSGUID) {

                if(ClassGuidSpecified) {

                    if(!SetupDiClassNameFromGuid(&ClassGuid,
                                                 ClassName,
                                                 SIZECHARS(ClassName),
                                                 &ClassNameLength)) {
                        //
                        // We couldn't retrieve the corresponding class name.
                        // Set ClassNameLength to zero so that we reset class
                        // name below.
                        //
                        ClassNameLength = 0;
                    }

                } else {
                    //
                    // Resetting ClassGUID--we want to reset class name also.
                    //
                    ClassNameLength = 0;
                }

                CM_Set_DevInst_Registry_Property(DevInfoElem->DevInst,
                                                 CM_DRP_CLASS,
                                                 ClassNameLength ? (PVOID)ClassName : NULL,
                                                 ClassNameLength * sizeof(TCHAR),
                                                 0
                                                );

                //
                // Finally, update the device's class GUID, and also update the
                // caller-supplied SP_DEVINFO_DATA structure to reflect the device's
                // new class.
                //
                CopyMemory(&(DevInfoElem->ClassGuid),
                           (ClassGuidSpecified ? &ClassGuid : &GUID_NULL),
                           sizeof(GUID)
                          );

                CopyMemory(&(DeviceInfoData->ClassGuid),
                           (ClassGuidSpecified ? &ClassGuid : &GUID_NULL),
                           sizeof(GUID)
                          );
            }

        } else {

            switch(cr) {

                case CR_INVALID_DEVINST :
                    Err = ERROR_NO_SUCH_DEVINST;
                    break;

                case CR_INVALID_PROPERTY :
                    Err = ERROR_INVALID_REG_PROPERTY;
                    break;

                case CR_INVALID_DATA :
                    Err = ERROR_INVALID_PARAMETER;
                    break;

                default :
                    Err = ERROR_INVALID_DATA;
            }
        }

clean0:
        ; // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return (Err == NO_ERROR);
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiSetDeviceRegistryPropertyA(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData,
    IN     DWORD            Property,
    IN     CONST BYTE*      PropertyBuffer,    OPTIONAL
    IN     DWORD            PropertyBufferSize
    )
{
    BOOL b;

    b = _SetupDiSetDeviceRegistryProperty(
            DeviceInfoSet,
            DeviceInfoData,
            Property,
            PropertyBuffer,
            PropertyBufferSize,
            TRUE
            );

    return(b);
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupDiSetDeviceRegistryPropertyW(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData,
    IN     DWORD            Property,
    IN     CONST BYTE*      PropertyBuffer,    OPTIONAL
    IN     DWORD            PropertyBufferSize
    )
{
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceInfoData);
    UNREFERENCED_PARAMETER(Property);
    UNREFERENCED_PARAMETER(PropertyBuffer);
    UNREFERENCED_PARAMETER(PropertyBufferSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiSetDeviceRegistryProperty(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData,
    IN     DWORD            Property,
    IN     CONST BYTE*      PropertyBuffer,    OPTIONAL
    IN     DWORD            PropertyBufferSize
    )

/*++

Routine Description:

    This routine sets the specified Plug & Play device registry property.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        information about the device instance to set a Plug & Play registry
        property for.

    DeviceInfoData - Supplies a pointer to a SP_DEVINFO_DATA structure indicating
        the device instance to set the Plug & Play registry property for.  If the
        ClassGUID property is being set, then this structure will be updated upon
        return to reflect the device's new class.

    Property - Supplies an ordinal specifying the property to be set.  Refer to
        sdk\inc\setupapi.h for a complete listing of values that may be set
        (these values are denoted with 'R/W' in their descriptive comment).

    PropertyBuffer - Supplies the address of a buffer containing the new data
        for the property.  If the property is being cleared, then this pointer
        should be NULL, and PropertyBufferSize must be zero.

    PropertyBufferSize - Supplies the length, in bytes, of PropertyBuffer.  If
        PropertyBuffer isn't specified (i.e., the property is to be cleared),
        then this value must be zero.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    Note that the Class property cannot be set.  This is because it is based on
    the corresponding ClassGUID, and is automatically updated when that property
    changes.

    Also, note that when the ClassGUID property changes, this routine automatically
    cleans up any software keys associated with the device.  Otherwise, we would
    be left with orphaned registry keys.

--*/

{
    BOOL b;

    b = _SetupDiSetDeviceRegistryProperty(
            DeviceInfoSet,
            DeviceInfoData,
            Property,
            PropertyBuffer,
            PropertyBufferSize
#ifdef UNICODE
           ,FALSE
#endif
            );

    return(b);
}

DWORD
_SetupDiGetClassRegistryProperty(
    IN  CONST GUID      *ClassGuid,
    IN  DWORD            Property,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize,        OPTIONAL
    IN  PCTSTR           MachineName,         OPTIONAL
    IN  BOOL             Ansi
    )
/*++

    See SetupDiGetClassRegistryProperty

--*/
{
    DWORD Err;
    CONFIGRET cr;
    ULONG CmRegProperty, PropLength;
    HMACHINE hMachine = NULL;
    Err = NO_ERROR;

#ifndef UNICODE
    UNREFERENCED_PARAMETER(Ansi);
#endif

    try {
        //
        // if we want to set register for another machine, find that machine
        //
        if(MachineName) {

            if(CR_SUCCESS != (cr = CM_Connect_Machine(MachineName, &hMachine))) {
                //
                // Make sure machine handle is still invalid, so we won't
                // try to disconnect later.
                //
                hMachine = NULL;
                Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                leave;
            }
        }

        if(Property < SPCRP_MAXIMUM_PROPERTY) {
            CmRegProperty = (ULONG)SPCRP_TO_CMCRP(Property);
        } else {
            Err = ERROR_INVALID_REG_PROPERTY;
            leave;
        }

        PropLength = PropertyBufferSize;
    #ifdef UNICODE
        if(Ansi) {
            cr = CM_Get_Class_Registry_PropertyA(
                    (LPGUID)ClassGuid,
                    CmRegProperty,
                    PropertyRegDataType,
                    PropertyBuffer,
                    &PropLength,
                    0,
                    hMachine);
         } else {
             cr = CM_Get_Class_Registry_PropertyW(
                     (LPGUID)ClassGuid,
                     CmRegProperty,
                     PropertyRegDataType,
                     PropertyBuffer,
                     &PropLength,
                     0,
                     hMachine);
         }
    #else
        //
        // on ANSI version
        //
        cr = CM_Get_Class_Registry_Property(
                (LPGUID)ClassGuid,
                CmRegProperty,
                PropertyRegDataType,
                PropertyBuffer,
                &PropLength,
                0,
                hMachine);
    #endif

        if((cr == CR_SUCCESS) || (cr == CR_BUFFER_SMALL)) {

            if(RequiredSize) {
                *RequiredSize = PropLength;
            }
        }

        if(cr != CR_SUCCESS) {

            switch(cr) {

                case CR_INVALID_DEVINST :
                    Err = ERROR_NO_SUCH_DEVINST;
                    break;

                case CR_INVALID_PROPERTY :
                    Err = ERROR_INVALID_REG_PROPERTY;
                    break;

                case CR_BUFFER_SMALL :
                    Err = ERROR_INSUFFICIENT_BUFFER;
                    break;

                default :
                    Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    if (hMachine != NULL) {
        CM_Disconnect_Machine(hMachine);
    }

    return Err;
}

#ifdef UNICODE
//
// ANSI version
//
WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassRegistryPropertyA(
    IN  CONST GUID      *ClassGuid,
    IN  DWORD            Property,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize,        OPTIONAL
    IN  PCSTR            MachineName,         OPTIONAL
    IN  PVOID            Reserved
    )
/*++

    See SetupDiGetClassRegistryProperty

--*/
{
    PCWSTR MachineString = NULL;
    DWORD Err = NO_ERROR;

    if (Reserved != NULL) {
        //
        // make sure caller doesn't pass a value here
        // so we know we can use this at a later date
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    try {
        //
        // convert machine-name to local
        //

        if (MachineName != NULL) {
            MachineString = pSetupAnsiToUnicode(MachineName);
            if(!MachineString) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                leave;
            }
        }
        Err = _SetupDiGetClassRegistryProperty(ClassGuid,
                                                Property,
                                                PropertyRegDataType,
                                                PropertyBuffer,
                                                PropertyBufferSize,
                                                RequiredSize,
                                                MachineString,
                                                TRUE);

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = NO_ERROR;
    }
    if (MachineString != NULL) {
        MyFree(MachineString);
    }
    SetLastError(Err);
    return (BOOL)(Err == NO_ERROR);
}

#else
//
// UNICODE stub
//
WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassRegistryPropertyW(
    IN  CONST GUID       *ClassGuid,
    IN  DWORD            Property,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize,        OPTIONAL
    IN  PCWSTR           MachineName,         OPTIONAL
    IN  PVOID            Reserved
    )
/*++

    See SetupDiGetClassRegistryProperty

--*/
{
    UNREFERENCED_PARAMETER(ClassGuid);
    UNREFERENCED_PARAMETER(Property);
    UNREFERENCED_PARAMETER(PropertyRegDataType);
    UNREFERENCED_PARAMETER(PropertyBuffer);
    UNREFERENCED_PARAMETER(PropertyBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    UNREFERENCED_PARAMETER(MachineName);
    UNREFERENCED_PARAMETER(Reserved);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}

#endif // UNICODE

WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassRegistryProperty(
    IN  CONST GUID       *ClassGuid,
    IN  DWORD            Property,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize,        OPTIONAL
    IN  PCTSTR           MachineName,         OPTIONAL
    IN  PVOID            Reserved
    )
/*++

Routine Description:

    This routine gets the specified Plug & Play device class registry property.
    This is just a wrapper around the Config Mgr API
    Typically the properties here can be overridden on a per-device basis,
    however this routine returns the class properties only.

Arguments:

    ClassGuid - Supplies the class Guid that the property is to be got from

    Property - Supplies an ordinal specifying the property to be set.  Refer to
        sdk\inc\setupapi.h for a complete listing of values that may be set
        (these values are denoted with 'R/W' in their descriptive comment).

    PropertyBuffer - Supplies the address of a buffer containing the new data
        for the property.  If the property is being cleared, then this pointer
        should be NULL, and PropertyBufferSize must be zero.

    PropertyBufferSize - Supplies the length, in bytes, of PropertyBuffer.  If
        PropertyBuffer isn't specified (i.e., the property is to be cleared),
        then this value must be zero.

    MachineName - Allows properties to be set on a remote machine (if Non-NULL)

    Reserved - should be nULL

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    DWORD Err = NO_ERROR;

    if (Reserved != NULL) {
        //
        // make sure caller doesn't pass a value here
        // so we know we can use this at a later date
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    Err = _SetupDiGetClassRegistryProperty(ClassGuid,
                                            Property,
                                            PropertyRegDataType,
                                            PropertyBuffer,
                                            PropertyBufferSize,
                                            RequiredSize,
                                            MachineName,
                                            FALSE);

    SetLastError(Err);
    return (BOOL)(Err == NO_ERROR);
}


DWORD
_SetupDiSetClassRegistryProperty(
    IN  CONST GUID      *ClassGuid,
    IN  DWORD            Property,
    IN  CONST BYTE*      PropertyBuffer,      OPTIONAL
    IN  DWORD            PropertyBufferSize,
    IN  PCTSTR           MachineName,         OPTIONAL
    IN  BOOL             Ansi
    )
/*++

    See SetupDiGetClassRegistryProperty

--*/
{
    DWORD Err;
    CONFIGRET cr;
    ULONG CmRegProperty, PropLength;
    HMACHINE hMachine = NULL;

    Err = NO_ERROR;

    try {
        //
        // if we want to set register for another machine, find that machine
        //
        if(MachineName) {

            if(CR_SUCCESS != (cr = CM_Connect_Machine(MachineName, &hMachine))) {
                //
                // Make sure machine handle is still invalid, so we won't
                // try to disconnect later.
                //
                hMachine = NULL;
                Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                leave;
            }
        }

        if(Property < SPCRP_MAXIMUM_PROPERTY) {
            CmRegProperty = (ULONG)SPCRP_TO_CMCRP(Property);
        } else {
            Err = ERROR_INVALID_REG_PROPERTY;
            leave;
        }

        PropLength = PropertyBufferSize;

    #ifdef UNICODE
        if(Ansi) {
            cr = CM_Set_Class_Registry_PropertyA(
                    (LPGUID)ClassGuid,
                    CmRegProperty,
                    PropertyBuffer,
                    PropLength,
                    0,
                    hMachine);
         } else {
             cr = CM_Set_Class_Registry_PropertyW(
                     (LPGUID)ClassGuid,
                     CmRegProperty,
                     PropertyBuffer,
                     PropLength,
                     0,
                     hMachine);
         }
    #else
        //
        // on ANSI version
        //
        cr = CM_Set_Class_Registry_Property(
                (LPGUID)ClassGuid,
                CmRegProperty,
                PropertyBuffer,
                PropLength,
                0,
                hMachine);
    #endif

        if(cr != CR_SUCCESS) {

            switch(cr) {

                case CR_INVALID_PROPERTY :
                    Err = ERROR_INVALID_REG_PROPERTY;
                    break;

                default :
                    Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    if (hMachine != NULL) {
        CM_Disconnect_Machine(hMachine);
    }

    return Err;
}

#ifdef UNICODE
//
// ANSI version
//
WINSETUPAPI
BOOL
WINAPI
SetupDiSetClassRegistryPropertyA(
    IN     CONST GUID      *ClassGuid,
    IN     DWORD            Property,
    IN     CONST BYTE*      PropertyBuffer,    OPTIONAL
    IN     DWORD            PropertyBufferSize,
    IN     PCSTR            MachineName,       OPTIONAL
    IN     PVOID            Reserved
    )
/*++

    See SetupDiSetClassRegistryProperty

--*/
{
    PCWSTR MachineString = NULL;
    DWORD Err = NO_ERROR;

    if (Reserved != NULL) {
        //
        // make sure caller doesn't pass a value here
        // so we know we can use this at a later date
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    try {
        //
        // convert machine-name to local
        //

        if (MachineName != NULL) {
            MachineString = pSetupAnsiToUnicode(MachineName);
            if(!MachineString) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                leave;
            }
        }
        Err = _SetupDiSetClassRegistryProperty(ClassGuid,
                                                Property,
                                                PropertyBuffer,
                                                PropertyBufferSize,
                                                MachineString,
                                                TRUE);

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = NO_ERROR;
    }
    if (MachineString != NULL) {
        MyFree(MachineString);
    }
    SetLastError(Err);
    return (BOOL)(Err == NO_ERROR);
}

#else
//
// UNICODE stub
//
WINSETUPAPI
BOOL
WINAPI
SetupDiSetClassRegistryPropertyW(
    IN     CONST GUID      *ClassGuid,
    IN     DWORD            Property,
    IN     CONST BYTE*      PropertyBuffer,    OPTIONAL
    IN     DWORD            PropertyBufferSize,
    IN     PCWSTR           MachineName,       OPTIONAL
    IN     PVOID            Reserved
    )
/*++

    See SetupDiSetClassRegistryProperty

--*/
{
    UNREFERENCED_PARAMETER(ClassGuid);
    UNREFERENCED_PARAMETER(Property);
    UNREFERENCED_PARAMETER(PropertyBuffer);
    UNREFERENCED_PARAMETER(PropertyBufferSize);
    UNREFERENCED_PARAMETER(MachineName);
    UNREFERENCED_PARAMETER(Reserved);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}

#endif // UNICODE


WINSETUPAPI
BOOL
WINAPI
SetupDiSetClassRegistryProperty(
    IN     CONST GUID      *ClassGuid,
    IN     DWORD            Property,
    IN     CONST BYTE*      PropertyBuffer,    OPTIONAL
    IN     DWORD            PropertyBufferSize,
    IN     PCTSTR           MachineName,       OPTIONAL
    IN     PVOID            Reserved
    )
/*++

Routine Description:

    This routine sets the specified Plug & Play device class registry property.
    This is just a wrapper around the Config Mgr API
    Typically the properties here can be overridden on a per-device basis

Arguments:

    ClassGuid - Supplies the class Guid for the P&P device, that the property is to
        be set for

    Property - Supplies an ordinal specifying the property to be retrieved.  Refer
        to sdk\inc\setupapi.h for a complete list of properties that may be retrieved.

    PropertyRegDataType - Optionally, supplies the address of a variable that
        will receive the data type of the property being retrieved.  This will
        be one of the standard registry data types (REG_SZ, REG_BINARY, etc.)

    PropertyBuffer - Supplies the address of a buffer that receives the property
        data.

    PropertyBufferSize - Supplies the length, in bytes, of PropertyBuffer.

    RequiredSize - Optionally, supplies the address of a variable that receives
        the number of bytes required to store the requested property in the buffer.

    MachineName - Allows properties to be got from a remote machine (if Non-NULL)

    Reserved - should be nULL

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    DWORD Err;

    Err = _SetupDiSetClassRegistryProperty(ClassGuid,
                                            Property,
                                            PropertyBuffer,
                                            PropertyBufferSize,
                                            MachineName,
                                            FALSE);
    SetLastError(Err);
    return (BOOL)(Err == NO_ERROR);
}




BOOL
pSetupFindUniqueKey(
    IN HKEY   hkRoot,
    IN LPTSTR SubKey,
    IN ULONG  SubKeyLength
    )
/*++

Routine Description:

    This routine finds a unique key under the specified subkey.  This key is
    of the form <SubKey>\xxxx, where xxxx is a base-10, 4-digit number.

Arguments:

    hkRoot - Root key under which the specified SubKey is located.

    SubKey - Name of the subkey, under which a unique key is to be generated.

    SubKeyLength - Supplies the length of the SubKey string, not including
        terminating NULL.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.

--*/
{
    INT  i;
    HKEY hk;

    for(i = 0; i <= 9999; i++) {
        wsprintf(&(SubKey[SubKeyLength]), pszUniqueSubKey, i);
        if(RegOpenKeyEx(hkRoot, SubKey, 0, KEY_READ, &hk) != ERROR_SUCCESS) {
            return TRUE;
        }
        RegCloseKey(hk);
    }
    return FALSE;
}


BOOL
WINAPI
SetupDiDeleteDevRegKey(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Scope,
    IN DWORD            HwProfile,
    IN DWORD            KeyType
    )
/*++

Routine Description:

    This routine deletes the specified registry key(s) associated with a device
    information element.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device instance to delete key(s) for.

    DeviceInfoData - Supplies a pointer to a SP_DEVINFO_DATA structure indicating
        the device instance to delete key(s) for.

    Scope - Specifies the scope of the registry key to be deleted.  This determines
        where the key to be deleted is located--the key may be one that is global
        (i.e., constant regardless of current hardware profile) or hardware
        profile-specific.  May be a combination of the following values:

        DICS_FLAG_GLOBAL - Delete the key that stores global configuration information.

        DICS_FLAG_CONFIGSPECIFIC - Delete the key that stores hardware profile-specific
                                   information.

    HwProfile - Specifies the hardware profile to delete a key for, if the Scope parameter
        includes the DICS_FLAG_CONFIGSPECIFIC flag.  If this parameter is 0, then the key
        for the current hardware profile should be deleted (i.e., in the Class branch
        under HKEY_CURRENT_CONFIG).  If this parameter is 0xFFFFFFFF, then the key for
        _all_ hardware profiles should be deleted.

    KeyType - Specifies the type of registry storage key to be deleted.  May be one of
        the following values:

        DIREG_DEV - Delete the hardware registry key for the device.  This is the key for
            storage of driver-independent configuration information.  (This key is in
            the device instance key in the Enum branch.

        DIREG_DRV - Delete the software (i.e., driver) registry key for the device.  (This key
            is located in the class branch.)

        DIREG_BOTH - Delete both the hardware and software keys for the device.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    CONFIGRET cr;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    try {
        //
        // Get a pointer to the element for the specified device
        // instance.
        //
        if(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                   DeviceInfoData,
                                                   NULL)) {

            Err = pSetupDeleteDevRegKeys(DevInfoElem->DevInst, Scope, HwProfile, KeyType, FALSE);

        } else {
            Err = ERROR_INVALID_PARAMETER;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


DWORD
pSetupDeleteDevRegKeys(
    IN DEVINST DevInst,
    IN DWORD   Scope,
    IN DWORD   HwProfile,
    IN DWORD   KeyType,
    IN BOOL    DeleteUserKeys
    )
/*++

Routine Description:

    This is the worker routine for SetupDiDeleteDevRegKey.  See the discussion of
    that API for details.

Return Value:

    If successful, the return value is NO_ERROR;

    If failure, the return value is a Win32 error code indicating the cause of failure.

Remarks:

    Even if one of the operations in this routine fails, all operations will be attempted.
    Thus, as many keys as possible will be deleted.  The error returned will be the first
    error that was encountered in this case.

--*/
{
    CONFIGRET cr, crTemp;
    DWORD Err;

    cr = CR_SUCCESS;

    if(Scope & DICS_FLAG_GLOBAL) {

        if((KeyType == DIREG_DEV) || (KeyType == DIREG_BOTH)) {
            crTemp = CM_Delete_DevInst_Key(DevInst, 0, CM_REGISTRY_HARDWARE);
            if((cr == CR_SUCCESS) && (crTemp != CR_SUCCESS) && (crTemp != CR_NO_SUCH_REGISTRY_KEY)) {
                cr = crTemp;
            }
        }

        if((KeyType == DIREG_DRV) || (KeyType == DIREG_BOTH)) {
            crTemp = CM_Delete_DevInst_Key(DevInst, 0, CM_REGISTRY_SOFTWARE);
            if((cr == CR_SUCCESS) && (crTemp != CR_SUCCESS) && (crTemp != CR_NO_SUCH_REGISTRY_KEY)) {
                cr = crTemp;
            }
        }
    }

    if(Scope & DICS_FLAG_CONFIGSPECIFIC) {

        if((KeyType == DIREG_DEV) || (KeyType == DIREG_BOTH)) {
            crTemp = CM_Delete_DevInst_Key(DevInst, HwProfile, CM_REGISTRY_HARDWARE | CM_REGISTRY_CONFIG);
            if((cr == CR_SUCCESS) && (crTemp != CR_SUCCESS) && (crTemp != CR_NO_SUCH_REGISTRY_KEY)) {
                cr = crTemp;
            }
        }

        if((KeyType == DIREG_DRV) || (KeyType == DIREG_BOTH)) {
            crTemp = CM_Delete_DevInst_Key(DevInst, HwProfile, CM_REGISTRY_SOFTWARE | CM_REGISTRY_CONFIG);
            if((cr == CR_SUCCESS) && (crTemp != CR_SUCCESS) && (crTemp != CR_NO_SUCH_REGISTRY_KEY)) {
                cr = crTemp;
            }
        }
    }

    if(DeleteUserKeys) {

        if((KeyType == DIREG_DEV) || (KeyType == DIREG_BOTH)) {
            crTemp = CM_Delete_DevInst_Key(DevInst, 0, CM_REGISTRY_HARDWARE | CM_REGISTRY_USER);
            if((cr == CR_SUCCESS) && (crTemp != CR_SUCCESS) && (crTemp != CR_NO_SUCH_REGISTRY_KEY)) {
                cr = crTemp;
            }
        }

        if((KeyType == DIREG_DRV) || (KeyType == DIREG_BOTH)) {
            crTemp = CM_Delete_DevInst_Key(DevInst, 0, CM_REGISTRY_SOFTWARE | CM_REGISTRY_USER);
            if((cr == CR_SUCCESS) && (crTemp != CR_SUCCESS) && (crTemp != CR_NO_SUCH_REGISTRY_KEY)) {
                cr = crTemp;
            }
        }
    }

    //
    // Now translate the ConfigMgr return code into a Win32 one.
    //
    switch(cr) {

        case CR_SUCCESS :
            Err = NO_ERROR;
            break;

        case CR_REGISTRY_ERROR :
            Err = ERROR_ACCESS_DENIED;
            break;

        case CR_INVALID_DEVINST :
            Err = ERROR_NO_SUCH_DEVINST;
            break;

        default :
            Err = ERROR_INVALID_DATA;
    }

    return Err;
}


#ifdef UNICODE
//
// ANSI version
//
HKEY
WINAPI
SetupDiCreateDeviceInterfaceRegKeyA(
    IN HDEVINFO                  DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN DWORD                     Reserved,
    IN REGSAM                    samDesired,
    IN HINF                      InfHandle,           OPTIONAL
    IN PCSTR                     InfSectionName       OPTIONAL
    )
{
    DWORD rc;
    PWSTR name;
    HKEY h;

    if(InfSectionName) {
        rc = pSetupCaptureAndConvertAnsiArg(InfSectionName, &name);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(INVALID_HANDLE_VALUE);
        }
    } else {
        name = NULL;
    }

    h = SetupDiCreateDeviceInterfaceRegKeyW(DeviceInfoSet,
                                            DeviceInterfaceData,
                                            Reserved,
                                            samDesired,
                                            InfHandle,
                                            name
                                           );

    rc = GetLastError();

    if(name) {
        MyFree(name);
    }
    SetLastError(rc);
    return(h);
}
#else
//
// Unicode stub
//
HKEY
WINAPI
SetupDiCreateDeviceInterfaceRegKeyW(
    IN HDEVINFO                  DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN DWORD                     Reserved,
    IN REGSAM                    samDesired,
    IN HINF                      InfHandle,           OPTIONAL
    IN PCWSTR                    InfSectionName       OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceInterfaceData);
    UNREFERENCED_PARAMETER(Reserved);
    UNREFERENCED_PARAMETER(samDesired);
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(InfSectionName);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(INVALID_HANDLE_VALUE);
}
#endif

HKEY
WINAPI
SetupDiCreateDeviceInterfaceRegKey(
    IN HDEVINFO                  DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN DWORD                     Reserved,
    IN REGSAM                    samDesired,
    IN HINF                      InfHandle,           OPTIONAL
    IN PCTSTR                    InfSectionName       OPTIONAL
    )
/*++

Routine Description:

    This routine creates a registry storage key for a particular device interface,
    and returns a handle to the key.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device interface for whom a registry key is to be created.

    DeviceInterfaceData - Supplies a pointer to a device interface data structure
        indicating which device interface a key is to be created for.

    Reserved - Reserved for future use, must be set to 0.

    samDesired - Specifies the registry access desired for the resulting key handle.

    InfHandle - Optionally, supplies the handle of an opened INF file containing an
        install section to be executed for the newly-created key.  If this parameter is
        specified, then InfSectionName must be specified as well.

    InfSectionName - Optionally, supplies the name of an install section in the INF
        file specified by InfHandle.  This section will be executed for the newly
        created key. If this parameter is specified, then InfHandle must be specified
        as well.

Return Value:

    If the function succeeds, the return value is a handle to a newly-created
    registry key where private configuration data pertaining to this device
    interface may be stored/retrieved.

    If the function fails, the return value is INVALID_HANDLE_VALUE.  To get
    extended error information, call GetLastError.

Remarks:

    The handle returned from this routine must be closed by calling RegCloseKey.

    During GUI-mode setup on Windows NT, quiet-install behavior is always
    employed in the absence of a user-supplied file queue, regardless of
    whether the device information element has the DI_QUIETINSTALL flag set.

--*/

{
    HKEY hk, hSubKey;
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    PSP_FILE_CALLBACK MsgHandler;
    PVOID MsgHandlerContext;
    BOOL MsgHandlerIsNativeCharWidth;
    BOOL NoProgressUI;

    if(Reserved != 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return INVALID_HANDLE_VALUE;
    }

    Err = NO_ERROR;
    hk = hSubKey = INVALID_HANDLE_VALUE;

    try {
        //
        // Get a pointer to the device information element for the specified
        // interface device.
        //
        if(!(DevInfoElem = FindDevInfoElemForInterfaceDevice(pDeviceInfoSet, DeviceInterfaceData))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        hk = SetupDiOpenClassRegKeyEx(&(DeviceInterfaceData->InterfaceClassGuid),
                                      KEY_READ,
                                      DIOCR_INTERFACE,
                                      NULL,
                                      NULL
                                     );

        if(hk == INVALID_HANDLE_VALUE) {
            //
            // We couldn't open the interface class subkey--this should never happen.
            //
            Err = GetLastError();
            goto clean0;
        }

        //
        // Now, create the client-accessible registry storage key for this interface device.
        //
        Err = pSetupOpenOrCreateInterfaceDeviceRegKey(hk,
                                                      pDeviceInfoSet,
                                                      DeviceInterfaceData,
                                                      TRUE,
                                                      samDesired,
                                                      &hSubKey
                                                     );

        RegCloseKey(hk);
        hk = INVALID_HANDLE_VALUE;

        if(Err != NO_ERROR) {
            goto clean0;
        }

        //
        // We successfully created the storage key, now run an INF install
        // section against it (if specified).
        //
        if(InfHandle && (InfHandle != INVALID_HANDLE_VALUE) && InfSectionName) {
            //
            // If a copy msg handler and context haven't been specified, then
            // use the default one.
            //
            if(DevInfoElem->InstallParamBlock.InstallMsgHandler) {
                MsgHandler        = DevInfoElem->InstallParamBlock.InstallMsgHandler;
                MsgHandlerContext = DevInfoElem->InstallParamBlock.InstallMsgHandlerContext;
                MsgHandlerIsNativeCharWidth = DevInfoElem->InstallParamBlock.InstallMsgHandlerIsNativeCharWidth;
            } else {

                NoProgressUI = (GuiSetupInProgress || (DevInfoElem->InstallParamBlock.Flags & DI_QUIETINSTALL));

                if(!(MsgHandlerContext = SetupInitDefaultQueueCallbackEx(
                                             DevInfoElem->InstallParamBlock.hwndParent,
                                             (NoProgressUI ? INVALID_HANDLE_VALUE : NULL),
                                             0,
                                             0,
                                             NULL))) {

                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean0;
                }
                MsgHandler = SetupDefaultQueueCallback;
                MsgHandlerIsNativeCharWidth = TRUE;
            }

            if(!_SetupInstallFromInfSection(DevInfoElem->InstallParamBlock.hwndParent,
                                            InfHandle,
                                            InfSectionName,
                                            SPINST_ALL ^ SPINST_LOGCONFIG,
                                            hSubKey,
                                            NULL,
                                            0,
                                            MsgHandler,
                                            MsgHandlerContext,
                                            INVALID_HANDLE_VALUE,
                                            NULL,
                                            MsgHandlerIsNativeCharWidth,
                                            NULL
                                            )) {
                Err = GetLastError();
            }

            //
            // If we used the default msg handler, release the default context
            // now.
            //
            if(!DevInfoElem->InstallParamBlock.InstallMsgHandler) {
                SetupTermDefaultQueueCallback(MsgHandlerContext);
            }
        }

clean0:
        ; // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;

        if(hk != INVALID_HANDLE_VALUE) {
            RegCloseKey(hk);
        }

        //
        // Access the following registry handle so that the compiler will
        // respect statement ordering w.r.t. its assignment.
        //
        hSubKey = hSubKey;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    if(Err == NO_ERROR) {
        return hSubKey;
    } else {
        if(hSubKey != INVALID_HANDLE_VALUE) {
            RegCloseKey(hSubKey);
        }
        SetLastError(Err);
        return INVALID_HANDLE_VALUE;
    }
}


HKEY
WINAPI
SetupDiOpenDeviceInterfaceRegKey(
    IN HDEVINFO                  DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN DWORD                     Reserved,
    IN REGSAM                    samDesired
    )
/*++

Routine Description:

    This routine opens a registry storage key for a particular device interface,
    and returns a handle to the key.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device interface for whom a registry key is to be opened.

    InterfaceDeviceData - Supplies a pointer to a device interface data structure
        indicating which device interface a key is to be opened for.

    Reserved - Reserved for future use, must be set to 0.

    samDesired - Specifies the access you require for this key.

Return Value:

    If the function succeeds, the return value is a handle to an opened registry
    key where private configuration data pertaining to this device interface may be
    stored/retrieved.

    If the function fails, the return value is INVALID_HANDLE_VALUE.  To get
    extended error information, call GetLastError.

Remarks:

    The handle returned from this routine must be closed by calling RegCloseKey.

--*/

{
    HKEY hk, hSubKey;
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;

    if(Reserved != 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return INVALID_HANDLE_VALUE;
    }

    Err = NO_ERROR;
    hk = INVALID_HANDLE_VALUE;

    try {
        //
        // Get a pointer to the device information element for the specified
        // interface device.
        //
        if(!(DevInfoElem = FindDevInfoElemForInterfaceDevice(pDeviceInfoSet, DeviceInterfaceData))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        hk = SetupDiOpenClassRegKeyEx(&(DeviceInterfaceData->InterfaceClassGuid),
                                      KEY_READ,
                                      DIOCR_INTERFACE,
                                      NULL,
                                      NULL
                                     );

        if(hk == INVALID_HANDLE_VALUE) {
            //
            // We couldn't open the interface class subkey--this should never happen.
            //
            Err = GetLastError();
            goto clean0;
        }

        //
        // Now, open up the client-accessible registry storage key for this interface device.
        //
        Err = pSetupOpenOrCreateInterfaceDeviceRegKey(hk,
                                                      pDeviceInfoSet,
                                                      DeviceInterfaceData,
                                                      FALSE,
                                                      samDesired,
                                                      &hSubKey
                                                     );

clean0:
        ; // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        //
        // Access the following registry handle so that the compiler will respect
        // statement ordering w.r.t. its assignment.
        //
        hk = hk;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    if(hk != INVALID_HANDLE_VALUE) {
        RegCloseKey(hk);
    }

    SetLastError(Err);
    return (Err == NO_ERROR) ? hSubKey : INVALID_HANDLE_VALUE;
}


BOOL
WINAPI
SetupDiDeleteDeviceInterfaceRegKey(
    IN HDEVINFO                  DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN DWORD                     Reserved
    )
/*++

Routine Description:

    This routine deletes the registry key associated with a device interface.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device interface whose registry key is to be deleted.

    DeviceInterfaceData - Supplies a pointer to a device interface data structure
        indicating which device interface is to have its registry key deleted.

    Reserved - Reserved for future use, must be set to 0.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    HKEY hk;
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;

    if(Reserved != 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    hk = INVALID_HANDLE_VALUE;

    try {
        //
        // Get a pointer to the device information element for the specified
        // interface device.
        //
        if(!(DevInfoElem = FindDevInfoElemForInterfaceDevice(pDeviceInfoSet, DeviceInterfaceData))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        hk = SetupDiOpenClassRegKeyEx(&(DeviceInterfaceData->InterfaceClassGuid),
                                      KEY_READ,
                                      DIOCR_INTERFACE,
                                      NULL,
                                      NULL
                                     );

        if(hk == INVALID_HANDLE_VALUE) {
            //
            // We couldn't open the interface class subkey--this should never happen.
            //
            Err = GetLastError();
            goto clean0;
        }

        //
        // Now delete the interface device key.
        //
        Err = pSetupDeleteInterfaceDeviceKey(hk, pDeviceInfoSet, DeviceInterfaceData);

clean0:
        ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        //
        // Access the following registry handle so the compiler will respect statement
        // ordering w.r.t. its assignment.
        //
        hk = hk;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    if(hk != INVALID_HANDLE_VALUE) {
        RegCloseKey(hk);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}


DWORD
pSetupOpenOrCreateInterfaceDeviceRegKey(
    IN  HKEY                      hInterfaceClassKey,
    IN  PDEVICE_INFO_SET          DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA InterfaceDeviceData,
    IN  BOOL                      Create,
    IN  REGSAM                    samDesired,
    OUT PHKEY                     hInterfaceDeviceKey
    )
/*++

Routine Description:

    This routine creates or opens a registry storage key for the specified
    interface device, and returns a handle to the opened key.

Arguments:

    hInterfaceClassKey - Supplies a handle to the opened driver key, underneath which
        resides the interface device key to be deleted.

    DeviceInfoSet - Supplies a pointer to the device information set containing
        the interface device for which a registry storage key is to be created/opened.

    InterfaceDeviceData - Supplies a pointer to an interface device data structure
        indicating which interface device a key is to be opened/created for.

    Create - Specifies whether the key should be created if doesn't already exist.

    samDesired - Specifies the access you require for this key.

    hInterfaceDeviceKey - Supplies the address of a variable that receives a handle
        to the requested registry key.  (This variable will only be written to if the
        handle is successfully opened.)

Return Value:

    If the function is successful, the return value is NO_ERROR, otherwise, it is
    the ERROR_* code indicating the error that occurred.

Remarks:

    The algorithm used to form the storage keys for an interface device must be kept
    in sync with the kernel mode implementation of IoOpenDeviceClassRegistryKey.

--*/
{
    DWORD Err;
    PINTERFACE_DEVICE_NODE InterfaceDeviceNode;
    LPGUID ClassGuid;
    HKEY hInterfaceDeviceRootKey, hSubKey;
    DWORD Disposition;
    PCTSTR DevicePath;

    Err = NO_ERROR;
    hInterfaceDeviceRootKey = INVALID_HANDLE_VALUE;
    try {
        //
        // Get the interface device node, and verify that its class matches what the
        // caller passed us.
        //
        InterfaceDeviceNode = (PINTERFACE_DEVICE_NODE)(InterfaceDeviceData->Reserved);
        ClassGuid = &(DeviceInfoSet->GuidTable[InterfaceDeviceNode->GuidIndex]);

        if(!IsEqualGUID(ClassGuid, &(InterfaceDeviceData->InterfaceClassGuid))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // Verify that this interface device hasn't been removed.
        //
        if(InterfaceDeviceNode->Flags & SPINT_REMOVED) {
            Err = ERROR_DEVICE_INTERFACE_REMOVED;
            goto clean0;
        }

        //
        // OK, now open the interface device's root storage key.
        //
        DevicePath = pStringTableStringFromId(DeviceInfoSet->StringTable,
                                              InterfaceDeviceNode->SymLinkName
                                             );

        if(ERROR_SUCCESS != OpenDeviceInterfaceSubKey(hInterfaceClassKey,
                                                      DevicePath,
                                                      KEY_READ,
                                                      &hInterfaceDeviceRootKey,
                                                      NULL,
                                                      NULL)) {
            //
            // Make sure hInterfaceDeviceRootKey is still INVALID_HANDLE_VALUE, so we
            // won't try to close it later.
            //
            hInterfaceDeviceRootKey = INVALID_HANDLE_VALUE;
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        if(Create) {

            Err = RegCreateKeyEx(hInterfaceDeviceRootKey,
                                 pszDeviceParameters,
                                 0,
                                 NULL,
                                 REG_OPTION_NON_VOLATILE,
                                 samDesired,
                                 NULL,
                                 &hSubKey,
                                 &Disposition
                                );
        } else {

            Err = RegOpenKeyEx(hInterfaceDeviceRootKey,
                               pszDeviceParameters,
                               0,
                               samDesired,
                               &hSubKey
                              );
        }

clean0:
        ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        //
        // Access the following variable so the compiler will respect statement ordering
        // w.r.t. assignment.
        //
        hInterfaceDeviceRootKey = hInterfaceDeviceRootKey;
    }

    if(hInterfaceDeviceRootKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(hInterfaceDeviceRootKey);
    }

    if(Err == NO_ERROR) {
        *hInterfaceDeviceKey = hSubKey;
    }

    return Err;
}


DWORD
pSetupDeleteInterfaceDeviceKey(
    IN HKEY                      hInterfaceClassKey,
    IN PDEVICE_INFO_SET          DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA InterfaceDeviceData
    )
/*++

Routine Description:

    This routine deletes an interface device registry key (recursively deleting
    any subkeys as well).

Arguments:

    hInterfaceClassKey - Supplies the handle to the registry key underneath which the 2-level
        interface class hierarchy exists.

    DeviceInfoSet - Supplies a pointer to the device information set containing
        the interface device whose registry key is to be deleted.

    InterfaceDeviceData - Supplies a pointer to an interface device data structure
        indicating which interface device is to have its registry key deleted.

Return Value:

    If successful, the return value is NO_ERROR;

    If failure, the return value is a Win32 error code indicating the cause of failure.

--*/
{
    DWORD Err;
    PINTERFACE_DEVICE_NODE InterfaceDeviceNode;
    LPGUID ClassGuid;
    HKEY hInterfaceDeviceRootKey;
    PCTSTR DevicePath;

    Err = NO_ERROR;
    hInterfaceDeviceRootKey = INVALID_HANDLE_VALUE;

    try {
        //
        // Get the interface device node, and verify that its class matches what the
        // caller passed us.
        //
        InterfaceDeviceNode = (PINTERFACE_DEVICE_NODE)(InterfaceDeviceData->Reserved);
        ClassGuid = &(DeviceInfoSet->GuidTable[InterfaceDeviceNode->GuidIndex]);

        if(!IsEqualGUID(ClassGuid, &(InterfaceDeviceData->InterfaceClassGuid))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // Verify that this interface device hasn't been removed.
        //
        if(InterfaceDeviceNode->Flags & SPINT_REMOVED) {
            Err = ERROR_DEVICE_INTERFACE_REMOVED;
            goto clean0;
        }

        //
        // OK, now open the interface device's root storage key.
        //
        DevicePath = pStringTableStringFromId(DeviceInfoSet->StringTable,
                                              InterfaceDeviceNode->SymLinkName
                                             );

        if(ERROR_SUCCESS != OpenDeviceInterfaceSubKey(hInterfaceClassKey,
                                                      DevicePath,
                                                      KEY_READ,
                                                      &hInterfaceDeviceRootKey,
                                                      NULL,
                                                      NULL)) {
            //
            // Make sure hInterfaceDeviceRootKey is still INVALID_HANDLE_VALUE, so we
            // won't try to close it later.
            //
            hInterfaceDeviceRootKey = INVALID_HANDLE_VALUE;
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        Err = pSetupRegistryDelnode(hInterfaceDeviceRootKey, pszDeviceParameters);

clean0:
        ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        //
        // Access the following variable so the compiler will respect statement ordering
        // w.r.t. assignment.
        //
        hInterfaceDeviceRootKey = hInterfaceDeviceRootKey;
    }

    if(hInterfaceDeviceRootKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(hInterfaceDeviceRootKey);
    }

    return Err;
}


#ifdef UNICODE
BOOL
WINAPI
_SetupDiGetCustomDeviceProperty(
    IN  HDEVINFO          DeviceInfoSet,
    IN  PSP_DEVINFO_DATA  DeviceInfoData,
    IN  CONST VOID       *CustomPropertyName, // ANSI or Unicode, depending on "Ansi" param.
    IN  DWORD             Flags,
    OUT PDWORD            PropertyRegDataType, OPTIONAL
    OUT PBYTE             PropertyBuffer,
    IN  DWORD             PropertyBufferSize,
    OUT PDWORD            RequiredSize,        OPTIONAL
    IN  BOOL              Ansi
    )
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    CONFIGRET cr;
    ULONG PropLength, CmFlags;

    //
    // At present, there's only one valid flag...
    //
    if(Flags & ~DICUSTOMDEVPROP_MERGE_MULTISZ) {
        SetLastError(ERROR_INVALID_FLAGS);
        return FALSE;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {
        //
        // Get a pointer to the element for the specified device
        // instance.
        //
        if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                     DeviceInfoData,
                                                     NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        if(Flags & DICUSTOMDEVPROP_MERGE_MULTISZ) {
            CmFlags = CM_CUSTOMDEVPROP_MERGE_MULTISZ;
        } else {
            CmFlags = 0;
        }

        PropLength = PropertyBufferSize;
        if(Ansi) {
            cr = CM_Get_DevInst_Custom_Property_ExA(
                    DevInfoElem->DevInst,
                    CustomPropertyName,
                    PropertyRegDataType,
                    PropertyBuffer,
                    &PropLength,
                    CmFlags,
                    pDeviceInfoSet->hMachine
                   );
        } else {
            cr = CM_Get_DevInst_Custom_Property_ExW(
                    DevInfoElem->DevInst,
                    CustomPropertyName,
                    PropertyRegDataType,
                    PropertyBuffer,
                    &PropLength,
                    CmFlags,
                    pDeviceInfoSet->hMachine
                   );
        }

        if((cr == CR_SUCCESS) || (cr == CR_BUFFER_SMALL)) {

            if(RequiredSize) {
                *RequiredSize = PropLength;
            }
        }

        if(cr != CR_SUCCESS) {

            switch(cr) {

                case CR_INVALID_DEVINST :
                    Err = ERROR_NO_SUCH_DEVINST;
                    break;

                case CR_BUFFER_SMALL :
                    Err = ERROR_INSUFFICIENT_BUFFER;
                    break;

                case CR_NO_SUCH_VALUE :
                    Err = ERROR_NOT_FOUND;
                    break;

                default :
                    Err = ERROR_INVALID_DATA;
            }
        }

clean0:
        ; // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return (Err == NO_ERROR);
}
#endif


#ifdef UNICODE
//
// Unicode version
//
BOOL
WINAPI
SetupDiGetCustomDevicePropertyW(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  PCWSTR           CustomPropertyName,
    IN  DWORD            Flags,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize         OPTIONAL
    )
/*++

Routine Description:

    This routine retrieves the data for the specified property, either from the
    device information element's hardware key, or from the most-specific
    per-hardware-id storage key containing that property.

Arguments:

    DeviceInfoSet -- Supplies a handle to the device information set containing
        information about the device instance to retrieve a Plug & Play
        registry property for.

    DeviceInfoData -- Supplies a pointer to a SP_DEVINFO_DATA structure
        indicating the device instance to retrieve the Plug & Play registry
        property for

    CustomPropertyName - Supplies the name of the property to be retrieved.

    Flags - Supplies flags controlling how the property data is to be
        retrieved.  May be a combination of the following values:

        DICUSTOMDEVPROP_MERGE_MULTISZ : Merge the devnode-specific REG_SZ or
                                        REG_MULTI_SZ property (if present) with
                                        the per-hardware-id REG_SZ or
                                        REG_MULTI_SZ property (if present).
                                        The resultant data will always be a
                                        multi-sz list.

    PropertyRegDataType -- Optionally, supplies the address of a variable that
        will receive the data type of the property being retrieved.  This will
        be one of the standard registry data types (REG_SZ, REG_BINARY, etc.)

    PropertyBuffer -- Supplies the address of a buffer that receives the
        property data.

    PropertyBufferSize -- Supplies the length, in bytes, of PropertyBuffer.

    RequiredSize -- Optionally, supplies the address of a variable that
        receives the number of bytes required to store the requested property
        in the buffer.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.  If the supplied buffer was not large
    enough to hold the requested property, the error will be
    ERROR_INSUFFICIENT_BUFFER and RequiredSize will specify how large the
    buffer needs to be.

--*/

{
    BOOL b;

    b = _SetupDiGetCustomDeviceProperty(
            DeviceInfoSet,
            DeviceInfoData,
            CustomPropertyName,
            Flags,
            PropertyRegDataType,
            PropertyBuffer,
            PropertyBufferSize,
            RequiredSize,
            FALSE           // want Unicode results
            );

    return(b);
}

//
// ANSI version
//
BOOL
WINAPI
SetupDiGetCustomDevicePropertyA(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  PCSTR            CustomPropertyName,
    IN  DWORD            Flags,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize         OPTIONAL
    )

/*++

Routine Description:

    (See SetupDiGetCustomDevicePropertyW)

--*/

{
    BOOL b;

    b = _SetupDiGetCustomDeviceProperty(
            DeviceInfoSet,
            DeviceInfoData,
            CustomPropertyName,
            Flags,
            PropertyRegDataType,
            PropertyBuffer,
            PropertyBufferSize,
            RequiredSize,
            TRUE            // want ANSI results
            );

    return(b);
}


#else   // Both Unicode and ANSI stubs are unimplemented in ANSI setupapi...
//
// Unicode stub
//
BOOL
WINAPI
SetupDiGetCustomDevicePropertyW(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  PCWSTR           CustomPropertyName,
    IN  DWORD            Flags,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize         OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceInfoData);
    UNREFERENCED_PARAMETER(CustomPropertyName);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(PropertyRegDataType);
    UNREFERENCED_PARAMETER(PropertyBuffer);
    UNREFERENCED_PARAMETER(PropertyBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}

//
// ANSI stub
//
BOOL
WINAPI
SetupDiGetCustomDevicePropertyA(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  PCSTR            CustomPropertyName,
    IN  DWORD            Flags,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize         OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceInfoData);
    UNREFERENCED_PARAMETER(CustomPropertyName);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(PropertyRegDataType);
    UNREFERENCED_PARAMETER(PropertyBuffer);
    UNREFERENCED_PARAMETER(PropertyBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\devres.h ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    devres.c

Abstract:

    Header for resource dialog routines

Author:

    Paula Tomlinson (paulat) 7-Feb-1996

--*/

#pragma once

#define MAX_MSG_LEN         512
#define MAX_VAL_LEN         25

#define MAX_SPINRANGE   0x7FFF

#define MAX_RES_PROPERTY_PAGES          6

#define DMPROP_FLAG_CHANGESSAVED        0x00000001
#define DMPROP_FLAG_64BIT_RANGE         0x00000002
#define DMPROP_FLAG_CLASSNAMECHANGED    0x00000100
#define DMPROP_FLAG_DEVDESCCHANGED      0x00000200
#define DMPROP_FLAG_DRVDESCCHANGED      0x00000400
#define DMPROP_FLAG_GLOBALDISCHANGED    0x00000800
#define DMPROP_FLAG_PROFILECHANGED      0x00001000
#define DMPROP_FLAG_DEVREMOVED          0x00002000
#define DMPROP_FLAG_VIEWONLYRES         0x00004000
#define DMPROP_FLAG_DEVUSAGECHANGE      0x00008000
#define DMPROP_FLAG_USESYSSETTINGS      0x00010000
#define DMPROP_FLAG_FIXEDCONFIG         0x00020000
#define DMPROP_FLAG_FORCEDONLY          0x00040000

#define DMPROP_FLAG_HASPROBLEM          0x00800000
#define DMPROP_FLAG_DISPLAY_ALLOC       0x01000000
#define DMPROP_FLAG_DISPLAY_BOOT        0x02000000
#define DMPROP_FLAG_DISPLAY_FORCED      0x04000000
#define DMPROP_FLAG_DISPLAY_BASIC       0x08000000
#define DMPROP_FLAG_DISPLAY_MASK        0x0f000000
#define DMPROP_FLAG_PARTIAL_MATCH       0x10000000
#define DMPROP_FLAG_MATCH_OUT_OF_ORDER  0x20000000
#define DMPROP_FLAG_NO_RESOURCES        0x40000000
#define DMPROP_FLAG_SINGLE_CONFIG       0x80000000

#define DEVRES_HELP TEXT("devmgr.hlp")

#ifdef ANSI_SETUPAPI
#define DEVRES_WIDTH_FLAGS (0)
#define DEVRES_PIRQ_RESOURCE PIRQ_RESOURCE
#define DEVRES_IRQ_RESOURCE IRQ_RESOURCE
#define DEVRES_AFFINITY ULONG32
#else
#define DEVRES_WIDTH_FLAGS CM_RESDES_WIDTH_64
#define DEVRES_PIRQ_RESOURCE PIRQ_RESOURCE_64
#define DEVRES_IRQ_RESOURCE IRQ_RESOURCE_64
#define DEVRES_AFFINITY ULONG64
#endif

typedef struct {
    PROPSHEETPAGE    psp;
    HIMAGELIST       himlResourceImages;
    ULONG            ConfigListLCType;
    LOG_CONF         CurrentLC;
    ULONG            CurrentLCType;
    LOG_CONF         MatchingLC;
    ULONG            MatchingLCType;
    LOG_CONF         SelectedLC;
    ULONG            SelectedLCType;
    HDEVINFO         hDevInfo;
    PSP_DEVINFO_DATA lpdi;
    HWND             hDlg;
    DWORD            dwFlags;
    DEVINST          DevInst;
    TCHAR            szDeviceID[MAX_DEVICE_ID_LEN];
    HANDLE           hDialogEvent;
} DMPROP_DATA, *LPDMPROP_DATA;

typedef struct {
    RESOURCEID  ResourceType;
    ULONG64     ulValue;
    ULONG64     ulLen;
} LCDATA, *PLCDATA;


typedef struct {
    RESOURCEID  ResType;
    RES_DES     MatchingResDes;
    ULONG       RangeCount;
    ULONG64     ulValue;
    ULONG64     ulLen;
    ULONG64     ulEnd;
    ULONG       ulFlags;
    BOOL        bValid;
    BOOL        bFixed;
} ITEMDATA, *PITEMDATA;


typedef struct  _ResourceEditInfo_tag {
    HWND             hDlg;
    ULONG            dwPropFlags;
    WORD             wResNum;
    RESOURCEID       ridResType;        // resource type
    LOG_CONF         KnownLC;
    LOG_CONF         MatchingBasicLC;
    LOG_CONF         SelectedBasicLC;
    RES_DES          ResDes;            // res des that values are based on
    LPBYTE           pData;             // data for ResDes field
    //DEVINST          dnDevInst;
    ULONG            ulRangeCount;      // range that resource settings are based on
    ULONG64          ulCurrentVal;      // current resource start value
    ULONG64          ulCurrentLen;      // current resource range length
    ULONG64          ulCurrentEnd;      // current resource end value
    ULONG            ulCurrentFlags;    // current resource type specific flag
    PSP_DEVINFO_DATA lpdi;              // only used for devinst
    DWORD            dwFlags;           // internal state information
    BOOL             bShareable;         // Resource is shareable
    HMACHINE         hMachine;
}   RESOURCEEDITINFO, *PRESOURCEEDITINFO;

// ClearEditResConflictList Flags defines
#define CEF_UNKNOWN             0x00000001

#define REI_FLAGS_CONFLICT      0x00000001
#define REI_FLAG_NONUSEREDIT    0x00000002
#define REI_FLAG_MODIFY         0x00000004


typedef struct Generic_Des_s {
   DWORD    GENERIC_Count;
   DWORD    GENERIC_Type;
} GENERIC_DES, *PGENERIC_DES;

typedef struct Generic_Resource_S {
   GENERIC_DES    GENERIC_Header;
} GENERIC_RESOURCE, *PGENERIC_RESOURCE;

#define szNoValue                   TEXT(" ?")
#define szOneDWordHexNoConflict     TEXT("%08lX")
#define szTwoDWordHexNoConflict     TEXT("%08lX - %08lX")
#define szOne64bitHexNoConflict     TEXT("%016I64X")
#define szTwo64bitHexNoConflict     TEXT("%016I64X - %016I64X")
#define szOneWordHexNoConflict      TEXT("%04lX")
#define szTwoWordHexNoConflict      TEXT("%04lX - %04lX")
#define szOneDecNoConflict          TEXT("%02u")

#define NO_LC_MATCH         (0x00000000)
#define LC_MATCH_SUPERSET   (0x00000001)
#define LC_MATCH_SUBSET     (0x00000002)
#define LC_MATCH            (0x00000003)
#define ORDERED_LC_MATCH    (0x00000004)

typedef struct _RESDES_ENTRY {
    struct _RESDES_ENTRY *Next;
    struct _RESDES_ENTRY *CrossLink;
    LPBYTE      ResDesData;
    RESOURCEID  ResDesType;
    ULONG       ResDesDataSize;
    RES_DES     ResDesHandle;
} RESDES_ENTRY, *PRESDES_ENTRY;

typedef struct _RDE_LIST {
    struct _RDE_LIST *Prev;
    struct _RDE_LIST *Next;
    PRESDES_ENTRY Entry;
} RDE_LIST, *PRDE_LIST;

typedef struct _ITEMDATA_LISTNODE {
    struct _ITEMDATA_LISTNODE  *Next;
    PITEMDATA                   ItemData;
} ITEMDATA_LISTNODE, *PITEMDATA_LISTNODE;

//
// NTRAID#166214-2000/08/19-JamieHun Conflict Supression Hack
// this stuff needs to be fixed proper
//

#define MAX_CE_TAGS (8)             // only recognise first 8 tags specified
#define CE_TAG_RESERVED TEXT("*")   // special tag
#define CE_RES_IO TEXT("IO")
#define CE_RES_MEM TEXT("MEM")
#define CE_RES_IRQ TEXT("IRQ")
#define CE_RES_DMA TEXT("DMA")

typedef struct _CE_TAGS {
    LONG    nTags;
    LONG    Tag[MAX_CE_TAGS];
} CE_TAGS, *PCE_TAGS;

typedef struct _CE_ENTRY {
    struct _CE_ENTRY * Next;
    RESOURCEID resType;
    ULONG64 resStart;
    ULONG64 resEnd;
    CE_TAGS tags;
} CE_ENTRY, *PCE_ENTRY;

typedef struct _CONFLICT_EXCEPTIONS {
    PVOID ceTagMap;
    PCE_ENTRY exceptions;
} CONFLICT_EXCEPTIONS, *PCONFLICT_EXCEPTIONS;

//
// Prototypes
//
HPROPSHEETPAGE
GetResourceSelectionPage(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    );

INT_PTR
CALLBACK
pResourcePickerDlgProc(
   HWND   hDlg,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   );


UINT CALLBACK pResourcePickerPropPageCallback(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp
);

HMACHINE
pGetMachine(
    LPDMPROP_DATA   lpdmpd
    );

BOOL
pInitDevResourceDlg(
    LPDMPROP_DATA   lpdmpd
    );

PITEMDATA
pGetResourceToChange(
    IN  LPDMPROP_DATA   lpdmpd,
    OUT int             *pCur
    );

VOID
pCheckEnableResourceChange(
    LPDMPROP_DATA   lpdmpd
    );

BOOL
pDevHasConfig(
    DEVINST     DevInst,
    ULONG       ulConfigType,
    HMACHINE    hMachine
    );

DWORD
pGetMinLCPriority(
    IN DEVINST DevInst,
    IN ULONG   ulConfigType,
    IN HMACHINE hMachine
    );

BOOL
pDevRequiresResources(
    DEVINST DevInst,
    HMACHINE hMachine
    );

BOOL
pGetCurrentConfig(
    IN OUT  LPDMPROP_DATA lpdmpd
    );

void
pGetHdrValues(
    IN  LPBYTE      pData,
    IN  RESOURCEID  ResType,
    OUT PULONG64    pulValue,
    OUT PULONG64    pulLen,
    OUT PULONG64    pulEnd,
    OUT PULONG      pulFlags
    );

void
pGetRangeValues(
    IN  LPBYTE      pData,
    IN  RESOURCEID  ResType,
    IN  ULONG       ulIndex,
    OUT PULONG64    pulValue, OPTIONAL
    OUT PULONG64    pulLen, OPTIONAL
    OUT PULONG64    pulEnd, OPTIONAL
    OUT PULONG64    pulAlign, OPTIONAL
    OUT PULONG      pulFlags OPTIONAL
    );

BOOL
pAlignValues(
    IN OUT PULONG64  pulValue,
    IN     ULONG64   ulStart,
    IN     ULONG64   ulLen,
    IN     ULONG64   ulEnd,
    IN     ULONG64   ulAlignment,
    IN     int       Increment
    );

void
pFormatResString(
    LPDMPROP_DATA lpdmpd,
    LPTSTR      lpszString,
    ULONG64     ulVal,
    ULONG64     ulLen,
    RESOURCEID  ResType
    );

BOOL
pUnFormatResString(
    LPTSTR      lpszString,
    PULONG64    pulVal,
    PULONG64    pulEnd,
    RESOURCEID  ridResType
    );

BOOL
pConvertEditText(
    LPTSTR      lpszConvert,
    PULONG64    pulVal,
    RESOURCEID  ridResType
    );

void
pWarnResSettingNotEditable(
    HWND    hDlg,
    WORD    idWarning
    );

LPVOID
pGetListViewItemData(
    HWND hList,
    int iItem,
    int iSubItem
    );

BOOL
pSaveDevResSettings(
    LPDMPROP_DATA   lpdmpd
    );

BOOL
pSaveCustomResSettings(
    LPDMPROP_DATA   lpdmpd,
    IN HMACHINE     hMachine
    );

BOOL
pWriteResDesRangeToForced(
    IN LOG_CONF     ForcedLogConf,
    IN RESOURCEID   ResType,
    IN ULONG        RangeIndex,
    IN RES_DES      RD,             OPTIONAL
    IN LPBYTE       ResDesData,     OPTIONAL
    IN HMACHINE     hMachine        OPTIONAL
    );

BOOL
pWriteValuesToForced(
    IN LOG_CONF     ForcedLogConf,
    IN RESOURCEID   ResType,
    IN ULONG        RangeIndex,
    IN RES_DES      RD,
    IN ULONG64      ulValue,
    IN ULONG64      ulLen,
    IN ULONG64      ulEnd,
    IN HMACHINE     hMachine
    );

BOOL
MakeResourceData(
    OUT LPBYTE     *ppResourceData,
    OUT PULONG     pulSize,
    IN  RESOURCEID ResType,
    IN  ULONG64    ulValue,
    IN  ULONG64    ulLen,
    IN  ULONG      ulFlags
    );

BOOL
pShowWindow(
    IN HWND hWnd,
    IN int nShow
    );

BOOL
pEnableWindow(
    IN HWND hWnd,
    IN BOOL Enable
    );

BOOL
pGetResDesDataList(
    IN LOG_CONF LogConf,
    IN OUT PRESDES_ENTRY *pResList,
    IN BOOL bArbitratedOnly,
    IN HMACHINE hMachine
    );

VOID
pDeleteResDesDataList(
    IN PRESDES_ENTRY pResList
    );

VOID
pHideAllControls(
    IN LPDMPROP_DATA lpdmpd
    );

VOID
pShowViewNoResources(
    IN LPDMPROP_DATA lpdmpd
    );

BOOL
pShowViewMFReadOnly(
    IN LPDMPROP_DATA lpdmpd,
    IN BOOL HideIfProb
    );

BOOL
pShowViewReadOnly(
    IN LPDMPROP_DATA lpdmpd,
    IN BOOL HideIfProb
    );

VOID
pShowViewNoAlloc(
    IN LPDMPROP_DATA lpdmpd
    );

VOID
pShowViewNeedForced(
    IN LPDMPROP_DATA lpdmpd
    );

VOID
pShowViewAllEdit(
    IN LPDMPROP_DATA lpdmpd
    );

BOOL
pLoadCurrentConfig(
    IN LPDMPROP_DATA lpdmpd,
    BOOL ReadOnly
    );

BOOL
pLoadConfig(
    LPDMPROP_DATA lpdmpd,
    LOG_CONF forceLC,
    ULONG forceLCType
    );

BOOL
bIsMultiFunctionChild(
    PSP_DEVINFO_DATA lpdi,
    HMACHINE         hMachine
    );

VOID
pSelectLogConf(
    LPDMPROP_DATA lpdmpd,
    LOG_CONF forceLC,
    ULONG forceLCType,
    BOOL Always
    );


VOID
pChangeCurrentResSetting(
    IN LPDMPROP_DATA lpdmpd
    );

VOID
pShowConflicts(
    IN LPDMPROP_DATA lpdmpd
    );

VOID
pShowUpdateEdit(
    IN LPDMPROP_DATA lpdmpd
    );

int
pWarnNoSave(
    HWND    hDlg,
    WORD    idWarning
    );

BOOL
pOkToSave(
    IN LPDMPROP_DATA lpdmpd
    );


//
//
//


BOOL
pGetMatchingRange(
    IN ULONG64  ulKnownValue,
    IN ULONG64  ulKnownLen,
    IN LPBYTE   pData,
    IN RESOURCEID ResType,
    OUT PULONG  pRange,
    OUT PBOOL   pExact,
    OUT PULONG  pFlags
    );

ULONG
pMergeResDesDataLists(
    IN OUT PRESDES_ENTRY pKnown,
    IN OUT PRESDES_ENTRY pTest,
    OUT PULONG pMatchCount
    );

ULONG
pCompareLogConf(
    IN LOG_CONF KnownLogConf,
    IN LOG_CONF TestLogConf,
    IN HMACHINE hMachine,
    OUT PULONG pMatchCount
    );

BOOL
pFindMatchingAllocConfig(
    IN  LPDMPROP_DATA lpdmpd
    );

BOOL
pGetMatchingResDes(
    IN ULONG64    ulKnownValue,
    IN ULONG64    ulKnownLen,
    IN ULONG64    ulKnownEnd,
    IN RESOURCEID ResType,
    IN LOG_CONF   MatchingLogConf,
    OUT PRES_DES  pMatchingResDes,
    IN HMACHINE   hMachine
    );

BOOL
pConfigHasNoAlternates(
    LPDMPROP_DATA lpdmpd,
    LOG_CONF testLC
    );

//
// NTRAID#166214-2000/08/19-JamieHun Conflict Supression Hack
// this stuff needs to be fixed proper
//
PCONFLICT_EXCEPTIONS pLoadConflictExceptions(
    IN LPDMPROP_DATA lpdmpd
    );

VOID pFreeConflictExceptions(
    IN PCONFLICT_EXCEPTIONS pExceptions
    );

BOOL pIsConflictException(
    IN LPDMPROP_DATA lpdmpd,
    IN PCONFLICT_EXCEPTIONS pExceptions,
    IN DEVINST devConflict,
    IN PCTSTR resDesc,
    IN RESOURCEID resType,
    IN ULONG64 resValue,
    IN ULONG64 resLength
    );

INT_PTR
WINAPI
EditResourceDlgProc(
    HWND    hDlg,
    UINT    wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
LocateClosestValue(
    IN LPBYTE      pData,
    IN RESOURCEID  ResType,
    IN ULONG64     TestValue,
    IN ULONG64     TestLen,
    IN INT         Mode,
    OUT PULONG64   OutValue, OPTIONAL
    OUT PULONG64   OutLen, OPTIONAL
    OUT PULONG     OutIndex OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\devprop.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devprop.c

Abstract:

    Device Installer functions for property sheet support.

Author:

    Lonny McMichael (lonnym) 07-Sep-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// Private routine prototypes.
//
BOOL
CALLBACK
pSetupAddPropPage(
    IN HPROPSHEETPAGE hPage,
    IN LPARAM         lParam
   );


//
// Define the context structure that gets passed to pSetupAddPropPage as lParam.
//
typedef struct _SP_PROPPAGE_ADDPROC_CONTEXT {

    BOOL              NoCancelOnFailure;   // input
    LPPROPSHEETHEADER PropertySheetHeader; // input
    DWORD             PageListSize;        // input
    DWORD             NumPages;            // output

} SP_PROPPAGE_ADDPROC_CONTEXT, *PSP_PROPPAGE_ADDPROC_CONTEXT;


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiGetClassDevPropertySheetsA(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData,                  OPTIONAL
    IN  LPPROPSHEETHEADERA PropertySheetHeader,
    IN  DWORD              PropertySheetHeaderPageListSize,
    OUT PDWORD             RequiredSize,                    OPTIONAL
    IN  DWORD              PropertySheetType
    )
{
    PROPSHEETHEADERW UnicodePropertySheetHeader;
    DWORD Err = NO_ERROR;

    //
    // Make sure we're running interactively.
    //
    if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
        SetLastError(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION);
        return FALSE;
    }

    //
    // None of the fields that we care about in this structure contain
    // characters.  Thus, we'll simply copy over the fields we need into
    // our unicode property sheet header, and pass that into the W-API.
    //
    // The fields that we care about are the following:
    //
    //     dwFlags (in)
    //     nPages  (in/out)
    //     phpage  (in/out)
    //
    ZeroMemory(&UnicodePropertySheetHeader, sizeof(UnicodePropertySheetHeader));

    try {

        UnicodePropertySheetHeader.dwFlags = PropertySheetHeader->dwFlags;
        UnicodePropertySheetHeader.nPages  = PropertySheetHeader->nPages;
        UnicodePropertySheetHeader.phpage  = PropertySheetHeader->phpage;

        if(SetupDiGetClassDevPropertySheetsW(DeviceInfoSet,
                                             DeviceInfoData,
                                             &UnicodePropertySheetHeader,
                                             PropertySheetHeaderPageListSize,
                                             RequiredSize,
                                             PropertySheetType)) {

            PropertySheetHeader->nPages = UnicodePropertySheetHeader.nPages;
            PropertySheetHeader->phpage = UnicodePropertySheetHeader.phpage;

        } else {
            Err = GetLastError();
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupDiGetClassDevPropertySheetsW(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData,                  OPTIONAL
    IN  LPPROPSHEETHEADERW PropertySheetHeader,
    IN  DWORD              PropertySheetHeaderPageListSize,
    OUT PDWORD             RequiredSize,                    OPTIONAL
    IN  DWORD              PropertySheetType
    )
{
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceInfoData);
    UNREFERENCED_PARAMETER(PropertySheetHeader);
    UNREFERENCED_PARAMETER(PropertySheetHeaderPageListSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    UNREFERENCED_PARAMETER(PropertySheetType);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiGetClassDevPropertySheets(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData,                  OPTIONAL
    IN  LPPROPSHEETHEADER  PropertySheetHeader,
    IN  DWORD              PropertySheetHeaderPageListSize,
    OUT PDWORD             RequiredSize,                    OPTIONAL
    IN  DWORD              PropertySheetType
    )
/*++

Routine Description:

    This routine adds property sheets to the supplied property sheet
    header for the device information set or element.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set for
        which property sheets are to be retrieved.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure for which property sheets are to be retrieved.  If this
        parameter is not specified, then property sheets are retrieved based
        on the global class driver list associated with the device information
        set itself.

    PropertySheetHeader - Supplies the property sheet header to which the
        property sheets are to be added.

        NOTE:  PropertySheetHeader->dwFlags _must not_ have the PSH_PROPSHEETPAGE
        flag set, or this API will fail with ERROR_INVALID_FLAGS.

    PropertySheetHeaderPageListSize - Specifies the size of the
        HPROPSHEETPAGE array pointed to by the PropertySheetHeader->phpage.
        Note that this is _not_ the same value as PropertySheetHeader->nPages.
        The latter specifies the number of page handles currently in the
        list.  The number of pages that may be added by this routine equals
        PropertySheetHeaderPageListSize - PropertySheetHeader->nPages.  If the
        property page provider attempts to add more pages than the property
        sheet header list can hold, this API will fail, and GetLastError will
        return ERROR_INSUFFICIENT_BUFFER.  However, any pages that have already
        been added will be in the PropertySheetHeader->phpage list, and the
        nPages field will contain the correct count.  It is the caller's
        responsibility to destroy all property page handles in this list via
        DestroyPropertySheetPage (unless the caller goes ahead and uses
        PropertySheetHeader in a call to PropertySheet).

    RequiredSize - Optionally, supplies the address of a variable that receives
        the number of property page handles added to the PropertySheetHeader.  If
        this API fails with ERROR_INSUFFICIENT_BUFFER, this variable will be set
        to the total number of property pages that the property page provider(s)
        _attempted to add_ (i.e., including those which were not successfully
        added because the PropertySheetHeader->phpage array wasn't big enough).

        Note:  This number will not equal PropertySheetHeader->nPages upon return
        if either (a) there were already property pages in the list before this
        API was called, or (b) the call failed with ERROR_INSUFFICIENT_BUFFER.

    PropertySheetType - Specifies what type of property sheets are to be
        retrieved.  May be one of the following values:

        DIGCDP_FLAG_BASIC - Retrieve basic property sheets (typically, for
                            CPL applets).

        DIGCDP_FLAG_ADVANCED - Retrieve advanced property sheets (typically,
                               for the Device Manager).

        DIGCDP_FLAG_REMOTE_BASIC - Currently not used.

        DIGCDP_FLAG_REMOTE_ADVANCED - Retrieve advanced property sheets for a device
                                      on a remote machine (typically, for the Device
                                      Manager).

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    PDEVINSTALL_PARAM_BLOCK InstallParamBlock;
    LPGUID ClassGuid;
    HKEY hk;
    SP_PROPSHEETPAGE_REQUEST PropPageRequest;
    SP_PROPPAGE_ADDPROC_CONTEXT PropPageAddProcContext;
    SP_ADDPROPERTYPAGE_DATA PropertyPageData;
    UINT OriginalPageCount;
    SPFUSIONINSTANCE spFusionInstance;

    //
    // Make sure we're running interactively.
    //
    if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
        SetLastError(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION);
        return FALSE;
    }

    //
    // Make sure the caller passed us a valid PropertySheetType.
    //
    if((PropertySheetType != DIGCDP_FLAG_BASIC) &&
       (PropertySheetType != DIGCDP_FLAG_ADVANCED) &&
       (PropertySheetType != DIGCDP_FLAG_REMOTE_ADVANCED)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;
    DevInfoElem = NULL;
    hk = INVALID_HANDLE_VALUE;

    try {
        //
        // Make sure the property sheet header doesn't have the PSH_PROPSHEETPAGE flag set.
        //
        if(PropertySheetHeader->dwFlags & PSH_PROPSHEETPAGE) {
            Err = ERROR_INVALID_FLAGS;
            goto clean0;
        }

        //
        // Also, ensure that the parts of the property sheet header we'll be dealing with
        // look reasonable.
        //
        OriginalPageCount = PropertySheetHeader->nPages;

        if((OriginalPageCount > PropertySheetHeaderPageListSize) ||
           (PropertySheetHeaderPageListSize && !(PropertySheetHeader->phpage))) {

            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        if(DeviceInfoData) {
            //
            // Then we are to retrieve property sheets for a particular device.
            //
            if(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                       DeviceInfoData,
                                                       NULL))
            {
                InstallParamBlock = &(DevInfoElem->InstallParamBlock);
                ClassGuid = &(DevInfoElem->ClassGuid);

            } else {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }

        } else {
            //
            // We're retrieving (advanced) property pages for the set's class.
            //
            if(pDeviceInfoSet->HasClassGuid) {
                InstallParamBlock = &(pDeviceInfoSet->InstallParamBlock);
                ClassGuid = &(pDeviceInfoSet->ClassGuid);
            } else {
                Err = ERROR_NO_ASSOCIATED_CLASS;
                goto clean0;
            }
        }

        //
        // Fill in a property sheet request structure for later use.
        //
        PropPageRequest.cbSize         = sizeof(SP_PROPSHEETPAGE_REQUEST);
        PropPageRequest.DeviceInfoSet  = DeviceInfoSet;
        PropPageRequest.DeviceInfoData = DeviceInfoData;

        //
        // Fill in the context structure for use later on by our AddPropPageProc
        // callback.
        //
        PropPageAddProcContext.PropertySheetHeader = PropertySheetHeader;
        PropPageAddProcContext.PageListSize = PropertySheetHeaderPageListSize;
        PropPageAddProcContext.NumPages = 0;
        //
        // If the caller supplied the RequiredSize output parameter, then we don't
        // want to abort the callback process, even if we run out of space in the
        // hPage list.
        //
        PropPageAddProcContext.NoCancelOnFailure = RequiredSize ? TRUE : FALSE;


        //
        // Check if we should be getting Basic or Advanced Property Sheets.
        // Essentially, CPL's will want BASIC sheets, and the Device Manager
        // will want advanced sheets.
        //
        switch (PropertySheetType) {

        case DIGCDP_FLAG_BASIC:
            //
            // The BasicProperties32 entrypoint is only supplied via a device's
            // driver key.  Thus, a device information element must be specified
            // when basic property pages are requested.
            //
            // NOTE: this is different from setupx, which enumerates _all_ lpdi's
            // in the list, retrieving basic properties for each.  This doesn't
            // seem to have any practical application, and if it is really
            // required, then the caller can loop through each devinfo element
            // themselves, and retrieve basic property pages for each one.
            //
            if(!DevInfoElem) {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }

            //
            // If the basic property page provider has not been loaded, then load
            // it and get the function address for the BasicProperties32 function.
            //
            if(!InstallParamBlock->hinstBasicPropProvider) {

                hk = SetupDiOpenDevRegKey(DeviceInfoSet,
                                          DeviceInfoData,
                                          DICS_FLAG_GLOBAL,
                                          0,
                                          DIREG_DRV,
                                          KEY_READ
                                         );

                if(hk != INVALID_HANDLE_VALUE) {

                    try {
                        Err = GetModuleEntryPoint(hk,
                                                  pszBasicProperties32,
                                                  pszBasicPropDefaultProc,
                                                  &(InstallParamBlock->hinstBasicPropProvider),
                                                  &((FARPROC)InstallParamBlock->EnumBasicPropertiesEntryPoint),
                                                  &(InstallParamBlock->EnumBasicPropertiesFusionContext),
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  SetupapiVerifyNoProblem,
                                                  NULL,
                                                  DRIVERSIGN_NONE,
                                                  TRUE,
                                                  NULL
                                                 );

                        if(Err == ERROR_DI_DO_DEFAULT) {
                            //
                            // The BasicProperties32 value wasn't present--this is not an error.
                            //
                            Err = NO_ERROR;

                        } else if(Err != NO_ERROR) {
                            Err = ERROR_INVALID_PROPPAGE_PROVIDER;
                        }

                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        Err = ERROR_INVALID_PROPPAGE_PROVIDER;
                        InstallParamBlock->EnumBasicPropertiesEntryPoint = NULL;
                    }

                    RegCloseKey(hk);
                    hk = INVALID_HANDLE_VALUE;

                    if(Err != NO_ERROR) {
                        goto clean0;
                    }
                }
            }

            //
            // If there is a basic property page provider entry point, then call it.
            //
            if(InstallParamBlock->EnumBasicPropertiesEntryPoint) {

                PropPageRequest.PageRequested = SPPSR_ENUM_BASIC_DEVICE_PROPERTIES;

                //
                // We must first release the HDEVINFO lock, so we don't run into any weird
                // deadlock issues
                //
                UnlockDeviceInfoSet(pDeviceInfoSet);
                pDeviceInfoSet = NULL;

                spFusionEnterContext(InstallParamBlock->EnumBasicPropertiesFusionContext,
                                     &spFusionInstance);
                try {
                    InstallParamBlock->EnumBasicPropertiesEntryPoint(
                                             &PropPageRequest,
                                             pSetupAddPropPage,
                                             (LPARAM)&PropPageAddProcContext
                                            );
                } finally {
                    spFusionLeaveContext(&spFusionInstance);
                }
            }

            //
            // Now use the new DIF_ADDPROPERTYPAGE_BASIC call to see if any
            // class-/co-installers want to add basic property pages as well.
            //
            memset(&PropertyPageData, 0, sizeof(SP_ADDPROPERTYPAGE_DATA));
            PropertyPageData.ClassInstallHeader.InstallFunction = DIF_ADDPROPERTYPAGE_BASIC;
            PropertyPageData.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            PropertyPageData.hwndWizardDlg = PropertySheetHeader->hwndParent;

            Err = DoInstallActionWithParams(DIF_ADDPROPERTYPAGE_BASIC,
                                            DeviceInfoSet,
                                            DeviceInfoData,
                                            &PropertyPageData.ClassInstallHeader,
                                            sizeof(SP_ADDPROPERTYPAGE_DATA),
                                            INSTALLACTION_CALL_CI);

            if (ERROR_DI_DO_DEFAULT == Err) {

                //
                // The class-/co-installers do not have any pages to add--this is not an error.
                //
                Err = NO_ERROR;
            }

            if ((NO_ERROR == Err) &&
                (PropertyPageData.NumDynamicPages > 0))
            {
                DWORD NumPages = 0;

                while (NumPages < PropertyPageData.NumDynamicPages) {

                    pSetupAddPropPage(PropertyPageData.DynamicPages[NumPages++],
                                      (LPARAM)&PropPageAddProcContext
                                      );
                }
            }
            break;

        case DIGCDP_FLAG_ADVANCED:
            //
            // We're retrieving advanced property pages.  We want to look for EnumPropPages32
            // entries in both the class key and (if we're talking about a specific device) in
            // the device's driver key.
            //
            if(!InstallParamBlock->hinstClassPropProvider) {

                hk = SetupDiOpenClassRegKey(ClassGuid, KEY_READ);

                if(hk != INVALID_HANDLE_VALUE) {

                    try {
                        Err = GetModuleEntryPoint(hk,
                                                  pszEnumPropPages32,
                                                  pszEnumPropDefaultProc,
                                                  &(InstallParamBlock->hinstClassPropProvider),
                                                  &((FARPROC)InstallParamBlock->ClassEnumPropPagesEntryPoint),
                                                  &(InstallParamBlock->ClassEnumPropPagesFusionContext),
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  SetupapiVerifyNoProblem,
                                                  NULL,
                                                  DRIVERSIGN_NONE,
                                                  TRUE,
                                                  NULL
                                                 );

                        if(Err == ERROR_DI_DO_DEFAULT) {
                            //
                            // The EnumPropPages32 value wasn't present--this is not an error.
                            //
                            Err = NO_ERROR;

                        } else if(Err != NO_ERROR) {
                            Err = ERROR_INVALID_PROPPAGE_PROVIDER;
                        }

                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        Err = ERROR_INVALID_PROPPAGE_PROVIDER;
                        InstallParamBlock->ClassEnumPropPagesEntryPoint = NULL;
                    }

                    RegCloseKey(hk);
                    hk = INVALID_HANDLE_VALUE;

                    if(Err != NO_ERROR) {
                        goto clean0;
                    }
                }
            }

            if(DevInfoElem && !InstallParamBlock->hinstDevicePropProvider) {

                hk = SetupDiOpenDevRegKey(DeviceInfoSet,
                                          DeviceInfoData,
                                          DICS_FLAG_GLOBAL,
                                          0,
                                          DIREG_DRV,
                                          KEY_READ
                                         );

                if(hk != INVALID_HANDLE_VALUE) {

                    try {
                        Err = GetModuleEntryPoint(hk,
                                                  pszEnumPropPages32,
                                                  pszEnumPropDefaultProc,
                                                  &(InstallParamBlock->hinstDevicePropProvider),
                                                  &((FARPROC)InstallParamBlock->DeviceEnumPropPagesEntryPoint),
                                                  &(InstallParamBlock->DeviceEnumPropPagesFusionContext),
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  SetupapiVerifyNoProblem,
                                                  NULL,
                                                  DRIVERSIGN_NONE,
                                                  TRUE,
                                                  NULL
                                                 );

                        if(Err == ERROR_DI_DO_DEFAULT) {
                            //
                            // The EnumPropPages32 value wasn't present--this is not an error.
                            //
                            Err = NO_ERROR;

                        } else if(Err != NO_ERROR) {
                            Err = ERROR_INVALID_PROPPAGE_PROVIDER;
                        }

                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        Err = ERROR_INVALID_PROPPAGE_PROVIDER;
                        InstallParamBlock->DeviceEnumPropPagesEntryPoint = NULL;
                    }

                    RegCloseKey(hk);
                    hk = INVALID_HANDLE_VALUE;

                    if(Err != NO_ERROR) {
                        goto clean0;
                    }
                }
            }

            //
            // Clear the DI_GENERALPAGE_ADDED, DI_DRIVERPAGE_ADDED, and DI_RESOURCEPAGE_ADDED flags.
            //
            InstallParamBlock->Flags &= ~(DI_GENERALPAGE_ADDED | DI_RESOURCEPAGE_ADDED | DI_DRIVERPAGE_ADDED);

            PropPageRequest.PageRequested = SPPSR_ENUM_ADV_DEVICE_PROPERTIES;

            //
            // We must first release the HDEVINFO lock, so we don't run into any weird
            // deadlock issues
            //
            UnlockDeviceInfoSet(pDeviceInfoSet);
            pDeviceInfoSet = NULL;

            //
            // If there is an advanced property page provider for this class, then call it.
            //
            if(InstallParamBlock->ClassEnumPropPagesEntryPoint) {

                spFusionEnterContext(InstallParamBlock->ClassEnumPropPagesFusionContext,
                                     &spFusionInstance);
                try {
                    InstallParamBlock->ClassEnumPropPagesEntryPoint(
                                             &PropPageRequest,
                                             pSetupAddPropPage,
                                             (LPARAM)&PropPageAddProcContext
                                            );
                } finally {
                    spFusionLeaveContext(&spFusionInstance);
                }
            }

            //
            // If there is an advanced property page provider for this particular device, then call it.
            //
            if(InstallParamBlock->DeviceEnumPropPagesEntryPoint) {

                spFusionEnterContext(InstallParamBlock->DeviceEnumPropPagesFusionContext,
                                     &spFusionInstance);
                try {
                    InstallParamBlock->DeviceEnumPropPagesEntryPoint(
                                             &PropPageRequest,
                                             pSetupAddPropPage,
                                             (LPARAM)&PropPageAddProcContext
                                            );
                } finally {
                    spFusionLeaveContext(&spFusionInstance);
                }
            }

            //
            // Now use the new DIF_ADDPROPERTYPAGE_ADVANCED call to see if any
            // class-/co-installers want to add advanced property pages as well.
            //
            memset(&PropertyPageData, 0, sizeof(SP_ADDPROPERTYPAGE_DATA));
            PropertyPageData.ClassInstallHeader.InstallFunction = DIF_ADDPROPERTYPAGE_ADVANCED;
            PropertyPageData.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            PropertyPageData.hwndWizardDlg = PropertySheetHeader->hwndParent;

            Err = DoInstallActionWithParams(DIF_ADDPROPERTYPAGE_ADVANCED,
                                            DeviceInfoSet,
                                            DeviceInfoData,
                                            &PropertyPageData.ClassInstallHeader,
                                            sizeof(SP_ADDPROPERTYPAGE_DATA),
                                            INSTALLACTION_CALL_CI);

            if (ERROR_DI_DO_DEFAULT == Err) {

                //
                // The class-/co-installers do not have any pages to add--this is not an error.
                //
                Err = NO_ERROR;
            }

            if ((NO_ERROR == Err) ||
                (PropertyPageData.NumDynamicPages > 0))
            {
                DWORD NumPages = 0;

                while (NumPages < PropertyPageData.NumDynamicPages) {

                    pSetupAddPropPage(PropertyPageData.DynamicPages[NumPages++],
                                      (LPARAM)&PropPageAddProcContext
                                      );
                }
            }
            break;

        case DIGCDP_FLAG_REMOTE_ADVANCED:
            //
            // Now use the new DIF_ADDREMOTEPROPERTYPAGE_ADVANCED call to see if any
            // class-/co-installers want to add advanced property pages as well.
            //
            memset(&PropertyPageData, 0, sizeof(SP_ADDPROPERTYPAGE_DATA));
            PropertyPageData.ClassInstallHeader.InstallFunction = DIF_ADDREMOTEPROPERTYPAGE_ADVANCED;
            PropertyPageData.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            PropertyPageData.hwndWizardDlg = PropertySheetHeader->hwndParent;

            Err = DoInstallActionWithParams(DIF_ADDREMOTEPROPERTYPAGE_ADVANCED,
                                            DeviceInfoSet,
                                            DeviceInfoData,
                                            &PropertyPageData.ClassInstallHeader,
                                            sizeof(SP_ADDPROPERTYPAGE_DATA),
                                            INSTALLACTION_CALL_CI);

            if (ERROR_DI_DO_DEFAULT == Err) {

                //
                // The class-/co-installers do not have any pages to add--this is not an error.
                //
                Err = NO_ERROR;
            }

            if ((NO_ERROR == Err) ||
                (PropertyPageData.NumDynamicPages > 0))
            {
                DWORD NumPages = 0;

                while (NumPages < PropertyPageData.NumDynamicPages) {

                    pSetupAddPropPage(PropertyPageData.DynamicPages[NumPages++],
                                      (LPARAM)&PropPageAddProcContext
                                      );
                }
            }
            break;
        }

        if(RequiredSize) {
            *RequiredSize = PropPageAddProcContext.NumPages;
        }

        if((OriginalPageCount + PropPageAddProcContext.NumPages) > PropertySheetHeaderPageListSize) {
            Err = ERROR_INSUFFICIENT_BUFFER;
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;

        if(hk != INVALID_HANDLE_VALUE) {
            RegCloseKey(hk);
        }

        //
        // Reference the following variable so the compiler will respect our statement ordering
        // w.r.t. assignment.
        //
        pDeviceInfoSet = pDeviceInfoSet;
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
CALLBACK
pSetupAddPropPage(
    IN HPROPSHEETPAGE hPage,
    IN LPARAM         lParam
   )
/*++

Routine Description:

    This is the callback routine that is passed to property page providers.
    This routine is called for each property page that the provider wishes to
    add.

Arguments:

    hPage - Supplies a handle to the property page being added.

    lParam - Supplies a pointer to a context structure used when adding the new
        property page handle.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.

--*/
{
    PSP_PROPPAGE_ADDPROC_CONTEXT Context = (PSP_PROPPAGE_ADDPROC_CONTEXT)lParam;

    //
    // Regardless of whether we successfully add this new hPage, we want to keep
    // a count of how many pages we were asked to add.
    //
    Context->NumPages++;

    if(Context->PropertySheetHeader->nPages < Context->PageListSize) {
        Context->PropertySheetHeader->phpage[Context->PropertySheetHeader->nPages++] = hPage;
        return TRUE;
    }

    return Context->NoCancelOnFailure;
}


BOOL
CALLBACK
ExtensionPropSheetPageProc(
    IN LPVOID lpv,
    IN LPFNADDPROPSHEETPAGE lpfnAddPropSheetPageProc,
    IN LPARAM lParam
    )
{
    PSP_PROPSHEETPAGE_REQUEST PropPageRequest = (PSP_PROPSHEETPAGE_REQUEST)lpv;
    HPROPSHEETPAGE hPropSheetPage = NULL;
    BOOL b = FALSE;

    //
    // Make sure we're running interactively.
    //
    if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
        SetLastError(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION);
        return FALSE;
    }

    try {

        if(PropPageRequest->cbSize != sizeof(SP_PROPSHEETPAGE_REQUEST)) {
            goto clean0;
        }

        switch(PropPageRequest->PageRequested) {

            case SPPSR_SELECT_DEVICE_RESOURCES :

                if(!(hPropSheetPage = GetResourceSelectionPage(PropPageRequest->DeviceInfoSet,
                                                               PropPageRequest->DeviceInfoData))) {
                    goto clean0;
                }
                break;

            default :
                //
                // Don't know what to do with this request.
                //
                goto clean0;
        }

        if(lpfnAddPropSheetPageProc(hPropSheetPage, lParam)) {
            //
            // Page successfully handed off to requestor.  Reset our handle so that we don't
            // try to free it.
            //
            hPropSheetPage = NULL;
            b = TRUE;
        }

clean0: ; // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Access the hPropSheetPage variable, so that the compiler will respect our statement
        // order w.r.t. assignment.
        //
        hPropSheetPage = hPropSheetPage;
    }

    if(hPropSheetPage) {
        //
        // Property page was successfully created, but never handed off to requestor.  Free
        // it now.
        //
        DestroyPropertySheetPage(hPropSheetPage);
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\devres1.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    devres1.c

Abstract:

    Routines for displaying resource dialogs.

Author:

    Paula Tomlinson (paulat) 7-Feb-1996

Revision History:

    Jamie Hunter (jamiehun) 19-Mar-1998
        Removed EditResource Dialog Proceedures into this file
        Resource picking functionality improved


--*/

#include "precomp.h"
#pragma hdrstop

#define Nearness(x,y) (((x)>(y))?(x)-(y):(y)-(x))

static UDACCEL udAccel[] = {{0,1},{1,16},{2,256},{3,4096},{4,16000}};

static const DWORD EditResHelpIDs[]=
{
    IDC_EDITRES_INSTRUCTIONS,   IDH_NOHELP,
    IDC_EDITRES_MFCHILDREN,     IDH_NOHELP,
    IDC_EDITRES_VALUE_LABEL,    IDH_DEVMGR_RESOURCES_EDIT_VALUE,
    IDC_EDITRES_VALUE,          IDH_DEVMGR_RESOURCES_EDIT_VALUE,
    IDC_EDITRES_CONFLICTINFO,   IDH_DEVMGR_RESOURCES_EDIT_INFO,
    IDC_EDITRES_CONFLICTTEXT,   IDH_DEVMGR_RESOURCES_EDIT_INFO,
    IDC_EDITRES_CONFLICTLIST,   IDH_DEVMGR_RESOURCES_EDIT_INFO,
    0, 0
};


void
InitEditResDlg(
    HWND                hDlg,
    PRESOURCEEDITINFO   lprei,
    ULONG64             ulVal,
    ULONG64             ulLen
    );

void
ClearEditResConflictList(
    HWND    hDlg,
    DWORD   dwFlags
    );

void
UpdateEditResConflictList(
    HWND                hDlg,
    PRESOURCEEDITINFO   lprei,
    ULONG64             ulVal,
    ULONG64             ulLen,
    ULONG               ulFlags
    );

void
GetOtherValues(
    IN     LPBYTE      pData,
    IN     RESOURCEID  ResType,
    IN     LONG        Increment,
    OUT    PULONG64    pulValue,
    OUT    PULONG64    pulLen,
    OUT    PULONG64    pulEnd
    );

void
UpdateEditResConflictList(
    HWND                hDlg,
    PRESOURCEEDITINFO   lprei,
    ULONG64             ulVal,
    ULONG64             ulLen,
    ULONG               ulFlags
    );

BOOL
bValidateResourceVal(
    HWND                hDlg,
    PULONG64            pulVal,
    PULONG64            pulLen,
    PULONG64            pulEnd,
    PULONG              pulIndex,
    PRESOURCEEDITINFO   lprei
    );

BOOL
bConflictWarn(
    HWND                hDlg,
    ULONG64             ulVal,
    ULONG64             ulLen,
    ULONG64             ulEnd,
    PRESOURCEEDITINFO   lprei
    );

void
ClearEditResConflictList(
    HWND    hDlg,
    DWORD   dwFlags
    );

void
UpdateMFChildList(
    HWND                hDlg,
    PRESOURCEEDITINFO   lprei
    );

//---------------------------------------------------------------------------
// Edit Resource Dialog Box
//---------------------------------------------------------------------------



INT_PTR
WINAPI
EditResourceDlgProc(
    HWND    hDlg,
    UINT    wMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    TCHAR   szBuffer[MAX_PATH];
    //
    // ISSUE-2000/02/03-JamieHun Remove statics from EditResourceDlgProc
    //
    static  ULONG64   ulEditedValue, ulEditedLen, ulEditedEnd;


    switch (wMsg) {

        case WM_INITDIALOG: {

            PRESOURCEEDITINFO lprei = (PRESOURCEEDITINFO)lParam;
            ULONG             ulSize = 0;

            SetWindowLongPtr(hDlg, DWLP_USER, lParam);  // save for later msgs

            lprei->dwFlags &= ~REI_FLAGS_CONFLICT;   // no conflict yet
            lprei->dwFlags |= REI_FLAG_NONUSEREDIT; // no manual edits yet

            ulEditedValue = lprei->ulCurrentVal;
            ulEditedLen = lprei->ulCurrentLen;
            ulEditedEnd = lprei->ulCurrentEnd;

            InitEditResDlg(hDlg, lprei, ulEditedValue, ulEditedLen);

            SetFocus(GetDlgItem(hDlg, IDC_EDITRES_VALUE));
            break;  // return default (FALSE) to indicate we've set focus
        }

        case WM_NOTIFY: {

            PRESOURCEEDITINFO lprei = (PRESOURCEEDITINFO)GetWindowLongPtr(hDlg, DWLP_USER);
            LPNM_UPDOWN lpnm = (LPNM_UPDOWN)lParam;

            switch (lpnm->hdr.code) {

                case UDN_DELTAPOS:
                    if (lpnm->hdr.idFrom == IDC_EDITRES_SPIN) {

                        if (lpnm->iDelta > 0) {
                            GetOtherValues(lprei->pData, lprei->ridResType, +1,
                                           &ulEditedValue,
                                           &ulEditedLen,
                                           &ulEditedEnd);
                        } else {
                            GetOtherValues(lprei->pData, lprei->ridResType, -1,
                                           &ulEditedValue,
                                           &ulEditedLen,
                                           &ulEditedEnd);
                        }

                        pFormatResString(NULL,szBuffer, ulEditedValue, ulEditedLen,
                                        lprei->ridResType);

                        lprei->dwFlags |= REI_FLAG_NONUSEREDIT;
                        SetDlgItemText(hDlg, IDC_EDITRES_VALUE, szBuffer);
                        UpdateEditResConflictList(hDlg, lprei,
                                                  ulEditedValue,
                                                  ulEditedLen,
                                                  lprei->ulCurrentFlags);
                }
                break;
            }
            break;
        }

        case WM_COMMAND: {

            switch(LOWORD(wParam)) {

                case IDOK: {

                    PRESOURCEEDITINFO  lprei = (PRESOURCEEDITINFO) GetWindowLongPtr(hDlg, DWLP_USER);
                    ULONG ulIndex;

                    //
                    // Validate the values (could have been manually edited)
                    //
                    if (bValidateResourceVal(hDlg, &ulEditedValue, &ulEditedLen,
                                             &ulEditedEnd, &ulIndex, lprei)) {
                        //
                        // Warn if there is a conflict.  If use accepts conflict
                        // end the dialog, otherwise update the
                        // edit control since it may have been changed by the
                        // Validate call.
                        //
                        //No HMACHINE
                        if(bConflictWarn(hDlg, ulEditedValue, ulEditedLen,
                                         ulEditedEnd, lprei)) {

                            lprei->ulCurrentVal = ulEditedValue;
                            lprei->ulCurrentLen = ulEditedLen;
                            lprei->ulCurrentEnd = ulEditedEnd;
                            lprei->ulRangeCount = ulIndex;
                            EndDialog(hDlg, IDOK);

                            if (lprei->pData) {
                                MyFree(lprei->pData);
                            }

                        } else {
                            //
                            // Format and display the data
                            //
                            pFormatResString(NULL,szBuffer, ulEditedValue, ulEditedLen, lprei->ridResType);
                            SetDlgItemText(hDlg, IDC_EDITRES_VALUE, szBuffer);
                            //
                            // Update the Conflict List.
                            //
                            UpdateEditResConflictList(hDlg, lprei, ulEditedValue, ulEditedLen, lprei->ulCurrentFlags);
                        }

                    }
                    return TRUE;
                }

                case IDCANCEL: {

                    PRESOURCEEDITINFO lprei = (PRESOURCEEDITINFO)GetWindowLongPtr(hDlg, DWLP_USER);

                    if (lprei->pData) {
                        MyFree(lprei->pData);
                    }

                    EndDialog(hDlg, FALSE);
                    return TRUE;
                }

                case IDC_EDITRES_VALUE: {
                    switch (HIWORD(wParam)) {
                        case EN_CHANGE: {

                            PRESOURCEEDITINFO lprei = (PRESOURCEEDITINFO)GetWindowLongPtr(hDlg, DWLP_USER);

                            // If Non user edit, then clear the flag, else
                            // clear the conflict list, since we are unsure
                            // of what the user has entered at this time

                            if (lprei->dwFlags & REI_FLAG_NONUSEREDIT) {
                                lprei->dwFlags &= ~REI_FLAG_NONUSEREDIT;
                            } else {
                                ClearEditResConflictList(hDlg, CEF_UNKNOWN);
                            }
                            break;
                        }

                        // If the edit control looses focus, then we should
                        // validte the contents
                        case EN_KILLFOCUS: {
                        }
                        break;
                    }
                    break;
                }
            }
            break;
        }

        case WM_HELP:      // F1
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, DEVRES_HELP, HELP_WM_HELP, (ULONG_PTR)EditResHelpIDs);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND)wParam, DEVRES_HELP, HELP_CONTEXTMENU, (ULONG_PTR)EditResHelpIDs);
            break;
   }
   return FALSE;

} // EditResourceDlgProc




void
InitEditResDlg(
    HWND                hDlg,
    PRESOURCEEDITINFO   lprei,
    ULONG64             ulVal,
    ULONG64             ulLen
    )
{
    TCHAR       szBuffer[MAX_PATH], szInstr[MAX_PATH], szTemp[MAX_PATH],
                szResType[MAX_PATH], szResTypeLC[MAX_PATH];
    ULONG       ulSize = 0;


    //
    // Set the initial Value
    //
    pFormatResString(NULL,szBuffer, ulVal, ulLen, lprei->ridResType);
    SetDlgItemText(hDlg, IDC_EDITRES_VALUE, szBuffer);

    //
    // Setup the Spinner
    //
    SendDlgItemMessage(hDlg, IDC_EDITRES_SPIN, UDM_SETRANGE, 0, MAKELONG(MAX_SPINRANGE, 0));
    SendDlgItemMessage(hDlg, IDC_EDITRES_SPIN, UDM_SETPOS, 0, MAKELONG(0,0));
    SendDlgItemMessage(hDlg, IDC_EDITRES_SPIN, UDM_SETACCEL, 5, (LPARAM)(LPUDACCEL)udAccel);

    //
    // Limit the Edit Text.
    //
    switch (lprei->ridResType) {

        case ResType_Mem:
            LoadString(MyDllModuleHandle, IDS_MEMORY_FULL, szResType, MAX_PATH);
            LoadString(MyDllModuleHandle, IDS_MEMORY_FULL_LC, szResTypeLC, MAX_PATH);
            LoadString(MyDllModuleHandle, IDS_EDITRES_RANGEINSTR1, szInstr, MAX_PATH);
            LoadString(MyDllModuleHandle, IDS_EDITRES_RANGEINSTR2, szTemp, MAX_PATH);
            lstrcat(szInstr, szTemp);

            //
            // Limit the Input field to Start Val (8) + End Val(8) + seperator (4)
            //
            SendDlgItemMessage(hDlg, IDC_EDITRES_VALUE, EM_LIMITTEXT, 20, 0l);
            break;

        case ResType_IO:
            LoadString(MyDllModuleHandle, IDS_IO_FULL, szResType, MAX_PATH);
            LoadString(MyDllModuleHandle, IDS_EDITRES_RANGEINSTR1, szInstr, MAX_PATH);
            LoadString(MyDllModuleHandle, IDS_EDITRES_RANGEINSTR2, szTemp, MAX_PATH);
            LoadString(MyDllModuleHandle, IDS_IO_FULL_LC, szResTypeLC, MAX_PATH);
            lstrcat(szInstr, szTemp);

            //
            // Limit the Input field to Start Val (4) + End Val(4) + seperator (4)
            //
            SendDlgItemMessage(hDlg, IDC_EDITRES_VALUE, EM_LIMITTEXT, 12, 0l);
            break;

        case ResType_DMA:
            LoadString(MyDllModuleHandle, IDS_DMA_FULL, szResType, MAX_PATH);
            LoadString(MyDllModuleHandle, IDS_EDITRES_SINGLEINSTR1, szInstr, MAX_PATH);
            LoadString(MyDllModuleHandle, IDS_EDITRES_SINGLEINSTR2, szTemp, MAX_PATH);
            LoadString(MyDllModuleHandle, IDS_DMA_FULL_LC, szResTypeLC, MAX_PATH);
            lstrcat(szInstr, szTemp);

            //
            // Limit the Input field to Val (2)
            //
            SendDlgItemMessage(hDlg, IDC_EDITRES_VALUE, EM_LIMITTEXT, 2, 0l);
            break;

        case ResType_IRQ:
            LoadString(MyDllModuleHandle, IDS_IRQ_FULL, szResType, MAX_PATH);
            LoadString(MyDllModuleHandle, IDS_EDITRES_SINGLEINSTR1, szInstr, MAX_PATH);
            LoadString(MyDllModuleHandle, IDS_EDITRES_SINGLEINSTR2, szTemp, MAX_PATH);
            LoadString(MyDllModuleHandle, IDS_IRQ_FULL_LC, szResTypeLC, MAX_PATH);
            lstrcat(szInstr, szTemp);

            //
            // Limit the Input field to Val (2)
            //
            SendDlgItemMessage(hDlg, IDC_EDITRES_VALUE, EM_LIMITTEXT, 2, 0l);
            break;
    }

    //
    // Set the Instruction Text
    //
    wsprintf(szBuffer, szInstr, szResTypeLC);
    SetDlgItemText(hDlg, IDC_EDITRES_INSTRUCTIONS, szBuffer);

    //
    // Set the Dialog Title
    //
    LoadString(MyDllModuleHandle, IDS_EDITRES_TITLE, szTemp, MAX_PATH);
    wsprintf(szBuffer, szTemp, szResType);
    SetWindowText(hDlg, szBuffer);

    //
    // If this is a MF parent device, then show which children own this resource.
    //
    UpdateMFChildList(hDlg, lprei);

    //
    // Read the res des data and store a ptr to it so we
    // don't have to refetch it multiple times.
    //
    lprei->pData = NULL;
    if (CM_Get_Res_Des_Data_Size_Ex(&ulSize, lprei->ResDes, CM_RESDES_WIDTH_64,lprei->hMachine) == CR_SUCCESS) {
        lprei->pData = MyMalloc(ulSize);
        if (lprei->pData != NULL) {
            CM_Get_Res_Des_Data_Ex(lprei->ResDes, lprei->pData, ulSize, CM_RESDES_WIDTH_64,lprei->hMachine);
        }
    }

    //
    // Update the Conflict List.
    //
    UpdateEditResConflictList(hDlg, lprei, ulVal, ulLen, lprei->ulCurrentFlags);


} // InitEditResDlg



BOOL
LocateClosestValue(
    IN LPBYTE      pData,
    IN RESOURCEID  ResType,
    IN ULONG64     TestValue,
    IN ULONG64     TestLen,
    IN INT         Mode,
    OUT PULONG64   OutValue, OPTIONAL
    OUT PULONG64   OutLen, OPTIONAL
    OUT PULONG     OutIndex OPTIONAL
    )
/*++

Routine Description:

    This routine finds the nearest valid address/range
    to that the user specified
    if Mode == 0, the nearest value is used
    if Mode > 0, the nearest higher value is used
    if Mode < 0, the nearest lower value is used

Arguments:

    pData - information about the resources being selected
    ResType - type of resource being selected
    CurrentValue - value entered by user
    CurrentLen - length based on range entered by user
    Mode - search mode, -1 = previous, 1 = next, 0 = nearest
    OutValue - nearest valid value
    OutLen - length associated with nearest valid value

Return Value:

    If exact match found, return TRUE
    otherwise FALSE

--*/
{
    PGENERIC_RESOURCE   pGenRes = (PGENERIC_RESOURCE)pData;
    ULONG64 Start, Len, End, Align;
    ULONG Flags;
    ULONG64 BestVal;
    ULONG64 BestValL;
    ULONG64 BestValU;
    ULONG64 FoundVal = 0;
    ULONG64 FoundLen = 0;
    ULONG FoundIndex = 0;
    ULONG Index;
    BOOL FindNearest = TRUE; // indicates we should find nearest

    //
    // precedence (1) Value&Len match exactly
    // precedence (2) closest valid value
    //

    //
    // cover a catch-all case - start of the very first resource range
    //
    pGetRangeValues(pData, ResType, 0, &Start, &Len, &End, &Align, &Flags);
    //
    // we have at least 1 found value
    //
    FoundVal = Start;
    FoundLen = Len;

    //
    // Find a nearby valid range to the one supplied
    //

    //
    // check each range at a time
    // sometimes ranges may not be given in ascending order
    // eg, first range is a preferred, second range is alternative
    //
    for (Index = 0; Index < pGenRes->GENERIC_Header.GENERIC_Count; Index++) {

        //
        // get limits for this range
        //
        pGetRangeValues(pData, ResType, Index, &Start, &Len, &End, &Align, &Flags);

        //
        // first, try to find a value that is GOOD, that is <= TestValue
        //

        BestValL = TestValue;
        if (pAlignValues(&BestValL, Start, Len, End, Align, -1) == FALSE) {
            //
            // if it failed, use the lowest value in this range (ie Start)
            //
            BestValL = Start;
        }

        //
        // find an upper value that is aligned
        //
        if (BestValL == TestValue) {
            //
            // if match was exact, skip test
            //
            BestValU = TestValue;
        } else {
            //
            // search for upper limit
            //
            BestValU = TestValue;
            if (pAlignValues(&BestValU, Start, Len, End, Align, 1) == FALSE) {
                //
                // couldn't use it - find highest valid value
                //
                BestValU = End-Len+1;
                if (pAlignValues(&BestValU, Start, Len, End, Align, -1) == FALSE) {
                    //
                    // still no go
                    //
                    BestValU = BestValL;
                }
            }
        }

        //
        // now we have found our boundaries
        // may need to modify, depending on preferences
        //

        if (Mode<0) {
            //
            // if range is < TestVal, use highest, else lowest
            //
            if (BestValU <= TestValue) {
                BestVal = BestValU;
            } else {
                BestVal = BestValL;
            }
        } else if (Mode>0) {
            //
            // if range is > TestVal, use lowest, else highest
            //
            if (BestValL >= TestValue) {
                BestVal = BestValL;
            } else {
                BestVal = BestValU;
            }
        } else {
            //
            // use closest of the two values
            //
            if (Nearness(BestValL,TestValue)<= Nearness(BestValU,TestValue)) {
                BestVal = BestValL;
            } else {
                BestVal = BestValU;
            }
        }

        //
        // we know that BestVal is valid within the range
        // and is the choice for this range
        //

        //
        // handle the match cases
        //
        if (TestValue == BestVal && TestLen == Len) {
            //
            // exact match
            //

            if (OutValue != NULL) {
                *OutValue = BestVal;
            }
            if (OutLen != NULL) {
                *OutLen = Len;
            }
            if (OutIndex != NULL) {
                *OutIndex = Index;
            }
            return TRUE;
        }

        if (FindNearest && Mode != 0) {
            //
            // we are currently in "FindNearest" mode which means
            // we haven't found one in the direction we wanted
            //
            if (Mode < 0 && BestVal <= TestValue) {
                //
                // not looking for nearness now we've found one lower
                //
                FoundVal = BestVal;
                FoundLen = Len;
                FoundIndex = Index;
                FindNearest = FALSE;
            } else if (Mode > 0 && BestVal >= TestValue) {
                //
                // not looking for nearness now we've found one higher
                //
                FoundVal = BestVal;
                FoundLen = Len;
                FoundIndex = Index;
                FindNearest = FALSE;
            }

        } else if (FindNearest ||
            (Mode < 0 && BestVal <= TestValue) ||
            (Mode > 0 && BestVal >= TestValue)) {
            if (Nearness(BestVal,TestValue) < Nearness(FoundVal,TestValue)) {
                //
                // this address is nearer
                //
                FoundVal = BestVal;
                FoundLen = Len;
                FoundIndex = Index;
            } else if (Nearness(BestVal,TestValue) == Nearness(FoundVal,TestValue)) {
                //
                // this address guess is as near as nearest guess, pick the better length
                //
                // I can't see any place that this should happen
                // but theoretically it could happen
                // so this is a safety net more than anything else
                //
                if (Nearness(Len,TestLen) < Nearness(FoundLen,TestLen)) {
                    //
                    // this length is nearer
                    //
                    FoundVal = BestVal;
                    FoundLen = Len;
                    FoundIndex = Index;
                } else if (Nearness(Len,TestLen) == Nearness(FoundLen,TestLen)) {
                    //
                    // pick the bigger (safer)
                    //
                    if (Len > FoundLen) {
                        //
                        // this length is bigger
                        //
                        FoundVal = BestVal;
                        FoundLen = Len;
                        FoundIndex = Index;
                    }
                }
            }
        }
    }

    //
    // if we get here, we didn't find an exact match
    //

    // Use our best guess
    if (OutValue != NULL) {
        *OutValue = FoundVal;
    }
    if (OutLen != NULL) {
        *OutLen = FoundLen;
    }
    if (OutIndex != NULL) {
        *OutIndex = FoundIndex;
    }
    return FALSE;

}


void
GetOtherValues(
    IN     LPBYTE      pData,
    IN     RESOURCEID  ResType,
    IN     LONG        Increment,
    IN OUT PULONG64    pulValue,
    IN OUT PULONG64    pulLen,
    IN OUT PULONG64    pulEnd
    )
/*++

Routine Description:

    Finds the next valid value, wrapping around to beginning/end value when end of range

Arguments:

    pData - resource data
    ResType - resource type
    Increment - 1 or -1
    pulValue - pointer to old/new start that is changed
    pulLen - pointer to old/new length
    pulEnd - pointer to old/new end

Return Value:

    none

--*/
{

    ULONG64 TestValue = *pulValue;
    ULONG64 TestLen = *pulLen;
    ULONG64 RetValue = 0;
    ULONG64 RetLen = 0;

    MYASSERT((Increment == 1) || (Increment == -1));

    if (Increment == 1) {
        TestValue++;
        LocateClosestValue(pData,ResType,TestValue,TestLen, 1 ,&RetValue,&RetLen,NULL);
        if (RetValue < TestValue) {
            //
            // wrap around, find lowest possible valid address
            //
            LocateClosestValue(pData,ResType,0,TestLen, 0 ,&RetValue,&RetLen,NULL);
        }
    } else {
        TestValue--;
        LocateClosestValue(pData,ResType,TestValue,TestLen, -1 ,&RetValue,&RetLen,NULL);
        if (RetValue > TestValue) {
            //
            // wrap around, find highest possible valid address
            //
            LocateClosestValue(pData,ResType,(ULONG64)(-1),TestLen, 0 ,&RetValue,&RetLen,NULL);
        }
    }

    *pulValue = RetValue;
    *pulLen = RetLen;
    *pulEnd = RetValue + RetLen - 1;

    return;

} // GetOtherValues


void
UpdateEditResConflictList(
    HWND                hDlg,
    PRESOURCEEDITINFO   lprei,
    ULONG64             ulVal,
    ULONG64             ulLen,
    ULONG               ulFlags
    )
/*++

Routine Description:

    Updates all the conflict information for the selected resource
    Should give more details than UpdateDevResConflictList

Arguments:

    hDlg - handle of this dialog to display into
    lprei - resource edit info
    ulVal - value to try
    ulLen - length to test
    ulFlags - flags part of resdes

Return Value:

    none

--*/
{
    CONFIGRET   Status = CR_SUCCESS;
    HWND        hwndConflictList = GetDlgItem(hDlg, IDC_EDITRES_CONFLICTLIST);
    ULONG       ConflictCount = 0;
    ULONG       ConflictIndex = 0;
    ULONG       ulSize = 0;
    LPBYTE      pResourceData = NULL;
    CONFLICT_LIST ConflictList = 0;
    PDEVICE_INFO_SET pDeviceInfoSet;
    CONFLICT_DETAILS ConflictDetails;
    TCHAR       szBuffer[MAX_PATH];
    TCHAR       szItemFormat[MAX_PATH];
    BOOL        ReservedResource = FALSE;
    BOOL        BadResource = FALSE;

    //
    // need resource-data for determining conflict
    //
    if (MakeResourceData(&pResourceData, &ulSize,
                         lprei->ridResType,
                         ulVal,
                         ulLen,
                         ulFlags)) {

        Status = CM_Query_Resource_Conflict_List(&ConflictList,
                                                    lprei->lpdi->DevInst,
                                                    lprei->ridResType,
                                                    pResourceData,
                                                    ulSize,
                                                    DEVRES_WIDTH_FLAGS,
                                                    lprei->hMachine);

        if (Status != CR_SUCCESS) {
            //
            // error occurred
            //
            ConflictList = 0;
            ConflictCount =  0;
            BadResource = TRUE;
        } else {
            //
            // find out how many things conflicted
            //
            Status = CM_Get_Resource_Conflict_Count(ConflictList,&ConflictCount);
            if (Status != CR_SUCCESS) {
                //
                // error shouldn't occur
                //
                MYASSERT(Status == CR_SUCCESS);
                ConflictCount = 0;
                BadResource = TRUE;
            }
        }
    } else {
        MYASSERT(FALSE);
        //
        // should not fail
        //
        ConflictList = 0;
        ConflictCount =  0;
        BadResource = TRUE;
    }
    if (BadResource) {
        //
        // The resource conflict information is indeterminate
        //
        SendMessage(hwndConflictList, LB_RESETCONTENT, 0, 0L);
        lprei->dwFlags &= ~REI_FLAGS_CONFLICT;
        LoadString(MyDllModuleHandle, IDS_EDITRES_UNKNOWNCONFLICT, szBuffer, MAX_PATH);
        SetDlgItemText(hDlg, IDC_EDITRES_CONFLICTTEXT, szBuffer);
        LoadString(MyDllModuleHandle, IDS_EDITRES_UNKNOWNCONFLICTINGDEVS, szBuffer, MAX_PATH);
        SendMessage(hwndConflictList, LB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer);

    } else if (ConflictCount || ReservedResource) {

    TreatAsReserved:

        SendMessage(hwndConflictList, LB_RESETCONTENT, 0, 0L);
        lprei->dwFlags |= REI_FLAGS_CONFLICT;

        if(ReservedResource == FALSE) {
            //
            // The resource conflicts with another unknown device.
            //
            LoadString(MyDllModuleHandle, IDS_EDITRES_DEVCONFLICT, szBuffer, MAX_PATH);
            SetDlgItemText(hDlg, IDC_EDITRES_CONFLICTTEXT, szBuffer);

            for(ConflictIndex = 0; ConflictIndex < ConflictCount ; ConflictIndex++) {

                //
                // obtain details for this conflict
                //
                ZeroMemory(&ConflictDetails,sizeof(ConflictDetails));
                ConflictDetails.CD_ulSize = sizeof(ConflictDetails);
                ConflictDetails.CD_ulMask = CM_CDMASK_DEVINST | CM_CDMASK_DESCRIPTION | CM_CDMASK_FLAGS;

                Status = CM_Get_Resource_Conflict_Details(ConflictList,ConflictIndex,&ConflictDetails);
                if (Status == CR_SUCCESS) {
                    if ((ConflictDetails.CD_ulFlags & CM_CDFLAGS_RESERVED) != 0) {
                        //
                        // treat as reserved - backtrack
                        //
                        ReservedResource = TRUE;
                        goto TreatAsReserved;
                    }
                    //
                    // convert CD_dnDevInst to string information
                    //
                    lstrcpy(szBuffer,ConflictDetails.CD_szDescription);
                    if (szBuffer[0] == 0) {
                        ReservedResource = TRUE;
                        goto TreatAsReserved;
                    }

                } else {
                    MYASSERT(Status == CR_SUCCESS);
                    ReservedResource = TRUE;
                    goto TreatAsReserved;
                }

                SendMessage(hwndConflictList, LB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer);
            }
        } else {
            LoadString(MyDllModuleHandle, IDS_EDITRES_RESERVED, szBuffer, MAX_PATH);
            SetDlgItemText(hDlg, IDC_EDITRES_CONFLICTTEXT, szBuffer);
            LoadString(MyDllModuleHandle, IDS_EDITRES_RESERVEDRANGE, szBuffer, MAX_PATH);
            SendMessage(hwndConflictList, LB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer);
        }

    } else {
        //
        // The resource does not conflict with any other devices.
        //
        SendMessage(hwndConflictList, LB_RESETCONTENT, 0, 0L);
        lprei->dwFlags &= ~REI_FLAGS_CONFLICT;
        LoadString(MyDllModuleHandle, IDS_EDITRES_NOCONFLICT, szBuffer, MAX_PATH);
        SetDlgItemText(hDlg, IDC_EDITRES_CONFLICTTEXT, szBuffer);
        LoadString(MyDllModuleHandle, IDS_EDITRES_NOCONFLICTINGDEVS, szBuffer, MAX_PATH);
        SendMessage(hwndConflictList, LB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer);
    }

    if (ConflictList) {
        CM_Free_Resource_Conflict_Handle(ConflictList);
    }

    if (pResourceData != NULL) {
        MyFree(pResourceData);
    }

    return;
}


BOOL
bValidateResourceVal(
    HWND                hDlg,
    PULONG64            pulVal,
    PULONG64            pulLen,
    PULONG64            pulEnd,
    PULONG              pulIndex,
    PRESOURCEEDITINFO   lprei
    )
{
    TCHAR    szSetting[MAX_VAL_LEN], szNewSetting[MAX_VAL_LEN];
    TCHAR    szMessage[MAX_MSG_LEN], szTemp[MAX_MSG_LEN], szTemp1[MAX_MSG_LEN];
    TCHAR    szTitle[MAX_PATH];
    ULONG64  ulVal, ulEnd, ulLen;
    ULONG64  ulValidVal, ulValidLen;
    ULONG    ulIndex;
    BOOL     bRet;
    BOOL     exact = TRUE;


    GetDlgItemText(hDlg, IDC_EDITRES_VALUE, szSetting, MAX_VAL_LEN);

    if (pUnFormatResString(szSetting, &ulVal, &ulEnd, lprei->ridResType)) {

        ulLen = ulEnd - ulVal + 1;

        //
        // Validate the Current Settings
        //
        // If an exact match doesn't exist
        // use a close match
        // close is based on start address
        //

        if (LocateClosestValue(lprei->pData, lprei->ridResType,
                                ulVal, ulLen,0,
                                &ulValidVal, &ulValidLen,&ulIndex) == FALSE) {
            //
            // An alternate setting was found
            // we think this might be what the user wanted
            //
            LoadString(MyDllModuleHandle, IDS_EDITRES_ENTRYERROR, szTitle, MAX_PATH);

            LoadString(MyDllModuleHandle, IDS_EDITRES_VALIDATEERROR1, szTemp, MAX_MSG_LEN);
            LoadString(MyDllModuleHandle, IDS_EDITRES_VALIDATEERROR2, szTemp1, MAX_MSG_LEN);
            lstrcat(szTemp, szTemp1);
            LoadString(MyDllModuleHandle, IDS_EDITRES_VALIDATEERROR3, szTemp1, MAX_MSG_LEN);
            lstrcat(szTemp, szTemp1);

            pFormatResString(NULL, szSetting, ulVal, ulLen, lprei->ridResType);
            pFormatResString(NULL,szNewSetting, ulValidVal, ulValidLen, lprei->ridResType);

            wsprintf(szMessage, szTemp, szSetting, szNewSetting);

            if (MessageBox(hDlg, szMessage, szTitle,
                           MB_YESNO | MB_TASKMODAL | MB_ICONEXCLAMATION) == IDYES) {
                //
                // Update the Edited values.
                //
                *pulVal = ulValidVal;
                *pulLen = ulValidLen;
                *pulEnd = ulValidVal + ulValidLen - 1;
                *pulIndex = ulIndex;
                bRet = TRUE;
            } else {
                bRet = FALSE;
            }

        } else {
            //
            // The specified values are valid
            //
            *pulVal = ulVal;
            *pulLen = ulLen;
            *pulEnd = ulEnd;
            *pulIndex = ulIndex;
            bRet = TRUE;
        }

    } else {

        switch (lprei->ridResType) {
            case ResType_Mem:
                LoadString(MyDllModuleHandle, IDS_ERROR_BADMEMTEXT, szMessage, MAX_MSG_LEN);
                break;
            case ResType_IO:
                LoadString(MyDllModuleHandle, IDS_ERROR_BADIOTEXT, szMessage, MAX_MSG_LEN);
                break;
            case ResType_DMA:
                LoadString(MyDllModuleHandle, IDS_ERROR_BADDMATEXT, szMessage, MAX_MSG_LEN);
                break;
            case ResType_IRQ:
                LoadString(MyDllModuleHandle, IDS_ERROR_BADIRQTEXT, szMessage, MAX_MSG_LEN);
                break;
        }

        LoadString(MyDllModuleHandle, IDS_EDITRES_ENTRYERROR, szTitle, MAX_PATH);
        MessageBox(hDlg, szMessage, szTitle, MB_OK | MB_TASKMODAL | MB_ICONASTERISK);
        bRet = FALSE;
    }

    return bRet;

} // bValidateResoureceVal



BOOL
bConflictWarn(
    HWND                hDlg,
    ULONG64             ulVal,
    ULONG64             ulLen,
    ULONG64             ulEnd,
    PRESOURCEEDITINFO   lprei
    )
{
    BOOL    bRet = TRUE;
    TCHAR   szMessage[MAX_MSG_LEN], szTitle[MAX_PATH];


    if (!(lprei->dwFlags & REI_FLAG_NONUSEREDIT)) {
        //
        // user edits have been made so the conflict flag may not be
        // up-to-date, check conflicts now.
        //
        UpdateEditResConflictList(hDlg, lprei, ulVal, ulLen, lprei->ulCurrentFlags);
    }

    if (lprei->dwFlags & REI_FLAGS_CONFLICT) {

        LoadString(MyDllModuleHandle, IDS_EDITRES_CONFLICTWARNMSG, szMessage, MAX_MSG_LEN);
        LoadString(MyDllModuleHandle, IDS_EDITRES_CONFLICTWARNTITLE, szTitle, MAX_PATH);

        if (MessageBox(hDlg, szMessage, szTitle,
                MB_YESNO | MB_DEFBUTTON2| MB_TASKMODAL | MB_ICONEXCLAMATION) == IDNO) {
            bRet = FALSE;
        } else {
            bRet = TRUE;                // User approved conflict
        }
    }

    return bRet;

} // bConflictWarn



void
ClearEditResConflictList(
    HWND    hDlg,
    DWORD   dwFlags
    )
{
    HWND    hwndConflictList = GetDlgItem(hDlg, IDC_EDITRES_CONFLICTLIST);
    TCHAR   szBuffer[MAX_PATH];

    //
    // Clear the Conflict list to start.
    //
    SendMessage(hwndConflictList, LB_RESETCONTENT, 0, 0L);

    //
    // Load and set the info text string
    //
    if (dwFlags & CEF_UNKNOWN) {
        LoadString(MyDllModuleHandle, IDS_EDITRES_UNKNOWNCONFLICT, szBuffer, MAX_PATH);
    } else {
        LoadString(MyDllModuleHandle, IDS_EDITRES_NOCONFLICT, szBuffer, MAX_PATH);
    }
    SetDlgItemText(hDlg, IDC_EDITRES_CONFLICTTEXT, szBuffer);

    //
    // Load and set the List string
    //
    if (dwFlags & CEF_UNKNOWN) {
        LoadString(MyDllModuleHandle, IDS_EDITRES_UNKNOWNCONFLICTINGDEVS, szBuffer, MAX_PATH);
    } else {
        LoadString(MyDllModuleHandle, IDS_EDITRES_NOCONFLICTINGDEVS, szBuffer, MAX_PATH);
    }
    SendMessage(hwndConflictList, LB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer);

} // ClearEditResConflictList





void
UpdateMFChildList(
    HWND                hDlg,
    PRESOURCEEDITINFO   lprei
    )
{
    UNREFERENCED_PARAMETER(hDlg);
    UNREFERENCED_PARAMETER(lprei);

    //
    // See if this is a MF parent device.  Check for a Child0000 subkey
    //
    // NOT IMPLEMENTED, SEE WINDOWS 95 SOURCES.
    //

} // UpdateMFChildList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\diskspac.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    diskspac.c

Abstract:

    APIs and supporting routines for disk space requirement
    calculation.

Author:

    Ted Miller (tedm) 26-Jul-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// An HDSKSPC actually points to one of these.
//
typedef struct _DISK_SPACE_LIST {

    MYLOCK Lock;

    PVOID DrivesTable;

    UINT Flags;

} DISK_SPACE_LIST, *PDISK_SPACE_LIST;

#define LockIt(h)   BeginSynchronizedAccess(&h->Lock)
#define UnlockIt(h) EndSynchronizedAccess(&h->Lock)

__inline
LONGLONG
_AdjustSpace(
    IN LONGLONG sz,
    IN LONGLONG block
    )
{
    //
    // 4097,512 should return 4097+(512-1) = 4608
    // -4097,512 should return -(4097+(512-1)) = -4608
    //
    LONGLONG sign = (sz<0?-1:1);
    LONGLONG rem = (sz*sign)%block;

    return sz + (rem ? sign*(block-rem) : 0);
}

//
// These structures are stored as data associated with
// paths/filenames in the string table.
//

typedef struct _XFILE {
    //
    // -1 means it doesn't currently exist
    //
    LONGLONG CurrentSize;

    //
    // -1 means it will be deleted.
    //
    LONGLONG NewSize;

} XFILE, *PXFILE;


typedef struct _XDIRECTORY {
    //
    // Value indicating how many bytes will be required
    // to hold all the files in the FilesTable after they
    // are put on a file queue and then the queue is committed.
    //
    // This may be a negative number indicating that space will
    // actually be freed!
    //
    LONGLONG SpaceRequired;

    PVOID FilesTable;

} XDIRECTORY, *PXDIRECTORY;


typedef struct _XDRIVE {
    //
    // Value indicating how many bytes will be required
    // to hold all the files in the space list for this drive.
    //
    // This may be a negative number indicating that space will
    // actually be freed!
    //
    LONGLONG SpaceRequired;

    PVOID DirsTable;

    DWORD BytesPerCluster;

    //
    // This is the amount to skew SpaceRequired, based on
    // SetupAdjustDiskSpaceList(). We track this separately
    // for flexibility.
    //
    LONGLONG Slop;

} XDRIVE, *PXDRIVE;


typedef struct _RETURN_BUFFER_INFO {
    PVOID ReturnBuffer;
    DWORD ReturnBufferSize;
    DWORD RequiredSize;
#ifdef UNICODE
    BOOL IsUnicode;
#endif
} RETURN_BUFFER_INFO, *PRETURN_BUFFER_INFO;


BOOL
pSetupQueryDrivesInDiskSpaceList(
    IN  HDSKSPC DiskSpace,
    OUT PVOID   ReturnBuffer,       OPTIONAL
    IN  DWORD   ReturnBufferSize,
    OUT PDWORD  RequiredSize        OPTIONAL
#ifdef UNICODE
    IN ,BOOL    IsUnicode
#endif
    );

BOOL
pAddOrRemoveFileFromSectionToDiskSpaceList(
    IN OUT PDISK_SPACE_LIST        DiskSpaceList,
    IN     HINF                    LayoutInf,
    IN     PINFCONTEXT             LineInSection,   OPTIONAL
    IN     PCTSTR                  FileName,        OPTIONAL
    IN     PCTSTR                  TargetDirectory,
    IN     UINT                    Operation,
    IN     BOOL                    Add,
    IN     PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo  OPTIONAL
    );

BOOL
_SetupAddSectionToDiskSpaceList(
    IN HDSKSPC                 DiskSpace,
    IN HINF                    InfHandle,
    IN HINF                    ListInfHandle,  OPTIONAL
    IN PCTSTR                  SectionName,
    IN UINT                    Operation,
    IN PVOID                   Reserved1,
    IN UINT                    Reserved2,
    IN PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo OPTIONAL
    );

BOOL
_SetupRemoveSectionFromDiskSpaceList(
    IN HDSKSPC                 DiskSpace,
    IN HINF                    InfHandle,
    IN HINF                    ListInfHandle,  OPTIONAL
    IN PCTSTR                  SectionName,
    IN UINT                    Operation,
    IN PVOID                   Reserved1,
    IN UINT                    Reserved2,
    IN PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo OPTIONAL
    );

BOOL
pAddOrRemoveInstallSection(
    IN HDSKSPC                 DiskSpace,
    IN HINF                    InfHandle,
    IN HINF                    LayoutInfHandle, OPTIONAL
    IN PCTSTR                  SectionName,
    IN BOOL                    Add,
    IN PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo  OPTIONAL
    );

BOOL
pSetupAddToDiskSpaceList(
    IN  PDISK_SPACE_LIST DiskSpaceList,
    IN  PCTSTR           TargetFilespec,
    IN  LONGLONG         FileSize,
    IN  UINT             Operation
    );

BOOL
pSetupRemoveFromDiskSpaceList(
    IN  PDISK_SPACE_LIST DiskSpaceList,
    IN  PCTSTR           TargetFilespec,
    IN  UINT             Operation
    );

VOID
pRecalcSpace(
    IN OUT PDISK_SPACE_LIST DiskSpaceList,
    IN     LONG             DriveStringId
    );

BOOL
pStringTableCBEnumDrives(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    );

BOOL
pStringTableCBDelDrives(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    );

BOOL
pStringTableCBDelDirs(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    );

BOOL
pStringTableCBZeroDirsTableMember(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    );

BOOL
pStringTableCBDupMemberStringTable(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    );

DWORD
pParsePath(
    IN  PCTSTR    PathSpec,
    OUT PTSTR     Buffer,
    OUT PTSTR    *DirectoryPart,
    OUT PTSTR    *FilePart,
    OUT LONGLONG *FileSize,
    IN  UINT      Flags
    );




HDSKSPC
SetupCreateDiskSpaceList(
    IN PVOID Reserved1,
    IN DWORD Reserved2,
    IN UINT  Flags
    )

/*++

Routine Description:

    This routine creates a disk space list, which can be used to
    determine required disk space for a set of file operations
    that parallel those that an application will perform later,
    such as via the file queue APIs.

Arguments:

    Reserved1 - Unused, must be 0.

    Reserved2 - Unused, must be 0.

    Flags - Specifies flags that govern operation of the disk space list.

        SPDSL_IGNORE_DISK: If this flag is set, then delete operations
            will be ignored, and copy operations will behave as if
            the target files are not present on the disk, regardless of
            whether the files are actually present. This flag is useful
            to determine an approximate size that can be associated with
            a set of files.
        SPDSL_DISALLOW_NEGATIVE_ADJUST:

Return Value:

    Handle to disk space list to be used in subsequent operations,
    or NULL if the routine fails, in which case GetLastError()
    returns extended error info.

--*/

{
    PDISK_SPACE_LIST SpaceList;
    DWORD d;

    //
    // Validate args.
    //
    if(Reserved1 || Reserved2) {
        d = ERROR_INVALID_PARAMETER;
        goto c1;
    }
    //
    // validate what flags are allowed
    //
    if (Flags & ~(SPDSL_IGNORE_DISK|SPDSL_DISALLOW_NEGATIVE_ADJUST)) {
        d = ERROR_INVALID_PARAMETER;
        goto c1;
    }

    //
    // Allocate space for a structure.
    //
    SpaceList = MyMalloc(sizeof(DISK_SPACE_LIST));
    if(!SpaceList) {
        d = ERROR_NOT_ENOUGH_MEMORY;
        goto c1;
    }

    ZeroMemory(SpaceList,sizeof(DISK_SPACE_LIST));

    SpaceList->Flags = Flags;

    //
    // Create a string table for the drives.
    //
    SpaceList->DrivesTable = pStringTableInitialize(sizeof(XDRIVE));
    if(!SpaceList->DrivesTable) {
        d = ERROR_NOT_ENOUGH_MEMORY;
        goto c2;
    }

    //
    // Create a locking structure for this guy.
    //
    if(!InitializeSynchronizedAccess(&SpaceList->Lock)) {
        d = ERROR_NOT_ENOUGH_MEMORY;
        goto c3;
    }

    //
    // Success.
    //
    return(SpaceList);

c3:
    pStringTableDestroy(SpaceList->DrivesTable);
c2:
    if(SpaceList) {
        MyFree(SpaceList);
    }
c1:
    SetLastError(d);
    return(NULL);
}


#ifdef UNICODE
//
// Ansi version.
//
HDSKSPC
SetupCreateDiskSpaceListA(
    IN PVOID Reserved1,
    IN DWORD Reserved2,
    IN UINT  Flags
    )
{
    //
    // Nothing actually ansi/unicode specific now
    //
    return(SetupCreateDiskSpaceListW(Reserved1,Reserved2,Flags));
}
#else
//
// Unicode stub.
//
HDSKSPC
SetupCreateDiskSpaceListW(
    IN PVOID Reserved1,
    IN DWORD Reserved2,
    IN UINT  Flags
    )
{
    UNREFERENCED_PARAMETER(Reserved1);
    UNREFERENCED_PARAMETER(Reserved2);
    UNREFERENCED_PARAMETER(Flags);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(NULL);
}
#endif


HDSKSPC
SetupDuplicateDiskSpaceList(
    IN HDSKSPC DiskSpace,
    IN PVOID   Reserved1,
    IN DWORD   Reserved2,
    IN UINT    Flags
    )

/*++

Routine Description:

    This routine duplicates a disk space, creating a new, fully independent
    disk space list.

Arguments:

    DiskSpace - supplies handle of disk space list to be duplicated.

    Reserved1 - reserved, must be 0.

    Reserved2 - reserved, must be 0.

    Flags - reserved, must be 0.

Return Value:

    If successful, returns a handle to a new disk space list.
    NULL if failure; GetLastError() returns extended error info.

--*/

{
    PDISK_SPACE_LIST OldSpaceList;
    PDISK_SPACE_LIST NewSpaceList = NULL; // shut up preFast
    DWORD d;
    BOOL b;
    XDRIVE xDrive;

    //
    // Validate args.
    //
    if(Reserved1 || Reserved2 || Flags) {
        d = ERROR_INVALID_PARAMETER;
        goto c0;
    }

    //
    // Allocate space for a new structure and create a locking structure.
    //
    NewSpaceList = MyMalloc(sizeof(DISK_SPACE_LIST));
    if(!NewSpaceList) {
        d = ERROR_NOT_ENOUGH_MEMORY;
        goto c0;
    }
    ZeroMemory(NewSpaceList,sizeof(DISK_SPACE_LIST));

    if(!InitializeSynchronizedAccess(&NewSpaceList->Lock)) {
        d = ERROR_NOT_ENOUGH_MEMORY;
        goto c1;
    }

    //
    // Lock down the existing space list.
    //
    OldSpaceList = DiskSpace;
    d = NO_ERROR;
    try {
        if(!LockIt(OldSpaceList)) {
            d = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_HANDLE;
    }

    if(d != NO_ERROR) {
        goto c2;
    }

    //
    // Duplicate the top-level string table. After we do this, we'll have
    // a string table whose items' extra data is XDRIVE structures,
    // which will each contain a string table handle for a string table for
    // directories. But we don't want to share that string table between
    // the old and new disk space tables. So start by zeroing the DirsTable
    // members of all the XDRIVE structures. This will let us clean up
    // more easily later in the error path.
    //
    MYASSERT(OldSpaceList->DrivesTable);
    NewSpaceList->DrivesTable = pStringTableDuplicate(OldSpaceList->DrivesTable);
    if(!NewSpaceList->DrivesTable) {
        d = ERROR_NOT_ENOUGH_MEMORY;
        goto c3;
    }

    pStringTableEnum(
        NewSpaceList->DrivesTable,
        &xDrive,
        sizeof(XDRIVE),
        pStringTableCBZeroDirsTableMember,
        0
        );

    //
    // Now we enumerate the old drives table and duplicate each directory
    // string table into the new drives table. We take heavy advantage
    // of the fact that the ids are the same between the old and new tables.
    //
    b = pStringTableEnum(
            OldSpaceList->DrivesTable,
            &xDrive,
            sizeof(XDRIVE),
            pStringTableCBDupMemberStringTable,
            (LPARAM)NewSpaceList->DrivesTable
            );

    if(!b) {
        d = ERROR_NOT_ENOUGH_MEMORY;
    }

    if(d != NO_ERROR) {
        pStringTableEnum(
            NewSpaceList->DrivesTable,
            &xDrive,
            sizeof(XDRIVE),
            pStringTableCBDelDrives,
            0
            );
        pStringTableDestroy(NewSpaceList->DrivesTable);
    }
c3:
    //
    // Unlock the existing space list.
    //
    try {
        UnlockIt(OldSpaceList);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Don't worry if the pointer went bad, we're already done
        // with the important work.
        //
        ;
    }
c2:
    if(d != NO_ERROR) {
        DestroySynchronizedAccess(&NewSpaceList->Lock);
    }
c1:
    if(d != NO_ERROR) {
        MyFree(NewSpaceList);
    }
c0:
    SetLastError(d);
    return((d == NO_ERROR) ? NewSpaceList : NULL);
}

#ifdef UNICODE
//
// Ansi version.
//
HDSKSPC
SetupDuplicateDiskSpaceListA(
    IN HDSKSPC DiskSpace,
    IN PVOID   Reserved1,
    IN DWORD   Reserved2,
    IN UINT    Flags
    )
{
    //
    // Nothing actually ansi/unicode specific now
    //
    return(SetupDuplicateDiskSpaceListW(DiskSpace,Reserved1,Reserved2,Flags));
}
#else
//
// Unicode stub.
//
HDSKSPC
SetupDuplicateDiskSpaceListW(
    IN HDSKSPC DiskSpace,
    IN PVOID   Reserved1,
    IN DWORD   Reserved2,
    IN UINT    Flags
    )
{
    UNREFERENCED_PARAMETER(DiskSpace);
    UNREFERENCED_PARAMETER(Reserved1);
    UNREFERENCED_PARAMETER(Reserved2);
    UNREFERENCED_PARAMETER(Flags);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(NULL);
}
#endif


BOOL
SetupDestroyDiskSpaceList(
    IN OUT HDSKSPC DiskSpace
    )

/*++

Routine Description:

    This routine destryos a disk space list which was created
    with SetupCreateDiskSpaceList() and releases all resources
    used thereby.

Arguments:

    DiskSpace - supplies handle to space list to be deconstructed.

Return Value:

    Boolean value indicating outcome. If FALSE, extended error info
    is available from GetLastError().

--*/

{
    PDISK_SPACE_LIST DiskSpaceList;
    DWORD rc;
    XDRIVE xDrive;

    DiskSpaceList = DiskSpace;
    rc = NO_ERROR;

    try {
        if(!LockIt(DiskSpaceList)) {
            rc = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_HANDLE;
    }

    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    try {
        DestroySynchronizedAccess(&DiskSpaceList->Lock);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Just swallow this.
        //
        ;
    }

    try {

        MYASSERT(DiskSpaceList->DrivesTable);
        //
        // Enumerate the drives string table. This in turn causes
        // all directory and file string tables to get destroyed.
        //
        pStringTableEnum(
            DiskSpaceList->DrivesTable,
            &xDrive,
            sizeof(XDRIVE),
            pStringTableCBDelDrives,
            0
            );

        pStringTableDestroy(DiskSpaceList->DrivesTable);

        //
        // Free the disk space list guy.
        //
        MyFree(DiskSpaceList);

    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_HANDLE;
    }

    SetLastError(rc);
    return(rc == NO_ERROR);
}


BOOL
SetupAdjustDiskSpaceList(
    IN HDSKSPC  DiskSpace,
    IN LPCTSTR  DriveRoot,
    IN LONGLONG Amount,
    IN PVOID    Reserved1,
    IN UINT     Reserved2
    )

/*++

Routine Description:

    This routine is used to add an absolute amount of required disk space
    for a drive.

Arguments:

    DiskSpace - supplies a handle to a disk space list.

    DriveRoot - specifies a valid Win32 drive root. If this drive is not
        currently represented in the disk space list then an entry for it
        is added.

    Amount - supplies the amount of disk space by which to adjust space
        required on the drive. Use a negative number to remove space.

    Reserved1 - must be 0.

    Reserved2 - must be 0.

Return Value:

--*/

{
    DWORD rc;
    BOOL b;

    if(Reserved1 || Reserved2) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    rc = NO_ERROR;

    try {
        if(!LockIt(((PDISK_SPACE_LIST)DiskSpace))) {
            rc = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_HANDLE;
    }

    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    //
    // pSetupAddToDiskSpaceList does all the work. That routine
    // uses SEH so no need for try/excepts here.
    //
    b = pSetupAddToDiskSpaceList(DiskSpace,DriveRoot,Amount,(UINT)(-1));
    rc = GetLastError();

    //
    // The try/except around the unlock simply prevents us from faulting
    // but we don't return error if the pointer goes bad.
    //
    try {
        UnlockIt(((PDISK_SPACE_LIST)DiskSpace));
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }

    SetLastError(rc);
    return(b);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupAdjustDiskSpaceListA(
    IN HDSKSPC  DiskSpace,
    IN LPCSTR   DriveRoot,
    IN LONGLONG Amount,
    IN PVOID    Reserved1,
    IN UINT     Reserved2
    )
{
    LPCWSTR p;
    BOOL b;
    DWORD rc;

    rc = pSetupCaptureAndConvertAnsiArg(DriveRoot,&p);
    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    b = SetupAdjustDiskSpaceListW(DiskSpace,p,Amount,Reserved1,Reserved2);
    rc = GetLastError();

    MyFree(p);

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupAdjustDiskSpaceListW(
    IN HDSKSPC  DiskSpace,
    IN LPCWSTR  DriveRoot,
    IN LONGLONG Amount,
    IN PVOID    Reserved1,
    IN UINT     Reserved2
    )
{
    UNREFERENCED_PARAMETER(DiskSpace);
    UNREFERENCED_PARAMETER(DriveRoot);
    UNREFERENCED_PARAMETER(Amount);
    UNREFERENCED_PARAMETER(Reserved1);
    UNREFERENCED_PARAMETER(Reserved2);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif


BOOL
SetupAddToDiskSpaceList(
    IN HDSKSPC  DiskSpace,
    IN PCTSTR   TargetFilespec,
    IN LONGLONG FileSize,
    IN UINT     Operation,
    IN PVOID    Reserved1,
    IN UINT     Reserved2
    )

/*++

Routine Description:

    This routine adds a single delete or copy operation to a
    disk space list.

    Note that disk compression is completely ignored by this routine.
    Files are assumed to occupy their full size on the disk.

Arguments:

    DiskSpace - specifies handle to disk space list created by
        SetupCreateDiskSpaceList().

    TargetFilespec - specifies filename of the file to add
        to the disk space list. This will generally be a full win32
        path, though this is not a requirement. If it is not then
        standard win32 path semantics apply.

    FileSize - supplies the (uncompressed) size of the file as it will
        exist on the target when copied. Ignored for FILEOP_DELETE.

    Operation - one of FILEOP_DELETE or FILEOP_COPY.

    Reserved1 - must be 0.

    Reserved2 - must be 0.

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information.

--*/

{
    DWORD rc;
    BOOL b;

    if(Reserved1 || Reserved2) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    rc = NO_ERROR;

    try {
        if(!LockIt(((PDISK_SPACE_LIST)DiskSpace))) {
            rc = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_HANDLE;
    }

    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    b = pSetupAddToDiskSpaceList(DiskSpace,TargetFilespec,FileSize,Operation);
    rc = GetLastError();

    //
    // The try/except around the unlock simply prevents us from faulting
    // but we don't return error if the pointer goes bad.
    //
    try {
        UnlockIt(((PDISK_SPACE_LIST)DiskSpace));
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }

    SetLastError(rc);
    return(b);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupAddToDiskSpaceListA(
    IN HDSKSPC  DiskSpace,
    IN PCSTR    TargetFilespec,
    IN LONGLONG FileSize,
    IN UINT     Operation,
    IN PVOID    Reserved1,
    IN UINT     Reserved2
    )
{
    PWSTR targetFilespec;
    DWORD rc;
    BOOL b;

    rc = pSetupCaptureAndConvertAnsiArg(TargetFilespec,&targetFilespec);
    if(rc != NO_ERROR) {
        return(rc);
    }

    b = SetupAddToDiskSpaceListW(DiskSpace,targetFilespec,FileSize,Operation,Reserved1,Reserved2);
    rc = GetLastError();

    MyFree(targetFilespec);

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupAddToDiskSpaceListW(
    IN HDSKSPC  DiskSpace,
    IN PCWSTR   TargetFilespec,
    IN LONGLONG FileSize,
    IN UINT     Operation,
    IN PVOID    Reserved1,
    IN UINT     Reserved2
    )
{
    UNREFERENCED_PARAMETER(DiskSpace);
    UNREFERENCED_PARAMETER(TargetFilespec);
    UNREFERENCED_PARAMETER(FileSize);
    UNREFERENCED_PARAMETER(Operation);
    UNREFERENCED_PARAMETER(Reserved1);
    UNREFERENCED_PARAMETER(Reserved2);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif


BOOL
_SetupAddSectionToDiskSpaceList(
    IN HDSKSPC                 DiskSpace,
    IN HINF                    InfHandle,
    IN HINF                    ListInfHandle,  OPTIONAL
    IN PCTSTR                  SectionName,
    IN UINT                    Operation,
    IN PVOID                   Reserved1,
    IN UINT                    Reserved2,
    IN PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo OPTIONAL
    )

/*++

Routine Description:

    This routine adds a delete or copy section to a disk space list.

    Note that disk compression is completely ignored by this routine.
    Files are assumed to occupy their full size on the disk.

Arguments:

    DiskSpace - specifies handle to disk space list created by
        SetupCreateDiskSpaceList().

    InfHandle - supplies a handle to an open inf file, that contains the
        [SourceDisksFiles] section, and, if ListInfHandle is not specified,
        contains the section named by SectionName. This handle must be for
        a win95-style inf.

    ListInfHandle - if specified, supplies a handle to an open inf file
        containing the section to be added to the disk space list.
        Otherwise InfHandle is assumed to contain the section.

    SectionName - supplies the name of the section to be added to
        the disk space list.

    Operation - one of FILEOP_DELETE or FILEOP_COPY.

    Reserved1 - must be 0.

    Reserved2 - must be 0.

    AltPlatformInfo - optionally, supplies alternate platform info to be used
        in determining the appropriately-decorated [SourceDisksFiles] section
        containing file size information.

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information.

--*/

{
    PDISK_SPACE_LIST DiskSpaceList;
    LONG LineCount;
    PCTSTR TargetFilename;
    BOOL b;
    INFCONTEXT LineContext;
    TCHAR FullTargetPath[MAX_PATH];
    DWORD FileSize;
    DWORD rc;

    //
    // Note throughout this routine that very little structured exception handling
    // is needed, since most of the work is performed by subroutines that are
    // properly guarded.
    //

    if(Reserved1 || Reserved2) {
        rc = ERROR_INVALID_PARAMETER;
        b = FALSE;
        goto c0;
    }

    //
    // Lock down the DiskSpace handle/structure.
    //
    DiskSpaceList = DiskSpace;
    rc = NO_ERROR;

    try {
        if(!LockIt(DiskSpaceList)) {
            rc = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_HANDLE;
    }

    if(rc != NO_ERROR) {
        b = FALSE;
        goto c0;
    }

    if(!ListInfHandle) {
        ListInfHandle = InfHandle;
    }

    //
    // The section must at least exist; an empty section is
    // a trivial success case.
    //
    LineCount = SetupGetLineCount(ListInfHandle,SectionName);
    if(LineCount == -1) {
        rc = ERROR_SECTION_NOT_FOUND;
        b = FALSE;
        goto c1;
    }
    if(!LineCount) {
        b = TRUE;
        goto c1;
    }

    //
    // Find the first line. We know there is at least one since the line count
    // was checked above. Sanity check it anyway.
    //
    b = SetupFindFirstLine(ListInfHandle,SectionName,NULL,&LineContext);
    MYASSERT(b);
    if(!b) {
        rc = ERROR_SECTION_NOT_FOUND;
        goto c1;
    }

    //
    // Find the target path for this section.
    //
    if(!SetupGetTargetPath(NULL,&LineContext,NULL,FullTargetPath,MAX_PATH,NULL)) {
        rc = GetLastError();
        goto c1;
    }

    //
    // Process each line in the section.
    //
    do {

        b = pAddOrRemoveFileFromSectionToDiskSpaceList(
                DiskSpaceList,
                InfHandle,
                &LineContext,
                NULL,
                FullTargetPath,
                Operation,
                TRUE,
                AltPlatformInfo
                );

        if(!b) {
            rc = GetLastError();
        }

    } while(b && SetupFindNextLine(&LineContext,&LineContext));

c1:
    try {
        UnlockIt(DiskSpaceList);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }
c0:
    SetLastError(rc);
    return(b);
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupAddSectionToDiskSpaceListA(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    ListInfHandle,  OPTIONAL
    IN PCSTR   SectionName,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    )
{
    PWSTR sectionName;
    BOOL b;
    DWORD rc;

    rc = pSetupCaptureAndConvertAnsiArg(SectionName,&sectionName);
    if(rc == NO_ERROR) {

        b = _SetupAddSectionToDiskSpaceList(
                DiskSpace,
                InfHandle,
                ListInfHandle,
                sectionName,
                Operation,
                Reserved1,
                Reserved2,
                NULL
               );

        rc = GetLastError();

        MyFree(sectionName);
    } else {
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupAddSectionToDiskSpaceListW(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    ListInfHandle,  OPTIONAL
    IN PCWSTR  SectionName,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    )
{
    UNREFERENCED_PARAMETER(DiskSpace);
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(ListInfHandle);
    UNREFERENCED_PARAMETER(SectionName);
    UNREFERENCED_PARAMETER(Operation);
    UNREFERENCED_PARAMETER(Reserved1);
    UNREFERENCED_PARAMETER(Reserved2);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupAddSectionToDiskSpaceList(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    ListInfHandle,  OPTIONAL
    IN PCTSTR  SectionName,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    )
{
    return _SetupAddSectionToDiskSpaceList(DiskSpace,
                                           InfHandle,
                                           ListInfHandle,
                                           SectionName,
                                           Operation,
                                           Reserved1,
                                           Reserved2,
                                           NULL
                                          );
}


BOOL
SetupAddInstallSectionToDiskSpaceList(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    LayoutInfHandle,     OPTIONAL
    IN PCTSTR  SectionName,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    )

/*++

Routine Description:

    Processes an install section, looking for CopyFiles and DelFiles
    lines, and adds those sections to a disk space list.

Arguments:

Return Value:

    Win32 error code indicating outcome.

--*/

{
    if(Reserved1 || Reserved2) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    return(pAddOrRemoveInstallSection(DiskSpace,
                                      InfHandle,
                                      LayoutInfHandle,
                                      SectionName,
                                      TRUE,
                                      NULL
                                     ));
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupAddInstallSectionToDiskSpaceListA(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    LayoutInfHandle,     OPTIONAL
    IN PCSTR   SectionName,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    )
{
    PWSTR sectionName;
    DWORD rc;
    BOOL b;

    rc = pSetupCaptureAndConvertAnsiArg(SectionName,&sectionName);
    if(rc == NO_ERROR) {

        b = SetupAddInstallSectionToDiskSpaceListW(
                DiskSpace,
                InfHandle,
                LayoutInfHandle,
                sectionName,
                Reserved1,
                Reserved2
                );

        rc = GetLastError();

        MyFree(sectionName);
    } else {
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupAddInstallSectionToDiskSpaceListW(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    LayoutInfHandle,     OPTIONAL
    IN PCWSTR  SectionName,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    )
{
    UNREFERENCED_PARAMETER(DiskSpace);
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(LayoutInfHandle);
    UNREFERENCED_PARAMETER(SectionName);
    UNREFERENCED_PARAMETER(Reserved1);
    UNREFERENCED_PARAMETER(Reserved2);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif


BOOL
SetupRemoveFromDiskSpaceList(
    IN HDSKSPC DiskSpace,
    IN PCTSTR  TargetFilespec,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    )

/*++

Routine Description:

    This routine removes a single delete or copy operation from a
    disk space list.

Arguments:

    DiskSpace - specifies handle to disk space list created by
        SetupCreateDiskSpaceList().

    TargetFilespec - specifies filename of the file to remove from
        the disk space list. This will generally be a full win32
        path, though this is not a requirement. If it is not then
        standard win32 path semantics apply.

    Operation - one of FILEOP_DELETE or FILEOP_COPY.

    Reserved1 - must be 0.

    Reserved2 - must be 0.

Return Value:

    If the file was not in the list, the routine returns TRUE and
    GetLastError() returns ERROR_INVALID_DRIVE or ERROR_INVALID_NAME.
    If the file was in the list then upon success the routine returns
    TRUE and GetLastError() returns NO_ERROR.

    If the routine fails for some other reason it returns FALSE and GetLastError()
    can be used to fetch extended error info.

--*/

{
    DWORD rc;
    BOOL b;

    if(Reserved1 || Reserved2) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    rc = NO_ERROR;

    try {
        if(!LockIt(((PDISK_SPACE_LIST)DiskSpace))) {
            rc = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_HANDLE;
    }

    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    b = pSetupRemoveFromDiskSpaceList(DiskSpace,TargetFilespec,Operation);
    rc = GetLastError();

    //
    // The try/except around the unlock simply prevents us from faulting
    // but we don't return error if the pointer goes bad.
    //
    try {
        UnlockIt(((PDISK_SPACE_LIST)DiskSpace));
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }

    SetLastError(rc);
    return(b);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupRemoveFromDiskSpaceListA(
    IN HDSKSPC DiskSpace,
    IN PCSTR   TargetFilespec,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    )
{
    PWSTR targetFilespec;
    DWORD rc;
    BOOL b;

    rc = pSetupCaptureAndConvertAnsiArg(TargetFilespec,&targetFilespec);
    if(rc != NO_ERROR) {
        return(rc);
    }

    b = SetupRemoveFromDiskSpaceListW(DiskSpace,targetFilespec,Operation,Reserved1,Reserved2);
    rc = GetLastError();

    MyFree(targetFilespec);

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupRemoveFromDiskSpaceListW(
    IN HDSKSPC DiskSpace,
    IN PCWSTR  TargetFilespec,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    )
{
    UNREFERENCED_PARAMETER(DiskSpace);
    UNREFERENCED_PARAMETER(TargetFilespec);
    UNREFERENCED_PARAMETER(Operation);
    UNREFERENCED_PARAMETER(Reserved1);
    UNREFERENCED_PARAMETER(Reserved2);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif


BOOL
_SetupRemoveSectionFromDiskSpaceList(
    IN HDSKSPC                 DiskSpace,
    IN HINF                    InfHandle,
    IN HINF                    ListInfHandle,  OPTIONAL
    IN PCTSTR                  SectionName,
    IN UINT                    Operation,
    IN PVOID                   Reserved1,
    IN UINT                    Reserved2,
    IN PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo OPTIONAL
    )

/*++

Routine Description:

    This routine removes a delete or copy section from a disk space list.
    The section is presumed to have been added via SetupAddSectionToDiskSpaceList,
    though this is not a requirement. Files that have not actually been added
    will not be removed.

    Note that disk compression is completely ignored by this routine.
    Files are assumed to occupy their full size on the disk.

Arguments:

    DiskSpace - specifies handle to disk space list created by
        SetupCreateDiskSpaceList().

    InfHandle - supplies a handle to an open inf file, that contains the
        [SourceDisksFiles] section, and, if ListInfHandle is not specified,
        contains the section named by SectionName. This handle must be for
        a win95-style inf.

    ListInfHandle - if specified, supplies a handle to an open inf file
        containing the section to be removed from the disk space list.
        Otherwise InfHandle is assumed to contain the section.

    SectionName - supplies the name of the section to be added to
        the disk space list.

    Operation - one of FILEOP_DELETE or FILEOP_COPY.

    Reserved1 - must be 0.

    Reserved2 - must be 0.

    AltPlatformInfo - optionally, supplies alternate platform info to be used
        in determining the appropriately-decorated [SourceDisksFiles] section
        containing file size information.


Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information.

--*/

{
    PDISK_SPACE_LIST DiskSpaceList;
    LONG LineCount;
    PCTSTR TargetFilename;
    BOOL b;
    INFCONTEXT LineContext;
    TCHAR FullTargetPath[MAX_PATH];
    DWORD rc;

    //
    // Note throughout this routine that very little structured exception handling
    // is needed, since most of the work is performed by subroutines that are
    // properly guarded.
    //

    if(Reserved1 || Reserved2) {
        rc = ERROR_INVALID_PARAMETER;
        b = FALSE;
        goto c0;
    }

    //
    // Lock down the DiskSpace handle/structure.
    //
    DiskSpaceList = DiskSpace;
    rc = NO_ERROR;

    try {
        if(!LockIt(DiskSpaceList)) {
            rc = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_HANDLE;
    }

    if(rc != NO_ERROR) {
        b = FALSE;
        goto c0;
    }

    if(!ListInfHandle) {
        ListInfHandle = InfHandle;
    }

    //
    // The section must at least exist; an empty section is
    // a trivial success case.
    //
    LineCount = SetupGetLineCount(ListInfHandle,SectionName);
    if(LineCount == -1) {
        rc = ERROR_SECTION_NOT_FOUND;
        b = FALSE;
        goto c1;
    }
    if(!LineCount) {
        b = TRUE;
        goto c1;
    }

    //
    // Find the first line. We know there is at least one since the line count
    // was checked above. Sanity check it anyway.
    //
    b = SetupFindFirstLine(ListInfHandle,SectionName,NULL,&LineContext);
    MYASSERT(b);
    if(!b) {
        rc = ERROR_SECTION_NOT_FOUND;
        b = FALSE;
        goto c1;
    }

    //
    // Find the target path for this section.
    //
    if(!SetupGetTargetPath(NULL,&LineContext,NULL,FullTargetPath,MAX_PATH,NULL)) {
        rc = GetLastError();
        b = FALSE;
        goto c1;
    }

    //
    // Process each line in the section.
    //
    do {

        b = pAddOrRemoveFileFromSectionToDiskSpaceList(
                DiskSpaceList,
                InfHandle,
                &LineContext,
                NULL,
                FullTargetPath,
                Operation,
                FALSE,
                AltPlatformInfo
               );

        if(!b) {
            rc = GetLastError();
        }
    } while(b && SetupFindNextLine(&LineContext,&LineContext));

c1:
    try {
        UnlockIt(DiskSpaceList);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }

c0:
    SetLastError(rc);
    return(b);
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupRemoveSectionFromDiskSpaceListA(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    ListInfHandle,  OPTIONAL
    IN PCSTR   SectionName,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    )
{
    PWSTR sectionName;
    BOOL b;
    DWORD rc;

    rc = pSetupCaptureAndConvertAnsiArg(SectionName,&sectionName);
    if(rc == NO_ERROR) {

        b = _SetupRemoveSectionFromDiskSpaceList(
                DiskSpace,
                InfHandle,
                ListInfHandle,
                sectionName,
                Operation,
                Reserved1,
                Reserved2,
                NULL
               );

        rc = GetLastError();

        MyFree(sectionName);
    } else {
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupRemoveSectionFromDiskSpaceListW(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    ListInfHandle,  OPTIONAL
    IN PCWSTR  SectionName,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    )
{
    UNREFERENCED_PARAMETER(DiskSpace);
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(ListInfHandle);
    UNREFERENCED_PARAMETER(SectionName);
    UNREFERENCED_PARAMETER(Operation);
    UNREFERENCED_PARAMETER(Reserved1);
    UNREFERENCED_PARAMETER(Reserved2);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupRemoveSectionFromDiskSpaceList(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    ListInfHandle,  OPTIONAL
    IN PCTSTR  SectionName,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    )
{
    return _SetupRemoveSectionFromDiskSpaceList(DiskSpace,
                                                InfHandle,
                                                ListInfHandle,
                                                SectionName,
                                                Operation,
                                                Reserved1,
                                                Reserved2,
                                                NULL
                                               );
}


BOOL
SetupRemoveInstallSectionFromDiskSpaceList(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    LayoutInfHandle,     OPTIONAL
    IN PCTSTR  SectionName,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    )

/*++

Routine Description:

    Processes an install section, looking for CopyFiles and DelFiles
    lines, and removes those sections from a disk space list.

Arguments:

    DiskSpace - supplies a handle to a disk space list.

    InfHandle - supplies a handle to an open inf file, that contains the
        [SourceDisksFiles] section, and, if ListInfHandle is not specified,
        contains the section named by SectionName. This handle must be for
        a win95-style inf.

    ListInfHandle - if specified, supplies a handle to an open inf file
        containing the section to be removed from the disk space list.
        Otherwise InfHandle is assumed to contain the section.

    SectionName - supplies the name of the section to be added to
        the disk space list.

    Reserved1 - must be 0.

    Reserved2 - must be 0.

Return Value:

    Boolean value indicating outcome. If FALSE, extended error info
    is available via GetLastError().


--*/

{
    if(Reserved1 || Reserved2) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    return(pAddOrRemoveInstallSection(DiskSpace,
                                      InfHandle,
                                      LayoutInfHandle,
                                      SectionName,
                                      FALSE,
                                      NULL
                                     ));
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupRemoveInstallSectionFromDiskSpaceListA(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    LayoutInfHandle,     OPTIONAL
    IN PCSTR   SectionName,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    )
{
    PWSTR sectionName;
    DWORD rc;
    BOOL b;

    rc = pSetupCaptureAndConvertAnsiArg(SectionName,&sectionName);
    if(rc == NO_ERROR) {

        b = SetupRemoveInstallSectionFromDiskSpaceListW(
                DiskSpace,
                InfHandle,
                LayoutInfHandle,
                sectionName,
                Reserved1,
                Reserved2
                );

        rc = GetLastError();

        MyFree(sectionName);
    } else {
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupRemoveInstallSectionFromDiskSpaceListW(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    LayoutInfHandle,     OPTIONAL
    IN PCWSTR  SectionName,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    )
{
    UNREFERENCED_PARAMETER(DiskSpace);
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(LayoutInfHandle);
    UNREFERENCED_PARAMETER(SectionName);
    UNREFERENCED_PARAMETER(Reserved1);
    UNREFERENCED_PARAMETER(Reserved2);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif


BOOL
SetupQuerySpaceRequiredOnDrive(
    IN  HDSKSPC   DiskSpace,
    IN  PCTSTR    DriveSpec,
    OUT LONGLONG *SpaceRequired,
    IN  PVOID     Reserved1,
    IN  UINT      Reserved2
    )

/*++

Routine Description:

    Examine a disk space list to determine the space required on a
    particular drive.

Arguments:

    DiskSpace - supplies a handle to a disk space list.

    DriveSpec - specifies the drive for which space info is desired.
        This should be in the form x: or \\server\share.

    SpaceRequired - if the function succeeds, receives the amount
        of space required. This may be 0 or a negative number!

    Reserved1 - reserved, must be 0.

    Reserved2 - reserved, must be 0.

Return Value:

    Boolean value indicating outcome. If TRUE, SpaceRequired is filled in.

    If FALSE, extended error info is available via GetLastError():

    ERROR_INVALID_HANDLE - the specified DiskSpace handle is invalid.
    ERROR_INVALID_DRIVE - the given drive is not in the disk space list.

--*/

{
    PDISK_SPACE_LIST DiskSpaceList;
    DWORD rc;
    BOOL b;
    LONG l;
    DWORD Hash;
    DWORD StringLength;
    XDRIVE xDrive;
    TCHAR drive[MAX_PATH];

    if(Reserved1 || Reserved2) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // Lock down the DiskSpace handle/structure.
    //
    DiskSpaceList = DiskSpace;
    rc = NO_ERROR;

    try {
        if(!LockIt(DiskSpaceList)) {
            rc = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_HANDLE;
    }

    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    try {
        lstrcpyn(drive,DriveSpec,MAX_PATH);

        MYASSERT(DiskSpaceList->DrivesTable);

        l = pStringTableLookUpString(
                DiskSpaceList->DrivesTable,
                drive,
                &StringLength,
                &Hash,
                NULL,
                STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                NULL,
                0
                );

        if(l != -1) {
            //
            // Found the drive. Recalc space and return it.
            //
            pRecalcSpace(DiskSpaceList,l);
            pStringTableGetExtraData(DiskSpaceList->DrivesTable,l,&xDrive,sizeof(XDRIVE));
            *SpaceRequired = xDrive.SpaceRequired + xDrive.Slop;
            b = TRUE;
        } else {
            rc = ERROR_INVALID_DRIVE;
            b = FALSE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
        b = FALSE;
    }

    try {
        UnlockIt(DiskSpaceList);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }

    SetLastError(rc);
    return(b);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupQuerySpaceRequiredOnDriveA(
    IN  HDSKSPC   DiskSpace,
    IN  PCSTR     DriveSpec,
    OUT LONGLONG *SpaceRequired,
    IN  PVOID     Reserved1,
    IN  UINT      Reserved2
    )
{
    PCWSTR drivespec;
    DWORD rc;
    BOOL b;

    rc = pSetupCaptureAndConvertAnsiArg(DriveSpec,&drivespec);
    if(rc == NO_ERROR) {

        b = SetupQuerySpaceRequiredOnDrive(DiskSpace,drivespec,SpaceRequired,Reserved1,Reserved2);
        rc = GetLastError();

        MyFree(drivespec);
    } else {
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupQuerySpaceRequiredOnDriveW(
    IN  HDSKSPC   DiskSpace,
    IN  PCWSTR    DriveSpec,
    OUT LONGLONG *SpaceRequired,
    IN  PVOID     Reserved1,
    IN  UINT      Reserved2
    )
{
    UNREFERENCED_PARAMETER(DiskSpace);
    UNREFERENCED_PARAMETER(DriveSpec);
    UNREFERENCED_PARAMETER(SpaceRequired);
    UNREFERENCED_PARAMETER(Reserved1);
    UNREFERENCED_PARAMETER(Reserved2);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif


BOOL
SetupQueryDrivesInDiskSpaceListA(
    IN  HDSKSPC DiskSpace,
    OUT PSTR    ReturnBuffer,       OPTIONAL
    IN  DWORD   ReturnBufferSize,
    OUT PDWORD  RequiredSize        OPTIONAL
    )

/*++

Routine Description:

    This routine fills a caller-supplied buffer with drive specs for each
    drive currently represented in the given disk space list.

Arguments:

    DiskSpace - supplies a disk space list handle.

    ReturnBuffer - if supplied, points to a buffer that gets packed with
        the drive specs, followed by a final terminating nul. If not specified
        and not other error occurs, the function succeeds and fills in
        RequiredSize.

    ReturnBufferSize - supplies the size (chars for Unicode, bytes for ANSI)
        of the buffer pointed by ReturnBuffer. Ingored if ReturnBuffer
        is not specified.

    RequiredSize - if specified, receives the size of the buffer required
        to hold the list of drives and terminating nul.

Return Value:

    Boolean value indicating outcome. If the function returns FALSE,
    extended error info is available via GetLastError(). If GetLastError()
    returns ERROR_INSUFFICIENT_BUFFER then ReturnBuffer was specified but
    ReturnBufferSize indicated that the supplied buffer was too small.

--*/

{
    BOOL b;

    b = pSetupQueryDrivesInDiskSpaceList(
            DiskSpace,
            ReturnBuffer,
            ReturnBufferSize,
            RequiredSize
#ifdef UNICODE
           ,FALSE
#endif
            );

    return(b);
}


BOOL
SetupQueryDrivesInDiskSpaceListW(
    IN  HDSKSPC DiskSpace,
    OUT PWSTR   ReturnBuffer,       OPTIONAL
    IN  DWORD   ReturnBufferSize,
    OUT PDWORD  RequiredSize        OPTIONAL
    )

/*++

Routine Description:

    See SetupQueryDrivesInDiskSpaceListA.

Arguments:

    See SetupQueryDrivesInDiskSpaceListA.

Return Value:

    See SetupQueryDrivesInDiskSpaceListA.

--*/

{
    BOOL b;

#ifdef UNICODE
    b = pSetupQueryDrivesInDiskSpaceList(
            DiskSpace,
            ReturnBuffer,
            ReturnBufferSize,
            RequiredSize,
            TRUE
            );
#else
    UNREFERENCED_PARAMETER(DiskSpace);
    UNREFERENCED_PARAMETER(ReturnBuffer);
    UNREFERENCED_PARAMETER(ReturnBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    b = FALSE;
#endif

    return(b);
}


BOOL
pSetupQueryDrivesInDiskSpaceList(
    IN  HDSKSPC DiskSpace,
    OUT PVOID   ReturnBuffer,       OPTIONAL
    IN  DWORD   ReturnBufferSize,
    OUT PDWORD  RequiredSize        OPTIONAL
#ifdef UNICODE
    IN ,BOOL    IsUnicode
#endif
    )

/*++

Routine Description:

    Worker routine for SetupQueryDrivesInDiskSpaceList.

Arguments:

    Same as SetupQueryDrivesInDiskSpaceListA/W.

    IsUnicode - for Unicode DLL, specifies whether buffer args
        are ansi or unicode.

Return Value:

    Same as SetupQueryDrivesInDiskSpaceListA/W.

--*/

{
    PDISK_SPACE_LIST DiskSpaceList;
    DWORD rc;
    BOOL b;
    XDRIVE xDrive;
    RETURN_BUFFER_INFO ReturnBufferInfo;

    //
    // Lock down the DiskSpace handle/structure.
    //
    DiskSpaceList = DiskSpace;
    rc = NO_ERROR;

    try {
        if(!LockIt(DiskSpaceList)) {
            rc = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_HANDLE;
    }

    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    try {
        ReturnBufferInfo.ReturnBuffer = ReturnBuffer;
        ReturnBufferInfo.ReturnBufferSize = ReturnBufferSize;
        ReturnBufferInfo.RequiredSize = 0;
        #ifdef UNICODE
        ReturnBufferInfo.IsUnicode = IsUnicode;
        #endif

        MYASSERT(DiskSpaceList->DrivesTable);

        b = pStringTableEnum(
                DiskSpaceList->DrivesTable,
                &xDrive,
                sizeof(XDRIVE),
                pStringTableCBEnumDrives,
                (LPARAM)&ReturnBufferInfo
                );

        if(b) {
            //
            // Need one more char slot for the extra terminating nul.
            //
            ReturnBufferInfo.RequiredSize++;
            if(RequiredSize) {
                *RequiredSize = ReturnBufferInfo.RequiredSize;
            }

            if(ReturnBuffer) {

                if(ReturnBufferInfo.RequiredSize <= ReturnBufferSize) {

                    #ifdef UNICODE
                    if(!IsUnicode) {
                        ((PSTR)ReturnBuffer)[ReturnBufferInfo.RequiredSize-1] = 0;
                    } else
                    #endif
                    ((PTSTR)ReturnBuffer)[ReturnBufferInfo.RequiredSize-1] = 0;

                } else {
                    rc = ERROR_INSUFFICIENT_BUFFER;
                    b = FALSE;
                }
            }
        } else {
            rc = ERROR_INSUFFICIENT_BUFFER;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
        b = FALSE;
    }

    try {
        UnlockIt(DiskSpaceList);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }

    SetLastError(rc);
    return(b);
}


BOOL
pAddOrRemoveInstallSection(
    IN HDSKSPC                 DiskSpace,
    IN HINF                    InfHandle,
    IN HINF                    LayoutInfHandle, OPTIONAL
    IN PCTSTR                  SectionName,
    IN BOOL                    Add,
    IN PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo  OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    DWORD rc;
    BOOL b;
    unsigned i;
    unsigned numops;
    UINT operation;
    PDISK_SPACE_LIST DiskSpaceList;
    INFCONTEXT LineContext;
    DWORD FieldCount;
    DWORD Field;
    PCTSTR SectionSpec;
    PCTSTR Operations[1] = { TEXT("Copyfiles") };
    INFCONTEXT SectionLineContext;
    TCHAR DefaultTarget[MAX_PATH];

    //
    // Delfiles causes too many issues
    // removed to give a good "worst case" scenario
    // however we intend to add it back along with
    // RenFiles When this issue is revisited, change numops
    // The Operations array and the switch to convert i to operation
    //
    // PCTSTR Operations[2] = { TEXT("Delfiles"),TEXT("Copyfiles") };
    //

    //
    // Lock down the DiskSpace handle/structure.
    //
    DiskSpaceList = DiskSpace;
    rc = NO_ERROR;
    b = TRUE;
    DefaultTarget[0] = 0;

    //
    // only handle Copyfiles at the moment
    //
    numops = 1;

    try {
        if(!LockIt(DiskSpaceList)) {
            rc = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_HANDLE;
    }

    if(rc != NO_ERROR) {
        b = FALSE;
        goto c0;
    }
    if(!LayoutInfHandle) {
        LayoutInfHandle = InfHandle;
    }

    //
    // see if install section exists for diagnostics (this will also check InfHandle)
    // however proceed so that we don't break existing broken code :-(
    //
    if (!SetupFindFirstLine(InfHandle,SectionName,NULL,&LineContext)) {
        DWORD x;
        x = GetLastError();
        pSetupLogSectionError(InfHandle,NULL,NULL,NULL,SectionName,MSG_LOG_NOSECTION_SPACE,x,NULL);
    }

    b = TRUE;
    for(i=0; b && (i < numops); i++) {

        //
        // Find the relevent line in the given install section.
        // If not present then we're done with this operation.
        //
        if(!SetupFindFirstLine(InfHandle,SectionName,Operations[i],&LineContext)) {
            continue;
        }

        switch(i) {
        case 0:
            operation = FILEOP_COPY;
            break;
        default:
            //
            // if we get here, someone changed numops
            // without changing this switch
            //
            MYASSERT(FALSE);
            break;
        }


        do {
            //
            // Each value on the line in the given install section
            // is the name of another section.
            //
            FieldCount = SetupGetFieldCount(&LineContext);
            for(Field=1; b && (Field<=FieldCount); Field++) {

                if(SectionSpec = pSetupGetField(&LineContext,Field)) {

                    //
                    // Handle single-file copy specially.
                    //
                    if((operation == FILEOP_COPY) && (*SectionSpec == TEXT('@'))) {

                        if(!DefaultTarget[0]) {
                            //
                            // Fetch the default target path for this inf, for use with
                            // single-file copy specs.
                            //
                            b = SetupGetTargetPath(
                                    InfHandle,
                                    NULL,
                                    NULL,
                                    DefaultTarget,
                                    MAX_PATH,
                                    NULL
                                    );
                        }

                        if(b) {
                            b = pAddOrRemoveFileFromSectionToDiskSpaceList(
                                    DiskSpace,
                                    LayoutInfHandle,
                                    NULL,
                                    SectionSpec+1,
                                    DefaultTarget,
                                    operation,
                                    Add,
                                    AltPlatformInfo
                                    );
                        }

                        if(!b) {
                            rc = GetLastError();
                        }
                    } else if(SetupGetLineCount(InfHandle,SectionSpec) > 0) {
                        //
                        // The section exists and is not empty.
                        // Add/remove it to the space list.
                        //
                        if(Add) {
                            b = _SetupAddSectionToDiskSpaceList(
                                    DiskSpace,
                                    LayoutInfHandle,
                                    InfHandle,
                                    SectionSpec,
                                    operation,
                                    0,0,
                                    AltPlatformInfo
                                    );
                        } else {
                            b = _SetupRemoveSectionFromDiskSpaceList(
                                    DiskSpace,
                                    LayoutInfHandle,
                                    InfHandle,
                                    SectionSpec,
                                    operation,
                                    0,0,
                                    AltPlatformInfo
                                    );
                        }

                        if(!b) {
                            rc = GetLastError();
                        }
                    }
                }
            }
        } while(b && SetupFindNextMatchLine(&LineContext,Operations[i],&LineContext));
    }

    try {
        UnlockIt(DiskSpaceList);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }
c0:
    SetLastError(rc);
    return(b);
}


BOOL
pAddOrRemoveFileFromSectionToDiskSpaceList(
    IN OUT PDISK_SPACE_LIST        DiskSpaceList,
    IN     HINF                    LayoutInf,
    IN     PINFCONTEXT             LineInSection,   OPTIONAL
    IN     PCTSTR                  FileName,        OPTIONAL
    IN     PCTSTR                  TargetDirectory,
    IN     UINT                    Operation,
    IN     BOOL                    Add,
    IN     PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo  OPTIONAL
    )
{
    PCTSTR TargetFilename;
    TCHAR FullTargetPath[MAX_PATH];
    DWORD FileSize;
    BOOL b;
    DWORD rc;

    //
    // Get the target filename out of the line.
    // Field 1 is the target so there must be one for the line to be valid.
    //
    if(TargetFilename = LineInSection ? pSetupFilenameFromLine(LineInSection,FALSE) : FileName) {

        //
        // Form the full target path by concatenating the target dir
        // for this section and the target filename.
        //
        lstrcpyn(FullTargetPath,TargetDirectory,MAX_PATH);
        pSetupConcatenatePaths(FullTargetPath,TargetFilename,MAX_PATH,NULL);

        if(Add) {
            //
            // Fetch the size of the target file and add the operation
            // to the disk space list.
            //
            if(_SetupGetSourceFileSize(LayoutInf,
                                       LineInSection,
                                       FileName,
                                       NULL,
                                       AltPlatformInfo,
                                       &FileSize,
                                       0)) {

                b = pSetupAddToDiskSpaceList(
                        DiskSpaceList,
                        FullTargetPath,
                        (LONGLONG)(LONG)FileSize,
                        Operation
                        );

                if(!b) {
                    rc = GetLastError();
                }
            } else {
                b = FALSE;
                rc = GetLastError();
            }
        } else {
            //
            // Remove the operation from the disk space list.
            //
            b = pSetupRemoveFromDiskSpaceList(
                    DiskSpaceList,
                    FullTargetPath,
                    Operation
                    );

            if (!b) {
                rc = GetLastError();
            }
        }
    } else {
        b = FALSE;
        rc = ERROR_INVALID_DATA;
    }

    SetLastError(rc);
    return(b);
}


BOOL
pSetupAddToDiskSpaceList(
    IN  PDISK_SPACE_LIST DiskSpaceList,
    IN  PCTSTR           TargetFilespec,
    IN  LONGLONG         FileSize,
    IN  UINT             Operation
    )

/*++

Routine Description:

    Worker routine to add an item to a disk space list.
    Assumes locking is done by the caller.

Arguments:

    DiskSpaceList - specifies pointer to disk space list structure
        created by SetupCreateDiskSpaceList().

    TargetFilespec - specifies filename of the file to add
        to the disk space list. This will generally be a full win32
        path, though this is not a requirement. If it is not then
        standard win32 path semantics apply.

    FileSize - supplies the (uncompressed) size of the file as it will
        exist on the target when copied. Ignored for FILEOP_DELETE.

    Operation - one of FILEOP_DELETE or FILEOP_COPY.

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information.

--*/

{
    TCHAR Buffer[MAX_PATH];
    DWORD rc;
    BOOL b;
    PTSTR DirPart;
    PTSTR FilePart;
    PTSTR drivespec;
    TCHAR drivelet[4];
    LONGLONG ExistingFileSize;
    XDRIVE xDrive;
    XDIRECTORY xDir;
    XFILE xFile;
    DWORD StringLength;
    DWORD Hash;
    LONG l;
    DWORD SectorsPerCluster;
    DWORD BytesPerSector;
    DWORD TotalClusters;
    DWORD FreeClusters;

    if((Operation != FILEOP_DELETE) && (Operation != FILEOP_COPY) && (Operation != (UINT)(-1))) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    rc = NO_ERROR;

    try {
        rc = pParsePath(
                TargetFilespec,
                Buffer,
                &DirPart,
                &FilePart,
                &ExistingFileSize,
                DiskSpaceList->Flags
                );

        if(rc != NO_ERROR) {
            goto c0;
        }

        //
        // If we're not just doing the adjust case, drivespecs are not
        // acceptable.
        //
        if((Operation != (UINT)(-1)) && (*FilePart == 0)) {
            rc = ERROR_INVALID_PARAMETER;
            goto c0;
        }

        //
        // See whether the drive is already present in the drive list.
        //

        MYASSERT(DiskSpaceList->DrivesTable);

        l = pStringTableLookUpString(
                DiskSpaceList->DrivesTable,
                Buffer,
                &StringLength,
                &Hash,
                NULL,
                STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                &xDrive,
                sizeof(XDRIVE)
                );

        if(l == -1) {
            //
            // Determine cluster size for the drive and then add the drive
            // to the drive list and create a string table for the
            // directory list for this drive.
            //
            if(xDrive.DirsTable = pStringTableInitialize(sizeof(XDIRECTORY))) {
                //
                // The API is a little picky about what it is passed.
                // For the local drive case we have to use x:\ but pParsePath
                // sets things up so it's x:.
                //
                if(Buffer[1] == TEXT(':')) {
                    drivelet[0] = Buffer[0];
                    drivelet[1] = Buffer[1];
                    drivelet[2] = TEXT('\\');
                    drivelet[3] = 0;
                    drivespec = drivelet;
                } else {
                    drivespec = Buffer;
                }

                b = GetDiskFreeSpace(
                        drivespec,
                        &SectorsPerCluster,
                        &BytesPerSector,
                        &FreeClusters,
                        &TotalClusters
                        );

                if(!b) {
                    //
                    // This should probably be an error but there could be
                    // cases where people want to queue files say to a UNC path
                    // that isn't accessible now or something. Use reasonable defaults.
                    //
                    SectorsPerCluster = 1;
                    BytesPerSector = 512;
                    FreeClusters = 0;
                    TotalClusters = 0;
                }

                xDrive.SpaceRequired = 0;
                xDrive.Slop = 0;
                xDrive.BytesPerCluster = SectorsPerCluster * BytesPerSector;

                l = pStringTableAddString(
                        DiskSpaceList->DrivesTable,
                        Buffer,
                        STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                        &xDrive,
                        sizeof(XDRIVE)
                        );

                if(l == -1) {
                    pStringTableDestroy(xDrive.DirsTable);
                }
            }
        }

        if(l == -1) {
            //
            // Assume OOM.
            //
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto c0;
        }

        if(Operation == (UINT)(-1)) {
            //
            // Only want to add the drive. Adjust the slop for the drive.
            // rc is already set to NO_ERROR.
            //
            xDrive.Slop += FileSize;
            if((DiskSpaceList->Flags & SPDSL_DISALLOW_NEGATIVE_ADJUST) && (xDrive.Slop < 0)) {
                xDrive.Slop = 0;
            }

            pStringTableSetExtraData(
                DiskSpaceList->DrivesTable,
                l,
                &xDrive,
                sizeof(XDRIVE)
                );

            goto c0;
        }

        //
        // Adjust sizes to account for cluster size.
        //
        FileSize = _AdjustSpace(FileSize,xDrive.BytesPerCluster);
        if(ExistingFileSize != -1) {
            ExistingFileSize = _AdjustSpace(ExistingFileSize,xDrive.BytesPerCluster);
        }

        //
        // OK, xDrive has the drive info relevent for this file.
        // Now handle the directory part. First see whether the directory
        // is already present in the drive list.
        //
        l = pStringTableLookUpString(
                xDrive.DirsTable,
                DirPart,
                &StringLength,
                &Hash,
                NULL,
                STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                &xDir,
                sizeof(XDIRECTORY)
                );

        if(l == -1) {
            //
            // Add the directory to the directory string table.
            //
            if(xDir.FilesTable = pStringTableInitialize(sizeof(XFILE))) {

                xDir.SpaceRequired = 0;

                l = pStringTableAddString(
                        xDrive.DirsTable,
                        DirPart,
                        STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                        &xDir,
                        sizeof(XDIRECTORY)
                        );

                if(l == -1) {
                    pStringTableDestroy(xDir.FilesTable);
                }
            }
        }

        if(l == -1) {
            //
            // Assume OOM.
            //
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto c0;
        }

        //
        // Finally, deal with the file itself.
        // First see if it's in the list already.
        //
        l = pStringTableLookUpString(
                xDir.FilesTable,
                FilePart,
                &StringLength,
                &Hash,
                NULL,
                STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                &xFile,
                sizeof(XFILE)
                );

        if(l == -1) {
            //
            // The file is not already in there so put it in.
            //
            xFile.CurrentSize = ExistingFileSize;
            xFile.NewSize = (Operation == FILEOP_DELETE) ? -1 : FileSize;

            l = pStringTableAddString(
                    xDir.FilesTable,
                    FilePart,
                    STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                    &xFile,
                    sizeof(XFILE)
                    );

            if(l == -1) {
                rc = ERROR_NOT_ENOUGH_MEMORY;
                goto c0;
            }

        } else {

            if((xFile.CurrentSize == -1) && (xFile.NewSize == -1)) {
                //
                // This is a special "no-op" coding.
                //
                // The file is in there, but either the file was previously added
                // for a delete op but it didn't exist on the disk, or it was removed
                // via SetupRemoveFromDiskSpaceList().
                //
                xFile.CurrentSize = ExistingFileSize;
                xFile.NewSize = (Operation == FILEOP_DELETE) ? -1 : FileSize;

            } else {

                //
                // File is already in there. Remembering that deletes are done
                // before copies when a file queue is committed and assuming
                // that operations are put on the disk list in the same order they
                // will eventually be done on the file queue, there are 4 cases:
                //
                // 1) On list as delete, caller wants to delete. Just refresh
                //    the existing file size in case it changed.
                //
                // 2) On list as delete, caller wants to copy. We treat this case
                //    as a copy and override the existing info on the disk space list.
                //
                // 3) On list as copy, caller wants to delete. At commit time the file
                //    will be deleted but then later copied; just refresh the existing
                //    file size, in case it changed.
                //
                // 4) On list as copy, caller wants to copy. Override existing
                //    info in this case.
                //
                // This actually boils down to the following: Always refresh the
                // existing file size, and if the caller wants a copy, then
                // remember the new size.
                //
                xFile.CurrentSize = ExistingFileSize;
                if(Operation == FILEOP_COPY) {

                    xFile.NewSize = FileSize;
                }
            }

            pStringTableSetExtraData(xDir.FilesTable,l,&xFile,sizeof(XFILE));
        }

        c0:

        ;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    SetLastError(rc);
    return(rc == NO_ERROR);
}


BOOL
pSetupRemoveFromDiskSpaceList(
    IN  PDISK_SPACE_LIST DiskSpace,
    IN  PCTSTR           TargetFilespec,
    IN  UINT             Operation
    )

/*++

Routine Description:

    Worker routine to remove a single delete or copy operation from a
    disk space list.

    Assumes locking is handled by the caller.

Arguments:

    DiskSpaceList - specifies pointer to disk space list structure created by
        SetupCreateDiskSpaceList().

    TargetFilespec - specifies filename of the file to remove from
        the disk space list. This will generally be a full win32
        path, though this is not a requirement. If it is not then
        standard win32 path semantics apply.

    Operation - one of FILEOP_DELETE or FILEOP_COPY.

Return Value:

    If the file was not in the list, the routine returns TRUE and
    GetLastError() returns ERROR_INVALID_DRIVE or ERROR_INVALID_NAME.
    If the file was in the list then upon success the routine returns
    TRUE and GetLastError() returns NO_ERROR.

    If the routine fails for some other reason it returns FALSE and GetLastError()
    can be used to fetch extended error info.

--*/

{
    DWORD rc;
    BOOL b;
    TCHAR Buffer[MAX_PATH];
    PTSTR DirPart;
    PTSTR FilePart;
    LONGLONG ExistingFileSize;
    LONG l;
    DWORD StringLength;
    DWORD Hash;
    XDRIVE xDrive;
    XDIRECTORY xDir;
    XFILE xFile;

    if((Operation != FILEOP_DELETE) && (Operation != FILEOP_COPY)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    rc = NO_ERROR;
    b = TRUE;

    try {
        //
        // Split up the path into its constituent components.
        //
        rc = pParsePath(
                TargetFilespec,
                Buffer,
                &DirPart,
                &FilePart,
                &ExistingFileSize,
                DiskSpace->Flags
                );

        if(rc != NO_ERROR) {
            goto c0;
        }

        //
        // Drivespecs alone are not acceptable.
        //
        if(*FilePart == 0) {
            rc = ERROR_INVALID_PARAMETER;
            goto c0;
        }

        //
        // Follow the trail down to the file string table.
        //

        MYASSERT(DiskSpace->DrivesTable);

        l = pStringTableLookUpString(
                DiskSpace->DrivesTable,
                Buffer,
                &StringLength,
                &Hash,
                NULL,
                STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                &xDrive,
                sizeof(XDRIVE)
                );

        if(l == -1) {
            //
            // Return success but set last error to indicate condition.
            //
            rc = ERROR_INVALID_DRIVE;
            goto c0;
        }

        MYASSERT(xDrive.DirsTable);

        l = pStringTableLookUpString(
                xDrive.DirsTable,
                DirPart,
                &StringLength,
                &Hash,
                NULL,
                STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                &xDir,
                sizeof(XDIRECTORY)
                );

        if(l == -1) {
            //
            // Return success but set last error to indicate condition.
            //
            rc = ERROR_INVALID_NAME;
            goto c0;
        }

        MYASSERT(xDir.FilesTable);

        l = pStringTableLookUpString(
                xDir.FilesTable,
                FilePart,
                &StringLength,
                &Hash,
                NULL,
                STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                &xFile,
                sizeof(XFILE)
                );

        if(l == -1) {
            //
            // Return success but set last error to indicate condition.
            //
            rc = ERROR_INVALID_NAME;
            goto c0;
        }

        //
        // Set special 'no-op' code for this file if the operations match.
        //
        if(Operation == FILEOP_DELETE) {
            if(xFile.NewSize == -1) {
                xFile.CurrentSize = -1;
            }
        } else {
            if(xFile.NewSize != -1) {
                xFile.NewSize = -1;
                xFile.CurrentSize = -1;
            }
        }

        pStringTableSetExtraData(xDir.FilesTable,l,&xFile,sizeof(XFILE));

        c0:

        ;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}


BOOL
pStringTableCBEnumDrives(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Internal routine used as the callback when enumerating drives
    in the disk space list. Writes the drivespec into a buffer
    supplies to the enumeration routine.

Arguments:

Return Value:

--*/

{
    PRETURN_BUFFER_INFO p;
    UINT Length;
    BOOL b;
    PCVOID string;

    UNREFERENCED_PARAMETER(StringTable);
    UNREFERENCED_PARAMETER(StringId);
    UNREFERENCED_PARAMETER(ExtraData);
    UNREFERENCED_PARAMETER(ExtraDataSize);

    p = (PRETURN_BUFFER_INFO)lParam;

#ifdef UNICODE
    if(!p->IsUnicode) {
        if(string = pSetupUnicodeToAnsi(String)) {
            Length = lstrlenA(string) + 1;
        } else {
            return(FALSE);
        }
    } else
#endif
    {
        string = String;
        Length = lstrlen(string) + 1;
    }

    p->RequiredSize += Length;

    if(p->ReturnBuffer) {

        if(p->RequiredSize <= p->ReturnBufferSize) {

            //
            // There's still room in the caller's buffer for this drive spec.
            //
#ifdef UNICODE
            if(!p->IsUnicode) {
                lstrcpyA((PSTR)p->ReturnBuffer+p->RequiredSize-Length,string);
            } else
#endif
            lstrcpy((PTSTR)p->ReturnBuffer+p->RequiredSize-Length,string);

            b = TRUE;

        } else {
            //
            // Buffer is too small. Abort the enumeration.
            //
            b = FALSE;
        }
    } else {
        //
        // No buffer: just update the length required.
        //
        b = TRUE;
    }

#ifdef UNICODE
    if(string != String) {
        MyFree(string);
    }
#endif
    return(b);
}


BOOL
pStringTableCBDelDrives(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Internal routine used as the callback when calling pStringTableEnum
    to determine which drives are part of a disk space list.
    Enumerates directories on the drive, and then deletes the drives
    string table.

Arguments:

Return Value:

--*/

{
    PXDRIVE xDrive;
    XDIRECTORY xDir;
    BOOL b;

    UNREFERENCED_PARAMETER(StringTable);
    UNREFERENCED_PARAMETER(StringId);
    UNREFERENCED_PARAMETER(String);
    UNREFERENCED_PARAMETER(ExtraDataSize);
    UNREFERENCED_PARAMETER(lParam);

    //
    // The extra data for the drives table is an XDRIVE structure.
    //
    xDrive = ExtraData;

    //
    // Enumerate the directory table for this drive. This destroys
    // all of *those* string tables.
    //
    if(xDrive->DirsTable) {
        b = pStringTableEnum(
                xDrive->DirsTable,
                &xDir,
                sizeof(XDIRECTORY),
                pStringTableCBDelDirs,
                0
                );

        pStringTableDestroy(xDrive->DirsTable);
    } else {
        b = FALSE;
    }

    return(b);
}


BOOL
pStringTableCBDelDirs(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Internal routine used as the callback when calling pStringTableEnum
    to determine which directories on a given drive are part of a
    disk space list. Basically we just destroy the directory's file string table.

Arguments:

Return Value:

--*/

{
    PXDIRECTORY xDir;

    UNREFERENCED_PARAMETER(StringTable);
    UNREFERENCED_PARAMETER(StringId);
    UNREFERENCED_PARAMETER(String);
    UNREFERENCED_PARAMETER(ExtraDataSize);
    UNREFERENCED_PARAMETER(lParam);

    //
    // The extra data for the dirs table is an XDIRECTORY structure.
    //
    xDir = ExtraData;

    if(xDir->FilesTable) {
        pStringTableDestroy(xDir->FilesTable);
    }

    return(TRUE);
}


DWORD
pParsePath(
    IN  PCTSTR    PathSpec,
    OUT PTSTR     Buffer,
    OUT PTSTR    *DirectoryPart,
    OUT PTSTR    *FilePart,
    OUT LONGLONG *FileSize,
    IN  UINT      Flags
    )

/*++

Routine Description:

    Given a (possibly relative or incomplete) pathspec, determine
    the drive part, the directory part, and the filename parts and
    return pointers thereto.

Arguments:

    PathSpec - supplies the (possible relative) filename.

    Buffer - must be MAX_PATH TCHAR elements. Receives the full win32
        path, which is then carved up into drive, dir, and file parts.
        When the function returns, the first part of Buffer is the
        0-terminated drive spec, not including a terminating \ char.

    DirectoryPart - receives a pointer within Buffer to the first char
        in the full path (which will not be \). The string starting
        with that char will be nul-terminated.

    FilePart - receives a pointer within Buffer to the nul-terminated
        filename part (ie, the final component) of the win32 path
        (no path sep chars are involved in that part of the path).

    FileSize - receives the size of the file if it exists or -1 if not.

    Flags - specifies flags.
        SPDSL_IGNORE_DISK: this forces the routine to behave as if the file
            does not exist on-disk.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    DWORD rc;
    WIN32_FIND_DATA FindData;
    LPTSTR p;

    rc = GetFullPathName(PathSpec,
                         MAX_PATH,
                         Buffer,
                         FilePart
                        );

    if(!rc) {
        return(GetLastError());
    } else if(rc >= MAX_PATH) {
        MYASSERT(0);
        return(ERROR_BUFFER_OVERFLOW);
    }

    //
    // Get the file size, if the file exists.
    //
    if(Flags & SPDSL_IGNORE_DISK) {
        *FileSize = -1;
    } else {
        *FileSize = FileExists(Buffer,&FindData)
                  ? ((LONGLONG)FindData.nFileSizeHigh << 32) | FindData.nFileSizeLow
                  : -1;
    }

    //
    // Figure the drive part. We have no choice but to assume that
    // full paths are either x:\... or \\server\share\... because
    // there isn't any solid way to ask win32 itself what the drive
    // part of the path is.
    //
    // Stick a nul-terminator into the buffer to set off the drive part
    // once we've found it. Note that drive roots are acceptable in
    // the following forms:
    //
    //      x:
    //      x:\
    //      \\server\share
    //      \\server\share\
    //
    if(Buffer[0] && (Buffer[1] == TEXT(':'))) {
        if(Buffer[2] == 0) {
            p = &Buffer[2];
        } else {
            if(Buffer[2] == TEXT('\\')) {
                Buffer[2] = 0;
                p = &Buffer[3];
            } else {
                return(ERROR_INVALID_DRIVE);
            }
        }
    } else {
        if((Buffer[0] == TEXT('\\')) && (Buffer[1] == TEXT('\\')) && Buffer[2]
        && (p = _tcschr(&Buffer[3],TEXT('\\'))) && *(p+1) && (*(p+1) != TEXT('\\'))) {
            //
            // Dir part starts at next \, or it could be a drive root.
            //
            if(p = _tcschr(p+2,TEXT('\\'))) {
                *p++ = 0;
            } else {
                p = _tcschr(p+2,0);
            }
        } else {
            return(ERROR_INVALID_DRIVE);
        }
    }

    //
    // If we have a drive root, we're done. Set the dir and file parts
    // to point at an empty string and return.
    //
    if(*p == 0) {
        *DirectoryPart = p;
        *FilePart = p;
        return(NO_ERROR);
    }

    if(_tcschr(p,TEXT('\\'))) {
        //
        // There are at least 2 path components, so we have
        // a directory and filename. We need to nul-terminate
        // the directory part.
        //
        *DirectoryPart = p;
        *(*FilePart - 1) = 0;
    } else {
        //
        // There's only the one path component, so we have a file
        // at the root of the drive. FilePart is already set from
        // the call to GetFullPathName above. Set DirectoryPart
        // to a nul-terminator to make it an empty string.
        //
        *DirectoryPart = Buffer+lstrlen(Buffer);
    }

    return(NO_ERROR);
}


BOOL
pStringTableCBRecalcFiles(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PXFILE xFile;
    LONGLONG Delta;

    UNREFERENCED_PARAMETER(StringTable);
    UNREFERENCED_PARAMETER(StringId);
    UNREFERENCED_PARAMETER(String);
    UNREFERENCED_PARAMETER(ExtraDataSize);
    UNREFERENCED_PARAMETER(lParam);

    //
    // Extra data points to an XFILE.
    //
    xFile = ExtraData;

    //
    // Calculate the additional space the new file will require
    // or the space that will be freed after the file is copied/deleted.
    //
    if(xFile->NewSize == -1) {
        //
        // File is being deleted. Account for the special 'no-op' coding.
        //
        Delta = (xFile->CurrentSize == -1) ? 0 : (0 - xFile->CurrentSize);

    } else {
        //
        // File is being copied. Account for the fact that the file might not
        // already exist on the disk.
        //
        Delta = (xFile->CurrentSize == -1) ? xFile->NewSize : (xFile->NewSize - xFile->CurrentSize);
    }

    //
    // Update running accumulated total.
    //
    *(LONGLONG *)lParam += Delta;

    return(TRUE);
}


BOOL
pStringTableCBRecalcDirs(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PXDIRECTORY xDir;
    XFILE xFile;

    UNREFERENCED_PARAMETER(StringTable);
    UNREFERENCED_PARAMETER(StringId);
    UNREFERENCED_PARAMETER(String);
    UNREFERENCED_PARAMETER(ExtraDataSize);
    UNREFERENCED_PARAMETER(lParam);

    //
    // Extra data points to an XDIRECTORY.
    //
    xDir = ExtraData;

    xDir->SpaceRequired = 0;

    pStringTableEnum(
        xDir->FilesTable,
        &xFile,
        sizeof(XFILE),
        pStringTableCBRecalcFiles,
        (LPARAM)&xDir->SpaceRequired
        );

    //
    // Update running accumulated total.
    //
    *(LONGLONG *)lParam += xDir->SpaceRequired;

    return(TRUE);
}


BOOL
pStringTableCBZeroDirsTableMember(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    )

/*++

Routine Description:

Arguments:

    Standard string table callback arguments.

Return Value:

--*/

{
    UNREFERENCED_PARAMETER(String);
    UNREFERENCED_PARAMETER(lParam);

    if(lParam) {
        ((PXDIRECTORY)ExtraData)->FilesTable = NULL;
    } else {
        ((PXDRIVE)ExtraData)->DirsTable = NULL;
    }

    MYASSERT(StringTable);

    pStringTableSetExtraData(StringTable,StringId,ExtraData,ExtraDataSize);
    return(TRUE);
}


BOOL
pStringTableCBDupMemberStringTable2(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    )

/*++

Routine Description:

Arguments:

    Standard string table callback arguments.

Return Value:

--*/

{
    PXDIRECTORY xDir;
    BOOL b;

    UNREFERENCED_PARAMETER(StringTable);
    UNREFERENCED_PARAMETER(String);

    //
    // Extra data is the XDIRECTORY structure in the old string table.
    //
    xDir = ExtraData;

    //
    // Duplicate the old FilesTable string table into the new table.
    // We can reuse the xDir buffer.
    //
    xDir->FilesTable = pStringTableDuplicate(xDir->FilesTable);
    if(!xDir->FilesTable) {
        return(FALSE);
    }

    pStringTableSetExtraData((PVOID)lParam,StringId,ExtraData,ExtraDataSize);
    return(TRUE);
}


BOOL
pStringTableCBDupMemberStringTable(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    )

/*++

Routine Description:

Arguments:

    Standard string table callback arguments.

Return Value:

--*/

{
    PXDRIVE xDrive;
    XDIRECTORY xDir;
    BOOL b;
    PVOID OldTable;

    UNREFERENCED_PARAMETER(StringTable);
    UNREFERENCED_PARAMETER(String);

    //
    // Extra data is the XDRIVE structure in the old string table.
    //
    xDrive = ExtraData;

    //
    // Duplicate the old DirsTable string table into the new table.
    // We can reuse the xDrive buffer.
    //
    OldTable = xDrive->DirsTable;
    xDrive->DirsTable = pStringTableDuplicate(xDrive->DirsTable);
    if(!xDrive->DirsTable) {
        return(FALSE);
    }

    pStringTableSetExtraData((PVOID)lParam,StringId,ExtraData,ExtraDataSize);

    //
    // Now zero out the FilesTable members of the XDIRECTORY extra data
    // items in DirsTable string table.
    //
    pStringTableEnum(
        xDrive->DirsTable,
        &xDir,
        sizeof(XDIRECTORY),
        pStringTableCBZeroDirsTableMember,
        1
        );

    //
    // Finally, take advantage of the fact that the ids in the table we just
    // duplicated are the same in the old and new tables, to iterate the
    // old table to duplicate its FilesTable string tables into the new
    // string table. Clean up if failure.
    //
    b = pStringTableEnum(
            OldTable,
            &xDir,
            sizeof(XDIRECTORY),
            pStringTableCBDupMemberStringTable2,
            (LPARAM)xDrive->DirsTable
            );

    if(!b) {
        //
        // Clean up.
        //
        pStringTableEnum(
            xDrive->DirsTable,
            &xDir,
            sizeof(XDIRECTORY),
            pStringTableCBDelDirs,
            0
            );
    }

    return(b);
}


VOID
pRecalcSpace(
    IN OUT PDISK_SPACE_LIST DiskSpaceList,
    IN     LONG             DriveStringId
    )

/*++

Routine Description:

    Recalcuates the disk space required for a given drive by
    traversing all the dirs and files that are on the space list
    for the drive and performing additions/subtractions as necessary.

    Assumes locking is handled by the caller and does not guard args.

Arguments:

    DiskSpaceList - supplies the disk space list structure created
        by SetupCreateDiskSpaceList().

    DriveStringId - supplies the string id for the drive
        (in DiskSpaceList->DrivesTable) for the drive to be updated.

Return Value:

    None.

--*/

{
    XDRIVE xDrive;
    XDIRECTORY xDir;

    if(DriveStringId == -1) {
        return;
    }

    MYASSERT(DiskSpaceList->DrivesTable);

    pStringTableGetExtraData(DiskSpaceList->DrivesTable,DriveStringId,&xDrive,sizeof(XDRIVE));

    xDrive.SpaceRequired = 0;

    pStringTableEnum(
        xDrive.DirsTable,
        &xDir,
        sizeof(XDIRECTORY),
        pStringTableCBRecalcDirs,
        (LPARAM)&xDrive.SpaceRequired
        );

    pStringTableSetExtraData(DiskSpaceList->DrivesTable,DriveStringId,&xDrive,sizeof(XDRIVE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\diamond.c ===
/*++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name:

    diamond.c

Abstract:

    Diamond MSZIP decompression support.

Author:

    Ted Miller (tedm) 31-Jan-1995

Revision History:

    Jamie Hunter (JamieHun) Jul-12-2000
        Made this behave better in MUI scenario
        changed all handles to be of type HANDLE rather than HFILE
        use UNICODE where we can
        convert path to short filename in the one place we can't

--*/

#include "precomp.h"
#pragma hdrstop

BOOL
DiamondInitialize(
    VOID
    );

INT_PTR
DIAMONDAPI
SpdFdiOpen(
    IN PSTR FileName,
    IN int  oflag,
    IN int  pmode
    );

int
DIAMONDAPI
SpdFdiClose(
    IN INT_PTR Handle
    );


UINT
pDiamondNotifyFileDone(
    IN PDIAMOND_THREAD_DATA PerThread,
    IN DWORD                Win32Error
    )
{
    UINT u;
    FILEPATHS FilePaths;

    MYASSERT(PerThread->CurrentTargetFile);

    FilePaths.Source = PerThread->CabinetFile;
    FilePaths.Target = PerThread->CurrentTargetFile;
    FilePaths.Win32Error = Win32Error;

    u = pSetupCallMsgHandler(
            NULL, // LogContext - we get from thread log context
            PerThread->MsgHandler,
            PerThread->IsMsgHandlerNativeCharWidth,
            PerThread->Context,
            SPFILENOTIFY_FILEEXTRACTED,
            (UINT_PTR)&FilePaths,
            0
            );

    return(u);
}


INT_PTR
DIAMONDAPI
DiamondNotifyFunction(
    IN FDINOTIFICATIONTYPE Operation,
    IN PFDINOTIFICATION    Parameters
    )
{
    PSETUP_TLS pTLS;
    PDIAMOND_THREAD_DATA PerThread;
    INT_PTR rc;
    HANDLE hFile;
    CABINET_INFO CabInfo;
    FILE_IN_CABINET_INFO FileInCab;
    FILETIME FileTime, UtcTime;
    TCHAR NewPath[MAX_PATH];
    PTSTR p;
    DWORD err;
    UINT action;

    pTLS = SetupGetTlsData();
    if(!pTLS) {
        return (INT_PTR)(-1);
    }
    PerThread = &pTLS->Diamond;

    switch(Operation) {

    case fdintCABINET_INFO:
        //
        // Tell the callback function, in case it wants to do something
        // with this information.
        //
        err = ERROR_NOT_ENOUGH_MEMORY;

        CabInfo.CabinetFile = NewPortableString(Parameters->psz1);
        if(CabInfo.CabinetFile) {

            CabInfo.DiskName = NewPortableString(Parameters->psz2);
            if(CabInfo.DiskName) {

                CabInfo.CabinetPath = NewPortableString(Parameters->psz3);
                if(CabInfo.CabinetPath) {

                    CabInfo.SetId = Parameters->setID;
                    CabInfo.CabinetNumber = Parameters->iCabinet;

                    err = (DWORD)pSetupCallMsgHandler(
                            NULL, // LogContext - we get from thread log context
                            PerThread->MsgHandler,
                            PerThread->IsMsgHandlerNativeCharWidth,
                            PerThread->Context,
                            SPFILENOTIFY_CABINETINFO,
                            (UINT_PTR)&CabInfo,
                            0
                            );

                    MyFree(CabInfo.CabinetPath);
                }
                MyFree(CabInfo.DiskName);
            }
            MyFree(CabInfo.CabinetFile);
        }

        if(err != NO_ERROR) {
            PerThread->LastError = err;
        }
        return (INT_PTR)((err == NO_ERROR) ? 0 : -1);

    case fdintCOPY_FILE:
        //
        // Diamond is asking us whether we want to copy the file.
        // If we switched cabinets, then the answer is no.
        //
        if(PerThread->SwitchedCabinets) {
            PerThread->LastError = NO_ERROR;
            return (INT_PTR)(-1);
        }

        // Pass the information on to the callback function and
        // let it decide.
        //
        FileInCab.NameInCabinet = NewPortableString(Parameters->psz1);
        FileInCab.FileSize = Parameters->cb;
        FileInCab.DosDate = Parameters->date;
        FileInCab.DosTime = Parameters->time;
        FileInCab.DosAttribs = Parameters->attribs;
        FileInCab.Win32Error = NO_ERROR;

        if(!FileInCab.NameInCabinet) {
            PerThread->LastError = ERROR_NOT_ENOUGH_MEMORY;
            return (INT_PTR)(-1);
        }

        //
        // Call the callback function.
        //
        action = pSetupCallMsgHandler(NULL, // LogContext - we get from thread log context
                                      PerThread->MsgHandler,
                                      PerThread->IsMsgHandlerNativeCharWidth,
                                      PerThread->Context,
                                      SPFILENOTIFY_FILEINCABINET,
                                      (UINT_PTR)&FileInCab,
                                      (UINT_PTR)PerThread->CabinetFile
                                      );

        MyFree (FileInCab.NameInCabinet);

        switch(action) {

        case FILEOP_SKIP:
            rc = 0;
            break;

        case FILEOP_DOIT:
            //
            // The callback wants to copy the file. In this case it has
            // provided us the full target pathname to use.
            //
            MYASSERT(PerThread->CurrentTargetFile == NULL);

            if(p = DuplicateString(FileInCab.FullTargetName)) {

                //
                // we need ANSI version of filename for sake of Diamond API's
                // note that the handle returned here must be compatible with
                // the handle returned by SpdFdiOpen
                //

                hFile = CreateFile(FileInCab.FullTargetName,
                                   GENERIC_READ | GENERIC_WRITE,
                                   FILE_SHARE_READ | FILE_SHARE_WRITE, // should probably be 0
                                   NULL,
                                   CREATE_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL);

                if(hFile == INVALID_HANDLE_VALUE) {
                    PerThread->LastError = GetLastError();
                    rc = -1;
                    MyFree(p);
                } else {
                    rc = (INT_PTR)hFile;
                    PerThread->CurrentTargetFile = p;
                }
            } else {

                PerThread->LastError = ERROR_NOT_ENOUGH_MEMORY;
                rc = -1;
            }

            break;

        case FILEOP_ABORT:
            //
            // Abort.
            //
            rc = -1;
            PerThread->LastError = FileInCab.Win32Error;
            //
            // here, if PerThread->LastError is still NO_ERROR, this is ok
            // it was the callback's intent
            // we know callback itself is ok, since internal failure returns
            // FILEOP_INTERNAL_FAILED
            //
            break;

        case FILEOP_INTERNAL_FAILED:
            //
            // should only be returned by callback wrapper
            //
            PerThread->LastError = GetLastError();
            if(!PerThread->LastError) {
                MYASSERT(PerThread->LastError);
                PerThread->LastError = ERROR_OPERATION_ABORTED;
            }
            rc = -1;
            break;

        default:
            PerThread->LastError = ERROR_OPERATION_ABORTED;
        }

        return rc;

    case fdintCLOSE_FILE_INFO:
        //
        // Diamond is done with the target file and wants us to close it.
        // (ie, this is the counterpart to fdintCOPY_FILE).
        //
        // We want the timestamp to be what is stored in the cabinet.
        // Note that we lose the create and last access times in this case.
        //
        if(DosDateTimeToFileTime(Parameters->date,Parameters->time,&FileTime) &&
            LocalFileTimeToFileTime(&FileTime, &UtcTime)) {

            SetFileTime((HANDLE)Parameters->hf,NULL,NULL,&UtcTime);
        }

        SpdFdiClose(Parameters->hf);

        //
        // Call the callback function to inform it that the file has been
        // successfully extracted from the cabinet.
        //
        MYASSERT(PerThread->CurrentTargetFile);

        err = (DWORD)pDiamondNotifyFileDone(PerThread,NO_ERROR);

        if(err != NO_ERROR) {
            PerThread->LastError = err;
        }

        MyFree(PerThread->CurrentTargetFile);
        PerThread->CurrentTargetFile = NULL;

        return (INT_PTR)((err == NO_ERROR) ? TRUE : -1);

    case fdintPARTIAL_FILE:
    case fdintENUMERATE:

        //
        // We don't do anything with this.
        //
        return (INT_PTR)(0);

    case fdintNEXT_CABINET:

        if((Parameters->fdie == FDIERROR_NONE) || (Parameters->fdie == FDIERROR_WRONG_CABINET)) {
            //
            // A file continues into another cabinet.
            // Inform the callback function, who is responsible for
            // making sure the cabinet is accessible when it returns.
            //
            err = ERROR_NOT_ENOUGH_MEMORY;
            CabInfo.SetId = 0;
            CabInfo.CabinetNumber = 0;

            CabInfo.CabinetPath = NewPortableString(Parameters->psz3);
            if(CabInfo.CabinetPath) {

                CabInfo.CabinetFile = NewPortableString(Parameters->psz1);
                if(CabInfo.CabinetFile) {

                    CabInfo.DiskName = NewPortableString(Parameters->psz2);
                    if(CabInfo.DiskName) {

                        err = (DWORD)pSetupCallMsgHandler(NULL, // LogContext - we get from thread log context
                                                          PerThread->MsgHandler,
                                                          PerThread->IsMsgHandlerNativeCharWidth,
                                                          PerThread->Context,
                                                          SPFILENOTIFY_NEEDNEWCABINET,
                                                          (UINT_PTR)&CabInfo,
                                                          (UINT_PTR)NewPath
                                                          );

                        if(err == NO_ERROR) {
                            //
                            // See if a new path was specified.
                            //
                            if(NewPath[0]) {
                                lstrcpyn(PerThread->UserPath,NewPath,MAX_PATH);
                                if(!pSetupConcatenatePaths(PerThread->UserPath,TEXT("\\"),MAX_PATH,NULL)) {
                                    err = ERROR_BUFFER_OVERFLOW;
                                } else {
                                    PSTR pp = NewAnsiString(PerThread->UserPath);
                                    if(strlen(pp)>=CB_MAX_CAB_PATH) {
                                        err = ERROR_BUFFER_OVERFLOW;
                                    } else {
                                        strcpy(Parameters->psz3,pp);
                                    }
                                    MyFree(pp);
                                }
                            }
                        }
                        if(err == NO_ERROR) {
                            //
                            // Remember that we switched cabinets.
                            //
                            PerThread->SwitchedCabinets = TRUE;
                        }

                        MyFree(CabInfo.DiskName);
                    }

                    MyFree(CabInfo.CabinetFile);
                }

                MyFree(CabInfo.CabinetPath);
            }

        } else {
            //
            // Some other error we don't understand -- this indicates
            // a bad cabinet.
            //
            err = ERROR_INVALID_DATA;
        }

        if(err != NO_ERROR) {
            PerThread->LastError = err;
        }

        return (INT_PTR)((err == NO_ERROR) ? 0 : -1);

    default:
        //
        // Unknown notification type. Should never get here.
        //
        MYASSERT(0);
        return (INT_PTR)(0);
    }
}

PVOID
DIAMONDAPI
SpdFdiAlloc(
    IN ULONG NumberOfBytes
    )

/*++

Routine Description:

    Callback used by FDICopy to allocate memory.

Arguments:

    NumberOfBytes - supplies desired size of block.

Return Value:

    Returns pointer to a block of memory or NULL
    if memory cannot be allocated.

--*/

{
    return(MyMalloc(NumberOfBytes));
}


VOID
DIAMONDAPI
SpdFdiFree(
    IN PVOID Block
    )

/*++

Routine Description:

    Callback used by FDICopy to free a memory block.
    The block must have been allocated with SpdFdiAlloc().

Arguments:

    Block - supplies pointer to block of memory to be freed.

Return Value:

    None.

--*/

{
    MyFree(Block);
}


INT_PTR
DIAMONDAPI
SpdFdiOpen(
    IN PSTR FileName,
    IN int  oflag,
    IN int  pmode
    )

/*++

Routine Description:

    Callback used by FDICopy to open files.

    This routine is capable only of opening existing files.

    When making changes here, also take note of other places
    that open the file directly (search for SpdFdiOpen)

Arguments:

    FileName - supplies name of file to be opened.

    oflag - supplies flags for open.

    pmode - supplies additional flags for open.

Return Value:

    Handle to open file or -1 if error occurs.

--*/

{
    HANDLE h;
    PDIAMOND_THREAD_DATA PerThread;
    PSETUP_TLS pTLS;

    UNREFERENCED_PARAMETER(pmode);

    pTLS = SetupGetTlsData();
    if (!pTLS) {
        return -1;
    }
    PerThread = &pTLS->Diamond;

    MYASSERT(PerThread);

    if(oflag & (_O_WRONLY | _O_RDWR | _O_APPEND | _O_CREAT | _O_TRUNC | _O_EXCL)) {
        PerThread->LastError = ERROR_INVALID_PARAMETER;
        return(-1);
    }

    h = CreateFileA(FileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);
    if(h == INVALID_HANDLE_VALUE) {
        PerThread->LastError = GetLastError();
        return(-1);
    }

    return (INT_PTR)h;
}

UINT
DIAMONDAPI
SpdFdiRead(
    IN  INT_PTR Handle,
    OUT PVOID pv,
    IN  UINT  ByteCount
    )

/*++

Routine Description:

    Callback used by FDICopy to read from a file.

Arguments:

    Handle - supplies handle to open file to be read from.

    pv - supplies pointer to buffer to receive bytes we read.

    ByteCount - supplies number of bytes to read.

Return Value:

    Number of bytes read or -1 if an error occurs.

--*/

{
    PDIAMOND_THREAD_DATA PerThread;
    PSETUP_TLS pTLS;
    DWORD d;
    HANDLE hFile = (HANDLE)Handle;
    DWORD bytes;
    UINT rc;

    if(ReadFile(hFile,pv,(DWORD)ByteCount,&bytes,NULL)) {
        rc = (UINT)bytes;
    } else {
        d = GetLastError();
        rc = (UINT)(-1);

        pTLS = SetupGetTlsData();
        MYASSERT(pTLS);
        PerThread = &pTLS->Diamond;
        PerThread->LastError = d;
    }
    return rc;
}


UINT
DIAMONDAPI
SpdFdiWrite(
    IN INT_PTR Handle,
    IN PVOID pv,
    IN UINT  ByteCount
    )

/*++

Routine Description:

    Callback used by FDICopy to write to a file.

Arguments:

    Handle - supplies handle to open file to be written to.

    pv - supplies pointer to buffer containing bytes to write.

    ByteCount - supplies number of bytes to write.

Return Value:

    Number of bytes written (ByteCount) or -1 if an error occurs.

--*/

{
    UINT rc;
    PDIAMOND_THREAD_DATA PerThread;
    PSETUP_TLS pTLS;
    DWORD d;
    HANDLE hFile = (HANDLE)Handle;
    DWORD bytes;

    if(WriteFile(hFile,pv,(DWORD)ByteCount,&bytes,NULL)) {
        rc = (UINT)bytes;
    } else {
        d = GetLastError();
        rc = (UINT)(-1);

        pTLS = SetupGetTlsData();
        MYASSERT(pTLS);
        PerThread = &pTLS->Diamond;
        PerThread->LastError = d;
    }

    return rc;
}


int
DIAMONDAPI
SpdFdiClose(
    IN INT_PTR Handle
    )

/*++

Routine Description:

    Callback used by FDICopy to close files.

Arguments:

    Handle - handle of file to close.

Return Value:

    0 (success).

--*/

{
    HANDLE hFile = (HANDLE)Handle;
    BOOL success = FALSE;

    //
    // diamond has in the past given us an invalid file handle
    // actually it gives us the same file handle twice.
    //
    //
    try {
        success = CloseHandle(hFile);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        success = FALSE;
    }

    MYASSERT(success);

    //
    // Always act like we succeeded.
    //
    return 0;
}


long
DIAMONDAPI
SpdFdiSeek(
    IN INT_PTR Handle,
    IN long Distance,
    IN int  SeekType
    )

/*++

Routine Description:

    Callback used by FDICopy to seek files.

Arguments:

    Handle - handle of file to close.

    Distance - supplies distance to seek. Interpretation of this
        parameter depends on the value of SeekType.

    SeekType - supplies a value indicating how Distance is to be
        interpreted; one of SEEK_SET, SEEK_CUR, SEEK_END.

Return Value:

    New file offset or -1 if an error occurs.

--*/

{
    LONG rc;
    DWORD d;
    PDIAMOND_THREAD_DATA PerThread;
    PSETUP_TLS pTLS;
    HANDLE hFile = (HANDLE)Handle;
    DWORD pos_low;
    DWORD method;

    switch(SeekType) {
        case SEEK_SET:
            method = FILE_BEGIN;
            break;

        case SEEK_CUR:
            method = FILE_CURRENT;
            break;

        case SEEK_END:
            method = FILE_END;
            break;

        default:
            return -1;
    }

    pos_low = SetFilePointer(hFile,(DWORD)Distance,NULL,method);
    if(pos_low == INVALID_SET_FILE_POINTER) {
        d = GetLastError();
        rc = -1L;

        pTLS = SetupGetTlsData();
        MYASSERT(pTLS);
        PerThread = &pTLS->Diamond;
        PerThread->LastError = d;
    } else {
        rc = (long)pos_low;
    }

    return(rc);
}


DWORD
DiamondProcessCabinet(
    IN PCTSTR CabinetFile,
    IN DWORD  Flags,
    IN PVOID  MsgHandler,
    IN PVOID  Context,
    IN BOOL   IsMsgHandlerNativeCharWidth
    )

/*++

Routine Description:

    Process a diamond cabinet file, iterating through all files
    contained within it and calling the callback function with
    information about each file.

Arguments:

    SourceFileName - supplies name of cabinet file.

    Flags - supplies flags to control behavior of cabinet processing.

    MsgHandler - Supplies a callback routine to be notified
        of various significant events in cabinet processing.

    Context - Supplies a value that is passed to the MsgHandler
        callback function.

Return Value:

    Win32 error code indicating result. If the cabinet was corrupt,
    ERROR_INVALID_DATA is returned.

--*/

{
    BOOL b;
    DWORD rc;
    PDIAMOND_THREAD_DATA PerThread;
    PSETUP_TLS pTLS;
    PSTR FilePartA = NULL;
    PSTR PathPartA = NULL;
    PCTSTR FileTitle;
    CHAR c;
    int h;

    UNREFERENCED_PARAMETER(Flags);

    //
    // Fetch pointer to per-thread data.
    // may cause initialization
    //
    pTLS = SetupGetTlsData();
    if(!pTLS) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto c0;
    }
    PerThread = &pTLS->Diamond;

    MYASSERT(PerThread->FdiContext);

    //
    // Because diamond does not really give us a truly comprehensive
    // context mechanism, our diamond support is NOT reentrant.
    // No synchronization is required to check this state because
    // it is stored in per-thread data.
    //
    if(PerThread->InDiamond) {
        rc = ERROR_INVALID_FUNCTION;
        goto c0;
    }

    PerThread->InDiamond = TRUE;

    //
    // Split the cabinet name into path and name.
    // we need to convert to short-name format before
    // passing it on, so that diamond doesn't get upset
    // in MUI install situations
    //
    FileTitle = pSetupGetFileTitle(CabinetFile);
    FilePartA = GetAnsiMuiSafeFilename(FileTitle);
    PathPartA = GetAnsiMuiSafePathname(CabinetFile);
    if(!FilePartA || !PathPartA) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto c1;
    }

    //
    // Initialize thread globals.
    //
    PerThread->LastError = NO_ERROR;
    PerThread->CabinetFile = CabinetFile;

    PerThread->MsgHandler = MsgHandler;
    PerThread->IsMsgHandlerNativeCharWidth = IsMsgHandlerNativeCharWidth;
    PerThread->Context = Context;

    PerThread->SwitchedCabinets = FALSE;
    PerThread->UserPath[0] = 0;

    PerThread->CurrentTargetFile = NULL;

    //
    // Perform the copy.
    //
    b = FDICopy(
            PerThread->FdiContext,
            FilePartA,
            PathPartA,
            0,                          // flags
            DiamondNotifyFunction,
            NULL,                       // no decryption
            NULL                        // don't bother with user-specified data
            );

    if(b) {

        //
        // Everything succeeded so we shouldn't have any partially
        // processed files.
        //
        MYASSERT(!PerThread->CurrentTargetFile);
        rc = NO_ERROR;

    } else {

        switch(PerThread->FdiError.erfOper) {

        case FDIERROR_NONE:
            //
            // We shouldn't see this -- if there was no error
            // then FDICopy should have returned TRUE.
            //
            MYASSERT(PerThread->FdiError.erfOper != FDIERROR_NONE);
            rc = ERROR_INVALID_DATA;
            break;

        case FDIERROR_CABINET_NOT_FOUND:
            rc = ERROR_FILE_NOT_FOUND;
            break;

        case FDIERROR_CORRUPT_CABINET:
            //
            // Read/open/seek error or corrupt cabinet
            //
            rc = PerThread->LastError;
            if(rc == NO_ERROR) {
                rc = ERROR_INVALID_DATA;
            }
            break;

        case FDIERROR_ALLOC_FAIL:
            rc = ERROR_NOT_ENOUGH_MEMORY;
            break;

        case FDIERROR_TARGET_FILE:
        case FDIERROR_USER_ABORT:
            rc = PerThread->LastError;
            break;

        case FDIERROR_NOT_A_CABINET:
        case FDIERROR_UNKNOWN_CABINET_VERSION:
        case FDIERROR_BAD_COMPR_TYPE:
        case FDIERROR_MDI_FAIL:
        case FDIERROR_RESERVE_MISMATCH:
        case FDIERROR_WRONG_CABINET:
        default:
            //
            // Cabinet is corrupt or not actually a cabinet, etc.
            //
            rc = ERROR_INVALID_DATA;
            break;
        }

        if(PerThread->CurrentTargetFile) {
            //
            // Call the callback function to inform it that the last file
            // was not successfully extracted from the cabinet.
            // Also remove the partially copied file.
            //
            DeleteFile(PerThread->CurrentTargetFile);

            pDiamondNotifyFileDone(PerThread,rc);
            MyFree(PerThread->CurrentTargetFile);
            PerThread->CurrentTargetFile = NULL;
        }

    }

c1:
    if(FilePartA) {
        MyFree(FilePartA);
    }
    if(PathPartA) {
        MyFree(PathPartA);
    }
    PerThread->InDiamond = FALSE;
c0:
    return(rc);
}


BOOL
DiamondIsCabinet(
    IN PCTSTR FileName
    )

/*++

Routine Description:

    Determine if a file is a diamond cabinet.

Arguments:

    FileName - supplies name of file to be checked.

Return Value:

    TRUE if file is diamond file. FALSE if not;

--*/

{
    FDICABINETINFO CabinetInfo;
    BOOL b;
    INT_PTR h;
    HANDLE hFile;
    PDIAMOND_THREAD_DATA PerThread;
    PSETUP_TLS pTLS;

    b = FALSE;

    //
    // Get TLS data, may cause initialization
    //
    pTLS = SetupGetTlsData();
    if(!pTLS) {
        MYASSERT( FALSE && TEXT("DiamondInitialize failed") );
        goto c0;
    }

    if (!FileExists(FileName,NULL)) {
        return FALSE;
    }

    PerThread = &pTLS->Diamond;

    MYASSERT(PerThread->FdiContext);

    //
    // Because diamond does not really give us a truly comprehensive
    // context mechanism, our diamond support is NOT reentrant.
    // No synchronization is required to check this state because
    // it is stored in per-thread data.
    //
    if(PerThread->InDiamond) {
        MYASSERT( FALSE && TEXT("PerThread->InDiamond failed") );
        goto c0;
    }

    PerThread->InDiamond = TRUE;

    //
    // The handle returned here must be compatible with
    // that returnd by SpdFdiOpen
    //
    hFile = CreateFile(FileName,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);
    if(hFile == INVALID_HANDLE_VALUE) {
        goto c1;
    }
    h = (INT_PTR)hFile;
    SpdFdiSeek(h , 0, SEEK_SET);
    b = FDIIsCabinet(PerThread->FdiContext,h,&CabinetInfo);

#if DBG
    if (!b) {
        LPCTSTR p;
        p = _tcsrchr(FileName, TEXT('.'));
        while (p && *p) {
            if (*p == '_') {
                MYASSERT(FALSE && TEXT("FDIIsCabinetFailed for a file ending in _"));
                SpdFdiSeek(h , 0, SEEK_SET);
                FDIIsCabinet(PerThread->FdiContext,h,&CabinetInfo);
            }
            p++;
        }
    }
#endif

    SpdFdiClose(h);

c1:
    PerThread->InDiamond = FALSE;
c0:
    return(b);
}



BOOL
DiamondInitialize(
    VOID
    )

/*++

Routine Description:

    Per-thread initialization routine for Diamond.
    Called once per thread.

Arguments:

    None.

Return Value:

    Boolean result indicating success or failure.
    Failure can be assumed to be out of memory.

--*/

{
    HFDI FdiContext;
    PDIAMOND_THREAD_DATA PerThread;
    PSETUP_TLS pTLS;
    BOOL retval = FALSE;

    pTLS = SetupGetTlsData();
    MYASSERT(pTLS);
    PerThread = &pTLS->Diamond;
    PerThread->FdiContext = NULL;

    retval = FALSE;
    try {

        //
        // Initialize a diamond context.
        //
        FdiContext = FDICreate(
                        SpdFdiAlloc,
                        SpdFdiFree,
                        SpdFdiOpen,
                        SpdFdiRead,
                        SpdFdiWrite,
                        SpdFdiClose,
                        SpdFdiSeek,
                        cpuUNKNOWN,
                        &PerThread->FdiError
                        );

        if(FdiContext) {
            PerThread->FdiContext = FdiContext;
            retval = TRUE;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        retval = FALSE;
    }

    return(retval);
}


VOID
DiamondTerminate(
    VOID
    )

/*++

Routine Description:

    Per-thread termination routine for Diamond.
    Called internally.

Arguments:

    None.

Return Value:

    Boolean result indicating success or failure.
    Failure can be assumed to be out of memory.

--*/

{
    PSETUP_TLS pTLS;
    PDIAMOND_THREAD_DATA PerThread;

    pTLS = SetupGetTlsData();
    PerThread = pTLS? &pTLS->Diamond : NULL;
    if(PerThread && PerThread->FdiContext) {
        FDIDestroy(PerThread->FdiContext);
        PerThread->FdiContext = NULL;
    }

}


BOOL
DiamondProcessAttach(
    IN BOOL Attach
    )

/*++

Routine Description:

    Process attach routine. Must be called by the DLL entry point routine
    on DLL_PROCESS_ATTACH and DLL_PROCESS_DETACH notifications.

Arguments:

    Attach - TRUE if process is attaching; FALSE if not.

Return Value:

    Boolean result indicating success or failure. Meaningful only if
    Attach is TRUE.

--*/

{
    return TRUE;
}


BOOL
DiamondTlsInit(
    IN BOOL Init
    )

/*++

Routine Description:

    The routine initializes per-thread data used by diamond.

Arguments:

    Init - TRUE if thread initialization; FALSE to cleanup

Return Value:

    None.

--*/

{
    if(Init) {
        return DiamondInitialize();
    } else {
        DiamondTerminate();
        return TRUE;
    }
}


///////////////////////////////////////////////////////////////////////////


BOOL
_SetupIterateCabinet(
    IN PCTSTR CabinetFile,
    IN DWORD  Flags,
    IN PVOID  MsgHandler,
    IN PVOID  Context,
    IN BOOL   IsMsgHandlerNativeCharWidth
    )
{
    PTSTR cabinetFile;
    DWORD rc;

    //
    // Flags param not used. Make sure it's zero.
    //
    if(Flags) {
        rc = ERROR_INVALID_PARAMETER;
        goto c0;
    }

    //
    // Get a copy of the cabinet file name to validate
    // the caller's buffer.
    //
    try {
        cabinetFile = DuplicateString(CabinetFile);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
        goto c0;
    }

    if(!cabinetFile) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto c0;
    }

    rc = DiamondProcessCabinet(cabinetFile,Flags,MsgHandler,Context,IsMsgHandlerNativeCharWidth);

    MyFree(cabinetFile);

c0:
    SetLastError(rc);
    return(rc == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupIterateCabinetA(
    IN  PCSTR               CabinetFile,
    IN  DWORD               Flags,
    IN  PSP_FILE_CALLBACK_A MsgHandler,
    IN  PVOID               Context
    )
{
    BOOL b;
    DWORD rc;
    PCWSTR cabinetFile;

    rc = pSetupCaptureAndConvertAnsiArg(CabinetFile,&cabinetFile);
    if(rc == NO_ERROR) {

        b = _SetupIterateCabinet(cabinetFile,Flags,MsgHandler,Context,FALSE);
        rc = GetLastError();

        MyFree(cabinetFile);

    } else {
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupIterateCabinetW(
    IN  PCWSTR              CabinetFile,
    IN  DWORD               Flags,
    IN  PSP_FILE_CALLBACK_W MsgHandler,
    IN  PVOID               Context
    )
{
    UNREFERENCED_PARAMETER(CabinetFile);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(MsgHandler);
    UNREFERENCED_PARAMETER(Context);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupIterateCabinet(
    IN  PCTSTR            CabinetFile,
    IN  DWORD             Flags,
    IN  PSP_FILE_CALLBACK MsgHandler,
    IN  PVOID             Context
    )
{
    return(_SetupIterateCabinet(CabinetFile,Flags,MsgHandler,Context,TRUE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\diansicv.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    diansicv.c

Abstract:

    Routine to convert device installer data structures between
    ANSI and Unicode.

    The contents of this file are compiled only when UNICODE
    is #define'd.

Author:

    Ted Miller (tedm) 19-July-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


#ifdef UNICODE

DWORD
pSetupDiDevInstParamsAnsiToUnicode(
    IN  PSP_DEVINSTALL_PARAMS_A AnsiDevInstParams,
    OUT PSP_DEVINSTALL_PARAMS_W UnicodeDevInstParams
    )

/*++

Routine Description:

    This routine converts an SP_DEVINSTALL_PARAMS_A structure to
    an SP_DEVINSTALL_PARAMS_W, guarding against bogus pointers
    passed in the by the caller.

Arguments:

    AnsiDevInstParams - supplies ANSI device installation parameters
        to be converted to unicode.

    UnicodeDevInstParams - if successful, receives Unicode equivalent of
        AnsiDevInstParams.

Return Value:

    NO_ERROR                - conversion successful.
    ERROR_INVALID_PARAMETER - one of the arguments was not a valid pointer.

    It is not believed that, given valid arguments, text conversion itself
    can fail, since all ANSI chars always have Unicode equivalents.

--*/

{
    int i;
    DWORD rc;

    rc = NO_ERROR;

    try {

        if(AnsiDevInstParams->cbSize == sizeof(SP_DEVINSTALL_PARAMS_A)) {

            //
            // Fixed part of structure.
            //
            MYASSERT(offsetof(SP_DEVINSTALL_PARAMS_A,DriverPath) == offsetof(SP_DEVINSTALL_PARAMS_W,DriverPath));

            CopyMemory(
                UnicodeDevInstParams,
                AnsiDevInstParams,
                offsetof(SP_DEVINSTALL_PARAMS_W,DriverPath)
                );

            UnicodeDevInstParams->cbSize = sizeof(SP_DEVINSTALL_PARAMS_W);

            //
            // Convert the single string in the structure. To make things easier
            // we'll just convert the entire buffer. There's no potential for overflow.
            //
            i = MultiByteToWideChar(
                    CP_ACP,
                    MB_PRECOMPOSED,
                    AnsiDevInstParams->DriverPath,
                    sizeof(AnsiDevInstParams->DriverPath),
                    UnicodeDevInstParams->DriverPath,
                    sizeof(UnicodeDevInstParams->DriverPath) / sizeof(WCHAR)
                    );

            if(!i) {
                rc = GetLastError();
            }
        } else {
            rc = ERROR_INVALID_USER_BUFFER;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    return(rc);
}


DWORD
pSetupDiDevInstParamsUnicodeToAnsi(
    IN  PSP_DEVINSTALL_PARAMS_W UnicodeDevInstParams,
    OUT PSP_DEVINSTALL_PARAMS_A AnsiDevInstParams
    )

/*++

Routine Description:

    This routine converts an SP_DEVINSTALL_PARAMS_W structure to
    an SP_DEVINSTALL_PARAMS_A, guarding against bogus pointers
    passed in the by the caller.

Arguments:

    UnicodeDevInstParams - supplies Unicode device installation parameters
        to be converted to ANSI.

    AnsiDevInstParams - if successful, receives Ansi equivalent of
        UnicodeDevInstParams.

Return Value:

    NO_ERROR                - conversion successful.
    ERROR_INVALID_PARAMETER - one of the arguments was not a valid pointer.

    Unicode chars that can't be represented in the current system ANSI codepage
    will be replaced with a system default in the ANSI structure.

--*/

{
    int i;
    DWORD rc;
    UCHAR AnsiString[MAX_PATH*2];

    MYASSERT(UnicodeDevInstParams->cbSize == sizeof(SP_DEVINSTALL_PARAMS_W));

    rc = NO_ERROR;

    try {

        if(AnsiDevInstParams->cbSize == sizeof(SP_DEVINSTALL_PARAMS_A)) {
            //
            // Fixed part of structure.
            //
            MYASSERT(offsetof(SP_DEVINSTALL_PARAMS_A,DriverPath) == offsetof(SP_DEVINSTALL_PARAMS_W,DriverPath));

            CopyMemory(
                AnsiDevInstParams,
                UnicodeDevInstParams,
                offsetof(SP_DEVINSTALL_PARAMS_W,DriverPath)
                );

            AnsiDevInstParams->cbSize = sizeof(SP_DEVINSTALL_PARAMS_A);

            //
            // Convert the single string in the structure. Unfortunately there is
            // potential for overflow because some Unicode chars could convert to
            // double-byte ANSI characters -- but the string in the ANSI structure
            // is only MAX_PATH *bytes* (not MAX_PATH double-byte *characters*) long.
            //
            i = WideCharToMultiByte(
                    CP_ACP,
                    0,
                    UnicodeDevInstParams->DriverPath,
                    sizeof(UnicodeDevInstParams->DriverPath) / sizeof(WCHAR),
                    AnsiString,
                    sizeof(AnsiString),
                    NULL,
                    NULL
                    );

            if(i) {
                //
                // Copy converted string into caller's structure, limiting
                // its length to avoid overflow.
                //
                if(!lstrcpynA(AnsiDevInstParams->DriverPath,AnsiString,sizeof(AnsiDevInstParams->DriverPath))) {
                    //
                    // lstrcpyn faulted, a pointer must be bogus
                    //
                    rc = ERROR_INVALID_PARAMETER;
                }
            } else {
                rc = GetLastError();
            }
        } else {
            rc = ERROR_INVALID_USER_BUFFER;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    return(rc);
}


DWORD
pSetupDiSelDevParamsAnsiToUnicode(
    IN  PSP_SELECTDEVICE_PARAMS_A AnsiSelDevParams,
    OUT PSP_SELECTDEVICE_PARAMS_W UnicodeSelDevParams
    )

/*++

Routine Description:

    This routine converts an SP_SELECTDEVICE_PARAMS_A structure to
    an SP_SELECTDEVICE_PARAMS_W, guarding against bogus pointers
    passed in the by the caller.

Arguments:

    AnsiSelDevParams - supplies ANSI device selection parameters
        to be converted to unicode.

    UnicodeSelDevParams - if successful, receives Unicode equivalent of
        AnsiSelDevParams.

Return Value:

    NO_ERROR                - conversion successful.
    ERROR_INVALID_PARAMETER - one of the arguments was not a valid pointer.

    It is not believed that, given valid arguments, text conversion itself
    can fail, since all ANSI chars always have Unicode equivalents.

--*/

{
    int i;
    DWORD rc;

    rc = NO_ERROR;

    try {
        if(AnsiSelDevParams->ClassInstallHeader.cbSize == sizeof(SP_CLASSINSTALL_HEADER)) {
            //
            // Fixed part of structure.
            //
            MYASSERT(offsetof(SP_SELECTDEVICE_PARAMS_A,Title) == offsetof(SP_SELECTDEVICE_PARAMS_W,Title));

            CopyMemory(
                UnicodeSelDevParams,
                AnsiSelDevParams,
                offsetof(SP_SELECTDEVICE_PARAMS_W,Title)
                );

            //
            // Convert the strings in the structure. To make things easier
            // we'll just convert the entire buffers. There's no potential for overflow.
            //
            i = MultiByteToWideChar(
                    CP_ACP,
                    MB_PRECOMPOSED,
                    AnsiSelDevParams->Title,
                    sizeof(AnsiSelDevParams->Title),
                    UnicodeSelDevParams->Title,
                    sizeof(UnicodeSelDevParams->Title) / sizeof(WCHAR)
                    );

            if(i) {
                i = MultiByteToWideChar(
                        CP_ACP,
                        MB_PRECOMPOSED,
                        AnsiSelDevParams->Instructions,
                        sizeof(AnsiSelDevParams->Instructions),
                        UnicodeSelDevParams->Instructions,
                        sizeof(UnicodeSelDevParams->Instructions) / sizeof(WCHAR)
                        );

                if(i) {
                    i = MultiByteToWideChar(
                            CP_ACP,
                            MB_PRECOMPOSED,
                            AnsiSelDevParams->ListLabel,
                            sizeof(AnsiSelDevParams->ListLabel),
                            UnicodeSelDevParams->ListLabel,
                            sizeof(UnicodeSelDevParams->ListLabel) / sizeof(WCHAR)
                            );
                    if(i) {
                        i = MultiByteToWideChar(
                                CP_ACP,
                                MB_PRECOMPOSED,
                                AnsiSelDevParams->SubTitle,
                                sizeof(AnsiSelDevParams->SubTitle),
                                UnicodeSelDevParams->SubTitle,
                                sizeof(UnicodeSelDevParams->SubTitle) / sizeof(WCHAR)
                                );

                        if(!i) {
                            rc = GetLastError();
                        }
                    } else {
                        rc = GetLastError();
                    }
                } else {
                    rc = GetLastError();
                }
            } else {
                rc = GetLastError();
            }
        } else {
            rc = ERROR_INVALID_USER_BUFFER;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    return(rc);
}


DWORD
pSetupDiSelDevParamsUnicodeToAnsi(
    IN  PSP_SELECTDEVICE_PARAMS_W UnicodeSelDevParams,
    OUT PSP_SELECTDEVICE_PARAMS_A AnsiSelDevParams
    )

/*++

Routine Description:

    This routine converts an SP_SELECTDEVICE_PARAMS_W structure to
    an SP_SELECTDEVICE_PARAMS_A, guarding against bogus pointers
    passed in the by the caller.  It is assumed that the ANSI output buffer is
    of sufficient size, and that its ClassInstallHeader.cbSize field is
    initialized correctly.

Arguments:

    UnicodeSelDevParams - supplies Unicode device selection parameters
        to be converted to ANSI.

    AnsiSelDevParams - if successful, receives Ansi equivalent of
        UnicodeSelDevParams.

Return Value:

    NO_ERROR                - conversion successful.
    ERROR_INVALID_PARAMETER - one of the arguments was not a valid pointer.

    Unicode chars that can't be represented in the current system ANSI codepage
    will be replaced with a system default in the ANSI structure.

--*/

{
    int i;
    DWORD rc;
    UCHAR AnsiTitle[MAX_TITLE_LEN*2];
    UCHAR AnsiInstructions[MAX_INSTRUCTION_LEN*2];
    UCHAR AnsiListLabel[MAX_LABEL_LEN*2];
    UCHAR AnsiSubTitle[MAX_SUBTITLE_LEN*2];
    PVOID p;

    MYASSERT(UnicodeSelDevParams->ClassInstallHeader.cbSize == sizeof(SP_CLASSINSTALL_HEADER));
    MYASSERT(AnsiSelDevParams->ClassInstallHeader.cbSize    == sizeof(SP_CLASSINSTALL_HEADER));

    rc = NO_ERROR;

    try {
        //
        // Fixed part of structure.
        //
        MYASSERT(offsetof(SP_SELECTDEVICE_PARAMS_A,Title) == offsetof(SP_SELECTDEVICE_PARAMS_W,Title));

        CopyMemory(
            AnsiSelDevParams,
            UnicodeSelDevParams,
            offsetof(SP_SELECTDEVICE_PARAMS_W,Title)
            );

        ZeroMemory(AnsiSelDevParams->Reserved,sizeof(AnsiSelDevParams->Reserved));

        //
        // Convert the strings in the structure. Unfortunately there is
        // potential for overflow because some Unicode chars could convert to
        // double-byte ANSI characters -- but the strings in the ANSI structure
        // are sized in *bytes* (not double-byte *characters*).
        //
        i = WideCharToMultiByte(
                CP_ACP,
                0,
                UnicodeSelDevParams->Title,
                sizeof(UnicodeSelDevParams->Title) / sizeof(WCHAR),
                AnsiTitle,
                sizeof(AnsiTitle),
                NULL,
                NULL
                );

        if(i) {

            i = WideCharToMultiByte(
                    CP_ACP,
                    0,
                    UnicodeSelDevParams->Instructions,
                    sizeof(UnicodeSelDevParams->Instructions) / sizeof(WCHAR),
                    AnsiInstructions,
                    sizeof(AnsiInstructions),
                    NULL,
                    NULL
                    );

            if(i) {

                i = WideCharToMultiByte(
                        CP_ACP,
                        0,
                        UnicodeSelDevParams->ListLabel,
                        sizeof(UnicodeSelDevParams->ListLabel) / sizeof(WCHAR),
                        AnsiListLabel,
                        sizeof(AnsiListLabel),
                        NULL,
                        NULL
                        );

                if(i) {

                    i = WideCharToMultiByte(
                            CP_ACP,
                            0,
                            UnicodeSelDevParams->SubTitle,
                            sizeof(UnicodeSelDevParams->SubTitle) / sizeof(WCHAR),
                            AnsiSubTitle,
                            sizeof(AnsiSubTitle),
                            NULL,
                            NULL
                            );
                    if(i) {
                        //
                        // Copy converted strings into caller's structure, limiting
                        // lengths to avoid overflow. If any lstrcpynA call returns NULL
                        // then it faulted meaning a pointer is bad.
                        //
                        #undef CPYANS
                        #define CPYANS(field) lstrcpynA(AnsiSelDevParams->field,Ansi##field,sizeof(AnsiSelDevParams->field))

                        if(!CPYANS(Title) || 
                           !CPYANS(Instructions) || 
                           !CPYANS(ListLabel) ||
                           !CPYANS(SubTitle)) {
                            
                            rc = ERROR_INVALID_PARAMETER;
                        }

                    } else {
                        rc = GetLastError();
                    }
                } else {
                    rc = GetLastError();
                }
            } else {
                rc = GetLastError();
            }
        } else {
            rc = GetLastError();
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    return(rc);
}


DWORD
pSetupDiDrvInfoDataAnsiToUnicode(
    IN  PSP_DRVINFO_DATA_A AnsiDrvInfoData,
    OUT PSP_DRVINFO_DATA_W UnicodeDrvInfoData
    )

/*++

Routine Description:

    This routine converts an SP_DRVINFO_DATA_A structure to
    an SP_DRVINFO_DATA_W, guarding against bogus pointers
    passed in the by the caller.

Arguments:

    AnsiDrvInfoData - supplies ANSI structure to be converted to unicode.

    UnicodeDrvInfoData - if successful, receives Unicode equivalent of
        AnsiDrvInfoData.

Return Value:

    NO_ERROR                - conversion successful.
    ERROR_INVALID_PARAMETER - one of the arguments was not a valid pointer.

    It is not believed that, given valid arguments, text conversion itself
    can fail, since all ANSI chars always have Unicode equivalents.

--*/

{
    int i;
    DWORD rc;

    rc = NO_ERROR;

    try {
        if((AnsiDrvInfoData->cbSize == sizeof(SP_DRVINFO_DATA_A)) ||
           (AnsiDrvInfoData->cbSize == sizeof(SP_DRVINFO_DATA_V1_A))) {
            //
            // Fixed part of structure.
            //
            MYASSERT(offsetof(SP_DRVINFO_DATA_A,Description) == offsetof(SP_DRVINFO_DATA_W,Description));

            ZeroMemory(UnicodeDrvInfoData, sizeof(SP_DRVINFO_DATA_W));

            CopyMemory(
                UnicodeDrvInfoData,
                AnsiDrvInfoData,
                offsetof(SP_DRVINFO_DATA_W,Description)
                );

            UnicodeDrvInfoData->cbSize = sizeof(SP_DRVINFO_DATA_W);

            //
            // Convert the strings in the structure. To make things easier
            // we'll just convert the entire buffers. There's no potential for overflow.
            //
            i = MultiByteToWideChar(
                    CP_ACP,
                    MB_PRECOMPOSED,
                    AnsiDrvInfoData->Description,
                    sizeof(AnsiDrvInfoData->Description),
                    UnicodeDrvInfoData->Description,
                    sizeof(UnicodeDrvInfoData->Description) / sizeof(WCHAR)
                    );

            if(i) {
                i = MultiByteToWideChar(
                        CP_ACP,
                        MB_PRECOMPOSED,
                        AnsiDrvInfoData->MfgName,
                        sizeof(AnsiDrvInfoData->MfgName),
                        UnicodeDrvInfoData->MfgName,
                        sizeof(UnicodeDrvInfoData->MfgName) / sizeof(WCHAR)
                        );

                if(i) {
                    i = MultiByteToWideChar(
                            CP_ACP,
                            MB_PRECOMPOSED,
                            AnsiDrvInfoData->ProviderName,
                            sizeof(AnsiDrvInfoData->ProviderName),
                            UnicodeDrvInfoData->ProviderName,
                            sizeof(UnicodeDrvInfoData->ProviderName) / sizeof(WCHAR)
                            );

                    if(i) {
                        //
                        // Successfully converted all strings to unicode.  Set
                        // the final two fields (DriverDate and DriverVersion)
                        // unless the caller supplied us with a version 1
                        // structure.
                        //
                        if(AnsiDrvInfoData->cbSize == sizeof(SP_DRVINFO_DATA_A)) {
                            UnicodeDrvInfoData->DriverDate = AnsiDrvInfoData->DriverDate;
                            UnicodeDrvInfoData->DriverVersion = AnsiDrvInfoData->DriverVersion;
                        }

                    } else {
                        rc = GetLastError();
                    }
                } else {
                    rc = GetLastError();
                }
            } else {
                rc = GetLastError();
            }
        } else {
            rc = ERROR_INVALID_USER_BUFFER;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    return(rc);
}


DWORD
pSetupDiDrvInfoDataUnicodeToAnsi(
    IN  PSP_DRVINFO_DATA_W UnicodeDrvInfoData,
    OUT PSP_DRVINFO_DATA_A AnsiDrvInfoData
    )

/*++

Routine Description:

    This routine converts an SP_DRVINFO_DATA_W structure to
    an SP_DRVINFO_DATA_A, guarding against bogus pointers
    passed in the by the caller.

Arguments:

    UnicodeDrvInfoData - supplies Unicode structure to be converted
        to ANSI.

    AnsiDrvInfoData - if successful, receives Ansi equivalent of
        UnicodeDrvInfoData.

Return Value:

    NO_ERROR                - conversion successful.
    ERROR_INVALID_PARAMETER - one of the arguments was not a valid pointer.

    Unicode chars that can't be represented in the current system ANSI codepage
    will be replaced with a system default in the ANSI structure.

--*/

{
    int i;
    DWORD rc;
    UCHAR AnsiDescription[LINE_LEN*2];
    UCHAR AnsiMfgName[LINE_LEN*2];
    UCHAR AnsiProviderName[LINE_LEN*2];
    PVOID p;

    MYASSERT(UnicodeDrvInfoData->cbSize == sizeof(SP_DRVINFO_DATA_W));

    rc = NO_ERROR;

    try {

        if((AnsiDrvInfoData->cbSize == sizeof(SP_DRVINFO_DATA_A)) ||
           (AnsiDrvInfoData->cbSize == sizeof(SP_DRVINFO_DATA_V1_A))) {

            //
            // Copy over the DriverType and the Reserved field.
            //
            AnsiDrvInfoData->DriverType = UnicodeDrvInfoData->DriverType;
            AnsiDrvInfoData->Reserved = UnicodeDrvInfoData->Reserved;

            //
            // Convert the strings in the structure. Unfortunately there is
            // potential for overflow because some Unicode chars could convert to
            // double-byte ANSI characters -- but the strings in the ANSI structure
            // are sized in *bytes* (not double-byte *characters*).
            //
            i = WideCharToMultiByte(
                    CP_ACP,
                    0,
                    UnicodeDrvInfoData->Description,
                    sizeof(UnicodeDrvInfoData->Description) / sizeof(WCHAR),
                    AnsiDescription,
                    sizeof(AnsiDescription),
                    NULL,
                    NULL
                    );

            if(i) {

                i = WideCharToMultiByte(
                        CP_ACP,
                        0,
                        UnicodeDrvInfoData->MfgName,
                        sizeof(UnicodeDrvInfoData->MfgName) / sizeof(WCHAR),
                        AnsiMfgName,
                        sizeof(AnsiMfgName),
                        NULL,
                        NULL
                        );

                if(i) {

                    i = WideCharToMultiByte(
                            CP_ACP,
                            0,
                            UnicodeDrvInfoData->ProviderName,
                            sizeof(UnicodeDrvInfoData->ProviderName) / sizeof(WCHAR),
                            AnsiProviderName,
                            sizeof(AnsiProviderName),
                            NULL,
                            NULL
                            );

                    if(i) {
                        //
                        // Copy converted strings into caller's structure, limiting
                        // lengths to avoid overflow. If any lstrcpynA call returns NULL
                        // then it faulted meaning a pointer is bad.
                        //
                        #undef CPYANS
                        #define CPYANS(field) lstrcpynA(AnsiDrvInfoData->field,Ansi##field,sizeof(AnsiDrvInfoData->field))

                        if(!CPYANS(Description) || !CPYANS(MfgName) || !CPYANS(ProviderName)) {
                            rc = ERROR_INVALID_PARAMETER;
                        } else {
                            //
                            // Successfully converted/transferred all the
                            // unicode strings back to ANSI.  Now, set the
                            // final two fields (DriverDate and DriverVersion)
                            // unless the caller supplied us with a version 1
                            // structure.
                            //
                            if(AnsiDrvInfoData->cbSize == sizeof(SP_DRVINFO_DATA_A)) {
                                AnsiDrvInfoData->DriverDate = UnicodeDrvInfoData->DriverDate;
                                AnsiDrvInfoData->DriverVersion = UnicodeDrvInfoData->DriverVersion;
                            }
                        }
                    } else {
                        rc = GetLastError();
                    }
                } else {
                    rc = GetLastError();
                }
            } else {
                rc = GetLastError();
            }
        } else {
            rc = ERROR_INVALID_USER_BUFFER;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    return(rc);
}


DWORD
pSetupDiDevInfoSetDetailDataUnicodeToAnsi(
    IN  PSP_DEVINFO_LIST_DETAIL_DATA_W UnicodeDevInfoSetDetails,
    OUT PSP_DEVINFO_LIST_DETAIL_DATA_A AnsiDevInfoSetDetails
    )

/*++

Routine Description:

    This routine converts an SP_DEVINFO_LIST_DETAIL_DATA_W structure
    to an SP_DEVINFO_LIST_DETAIL_DATA_A, guarding against bogus pointers
    passed in the by the caller.

Arguments:

    UnicodeDevInfoSetDetails - supplies Unicode structure to be converted
        to ANSI.

    AnsiDevInfoSetDetails - if successful, receives Ansi equivalent of
        UnicodeDevInfoSetDetails.

Return Value:

    NO_ERROR                - conversion successful.
    ERROR_INVALID_PARAMETER - one of the arguments was not a valid pointer.

    Unicode chars that can't be represented in the current system ANSI codepage
    will be replaced with a system default in the ANSI structure.

--*/

{
    int i;
    DWORD rc;
    UCHAR AnsiRemoteMachineName[SP_MAX_MACHINENAME_LENGTH * 2];
    PVOID p;

    MYASSERT(UnicodeDevInfoSetDetails->cbSize == sizeof(SP_DEVINFO_LIST_DETAIL_DATA_W));

    rc = NO_ERROR;

    try {

        if(AnsiDevInfoSetDetails->cbSize == sizeof(SP_DEVINFO_LIST_DETAIL_DATA_A)) {
            //
            // Fixed part of structure.
            //
            MYASSERT(offsetof(SP_DEVINFO_LIST_DETAIL_DATA_A, RemoteMachineName) ==
                     offsetof(SP_DEVINFO_LIST_DETAIL_DATA_W, RemoteMachineName)
                    );

            CopyMemory(AnsiDevInfoSetDetails,
                       UnicodeDevInfoSetDetails,
                       offsetof(SP_DEVINFO_LIST_DETAIL_DATA_W, RemoteMachineName)
                      );

            AnsiDevInfoSetDetails->cbSize = sizeof(SP_DEVINFO_LIST_DETAIL_DATA_A);

            //
            // Convert the strings in the structure. Unfortunately there is
            // potential for overflow because some Unicode chars could convert to
            // double-byte ANSI characters -- but the strings in the ANSI structure
            // are sized in *bytes* (not double-byte *characters*).
            //
            i = WideCharToMultiByte(CP_ACP,
                                    0,
                                    UnicodeDevInfoSetDetails->RemoteMachineName,
                                    SIZECHARS(UnicodeDevInfoSetDetails->RemoteMachineName),
                                    AnsiRemoteMachineName,
                                    sizeof(AnsiRemoteMachineName),
                                    NULL,
                                    NULL
                                   );

            if(i) {
                //
                // Copy converted string into caller's structure, limiting
                // lengths to avoid overflow. If any lstrcpynA call returns NULL
                // then it faulted meaning a pointer is bad.
                //
                if(!lstrcpynA(AnsiDevInfoSetDetails->RemoteMachineName,
                              AnsiRemoteMachineName,
                              sizeof(AnsiDevInfoSetDetails->RemoteMachineName))) {

                    rc = ERROR_INVALID_PARAMETER;
                }
            } else {
                rc = GetLastError();
            }
        } else {
            rc = ERROR_INVALID_USER_BUFFER;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    return rc;
}

#endif // def UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\devwiz.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devwiz.c

Abstract:

    Device Installer functions for install wizard support.

Author:

    Lonny McMichael (lonnym) 22-Sep-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Define some macros to make the code a little cleaner.
//

//
// BOOL
// USE_CI_SELSTRINGS(
//     IN PDEVINSTALL_PARAM_BLOCK p
//     );
//
// This macro checks all the appropriate values to determine whether the
// class-installer provided strings may be used in the wizard.
//
#define USE_CI_SELSTRINGS(p)                                                \
                                                                            \
    (((((p)->Flags) & (DI_USECI_SELECTSTRINGS | DI_CLASSINSTALLPARAMS)) ==  \
      (DI_USECI_SELECTSTRINGS | DI_CLASSINSTALLPARAMS)) &&                  \
     (((p)->ClassInstallHeader->InstallFunction) == DIF_SELECTDEVICE))

//
// PTSTR
// GET_CI_SELSTRING(
//     IN PDEVINSTALL_PARAM_BLOCK p,
//     IN <FieldName>             f
//     );
//
// This macro retrieves a pointer to the specified string in a
// SP_SELECTDEVICE_PARAMS structure.
//
#define GET_CI_SELSTRINGS(p, f)                                             \
                                                                            \
    (((PSP_SELECTDEVICE_PARAMS)((p)->ClassInstallHeader))->f)

//
// Definitions for timer used in device selection listboxes.
//
#define SELECTMFG_TIMER_ID              1
#define SELECTMFG_TIMER_DELAY           250

//
// Define a message sent from our auxilliary class driver search thread.
//
#define WMX_CLASSDRVLIST_DONE    (WM_USER+131)
#define WMX_NO_DRIVERS_IN_LIST   (WM_USER+132)

//
// HELP ID's
//
static const DWORD SelectDeviceShowAllHelpIDs[]=
{
    IDC_NDW_PICKDEV_MFGLIST,            IDH_DEVMGR_SELECTDEVICE_MANUFACTURER,
    IDC_NDW_PICKDEV_ONEMFG_DRVLIST,     IDH_DEVMGR_SELECTDEVICE_MODEL,
    IDC_NDW_PICKDEV_DRVLIST,            IDH_DEVMGR_SELECTDEVICE_MODEL,
    IDC_NDW_STATUS_TEXT,                IDH_NOHELP,
    IDC_CLASSICON,                      IDH_NOHELP,
    IDC_NDW_PICKDEV_COMPAT,             IDH_DEVMGR_SELECTDEVICE_SHOWCOMPATIBLE,
    IDC_NDW_PICKDEV_WINDOWSUPDATE,      IDH_DEVMGR_SELECTDEVICE_WINDOWSUPDATE,
    IDC_NDW_PICKDEV_HAVEDISK,           IDH_DEVMGR_SELECTDEVICE_HAVEDISK,
    IDC_NDW_TEXT,                       IDH_NOHELP,
    IDD_DEVINSLINE,                     IDH_NOHELP,
    0, 0
};

static const DWORD SelectDeviceShowSimilarHelpIDs[]=
{
    IDC_NDW_PICKDEV_MFGLIST,            IDH_DEVMGR_SELECTDEVICE_MANUFACTURER,
    IDC_NDW_PICKDEV_ONEMFG_DRVLIST,     IDH_DEVMGR_SELECTDEVICE_MODEL,
    IDC_NDW_PICKDEV_DRVLIST,            IDH_DEVMGR_SELECTDEVICE_MODEL,
    IDC_NDW_STATUS_TEXT,                IDH_NOHELP,
    IDC_CLASSICON,                      IDH_NOHELP,
    IDC_NDW_PICKDEV_COMPAT,             IDH_DEVMGR_SELECTDEVICE_SHOWCOMPATIBLE,
    IDC_NDW_PICKDEV_WINDOWSUPDATE,      IDH_DEVMGR_SELECTDEVICE_WINDOWSUPDATE,
    IDC_NDW_PICKDEV_HAVEDISK,           IDH_DEVMGR_SELECTDEVICE_HAVEDISK,
    IDC_NDW_TEXT,                       IDH_NOHELP,
    IDD_DEVINSLINE,                     IDH_NOHELP,
    0, 0
};

#define SELECTDEVICE_HELP TEXT("devmgr.hlp")

//
// Define structure containing class driver search context that is passed to
// an auxilliary thread while a Select Device dialog is displayed.
//
typedef struct _CLASSDRV_THREAD_CONTEXT {

    HDEVINFO        DeviceInfoSet;
    SP_DEVINFO_DATA DeviceInfoData;

    HWND NotificationWindow;

} CLASSDRV_THREAD_CONTEXT, *PCLASSDRV_THREAD_CONTEXT;


//
// Private function prototypes
//
DWORD
pSetupCreateNewDevWizData(
    IN  PSP_INSTALLWIZARD_DATA  InstallWizardData,
    OUT PNEWDEVWIZ_DATA        *NewDeviceWizardData
    );

UINT
CALLBACK
SelectDevicePropSheetPageProc(
    IN HWND hwnd,
    IN UINT uMsg,
    IN LPPROPSHEETPAGE ppsp
    );

INT_PTR
CALLBACK
SelectDeviceDlgProc(
    IN HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

BOOL
InitSelectDeviceDlg(
    IN     HWND hwndDlg,
    IN OUT PNEWDEVWIZ_DATA ndwData
    );

VOID
_OnSysColorChange(
    HWND hWnd,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
OnSetActive(
    IN     HWND            hwndDlg,
    IN OUT PNEWDEVWIZ_DATA ndwData
    );

DWORD
HandleSelectOEM(
    IN     HWND            hwndDlg,
    IN OUT PNEWDEVWIZ_DATA ndwData
    );

DWORD
HandleWindowsUpdate(
    IN     HWND            hwndDlg,
    IN OUT PNEWDEVWIZ_DATA ndwData
    );

DWORD
FillInDeviceList(
    IN HWND           hwndDlg,
    IN PSP_DIALOGDATA lpdd
    );

VOID
ShowListForMfg(
    IN PSP_DIALOGDATA          lpdd,
    IN PDEVICE_INFO_SET        DeviceInfoSet,
    IN PDEVINSTALL_PARAM_BLOCK InstallParamBlock,
    IN PDRIVER_NODE            DriverNode,        OPTIONAL
    IN INT                     iMfg
    );

VOID
LockAndShowListForMfg(
    IN PSP_DIALOGDATA   lpdd,
    IN INT              iMfg
    );

PDRIVER_NODE
GetDriverNodeFromLParam(
    IN PDEVICE_INFO_SET DeviceInfoSet,
    IN PSP_DIALOGDATA   lpdd,
    IN LPARAM           lParam
    );

BOOL
pSetupIsSelectedHardwareIdValid(
    IN HWND           hWnd,
    IN PSP_DIALOGDATA lpdd,
    IN INT            iCur
    );

PDRIVER_NODE
pSetupGetSelectedDriverNode(
    IN HWND           hWnd,
    IN PSP_DIALOGDATA lpdd,
    IN INT            iCur
    );

VOID
SetSelectedDriverNode(
    IN PSP_DIALOGDATA lpdd,
    IN INT            iCur
    );

BOOL
bNoDevsToShow(
    IN PDEVINFO_ELEM DevInfoElem
    );

PNEWDEVWIZ_DATA
GetNewDevWizDataFromPsPage(
    LPPROPSHEETPAGE ppsp
    );

LONG
GetCurDesc(
    IN PSP_DIALOGDATA lpdd
    );

VOID
OnCancel(
    IN PNEWDEVWIZ_DATA ndwData
    );

VOID
__cdecl
ClassDriverSearchThread(
    IN PVOID Context
    );

BOOL
pSetupIsClassDriverListBuilt(
    IN PSP_DIALOGDATA lpdd
    );

VOID
pSetupDevInfoDataFromDialogData(
    IN  PSP_DIALOGDATA   lpdd,
    OUT PSP_DEVINFO_DATA DeviceInfoData
    );

VOID
ToggleDialogControls(
    IN HWND                hwndDlg,
    IN OUT PNEWDEVWIZ_DATA ndwData,
    IN BOOL                Enable
    );

void
CleanupDriverLists(
    IN OUT PNEWDEVWIZ_DATA ndwData
    );

BOOL
CDMIsInternetAvailable(
    void
    );


HPROPSHEETPAGE
WINAPI
SetupDiGetWizardPage(
    IN HDEVINFO               DeviceInfoSet,
    IN PSP_DEVINFO_DATA       DeviceInfoData,    OPTIONAL
    IN PSP_INSTALLWIZARD_DATA InstallWizardData,
    IN DWORD                  PageType,
    IN DWORD                  Flags
    )
/*++

Routine Description:

    This routine retrieves a handle to one of the Setup API-provided wizard
    pages, for an application to include in its own wizard.

Arguments:

    DeviceInfoSet - Supplies the handle of the device information set to
        retrieve a wizard page for.

    DeviceInfoData - Optionally, supplies the address of a device information
        with which the wizard page will be associated.  This parameter is only
        used if the flags parameter includes DIWP_FLAG_USE_DEVINFO_DATA.  If that
        flag is set, and if this parameter is not specified, then the wizard
        page will be associated with the global class driver list.

    InstallWizardData - Supplies the address of a PSP_INSTALLWIZARD_DATA
        structure containing parameters to be used by this wizard page.  The
        cbSize field must be set to the size of the structure, in bytes, or the
        structure will be considered invalid.

    PageType - Supplies an ordinal indicating the type of wizard page to be retreived.
        May be one of the following values:

        SPWPT_SELECTDEVICE - Retrieve a select device wizard page.

    Flags - Supplies flags that specify how the wizard page is to be created.
        May be a combination of the following values:

        SPWP_USE_DEVINFO_DATA - Use the device information element specified
                                by DeviceInfoData, or use the global class
                                driver list if DeviceInfoData is not supplied.
                                If this flag is not supplied, the wizard page
                                will act upon the currently selected device
                                (as selected by SetupDiSetSelectedDevice), or
                                upon the global class driver list if no device
                                is selected.

Return Value:

    If the function succeeds, the return value is the handle to the requested
    wizard page.

    If the function fails, the return value is NULL.  To get extended error
    information, call GetLastError.

Remarks:

    A device information set may not be destroyed as long as there are any active wizard
    pages using it.  In addition, if the wizard page is associated with a particular device
    information element, then that element will not be deletable as long as it is being
    used by a wizard page.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    DWORD Err = NO_ERROR;
    HPROPSHEETPAGE hPage = NULL;
    PNEWDEVWIZ_DATA ndwData = NULL;
    PWIZPAGE_OBJECT WizPageObject = NULL;
    //
    // Store the address of the corresponding wizard object at the
    // end of the PROPSHEETPAGE buffer.
    //
    BYTE pspBuffer[sizeof(PROPSHEETPAGE) + sizeof(PVOID)];
    LPPROPSHEETPAGE Page = (LPPROPSHEETPAGE)pspBuffer;

    //
    // Make sure we're running interactively.
    //
    if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
        SetLastError(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION);
        return FALSE;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    try {

        switch(PageType) {

            case SPWPT_SELECTDEVICE :

                Page->pszTemplate = MAKEINTRESOURCE(IDD_DYNAWIZ_SELECTDEV_PAGE);
                Page->pfnDlgProc = SelectDeviceDlgProc;
                Page->pfnCallback = SelectDevicePropSheetPageProc;

#ifndef ANSI_SETUPAPI
                Page->pszHeaderTitle = MAKEINTRESOURCE(IDS_NDW_SELECTDEVICE);
                Page->pszHeaderSubTitle = NULL;
#endif

                break;

            default :
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
        }

        //
        // Validate the supplied InstallWizardData structure, and create a private
        // storage buffer for internal use by the wizard page.
        //
        if((Err = pSetupCreateNewDevWizData(InstallWizardData, &ndwData)) != NO_ERROR) {
            goto clean0;
        }

        //
        // Store the device information set handle in the dialogdata structure
        // embedded in the New Device Wizard buffer.
        //
        ndwData->ddData.DevInfoSet = DeviceInfoSet;

        //
        // If the caller specified the SPWP_USE_DEVINFO_DATA flag, then store information
        // in the dialog data structure about the specified devinfo element (if supplied).
        //
        if(Flags & SPWP_USE_DEVINFO_DATA) {
            if(DeviceInfoData) {
                //
                // Verify that the specified device information element is a valid one.
                //
                if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                             DeviceInfoData,
                                                             NULL))) {
                    Err = ERROR_INVALID_PARAMETER;
                    goto clean0;

                } else if(DevInfoElem->DiElemFlags & DIE_IS_LOCKED) {
                    //
                    // Device information element cannot be explicitly used by more than
                    // one wizard page at a time.
                    //
                    Err = ERROR_DEVINFO_DATA_LOCKED;
                    goto clean0;
                }

                DevInfoElem->DiElemFlags |= DIE_IS_LOCKED;
                ndwData->ddData.DevInfoElem = DevInfoElem;
            }
            ndwData->ddData.flags = DD_FLAG_USE_DEVINFO_ELEM;
        }

        //
        // We've successfully created and initialized the devwiz data structure.
        // Now create a wizpage object so we can keep track of it.
        //
        if(WizPageObject = MyMalloc(sizeof(WIZPAGE_OBJECT))) {
            WizPageObject->RefCount = 0;
            WizPageObject->ndwData = ndwData;
            //
            // Insert this new object into the devinfo set's wizard object list.
            //
            WizPageObject->Next = pDeviceInfoSet->WizPageList;
            pDeviceInfoSet->WizPageList = WizPageObject;

        } else {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        Page->dwSize = sizeof(pspBuffer);

#ifndef ANSI_SETUPAPI
        Page->dwFlags = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE | PSP_USECALLBACK | PSP_USEFUSIONCONTEXT;
        Page->hActCtx = NULL;
#else
        Page->dwFlags = PSP_DEFAULT | PSP_USECALLBACK;
#endif

        Page->hInstance = MyDllModuleHandle;

        Page->lParam = (LPARAM)DeviceInfoSet;

        *((PVOID *)(&(pspBuffer[sizeof(PROPSHEETPAGE)]))) = WizPageObject;

        if(!(hPage = CreatePropertySheetPage(Page))) {
            Err = ERROR_INVALID_DATA;
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    if(Err != NO_ERROR) {
        if(ndwData) {
            MyFree(ndwData);
        }
        if(WizPageObject) {
            MyFree(WizPageObject);
        }
    }

    SetLastError(Err);
    return hPage;
}


BOOL
WINAPI
SetupDiGetSelectedDevice(
    IN  HDEVINFO          DeviceInfoSet,
    OUT PSP_DEVINFO_DATA  DeviceInfoData
    )
/*++

Routine Description:

    This routine retrieves the currently-selected device for the specified
    device information set.  This is typically used during an installation
    wizard.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set for
        which the selected device is to be retrieved.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure
        that receives the currently-selected device.  If there is no device
        currently selected, then the routine will fail, and GetLastError
        will return ERROR_NO_DEVICE_SELECTED.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        if(pDeviceInfoSet->SelectedDevInfoElem) {

            if(!(DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                                  pDeviceInfoSet->SelectedDevInfoElem,
                                                  DeviceInfoData))) {
                Err = ERROR_INVALID_USER_BUFFER;
            }

        } else {
            Err = ERROR_NO_DEVICE_SELECTED;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiSetSelectedDevice(
    IN HDEVINFO          DeviceInfoSet,
    IN PSP_DEVINFO_DATA  DeviceInfoData
    )
/*++

Routine Description:

    This routine sets the specified device information element to be the
    currently selected member of a device information set.  This is typically
    used during an installation wizard.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set for
        which the selected device is to be set.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure
        specifying the device information element to be selected.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        if(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet, DeviceInfoData, NULL)) {
            pDeviceInfoSet->SelectedDevInfoElem = DevInfoElem;
        } else {
            Err = ERROR_INVALID_PARAMETER;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


DWORD
pSetupCreateNewDevWizData(
    IN  PSP_INSTALLWIZARD_DATA  InstallWizardData,
    OUT PNEWDEVWIZ_DATA        *NewDeviceWizardData
    )
/*++

Routine Description:

    This routine validates an InstallWizardData buffer, then allocates and
    fills in a NEWDEVWIZ_DATA buffer based on information supplied therein.

Arguments:

    InstallWizardData - Supplies the address of an installation wizard data
        structure to be validated and used in building the private buffer.

    NewDeviceWizardData - Supplies the address of a variable that receives a pointer
        to the newly-allocated install wizard data buffer.

Return Value:

    If the function succeeds, the return value is NO_ERROR, otherwise, it is
    an ERROR_* code.

--*/
{
    PNEWDEVWIZ_DATA ndwData = NULL;
    DWORD Err = NO_ERROR;

    if((InstallWizardData->ClassInstallHeader.cbSize != sizeof(SP_CLASSINSTALL_HEADER)) ||
       (InstallWizardData->ClassInstallHeader.InstallFunction != DIF_INSTALLWIZARD)) {

        return ERROR_INVALID_USER_BUFFER;
    }

    //
    // The dynamic page entries are currently ignored, as are the Private
    // fields.  Also, the hwndWizardDlg is not validated.
    //

    try {

        if(ndwData = MyMalloc(sizeof(NEWDEVWIZ_DATA))) {
            ZeroMemory(ndwData, sizeof(NEWDEVWIZ_DATA));
        } else {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        //
        // Initialize the Current Description string table index in the dialog data
        // to -1, so that it will get updated when the wizard page is first entered.
        //
        ndwData->ddData.iCurDesc = -1;

        //
        // Copy the installwizard data.
        //
        CopyMemory(&(ndwData->InstallData),
                   InstallWizardData,
                   sizeof(SP_INSTALLWIZARD_DATA)
                  );

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    if((Err != NO_ERROR) && ndwData) {
        MyFree(ndwData);
    } else {
        *NewDeviceWizardData = ndwData;
    }

    return Err;
}


UINT
CALLBACK
SelectDevicePropSheetPageProc(
    IN HWND hwnd,
    IN UINT uMsg,
    IN LPPROPSHEETPAGE ppsp
    )
/*++

Routine Description:

    This routine is called when the Select Device wizard page is created or destroyed.

Arguments:

    hwnd - Reserved

    uMsg - Action flag, either PSPCB_CREATE or PSPCB_RELEASE

    ppsp - Supplies the address of the PROPSHEETPAGE structure being created or destroyed.

Return Value:

    If uMsg is PSPCB_CREATE, then return non-zero to allow the page to be created, or
    zero to prevent it.

    if uMsg is PSPCB_RELEASE, the return value is ignored.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    UINT ret;
    PVOID WizObjectId;
    PWIZPAGE_OBJECT CurWizObject, PrevWizObject;

    //
    // Access the device info set handle stored in the propsheetpage's lParam.
    //
    if(!(pDeviceInfoSet = AccessDeviceInfoSet((HDEVINFO)(ppsp->lParam)))) {
        return FALSE;
    }

    ret = TRUE;

    try {
        //
        // The ObjectID (pointer, actually) for the corresponding wizard
        // object for this page is stored at the end of the ppsp structure.
        // Retrieve this now, and look for it in the devinfo set's list of
        // wizard objects.
        //
        WizObjectId = *((PVOID *)(&(((PBYTE)ppsp)[sizeof(PROPSHEETPAGE)])));

        for(CurWizObject = pDeviceInfoSet->WizPageList, PrevWizObject = NULL;
            CurWizObject;
            PrevWizObject = CurWizObject, CurWizObject = CurWizObject->Next) {

            if(WizObjectId == CurWizObject) {
                //
                // We found our object.
                //
                break;
            }
        }

        if(!CurWizObject) {
            ret = FALSE;
            goto clean0;
        }

        switch(uMsg) {

            case PSPCB_CREATE :
                //
                // Fail the create if we've already been created once (hopefully, this
                // will never happen).
                //
                if(CurWizObject->RefCount) {
                    ret = FALSE;
                    goto clean0;
                } else {
                    CurWizObject->RefCount++;
                }
                break;

            case PSPCB_RELEASE :
                //
                // Decrement the wizard object refcount.  If it goes to zero (or if it
                // already was zero because we never got a PSPCB_CREATE message), then
                // remove the object from the linked list, and free all associated memory.
                //
                if(CurWizObject->RefCount) {
                    CurWizObject->RefCount--;
                }

                MYASSERT(!CurWizObject->RefCount);

                if(!CurWizObject->RefCount) {
                    //
                    // Remove the object from the object list.
                    //
                    if(PrevWizObject) {
                        PrevWizObject->Next = CurWizObject->Next;
                    } else {
                        pDeviceInfoSet->WizPageList = CurWizObject->Next;
                    }

                    //
                    // If this wizard object was explicitly tied to a particular device
                    // information element, then unlock that element now.
                    //
                    if((CurWizObject->ndwData->ddData.flags & DD_FLAG_USE_DEVINFO_ELEM) &&
                       (DevInfoElem = CurWizObject->ndwData->ddData.DevInfoElem)) {

                        MYASSERT(DevInfoElem->DiElemFlags & DIE_IS_LOCKED);

                        DevInfoElem->DiElemFlags ^= DIE_IS_LOCKED;
                    }

                    MyFree(CurWizObject->ndwData);
                    MyFree(CurWizObject);
                }
        }

clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        ret = FALSE;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    return ret;
}


INT_PTR
CALLBACK
SelectDeviceDlgProc(
    IN HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    This is the dialog proc for the Select Device wizard page.

--*/
{
    INT iCur;
    HICON hicon;
    PNEWDEVWIZ_DATA ndwData;
    PSP_INSTALLWIZARD_DATA iwd;
    LV_ITEM lvItem;
    TCHAR TempString[LINE_LEN];
    PCLASSDRV_THREAD_CONTEXT ClassDrvThreadContext;
    HCURSOR hOldCursor;

    if(uMsg == WM_INITDIALOG) {

        LPPROPSHEETPAGE Page = (LPPROPSHEETPAGE)lParam;

        //
        // Retrieve a pointer to the device wizard data associated with
        // this wizard page.
        //
        ndwData = GetNewDevWizDataFromPsPage(Page);
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)ndwData);

        if(ndwData) {
            ndwData->bInit = TRUE;
            ndwData->idTimer = 0;
            ndwData->bInit = FALSE;
        } else {
            //
            // This is really bad--we can't simply call EndDialog() since we
            // don't know whether we're a dialog or a wizard page.  This should
            // never happen.
            //
            return TRUE;  // we didn't set the focus
        }

        if(ndwData->ddData.flags & DD_FLAG_IS_DIALOGBOX) {
            //
            // For the stand-alone dialog box version, we initialize here.
            //
            ndwData->bInit = TRUE;       // Still doing some init stuff

            //
            // Make sure our "waiting for class list" static text control is hidden!
            //
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_STATUS_TEXT), SW_HIDE);

            if (!InitSelectDeviceDlg(hwndDlg, ndwData)) {

                //
                // We don't have any items displayed so ask the user if they want
                // to go directly to Have Disk, or just cancel.
                //
                PostMessage(hwndDlg, WMX_NO_DRIVERS_IN_LIST, 0, 0);
            }

            ndwData->bInit = FALSE;      // Done with init stuff

            return FALSE;   // we already set the focus.

        } else {
            return TRUE;    // we didn't set the focus
        }

    } else {
        //
        // For the small set of messages that we get before WM_INITDIALOG, we
        // won't have a devwizdata pointer!
        //
        if(ndwData = (PNEWDEVWIZ_DATA)GetWindowLongPtr(hwndDlg, DWLP_USER)) {
            iwd = &(ndwData->InstallData);
        } else {
            //
            // If we haven't gotten a WM_INITDIALOG message yet, or if for some reason
            // we weren't able to retrieve the ndwData pointer when we did, then we
            // simply return FALSE for all messages.
            //
            // (If we ever need to process messages before WM_INITDIALOG (e.g., set font),
            // then we'll need to modify this approach.)
            //
            return FALSE;
        }
    }

    switch(uMsg) {

        case WMX_CLASSDRVLIST_DONE :

            MYASSERT(ndwData->ddData.AuxThreadRunning);
            ndwData->ddData.AuxThreadRunning = FALSE;

            //
            // wParam is a boolean indicating the result of the class driver search.
            // lParam is NO_ERROR upon success, or a Win32 error code indicating cause of failure.
            //
            switch(ndwData->ddData.PendingAction) {

                case PENDING_ACTION_NONE :
                    //
                    // Then the thread has completed, but the user is still mulling over the
                    // choices on the compatible driver list.  If the class driver list was
                    // successfully built, then there's nothing to do here.  If it failed for
                    // some reason (highly unlikely), then we (silently) disable the
                    // 'show compatible devices' check box.
                    if(!wParam) {
                        ndwData->ddData.flags |= DD_FLAG_CLASSLIST_FAILED;
                        EnableWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_COMPAT), FALSE);
                    }
                    break;

                case PENDING_ACTION_SELDONE :
                    //
                    // In this case, we don't care what happened in the other thread.  The
                    // user has made their selection, and we're ready to return success.
                    //
                    SetSelectedDriverNode(&(ndwData->ddData),
                                          ndwData->ddData.CurSelectionForSuccess
                                         );
                    EndDialog(hwndDlg, NO_ERROR);
                    break;

                case PENDING_ACTION_SHOWCLASS :
                    //
                    // Then we've been waiting on the class driver search to complete, so that
                    // we can show the list.  Hopefully, the search was successful.  If not,
                    // we'll give the user a popup saying that the list could not be shown, and
                    // then leave them in the compatible list view (with the class list radio
                    // button now disabled).
                    //
                    ndwData->ddData.PendingAction = PENDING_ACTION_NONE;

                    if(wParam) {
                        //
                        // The class driver list was built successfully.
                        //
                        if(ndwData->ddData.CurSelectionForSuccess != LB_ERR) {

                            lvItem.mask = LVIF_TEXT;
                            lvItem.iItem = ndwData->ddData.CurSelectionForSuccess;
                            lvItem.iSubItem = 0;
                            lvItem.pszText = TempString;
                            lvItem.cchTextMax = SIZECHARS(TempString);

                            if(ListView_GetItem((ndwData->ddData).hwndDrvList, &lvItem)) {
                                //
                                // Now retrieve the (case-insensitive) string ID of this
                                // string, and store it as the current description ID.
                                //
                                (ndwData->ddData).iCurDesc = LookUpStringInDevInfoSet((ndwData->ddData).DevInfoSet,
                                                                                      TempString,
                                                                                      FALSE
                                                                                     );
                            }
                        }

                        ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_STATUS_TEXT), SW_HIDE);

                        if(FillInDeviceList(hwndDlg, &(ndwData->ddData)) == NO_ERROR) {
                            //
                            // Enable the OK/Next button
                            //
                            if(ndwData->ddData.flags & DD_FLAG_IS_DIALOGBOX) {
                                EnableWindow(GetDlgItem(hwndDlg, IDOK), TRUE);
                            } else {
                                if(((ndwData->InstallData).Flags & NDW_INSTALLFLAG_SKIPCLASSLIST) &&
                                   ((ndwData->InstallData).Flags & NDW_INSTALLFLAG_EXPRESSINTRO) &&
                                   !((ndwData->InstallData).DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED)) {
                                    //
                                    // No back if we skipped the Class list, and are in express mode
                                    //
                                    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);
                                } else {
                                    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
                                }
                            }

                            break;
                        }
                    }

                    //
                    // Inform the user that the class driver search failed.
                    //
                    if(!LoadString(MyDllModuleHandle,
                                   IDS_SELECT_DEVICE,
                                   TempString,
                                   SIZECHARS(TempString))) {
                        *TempString = TEXT('\0');
                    }

                    FormatMessageBox(MyDllModuleHandle,
                                     hwndDlg,
                                     MSG_NO_CLASSDRVLIST_ERROR,
                                     TempString,
                                     MB_OK | MB_TASKMODAL
                                    );

                    //
                    // Check the 'Show compatible devices' check box and then gray
                    // it out since the user cannot uncheck it since we don't have
                    // a class list.
                    //
                    CheckDlgButton(hwndDlg, IDC_NDW_PICKDEV_COMPAT, BST_CHECKED);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_COMPAT), FALSE);
                    ndwData->ddData.bShowCompat = TRUE;
                    ndwData->ddData.flags |= DD_FLAG_CLASSLIST_FAILED;

                    //
                    // We also must unhide the compatible driver list controls, and re-enable
                    // the OK button.
                    //
                    ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_STATUS_TEXT), SW_HIDE);
                    ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST), SW_SHOW);
                    if(ndwData->ddData.flags & DD_FLAG_IS_DIALOGBOX) {
                        EnableWindow(GetDlgItem(hwndDlg, IDOK), TRUE);
                    } else {
                        if(((ndwData->InstallData).Flags & NDW_INSTALLFLAG_SKIPCLASSLIST) &&
                           ((ndwData->InstallData).Flags & NDW_INSTALLFLAG_EXPRESSINTRO) &&
                           !((ndwData->InstallData).DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED)) {
                            //
                            // No back if we skipped the Class list, and are in express mode
                            //
                            PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);
                        } else {
                            PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
                        }
                    }

                    break;

                case PENDING_ACTION_CANCEL :
                    //
                    // This is an easy one.  No matter what happened in the other thread,
                    // we simply want to clean up and return.
                    //
                    OnCancel(ndwData);
                    EndDialog(hwndDlg, ERROR_CANCELLED);
                    break;

                case PENDING_ACTION_OEM :
                case PENDING_ACTION_WINDOWSUPDATE:
                    //
                    // The user clicked the "Have Disk" button or the "Windows Update" button.
                    // Pass this off to either HandleSelectOEM() or HandleWindowsUpdate().
                    // If we get back success, then we are done, and can end the dialog.
                    //
                    if(((ndwData->ddData.PendingAction == PENDING_ACTION_OEM) &&
                        (HandleSelectOEM(hwndDlg, ndwData) == NO_ERROR)) ||
                       ((ndwData->ddData.PendingAction == PENDING_ACTION_WINDOWSUPDATE) &&
                        (HandleWindowsUpdate(hwndDlg, ndwData) == NO_ERROR))) {

                        ndwData->ddData.PendingAction = PENDING_ACTION_NONE;

                        if(ndwData->ddData.flags & DD_FLAG_IS_DIALOGBOX) {
                            EndDialog(hwndDlg, NO_ERROR);
                        } else {
                            iwd->Flags |= NDW_INSTALLFLAG_CI_PICKED_OEM;
                            PropSheet_PressButton(GetParent(hwndDlg), PSBTN_NEXT);
                        }

                    } else {
                        //
                        // The OEM selection was not made, so we'll just continue as though
                        // nothing had happened.  Re-enable the dialog/wizard controls.
                        //
                        ToggleDialogControls(hwndDlg, ndwData, TRUE);

                        if (ndwData->ddData.bShowCompat) {
                            ndwData->ddData.PendingAction = PENDING_ACTION_NONE;
                        } else {
                            ndwData->ddData.PendingAction = PENDING_ACTION_SHOWCLASS;
                        }

                        ndwData->bInit = FALSE;

                        //
                        // We got here by aborting the class driver search.  Since we may need
                        // it after all, we must re-start the search (unless the auxilliary thread
                        // happened to have already finished before we sent it the abort request).
                        //
                        if(!(ndwData->ddData.flags & DD_FLAG_CLASSLIST_FAILED) &&
                           !pSetupIsClassDriverListBuilt(&(ndwData->ddData)))
                        {
                            //
                            // Allocate a context structure to pass to the auxilliary thread (the
                            // auxilliary thread will take care of freeing the memory).
                            //
                            if(ClassDrvThreadContext = MyMalloc(sizeof(CLASSDRV_THREAD_CONTEXT))) {
                                //
                                // Fill in the context structure, and fire off the thread.
                                //
                                ClassDrvThreadContext->DeviceInfoSet = ndwData->ddData.DevInfoSet;

                                //
                                // SP_DEVINFO_DATA can only be retrieved whilst the device information
                                // set is locked.
                                //
                                pSetupDevInfoDataFromDialogData(&(ndwData->ddData),
                                                                &(ClassDrvThreadContext->DeviceInfoData)
                                                               );

                                ClassDrvThreadContext->NotificationWindow = hwndDlg;

                                if(_beginthread(ClassDriverSearchThread, 0, ClassDrvThreadContext) == -1) {
                                    MyFree(ClassDrvThreadContext);
                                } else {

                                    ndwData->ddData.AuxThreadRunning = TRUE;


                                    //
                                    // If we're currently in the class driver list view, then disable
                                    // the OK/Next button, since the user can't select a class driver yet.
                                    //
                                    if (!ndwData->ddData.bShowCompat) {
                                        if(ndwData->ddData.flags & DD_FLAG_IS_DIALOGBOX) {
                                            EnableWindow(GetDlgItem(hwndDlg, IDOK), FALSE);
                                        } else {
                                            if(((ndwData->InstallData).Flags & NDW_INSTALLFLAG_SKIPCLASSLIST) &&
                                               ((ndwData->InstallData).Flags & NDW_INSTALLFLAG_EXPRESSINTRO) &&
                                               !((ndwData->InstallData).DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED)) {
                                                //
                                                // No back if we skipped the Class list, and are in express mode
                                                //
                                                PropSheet_SetWizButtons(GetParent(hwndDlg), 0);
                                            } else {
                                                PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
                                            }
                                        }
                                    }
                                }
                            }

                            if(!(ndwData->ddData.AuxThreadRunning)) {
                                //
                                // We couldn't start the class driver search thread.
                                // check and disable the 'Show compatible devices'
                                // check box.
                                //
                                if (!ndwData->ddData.bShowCompat) {
                                    CheckDlgButton(hwndDlg,
                                                   IDC_NDW_PICKDEV_COMPAT,
                                                   BST_CHECKED
                                                   );
                                }

                                ndwData->ddData.flags |= DD_FLAG_CLASSLIST_FAILED;
                                EnableWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_COMPAT), FALSE);
                            }
                        }
                    }

                    break;
            }

            break;

        case WMX_NO_DRIVERS_IN_LIST: {

            TCHAR Title[LINE_LEN];

            if(!LoadString(MyDllModuleHandle, IDS_SELECT_DEVICE, Title, SIZECHARS(Title))) {
                Title[0]=TEXT('\0');
            }
            if(!LoadString(MyDllModuleHandle, IDS_NDW_NODRIVERS_WARNING, TempString, SIZECHARS(TempString))) {
                TempString[0]=TEXT('\0');
            }

            if (IDOK == MessageBox(hwndDlg, TempString, Title, MB_OKCANCEL | MB_ICONEXCLAMATION)) {

                PostMessage(hwndDlg, WM_COMMAND, IDC_NDW_PICKDEV_HAVEDISK, 0);
            } else {

                PostMessage(hwndDlg, WM_COMMAND, IDCANCEL, 0);
            }

            break;
        }

        case WM_DESTROY:

            if(ndwData->ddData.AuxThreadRunning) {
                //
                // This should never happen.  But just to be on the safe side, if it does,
                // we'll cancel the search.  We _will not_ however, wait for the
                // WMX_CLASSDRVLIST_DONE message, to signal that the thread has terminated.
                // This should be OK, since the worst that can happen is that it will try
                // to send a message to a window that no longer exists.
                //
                SetupDiCancelDriverInfoSearch(ndwData->ddData.DevInfoSet);
            }

            if(ndwData->idTimer) {
                ndwData->bInit = TRUE;
                KillTimer(hwndDlg, SELECTMFG_TIMER_ID);
            }

            if(hicon = (HICON)SendDlgItemMessage(hwndDlg, IDC_CLASSICON, STM_GETICON, 0, 0)) {
                DestroyIcon(hicon);
            }

            if(hicon = (HICON)SendDlgItemMessage(hwndDlg, IDC_NDW_PICKDEV_SIGNED_ICON, STM_GETICON, 0, 0)) {
                DestroyIcon(hicon);
            }

            if (ndwData->ddData.hImageList) {
                ImageList_Destroy(ndwData->ddData.hImageList);
            }

            if (ndwData->ddData.hFontNormal) {
                DeleteObject(ndwData->ddData.hFontNormal);
            }

            if (ndwData->ddData.hFontBold) {
                DeleteObject(ndwData->ddData.hFontBold);
            }
            break;

        case WM_COMMAND:

            switch(LOWORD(wParam)) {

                case IDC_NDW_PICKDEV_COMPAT:

                    if((HIWORD(wParam) == BN_CLICKED) &&
                       IsWindowVisible(GetDlgItem(hwndDlg, LOWORD(wParam)))) {

                        ndwData->ddData.bShowCompat = IsDlgButtonChecked(hwndDlg, IDC_NDW_PICKDEV_COMPAT);

                        //
                        // Update the current description ID in the dialog data so that
                        // the same device will be highlighted when we switch from one
                        // view to the other.
                        //
                        iCur = (int)ListView_GetNextItem((ndwData->ddData).hwndDrvList,
                                                         -1,
                                                         LVNI_SELECTED
                                                        );

                        if(ndwData->ddData.AuxThreadRunning) {
                            //
                            // There are two possibilities here:
                            //
                            // 1. The user was looking at the compatible driver list, and then
                            //    decided to look at the class driver list, which we're not done
                            //    building yet.  In that case, hide the compatible driver listbox,
                            //    and unhide our "waiting for class list" static text control.
                            //
                            // 2. The user switched to the class driver list view, saw that we
                            //    were still working on it, and then decided to switch back to
                            //    the compatible list.  In that case, we simply need to re-hide
                            //    the "waiting for class list" static text control, and show
                            //    the compatible driver listbox again.  In this case, we don't
                            //    want to attempt to re-initialize the listbox, as that will
                            //    require acquiring the HDEVINFO lock, and we will hang.
                            //
                            if(ndwData->ddData.bShowCompat) {

                                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_STATUS_TEXT), SW_HIDE);
                                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST), SW_SHOW);
                                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_ICON), SW_SHOW);
                                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_TEXT), SW_SHOW);
                                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_LINK), SW_SHOW);
                                if(ndwData->ddData.flags & DD_FLAG_IS_DIALOGBOX) {
                                    EnableWindow(GetDlgItem(hwndDlg, IDOK), TRUE);
                                } else {
                                    if(((ndwData->InstallData).Flags & NDW_INSTALLFLAG_SKIPCLASSLIST) &&
                                       ((ndwData->InstallData).Flags & NDW_INSTALLFLAG_EXPRESSINTRO) &&
                                       !((ndwData->InstallData).DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED)) {
                                        //
                                        // No back if we skipped the Class list, and are in express mode
                                        //
                                        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);
                                    } else {
                                        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
                                    }
                                }

                                //
                                // We no longer have a pending action.
                                //
                                ndwData->ddData.PendingAction = PENDING_ACTION_NONE;

                            } else {
                                //
                                // Temporarily hide the compatible driver listbox, and unhide the
                                // "waiting for class list" static text control.
                                //
                                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST), SW_HIDE);
                                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_ICON), SW_HIDE);
                                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_TEXT), SW_HIDE);
                                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_LINK), SW_HIDE);
                                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_STATUS_TEXT), SW_SHOW);

                                if(!LoadString(MyDllModuleHandle, IDS_NDW_RETRIEVING_LIST, TempString, SIZECHARS(TempString))) {
                                    TempString[0]=TEXT('\0');
                                }
                                SetDlgItemText(hwndDlg, IDC_NDW_STATUS_TEXT, TempString);

                                //
                                // Disable the OK/Next button, because the user can't select a class driver
                                // yet.
                                //
                                if(ndwData->ddData.flags & DD_FLAG_IS_DIALOGBOX) {
                                    EnableWindow(GetDlgItem(hwndDlg, IDOK), FALSE);
                                } else {
                                    if(((ndwData->InstallData).Flags & NDW_INSTALLFLAG_SKIPCLASSLIST) &&
                                       ((ndwData->InstallData).Flags & NDW_INSTALLFLAG_EXPRESSINTRO) &&
                                       !((ndwData->InstallData).DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED)) {
                                        //
                                        // No back if we skipped the Class list, and are in express mode
                                        //
                                        PropSheet_SetWizButtons(GetParent(hwndDlg), 0);
                                    } else {
                                        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
                                    }
                                }

                                MYASSERT(ndwData->ddData.PendingAction == PENDING_ACTION_NONE);

                                ndwData->ddData.PendingAction = PENDING_ACTION_SHOWCLASS;
                                ndwData->ddData.CurSelectionForSuccess = iCur;
                            }

                        } else {

                            if(iCur != LB_ERR) {

                                lvItem.mask = LVIF_TEXT;
                                lvItem.iItem = iCur;
                                lvItem.iSubItem = 0;
                                lvItem.pszText = TempString;
                                lvItem.cchTextMax = SIZECHARS(TempString);

                                if(ListView_GetItem((ndwData->ddData).hwndDrvList, &lvItem)) {
                                    //
                                    // Now retrieve the (case-insensitive) string ID of this
                                    // string, and store it as the current description ID.
                                    //
                                    (ndwData->ddData).iCurDesc = LookUpStringInDevInfoSet((ndwData->ddData).DevInfoSet,
                                                                                          TempString,
                                                                                          FALSE
                                                                                         );
                                }
                            }

                            FillInDeviceList(hwndDlg, &(ndwData->ddData));

                            //
                            // If we just filled in the compatible driver list,
                            // then make sure there isn't a timer waiting to
                            // pounce and destroy our list!
                            //
                            if((ndwData->ddData.bShowCompat) &&
                               (ndwData->idTimer)) {

                                KillTimer(hwndDlg, SELECTMFG_TIMER_ID);
                                ndwData->idTimer = 0;
                            }
                        }
                    }
                    break;

                case IDC_NDW_PICKDEV_HAVEDISK :
                    //
                    // If we're doing a dialog box, then pressing "Have Disk" will popup another
                    // Select Device dialog.  Disable all controls on this one first, to avoid
                    // user confusion.
                    //
                    ToggleDialogControls(hwndDlg, ndwData, FALSE);

                    //
                    // If HandleSelectOEM returns success, we are done, and can either end
                    // the dialog, or proceed to the next wizard page.
                    //
                    if(ndwData->ddData.AuxThreadRunning) {
                        //
                        // The auxilliary thread is still running.  Set our cursor to an
                        // hourglass, and set our pending action to be OEM Select while we
                        // wait for the thread to respond to our cancel request.
                        //
                        MYASSERT((ndwData->ddData.PendingAction == PENDING_ACTION_NONE) ||
                                 (ndwData->ddData.PendingAction == PENDING_ACTION_SHOWCLASS));

                        hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

                        SetupDiCancelDriverInfoSearch(ndwData->ddData.DevInfoSet);
                        //
                        // Disable all dialog controls, so that no other button may be pressed
                        // until we respond to this pending action.  Also, kill the timer, so
                        // that it doesn't fire in the meantime.
                        //
                        ndwData->bInit = TRUE;
                        if(ndwData->idTimer) {
                            KillTimer(hwndDlg, SELECTMFG_TIMER_ID);
                            ndwData->idTimer = 0;
                        }
                        ndwData->ddData.PendingAction = PENDING_ACTION_OEM;

                        SetCursor(hOldCursor);

                    } else {

                        if(HandleSelectOEM(hwndDlg, ndwData) == NO_ERROR) {

                            if(ndwData->ddData.flags & DD_FLAG_IS_DIALOGBOX) {
                                EndDialog(hwndDlg, NO_ERROR);
                            } else {
                                iwd->Flags |= NDW_INSTALLFLAG_CI_PICKED_OEM;
                                PropSheet_PressButton(GetParent(hwndDlg), PSBTN_NEXT);
                            }

                        } else {
                            //
                            // The user didn't make an OEM selection, so we need to re-enable
                            // the controls on our dialog/wizard.
                            //
                            ToggleDialogControls(hwndDlg, ndwData, TRUE);
                        }
                    }
                    break;

                case IDC_NDW_PICKDEV_WINDOWSUPDATE:
                    //
                    // If we're doing a dialog box, then pressing "Have Disk" will popup another
                    // Select Device dialog.  Disable all controls on this one first, to avoid
                    // user confusion.
                    //
                    ToggleDialogControls(hwndDlg, ndwData, FALSE);

                    //
                    // If HandleWindowsUpdate returns success, we are done, and can either end
                    // the dialog, or proceed to the next wizard page.
                    //
                    if(ndwData->ddData.AuxThreadRunning) {

                        //
                        // The auxilliary thread is still running.  Set our cursor to an
                        // hourglass, and set our pending action to be Windows Update Select while we
                        // wait for the thread to respond to our cancel request.
                        //
                        MYASSERT((ndwData->ddData.PendingAction == PENDING_ACTION_NONE) ||
                                 (ndwData->ddData.PendingAction == PENDING_ACTION_SHOWCLASS));

                        hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

                        SetupDiCancelDriverInfoSearch(ndwData->ddData.DevInfoSet);
                        //
                        // Disable all dialog controls, so that no other button may be pressed
                        // until we respond to this pending action.  Also, kill the timer, so
                        // that it doesn't fire in the meantime.
                        //
                        ndwData->bInit = TRUE;
                        if(ndwData->idTimer) {
                            KillTimer(hwndDlg, SELECTMFG_TIMER_ID);
                            ndwData->idTimer = 0;
                        }
                        ndwData->ddData.PendingAction = PENDING_ACTION_WINDOWSUPDATE;

                        SetCursor(hOldCursor);

                    } else {

                        if(HandleWindowsUpdate(hwndDlg, ndwData) == NO_ERROR) {

                            if(ndwData->ddData.flags & DD_FLAG_IS_DIALOGBOX) {
                                EndDialog(hwndDlg, NO_ERROR);
                            } else {
                                iwd->Flags |= NDW_INSTALLFLAG_CI_PICKED_OEM;
                                PropSheet_PressButton(GetParent(hwndDlg), PSBTN_NEXT);
                            }

                        } else {
                            //
                            // The user didn't make an OEM selection, so we need to re-enable
                            // the controls on our dialog.
                            //
                            ToggleDialogControls(hwndDlg, ndwData, TRUE);
                        }
                    }
                    break;

                case IDOK :
HandleOK:
                    iCur = (int)ListView_GetNextItem((ndwData->ddData).hwndDrvList,
                                                     -1,
                                                     LVNI_SELECTED
                                                    );
                    if(iCur != LB_ERR) {
                        //
                        // We have retrieved a valid selection from our listbox.
                        //
                        if(ndwData->ddData.AuxThreadRunning) {
                            //
                            // The auxilliary thread is still running.  Set our cursor to an
                            // hourglass, while we wait for the thread to terminate.
                            //
                            MYASSERT((ndwData->ddData.PendingAction == PENDING_ACTION_NONE) ||
                                     (ndwData->ddData.PendingAction == PENDING_ACTION_SHOWCLASS));

                            hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

                            SetupDiCancelDriverInfoSearch(ndwData->ddData.DevInfoSet);
                            //
                            // Disable all dialog controls, so that no other button may be pressed
                            // until we respond to this pending action.  Also, kill the timer, so
                            // that it doesn't fire in the meantime.
                            //
                            ToggleDialogControls(hwndDlg, ndwData, FALSE);
                            ndwData->bInit = TRUE;
                            if(ndwData->idTimer) {
                                KillTimer(hwndDlg, SELECTMFG_TIMER_ID);
                                ndwData->idTimer = 0;
                            }
                            ndwData->ddData.PendingAction = PENDING_ACTION_SELDONE;
                            ndwData->ddData.CurSelectionForSuccess = iCur;

                            SetCursor(hOldCursor);

                        } else {
                            //
                            // The auxilliary thread has already returned. We can return
                            // success right here.
                            //
                            SetSelectedDriverNode(&(ndwData->ddData), iCur);
                            EndDialog(hwndDlg, NO_ERROR);
                        }

                    } else {

                        //
                        // If the list box is empty, then just leave. We will treat this
                        // just like the user canceled.
                        //
                        if (0 == ListView_GetItemCount((ndwData->ddData).hwndDrvList)) {

                            PostMessage(hwndDlg, WM_COMMAND, IDCANCEL, 0);

                        } else {

                            //
                            // Tell user to select something since there are items in the list
                            //
                            if(!LoadString(MyDllModuleHandle,
                                           IDS_SELECT_DEVICE,
                                           TempString,
                                           SIZECHARS(TempString))) {
                                *TempString = TEXT('\0');
                            }

                            FormatMessageBox(MyDllModuleHandle,
                                             hwndDlg,
                                             MSG_SELECTDEVICE_ERROR,
                                             TempString,
                                             MB_OK | MB_ICONEXCLAMATION
                                            );
                        }
                    }
                    break;

                case IDCANCEL :

                    if(ndwData->ddData.AuxThreadRunning) {
                        //
                        // The auxilliary thread is running, so we have to ask it to cancel,
                        // and set our pending action to do the cancel upon the thread's
                        // termination notification.
                        //
                        MYASSERT((ndwData->ddData.PendingAction == PENDING_ACTION_NONE) ||
                                 (ndwData->ddData.PendingAction == PENDING_ACTION_SHOWCLASS));

                        hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

                        SetupDiCancelDriverInfoSearch(ndwData->ddData.DevInfoSet);
                        //
                        // Disable all dialog controls, so that no other button may be pressed
                        // until we respond to this pending action.  Also, kill the timer, so
                        // that it doesn't fire in the meantime.
                        //
                        ToggleDialogControls(hwndDlg, ndwData, FALSE);
                        ndwData->bInit = TRUE;
                        if(ndwData->idTimer) {
                            KillTimer(hwndDlg, SELECTMFG_TIMER_ID);
                            ndwData->idTimer = 0;
                        }
                        ndwData->ddData.PendingAction = PENDING_ACTION_CANCEL;

                        SetCursor(hOldCursor);

                    } else {
                        //
                        // The auxilliary thread isn't running, so we can return right here.
                        //
                        OnCancel(ndwData);
                        EndDialog(hwndDlg, ERROR_CANCELLED);
                    }
                    break;

                default :
                    return FALSE;
            }
            break;

        case WM_NOTIFY :

            switch(((LPNMHDR)lParam)->code) {

                case PSN_SETACTIVE :
                    //
                    // Init the text in set active since a class installer
                    // has the option of replacing it.
                    //
                    SetDlgText(hwndDlg, IDC_NDW_TEXT, IDS_NDW_PICKDEV1, IDS_NDW_PICKDEV1);

                    ndwData->bInit = TRUE;       // Still doing some init stuff

                    if(!OnSetActive(hwndDlg, ndwData)) {
                        SetDlgMsgResult(hwndDlg, uMsg, -1);
                    }

                    ndwData->bInit = FALSE;      // Done with init stuff
                    break;

                case PSN_WIZBACK :
                    CleanupDriverLists(ndwData);

                    if(iwd->DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED) {
                        SetDlgMsgResult(hwndDlg, uMsg, IDD_DYNAWIZ_SELECT_PREVPAGE);
                    } else {
                        SetDlgMsgResult(hwndDlg, uMsg, IDD_DYNAWIZ_SELECTCLASS_PAGE);
                    }
                    break;

                case PSN_WIZNEXT :
                    if(!(iwd->Flags & NDW_INSTALLFLAG_CI_PICKED_OEM)) {

                        iCur = (int)ListView_GetNextItem((ndwData->ddData).hwndDrvList,
                                                         -1,
                                                         LVNI_SELECTED
                                                        );
                        if(iCur != LB_ERR) {
                            //
                            // We have retrieved a valid selection from our listbox.
                            //
                            if (pSetupIsSelectedHardwareIdValid(hwndDlg, &(ndwData->ddData), iCur)) {
                                SetSelectedDriverNode(&(ndwData->ddData), iCur);
                            } else {
                                SetDlgMsgResult(hwndDlg, uMsg, (LRESULT)-1);
                                break;
                            }

                        } else {        // Invalid Listview selection
                            //
                            // Fail the call and end the case
                            //
                            SetDlgMsgResult(hwndDlg, uMsg, (LRESULT)-1);
                            break;
                        }
                    }

                    //
                    // Update the current description in the dialog data so that we'll hi-lite
                    // the correct selection if the user comes back to this page.
                    //
                    (ndwData->ddData).iCurDesc = GetCurDesc(&(ndwData->ddData));

                    if(iwd->DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED) {
                        SetDlgMsgResult(hwndDlg, uMsg, IDD_DYNAWIZ_SELECT_NEXTPAGE);
                    } else {
                        SetDlgMsgResult(hwndDlg, uMsg, IDD_DYNAWIZ_ANALYZEDEV_PAGE);
                    }
                    break;

                case LVN_ITEMCHANGED :
                    //
                    // If the idFrom is the MFG list, then update the Drv list.
                    //
                    if(((((LPNMHDR)lParam)->idFrom) == IDC_NDW_PICKDEV_MFGLIST) && !ndwData->bInit) {

                        if(ndwData->idTimer) {
                            KillTimer(hwndDlg, SELECTMFG_TIMER_ID);
                        }

                        ndwData->idTimer = SetTimer(hwndDlg,
                                                    SELECTMFG_TIMER_ID,
                                                    SELECTMFG_TIMER_DELAY,
                                                    NULL
                                                   );

                        if(ndwData->idTimer == 0) {
                            goto SelectMfgItemNow;
                        }
                    }

                    //
                    // If the idFrom is either of the model lists then update
                    // the digital signature icon and text.
                    //
                    if (((((LPNMHDR)lParam)->idFrom) == IDC_NDW_PICKDEV_ONEMFG_DRVLIST) ||
                        ((((LPNMHDR)lParam)->idFrom) == IDC_NDW_PICKDEV_DRVLIST)) {

                        LVITEM lviItem;
                        int iImage = -1;

                        hicon = NULL;

                        iCur = (int)ListView_GetNextItem((ndwData->ddData).hwndDrvList,
                                                         -1,
                                                         LVNI_SELECTED
                                                        );

                        if(iCur != -1) {
                            //
                            // We have retrieved a valid selection from our listbox.
                            //
                            lviItem.mask = LVIF_IMAGE;
                            lviItem.iItem = iCur;
                            lviItem.iSubItem = 0;

                            if(ListView_GetItem((ndwData->ddData).hwndDrvList, &lviItem)) {
                                iImage = lviItem.iImage;
                            }
                        }

                        if (iImage != -1) {

                            //
                            // Enable the OK/Next button, because the user can't select a class driver
                            // yet.
                            //
                            if(ndwData->ddData.flags & DD_FLAG_IS_DIALOGBOX) {
                                EnableWindow(GetDlgItem(hwndDlg, IDOK), TRUE);
                            } else {
                                if(((ndwData->InstallData).Flags & NDW_INSTALLFLAG_SKIPCLASSLIST) &&
                                   ((ndwData->InstallData).Flags & NDW_INSTALLFLAG_EXPRESSINTRO) &&
                                   !((ndwData->InstallData).DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED)) {
                                    //
                                    // No back if we skipped the Class list, and are in express mode
                                    //
                                    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);
                                } else {
                                    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
                                }
                            }

                            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_ICON), SW_SHOW);
                            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_TEXT), SW_SHOW);

                            //
                            // Don't show the link if we are in GUI setup because
                            // help center is not installed yet and so clicking
                            // on the link won't do anything.
                            //
                            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_LINK),
                                       GuiSetupInProgress ? SW_HIDE : SW_SHOW);

                            if (iImage == IMAGE_ICON_SIGNED) {
                                //
                                // Load the digital signature icon and text
                                //
                                hicon = LoadImage(MyDllModuleHandle,
                                                  MAKEINTRESOURCE(IDI_SIGNED),
                                                  IMAGE_ICON,
                                                  GetSystemMetrics(SM_CXSMICON),
                                                  GetSystemMetrics(SM_CYSMICON),
                                                  0
                                                  );

                                if(!LoadString(MyDllModuleHandle,
                                               IDS_DRIVER_IS_SIGNED,
                                               TempString,
                                               SIZECHARS(TempString))) {
                                    *TempString = TEXT('\0');
                                }

                                if ((ndwData->ddData).hFontNormal) {
                                    SetWindowFont(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_TEXT), (ndwData->ddData).hFontNormal, TRUE);
                                }
                            } else {
                                //
                                // Load the warning icon and text
                                //
                                hicon = LoadImage(MyDllModuleHandle,
                                                  MAKEINTRESOURCE(IDI_WARN),
                                                  IMAGE_ICON,
                                                  GetSystemMetrics(SM_CXSMICON),
                                                  GetSystemMetrics(SM_CYSMICON),
                                                  0
                                                  );

                                if(!LoadString(MyDllModuleHandle,
                                               IDS_DRIVER_NOT_SIGNED,
                                               TempString,
                                               SIZECHARS(TempString))) {
                                    *TempString = TEXT('\0');
                                }

                                if ((ndwData->ddData).hFontBold) {
                                    SetWindowFont(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_TEXT), (ndwData->ddData).hFontBold, TRUE);
                                }
                            }

                            if (hicon) {
                                hicon = (HICON)SendDlgItemMessage(hwndDlg,
                                                                  IDC_NDW_PICKDEV_SIGNED_ICON,
                                                                  STM_SETICON,
                                                                  (WPARAM)hicon,
                                                                  0L
                                                                  );
                            }
                            if (hicon) {
                                DestroyIcon(hicon);
                            }

                            SetDlgItemText(hwndDlg, IDC_NDW_PICKDEV_SIGNED_TEXT, TempString);

                        } else {
                            //
                            // Nothing is selected so hide the icon and the text.
                            //
                            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_ICON), SW_HIDE);
                            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_TEXT), SW_HIDE);
                            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_LINK), SW_HIDE);

                            //
                            // Disable the OK/Next button, because the user can't select a class driver
                            // yet.
                            //
                            if(ndwData->ddData.flags & DD_FLAG_IS_DIALOGBOX) {
                                EnableWindow(GetDlgItem(hwndDlg, IDOK), FALSE);
                            } else {
                                if(((ndwData->InstallData).Flags & NDW_INSTALLFLAG_SKIPCLASSLIST) &&
                                   ((ndwData->InstallData).Flags & NDW_INSTALLFLAG_EXPRESSINTRO) &&
                                   !((ndwData->InstallData).DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED)) {
                                    //
                                    // No back if we skipped the Class list, and are in express mode
                                    //
                                    PropSheet_SetWizButtons(GetParent(hwndDlg), 0);
                                } else {
                                    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
                                }
                            }
                        }
                    }

                    break;

                case NM_RETURN:
                case NM_CLICK:
                    if((((LPNMHDR)lParam)->idFrom) == IDC_NDW_PICKDEV_SIGNED_LINK) {
                        ShellExecute(hwndDlg,
                                     TEXT("open"),
                                     TEXT("HELPCTR.EXE"),
                                     TEXT("HELPCTR.EXE -url hcp://services/subsite?node=TopLevelBucket_4/Hardware&topic=MS-ITS%3A%25HELP_LOCATION%25%5Csysdm.chm%3A%3A/logo_testing.htm"),
                                     NULL,
                                     SW_SHOWNORMAL
                                     );
                    }
                    break;

                case NM_DBLCLK :
                    if(((((LPNMHDR)lParam)->idFrom) == IDC_NDW_PICKDEV_DRVLIST) ||
                       ((((LPNMHDR)lParam)->idFrom) == IDC_NDW_PICKDEV_ONEMFG_DRVLIST)) {

                        if(ndwData->ddData.flags & DD_FLAG_IS_DIALOGBOX) {
                            goto HandleOK;
                        } else {
                            PropSheet_PressButton(GetParent(hwndDlg), PSBTN_NEXT);
                        }
                    }
                    break;
            }

            break;

        case WM_TIMER :
            KillTimer(hwndDlg, SELECTMFG_TIMER_ID);
            ndwData->idTimer = 0;

SelectMfgItemNow:
            iCur = ListView_GetNextItem((ndwData->ddData).hwndMfgList,
                                        -1,
                                        LVNI_SELECTED
                                       );
            if(iCur != -1) {

                RECT rcTo, rcFrom;

                ListView_EnsureVisible((ndwData->ddData).hwndMfgList, iCur, FALSE);
                UpdateWindow((ndwData->ddData).hwndMfgList);

                GetWindowRect((ndwData->ddData).hwndDrvList, &rcTo);
                MapWindowPoints(NULL, hwndDlg, (LPPOINT)&rcTo, 2);

                ListView_GetItemRect((ndwData->ddData).hwndMfgList,
                                     iCur,
                                     &rcFrom,
                                     LVIR_LABEL
                                    );
                MapWindowPoints((ndwData->ddData).hwndMfgList,
                                hwndDlg,
                                (LPPOINT)&rcFrom,
                                2
                               );

                DrawAnimatedRects(hwndDlg, IDANI_OPEN, &rcFrom, &rcTo);
                LockAndShowListForMfg(&(ndwData->ddData), iCur);
            }
            break;

        case WM_SYSCOLORCHANGE :
            _OnSysColorChange(hwndDlg, wParam, lParam);
            break;

        case WM_HELP:      // F1
            WinHelp(((LPHELPINFO)lParam)->hItemHandle,
                    SELECTDEVICE_HELP,
                    HELP_WM_HELP,
                    (ndwData->ddData.flags & DD_FLAG_SHOWSIMILARDRIVERS) ?
                    (ULONG_PTR)SelectDeviceShowSimilarHelpIDs :
                    (ULONG_PTR)SelectDeviceShowAllHelpIDs
                    );
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND)wParam,
                    SELECTDEVICE_HELP,
                    HELP_CONTEXTMENU,
                    (ndwData->ddData.flags & DD_FLAG_SHOWSIMILARDRIVERS) ?
                    (ULONG_PTR)SelectDeviceShowSimilarHelpIDs :
                    (ULONG_PTR)SelectDeviceShowAllHelpIDs
                    );
            break;

        default :

            if (!g_uQueryCancelAutoPlay) {
                g_uQueryCancelAutoPlay = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));
            }

            if (uMsg == g_uQueryCancelAutoPlay) {
                SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, 1 );
                return 1;       // cancel auto-play
            }

            return(FALSE);
    }

    return TRUE;
}



INT CALLBACK
DriverNodeCompareProc(
    LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort
    )
/*++

Routine Description:

    This routine is the callback for the list control sorting that is done when
    ListView_SortItems is called.

    The sorting this routine does is that if a DriverNode has the
    DNF_INF_IS_SIGNED flag then it is considered better than a DriverNode that
    does not have this flag. If both DriverNodes have, or don't have, this
    flag then a simple string compare is done.

Return Value:

    -1 if lParam1 is better than lParam2 (should be higher in the ListControl
    +1 if lParam2 is better than lParam1 (should be higher in the ListControl
    0  if lParam1 and lParam2 are the same

--*/
{
    if ((((PDRIVER_NODE)lParam1)->Flags & DNF_INF_IS_SIGNED) &&
        !(((PDRIVER_NODE)lParam2)->Flags & DNF_INF_IS_SIGNED)) {

        return -1;
    }

    if ((((PDRIVER_NODE)lParam2)->Flags & DNF_INF_IS_SIGNED) &&
        !(((PDRIVER_NODE)lParam1)->Flags & DNF_INF_IS_SIGNED)) {

        return 1;
    }

    //
    // At this point both driver nodes are signed or both are not signed, so
    // compare based on their description.
    //
    return (lstrcmpi(pStringTableStringFromId(((PDEVICE_INFO_SET)lParamSort)->StringTable,
                                              ((PDRIVER_NODE)lParam1)->DevDescriptionDisplayName),
                     pStringTableStringFromId(((PDEVICE_INFO_SET)lParamSort)->StringTable,
                                              ((PDRIVER_NODE)lParam2)->DevDescriptionDisplayName)));
}


VOID
_OnSysColorChange(
    HWND hWnd,
    WPARAM wParam,
    LPARAM lParam
    )
/*++

Routine Description:

    This routine notifies all child windows of the specified window when there is
    a system color change.

Return Value:

    None.

--*/
{
    HWND hChildWnd;

    hChildWnd = GetWindow(hWnd, GW_CHILD);

    while(hChildWnd != NULL) {

        SendMessage(hChildWnd, WM_SYSCOLORCHANGE, wParam, lParam);
        hChildWnd = GetWindow(hChildWnd, GW_HWNDNEXT);

    }
}


DWORD
FillInDeviceList(
    IN HWND           hwndDlg,
    IN PSP_DIALOGDATA lpdd
    )
/*++

Routine Description:

    This routine sets the dialog to have the appropriate description strings.
    It also alternates dialog between showing the manufacturer "double list"
    and the single list.   This is done by showing/hiding overlapping listview.

    NOTE:  DO NOT CALL THIS ROUTINE TO WHILE ANOTHER THREAD IS BUSY BUILDING A
    CLASS DRIVER LIST.  WE WILL HANG HERE UNTIL THE OTHER THREAD COMPLETES!!!!

Arguments:

    hwndDlg - Supplies the handle of the dialog window.

    lpdd - Supplies the address of a dialog data buffer containing parameters to
        be used in filling in the device list.

Return Value:

    If success, the return value is NO_ERROR, otherwise, it is an ERROR_* code.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    PDRIVER_NODE DriverNodeHead, CurDriverNode;
    DWORD DriverNodeType;
    LONG MfgNameId;
    INT i;
    LPTSTR lpszMfg;
    LV_COLUMN lvcCol;
    LV_ITEM lviItem;
    BOOL bDidDrvList = FALSE;
    PDEVINSTALL_PARAM_BLOCK dipb;
    DWORD Err = NO_ERROR;
    TCHAR szBuf[LINE_LEN];
    TCHAR szMessage[MAX_INSTRUCTION_LEN];
    TCHAR szText[SDT_MAX_TEXT];
    LPTSTR lpszText;
    LPGUID ClassGuid;

    MYASSERT(lpdd);
    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return ERROR_INVALID_HANDLE;
    }

    try {

        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }

        if(DevInfoElem) {
            dipb = &(DevInfoElem->InstallParamBlock);
            ClassGuid = &(DevInfoElem->ClassGuid);

            if(lpdd->bShowCompat) {
                DriverNodeHead = DevInfoElem->CompatDriverHead;
                DriverNodeType = SPDIT_COMPATDRIVER;
            } else {
                DriverNodeHead = DevInfoElem->ClassDriverHead;
                DriverNodeType = SPDIT_CLASSDRIVER;
            }

        } else {
            //
            // We better not be trying to display a compatible driver list if
            // we don't have a devinfo element!
            //
            MYASSERT(!lpdd->bShowCompat);

            //
            // Since we don't have any compatible drivers to show, we will hide
            // the show compatible checkbox.
            //
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_COMPAT), SW_HIDE);

            dipb = &(pDeviceInfoSet->InstallParamBlock);
            DriverNodeHead = pDeviceInfoSet->ClassDriverHead;
            DriverNodeType = SPDIT_CLASSDRIVER;

            if(pDeviceInfoSet->HasClassGuid) {
                ClassGuid = &(pDeviceInfoSet->ClassGuid);
            } else {
                //
                // Cast away const-ness of this global GUID, since we only use
                // LPGUID type (in fact, there is no 'LPCGUID' type defined).
                //
                ClassGuid = (LPGUID)&GUID_DEVCLASS_UNKNOWN;
            }
        }

        if(!DriverNodeHead) {

            if(!(lpdd->flags & DD_FLAG_IS_DIALOGBOX)) {
                //
                // We can't just go away, so we have to do something useful.  For now, simply
                // display the UI as if we had a single-Mfg list, except that the list is empty.
                //
                // Hide the mult mfg controls
                //
                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_MFGLIST), SW_HIDE);
                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_DRVLIST), SW_HIDE);

                //
                // Show the Single MFG controls
                //
                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST), SW_SHOW);

                //
                // Set the Models string
                //
                lvcCol.mask = LVCF_FMT | LVCF_TEXT;
                lvcCol.fmt = LVCFMT_LEFT;

                if(USE_CI_SELSTRINGS(dipb)) {
                    lvcCol.pszText = GET_CI_SELSTRINGS(dipb, ListLabel);
                    ListView_SetColumn(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST), 0, &lvcCol);
                } else {
                    if(!(LoadString(MyDllModuleHandle,
                                    IDS_NDWSEL_MODELSLABEL,
                                    szBuf,
                                    SIZECHARS(szBuf)))) {
                        szBuf[0] = TEXT('\0');
                    }
                    lvcCol.pszText = szBuf;
                    ListView_SetColumn(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST), 0, &lvcCol);
                }

                //
                // Use the single listbox view for the driver list.
                //
                lpdd->hwndDrvList = GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST);

                ListView_DeleteAllItems(lpdd->hwndDrvList);
            }

            Err = ERROR_DI_BAD_PATH;
            goto clean0;
        }

        if((lpdd->flags & DD_FLAG_IS_DIALOGBOX) && !USE_CI_SELSTRINGS(dipb)) {
            //
            // If a class installer didn't supply strings for us to use in this dialogbox,
            // then retrieve the instruction text to be used.
            //
            // First, get the class description to use for the dialog text.
            //
            if(!SetupDiGetClassDescription(ClassGuid, szBuf, SIZECHARS(szBuf), NULL)) {
                //
                // Fall back to the generic description "device"
                //
                if(!LoadString(MyDllModuleHandle,
                           IDS_GENERIC_DEVNAME,
                           szBuf,
                           SIZECHARS(szBuf)
                          )) {
                    szBuf[0]=TEXT('\0');
                }
            }

            if(!lpdd->bShowCompat) {
                //
                // Show class list.
                //
                if(LoadString(MyDllModuleHandle,
                              IDS_INSTALLSTR1,
                              szMessage,
                              SIZECHARS(szMessage))) {
                    wsprintf(szText, szMessage, szBuf);
                } else {
                    szText[0] = TEXT('\0');
                }

            } else {
                //
                // Show compatible list.
                //
                if(LoadString(MyDllModuleHandle,
                              IDS_INSTALLSTR0,
                              szMessage,
                              SIZECHARS(szMessage))) {
                    wsprintf(szText, szMessage, szBuf);
                } else {
                    szText[0]=TEXT('\0');
                }
                lpszText = szText + lstrlen(szText);
                if(LoadString(MyDllModuleHandle,
                              IDS_INSTALLCLASS,
                              szMessage,
                              SIZECHARS(szMessage))) {
                    wsprintf(lpszText, szMessage, szBuf);
                } else {
                    szText[0] = TEXT('\0');
                }
            }

            if(dipb->DriverPath != -1) {

                lpszText = szText + lstrlen(szText);
                LoadString(MyDllModuleHandle,
                           IDS_INSTALLOEM1,
                           lpszText,
                           SIZECHARS(szText) - lstrlen(szText)
                           );

            } else if (dipb->Flags & DI_SHOWOEM) {

                lpszText = szText + lstrlen(szText);
                LoadString(MyDllModuleHandle,
                           IDS_INSTALLOEM,
                           lpszText,
                           SIZECHARS(szText) - lstrlen(szText)
                          );
            }

            SetDlgItemText(hwndDlg, IDC_NDW_TEXT, szText);
        }

        if((!lpdd->bShowCompat) && (dipb->Flags & DI_MULTMFGS)) {
            //
            // Hide the Single MFG controls
            //
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_STATUS_TEXT), SW_HIDE);

            //
            // Show the Multiple MFG controls
            //
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_MFGLIST), SW_SHOW);
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_DRVLIST), SW_SHOW);

            //
            // Set the colunm heading for the Driver list
            //
            lvcCol.mask = LVCF_FMT | LVCF_TEXT;
            lvcCol.fmt = LVCFMT_LEFT;

            if(USE_CI_SELSTRINGS(dipb)) {
                lvcCol.pszText = GET_CI_SELSTRINGS(dipb, ListLabel);
                ListView_SetColumn(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_DRVLIST), 0, &lvcCol);
            } else {
                if(!(LoadString(MyDllModuleHandle,
                                IDS_NDWSEL_MODELSLABEL,
                                szBuf,
                                SIZECHARS(szBuf)))) {
                    szBuf[0] = TEXT('\0');
                }
                lvcCol.pszText = szBuf;
                ListView_SetColumn(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_DRVLIST), 0, &lvcCol);
            }

            //
            // Use the 2nd listbox of the Manufacturers/Models view for the driver list.
            //
            lpdd->hwndDrvList = GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_DRVLIST);

#ifndef ANSI_SETUPAPI
            ListView_SetExtendedListViewStyle(lpdd->hwndDrvList, LVS_EX_LABELTIP);
#endif

            if (lpdd->hImageList) {
                ListView_SetImageList(lpdd->hwndDrvList, lpdd->hImageList, LVSIL_SMALL);
            }

            //
            // No redraw for faster insert
            //
            SendMessage(lpdd->hwndMfgList, WM_SETREDRAW, FALSE, 0L);

            //
            // Clean out the MFG list before filling it.
            //
            ListView_DeleteAllItems(lpdd->hwndMfgList);

            lviItem.mask = LVIF_TEXT | LVIF_PARAM;
            lviItem.iItem = 0;
            lviItem.iSubItem = 0;

            //
            // Setup the Column Header
            //
            MfgNameId = -1;

            for(CurDriverNode = DriverNodeHead; CurDriverNode; CurDriverNode = CurDriverNode->Next) {

                //
                // Skip this driver node if it is to be excluded of if it is an old INET driver or
                // if it is a BAD driver.
                //
                if ((CurDriverNode->Flags & DNF_OLD_INET_DRIVER) ||
                    (CurDriverNode->Flags & DNF_BAD_DRIVER) ||
                    ((CurDriverNode->Flags & DNF_EXCLUDEFROMLIST) &&
                   !(dipb->FlagsEx & DI_FLAGSEX_ALLOWEXCLUDEDDRVS))) {

                    continue;
                }


                if((MfgNameId == -1) || (MfgNameId != CurDriverNode->MfgName)) {

                    MfgNameId = CurDriverNode->MfgName;

                    MYASSERT(CurDriverNode->MfgDisplayName != -1);
                    lpszMfg = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                       CurDriverNode->MfgDisplayName
                                                      );
                    lviItem.pszText = lpszMfg;
                    lviItem.lParam = (LPARAM)CurDriverNode;
                    i = ListView_InsertItem(lpdd->hwndMfgList, &lviItem);
                }

                //
                // If this driver node is the selected one, preselect here.
                //
                if(lpdd->iCurDesc == CurDriverNode->DevDescription) {
                    ListView_SetItemState(lpdd->hwndMfgList,
                                          i,
                                          (LVIS_SELECTED|LVIS_FOCUSED),
                                          (LVIS_SELECTED|LVIS_FOCUSED)
                                         );
                    ShowListForMfg(lpdd, pDeviceInfoSet, dipb, NULL, i);
                    bDidDrvList = TRUE;
                }
            }

            //
            // Resize the Column
            //
            ListView_SetColumnWidth(lpdd->hwndMfgList, 0, LVSCW_AUTOSIZE_USEHEADER);

            //
            // If we did not expand one of the MFGs by default, then
            // expand the First MFG.
            //
            if(!bDidDrvList) {

                ListView_SetItemState(lpdd->hwndMfgList,
                                      0,
                                      (LVIS_SELECTED|LVIS_FOCUSED),
                                      (LVIS_SELECTED|LVIS_FOCUSED)
                                     );
                ShowListForMfg(lpdd, pDeviceInfoSet, dipb, NULL, 0);

                SendMessage(lpdd->hwndMfgList, WM_SETREDRAW, TRUE, 0L);

            } else {
                //
                // We must set redraw back to true before sending the LVM_ENSUREVISIBLE
                // message, or otherwise, the listbox item may only be partially exposed.
                //
                SendMessage(lpdd->hwndMfgList, WM_SETREDRAW, TRUE, 0L);

                ListView_EnsureVisible(lpdd->hwndMfgList,
                                       ListView_GetNextItem(lpdd->hwndMfgList, -1, LVNI_SELECTED),
                                       FALSE
                                      );
            }

        } else {
            //
            // Hide the mult mfg controls
            //
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_MFGLIST), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_DRVLIST), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_STATUS_TEXT), SW_HIDE);

            //
            // Show the Single MFG controls
            //
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST), SW_SHOW);

            //
            // Set the Models string
            //
            lvcCol.mask = LVCF_FMT | LVCF_TEXT;
            lvcCol.fmt = LVCFMT_LEFT;

            if(USE_CI_SELSTRINGS(dipb)) {
                lvcCol.pszText = GET_CI_SELSTRINGS(dipb, ListLabel);
                ListView_SetColumn(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST), 0, &lvcCol);
            } else {
                if(!(LoadString(MyDllModuleHandle,
                                IDS_NDWSEL_MODELSLABEL,
                                szBuf,
                                SIZECHARS(szBuf)))) {
                    szBuf[0] = TEXT('\0');
                }
                lvcCol.pszText = szBuf;
                ListView_SetColumn(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST), 0, &lvcCol);
            }

            //
            // Use the single listbox view for the driver list.
            //
            lpdd->hwndDrvList = GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST);

            if (lpdd->hImageList) {
                ListView_SetImageList(lpdd->hwndDrvList, lpdd->hImageList, LVSIL_SMALL);
            }

            ShowListForMfg(lpdd, pDeviceInfoSet, dipb, DriverNodeHead, -1);
        }

clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;   // nothing to do
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    return Err;
}


VOID
ShowListForMfg(
    IN PSP_DIALOGDATA          lpdd,
    IN PDEVICE_INFO_SET        DeviceInfoSet,
    IN PDEVINSTALL_PARAM_BLOCK InstallParamBlock,
    IN PDRIVER_NODE            DriverNode,        OPTIONAL
    IN INT                     iMfg
    )
/*++

Routine Description:

    This routine builds the driver description list.
    THE LOCK MUST ALREADY BE ACQUIRED BEFORE CALLING THIS ROUTINE!

Arguments:

    lpdd - Supplies the address of a dialog data buffer containing parameters
        to be used in filling in the driver description list.

    DeviceInfoSet - Supplies the address of the device information set structure
        for which the driver description list is to be built.

    InstallParamBlock - Supplies the address of a device installation parameter
        block that controls how the list is displayed.

    DriverNode - Optionally, supplies a pointer to the first node in a driver node
        list to traverse, adding to the list for each node.  If DriverNode
        is not specified, then the list is to be built based on a particular
        manufacturer, whose index in the Manufacturer list is given by iMfg.

    iMfg - Supplies the index within the Manufacturer list that the driver
        description list is to be based on.  This parameter is ignored if a
        DriverNode is specified.

Return Value:

    None.

--*/
{
    INT         i;
    LV_ITEM     lviItem;
    LV_FINDINFO lvfiFind;
    LONG        MfgNameId = -1;
    TCHAR       szTemp[LINE_LEN];
    SYSTEMTIME  SystemTime;
    TCHAR       szDate[LINE_LEN];
    TCHAR       FormatString[LINE_LEN];
    TCHAR       VersionString[LINE_LEN]; // Has format a.b.c.d

    //
    // Set listview sortascending style based on DI_INF_IS_SORTED flag
    //
    SetWindowLong(lpdd->hwndDrvList,
                  GWL_STYLE,
                  (GetWindowLong(lpdd->hwndDrvList, GWL_STYLE) & ~(LVS_SORTASCENDING | LVS_SORTDESCENDING)) |
                      ((InstallParamBlock->Flags & DI_INF_IS_SORTED)
                          ? 0
                          : LVS_SORTASCENDING)
                 );

    SendMessage(lpdd->hwndDrvList, WM_SETREDRAW, FALSE, 0L);

    //
    // Clean out the List.
    //
    ListView_DeleteAllItems(lpdd->hwndDrvList);

    if(!DriverNode) {

        if (ListView_GetItemCount(lpdd->hwndMfgList) > 0) {

            lviItem.mask = LVIF_PARAM;
            lviItem.iItem = iMfg;
            lviItem.iSubItem = 0;
            if(!ListView_GetItem(lpdd->hwndMfgList, &lviItem) ||
               !(DriverNode = GetDriverNodeFromLParam(DeviceInfoSet, lpdd, lviItem.lParam))) {

                return;
            }
            MfgNameId = DriverNode->MfgName;
        } else {
            //
            // This means that there are no Manufacturers so we just have a empty list.
            //
            return;
        }
    }

    lviItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    lviItem.iItem = 0;
    lviItem.iSubItem = 0;

    //
    // Add descriptions to the list
    //
    for( ; DriverNode; DriverNode = DriverNode->Next) {

        if((MfgNameId != -1) && (MfgNameId != DriverNode->MfgName)) {
            //
            // We've gone beyond the manufacturer list--break out of loop.
            //
            break;
        }

        //
        // If this is a special "Don't show me" one, then skip it
        //
        if ((DriverNode->Flags & DNF_OLD_INET_DRIVER) ||
            (DriverNode->Flags & DNF_BAD_DRIVER) ||
            ((DriverNode->Flags & DNF_EXCLUDEFROMLIST) &&
           !(InstallParamBlock->FlagsEx & DI_FLAGSEX_ALLOWEXCLUDEDDRVS))) {

            continue;
        }

        if(DriverNode->Flags & DNF_DUPDESC) {

            lstrcpy(szTemp,
                    pStringTableStringFromId(DeviceInfoSet->StringTable,
                                             DriverNode->DevDescriptionDisplayName)
                   );

            //
            //For drivers with duplicate descriptions add the provider name
            //in parens.
            //
#ifdef UNICODE
            if (GetWindowLong(lpdd->hwndDrvList, GWL_EXSTYLE) & WS_EX_RTLREADING) {
                lstrcat(szTemp, TEXT("\x200E"));
            }
#endif

            lstrcat(szTemp, pszSpaceLparen);
            if(DriverNode->ProviderDisplayName != -1) {
                lstrcat(szTemp,
                        pStringTableStringFromId(DeviceInfoSet->StringTable,
                                                 DriverNode->ProviderDisplayName)
                       );
            }

            lstrcat(szTemp, pszRparen);

#ifdef UNICODE
            if (GetWindowLong(lpdd->hwndDrvList, GWL_EXSTYLE) & WS_EX_RTLREADING) {
                lstrcat(szTemp, TEXT("\x200E"));
            }
#endif

        } else if (DriverNode->Flags & DNF_DUPPROVIDER) {

            lstrcpy(szTemp,
                    pStringTableStringFromId(DeviceInfoSet->StringTable,
                                             DriverNode->DevDescriptionDisplayName)
                   );

            //
            //For drivers with duplicate descriptions and providers, add the
            //driver version and driver date if there is one, in brackets.
            //
            if (DriverNode->DriverVersion != 0) {

                ULARGE_INTEGER Version;

                Version.QuadPart = DriverNode->DriverVersion;

                if(!LoadString(MyDllModuleHandle, IDS_VERSION, FormatString, SIZECHARS(FormatString))) {
                    FormatString[0]=TEXT('\0');
                }

                wsprintf(VersionString, FormatString,
                        HIWORD(Version.HighPart), LOWORD(Version.HighPart),
                        HIWORD(Version.LowPart), LOWORD(Version.LowPart));

                lstrcat(szTemp, VersionString);
            }

            if ((DriverNode->DriverDate.dwLowDateTime != 0) ||
                (DriverNode->DriverDate.dwHighDateTime != 0)) {

                if (FileTimeToSystemTime(&(DriverNode->DriverDate), &SystemTime)) {

                    if (GetDateFormat(LOCALE_USER_DEFAULT,
                                      DATE_SHORTDATE,
                                      &SystemTime,
                                      NULL,
                                      FormatString,
                                      SIZECHARS(FormatString)
                                      ) != 0) {

#ifdef UNICODE
                        if (GetWindowLong(lpdd->hwndDrvList, GWL_EXSTYLE) & WS_EX_RTLREADING) {
                            wsprintf(szDate, TEXT(" \x200E[%s]\x200E"), FormatString);
                        } else {
                            wsprintf(szDate, TEXT(" [%s]"), FormatString);
                        }
#else
                        wsprintf(szDate, TEXT(" [%s]"), FormatString);
#endif

                        lstrcat(szTemp, szDate);
                    }
                }
            }

        } else {

            lstrcpy(szTemp,
                    pStringTableStringFromId(DeviceInfoSet->StringTable,
                                             DriverNode->DevDescriptionDisplayName));
        }

        lviItem.pszText = szTemp;

        lviItem.lParam = (LPARAM)DriverNode;

        lviItem.iImage = (DriverNode->Flags & DNF_INF_IS_SIGNED) ?
            IMAGE_ICON_SIGNED :
            IMAGE_ICON_NOT_SIGNED;

        if(ListView_InsertItem(lpdd->hwndDrvList, &lviItem) != -1) {
            lviItem.iItem++;
        }
    }

    //
    // Sort the list unless the DI_INF_IS_SORTED flag is set
    //
    if (GetWindowLong(lpdd->hwndDrvList, GWL_STYLE) & LVS_SORTASCENDING) {
        ListView_SortItems(lpdd->hwndDrvList,
                           (PFNLVCOMPARE)DriverNodeCompareProc,
                           (LPARAM)DeviceInfoSet
                           );
    }

    //
    // Resize the Column
    //
    ListView_SetColumnWidth(lpdd->hwndDrvList, 0, LVSCW_AUTOSIZE_USEHEADER);

    //
    // select the current description string
    //
    if(lpdd->iCurDesc == -1) {
        i = 0;
    } else {
        lvfiFind.flags = LVFI_STRING;
        lvfiFind.psz = pStringTableStringFromId(DeviceInfoSet->StringTable,
                                                lpdd->iCurDesc
                                               );
        i = ListView_FindItem(lpdd->hwndDrvList, -1, &lvfiFind);
        if(i == -1) {
            i = 0;
        }
    }
    ListView_SetItemState(lpdd->hwndDrvList,
                          i,
                          (LVIS_SELECTED|LVIS_FOCUSED),
                          (LVIS_SELECTED|LVIS_FOCUSED)
                         );

    //
    // We must turn redraw back on before sending the LVM_ENSUREVISIBLE message, or
    // otherwise the item may only be partially visible.
    //
    SendMessage(lpdd->hwndDrvList, WM_SETREDRAW, TRUE, 0L);
    ListView_EnsureVisible(lpdd->hwndDrvList, i, FALSE);
}


VOID
LockAndShowListForMfg(
    IN PSP_DIALOGDATA   lpdd,
    IN INT              iMfg
    )
/*++

Routine Description:

    This routine is a wrapper for ShowListForMfg.  It is to be called from points
    where the device information set lock is not already owned (e.g., the dialog
    prop message loop.

Arguments:

    lpdd - Supplies the address of a dialog data buffer containing parameters
        to be used in filling in the driver description list.

    iMfg - Supplies the index within the Manufacturer list that the driver
        description list is to be based on.

Return Value:

    None.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINSTALL_PARAM_BLOCK dipb;
    PDEVINFO_ELEM DevInfoElem;

    MYASSERT(lpdd);
    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return;
    }

    try {

        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }

        dipb = DevInfoElem ? &(DevInfoElem->InstallParamBlock)
                           : &(pDeviceInfoSet->InstallParamBlock);

        ShowListForMfg(lpdd,
                       pDeviceInfoSet,
                       dipb,
                       NULL,
                       iMfg
                      );

    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;   // nothing to do
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);
}


BOOL
InitSelectDeviceDlg(
    IN     HWND hwndDlg,
    IN OUT PNEWDEVWIZ_DATA ndwData
    )
/*++

Routine Description:

    This routine initializes the select device wizard page.  It
    builds the class list if it is needed, shows/hides necessary
    controls based on Flags, and comes up with the right text
    description of what's going on.

Arguments:

    hwndDlg - Handle to dialog window

    ndwData - Supplies the address of a New Device Wizard data block to be used
        during the processing of this message.

Return Value:

    TRUE if we have at least one driver (compat or class) displayed.
    FALSE if we do not have any drivers (class and compat) displayed.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    PDEVINSTALL_PARAM_BLOCK dipb;
    SP_DEVINFO_DATA DevInfoData;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    DWORD DriverType = SPDIT_CLASSDRIVER;
    DWORD Err;
    INT ShowWhat;
    LPGUID ClassGuid;
    HICON hicon = NULL;
    LV_COLUMN lvcCol;
    BOOL SpawnClassDriverSearch = FALSE;
    PCLASSDRV_THREAD_CONTEXT ClassDrvThreadContext;
    HCURSOR hOldCursor;
    BOOL Return = TRUE;
    PSP_DIALOGDATA lpdd;
    HICON hIcon;
    TCHAR szBuf[LINE_LEN];
    HFONT hfont;
    LOGFONT LogFont;

    MYASSERT(ndwData);
    lpdd = &(ndwData->ddData);
    MYASSERT(lpdd);

    if(!lpdd->hwndMfgList) {
        UINT ImageListFlags = 0;

        //
        // Then this is the first time we've initialized this dialog (we may hit
        // this routine multiple times in the wizard case, because the user can
        // go back and forth between pages).
        //
        lpdd->hwndMfgList = GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_MFGLIST);
        //
        // Don't worry--hwndDrvList will be set later in FillInDeviceList().
        //

        //
        // Create an image list and add the signed and not signed (blank) icons
        // to the list.
        // Note: If the window is in RTL then we need to OR in the ILC_MIRROR flag
        // so that the icons do NOT get mirrored along with the rest of the UI.
        // This doesn't really make any sense that you have to or in a ILC_MIRROR
        // flag so the icons do NOT get mirrored, but that is the way it works.
        //
        ImageListFlags = ILC_MASK;
#ifdef UNICODE
        if (GetWindowLong(hwndDlg, GWL_EXSTYLE) & WS_EX_LAYOUTRTL) {
            ImageListFlags |= ILC_MIRROR;
        }
#endif


        lpdd->hImageList = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
                                            GetSystemMetrics(SM_CYSMICON),
                                            ImageListFlags,
                                            1,
                                            1
                                            );

        if (lpdd->hImageList) {

            ImageList_SetBkColor(lpdd->hImageList, GetSysColor(COLOR_WINDOW));

            if ((hIcon = LoadIcon(MyDllModuleHandle, MAKEINTRESOURCE(IDI_BLANK))) != NULL) {
                ImageList_AddIcon(lpdd->hImageList, hIcon);
                DestroyIcon(hIcon);
            }

            if ((hIcon = LoadIcon(MyDllModuleHandle, MAKEINTRESOURCE(IDI_SIGNED))) != NULL) {
                ImageList_AddIcon(lpdd->hImageList, hIcon);
                DestroyIcon(hIcon);
            }
        }

        //
        // Create the normal and bold fonts for the digital signing text.
        //
        lpdd->hFontNormal = lpdd->hFontBold = NULL;

        if ((hfont = (HFONT)SendMessage(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_TEXT), WM_GETFONT, 0, 0)) != NULL) {
            GetObject(hfont, sizeof(LogFont), &LogFont);
            lpdd->hFontNormal = CreateFontIndirect(&LogFont);
        }

        if ((hfont = (HFONT)SendMessage(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_TEXT), WM_GETFONT, 0, 0)) != NULL) {
            GetObject(hfont, sizeof(LogFont), &LogFont);
            LogFont.lfWeight = FW_BOLD;
            lpdd->hFontBold = CreateFontIndirect(&LogFont);
        }

#ifndef ANSI_SETUPAPI
        ListView_SetExtendedListViewStyle(lpdd->hwndMfgList, LVS_EX_LABELTIP);
#endif
        //
        // Insert a ListView column for each of the listboxes.
        // Set the text for the Manufacturer label now since it can't be changed
        // by class installers like the model label can.
        //
        lvcCol.mask = 0;

        ListView_InsertColumn(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_DRVLIST), 0, &lvcCol);
        ListView_InsertColumn(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST), 0, &lvcCol);

        lvcCol.mask = LVCF_FMT | LVCF_TEXT;
        lvcCol.fmt = LVCFMT_LEFT;
        if(!(LoadString(MyDllModuleHandle,
                        IDS_NDWSEL_MFGLABEL,
                        szBuf,
                        SIZECHARS(szBuf)))) {
            szBuf[0] = TEXT('\0');
        }
        lvcCol.pszText = szBuf;
        ListView_InsertColumn(lpdd->hwndMfgList, 0, &lvcCol);
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return FALSE;
    }

    try {

        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }

        if(DevInfoElem) {
            dipb = &(DevInfoElem->InstallParamBlock);
            ClassGuid = &(DevInfoElem->ClassGuid);
            //
            // Fill in a SP_DEVINFO_DATA structure for a later call to
            // SetupDiBuildDriverInfoList.
            //
            DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
            DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                             DevInfoElem,
                                             &DevInfoData
                                            );
            //
            // Set flags indicating which driver lists already exist.
            //
            if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_DIDCOMPATINFO) {
                lpdd->bKeeplpCompatDrvList = TRUE;
            }

            if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_DIDINFOLIST) {
                lpdd->bKeeplpClassDrvList = TRUE;
            }

            if(DevInfoElem->SelectedDriver) {
                lpdd->bKeeplpSelectedDrv = TRUE;
            }

            //
            // We want to start out with the compatible driver list.
            //
            DriverType = SPDIT_COMPATDRIVER;

        } else {
            dipb = &(pDeviceInfoSet->InstallParamBlock);
            if(pDeviceInfoSet->HasClassGuid) {
                ClassGuid = &(pDeviceInfoSet->ClassGuid);
            } else {
                //
                // Cast away const-ness of this global GUID, since we only use
                // LPGUID type (in fact, there is no 'LPCGUID' type defined).
                //
                ClassGuid = (LPGUID)&GUID_DEVCLASS_UNKNOWN;
            }

            if(pDeviceInfoSet->InstallParamBlock.FlagsEx & DI_FLAGSEX_DIDINFOLIST) {
                lpdd->bKeeplpClassDrvList = TRUE;
            }

            if(pDeviceInfoSet->SelectedClassDriver) {
                lpdd->bKeeplpSelectedDrv = TRUE;
            }
        }

        //
        // Get/set class icon
        //
        if (IsEqualGUID(ClassGuid, &GUID_NULL)) {
            if (!SetupDiLoadClassIcon(&GUID_DEVCLASS_UNKNOWN, &hicon, &(lpdd->iBitmap))) {
                hicon = NULL;
            }
        } else {
            if (!SetupDiLoadClassIcon(ClassGuid, &hicon, &(lpdd->iBitmap))) {
                hicon = NULL;
            }
        }

        if (hicon) {
            SendDlgItemMessage(hwndDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hicon, 0L);
        }

        //
        // If we are supposed to override the instructions and title with the class
        // installer-provided strings, do it now.
        //
        if(USE_CI_SELSTRINGS(dipb)) {

            if(lpdd->flags & DD_FLAG_IS_DIALOGBOX) {
                SetWindowText(hwndDlg, GET_CI_SELSTRINGS(dipb, Title));
            } else {

#ifndef ANSI_SETUPAPI
                // Set wizard title and subtitle
                //
                PropSheet_SetHeaderTitle(GetParent(hwndDlg),
                        PropSheet_HwndToIndex(GetParent(hwndDlg), hwndDlg),
                        GET_CI_SELSTRINGS(dipb, Title));

                PropSheet_SetHeaderSubTitle(GetParent(hwndDlg),
                        PropSheet_HwndToIndex(GetParent(hwndDlg), hwndDlg),
                        GET_CI_SELSTRINGS(dipb, SubTitle));
#endif
            }
            SetDlgItemText(hwndDlg, IDC_NDW_TEXT, GET_CI_SELSTRINGS(dipb, Instructions));
        }

        //
        // If we should not allow OEM driver, then hide the HAVE disk button.
        //
        if(!(dipb->Flags & DI_SHOWOEM)) {
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_HAVEDISK), SW_HIDE);
        }

#ifdef UNICODE
        //
        // Hide the Windows Update button if we should not search the web.
        //
        if ((!(dipb->FlagsEx & DI_FLAGSEX_SHOWWINDOWSUPDATE)) ||
            (CDMIsInternetAvailable() == FALSE)) {

            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_WINDOWSUPDATE), SW_HIDE);
        }
#else

        ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_WINDOWSUPDATE), SW_HIDE);
#endif

        if (dipb->FlagsEx & DI_FLAGSEX_FILTERSIMILARDRIVERS) {
            lpdd->flags |= DD_FLAG_SHOWSIMILARDRIVERS;
        }

        //
        // In order to decrease the amount of time the user must wait before they're able
        // to work with the Select Device dialog, we have adopted a 'hybrid' multi-threaded
        // approach.  As soon as we get the first displayable list built, then we will return,
        // and build the other list (if necessary) in another thread.
        //
        // We do it this way because it's easier, it maintains the existing external behavior,
        // and because it's easier.
        //
        hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));  // Potentially slow operations ahead!

        if(DriverType == SPDIT_COMPATDRIVER) {

            //
            // OR in the DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS flag so that we don't include
            // old internet drivers in the list that we get back.
            //
            DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            if (SetupDiGetDeviceInstallParams(lpdd->DevInfoSet,
                                              &DevInfoData,
                                              &DeviceInstallParams
                                              ))
            {
                DeviceInstallParams.FlagsEx |= DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS;

                SetupDiSetDeviceInstallParams(lpdd->DevInfoSet,
                                              &DevInfoData,
                                              &DeviceInstallParams
                                              );
            }

            SetupDiBuildDriverInfoList(lpdd->DevInfoSet,
                                       &DevInfoData,
                                       SPDIT_COMPATDRIVER
                                      );

            //
            // Verify that there are some devices in the list to show.
            //
            if(bNoDevsToShow(DevInfoElem)) {
                if(!lpdd->bKeeplpCompatDrvList) {
                    SetupDiDestroyDriverInfoList(lpdd->DevInfoSet, &DevInfoData, SPDIT_COMPATDRIVER);
                }
                DriverType = SPDIT_CLASSDRIVER;

            } else if(!lpdd->bKeeplpClassDrvList) {
                //
                // We have a list to get our UI up and running, but we don't have a class driver
                // list yet.  Set a flag that causes us to spawn a thread for this later.
                //
                SpawnClassDriverSearch = TRUE;
            }
        }

        if(DriverType == SPDIT_CLASSDRIVER) {
            //
            // We couldn't find any compatible drivers, so we fall back on the class driver
            // list.  In this case we have to have this list before continuing.  In the
            // future, maybe we'll get fancier and do this in a separate thread, but for now,
            // we just make the user wait.
            //

            //
            // OR in the DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS flag so that we don't include
            // old internet drivers in the list that we get back.
            //
            DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            if (SetupDiGetDeviceInstallParams(lpdd->DevInfoSet,
                                              DevInfoElem ? &DevInfoData : NULL,
                                              &DeviceInstallParams
                                              ))
            {
                DeviceInstallParams.FlagsEx |= DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS;

                SetupDiSetDeviceInstallParams(lpdd->DevInfoSet,
                                              DevInfoElem ? &DevInfoData : NULL,
                                              &DeviceInstallParams
                                              );
            }

            SetupDiBuildDriverInfoList(lpdd->DevInfoSet,
                                       DevInfoElem ? &DevInfoData : NULL,
                                       SPDIT_CLASSDRIVER
                                      );
        }

        SetCursor(LoadCursor(NULL, IDC_ARROW));  // Done with slow operations.

        if(DriverType == SPDIT_COMPATDRIVER) {
            //
            // Since we ran this through bNoDevsToShow() above, and it succeeded, we know
            // there's at least one driver in the compatible driver list.
            //
            // (NOTE: We don't call the class installer with a DIF_SELECTBESTCOMPATDRV
            // here.  The assumption is that any class installer that wants to get in
            // the act should check for the DI_FLAGSEX_AUTOSELECTRANK0, and try to select
            // a driver _before_ going ahead and letting the default behavior of
            // SetupDiSelectDevice occur.)
            //
            if((dipb->FlagsEx & DI_FLAGSEX_AUTOSELECTRANK0) &&
               !(DevInfoElem->CompatDriverHead->Rank)) {

                if(!SetupDiSelectBestCompatDrv(lpdd->DevInfoSet, &DevInfoData)) {
                    //
                    // The only time this failure should happen is if the device is
                    // a member of a set with an associated class, and the best driver
                    // match we found is from an INF of a different class.
                    //
                    if(lpdd->flags & DD_FLAG_IS_DIALOGBOX) {
                        EndDialog(hwndDlg, GetLastError());
                        goto clean0;
                    }
                }

                //
                // No need to spawn a class driver search thread.
                //
                SpawnClassDriverSearch = FALSE;

                EndDialog(hwndDlg, NO_ERROR);
                goto clean0;
            }
            lpdd->bShowCompat = TRUE;
            CheckDlgButton(hwndDlg,
                           IDC_NDW_PICKDEV_COMPAT,
                           BST_CHECKED
                           );
        } else {
            //
            // There is no compatible list, so hide the radio buttons.
            //
            lpdd->bShowCompat = FALSE;
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_COMPAT), SW_HIDE);
        }

        //
        // Initial current description.  This will be used to set
        // the Default ListView selection.
        //
        if(lpdd->iCurDesc == -1) {
            //
            // If we already have a selected driver for the devinfo set or element,
            // then we'll use that, otherwise, we'll use the devinfo element's
            // description (if applicable).
            //
            if(DevInfoElem) {
                if(DevInfoElem->SelectedDriver) {
                    lpdd->iCurDesc = DevInfoElem->SelectedDriver->DevDescription;
                } else {

                    TCHAR TempString[LINE_LEN];
                    ULONG TempStringSize;
                    //
                    // Use the caller-supplied device description, if there is one.
                    // If not, then see if we can retrieve the DeviceDesc registry
                    // property.
                    //
                    TempStringSize = sizeof(TempString);

                    if((DevInfoElem->DeviceDescription == -1) &&
                       (CM_Get_DevInst_Registry_Property(DevInfoElem->DevInst,
                                                         CM_DRP_DEVICEDESC,
                                                         NULL,
                                                         TempString,
                                                         &TempStringSize,
                                                         0) == CR_SUCCESS)) {
                        //
                        // We were able to retrieve a device description.  Now store it
                        // (case-insensitive only) in the devinfo element.
                        //
                        DevInfoElem->DeviceDescription = pStringTableAddString(
                                                           pDeviceInfoSet->StringTable,
                                                           TempString,
                                                           STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                                           NULL,0
                                                           );
                    }

                    lpdd->iCurDesc = DevInfoElem->DeviceDescription;
                }
            } else {
                if(pDeviceInfoSet->SelectedClassDriver) {
                    lpdd->iCurDesc = pDeviceInfoSet->SelectedClassDriver->DevDescription;
                }
            }
        }

        Err = FillInDeviceList(hwndDlg, lpdd);

        if(lpdd->flags & DD_FLAG_IS_DIALOGBOX) {

            HWND hLineWnd;
            RECT Rect;

            //
            // If FillInDeviceList() fails during init time, don't even bring up the dialog.
            //
            if(Err != NO_ERROR) {
                EndDialog(hwndDlg, Err);
                goto clean0;
            }

            //
            // Set the initial focus on the OK button.
            //
            SetFocus(GetDlgItem(hwndDlg, IDOK));

            //
            // Use the fancy etched frame style for the separator bar in the dialog.
            //
            hLineWnd = GetDlgItem(hwndDlg, IDD_DEVINSLINE);
            SetWindowLong(hLineWnd,
                          GWL_EXSTYLE,
                          (GetWindowLong(hLineWnd, GWL_EXSTYLE) | WS_EX_STATICEDGE)
                         );
            GetClientRect(hLineWnd, &Rect);
            SetWindowPos(hLineWnd,
                         HWND_TOP,
                         0,
                         0,
                         Rect.right,
                         GetSystemMetrics(SM_CYEDGE),
                         SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED
                        );
        }

        //
        // If DriverType is SPDIT_CLASSDRIVER and ListView_GetItemCount returns 0 then
        // we don't have any items to show at all. This will only happen when we search
        // the default Windows INF directory and we do not have any INFs for a device.
        //
        if ((DriverType == SPDIT_CLASSDRIVER) &&
            (0 == ListView_GetItemCount(lpdd->hwndDrvList))) {

            TCHAR TempString[LINE_LEN];

            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_MFGLIST), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_DRVLIST), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_ICON), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_TEXT), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_LINK), SW_HIDE);

            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_STATUS_TEXT), SW_SHOW);

            if(!LoadString(MyDllModuleHandle, IDS_NDW_NO_DRIVERS, TempString, SIZECHARS(TempString))) {
                TempString[0]=TEXT('\0');
            }
            SetDlgItemText(hwndDlg, IDC_NDW_STATUS_TEXT, TempString);

            if(lpdd->flags & DD_FLAG_IS_DIALOGBOX) {
                EnableWindow(GetDlgItem(hwndDlg, IDOK), FALSE);
            } else {
                if(((ndwData->InstallData).Flags & NDW_INSTALLFLAG_SKIPCLASSLIST) &&
                   ((ndwData->InstallData).Flags & NDW_INSTALLFLAG_EXPRESSINTRO) &&
                   !((ndwData->InstallData).DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED)) {
                    //
                    // No back if we skipped the Class list, and are in express mode
                    //
                    PropSheet_SetWizButtons(GetParent(hwndDlg), 0);
                } else {
                    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
                }
            }

            Return = FALSE;
        }


clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // If we're doing the dialog box version, then an exception should cause us to
        // terminate the dialog and return an error.  Note that presently, the dialog
        // case is the only time we'll try to spawn off a driver search thread, so we're
        // safe in resetting that flag here as well.
        //
        if(lpdd->flags & DD_FLAG_IS_DIALOGBOX) {
            EndDialog(hwndDlg, ERROR_INVALID_DATA);
            SpawnClassDriverSearch = FALSE;
        }
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    if(SpawnClassDriverSearch) {
        //
        // Allocate a context structure to pass to the auxilliary thread (the auxilliary
        // thread will take care of freeing the memory).
        //
        if(!(ClassDrvThreadContext = MyMalloc(sizeof(CLASSDRV_THREAD_CONTEXT)))) {
            EndDialog(hwndDlg, ERROR_NOT_ENOUGH_MEMORY);
        } else {
            //
            // Fill in the context structure, and fire off the thread.  NOTE: The DevInfoData
            // struct has to have been filled in above for us to have gotten to this point.
            //
            ClassDrvThreadContext->DeviceInfoSet = lpdd->DevInfoSet;

            CopyMemory(&(ClassDrvThreadContext->DeviceInfoData),
                       &DevInfoData,
                       sizeof(DevInfoData)
                      );

            ClassDrvThreadContext->NotificationWindow = hwndDlg;

            if(_beginthread(ClassDriverSearchThread, 0, ClassDrvThreadContext) == -1) {
                //
                // Assume out-of-memory
                //
                MyFree(ClassDrvThreadContext);
                EndDialog(hwndDlg, ERROR_NOT_ENOUGH_MEMORY);
            } else {
                lpdd->AuxThreadRunning = TRUE;
            }
        }
    }

    return Return;
}


PDRIVER_NODE
GetDriverNodeFromLParam(
    IN PDEVICE_INFO_SET DeviceInfoSet,
    IN PSP_DIALOGDATA   lpdd,
    IN LPARAM           lParam
    )
/*++

Routine Description:

    This routine interprets lParam as a pointer to a driver node, and tries to
    find the node in the class driver list for either the selected devinfo element,
    or the set itself.  If the lpdd flags field has the DD_FLAG_USE_DEVINFO_ELEM bit
    set, then the lpdd's DevInfoElem will be used instead of the currently selected
    device.

Arguments:

    DeviceInfoSet - Supplies the address of the device information set structure
        to search for the driver node in.

    lpdd - Supplies the address of a dialog data structure that specifies whether
        the wizard has an explicit association to the global class driver list or
        to a particular device information element, and if so, what it's associated
        with.

    lParam - Supplies a value which may be the address of a driver node.  The
        appropriate linked list of driver nodes is searched to see if one of them
        has this value as its address, and if so, a pointer to that driver node is
        returned.

Return Value:

    If success, the return value is the address of the matching driver node, otherwise,
    it is NULL.

--*/
{
    PDRIVER_NODE CurDriverNode;
    PDEVINFO_ELEM DevInfoElem;

    if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
        DevInfoElem = lpdd->DevInfoElem;
    } else {
        DevInfoElem = DeviceInfoSet->SelectedDevInfoElem;
    }

    if(DevInfoElem) {
        CurDriverNode = (lpdd->bShowCompat) ? DevInfoElem->CompatDriverHead
                                            : DevInfoElem->ClassDriverHead;
    } else {
        MYASSERT(!lpdd->bShowCompat);
        CurDriverNode = DeviceInfoSet->ClassDriverHead;
    }

    while(CurDriverNode) {
        if(CurDriverNode == (PDRIVER_NODE)lParam) {
            return CurDriverNode;
        } else {
            CurDriverNode = CurDriverNode->Next;
        }
    }

    return NULL;
}


BOOL
OnSetActive(
    IN     HWND            hwndDlg,
    IN OUT PNEWDEVWIZ_DATA ndwData
    )
/*++

Routine Description:

    This routine handles the PSN_SETACTIVE message of the select device wizard
    page.

Arguments:

    hwndDlg - Supplies the window handle of the wizard dialog page.

    ndwData - Supplies the address of a New Device Wizard data block to be used
        during the processing of this message.

Return Value:

    If success, the return value is TRUE, otherwise, it is FALSE.

--*/
{
    BOOL b = TRUE;
    PSP_INSTALLWIZARD_DATA iwd;
    PSP_DIALOGDATA lpdd;
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    PDEVINSTALL_PARAM_BLOCK dipb;

    MYASSERT(ndwData);
    iwd = &(ndwData->InstallData);
    lpdd = &(ndwData->ddData);

    MYASSERT(lpdd);
    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return FALSE;
    }

    //
    // Make sure our "waiting for class list" static text control is hidden!
    //
    ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_STATUS_TEXT), SW_HIDE);

    try {

        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }

        if(DevInfoElem) {
            dipb = &(DevInfoElem->InstallParamBlock);
        } else {
            dipb = &(pDeviceInfoSet->InstallParamBlock);
        }

        //
        // Set the Button State
        //
        if((iwd->Flags & NDW_INSTALLFLAG_SKIPCLASSLIST) &&
           (iwd->Flags & NDW_INSTALLFLAG_EXPRESSINTRO) &&
           !(iwd->DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED)) {
            //
            // No back if we skipped the Class list, and are in express mode
            //
            PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);
        } else {
            PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
        }

        //
        // Set the New Class install params.
        // If we are being jumped to by a dyna wiz page,
        // then do not call the class installer
        //
        if(iwd->DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED) {
            InitSelectDeviceDlg(hwndDlg, ndwData);
        } else {

            BOOL FlagNeedsReset = FALSE;
            SP_DEVINFO_DATA DeviceInfoData;
            DWORD CiErr;
            PDEVINFO_ELEM CurDevInfoElem;

            //
            // Call the Class Installer
            //
            if(!(dipb->Flags & DI_NODI_DEFAULTACTION)) {
                dipb->Flags |= DI_NODI_DEFAULTACTION;
                FlagNeedsReset = TRUE;
            }

            if(DevInfoElem) {
                //
                // Initialize a SP_DEVINFO_DATA buffer to use as an argument to
                // SetupDiCallClassInstaller.
                //
                DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
                DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                                 DevInfoElem,
                                                 &DeviceInfoData
                                                );
            }

            //
            // We need to unlock the HDEVINFO before calling the class installer.
            //
            UnlockDeviceInfoSet(pDeviceInfoSet);
            pDeviceInfoSet = NULL;

            if(_SetupDiCallClassInstaller(DIF_SELECTDEVICE,
                                          lpdd->DevInfoSet,
                                          DevInfoElem ? &DeviceInfoData : NULL,
                                          CALLCI_LOAD_HELPERS | CALLCI_CALL_HELPERS)) {
                CiErr = NO_ERROR;
            } else {
                CiErr = GetLastError();
            }

            //
            // Re-acquire the HDEVINFO lock.
            //
            if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
                //
                // should never hit this code path
                //
                MYASSERT(pDeviceInfoSet);
                return FALSE;
            }

            if(DevInfoElem && !(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM)) {
                //
                // Verify that the class installer didn't do something nasty like delete
                // the currently selected devinfo element!
                //
                for(CurDevInfoElem = pDeviceInfoSet->DeviceInfoHead;
                    CurDevInfoElem;
                    CurDevInfoElem = CurDevInfoElem->Next) {

                    if(CurDevInfoElem = DevInfoElem) {
                        break;
                    }
                }

                if(!CurDevInfoElem) {
                    //
                    // The class installer deleted the selected devinfo element.  Get
                    // the newly-selected one, or fall back to the global driver list
                    // if none selected.
                    //
                    if(DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem) {
                        dipb = &(DevInfoElem->InstallParamBlock);
                    } else {
                        dipb = &(pDeviceInfoSet->InstallParamBlock);
                    }

                    //
                    // Don't need to reset the default action flag.
                    //
                    FlagNeedsReset = FALSE;
                }
            }

            //
            // Reset the DI_NODI_DEFAULTACTION flag if necessary.
            //
            if(FlagNeedsReset) {
                dipb->Flags &= ~DI_NODI_DEFAULTACTION;
            }

            switch(CiErr) {
                //
                // Class installer did the select, so goto analyze
                //
                case NO_ERROR :

                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_DYNAWIZ_ANALYZEDEV_PAGE);
                    break;

                //
                // Class installer wants us to do default.
                //
                case ERROR_DI_DO_DEFAULT :

                    InitSelectDeviceDlg(hwndDlg, ndwData);
                    break;

                default :
                    //
                    // If we are doing an OEM select, and we fail, then
                    // we should init after clearing the OEM stuff.
                    //
                    if(iwd->Flags & NDW_INSTALLFLAG_CI_PICKED_OEM) {

                        iwd->Flags &= ~NDW_INSTALLFLAG_CI_PICKED_OEM;

                        //
                        // Destroy the existing class driver list.
                        //
                        if(DevInfoElem) {
                            //
                            // Initialize a SP_DEVINFO_DATA buffer to use as an argument to
                            // SetupDiDestroyDriverInfoList.
                            //
                            DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
                            DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                                             DevInfoElem,
                                                             &DeviceInfoData
                                                            );
                        }

                        SetupDiDestroyDriverInfoList(lpdd->DevInfoSet,
                                                     DevInfoElem ? &DeviceInfoData : NULL,
                                                     SPDIT_CLASSDRIVER
                                                    );

                        //
                        // Make sure the OEM button is shown.
                        //
                        dipb->Flags |= DI_SHOWOEM;

                        InitSelectDeviceDlg(hwndDlg, ndwData);

                    } else {
                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_DYNAWIZ_SELECTCLASS_PAGE);
                    }
                    break;
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
        //
        // Reference the following variable so that the compiler will respect ordering w.r.t.
        // assignment.
        //
        pDeviceInfoSet = pDeviceInfoSet;
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    return b;
}

BOOL
pSetupIsSelectedHardwareIdValid(
    IN HWND           hWnd,
    IN PSP_DIALOGDATA lpdd,
    IN INT            iCur
    )
/*++

Routine Description:

    This routine will check to see if the driver selected by the user is valid.  If the
    driver is not valid then we will prompt the user with a message box telling them that
    the driver was not writen for their hardware and ask them if they want to continue.

    A compatible driver is considered valid if one of the Hardware or Compatible IDs of
    the driver node matches a Hardware or Compatible ID of the hardware.  The only reason
    we have this check is that class/co-installers can do the list themselves so we just
    need to make sure they didn't stick a driver node into the compatible list that is not
    really compatible.

    A class driver is considered valid if it has the same Name, section name, and INF as a
    driver in the compatible list.  Or if one of the Hardware or Compatible IDs of the
    driver node matches a Hardware or Compatible ID of the hardware.

Arguments:

    hwnd - Supplies the window handle of the wizard dialog page.

    ndwData - Supplies the address of a New Device Wizard data block to be used
        during the processing of this message.

    iCur - The index of the selected driver in the list view.

Return Value:

    TRUE if the selected driver is valid, or if the selected driver is NOT valid but the
    user said they still want to install it.
    FALSE with GetLastError() == NO_ERROR if the selected driver is NOT valid
    and the user does NOT want to install it.

    return FALSE on errors with GetLastError() set apropriately
--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDRIVER_NODE DriverNode;
    LV_ITEM lviItem;
    PDEVINFO_ELEM DevInfoElem;
    LPTSTR Title = NULL;
    LPTSTR Message = NULL;
    UINT MessageLen;
    BOOL bRet = FALSE;
    LPTSTR IDBuffer = NULL;
    ULONG IDBufferLen;
    PTSTR pID, SelectedDriverHardwareId, SelectedDriverCompatibleId;
    DWORD i, j;
    int FailCount = 0;
    PTSTR StringBuffers = NULL;
    DWORD Err = ERROR_INVALID_DATA;

    //
    // If the DD_FLAG_USE_DEVINFO_ELEM flag is not set then this device did not have
    // we don't have a DevNode to validate the choosen ID against...so just return
    // TRUE.
    //
    MYASSERT(lpdd);
    if (!(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM))
        return TRUE;

    if (!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return FALSE;
    }

    //
    // allocate memory required for various strings
    // to reduce stack usage
    //
    StringBuffers = (PTSTR)MyMalloc(sizeof(TCHAR)*(LINE_LEN+SDT_MAX_TEXT+REGSTR_VAL_MAX_HCID_LEN));
    if(!StringBuffers) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    Title = StringBuffers;              // [LINE_LEN]
    Message = Title+LINE_LEN;           // [SDT_MAX_TEXT]
    IDBuffer = Message+SDT_MAX_TEXT;    // [REGSTR_VAL_MAX_HCID_LEN]

    try {

        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }

        //
        // We won't verify the selected driver for certain classes of devices. This is
        // usually because the device is not very Plug and Play and so we can't tell
        // what is a valid driver and what isn't a valid driver.  Currently the
        // list of classes that we don't verify are:
        //
        //  Monitor
        //
        if (DevInfoElem &&
            (IsEqualGUID(&GUID_DEVCLASS_MONITOR, &(DevInfoElem->ClassGuid)))) {

            bRet = TRUE;
            goto clean0;
        }

        lviItem.mask = LVIF_PARAM;
        lviItem.iItem = iCur;
        lviItem.iSubItem = 0;

        if(ListView_GetItem(lpdd->hwndDrvList, &lviItem)) {
            DriverNode = GetDriverNodeFromLParam(pDeviceInfoSet, lpdd, lviItem.lParam);
        } else {
            DriverNode = NULL;
        }

        if (DriverNode) {

            //
            //Retrieve the HardwareId for the selected driver.
            //
            SelectedDriverHardwareId = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                                DriverNode->HardwareId
                                                               );

            for (i=0; !bRet, i<2; i++) {

                IDBufferLen = REGSTR_VAL_MAX_HCID_LEN;
                if (CM_Get_DevInst_Registry_Property_Ex(
                        DevInfoElem->DevInst,
                        (i ? CM_DRP_COMPATIBLEIDS : CM_DRP_HARDWAREID),
                        NULL,
                        IDBuffer,
                        &IDBufferLen,
                        0,
                        pDeviceInfoSet->hMachine) == CR_SUCCESS) {

                    //
                    //See if the HardwareID for the selected driver matches any of the
                    //Hardware or Compatible IDs for the actual hardware.
                    //
                    for (pID = IDBuffer; !bRet, *pID; pID += (lstrlen(pID) + 1)) {

                        if (lstrcmpi(SelectedDriverHardwareId, pID) == 0) {

                            bRet = TRUE;
                            break;
                        }
                    }

                    //
                    //See if any of the Compatible IDs for the selceted driver matches any
                    //of the Hardware or Compatible IDs for the actual hardware
                    //
                    for (j=0; !bRet, j<DriverNode->NumCompatIds; j++) {

                        SelectedDriverCompatibleId = pStringTableStringFromId(
                                        pDeviceInfoSet->StringTable,
                                        DriverNode->CompatIdList[j]);

                        for (pID = IDBuffer; !bRet, *pID; pID += (lstrlen(pID) + 1)) {

                            if (lstrcmpi(SelectedDriverCompatibleId, pID) == 0) {

                                bRet = TRUE;
                                break;
                            }
                        }
                    }

                } else {

                    FailCount++;
                }
            }

            //
            //If FailCount is 2 then CM_Get_DevInst_Registry_Property_Ex failed for both
            //CM_DRP_HARDWAREID and CM_DRP_COMPATIBLEIDS.  Since this DevNode does not
            //have any Hardware or Compatible IDs we will let the user install any
            //driver they want on this device.  This usually happens only with manually
            //installed devices.
            //
            if (FailCount == 2) {

                bRet = TRUE;
            }

            //
            // If bRet is FALSE at this point the none of the Hardware or Compatible Ids of
            // the selected driver node match any of the Hardware or Compatible Ids of the
            // actuall hardware.  We will do one last check here if this is a class driver.
            // We will see if this class driver node has the same description, install section,
            // and INF as a driver in the compatible list.  The reason for this is that we don't
            // handle duplicate descriptions well for class drivers since we don't compute their
            // Rank.  This means that if two driver nodes exist in an INF with the same description
            // we might not have the correct matching one in the class list.
            //
            if (!bRet && (!lpdd->bShowCompat)) {

                PDRIVER_NODE CurDriverNode = NULL;

                if (DevInfoElem) {

                    //
                    // Enumerate through all of the compatible driver nodes
                    //
                    for(CurDriverNode = DevInfoElem->CompatDriverHead;
                        CurDriverNode;
                        CurDriverNode = CurDriverNode->Next) {

                        if ((CurDriverNode->InfFileName == DriverNode->InfFileName) &&
                            (CurDriverNode->InfSectionName == DriverNode->InfSectionName) &&
                            (CurDriverNode->DrvDescription == DriverNode->DrvDescription)) {

                            //
                            // We found a node that matches ours in the compatible driver list so
                            // that means that this class dirver node is good.
                            //
                            bRet = TRUE;
                            break;
                        }
                    }
                }
            }

            //
            //The ID of the driver that the user selected does not match any of the Hardware or
            //Compatible IDs of this device. Warn the user that this is a bad thing and see if they
            //want to continue.
            //
            if (!bRet) {

                if(!LoadString(MyDllModuleHandle, IDS_DRIVER_UPDATE_TITLE, Title, LINE_LEN)) {
                    Title[0]=TEXT('\0');
                }

                MessageLen  = LoadString(MyDllModuleHandle, IDS_DRIVER_NOMATCH1, Message, SDT_MAX_TEXT);
                MessageLen += LoadString(MyDllModuleHandle, IDS_DRIVER_NOMATCH2, Message + MessageLen, SDT_MAX_TEXT - MessageLen);
                MessageLen += LoadString(MyDllModuleHandle, IDS_DRIVER_NOMATCH3, Message + MessageLen, SDT_MAX_TEXT - MessageLen);

                if(MessageLen) {

                    if (MessageBox(hWnd, Message, Title, MB_YESNO | MB_TASKMODAL | MB_ICONEXCLAMATION |
                            MB_DEFBUTTON2) == IDYES) {

                        bRet = TRUE;
                    }
                }
            }
        } else {

            //
            //I am not sure how we could get here and not have a DRIVER_NODE for the selected device.
            //Maybe a different error message needs to be displayed here.
            //
            bRet = TRUE;
        }

clean0:
        Err = NO_ERROR;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;   // nothing to do
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    if(StringBuffers) {
        MyFree(StringBuffers);
    }

    SetLastError(Err);
    return bRet;
}

PDRIVER_NODE
pSetupGetSelectedDriverNode(
    IN HWND           hWnd,
    IN PSP_DIALOGDATA lpdd,
    IN INT            iCur
    )
/*++

Routine Description:

Arguments:

    hwnd - Supplies the window handle of the wizard dialog page.

    ndwData - Supplies the address of a New Device Wizard data block to be used
        during the processing of this message.

    iCur - The index of the selected driver in the list view.

Return Value:


--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDRIVER_NODE DriverNode = NULL;
    LV_ITEM lviItem;
    PDEVINFO_ELEM DevInfoElem;

    //
    // If the DD_FLAG_USE_DEVINFO_ELEM flag is not set then this device did not have
    // we don't have a DevNode to validate the choosen ID against...so just return
    // TRUE.
    //
    MYASSERT(lpdd);
    if (!(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM))
        return NULL;

    if (!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return NULL;
    }

    try {

        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }

        lviItem.mask = LVIF_PARAM;
        lviItem.iItem = iCur;
        lviItem.iSubItem = 0;

        if(ListView_GetItem(lpdd->hwndDrvList, &lviItem)) {
            DriverNode = GetDriverNodeFromLParam(pDeviceInfoSet, lpdd, lviItem.lParam);
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;   // nothing to do
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    return DriverNode;
}

VOID
SetSelectedDriverNode(
    IN PSP_DIALOGDATA lpdd,
    IN INT            iCur
    )
/*++

Routine Description:

    This routine sets the selected driver for the currently selected device (or global
    class driver list if no device selected) in the device information set referenced
    in the SP_DIALOGDATA structure.  If the DD_FLAG_USE_DEVINFO_ELEM flag in the
    structure is set, then the driver is selected for the set or element based on the
    DevInfoElem pointer instead of the currently selected one.

Arguments:

    lpdd - Supplies the address of a dialog data structure that contains information
        about the device information set being used.

    iCur - Supplies the index within the driver listbox window containing the driver
        to be selected.

Return Value:

    None.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDRIVER_NODE DriverNode;
    LV_ITEM lviItem;
    PDEVINFO_ELEM DevInfoElem;
    TCHAR ClassGuidString[GUID_STRING_LEN];
    SP_DEVINFO_DATA DevInfoData;

    MYASSERT(lpdd);
    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return;
    }

    try {

        lviItem.mask = LVIF_PARAM;
        lviItem.iItem = iCur;
        lviItem.iSubItem = 0;

        if(ListView_GetItem(lpdd->hwndDrvList, &lviItem)) {
            DriverNode = GetDriverNodeFromLParam(pDeviceInfoSet, lpdd, lviItem.lParam);
        } else {
            DriverNode = NULL;
        }

        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }

        if(DevInfoElem) {
            //
            // If a driver node is being selected, update the device's class to ensure
            // it matches the class of the INF containing the selected driver node.
            //
            if(DriverNode) {
                //
                // Get the INF class GUID for this driver node in string form, because
                // this property is stored as a REG_SZ.
                //
                pSetupStringFromGuid(&(pDeviceInfoSet->GuidTable[DriverNode->GuidIndex]),
                                     ClassGuidString,
                                     SIZECHARS(ClassGuidString)
                                    );

                //
                // Fill in a SP_DEVINFO_DATA structure for the upcoming call to
                // SetupDiSetDeviceRegistryProperty.
                //
                DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
                DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                                 DevInfoElem,
                                                 &DevInfoData
                                                );

                if(!SetupDiSetDeviceRegistryProperty(lpdd->DevInfoSet,
                                                     &DevInfoData,
                                                     SPDRP_CLASSGUID,
                                                     (PBYTE)ClassGuidString,
                                                     sizeof(ClassGuidString))) {
                    //
                    // The class cannot be updated--don't change the selected driver.
                    //
                    goto clean0;
                }
            }

            DevInfoElem->SelectedDriver = DriverNode;
            if(DriverNode) {
                DevInfoElem->SelectedDriverType = (lpdd->bShowCompat)
                                                      ? SPDIT_COMPATDRIVER
                                                      : SPDIT_CLASSDRIVER;
            } else {
                DevInfoElem->SelectedDriverType = SPDIT_NODRIVER;
            }
        } else {
            pDeviceInfoSet->SelectedClassDriver = DriverNode;
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;   // nothing to do
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);
}


DWORD
HandleSelectOEM(
    IN     HWND           hwndDlg,
    IN OUT PNEWDEVWIZ_DATA ndwData
    )
/*++

Routine Description:

    This routine selects a new device based on a user-supplied path.  Calling this
    routine may cause a driver list to get built, which is a potentially slow operation.

Arguments:

    hwndDlg - Supplies the window handle of the select device wizard page.

    ndwData - Supplies the address of a New Device Wizard data block to be used
        during the processing of this message.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is an ERROR_* code.

--*/
{
    PSP_DIALOGDATA lpdd;
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    SP_DEVINFO_DATA DevInfoData;
    DWORD Err;

    MYASSERT(ndwData);
    lpdd = &(ndwData->ddData);

    MYASSERT(lpdd);
    if (!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return ERROR_INVALID_HANDLE;
    }

    try {

        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }

        //
        // If this is for a particular device, then initialize a device
        // information structure to use for SelectOEMDriver.
        //
        if(DevInfoElem) {

            DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
            DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                             DevInfoElem,
                                             &DevInfoData
                                            );
        }

        //
        // Unlock the device information set before popping up the OEM Driver Selection
        // UI.  Otherwise, our multi-threaded dialog will deadlock.
        //
        UnlockDeviceInfoSet(pDeviceInfoSet);
        pDeviceInfoSet = NULL;

        if((Err = SelectOEMDriver(hwndDlg,
                                  lpdd->DevInfoSet,
                                  DevInfoElem ? &DevInfoData : NULL,
                                  !(lpdd->flags & DD_FLAG_IS_DIALOGBOX)
                                 )) == ERROR_DI_DO_DEFAULT) {


            if(DevInfoElem && DevInfoElem->CompatDriverHead) {

                lpdd->bShowCompat = TRUE;

                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_COMPAT), SW_SHOW);

            } else {

                lpdd->bShowCompat = FALSE;

                //
                // Since we don't have any compatible drivers to show, we will hide the show compatible
                // and show class selection buttons.
                //
                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_COMPAT), SW_HIDE);
            }

            CheckDlgButton(hwndDlg,
                           IDC_NDW_PICKDEV_COMPAT,
                           lpdd->bShowCompat ? BST_CHECKED : BST_UNCHECKED
                           );

            //
            // Enable the UI.  We turned it off when the user pressed the Have Disk... button
            //
            ToggleDialogControls(hwndDlg, ndwData, TRUE);

            //
            // Fill in the list to select from
            //
            FillInDeviceList(hwndDlg, lpdd);
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = GetLastError();
        //
        // Access the pDeviceInfoSet variable so that the compiler will respect our statement
        // ordering w.r.t. this value.
        //
        pDeviceInfoSet = pDeviceInfoSet;
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    return Err;
}

#ifdef UNICODE

DWORD
SelectWindowsUpdateDriver(
    IN     HWND             hwndParent,     OPTIONAL
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN     PTSTR            CDMPath,
    IN     BOOL             IsWizard
    )
/*++

Routine Description:

    This is the worker routine that actually allows for the selection of an Windows Update driver.

Arguments:

    hwndParent - Optionally, supplies the window handle that is to be the parent for any
        selection UI.  If this parameter is not supplied, then the hwndParent field of
        the devinfo set or element will be used.

    DeviceInfoSet - Supplies the handle of the device info set for which an Windows Update driver
        selection is to be performed.

    DeviceInfoData - Optionally, supplies the address of the device information element to
        select a driver for.  If this parameter is not supplied, then an OEM driver for
        the global class driver list will be selected.

        If a compatible driver was found for this device, the device information element
        will have its class GUID updated upon return to reflect the device's new class.

    IsWizard - Specifies whether this routine is being called in the context of a select
        device wizard page.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is an ERROR_* code.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem = NULL;
    PDEVINSTALL_PARAM_BLOCK dipb;
    DWORD Err = NO_ERROR;
    HWND hwndSave;
    LONG DriverPathSave;
    DWORD DriverPathFlagsSave;
    BOOL bRestoreHwnd = FALSE, bRestoreDriverPath = FALSE, bUnlockDevInfoElem = FALSE;
    UINT NewClassDriverCount;
    TCHAR Title[MAX_TITLE_LEN];
    DWORD SavedFlags;
    DWORD SavedFlagsEx;

    PDRIVER_NODE lpOrgCompat;
    PDRIVER_NODE lpOrgCompatTail;
    UINT         OrgCompatCount;
    PDRIVER_NODE lpOrgClass;
    PDRIVER_NODE lpOrgClassTail;
    UINT         OrgClassCount;
    PDRIVER_NODE lpOrgSel;
    PDRIVER_NODE CurDriverNode;
    PDRIVER_NODE DriverNodeHead = NULL;
    DWORD        dwOrgSelType;
    DWORD        dwOrgFlags;
    DWORD        dwOrgFlagsEx;
    BOOL         bRestoreDeviceInfo = FALSE;
    LONG         DriverPathId;

    pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet);

    try {

        if(DeviceInfoData) {
            //
            // Then we're working with a particular device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }

            //
            // If the DevInfoElem isn't already locked, then lock it now, because
            // we're going to be calling the class installer, and we don't want to
            // allow it to delete this element!
            //
            if(!(DevInfoElem->DiElemFlags & DIE_IS_LOCKED)) {
                DevInfoElem->DiElemFlags |= DIE_IS_LOCKED;
                bUnlockDevInfoElem = TRUE;
            }

            dipb = &(DevInfoElem->InstallParamBlock);

        } else {
            dipb = &(pDeviceInfoSet->InstallParamBlock);
        }

        //
        // Make this selection window the parent window for Windows Update stuff
        //
        if(hwndParent) {
            hwndSave = dipb->hwndParent;
            dipb->hwndParent = hwndParent;
            bRestoreHwnd = TRUE;
        }

        //
        // Don't assume there is no old path.  Save old one and
        // pretend there is no old one in case of cancel.
        //
        DriverPathSave = dipb->DriverPath;
        dipb->DriverPath = -1;

        //
        // Clear the DI_ENUMSINGLEINF flag, because we're going to be getting
        // a path to a directory, _not_ to an individual INF.  Also, clear the
        // DI_COMPAT_FROM_CLASS flag, because we don't want to build the compatible
        // driver list based on any class driver list.
        //
        DriverPathFlagsSave = dipb->Flags & (DI_ENUMSINGLEINF | DI_COMPAT_FROM_CLASS);
        dipb->Flags &= ~(DI_ENUMSINGLEINF | DI_COMPAT_FROM_CLASS);
        bRestoreDriverPath = TRUE;

        //
        // Set the DriverPath to the path returned by CDM
        //
        if((DriverPathId = pStringTableAddString(
                                      pDeviceInfoSet->StringTable,
                                      CDMPath,
                                      STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                      NULL,0)) == -1) {

            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;

        } else {

            dipb->DriverPath = DriverPathId;

        }

        //
        // Save the Original List info, in case we get
        // an empty list on the Windows Update information.
        //
        // (Note: we don't attempt to save/restore our driver enumeration hints)
        //
        if(DevInfoElem) {
            lpOrgCompat     = DevInfoElem->CompatDriverHead;
            lpOrgCompatTail = DevInfoElem->CompatDriverTail;
            OrgCompatCount  = DevInfoElem->CompatDriverCount;

            lpOrgClass      = DevInfoElem->ClassDriverHead;
            lpOrgClassTail  = DevInfoElem->ClassDriverTail;
            OrgClassCount   = DevInfoElem->ClassDriverCount;

            lpOrgSel        = DevInfoElem->SelectedDriver;
            dwOrgSelType    = DevInfoElem->SelectedDriverType;
        } else {
            lpOrgClass      = pDeviceInfoSet->ClassDriverHead;
            lpOrgClassTail  = pDeviceInfoSet->ClassDriverTail;
            OrgClassCount   = pDeviceInfoSet->ClassDriverCount;

            lpOrgSel        = pDeviceInfoSet->SelectedClassDriver;
            dwOrgSelType    = lpOrgSel ? SPDIT_CLASSDRIVER : SPDIT_NODRIVER;
        }

        dwOrgFlags = dipb->Flags;
        dwOrgFlagsEx = dipb->FlagsEx;

        bRestoreDeviceInfo = TRUE;

        if(DevInfoElem) {
            DevInfoElem->CompatDriverHead = DevInfoElem->CompatDriverTail = NULL;
            DevInfoElem->CompatDriverCount = 0;
            DevInfoElem->CompatDriverEnumHint = NULL;
            DevInfoElem->CompatDriverEnumHintIndex = INVALID_ENUM_INDEX;

            DevInfoElem->ClassDriverHead = DevInfoElem->ClassDriverTail = NULL;
            DevInfoElem->ClassDriverCount = 0;
            DevInfoElem->ClassDriverEnumHint = NULL;
            DevInfoElem->ClassDriverEnumHintIndex = INVALID_ENUM_INDEX;

            DevInfoElem->SelectedDriver = NULL;
            DevInfoElem->SelectedDriverType = SPDIT_NODRIVER;
        } else {
            lpOrgCompat     = NULL; // just so we won't ever try to free this list.

            pDeviceInfoSet->ClassDriverHead = pDeviceInfoSet->ClassDriverTail = NULL;
            pDeviceInfoSet->ClassDriverCount = 0;
            pDeviceInfoSet->ClassDriverEnumHint = NULL;
            pDeviceInfoSet->ClassDriverEnumHintIndex = INVALID_ENUM_INDEX;

            pDeviceInfoSet->SelectedClassDriver = NULL;
        }

        SavedFlags = dipb->Flags & (DI_SHOWOEM | DI_NODI_DEFAULTACTION);
        SavedFlagsEx = dipb->FlagsEx & (DI_FLAGSEX_SHOWWINDOWSUPDATE);

        dipb->Flags   &= ~(DI_DIDCOMPAT | DI_DIDCLASS | DI_MULTMFGS | DI_SHOWOEM);
        dipb->FlagsEx &= ~(DI_FLAGSEX_DIDINFOLIST | DI_FLAGSEX_DIDCOMPATINFO | DI_FLAGSEX_SHOWWINDOWSUPDATE);

        if(IsWizard) {
            //
            // We don't want default action taken in the wizard case.
            //
            dipb->Flags |= DI_NODI_DEFAULTACTION;
        }

        //
        // Unlock the HDEVINFO before handling the Select Device.  Otherwise, our
        // multi-threaded dialog will deadlock!
        //
        UnlockDeviceInfoSet(pDeviceInfoSet);
        pDeviceInfoSet = NULL;

        if(_SetupDiCallClassInstaller(DIF_SELECTDEVICE,
                                      DeviceInfoSet,
                                      DeviceInfoData,
                                      CALLCI_LOAD_HELPERS | CALLCI_CALL_HELPERS)) {
            Err = NO_ERROR;
        } else {
            Err = GetLastError();
        }

        //
        // Now, re-acquire the lock on our device information set.
        //
        if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            //
            // should never hit this code path
            //
            MYASSERT(pDeviceInfoSet);
            if (Err == NO_ERROR) {
                Err = ERROR_INVALID_HANDLE;
            }
        }

        //
        // Restore the saved flags.
        //
        dipb->Flags = (dipb->Flags & ~(DI_SHOWOEM | DI_NODI_DEFAULTACTION)) | SavedFlags;
        dipb->FlagsEx = (dipb->FlagsEx & ~(DI_FLAGSEX_SHOWWINDOWSUPDATE)) | SavedFlagsEx;

        //
        // If the class installer returned ERROR_DI_DO_DEFAULT, then
        // they either did not process the DIF_SELECTDEVICE, or they
        // have setup our device info structure with an OEM INF.
        //
        switch(Err) {

            case ERROR_DI_DO_DEFAULT :
                //
                // This case is only handled if we're in a wizard.  Otherwise, send it down
                // for default processing.
                //
                if(!IsWizard) {
                    goto DefaultHandling;
                }

                //
                // This will be the most likely return, since we are not allowing the
                // default handler to be called.  So we will build a new class Drv list
                // If it is empty we will ask again, otherwise we will accept the new
                // selection and go on.
                //
                SetCursor(LoadCursor(NULL, IDC_WAIT));

                //
                // Any drivers we find are Internet drivers.
                //
                dipb->FlagsEx |= DI_FLAGSEX_INET_DRIVER;

                SetupDiBuildDriverInfoList(DeviceInfoSet,
                                           DeviceInfoData,
                                           SPDIT_CLASSDRIVER
                                          );

                dipb->FlagsEx &= ~DI_FLAGSEX_INET_DRIVER;

                SetCursor(LoadCursor(NULL, IDC_ARROW));

                if(DevInfoElem) {
                    NewClassDriverCount = DevInfoElem->ClassDriverCount;
                    DriverNodeHead = DevInfoElem->ClassDriverHead;
                } else {
                    NewClassDriverCount = pDeviceInfoSet->ClassDriverCount;
                    DriverNodeHead = pDeviceInfoSet->ClassDriverHead;
                }

                if(NewClassDriverCount) {
                    //
                    //
                    //
                    if (DriverNodeHead) {
                        for (CurDriverNode=DriverNodeHead;
                             CurDriverNode;
                             CurDriverNode = CurDriverNode->Next) {

                            CurDriverNode->Flags |= DNF_INF_IS_SIGNED;
                        }
                    }
                } else {
                    //
                    // Error.
                    //
                    if(!LoadString(MyDllModuleHandle,
                                   IDS_SELECT_DEVICE,
                                   Title,
                                   SIZECHARS(Title))) {
                        *Title = TEXT('\0');
                    }

                    FormatMessageBox(MyDllModuleHandle,
                                     NULL,
                                     MSG_NO_DEVICEINFO_ERROR,
                                     Title,
                                     MB_OK | MB_TASKMODAL
                                    );


                    //
                    // Clean up anything that happened to get put in here.
                    //
                    if(DevInfoElem &&
                       (DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_DIDCOMPATINFO)) {
                        //
                        // The class installer built a compatible driver list--kill it here.
                        //
                        DestroyDriverNodes(DevInfoElem->CompatDriverHead, pDeviceInfoSet);

                        DevInfoElem->CompatDriverHead = DevInfoElem->CompatDriverTail = NULL;
                        DevInfoElem->CompatDriverCount = 0;
                        DevInfoElem->InstallParamBlock.Flags   &= ~DI_DIDCOMPAT;
                        DevInfoElem->InstallParamBlock.FlagsEx &= ~DI_FLAGSEX_DIDCOMPATINFO;

                        DevInfoElem->SelectedDriver = NULL;
                        DevInfoElem->SelectedDriverType = SPDIT_NODRIVER;
                    }
                    dipb->DriverPath = -1;

                    break;
                }
                //
                // Allow to fall through to handling of NO_ERROR which does clean-up for us.
                //

            case NO_ERROR :
                //
                // Destroy the original lists
                //
                if(bRestoreDeviceInfo) {
                    DestroyDriverNodes(lpOrgCompat, pDeviceInfoSet);
                    DereferenceClassDriverList(pDeviceInfoSet, lpOrgClass);

                    bRestoreDeviceInfo = FALSE;
                }

                bRestoreDriverPath = FALSE;
                break;

            case ERROR_DI_BAD_PATH :
                //
                // Pop up an error messagebox, and then leave
                //
                if(!LoadString(MyDllModuleHandle,
                               IDS_SELECT_DEVICE,
                               Title,
                               SIZECHARS(Title))) {
                    *Title = TEXT('\0');
                }

                FormatMessageBox(MyDllModuleHandle,
                                 NULL,
                                 MSG_NO_DEVICEINFO_ERROR,
                                 Title,
                                 MB_OK | MB_TASKMODAL
                                );

                dipb->DriverPath = -1;

                //
                // Allow to fall through to default processing to delete the current
                // driver list(s).
                //

            default :
DefaultHandling:
                //
                // Destroy the current driver list(s).
                //
                if(DevInfoElem) {

                    DestroyDriverNodes(DevInfoElem->CompatDriverHead, pDeviceInfoSet);
                    DevInfoElem->CompatDriverHead = DevInfoElem->CompatDriverTail = NULL;
                    DevInfoElem->CompatDriverCount = 0;

                    DereferenceClassDriverList(pDeviceInfoSet, DevInfoElem->ClassDriverHead);
                    DevInfoElem->ClassDriverHead = DevInfoElem->ClassDriverTail = NULL;
                    DevInfoElem->ClassDriverCount = 0;

                    DevInfoElem->SelectedDriver = NULL;
                    DevInfoElem->SelectedDriverType = SPDIT_NODRIVER;

                } else {

                    DereferenceClassDriverList(pDeviceInfoSet, pDeviceInfoSet->ClassDriverHead);
                    pDeviceInfoSet->ClassDriverHead = pDeviceInfoSet->ClassDriverTail = NULL;
                    pDeviceInfoSet->ClassDriverCount = 0;

                    pDeviceInfoSet->SelectedClassDriver = NULL;
                }
            }

clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = GetLastError();
        //
        // Access the following variables so that the compiler will respect
        // the statement ordering in the try clause.
        //
        bRestoreDeviceInfo = bRestoreDeviceInfo;
        bUnlockDevInfoElem = bUnlockDevInfoElem;
        bRestoreHwnd = bRestoreHwnd;
        bRestoreDriverPath = bRestoreDriverPath;
        pDeviceInfoSet = pDeviceInfoSet;
    }

    //
    // If we need to restore any state, then we must make sure that we have the HDEVINFO
    // locked.
    //
    if(bRestoreDeviceInfo || bUnlockDevInfoElem || bRestoreHwnd || bRestoreDriverPath) {

        if(!pDeviceInfoSet && !(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            //
            // should never hit this code path
            //
            MYASSERT(pDeviceInfoSet);
        } else {
            try {
                //
                // If necessary, restore the original list(s).
                //
                if(bRestoreDeviceInfo) {

                    if(DevInfoElem) {

                        DestroyDriverNodes(DevInfoElem->CompatDriverHead, pDeviceInfoSet);
                        DevInfoElem->CompatDriverHead = lpOrgCompat;
                        DevInfoElem->CompatDriverTail = lpOrgCompatTail;
                        DevInfoElem->CompatDriverCount = OrgCompatCount;
                        lpOrgCompat = NULL;

                        DereferenceClassDriverList(pDeviceInfoSet, DevInfoElem->ClassDriverHead);
                        DevInfoElem->ClassDriverHead = lpOrgClass;
                        DevInfoElem->ClassDriverTail = lpOrgClassTail;
                        DevInfoElem->ClassDriverCount = OrgClassCount;
                        lpOrgClass = NULL;

                        DevInfoElem->SelectedDriver = lpOrgSel;
                        DevInfoElem->SelectedDriverType = dwOrgSelType;

                    } else {

                        DereferenceClassDriverList(pDeviceInfoSet, pDeviceInfoSet->ClassDriverHead);
                        pDeviceInfoSet->ClassDriverHead = lpOrgClass;
                        pDeviceInfoSet->ClassDriverTail = lpOrgClassTail;
                        pDeviceInfoSet->ClassDriverCount = OrgClassCount;
                        lpOrgClass = NULL;

                        pDeviceInfoSet->SelectedClassDriver = lpOrgSel;
                    }

                    dipb->Flags = dwOrgFlags;
                    dipb->FlagsEx = dwOrgFlagsEx;
                }

                //
                // If we locked the DevInfoElem just for this API, then unlock it now.
                //
                if(bUnlockDevInfoElem) {
                    MYASSERT(DevInfoElem);
                    DevInfoElem->DiElemFlags &= ~DIE_IS_LOCKED;
                }

                //
                // If the install param block needs its parent hwnd restored, do so now.
                //
                if(bRestoreHwnd) {
                    dipb->hwndParent = hwndSave;
                }

                //
                // Likewise, restore the old driver path if necessary.
                //
                if(bRestoreDriverPath) {
                    dipb->DriverPath = DriverPathSave;
                    dipb->Flags |= DriverPathFlagsSave;
                }

                ;   // nothing to do

            } except(EXCEPTION_EXECUTE_HANDLER) {

                if(bRestoreDeviceInfo) {
                    //
                    // If we hit an exception before we got a chance to restore any of our stored-away
                    // driver lists, then clean those up here.
                    //
                    if(DevInfoElem) {
                        if(lpOrgCompat) {
                            DestroyDriverNodes(lpOrgCompat, pDeviceInfoSet);
                        }
                        if(lpOrgClass) {
                            DereferenceClassDriverList(pDeviceInfoSet, lpOrgClass);
                        }
                    } else {
                        if(lpOrgClass) {
                            DereferenceClassDriverList(pDeviceInfoSet, lpOrgClass);
                        }
                    }
                }
            }
        }
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    return Err;
}

DWORD
HandleWindowsUpdate(
    IN     HWND            hwndDlg,
    IN OUT PNEWDEVWIZ_DATA ndwData
    )
/*++

Routine Description:

    This routine selects a new driver based on a list from INF file(s) that get
    downloaded from the Windows Update Internet site.

Arguments:

    hwndDlg - Supplies the window handle of the select device wizard page.

    ndwData - Supplies the address of a New Device Wizard data block to be used
        during the processing of this message.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is an ERROR_* code.

--*/
{
    PSP_DIALOGDATA lpdd;
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINSTALL_PARAM_BLOCK dipb;
    SP_WINDOWSUPDATE_PARAMS WindowsUpdateParams;
    PDEVINFO_ELEM DevInfoElem;
    SP_DEVINFO_DATA DevInfoData;
    TCHAR CDMPath[MAX_PATH];
    ULONG BufferLen;
    DOWNLOADINFO DownloadInfo;
    HMODULE hModCDM;
    DOWNLOAD_UPDATED_FILES_PROC DownloadUpdateFilesProc;
    DWORD Err;
    TCHAR Title[MAX_TITLE_LEN];
    SPFUSIONINSTANCE spFusionInstance;

    MYASSERT(ndwData);
    lpdd = &(ndwData->ddData);

    MYASSERT(lpdd);

    pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet);

    try {

        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }

        //
        // If this is for a particular device, then initialize a device
        // information structure.
        //
        if(DevInfoElem) {

            DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
            DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                             DevInfoElem,
                                             &DevInfoData
                                            );
            dipb = &(DevInfoElem->InstallParamBlock);

        } else {

            dipb = &(pDeviceInfoSet->InstallParamBlock);
        }

        //
        // Call the class installer to get the package ID and so it can open
        // a handle to the Windows Update server.
        //
        memset(&WindowsUpdateParams, 0, sizeof(SP_WINDOWSUPDATE_PARAMS));
        WindowsUpdateParams.ClassInstallHeader.InstallFunction = DIF_GETWINDOWSUPDATEINFO;
        WindowsUpdateParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);

        if ((Err = DoInstallActionWithParams(DIF_GETWINDOWSUPDATEINFO,
                                             pDeviceInfoSet,
                                             DevInfoElem ? &DevInfoData : NULL,
                                             &WindowsUpdateParams.ClassInstallHeader,
                                             sizeof(SP_WINDOWSUPDATE_PARAMS),
                                             INSTALLACTION_CALL_CI)) == NO_ERROR) {


            //
            // We now have a PackageId and a handle to the Windows Update server
            //

            //
            // Fill In the DOWNLOADINFO structure to pass to CDM.DLL
            //
            ZeroMemory(&DownloadInfo, sizeof(DOWNLOADINFO));
            DownloadInfo.dwDownloadInfoSize = sizeof(DOWNLOADINFO);
            DownloadInfo.lpFile = NULL;

            DownloadInfo.lpHardwareIDs = (LPCWSTR)WindowsUpdateParams.PackageId;

            DownloadInfo.lpDeviceInstanceID = NULL;

            GetVersionEx((OSVERSIONINFOW *)&DownloadInfo.OSVersionInfo);

            //
            // Set dwArchitecture to PROCESSOR_ARCHITECTURE_UNKNOWN, this
            // causes Windows Update to check get the architecture of the
            // machine itself.  You only need to explictly set the value if
            // you want to download drivers for a different architecture then
            // the machine this is running on.
            //
            DownloadInfo.dwArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;
            DownloadInfo.dwFlags = 0;
            DownloadInfo.dwClientID = 0;
            DownloadInfo.localid = 0;

            CDMPath[0] = TEXT('\0');

            spFusionEnterContext(NULL,&spFusionInstance);
            if ((hModCDM = LoadLibrary(TEXT("cdm.dll"))) &&
                (DownloadUpdateFilesProc = (PVOID)GetProcAddress(hModCDM, "DownloadUpdatedFiles")) &&
                (DownloadUpdateFilesProc(WindowsUpdateParams.CDMContext,
                                         hwndDlg,
                                         &DownloadInfo,
                                         CDMPath,
                                         sizeof(CDMPath),
                                         &BufferLen)) &&

                (CDMPath[0] != TEXT('\0'))) {

                //
                // We successfully downloaded a package from Windows Update
                //
                spFusionLeaveContext(&spFusionInstance);

                //
                // Unlock the device information set before popping up the OEM Driver Selection
                // UI.  Otherwise, our multi-threaded dialog will deadlock.
                //

                UnlockDeviceInfoSet(pDeviceInfoSet);
                pDeviceInfoSet = NULL;

                if((Err = SelectWindowsUpdateDriver(hwndDlg,
                                              lpdd->DevInfoSet,
                                              DevInfoElem ? &DevInfoData : NULL,
                                              CDMPath,
                                              !(lpdd->flags & DD_FLAG_IS_DIALOGBOX)
                                             )) == ERROR_DI_DO_DEFAULT) {
                    //
                    // Fill in the list to select from
                    //
                    lpdd->bShowCompat = FALSE;
                    CheckDlgButton(hwndDlg,
                                   IDC_NDW_PICKDEV_COMPAT,
                                   BST_UNCHECKED
                                   );

                    //
                    // Enable the UI.  We turned it off when the user pressed the Windows Update... button
                    //
                    ToggleDialogControls(hwndDlg, ndwData, TRUE);

                    FillInDeviceList(hwndDlg, lpdd);

                    //
                    // Since we only show the class list when selecting from
                    // Windows Update, hide the selection buttons.
                    //
                    ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_COMPAT), SW_HIDE);
                }

            }  else {

                spFusionLeaveContext(&spFusionInstance);
                //
                // Something failed when we tried to download the INF from the Internet
                //
                Err = ERROR_INVALID_PARAMETER;

                //
                // Pop up an error messagebox, then go try again.
                //
                if(!LoadString(MyDllModuleHandle,
                               IDS_SELECT_DEVICE,
                               Title,
                               SIZECHARS(Title))) {
                    *Title = TEXT('\0');
                }

                FormatMessageBox(MyDllModuleHandle,
                                 NULL,
                                 MSG_NO_DEVICEINFO_ERROR,
                                 Title,
                                 MB_OK | MB_TASKMODAL
                                );
            }

            if (hModCDM) {

                spFusionEnterContext(NULL,&spFusionInstance);
                FreeLibrary(hModCDM);
                spFusionLeaveContext(&spFusionInstance);
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = GetLastError();
        //
        // Access the pDeviceInfoSet variable so that the compiler will respect our statement
        // ordering w.r.t. this value.
        //
        pDeviceInfoSet = pDeviceInfoSet;
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    return Err;
}
#else

DWORD
HandleWindowsUpdate(
    IN     HWND            hwndDlg,
    IN OUT PNEWDEVWIZ_DATA ndwData
    )
{
    return ERROR_INVALID_PARAMETER;
}


#endif

PNEWDEVWIZ_DATA
GetNewDevWizDataFromPsPage(
    LPPROPSHEETPAGE ppsp
    )
/*++

Routine Description:

    This routine retrieves a pointer to a NEWDEVWIZDATA structure to be used by a
    wizard page dialog proc.  It is called during the WM_INITDIALOG handling.

Arguments:

    Page - Property sheet page structure for this wizard page.

Return Value:

    If success, a pointer to the structure, NULL otherwise.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PVOID WizObjectId;
    PWIZPAGE_OBJECT CurWizObject = NULL;

    //
    // Access the device info set handle stored in the propsheetpage's lParam.
    //
    MYASSERT(ppsp);
    if(pDeviceInfoSet = AccessDeviceInfoSet((HDEVINFO)(ppsp->lParam))) {

        try {
            //
            // The ObjectID (pointer, actually) for the corresponding wizard
            // object for this page is stored at the end of the ppsp structure.
            // Retrieve this now, and look for it in the devinfo set's list of
            // wizard objects.
            //
            WizObjectId = *((PVOID *)(&(((PBYTE)ppsp)[sizeof(PROPSHEETPAGE)])));

            for(CurWizObject = pDeviceInfoSet->WizPageList;
                CurWizObject;
                CurWizObject = CurWizObject->Next) {

                if(WizObjectId == CurWizObject) {
                    //
                    // We found our object.
                    //
                    break;
                }
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            ;   // nothing to do
        }

        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    return CurWizObject ? CurWizObject->ndwData : NULL;
}


BOOL
WINAPI
SetupDiSelectDevice(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )
/*++

Routine Description:

    Default handler for DIF_SELECTDEVICE

    This routine will handle the UI for allowing a user to select a driver
    for the specified device information set or element. By using the Flags field
    of the installation parameter block struct, the caller can specify special
    handling of the UI, such as allowing selecting from OEM disks.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set for which a
        driver is to be selected.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure for which a driver is to be selected.  If this parameter is not
        specified, then a driver will be selected for the global class driver list
        associated with the device information set itself.

        This is an IN OUT parameter because the class GUID for the device will be
        updated to reflect the class of the most-compatible driver, if a compatible
        driver list was built.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem = NULL;
    PDEVINSTALL_PARAM_BLOCK dipb;
    WIZPAGE_OBJECT WizPageObject;
    NEWDEVWIZ_DATA ndwData;
    PWIZPAGE_OBJECT CurWizObject, PrevWizObject;
    //
    // Store the address of the corresponding wizard object at the
    // end of the PROPSHEETPAGE buffer.
    //
    BYTE pspBuffer[sizeof(PROPSHEETPAGE) + sizeof(PVOID)];
    LPPROPSHEETPAGE Page = (LPPROPSHEETPAGE)pspBuffer;

    //
    // Make sure we're running interactively.
    //
    if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
        SetLastError(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION);
        return FALSE;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {
        //
        // This routine cannot be called when the lock level is nested (i.e., > 1).  This
        // is explicitly disallowed, so that our multi-threaded dialog won't deadlock.
        //
        if(pDeviceInfoSet->LockRefCount > 1) {
            Err = ERROR_DEVINFO_LIST_LOCKED;
            goto clean0;
        }

        if(DeviceInfoData) {
            //
            // Special check to make sure we aren't being passed a zombie (different from
            // phantom, the zombie devinfo element is one whose corresponding devinst was
            // deleted via SetupDiRemoveDevice, but who lingers on until the caller kills
            // it via SetupDiDeleteDeviceInfo or SetupDiDestroyDeviceInfoList).
            //
            if(!DeviceInfoData->DevInst) {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }

            //
            // Then we are to select a driver for a particular device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }

            dipb = &(DevInfoElem->InstallParamBlock);
        } else {
            dipb = &(pDeviceInfoSet->InstallParamBlock);
        }

        ZeroMemory(&ndwData, sizeof(ndwData));
        ndwData.ddData.iCurDesc = -1;
        ndwData.ddData.DevInfoSet = DeviceInfoSet;
        ndwData.ddData.DevInfoElem = DevInfoElem;
        ndwData.ddData.flags = DD_FLAG_USE_DEVINFO_ELEM | DD_FLAG_IS_DIALOGBOX;

        WizPageObject.RefCount = 1;
        WizPageObject.ndwData = &ndwData;
        //
        // We're safe in placing this stack object in the devinfo set's linked
        // list, since nobody will ever attempt to free it.
        //
        WizPageObject.Next = pDeviceInfoSet->WizPageList;
        pDeviceInfoSet->WizPageList = &WizPageObject;

        //
        // Since we're using the same code as the Add New Device Wizard, we
        // have to supply a LPROPSHEETPAGE as the lParam to the DialogProc.
        // (All we care about is the lParam field, and the DWORD at the end
        // of the buffer.)
        //
        Page->lParam = (LPARAM)DeviceInfoSet;

        *((PVOID *)(&(pspBuffer[sizeof(PROPSHEETPAGE)]))) = &WizPageObject;

        //
        // Release the lock, so other stuff can happen while this dialog is up.
        //
        UnlockDeviceInfoSet(pDeviceInfoSet);
        pDeviceInfoSet = NULL;

        Err = (DWORD)DialogBoxParam(MyDllModuleHandle,
                                    MAKEINTRESOURCE(DLG_DEVINSTALL),
                                    dipb->hwndParent,
                                    SelectDeviceDlgProc,
                                    (LPARAM)Page
                                   );

        //
        // Re-acquire the devinfo set lock.
        //
        if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            //
            // should never hit this code path
            // this would imply another thread messed this handle up
            //
            MYASSERT(pDeviceInfoSet);
            Err = ERROR_INVALID_HANDLE;
            goto clean0;
        }

        //
        // Now remove the wizard page object from the devinfo set's list.  We can't
        // assume that it's still at the head of the list, since someone else couldn've
        // added another page.
        //
        for(CurWizObject = pDeviceInfoSet->WizPageList, PrevWizObject = NULL;
            CurWizObject;
            PrevWizObject = CurWizObject, CurWizObject = CurWizObject->Next) {

            if(CurWizObject == &WizPageObject) {
                break;
            }
        }

        MYASSERT(CurWizObject);

        if(PrevWizObject) {
            PrevWizObject->Next = CurWizObject->Next;
        } else {
            pDeviceInfoSet->WizPageList = CurWizObject->Next;
        }

        if(DeviceInfoData) {
            //
            // Update the caller's device information element with its (potentially) new class.
            //
            DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                             DevInfoElem,
                                             DeviceInfoData
                                            );
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        //
        // Access the pDeviceInfoSet variable so that the compiler will respect
        // the statement ordering in the try clause.
        //
        pDeviceInfoSet = pDeviceInfoSet;
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
bNoDevsToShow(
    IN PDEVINFO_ELEM DevInfoElem
    )
/*++

Routine Description:

    This routine determines whether or not there are any compatible devices to be
    displayed for the specified devinfo element.

Arguments:

    DevInfoElem - Supplies the address of a devinfo element to check.

Return Value:

    If there are no devices to show, the return value is TRUE.
    If there is at least one device (driver node) without the DNF_EXCLUDEFROMLIST flag
    set, the return value is FALSE.

--*/
{
    PDRIVER_NODE CurDriverNode;

    for(CurDriverNode = DevInfoElem->CompatDriverHead;
        CurDriverNode;
        CurDriverNode = CurDriverNode->Next) {

        if (!(CurDriverNode->Flags & DNF_OLD_INET_DRIVER) &&
            !(CurDriverNode->Flags & DNF_BAD_DRIVER) &&
            (!(CurDriverNode->Flags & DNF_EXCLUDEFROMLIST) ||
            (DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_ALLOWEXCLUDEDDRVS))) {

            return FALSE;
        }
    }

    return TRUE;
}


VOID
OnCancel(
    IN PNEWDEVWIZ_DATA ndwData
    )
/*++

Routine Description:

    This routine is only called in the select device dialog (not wizard) case.  Its
    sole purpose is to destroy any driver lists that weren't present before
    SetupDiSelectDevice was called.

Arguments:

    ndwData - Supplies the address of a data structure containing information on the
        driver lists to be (possibly) destroyed.

Return Value:

    None.

--*/
{
    PSP_DIALOGDATA lpdd;
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    PDEVINSTALL_PARAM_BLOCK dipb;
    DWORD SelectedDriverType = SPDIT_NODRIVER;

    MYASSERT(ndwData);
    lpdd = &(ndwData->ddData);

    MYASSERT(lpdd);
    if (!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return;
    }

    try {

        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }

        if(DevInfoElem) {

            if(lpdd->bKeeplpSelectedDrv) {
                SelectedDriverType = DevInfoElem->SelectedDriverType;
            } else {
                DevInfoElem->SelectedDriver = NULL;
                DevInfoElem->SelectedDriverType = SPDIT_NODRIVER;
            }

            if((DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_DIDINFOLIST) &&
               !lpdd->bKeeplpClassDrvList && (SelectedDriverType != SPDIT_CLASSDRIVER)) {

                DereferenceClassDriverList(pDeviceInfoSet, DevInfoElem->ClassDriverHead);
                DevInfoElem->ClassDriverHead = DevInfoElem->ClassDriverTail = NULL;
                DevInfoElem->ClassDriverCount = 0;
                DevInfoElem->ClassDriverEnumHint = NULL;
                DevInfoElem->ClassDriverEnumHintIndex = INVALID_ENUM_INDEX;
                DevInfoElem->InstallParamBlock.Flags   &= ~(DI_DIDCLASS | DI_MULTMFGS);
                DevInfoElem->InstallParamBlock.FlagsEx &= ~DI_FLAGSEX_DIDINFOLIST;
            }

            if((DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_DIDCOMPATINFO) &&
               !lpdd->bKeeplpCompatDrvList && (SelectedDriverType != SPDIT_COMPATDRIVER)) {

                DestroyDriverNodes(DevInfoElem->CompatDriverHead, pDeviceInfoSet);
                DevInfoElem->CompatDriverHead = DevInfoElem->CompatDriverTail = NULL;
                DevInfoElem->CompatDriverCount = 0;
                DevInfoElem->CompatDriverEnumHint = NULL;
                DevInfoElem->CompatDriverEnumHintIndex = INVALID_ENUM_INDEX;
                DevInfoElem->InstallParamBlock.Flags   &= ~DI_DIDCOMPAT;
                DevInfoElem->InstallParamBlock.FlagsEx &= ~DI_FLAGSEX_DIDCOMPATINFO;
            }

        } else {

            if(lpdd->bKeeplpSelectedDrv) {
                if(pDeviceInfoSet->SelectedClassDriver) {
                    SelectedDriverType = SPDIT_CLASSDRIVER;
                }
            } else {
                pDeviceInfoSet->SelectedClassDriver = NULL;
            }

            if((pDeviceInfoSet->InstallParamBlock.FlagsEx & DI_FLAGSEX_DIDINFOLIST) &&
               !lpdd->bKeeplpClassDrvList && (SelectedDriverType != SPDIT_CLASSDRIVER)) {

                DereferenceClassDriverList(pDeviceInfoSet, pDeviceInfoSet->ClassDriverHead);
                pDeviceInfoSet->ClassDriverHead = pDeviceInfoSet->ClassDriverTail = NULL;
                pDeviceInfoSet->ClassDriverCount = 0;
                pDeviceInfoSet->ClassDriverEnumHint = NULL;
                pDeviceInfoSet->ClassDriverEnumHintIndex = INVALID_ENUM_INDEX;
                pDeviceInfoSet->InstallParamBlock.Flags   &= ~(DI_DIDCLASS | DI_MULTMFGS);
                pDeviceInfoSet->InstallParamBlock.FlagsEx &= ~DI_FLAGSEX_DIDINFOLIST;
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;   // nothing to do
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);
}


LONG
GetCurDesc(
    IN PSP_DIALOGDATA lpdd
    )
/*++

Routine Description:

    This routine returns the (case-insensitive) string table index for the description
    of the currently selected driver.  This is used to select a particular entry in a
    listview control.

Arguments:

    lpdd - Supplies the address of a dialog data structure that contains information
        about the device information set being used.

Return Value:

    The string table ID for the device description, as stored in the currently-selected
    driver node.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    LONG ret;

    MYASSERT(lpdd);
    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return -1;
    }

    try {

        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }

        if(DevInfoElem) {
            ret = DevInfoElem->SelectedDriver
                      ? DevInfoElem->SelectedDriver->DevDescription
                      : -1;
        } else {
            ret = pDeviceInfoSet->SelectedClassDriver
                      ? pDeviceInfoSet->SelectedClassDriver->DevDescription
                      : -1;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        ret = -1;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    return ret;
}


VOID
__cdecl
ClassDriverSearchThread(
    IN PVOID Context
    )

/*++

Routine Description:

    Thread entry point to build a class driver list asynchronously to the main
    thread which is displaying a Select Device dialog.  This thread will free
    the memory containing its context, so the main thread should not access it
    after passing it to this thread.

Arguments:

    Context - supplies driver search context.

Return Value:

    None.

--*/

{
    PCLASSDRV_THREAD_CONTEXT ClassDrvThreadContext = Context;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    BOOL b;
    DWORD Err;

    //
    // OR in the DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS flag so that we don't include
    // old internet drivers in the list that we get back.
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (SetupDiGetDeviceInstallParams(ClassDrvThreadContext->DeviceInfoSet,
                                      &(ClassDrvThreadContext->DeviceInfoData),
                                      &DeviceInstallParams
                                      ))
    {
        DeviceInstallParams.FlagsEx |= DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS;

        SetupDiSetDeviceInstallParams(ClassDrvThreadContext->DeviceInfoSet,
                                      &(ClassDrvThreadContext->DeviceInfoData),
                                      &DeviceInstallParams
                                      );
    }

    if(b = SetupDiBuildDriverInfoList(ClassDrvThreadContext->DeviceInfoSet,
                                      &(ClassDrvThreadContext->DeviceInfoData),
                                      SPDIT_CLASSDRIVER)) {
        Err = NO_ERROR;
    } else {
        Err = GetLastError();
    }

    //
    // Now send a message to our notification window informing them of the outcome.
    //
    PostMessage(ClassDrvThreadContext->NotificationWindow,
                WMX_CLASSDRVLIST_DONE,
                (WPARAM)b,
                (LPARAM)Err
               );

    MyFree(Context);

    //
    // Done.
    //
    _endthread();
}


BOOL
pSetupIsClassDriverListBuilt(
    IN PSP_DIALOGDATA lpdd
    )
/*++

Routine Description:

    This routine determines whether or not a class driver list has already been
    built for the specified dialog data.

Arguments:

    lpdd - Supplies the address of a dialog data buffer that is being queried for
        the presence of a class driver list.

Return Value:

    If a class driver list has already been built, the return value is TRUE, otherwise,
    it is FALSE.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    BOOL b = FALSE;

    MYASSERT(lpdd);
    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return FALSE;
    }

    try {

        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }

        if(DevInfoElem) {
            b = DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_DIDINFOLIST;
        } else {
            b = pDeviceInfoSet->InstallParamBlock.FlagsEx & DI_FLAGSEX_DIDINFOLIST;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;   // nothing to do.
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    return b;
}


VOID
pSetupDevInfoDataFromDialogData(
    IN  PSP_DIALOGDATA   lpdd,
    OUT PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    This routine fills in a SP_DEVINFO_DATA structure based on the device information
    element specified in the supplied dialog data.

Arguments:

    lpdd - Supplies the address of a dialog data buffer that specifies a devinfo element
        to be used in filling in the DeviceInfoData buffer.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure that is filled
        in with information about the devinfo element specified in the dialog data.

Return Value:

    None.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;

    MYASSERT(lpdd);
    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return;
    }

    try {

        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }

        //
        // The dialog data had better be referencing a devinfo element!
        //
        MYASSERT(DevInfoElem);

        DeviceInfoData->cbSize = sizeof(SP_DEVINFO_DATA);
        DevInfoDataFromDeviceInfoElement(pDeviceInfoSet, DevInfoElem, DeviceInfoData);

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // What to do, what to do???
        // We'll just invalidate the DeviceInfoData structure.
        //
        DeviceInfoData->cbSize = 0;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);
}

VOID
CleanupDriverLists(
    IN OUT PNEWDEVWIZ_DATA ndwData
    )
/*++

Routine Description:

    This routine will destroy both the class and compatible driver lists that were
    created while the wizard page was up.

Arguments:

    ndwData - Supplies the address of a New Device Wizard data block to be used
        during the processing of this message.

Return Value:

    None.

--*/
{
    PSP_DIALOGDATA lpdd;
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    PDEVINSTALL_PARAM_BLOCK dipb;
    SP_DEVINFO_DATA DeviceInfoData;

    MYASSERT(ndwData);
    lpdd = &(ndwData->ddData);

    MYASSERT(lpdd);
    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return;
    }

    try {

        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }

        if (DevInfoElem) {

            //
            // Initialize a SP_DEVINFO_DATA buffer to use as an argument to
            // SetupDiDestroyDriverInfoList.
            //
            DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
            DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                             DevInfoElem,
                                             &DeviceInfoData
                                            );

            //
            // We need to reset the DriverPath so that if we come back into the wizard
            // we will rebuild from the correct directory.  Otherwise we will be stuck
            // with the Have Disk... path that the user entered.
            //
            DevInfoElem->InstallParamBlock.DriverPath = -1;

        } else {

            pDeviceInfoSet->InstallParamBlock.DriverPath = -1;
        }

        SetupDiDestroyDriverInfoList(pDeviceInfoSet,
                                     DevInfoElem ? &DeviceInfoData : NULL,
                                     SPDIT_COMPATDRIVER
                                    );

        SetupDiDestroyDriverInfoList(pDeviceInfoSet,
                                     DevInfoElem ? &DeviceInfoData : NULL,
                                     SPDIT_CLASSDRIVER
                                    );


    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;   // nothing to do.
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);
}

VOID
ToggleDialogControls(
    IN HWND                hwndDlg,
    IN OUT PNEWDEVWIZ_DATA ndwData,
    IN BOOL                Enable
    )
/*++

Routine Description:

    This routine either enables or disables all controls on a Select Device dialog box,
    depending on the value of Enable.

Arguments:

    hwndDlg - Supplies the handle of the Select Device dialog

    ndwData - Supplies the address of a New Device Wizard data block to be used
        during the processing of this message.

    Enable - If TRUE, then enable all controls (with possible exception of "Show all devices"
        radio button (if class list search failed).  If FALSE, disable all controls.

Return Value:

    None.

--*/
{
    //
    // If we're enabling controls, make sure we only enable the "Show compatible
    // drivers" check box if we successfully built a class list.
    //
    if(Enable) {
        if(!((ndwData->ddData).flags & DD_FLAG_CLASSLIST_FAILED)) {
            EnableWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_COMPAT), TRUE);
        } else {
            //
            // The class list failed to build, so we will show the compatible
            // list only.  Check and disable the show compatible check box.
            //
            (ndwData->ddData).bShowCompat = TRUE;
            CheckDlgButton(hwndDlg, IDC_NDW_PICKDEV_COMPAT, BST_CHECKED);
            EnableWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_COMPAT), FALSE);
        }
    } else {
        EnableWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_COMPAT), FALSE);
    }

    EnableWindow((ndwData->ddData).hwndDrvList, Enable);
    EnableWindow((ndwData->ddData).hwndMfgList, Enable);

    EnableWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_HAVEDISK), Enable);
    EnableWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_WINDOWSUPDATE), Enable);

    EnableWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_ICON), Enable);
    EnableWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_TEXT), Enable);
    EnableWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_LINK), Enable);

    if ((ndwData->ddData).flags & DD_FLAG_IS_DIALOGBOX) {
        EnableWindow(GetDlgItem(hwndDlg, IDOK), Enable);
        EnableWindow(GetDlgItem(hwndDlg, IDCANCEL), Enable);
    } else {
        INT WizardFlags = 0;

        if (Enable) {
            //
            // Don't show the back button if we are in express mode.
            //
            if(!((ndwData->InstallData).Flags & NDW_INSTALLFLAG_SKIPCLASSLIST) ||
               !((ndwData->InstallData).Flags & NDW_INSTALLFLAG_EXPRESSINTRO) ||
               ((ndwData->InstallData).DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED)) {

                WizardFlags |= PSWIZB_BACK;
            }

            //
            // Show the Next button if there is at least one driver selected in the
            // list view.
            //
            if (ListView_GetSelectedCount((ndwData->ddData).hwndDrvList) > 0) {
                WizardFlags |= PSWIZB_NEXT;
            }
        }

        PropSheet_SetWizButtons(GetParent(hwndDlg), WizardFlags);

        EnableWindow(GetDlgItem(GetParent(hwndDlg), IDCANCEL), Enable);
    }
}

BOOL
CDMIsInternetAvailable(
    void
    )
/*++

Routine Description:

    This routine will return TRUE or FALSE based on if this machine can get to the
    Internet or not.

Arguments:

    None

Return Value:

    TRUE if the machine can get to the Internet.
    FALSE if the machine can NOT get to the Internet.

--*/
{
    BOOL IsInternetAvailable = FALSE;
    OSVERSIONINFOEX info;
    HKEY hKey;
    DWORD Policy;
    ULONG cbData;
    HMODULE hModCDM = NULL;
    CDM_INTERNET_AVAILABLE_PROC CdmInternetAvailable;
    SPFUSIONINSTANCE spFusionInstance;

#ifdef UNICODE
    //
    // If this is DataCenter then never call CDM!
    //
    info.dwOSVersionInfoSize = sizeof(info);
    if (GetVersionEx((POSVERSIONINFOW)&info) &&
        (info.wSuiteMask & VER_SUITE_DATACENTER)) {
        return FALSE;
    }
#endif

    //
    // Check the DontSearchWindowsUpdate DriverSearching policy.
    //
    if (RegOpenKeyEx(HKEY_CURRENT_USER, 
                     TEXT("Software\\Policies\\Microsoft\\Windows\\DriverSearching"),
                     0,
                     KEY_READ,
                     &hKey
                     ) == ERROR_SUCCESS) {
        Policy = 0;
        cbData = sizeof(Policy);
        if (RegQueryValueEx(hKey,
                            TEXT("DontSearchWindowsUpdate"),
                            NULL,
                            NULL,
                            (LPBYTE)&Policy,
                            &cbData) != ERROR_SUCCESS) {
            Policy = 0;
        }

        RegCloseKey(hKey);

        //
        // If the DontSearchWindowsUpdate policy is set then return FALSE.
        //
        if (Policy) {
            return FALSE;
        }
    }

    spFusionEnterContext(NULL,&spFusionInstance);

    if ((hModCDM = LoadLibrary(TEXT("cdm.dll"))) &&
        (CdmInternetAvailable = (PVOID)GetProcAddress(hModCDM, "DownloadIsInternetAvailable")) &&
        (CdmInternetAvailable())) {

        IsInternetAvailable = TRUE;

    }

    if (hModCDM) {

        FreeLibrary(hModCDM);
    }

    spFusionLeaveContext(&spFusionInstance);

    return IsInternetAvailable;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\diutil.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    diutil.c

Abstract:

    Device Installer utility routines.

Author:

    Lonny McMichael (lonnym) 10-May-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <initguid.h>

//
// Define and initialize all device class GUIDs.
// (This must only be done once per module!)
//
#include <devguid.h>

//
// Define and initialize a global variable, GUID_NULL
// (from coguid.h)
//
DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

//
// Define the period in miliseconds to wait between attempts to lock the SCM database
//
#define ACQUIRE_SCM_LOCK_INTERVAL 500

//
// Define the number of attempts at locking the SCM database should be made
//
#define ACQUIRE_SCM_LOCK_ATTEMPTS 5

//
// Declare global string variables used throughout device
// installer routines.
//
// These strings are defined in regstr.h:
//
CONST TCHAR pszNoUseClass[]                      = REGSTR_VAL_NOUSECLASS,
            pszNoInstallClass[]                  = REGSTR_VAL_NOINSTALLCLASS,
            pszNoDisplayClass[]                  = REGSTR_VAL_NODISPLAYCLASS,
            pszDeviceDesc[]                      = REGSTR_VAL_DEVDESC,
            pszDevicePath[]                      = REGSTR_VAL_DEVICEPATH,
            pszPathSetup[]                       = REGSTR_PATH_SETUP,
            pszKeySetup[]                        = REGSTR_KEY_SETUP,
            pszPathRunOnce[]                     = REGSTR_PATH_RUNONCE,
            pszSourcePath[]                      = REGSTR_VAL_SRCPATH,
            pszSvcPackPath[]                     = REGSTR_VAL_SVCPAKSRCPATH,
            pszDriverCachePath[]                 = REGSTR_VAL_DRIVERCACHEPATH,
            pszBootDir[]                         = REGSTR_VAL_BOOTDIR,
            pszInsIcon[]                         = REGSTR_VAL_INSICON,
            pszInstaller32[]                     = REGSTR_VAL_INSTALLER_32,
            pszEnumPropPages32[]                 = REGSTR_VAL_ENUMPROPPAGES_32,
            pszInfPath[]                         = REGSTR_VAL_INFPATH,
            pszInfSection[]                      = REGSTR_VAL_INFSECTION,
            pszDrvDesc[]                         = REGSTR_VAL_DRVDESC,
            pszHardwareID[]                      = REGSTR_VAL_HARDWAREID,
            pszCompatibleIDs[]                   = REGSTR_VAL_COMPATIBLEIDS,
            pszDriver[]                          = REGSTR_VAL_DRIVER,
            pszConfigFlags[]                     = REGSTR_VAL_CONFIGFLAGS,
            pszMfg[]                             = REGSTR_VAL_MFG,
            pszService[]                         = REGSTR_VAL_SERVICE,
            pszProviderName[]                    = REGSTR_VAL_PROVIDER_NAME,
            pszFriendlyName[]                    = REGSTR_VAL_FRIENDLYNAME,
            pszServicesRegPath[]                 = REGSTR_PATH_SERVICES,
            pszLegacyInfOption[]                 = REGSTR_VAL_LEGACYINFOPT,
            pszInfSectionExt[]                   = REGSTR_VAL_INFSECTIONEXT,
            pszDeviceClassesPath[]               = REGSTR_PATH_DEVICE_CLASSES,
            pszDeviceInstance[]                  = REGSTR_VAL_DEVICE_INSTANCE,
            pszDefault[]                         = REGSTR_VAL_DEFAULT,
            pszControl[]                         = REGSTR_KEY_CONTROL,
            pszLinked[]                          = REGSTR_VAL_LINKED,
            pszDeviceParameters[]                = REGSTR_KEY_DEVICEPARAMETERS,
            pszLocationInformation[]             = REGSTR_VAL_LOCATION_INFORMATION,
            pszCapabilities[]                    = REGSTR_VAL_CAPABILITIES,
            pszUiNumber[]                        = REGSTR_VAL_UI_NUMBER,
            pszUpperFilters[]                    = REGSTR_VAL_UPPERFILTERS,
            pszLowerFilters[]                    = REGSTR_VAL_LOWERFILTERS,
            pszMatchingDeviceId[]                = REGSTR_VAL_MATCHINGDEVID,
            pszBasicProperties32[]               = REGSTR_VAL_BASICPROPERTIES_32,
            pszCoInstallers32[]                  = REGSTR_VAL_COINSTALLERS_32,
            pszPathCoDeviceInstallers[]          = REGSTR_PATH_CODEVICEINSTALLERS,
            pszSystem[]                          = REGSTR_KEY_SYSTEM,
            pszDrvSignPath[]                     = REGSTR_PATH_DRIVERSIGN,
            pszNonDrvSignPath[]                  = REGSTR_PATH_NONDRIVERSIGN,
            pszDrvSignPolicyPath[]               = REGSTR_PATH_DRIVERSIGN_POLICY,
            pszNonDrvSignPolicyPath[]            = REGSTR_PATH_NONDRIVERSIGN_POLICY,
            pszDrvSignPolicyValue[]              = REGSTR_VAL_POLICY,
            pszDrvSignBehaviorOnFailedVerifyDS[] = REGSTR_VAL_BEHAVIOR_ON_FAILED_VERIFY,
            pszDriverDate[]                      = REGSTR_VAL_DRIVERDATE,
            pszDriverDateData[]                  = REGSTR_VAL_DRIVERDATEDATA,
            pszDriverVersion[]                   = REGSTR_VAL_DRIVERVERSION,
            pszDevSecurity[]                     = REGSTR_VAL_DEVICE_SECURITY_DESCRIPTOR,
            pszDevType[]                         = REGSTR_VAL_DEVICE_TYPE,
            pszExclusive[]                       = REGSTR_VAL_DEVICE_EXCLUSIVE,
            pszCharacteristics[]                 = REGSTR_VAL_DEVICE_CHARACTERISTICS,
            pszUiNumberDescFormat[]              = REGSTR_VAL_UI_NUMBER_DESC_FORMAT,
            pszRemovalPolicyOverride[]           = REGSTR_VAL_REMOVAL_POLICY,
            pszReinstallPath[]                   = REGSTR_PATH_REINSTALL,
            pszReinstallDeviceInstanceIds[]      = REGSTR_VAL_REINSTALL_DEVICEINSTANCEIDS,
            pszReinstallDisplayName[]            = REGSTR_VAL_REINSTALL_DISPLAYNAME,
            pszReinstallString[]                 = REGSTR_VAL_REINSTALL_STRING;


//
// Other misc. global strings (defined in devinst.h):
//
CONST TCHAR pszInfWildcard[]              = DISTR_INF_WILDCARD,
            pszOemInfWildcard[]           = DISTR_OEMINF_WILDCARD,
            pszCiDefaultProc[]            = DISTR_CI_DEFAULTPROC,
            pszSpaceLparen[]              = DISTR_SPACE_LPAREN,
            pszRparen[]                   = DISTR_RPAREN,
            pszUniqueSubKey[]             = DISTR_UNIQUE_SUBKEY,
            pszOemInfGenerate[]           = DISTR_OEMINF_GENERATE,
            pszOemInfDefaultPath[]        = DISTR_OEMINF_DEFAULTPATH,
            pszDefaultService[]           = DISTR_DEFAULT_SERVICE,
            pszGuidNull[]                 = DISTR_GUID_NULL,
            pszEventLog[]                 = DISTR_EVENTLOG,
            pszGroupOrderListPath[]       = DISTR_GROUPORDERLIST_PATH,
            pszServiceGroupOrderPath[]    = DISTR_SERVICEGROUPORDER_PATH,
            pszOptions[]                  = DISTR_OPTIONS,
            pszOptionsText[]              = DISTR_OPTIONSTEXT,
            pszLanguagesSupported[]       = DISTR_LANGUAGESSUPPORTED,
            pszRunOnceExe[]               = DISTR_RUNONCE_EXE,
            pszGrpConv[]                  = DISTR_GRPCONV,
            pszGrpConvNoUi[]              = DISTR_GRPCONV_NOUI,
            pszDefaultSystemPartition[]   = DISTR_DEFAULT_SYSPART,
            pszBasicPropDefaultProc[]     = DISTR_BASICPROP_DEFAULTPROC,
            pszEnumPropDefaultProc[]      = DISTR_ENUMPROP_DEFAULTPROC,
            pszCoInstallerDefaultProc[]   = DISTR_CODEVICEINSTALL_DEFAULTPROC,
            pszDriverObjectPathPrefix[]   = DISTR_DRIVER_OBJECT_PATH_PREFIX,
            pszDriverSigningClasses[]     = DISTR_DRIVER_SIGNING_CLASSES,
            pszEmbeddedNTSecurity[]       = DISTR_PATH_EMBEDDED_NT_SECURITY,
            pszMinimizeFootprint[]        = DISTR_VAL_MINIMIZE_FOOTPRINT,
            pszDisableSCE[]               = DISTR_VAL_DISABLE_SCE;


//
// Define flag bitmask indicating which flags are controlled internally by the
// device installer routines, and thus are read-only to clients.
//
#define DI_FLAGS_READONLY    ( DI_DIDCOMPAT | DI_DIDCLASS | DI_MULTMFGS )

#define DI_FLAGSEX_READONLY  (  DI_FLAGSEX_DIDINFOLIST     \
                              | DI_FLAGSEX_DIDCOMPATINFO   \
                              | DI_FLAGSEX_IN_SYSTEM_SETUP )

#define DNF_FLAGS_READONLY   (  DNF_DUPDESC           \
                              | DNF_OLDDRIVER         \
                              | DNF_LEGACYINF         \
                              | DNF_CLASS_DRIVER      \
                              | DNF_COMPATIBLE_DRIVER \
                              | DNF_INET_DRIVER       \
                              | DNF_INDEXED_DRIVER    \
                              | DNF_OLD_INET_DRIVER   \
                              | DNF_DUPPROVIDER       \
                              | DNF_INF_IS_SIGNED     \
                              | DNF_OEM_F6_INF        \
                              | DNF_DUPDRIVERVER      )

//
// Define flag bitmask indicating which flags are illegal.
//
#define DI_FLAGS_ILLEGAL    ( 0x00400000L )  // setupx DI_NOSYNCPROCESSING flag
#define DI_FLAGSEX_ILLEGAL  ( 0xC0000008L )  // all flags not currently defined
#define DNF_FLAGS_ILLEGAL   ( 0xFFFE0000L )  // ""

#define NDW_INSTALLFLAG_ILLEGAL (~( NDW_INSTALLFLAG_DIDFACTDEFS        \
                                  | NDW_INSTALLFLAG_HARDWAREALLREADYIN \
                                  | NDW_INSTALLFLAG_NEEDRESTART        \
                                  | NDW_INSTALLFLAG_NEEDREBOOT         \
                                  | NDW_INSTALLFLAG_NEEDSHUTDOWN       \
                                  | NDW_INSTALLFLAG_EXPRESSINTRO       \
                                  | NDW_INSTALLFLAG_SKIPISDEVINSTALLED \
                                  | NDW_INSTALLFLAG_NODETECTEDDEVS     \
                                  | NDW_INSTALLFLAG_INSTALLSPECIFIC    \
                                  | NDW_INSTALLFLAG_SKIPCLASSLIST      \
                                  | NDW_INSTALLFLAG_CI_PICKED_OEM      \
                                  | NDW_INSTALLFLAG_PCMCIAMODE         \
                                  | NDW_INSTALLFLAG_PCMCIADEVICE       \
                                  | NDW_INSTALLFLAG_USERCANCEL         \
                                  | NDW_INSTALLFLAG_KNOWNCLASS         ))

#define DYNAWIZ_FLAG_ILLEGAL (~( DYNAWIZ_FLAG_PAGESADDED             \
                               | DYNAWIZ_FLAG_INSTALLDET_NEXT        \
                               | DYNAWIZ_FLAG_INSTALLDET_PREV        \
                               | DYNAWIZ_FLAG_ANALYZE_HANDLECONFLICT ))

#define NEWDEVICEWIZARD_FLAG_ILLEGAL (~(0)) // no flags are legal presently


//
// Declare data used in GUID->string conversion (from ole32\common\ccompapi.cxx).
//
static const BYTE GuidMap[] = { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
                                8, 9, '-', 10, 11, 12, 13, 14, 15 };

static const TCHAR szDigits[] = TEXT("0123456789ABCDEF");


PDEVICE_INFO_SET
AllocateDeviceInfoSet(
    VOID
    )
/*++

Routine Description:

    This routine allocates a device information set structure, zeroes it,
    and initializes the synchronization lock for it.

Arguments:

    none.

Return Value:

    If the function succeeds, the return value is a pointer to the new
    device information set.

    If the function fails, the return value is NULL.

--*/
{
    PDEVICE_INFO_SET p;

    if(p = MyMalloc(sizeof(DEVICE_INFO_SET))) {

        ZeroMemory(p, sizeof(DEVICE_INFO_SET));

        p->MachineName = -1;
        p->InstallParamBlock.DriverPath = -1;
        p->InstallParamBlock.CoInstallerCount = -1;

        //
        // If we're in GUI-mode setup on Windows NT, we'll automatically set
        // the DI_FLAGSEX_IN_SYSTEM_SETUP flag in the devinstall parameter
        // block for this devinfo set.
        //
        if(GuiSetupInProgress) {
            p->InstallParamBlock.FlagsEx |= DI_FLAGSEX_IN_SYSTEM_SETUP;
        }

        //
        // If we're in non-interactive mode, set the "be quiet" bits.
        //
        if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
            p->InstallParamBlock.Flags   |= DI_QUIETINSTALL;
            p->InstallParamBlock.FlagsEx |= DI_FLAGSEX_NOUIONQUERYREMOVE;
        }

        //
        // Initialize our enumeration 'hints'
        //
        p->DeviceInfoEnumHintIndex = INVALID_ENUM_INDEX;
        p->ClassDriverEnumHintIndex = INVALID_ENUM_INDEX;


        if(p->StringTable = pStringTableInitialize(0)) {

            if (CreateLogContext(NULL, FALSE, &(p->InstallParamBlock.LogContext)) == NO_ERROR) {
                //
                // succeeded
                //
                if(InitializeSynchronizedAccess(&(p->Lock))) {
                    return p;
                }

                DeleteLogContext(p->InstallParamBlock.LogContext);
            }

            pStringTableDestroy(p->StringTable);
        }
        MyFree(p);
    }

    return NULL;
}


VOID
DestroyDeviceInfoElement(
    IN HDEVINFO         hDevInfo,
    IN PDEVICE_INFO_SET pDeviceInfoSet,
    IN PDEVINFO_ELEM    DeviceInfoElement
    )
/*++

Routine Description:

    This routine destroys the specified device information element, freeing
    all resources associated with it.
    ASSUMES THAT THE CALLING ROUTINE HAS ALREADY ACQUIRED THE LOCK!

Arguments:

    hDevInfo - Supplies a handle to the device information set whose internal
        representation is given by pDeviceInfoSet.  This opaque handle is
        actually the same pointer as pDeviceInfoSet, but we want to keep this
        distinction clean, so that in the future we can change our implementation
        (e.g., hDevInfo might represent an offset in an array of DEVICE_INFO_SET
        elements).

    pDeviceInfoSet - Supplies a pointer to the device information set of which
        the devinfo element is a member.  This set contains the class driver list
        object list that must be used in destroying the class driver list.

    DeviceInfoElement - Supplies a pointer to the device information element
        to be destroyed.

Return Value:

    None.

--*/
{
    DWORD i;
    PINTERFACE_DEVICE_NODE InterfaceDeviceNode, NextInterfaceDeviceNode;
    CONFIGRET cr;

    MYASSERT(hDevInfo && (hDevInfo != INVALID_HANDLE_VALUE));

    //
    // Free resources contained in the install parameters block.  Do this
    // before anything else, because we'll be calling the class installer
    // with DIF_DESTROYPRIVATEDATA, and we want everything to be in a
    // consistent state when we do (plus, it may need to destroy private
    // data it's stored with individual driver nodes).
    //
    DestroyInstallParamBlock(hDevInfo,
                             pDeviceInfoSet,
                             DeviceInfoElement,
                             &(DeviceInfoElement->InstallParamBlock)
                            );

    //
    // Dereference the class driver list.
    //
    DereferenceClassDriverList(pDeviceInfoSet, DeviceInfoElement->ClassDriverHead);

    //
    // Destroy compatible driver list.
    //
    DestroyDriverNodes(DeviceInfoElement->CompatDriverHead, pDeviceInfoSet);

    //
    // If this is a non-registered device instance, then delete any registry
    // keys the caller may have created during the lifetime of this element.
    //
    if(DeviceInfoElement->DevInst && !(DeviceInfoElement->DiElemFlags & DIE_IS_REGISTERED)) {

        pSetupDeleteDevRegKeys(DeviceInfoElement->DevInst,
                               DICS_FLAG_GLOBAL | DICS_FLAG_CONFIGSPECIFIC,
                               (DWORD)-1,
                               DIREG_BOTH,
                               TRUE
                              );

        cr = CM_Uninstall_DevInst(DeviceInfoElement->DevInst, 0);
    }

    //
    // Free any interface device lists that may be associated with this devinfo element.
    //
    if(DeviceInfoElement->InterfaceClassList) {

        for(i = 0; i < DeviceInfoElement->InterfaceClassListSize; i++) {

            for(InterfaceDeviceNode = DeviceInfoElement->InterfaceClassList[i].InterfaceDeviceNode;
                InterfaceDeviceNode;
                InterfaceDeviceNode = NextInterfaceDeviceNode) {

                NextInterfaceDeviceNode = InterfaceDeviceNode->Next;
                MyFree(InterfaceDeviceNode);
            }
        }

        MyFree(DeviceInfoElement->InterfaceClassList);
    }

    //
    // Zero the signature field containing the address of the containing devinfo
    // set.  This will keep us thinking an SP_DEVINFO_DATA is still valid after
    // the underlying element has been deleted.
    //
    DeviceInfoElement->ContainingDeviceInfoSet = NULL;

    MyFree(DeviceInfoElement);
}


DWORD
DestroyDeviceInfoSet(
    IN HDEVINFO         hDevInfo,      OPTIONAL
    IN PDEVICE_INFO_SET pDeviceInfoSet
    )
/*++

Routine Description:

    This routine frees a device information set, and all resources
    used on its behalf.

Arguments:

    hDevInfo - Optionally, supplies a handle to the device information set
        whose internal representation is given by pDeviceInfoSet.  This
        opaque handle is actually the same pointer as pDeviceInfoSet, but
        we want to keep this distinction clean, so that in the future we
        can change our implementation (e.g., hDevInfo might represent an
        offset in an array of DEVICE_INFO_SET elements).

        This parameter will only be NULL if we're cleaning up half-way
        through the creation of a device information set.

    pDeviceInfoSet - supplies a pointer to the device information set
        to be freed.

Return Value:

    If successful, the return code is NO_ERROR, otherwise, it is an
    ERROR_* code.

--*/
{
    PDEVINFO_ELEM NextElem;
    PDRIVER_NODE DriverNode, NextNode;
    PMODULE_HANDLE_LIST_NODE NextModuleHandleNode;
    DWORD i;
    SPFUSIONINSTANCE spFusionInstance;

    //
    // We have to make sure that the wizard refcount is zero, and that
    // we haven't acquired the lock more than once (i.e., we're nested
    // more than one level deep in Di calls.
    //
    if(pDeviceInfoSet->WizPageList ||
       (pDeviceInfoSet->LockRefCount > 1)) {

        return ERROR_DEVINFO_LIST_LOCKED;
    }

    //
    // Destroy all the device information elements in this set.  Make sure
    // that we maintain consistency while removing devinfo elements, because
    // we may be calling the class installer.  This means that the device
    // installer APIs still have to work, even while we're tearing down the
    // list.
    //
    while(pDeviceInfoSet->DeviceInfoHead) {
        //
        // We'd better not have any device info elements locked by wizard
        // pages, since our wizard refcount is zero!
        //
        MYASSERT(!(pDeviceInfoSet->DeviceInfoHead->DiElemFlags & DIE_IS_LOCKED));

        NextElem = pDeviceInfoSet->DeviceInfoHead->Next;
        DestroyDeviceInfoElement(hDevInfo, pDeviceInfoSet, pDeviceInfoSet->DeviceInfoHead);

        MYASSERT(pDeviceInfoSet->DeviceInfoCount > 0);
        pDeviceInfoSet->DeviceInfoCount--;

        //
        // If this element was the currently selected device for this
        // set, then reset the device selection.
        //
        if(pDeviceInfoSet->SelectedDevInfoElem == pDeviceInfoSet->DeviceInfoHead) {
            pDeviceInfoSet->SelectedDevInfoElem = NULL;
        }

        pDeviceInfoSet->DeviceInfoHead = NextElem;
    }

    MYASSERT(pDeviceInfoSet->DeviceInfoCount == 0);
    pDeviceInfoSet->DeviceInfoTail = NULL;

    //
    // Free resources contained in the install parameters block.  Do this
    // before anything else, because we'll be calling the class installer
    // with DIF_DESTROYPRIVATEDATA, and we want everything to be in a
    // consistent state when we do (plus, it may need to destroy private
    // data it's stored with individual driver nodes).
    //
    DestroyInstallParamBlock(hDevInfo,
                             pDeviceInfoSet,
                             NULL,
                             &(pDeviceInfoSet->InstallParamBlock)
                            );

    //
    // Destroy class driver list.
    //
    if(pDeviceInfoSet->ClassDriverHead) {
        //
        // We've already destroyed all device information elements, so there should be
        // exactly one driver list object remaining--the one referenced by the global
        // class driver list.  Also, it's refcount should be 1.
        //
        MYASSERT(
            (pDeviceInfoSet->ClassDrvListObjectList) &&
            (!pDeviceInfoSet->ClassDrvListObjectList->Next) &&
            (pDeviceInfoSet->ClassDrvListObjectList->RefCount == 1) &&
            (pDeviceInfoSet->ClassDrvListObjectList->DriverListHead == pDeviceInfoSet->ClassDriverHead)
           );

        MyFree(pDeviceInfoSet->ClassDrvListObjectList);
        DestroyDriverNodes(pDeviceInfoSet->ClassDriverHead, pDeviceInfoSet);
    }

    //
    // Free the interface class GUID list (if there is one).
    //
    if(pDeviceInfoSet->GuidTable) {
        MyFree(pDeviceInfoSet->GuidTable);
    }

    //
    // Destroy the associated string table.
    //
    pStringTableDestroy(pDeviceInfoSet->StringTable);

    //
    // Destroy the lock (we have to do this after we've made all necessary calls
    // to the class installer, because after the lock is freed, the HDEVINFO set
    // is inaccessible).
    //
    DestroySynchronizedAccess(&(pDeviceInfoSet->Lock));

    //
    // If there are any module handles left to be freed, do that now.
    //
    for(; pDeviceInfoSet->ModulesToFree; pDeviceInfoSet->ModulesToFree = NextModuleHandleNode) {

        NextModuleHandleNode = pDeviceInfoSet->ModulesToFree->Next;

        for(i = 0; i < pDeviceInfoSet->ModulesToFree->ModuleCount; i++) {
            MYASSERT(pDeviceInfoSet->ModulesToFree->ModuleList[i].ModuleHandle);
            spFusionEnterContext(pDeviceInfoSet->ModulesToFree->ModuleList[i].FusionContext,
                                    &spFusionInstance);
            FreeLibrary(pDeviceInfoSet->ModulesToFree->ModuleList[i].ModuleHandle);
            spFusionLeaveContext(&spFusionInstance);
            spFusionKillContext(pDeviceInfoSet->ModulesToFree->ModuleList[i].FusionContext);
        }

        MyFree(pDeviceInfoSet->ModulesToFree);
    }

    //
    // If this is a remote HDEVINFO set, then disconnect from the remote machine.
    //
    if(pDeviceInfoSet->hMachine) {
        CM_Disconnect_Machine(pDeviceInfoSet->hMachine);
    }

    //
    // Now, destroy the container itself.
    //
    MyFree(pDeviceInfoSet);

    return NO_ERROR;
}


VOID
DestroyInstallParamBlock(
    IN HDEVINFO                hDevInfo,         OPTIONAL
    IN PDEVICE_INFO_SET        pDeviceInfoSet,
    IN PDEVINFO_ELEM           DevInfoElem,      OPTIONAL
    IN PDEVINSTALL_PARAM_BLOCK InstallParamBlock
    )
/*++

Routine Description:

    This routine frees any resources contained in the specified install
    parameter block.  THE BLOCK ITSELF IS NOT FREED!

Arguments:

    hDevInfo - Optionally, supplies a handle to the device information set
        containing the element whose parameter block is to be destroyed.

        If this parameter is not supplied, then we're cleaning up after
        failing part-way through a SetupDiCreateDeviceInfoList.

    pDeviceInfoSet - Supplies a pointer to the device information set of which
        the devinfo element is a member.

    DevInfoElem - Optionally, supplies the address of the device information
        element whose parameter block is to be destroyed.  If the parameter
        block being destroyed is associated with the set itself, then this
        parameter will be NULL.

    InstallParamBlock - Supplies the address of the install parameter
        block whose resources are to be freed.

Return Value:

    None.

--*/
{
    SP_DEVINFO_DATA DeviceInfoData;
    LONG i;

    if(InstallParamBlock->UserFileQ) {
        //
        // If there's a user-supplied file queue stored in this installation
        // parameter block, then decrement the refcount on it.  Make sure we
        // do this before calling the class installer with DIF_DESTROYPRIVATEDATA,
        // or else they won't be able to close the queue.
        //
        MYASSERT(((PSP_FILE_QUEUE)(InstallParamBlock->UserFileQ))->LockRefCount);

        ((PSP_FILE_QUEUE)(InstallParamBlock->UserFileQ))->LockRefCount--;
    }

    if(hDevInfo && (hDevInfo != INVALID_HANDLE_VALUE)) {
        //
        // Call the class installer/co-installers (if there are any) to let them
        // clean up any private data they may have.
        //
        if(DevInfoElem) {
            //
            // Generate an SP_DEVINFO_DATA structure from our device information
            // element (if we have one).
            //
            DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
            DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                             DevInfoElem,
                                             &DeviceInfoData
                                            );
        }

        InvalidateHelperModules(hDevInfo,
                                (DevInfoElem ? &DeviceInfoData : NULL),
                                IHM_FREE_IMMEDIATELY
                               );
    }

    if(InstallParamBlock->ClassInstallHeader) {
        MyFree(InstallParamBlock->ClassInstallHeader);
    }

    //
    // Get rid of the log context sitting in here.
    //
    DeleteLogContext(InstallParamBlock->LogContext);
}


PDEVICE_INFO_SET
AccessDeviceInfoSet(
    IN HDEVINFO DeviceInfoSet
    )
/*++

Routine Description:

    This routine locks the specified device information set, and returns
    a pointer to the structure for its internal representation.  It also
    increments the lock refcount on this set, so that it can't be destroyed
    if the lock has been acquired multiple times.

    After access to the set is completed, the caller must call
    UnlockDeviceInfoSet with the pointer returned by this function.

Arguments:

    DeviceInfoSet - Supplies the pointer to the device information set
        to be accessed.

Return Value:

    If the function succeeds, the return value is a pointer to the
    device information set.

    If the function fails, the return value is NULL.

Remarks:

    If the method for accessing a device information set's internal
    representation via its handle changes (e.g., instead of a pointer, it's an
    index into a table), then RollbackDeviceInfoSet and CommitDeviceInfoSet
    must also be changed.  Also, we cast an HDEVINFO to a PDEVICE_INFO_SET
    when specifying the containing device information set in a call to
    pSetupOpenAndAddNewDevInfoElem in devinfo.c!SetupDiGetClassDevsEx (only
    when we're working with a cloned devinfo set).

--*/
{
    PDEVICE_INFO_SET p;

    try {
        p = (PDEVICE_INFO_SET)DeviceInfoSet;
        if(LockDeviceInfoSet(p)) {
            p->LockRefCount++;
        } else {
            p = NULL;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        p = NULL;
    }

    return p;
}


PDEVICE_INFO_SET
CloneDeviceInfoSet(
    IN HDEVINFO hDevInfo
    )
/*++

Routine Description:

    This routine locks the specified device information set, then returns a
    clone of the structure used for its internal representation.  Device
    information elements or device interface nodes may subsequently be added to
    this cloned devinfo set, and the results can be committed via
    CommitDeviceInfoSet.  If the changes must be backed out (e.g., because an
    error was encountered while adding the additional elements to the set), the
    routine RollbackDeviceInfoSet must be called.

    After access to the set is completed (and the changes have either been
    committed or rolled back per the discussion above), the caller must call
    UnlockDeviceInfoSet with the pointer returned by CommitDeviceInfoSet or
    RollbackDeviceInfoSet.

Arguments:

    hDevInfo - Supplies the handle of the device information set to be cloned.

Return Value:

    If the function succeeds, the return value is a pointer to the
    device information set.

    If the function fails, the return value is NULL.

Remarks:

    The device information set handle specified to this routine MUST NOT BE
    USED until the changes are either committed or rolled back.  Also, the
    PDEVICE_INFO_SET returned by this routine must not be treated like an
    HDEVINFO handle--it is not.

--*/
{
    PDEVICE_INFO_SET p, NewDevInfoSet;
    BOOL b;
    PVOID StringTable;

    try {
        p = (PDEVICE_INFO_SET)hDevInfo;
        if(LockDeviceInfoSet(p)) {
            p->LockRefCount++;
        } else {
            p = NULL;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        p = NULL;
    }

    if(!p) {
        return NULL;
    }

    NewDevInfoSet = NULL;
    StringTable = NULL;
    b = FALSE;

    try {
        //
        // OK, we successfully locked the device information set.  Now, make a copy
        // of the internal structure to return to the caller.
        //
        NewDevInfoSet = MyMalloc(sizeof(DEVICE_INFO_SET));
        if(!NewDevInfoSet) {
            goto clean0;
        }

        CopyMemory(NewDevInfoSet, p, sizeof(DEVICE_INFO_SET));

        //
        // Duplicate the string table contained in this device information set.
        //
        StringTable = pStringTableDuplicate(p->StringTable);
        if(!StringTable) {
            goto clean0;
        }

        NewDevInfoSet->StringTable = StringTable;

        //
        // We've successfully cloned the device information set!
        //
        b = TRUE;

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Access the following variables so the compiler will respect our
        // statement ordering w.r.t. assignment.
        //
        NewDevInfoSet = NewDevInfoSet;
        StringTable = StringTable;
    }

    if(!b) {
        //
        // We failed to make a copy of the device information set--free any
        // memory we may have allocated, and unlock the original devinfo set
        // before returning failure.
        //
        if(NewDevInfoSet) {
            MyFree(NewDevInfoSet);
        }
        if(StringTable) {
            pStringTableDestroy(StringTable);
        }
        UnlockDeviceInfoSet(p);
        return NULL;
    }

    return NewDevInfoSet;
}


PDEVICE_INFO_SET
RollbackDeviceInfoSet(
    IN HDEVINFO hDevInfo,
    IN PDEVICE_INFO_SET ClonedDeviceInfoSet
    )
/*++

Routine Description:

    This routine rolls back the specified hDevInfo to a known good state that
    was saved when the set was cloned via a prior call to CloneDeviceInfoSet.

Arguments:

    hDevInfo - Supplies the handle of the device information set to be rolled
        back.

    ClonedDeviceInfoSet - Supplies the address of the internal structure
        representing the hDevInfo set's cloned (and potentially, modified)
        information.  Upon successful return, this structure will be freed.

Return Value:

    If the function succeeds, the return value is a pointer to the rolled-back
    device information set structure.

    If the function fails, the return value is NULL.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem, NextDevInfoElem;
    DWORD i, InterfaceDeviceCount;
    PINTERFACE_DEVICE_NODE InterfaceDeviceNode, NextInterfaceDeviceNode;

    //
    // Retrieve a pointer to the hDevInfo set's internal representation (we
    // don't need to acquire the lock, because we did that when we cloned the
    // originally cloned the structure).
    //
    // NOTE:  If the method for accessing an HDEVINFO set's internal
    // representation ever changes (i.e., the AccessDeviceInfoSet routine),
    // then this code will need to be modified accordingly.
    //
    pDeviceInfoSet = (PDEVICE_INFO_SET)hDevInfo;

    //
    // Make sure no additional locks have been acquired against the cloned
    // DEVICE_INFO_SET.
    //
    MYASSERT(pDeviceInfoSet->LockRefCount == ClonedDeviceInfoSet->LockRefCount);

    //
    // Do some validation to see whether it looks like only new device
    // information elements were added onto the end of our existing list (i.e.,
    // it's invalid to add new elements within the existing list, or to remove
    // elements from the existing list).
    //
#if ASSERTS_ON
    if(pDeviceInfoSet->DeviceInfoHead) {

        DWORD DevInfoElemCount = 1;

        MYASSERT(pDeviceInfoSet->DeviceInfoHead == ClonedDeviceInfoSet->DeviceInfoHead);
        for(DevInfoElem = ClonedDeviceInfoSet->DeviceInfoHead;
            DevInfoElem->Next;
            DevInfoElem = DevInfoElem->Next, DevInfoElemCount++) {

            if(DevInfoElem == pDeviceInfoSet->DeviceInfoTail) {
                break;
            }
        }
        //
        // Did we find the original tail?
        //
        MYASSERT(DevInfoElem == pDeviceInfoSet->DeviceInfoTail);
        //
        // And did we traverse the same number of nodes in getting there that
        // was in the original list?
        //
        MYASSERT(DevInfoElemCount == pDeviceInfoSet->DeviceInfoCount);
    }
#endif

    //
    // Destroy any newly-added members of the device information element list.
    //
    for(DevInfoElem = (pDeviceInfoSet->DeviceInfoTail ? pDeviceInfoSet->DeviceInfoTail->Next : pDeviceInfoSet->DeviceInfoHead);
        DevInfoElem;
        DevInfoElem = NextDevInfoElem) {

        NextDevInfoElem = DevInfoElem->Next;

        MYASSERT(!DevInfoElem->ClassDriverCount);
        MYASSERT(!DevInfoElem->CompatDriverCount);

        //
        // Free any interface device lists that may be associated with this
        // devinfo element.
        //
        if(DevInfoElem->InterfaceClassList) {

            for(i = 0; i < DevInfoElem->InterfaceClassListSize; i++) {

                for(InterfaceDeviceNode = DevInfoElem->InterfaceClassList[i].InterfaceDeviceNode;
                    InterfaceDeviceNode;
                    InterfaceDeviceNode = NextInterfaceDeviceNode) {

                    NextInterfaceDeviceNode = InterfaceDeviceNode->Next;
                    MyFree(InterfaceDeviceNode);
                }
            }

            MyFree(DevInfoElem->InterfaceClassList);
        }

        MyFree(DevInfoElem);
    }

    if(pDeviceInfoSet->DeviceInfoTail) {
        pDeviceInfoSet->DeviceInfoTail->Next = NULL;
    }

    //
    // At this point, we've trimmed our device information element list back to
    // what it was prior to the cloning of the device information set.  However,
    // we may have added new device interface nodes onto the interface class
    // lists of existing devinfo elements.  Go and truncate any such nodes.
    //
    for(DevInfoElem = pDeviceInfoSet->DeviceInfoHead;
        DevInfoElem;
        DevInfoElem = DevInfoElem->Next) {

        if(DevInfoElem->InterfaceClassList) {

            for(i = 0; i < DevInfoElem->InterfaceClassListSize; i++) {

                if(DevInfoElem->InterfaceClassList[i].InterfaceDeviceTruncateNode) {
                    //
                    // One or more device interface nodes were added to this
                    // list.  Find the tail of the list as it existed prior to
                    // cloning, and truncate from there.
                    //
                    InterfaceDeviceNode = NULL;
                    InterfaceDeviceCount = 0;
                    for(NextInterfaceDeviceNode = DevInfoElem->InterfaceClassList[i].InterfaceDeviceNode;
                        NextInterfaceDeviceNode;
                        InterfaceDeviceNode = NextInterfaceDeviceNode, NextInterfaceDeviceNode = NextInterfaceDeviceNode->Next) {

                        if(NextInterfaceDeviceNode == DevInfoElem->InterfaceClassList[i].InterfaceDeviceTruncateNode) {
                            break;
                        }

                        //
                        // We haven't encountered the truncate point yet--
                        // increment the count of device interface nodes we've
                        // traversed so far.
                        //
                        InterfaceDeviceCount++;
                    }

                    //
                    // We'd better have found the node to truncate in our list!
                    //
                    MYASSERT(NextInterfaceDeviceNode);

                    //
                    // Truncate the list, and destroy all newly-added device
                    // interface nodes.
                    //
                    if(InterfaceDeviceNode) {
                        InterfaceDeviceNode->Next = NULL;
                    } else {
                        DevInfoElem->InterfaceClassList[i].InterfaceDeviceNode = NULL;
                    }
                    DevInfoElem->InterfaceClassList[i].InterfaceDeviceCount = InterfaceDeviceCount;

                    for(InterfaceDeviceNode = NextInterfaceDeviceNode;
                        InterfaceDeviceNode;
                        InterfaceDeviceNode = NextInterfaceDeviceNode) {

                        NextInterfaceDeviceNode = InterfaceDeviceNode->Next;
                        MyFree(InterfaceDeviceNode);
                    }

                    //
                    // Reset the truncate node pointer.
                    //
                    DevInfoElem->InterfaceClassList[i].InterfaceDeviceTruncateNode = NULL;
                }
            }
        }
    }

    //
    // OK, our device information element list and device interface node lists
    // are exactly as they were before the cloning took place.  However, it's
    // possible that we allocated (or reallocated) a new buffer for our
    // GUID table, so we need to update that GUID table pointer and size in our
    // original device information set structure.
    //
    pDeviceInfoSet->GuidTable     = ClonedDeviceInfoSet->GuidTable;
    pDeviceInfoSet->GuidTableSize = ClonedDeviceInfoSet->GuidTableSize;

    //
    // The device information set has been successfully rolled back.  Free the
    // memory associated with the clone.
    //
    pStringTableDestroy(ClonedDeviceInfoSet->StringTable);
    MyFree(ClonedDeviceInfoSet);

    //
    // Return the original (rolled-back) device information set structure to
    // the caller.
    //
    return pDeviceInfoSet;
}


PDEVICE_INFO_SET
CommitDeviceInfoSet(
    IN HDEVINFO hDevInfo,
    IN PDEVICE_INFO_SET ClonedDeviceInfoSet
    )
/*++

Routine Description:

    This routine commits the changes that have been made to a cloned device
    information set.  The clone was generated via a prior call to
    CloneDeviceInfoSet.

Arguments:

    hDevInfo - Supplies the handle of the device information set whose changes
        are to be committed.

    ClonedDeviceInfoSet - Supplies the address of the internal structure
        representing the hDevInfo set's cloned (and potentially, modified)
        information.  Upon successful return, this structure will be freed.

Return Value:

    If the function succeeds, the return value is a pointer to the committed
    device information set structure.

    If the function fails, the return value is NULL.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    DWORD i;

    //
    // Retrieve a pointer to the hDevInfo set's internal representation (we
    // don't need to acquire the lock, because we did that when we cloned the
    // originally cloned the structure).
    //
    // NOTE:  If the method for accessing an HDEVINFO set's internal
    // representation ever changes (i.e., the AccessDeviceInfoSet routine),
    // then this code will need to be modified accordingly.
    //
    pDeviceInfoSet = (PDEVICE_INFO_SET)hDevInfo;

    //
    // Make sure no additional locks have been acquired against the cloned
    // DEVICE_INFO_SET.
    //
    MYASSERT(pDeviceInfoSet->LockRefCount == ClonedDeviceInfoSet->LockRefCount);

    //
    // Free the old string table.
    //
    pStringTableDestroy(pDeviceInfoSet->StringTable);

    //
    // Now copy the cloned device information set structure into the 'real' one.
    //
    CopyMemory(pDeviceInfoSet, ClonedDeviceInfoSet, sizeof(DEVICE_INFO_SET));

    //
    // Now we have to go through each device information element's interface
    // class list and reset the InterfaceDeviceTruncateNode fields to indicate
    // that all the new device interface nodes that were added have been
    // committed.
    //
    for(DevInfoElem = pDeviceInfoSet->DeviceInfoHead;
        DevInfoElem;
        DevInfoElem = DevInfoElem->Next) {

        for(i = 0; i < DevInfoElem->InterfaceClassListSize; i++) {
            DevInfoElem->InterfaceClassList[i].InterfaceDeviceTruncateNode = NULL;
        }
    }

    //
    // Free the cloned device information set structure.
    //
    MyFree(ClonedDeviceInfoSet);

    //
    // We've successfully committed the changes into the original device
    // information set structure--return that structure.
    //
    return pDeviceInfoSet;
}


PDEVINFO_ELEM
FindDevInfoByDevInst(
    IN  PDEVICE_INFO_SET  DeviceInfoSet,
    IN  DEVINST           DevInst,
    OUT PDEVINFO_ELEM    *PrevDevInfoElem OPTIONAL
    )
/*++

Routine Description:

    This routine searches through all (registered) elements of a
    device information set, looking for one that corresponds to the
    specified device instance handle.  If a match is found, a pointer
    to the device information element is returned.

Arguments:

    DeviceInfoSet - Specifies the set to be searched.

    DevInst - Specifies the device instance handle to search for.

    PrevDevInfoElem - Optionaly, supplies the address of the variable that
        receives a pointer to the device information element immediately
        preceding the matching element.  If the element was found at the
        front of the list, then this variable will be set to NULL.

Return Value:

    If a device information element is found, the return value is a
    pointer to that element, otherwise, the return value is NULL.

--*/
{
    PDEVINFO_ELEM cur, prev;

    for(cur = DeviceInfoSet->DeviceInfoHead, prev = NULL;
        cur;
        prev = cur, cur = cur->Next)
    {
        if((cur->DiElemFlags & DIE_IS_REGISTERED) && (cur->DevInst == DevInst)) {

            if(PrevDevInfoElem) {
                *PrevDevInfoElem = prev;
            }
            return cur;
        }
    }

    return NULL;
}


BOOL
DevInfoDataFromDeviceInfoElement(
    IN  PDEVICE_INFO_SET DeviceInfoSet,
    IN  PDEVINFO_ELEM    DevInfoElem,
    OUT PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    This routine fills in a SP_DEVINFO_DATA structure based on the
    information in the supplied DEVINFO_ELEM structure.

    Note:  The supplied DeviceInfoData structure must have its cbSize
    field filled in correctly, or the call will fail.

Arguments:

    DeviceInfoSet - Supplies a pointer to the device information set
        containing the specified element.

    DevInfoElem - Supplies a pointer to the DEVINFO_ELEM structure
        containing information to be used in filling in the
        SP_DEVINFO_DATA buffer.

    DeviceInfoData - Supplies a pointer to the buffer that will
        receive the filled-in SP_DEVINFO_DATA structure

Return Value:

    If the function succeeds, the return value is TRUE, otherwise, it
    is FALSE.

--*/
{
    if(DeviceInfoData->cbSize != sizeof(SP_DEVINFO_DATA)) {
        return FALSE;
    }

    ZeroMemory(DeviceInfoData, sizeof(SP_DEVINFO_DATA));
    DeviceInfoData->cbSize = sizeof(SP_DEVINFO_DATA);

    CopyMemory(&(DeviceInfoData->ClassGuid),
               &(DevInfoElem->ClassGuid),
               sizeof(GUID)
              );

    DeviceInfoData->DevInst = DevInfoElem->DevInst;

    //
    // The 'Reserved' field actually contains a pointer to the
    // corresponding device information element.
    //
    DeviceInfoData->Reserved = (ULONG_PTR)DevInfoElem;

    return TRUE;
}


PDEVINFO_ELEM
FindAssociatedDevInfoElem(
    IN  PDEVICE_INFO_SET  DeviceInfoSet,
    IN  PSP_DEVINFO_DATA  DeviceInfoData,
    OUT PDEVINFO_ELEM    *PreviousElement OPTIONAL
    )
/*++

Routine Description:

    This routine returns the devinfo element for the specified
    SP_DEVINFO_DATA, or NULL if no devinfo element exists.

Arguments:

    DeviceInfoSet - Specifies the set to be searched.

    DeviceInfoData - Supplies a pointer to a device information data
        buffer specifying the device information element to retrieve.

    PreviousElement - Optionally, supplies the address of a
        DEVINFO_ELEM pointer that receives the element that precedes
        the specified element in the linked list.  If the returned
        element is located at the front of the list, then this value
        will be set to NULL.

Return Value:

    If a device information element is found, the return value is a
    pointer to that element, otherwise, the return value is NULL.

--*/
{
    PDEVINFO_ELEM DevInfoElem, CurElem, PrevElem;
    PDEVINFO_ELEM ActualDevInfoElem = NULL;

    try {
        if((DeviceInfoData->cbSize != sizeof(SP_DEVINFO_DATA)) ||
           !(DevInfoElem = (PDEVINFO_ELEM)DeviceInfoData->Reserved)) {
            leave;
        }

        if(PreviousElement) {
            //
            // The caller requested that the preceding element be returned
            // (probably because the element is about to be deleted).  Since
            // this is a singly-linked list, we'll search through the list
            // until we find the desired element.
            //
            for(CurElem = DeviceInfoSet->DeviceInfoHead, PrevElem = NULL;
                CurElem;
                PrevElem = CurElem, CurElem = CurElem->Next) {

                if(CurElem == DevInfoElem) {
                    //
                    // We found the element in our set.
                    //
                    if(PreviousElement) {
                        *PreviousElement = PrevElem;
                    }
                    ActualDevInfoElem = CurElem;
                    leave;
                }
            }

        } else {
            //
            // The caller doesn't care what the preceding element is, so we
            // can go right to the element, and validate it by ensuring that
            // the ContainingDeviceInfoSet field at the location pointed to
            // by DevInfoElem matches the devinfo set where this guy is supposed
            // to exist.
            //
            if(DevInfoElem->ContainingDeviceInfoSet == DeviceInfoSet) {
                ActualDevInfoElem = DevInfoElem;
                leave;
            }
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // invalid memory
        //
        ActualDevInfoElem = NULL;
    }

    return ActualDevInfoElem;
}


BOOL
DrvInfoDataFromDriverNode(
    IN  PDEVICE_INFO_SET DeviceInfoSet,
    IN  PDRIVER_NODE     DriverNode,
    IN  DWORD            DriverType,
    OUT PSP_DRVINFO_DATA DriverInfoData
    )
/*++

Routine Description:

    This routine fills in a SP_DRVINFO_DATA structure based on the
    information in the supplied DRIVER_NODE structure.

    Note:  The supplied DriverInfoData structure must have its cbSize
    field filled in correctly, or the call will fail.

Arguments:

    DeviceInfoSet - Supplies a pointer to the device information set
        in which the driver node is located.

    DriverNode - Supplies a pointer to the DRIVER_NODE structure
        containing information to be used in filling in the
        SP_DRVNFO_DATA buffer.

    DriverType - Specifies what type of driver this is.  This value
        may be either SPDIT_CLASSDRIVER or SPDIT_COMPATDRIVER.

    DriverInfoData - Supplies a pointer to the buffer that will
        receive the filled-in SP_DRVINFO_DATA structure

Return Value:

    If the function succeeds, the return value is TRUE, otherwise, it
    is FALSE.

--*/
{
    PTSTR StringPtr;
    DWORD DriverInfoDataSize;

    if((DriverInfoData->cbSize != sizeof(SP_DRVINFO_DATA)) &&
       (DriverInfoData->cbSize != sizeof(SP_DRVINFO_DATA_V1))) {
        return FALSE;
    }

    DriverInfoDataSize = DriverInfoData->cbSize;

    ZeroMemory(DriverInfoData, DriverInfoDataSize);
    DriverInfoData->cbSize = DriverInfoDataSize;

    DriverInfoData->DriverType = DriverType;

    MYASSERT(DriverNode->DevDescriptionDisplayName != -1);
    StringPtr = pStringTableStringFromId(DeviceInfoSet->StringTable,
                                         DriverNode->DevDescriptionDisplayName
                                        );
    lstrcpy(DriverInfoData->Description,
            StringPtr
           );

    MYASSERT(DriverNode->MfgDisplayName != -1);
    StringPtr = pStringTableStringFromId(DeviceInfoSet->StringTable,
                                         DriverNode->MfgDisplayName
                                        );
    lstrcpy(DriverInfoData->MfgName,
            StringPtr
           );

    if(DriverNode->ProviderDisplayName != -1) {

        StringPtr = pStringTableStringFromId(DeviceInfoSet->StringTable,
                                             DriverNode->ProviderDisplayName
                                            );
        lstrcpy(DriverInfoData->ProviderName,
                StringPtr
               );

    }

    //
    // The 'Reserved' field actually contains a pointer to the
    // corresponding driver node.
    //
    DriverInfoData->Reserved = (ULONG_PTR)DriverNode;

    //
    //new NT 5 fields
    //
    if (DriverInfoDataSize == sizeof(SP_DRVINFO_DATA)) {
        DriverInfoData->DriverDate = DriverNode->DriverDate;
        DriverInfoData->DriverVersion = DriverNode->DriverVersion;
    }

    return TRUE;
}


PDRIVER_NODE
FindAssociatedDriverNode(
    IN  PDRIVER_NODE      DriverListHead,
    IN  PSP_DRVINFO_DATA  DriverInfoData,
    OUT PDRIVER_NODE     *PreviousNode    OPTIONAL
    )
/*++

Routine Description:

    This routine searches through all driver nodes in a driver node
    list, looking for one that corresponds to the specified driver
    information structure.  If a match is found, a pointer to the
    driver node is returned.

Arguments:

    DriverListHead - Supplies a pointer to the head of linked list
        of driver nodes to be searched.

    DriverInfoData - Supplies a pointer to a driver information buffer
        specifying the driver node to retrieve.

    PreviousNode - Optionally, supplies the address of a DRIVER_NODE
        pointer that receives the node that precedes the specified
        node in the linked list.  If the returned node is located at
        the front of the list, then this value will be set to NULL.

Return Value:

    If a driver node is found, the return value is a pointer to that
    node, otherwise, the return value is NULL.

--*/
{
    PDRIVER_NODE DriverNode, CurNode, PrevNode;

    if(((DriverInfoData->cbSize != sizeof(SP_DRVINFO_DATA)) &&
        (DriverInfoData->cbSize != sizeof(SP_DRVINFO_DATA_V1))) ||
       !(DriverNode = (PDRIVER_NODE)DriverInfoData->Reserved)) {

        return NULL;
    }

    for(CurNode = DriverListHead, PrevNode = NULL;
        CurNode;
        PrevNode = CurNode, CurNode = CurNode->Next) {

        if(CurNode == DriverNode) {
            //
            // We found the driver node in our list.
            //
            if(PreviousNode) {
                *PreviousNode = PrevNode;
            }
            return CurNode;
        }
    }

    return NULL;
}


PDRIVER_NODE
SearchForDriverNode(
    IN  PVOID             StringTable,
    IN  PDRIVER_NODE      DriverListHead,
    IN  PSP_DRVINFO_DATA  DriverInfoData,
    OUT PDRIVER_NODE     *PreviousNode    OPTIONAL
    )
/*++

Routine Description:

    This routine searches through all driver nodes in a driver node
    list, looking for one that matches the fields in the specified
    driver information structure (the 'Reserved' field is ignored).
    If a match is found, a pointer to the driver node is returned.

Arguments:

    StringTable - Supplies the string table that should be used in
        retrieving string IDs for driver look-up.

    DriverListHead - Supplies a pointer to the head of linked list
        of driver nodes to be searched.

    DriverInfoData - Supplies a pointer to a driver information buffer
        specifying the driver parameters we're looking for.

    PreviousNode - Optionally, supplies the address of a DRIVER_NODE
        pointer that receives the node that precedes the specified
        node in the linked list.  If the returned node is located at
        the front of the list, then this value will be set to NULL.

Return Value:

    If a driver node is found, the return value is a pointer to that
    node, otherwise, the return value is NULL.

--*/
{
    PDRIVER_NODE CurNode, PrevNode;
    LONG DevDescription, MfgName, ProviderName;
    TCHAR TempString[LINE_LEN];
    DWORD TempStringLength;
    BOOL  Match;

    MYASSERT((DriverInfoData->cbSize == sizeof(SP_DRVINFO_DATA)) ||
             (DriverInfoData->cbSize == sizeof(SP_DRVINFO_DATA_V1)));

    //
    // Retrieve the string IDs for the 3 driver parameters we'll be
    // matching against.
    //
    lstrcpyn(TempString, DriverInfoData->Description, SIZECHARS(TempString));
    if((DevDescription = pStringTableLookUpString(
                             StringTable,
                             TempString,
                             &TempStringLength,
                             NULL,
                             NULL,
                             STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                             NULL,0)) == -1) {

        return NULL;
    }

    lstrcpyn(TempString, DriverInfoData->MfgName, SIZECHARS(TempString));
    if((MfgName = pStringTableLookUpString(
                             StringTable,
                             TempString,
                             &TempStringLength,
                             NULL,
                             NULL,
                             STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                             NULL,0)) == -1) {

        return NULL;
    }

    //
    // ProviderName may be empty...
    //
    if(*(DriverInfoData->ProviderName)) {

        lstrcpyn(TempString, DriverInfoData->ProviderName, SIZECHARS(TempString));
        if((ProviderName = pStringTableLookUpString(
                                 StringTable,
                                 TempString,
                                 &TempStringLength,
                                 NULL,
                                 NULL,
                                 STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                 NULL,0)) == -1) {

            return NULL;
        }

    } else {
        ProviderName = -1;
    }

    for(CurNode = DriverListHead, PrevNode = NULL;
        CurNode;
        PrevNode = CurNode, CurNode = CurNode->Next)
    {
        //
        // Check first on DevDescription (least likely to match), then on MfgName, and finally
        // on ProviderName. On NT 5 and later we will also check the DriverDate and DriverVersion.
        //
        if(CurNode->DevDescription == DevDescription) {

            if(CurNode->MfgName == MfgName) {

                if(CurNode->ProviderName == ProviderName) {

                    //
                    //On NT 5 and later, also compare the DriverDate and DriverVersion
                    //
                    if (DriverInfoData->cbSize == sizeof(SP_DRVINFO_DATA)) {

                        //
                        //Assume that we have a match
                        //
                        Match = TRUE;

                        //
                        //If the DriverDate passed in is not 0 then make sure it matches
                        //
                        if (DriverInfoData->DriverDate.dwLowDateTime != 0 ||
                            DriverInfoData->DriverDate.dwHighDateTime != 0) {

                            if ((CurNode->DriverDate.dwLowDateTime != DriverInfoData->DriverDate.dwLowDateTime) ||
                                (CurNode->DriverDate.dwHighDateTime != DriverInfoData->DriverDate.dwHighDateTime)) {

                                Match = FALSE;
                            }
                        }

                        //
                        //If the DriverVersion passed in is not 0 then make sure it matches
                        //
                        else if (DriverInfoData->DriverVersion != 0) {

                            if (CurNode->DriverVersion != DriverInfoData->DriverVersion) {

                                Match = FALSE;
                            }
                        }

                        if (Match) {

                            //
                            // We found the driver node in our list.
                            //
                            if(PreviousNode) {
                                *PreviousNode = PrevNode;
                            }
                            return CurNode;
                        }

                    } else {

                        //
                        // We found the driver node in our list.
                        //
                        if(PreviousNode) {
                            *PreviousNode = PrevNode;
                        }
                        return CurNode;
                    }
                }
            }
        }
    }

    return NULL;
}


DWORD
DrvInfoDetailsFromDriverNode(
    IN  PDEVICE_INFO_SET        DeviceInfoSet,
    IN  PDRIVER_NODE            DriverNode,
    OUT PSP_DRVINFO_DETAIL_DATA DriverInfoDetailData, OPTIONAL
    IN  DWORD                   BufferSize,
    OUT PDWORD                  RequiredSize          OPTIONAL
    )
/*++

Routine Description:

    This routine fills in a SP_DRVINFO_DETAIL_DATA structure based on the
    information in the supplied DRIVER_NODE structure.

    If the buffer is supplied, and is valid, this routine is guaranteed to
    fill in all statically-sized fields, and as many IDs as will fit in the
    variable-length multi-sz buffer.

    Note:  If supplied, the DriverInfoDetailData structure must have its
    cbSize field filled in correctly, or the call will fail. Here correctly
    means sizeof(SP_DRVINFO_DETAIL_DATA), which we use as a signature.
    This is entirely separate from BufferSize. See below.

Arguments:

    DeviceInfoSet - Supplies a pointer to the device information set
        in which the driver node is located.

    DriverNode - Supplies a pointer to the DRIVER_NODE structure
        containing information to be used in filling in the
        SP_DRVNFO_DETAIL_DATA buffer.

    DriverInfoDetailData - Optionally, supplies a pointer to the buffer
        that will receive the filled-in SP_DRVINFO_DETAIL_DATA structure.
        If this buffer is not supplied, then the caller is only interested
        in what the RequiredSize for the buffer is.

    BufferSize - Supplies size of the DriverInfoDetailData buffer, in
        bytes.  If DriverInfoDetailData is not specified, then this
        value must be zero. This value must be at least the size
        of the fixed part of the structure (ie,
        offsetof(SP_DRVINFO_DETAIL_DATA,HardwareID)) plus sizeof(TCHAR),
        which gives us enough room to store the fixed part plus
        a terminating nul to guarantee we return at least a valid
        empty multi_sz.

    RequiredSize - Optionally, supplies the address of a variable that
        receives the number of bytes required to store the data. Note that
        depending on structure alignment and the data itself, this may
        actually be *smaller* than sizeof(SP_DRVINFO_DETAIL_DATA).

Return Value:

    If the function succeeds, the return value is NO_ERROR.
    If the function fails, an ERROR_* code is returned.

--*/
{
    PTSTR StringPtr, BufferPtr;
    DWORD IdListLen, CompatIdListLen, StringLen, TotalLen, i;
    DWORD Err = ERROR_INSUFFICIENT_BUFFER;

    #define FIXEDPARTLEN offsetof(SP_DRVINFO_DETAIL_DATA,HardwareID)

    if(DriverInfoDetailData) {
        //
        // Check validity of the DriverInfoDetailData buffer on the way in,
        // and make sure we have enough room for the fixed part
        // of the structure plus the extra nul that will terminate the
        // multi_sz.
        //
        if((DriverInfoDetailData->cbSize != sizeof(SP_DRVINFO_DETAIL_DATA))
        || (BufferSize < (FIXEDPARTLEN+sizeof(TCHAR)))) {

            return ERROR_INVALID_USER_BUFFER;
        }
        //
        // The buffer is large enough to contain at least the fixed-length part
        // of the structure.
        //
        Err = NO_ERROR;

    } else if(BufferSize) {
        return ERROR_INVALID_USER_BUFFER;
    }

    if(DriverInfoDetailData) {

        ZeroMemory(DriverInfoDetailData,FIXEDPARTLEN);
        DriverInfoDetailData->cbSize = FIXEDPARTLEN + sizeof(TCHAR);

        DriverInfoDetailData->InfDate = DriverNode->InfDate;

        MYASSERT(DriverNode->InfSectionName != -1);
        StringPtr = pStringTableStringFromId(DeviceInfoSet->StringTable,
                                             DriverNode->InfSectionName
                                            );
        lstrcpyn(DriverInfoDetailData->SectionName, StringPtr,sizeof(DriverInfoDetailData->SectionName)/sizeof(TCHAR));

        MYASSERT(DriverNode->InfFileName != -1);
        StringPtr = pStringTableStringFromId(DeviceInfoSet->StringTable,
                                             DriverNode->InfFileName
                                            );
        lstrcpyn(DriverInfoDetailData->InfFileName, StringPtr,sizeof(DriverInfoDetailData->InfFileName)/sizeof(TCHAR));

        MYASSERT(DriverNode->DrvDescription != -1);
        StringPtr = pStringTableStringFromId(DeviceInfoSet->StringTable,
                                             DriverNode->DrvDescription
                                            );
        lstrcpyn(DriverInfoDetailData->DrvDescription, StringPtr,sizeof(DriverInfoDetailData->DrvDescription)/sizeof(TCHAR));

        //
        // Initialize the multi_sz to be empty.
        //
        DriverInfoDetailData->HardwareID[0] = 0;

        //
        // The 'Reserved' field actually contains a pointer to the
        // corresponding driver node.
        //
        DriverInfoDetailData->Reserved = (ULONG_PTR)DriverNode;
    }

    //
    // Now, build the multi-sz buffer containing the hardware and compatible IDs.
    //
    if(DriverNode->HardwareId == -1) {
        //
        // If there's no HardwareId, then we know there are no compatible IDs, so
        // we can return right now.
        //
        if(RequiredSize) {
            *RequiredSize = FIXEDPARTLEN + sizeof(TCHAR);
        }
        return Err;
    }

    if(DriverInfoDetailData) {
        BufferPtr = DriverInfoDetailData->HardwareID;
        IdListLen = (BufferSize - FIXEDPARTLEN) / sizeof(TCHAR);
    } else {
        IdListLen = 0;
    }

    //
    // Retrieve the HardwareId.
    //
    StringPtr = pStringTableStringFromId(DeviceInfoSet->StringTable,
                                         DriverNode->HardwareId
                                        );

    TotalLen = StringLen = lstrlen(StringPtr) + 1; // include nul terminator

    if(StringLen < IdListLen) {
        MYASSERT(Err == NO_ERROR);
        CopyMemory(BufferPtr,
                   StringPtr,
                   StringLen * sizeof(TCHAR)
                  );
        BufferPtr += StringLen;
        IdListLen -= StringLen;
        DriverInfoDetailData->CompatIDsOffset = StringLen;
    } else {
        if(RequiredSize) {
            //
            // Since the caller requested the required size, we can't just return
            // here.  Set the error, so we'll know not to bother trying to fill
            // the buffer.
            //
            Err = ERROR_INSUFFICIENT_BUFFER;
        } else {
            return ERROR_INSUFFICIENT_BUFFER;
        }
    }

    //
    // Remember the size of the buffer left over for CompatibleIDs.
    //
    CompatIdListLen = IdListLen;

    //
    // Now retrieve the CompatibleIDs.
    //
    for(i = 0; i < DriverNode->NumCompatIds; i++) {

        MYASSERT(DriverNode->CompatIdList[i] != -1);

        StringPtr = pStringTableStringFromId(DeviceInfoSet->StringTable,
                                             DriverNode->CompatIdList[i]
                                            );
        StringLen = lstrlen(StringPtr) + 1;

        if(Err == NO_ERROR) {

            if(StringLen < IdListLen) {
                CopyMemory(BufferPtr,
                           StringPtr,
                           StringLen * sizeof(TCHAR)
                          );
                BufferPtr += StringLen;
                IdListLen -= StringLen;

            } else {

                Err = ERROR_INSUFFICIENT_BUFFER;
                if(!RequiredSize) {
                    //
                    // We've run out of buffer, and the caller doesn't care what
                    // the total required size is, so bail now.
                    //
                    break;
                }
            }
        }

        TotalLen += StringLen;
    }

    if(DriverInfoDetailData) {
        //
        // Append the additional terminating nul.  Note that we've been saving the
        // last character position in the buffer all along, so we're guaranteed to
        // be inside the buffer.
        //
        MYASSERT(BufferPtr < (PTSTR)((PBYTE)DriverInfoDetailData + BufferSize));
        *BufferPtr = 0;

        //
        // Store the length of the CompatibleIDs list.  Note that this is the length
        // of the list actually returned, which may be less than the length of the
        // entire list (if the caller-supplied buffer wasn't large enough).
        //
        if(CompatIdListLen -= IdListLen) {
            //
            // If this list is non-empty, then add a character for the extra nul
            // terminating the multi-sz list.
            //
            CompatIdListLen++;
        }
        DriverInfoDetailData->CompatIDsLength = CompatIdListLen;
    }

    if(RequiredSize) {
        *RequiredSize = FIXEDPARTLEN + ((TotalLen + 1) * sizeof(TCHAR));
    }

    return Err;
}


PDRIVER_LIST_OBJECT
GetAssociatedDriverListObject(
    IN  PDRIVER_LIST_OBJECT  ObjectListHead,
    IN  PDRIVER_NODE         DriverListHead,
    OUT PDRIVER_LIST_OBJECT *PrevDriverListObject OPTIONAL
    )
/*++

Routine Description:

    This routine searches through a driver list object list, and returns a
    pointer to the driver list object containing the list specified by
    DrvListHead.  It also optionally returns the preceding object in the list
    (used when extracting the driver list object from the linked list).

Arguments:

    ObjectListHead - Specifies the linked list of driver list objects to be
        searched.

    DriverListHead - Specifies the driver list to be searched for.

    PrevDriverListObject - Optionaly, supplies the address of the variable that
        receives a pointer to the driver list object immediately preceding the
        matching object.  If the object was found at the front of the list, then
        this variable will be set to NULL.

Return Value:

    If the matching driver list object is found, the return value is a pointer
    to that element, otherwise, the return value is NULL.

--*/
{
    PDRIVER_LIST_OBJECT prev = NULL;

    while(ObjectListHead) {

        if(ObjectListHead->DriverListHead == DriverListHead) {

            if(PrevDriverListObject) {
                *PrevDriverListObject = prev;
            }

            return ObjectListHead;
        }

        prev = ObjectListHead;
        ObjectListHead = ObjectListHead->Next;
    }

    return NULL;
}


VOID
DereferenceClassDriverList(
    IN PDEVICE_INFO_SET DeviceInfoSet,
    IN PDRIVER_NODE     DriverListHead OPTIONAL
    )
/*++

Routine Description:

    This routine dereferences the class driver list object associated with the
    supplied DriverListHead.  If the refcount goes to zero, the object is destroyed,
    and all associated memory is freed.

Arguments:

    DeviceInfoSet - Supplies the address of the device information set containing the
        linked list of class driver list objects.

    DriverListHead - Optionally, supplies a pointer to the header of the driver list
        to be dereferenced.  If this parameter is not supplied, the routine does nothing.

Return Value:

    None.

--*/
{
    PDRIVER_LIST_OBJECT DrvListObject, PrevDrvListObject;

    if(DriverListHead) {

        DrvListObject = GetAssociatedDriverListObject(DeviceInfoSet->ClassDrvListObjectList,
                                                      DriverListHead,
                                                      &PrevDrvListObject
                                                     );
        MYASSERT(DrvListObject && DrvListObject->RefCount);

        if(!(--DrvListObject->RefCount)) {

            if(PrevDrvListObject) {
                PrevDrvListObject->Next = DrvListObject->Next;
            } else {
                DeviceInfoSet->ClassDrvListObjectList = DrvListObject->Next;
            }
            MyFree(DrvListObject);

            DestroyDriverNodes(DriverListHead, DeviceInfoSet);
        }
    }
}


DWORD
GetDevInstallParams(
    IN  PDEVICE_INFO_SET        DeviceInfoSet,
    IN  PDEVINSTALL_PARAM_BLOCK DevInstParamBlock,
    OUT PSP_DEVINSTALL_PARAMS   DeviceInstallParams
    )
/*++

Routine Description:

    This routine fills in a SP_DEVINSTALL_PARAMS structure based on the
    installation parameter block supplied.

    Note:  The DeviceInstallParams structure must have its cbSize field
    filled in correctly, or the call will fail.

Arguments:

    DeviceInfoSet - Supplies the address of the device information set
        containing the parameters to be retrieved.  (This parameter is
        used to gain access to the string table for some of the string
        parameters).

    DevInstParamBlock - Supplies the address of an installation parameter
        block containing the parameters to be used in filling out the
        return buffer.

    DeviceInstallParams - Supplies the address of a buffer that will
        receive the filled-in SP_DEVINSTALL_PARAMS structure.

Return Value:

    If the function succeeds, the return value is NO_ERROR.
    If the function fails, an ERROR_* code is returned.

--*/
{
    PTSTR StringPtr;

    if(DeviceInstallParams->cbSize != sizeof(SP_DEVINSTALL_PARAMS)) {
        return ERROR_INVALID_USER_BUFFER;
    }

    //
    // Fill in parameters.
    //
    ZeroMemory(DeviceInstallParams, sizeof(SP_DEVINSTALL_PARAMS));
    DeviceInstallParams->cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    DeviceInstallParams->Flags                    = DevInstParamBlock->Flags;
    DeviceInstallParams->FlagsEx                  = DevInstParamBlock->FlagsEx;
    DeviceInstallParams->hwndParent               = DevInstParamBlock->hwndParent;
    DeviceInstallParams->InstallMsgHandler        = DevInstParamBlock->InstallMsgHandler;
    DeviceInstallParams->InstallMsgHandlerContext = DevInstParamBlock->InstallMsgHandlerContext;
    DeviceInstallParams->FileQueue                = DevInstParamBlock->UserFileQ;
    DeviceInstallParams->ClassInstallReserved     = DevInstParamBlock->ClassInstallReserved;
    //
    // The Reserved field is currently unused.
    //

    if(DevInstParamBlock->DriverPath != -1) {
        StringPtr = pStringTableStringFromId(DeviceInfoSet->StringTable,
                                             DevInstParamBlock->DriverPath
                                            );
        lstrcpy(DeviceInstallParams->DriverPath, StringPtr);
    }

    return NO_ERROR;
}


DWORD
GetClassInstallParams(
    IN  PDEVINSTALL_PARAM_BLOCK DevInstParamBlock,
    OUT PSP_CLASSINSTALL_HEADER ClassInstallParams, OPTIONAL
    IN  DWORD                   BufferSize,
    OUT PDWORD                  RequiredSize        OPTIONAL
    )
/*++

Routine Description:

    This routine fills in a buffer with the class installer parameters (if any)
    contained in the installation parameter block supplied.

    Note:  If supplied, the ClassInstallParams structure must have the cbSize
    field of the embedded SP_CLASSINSTALL_HEADER structure set to the size, in bytes,
    of the header.  If this is not set correctly, the call will fail.

Arguments:

    DevInstParamBlock - Supplies the address of an installation parameter block
        containing the class installer parameters to be used in filling out the
        return buffer.

    DeviceInstallParams - Optionally, supplies the address of a buffer
        that will receive the class installer parameters structure currently
        stored in the installation parameters block.  If this parameter is not
        supplied, then BufferSize must be zero.

    BufferSize - Supplies the size, in bytes, of the DeviceInstallParams
        buffer, or zero if DeviceInstallParams is not supplied.

    RequiredSize - Optionally, supplies the address of a variable that
        receives the number of bytes required to store the data.

Return Value:

    If the function succeeds, the return value is NO_ERROR.
    If the function fails, an ERROR_* code is returned.

--*/
{
    //
    // First, see whether we have any class install params, and if not, return
    // ERROR_NO_CLASSINSTALL_PARAMS.
    //
    if(!DevInstParamBlock->ClassInstallHeader) {
        return ERROR_NO_CLASSINSTALL_PARAMS;
    }

    if(ClassInstallParams) {

        if((BufferSize < sizeof(SP_CLASSINSTALL_HEADER)) ||
           (ClassInstallParams->cbSize != sizeof(SP_CLASSINSTALL_HEADER))) {

            return ERROR_INVALID_USER_BUFFER;
        }

    } else if(BufferSize) {
        return ERROR_INVALID_USER_BUFFER;
    }

    //
    // Store required size in output parameter (if requested).
    //
    if(RequiredSize) {
        *RequiredSize = DevInstParamBlock->ClassInstallParamsSize;
    }

    //
    // See if supplied buffer is large enough.
    //
    if(BufferSize < DevInstParamBlock->ClassInstallParamsSize) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    CopyMemory((PVOID)ClassInstallParams,
               (PVOID)DevInstParamBlock->ClassInstallHeader,
               DevInstParamBlock->ClassInstallParamsSize
              );

    return NO_ERROR;
}


DWORD
SetDevInstallParams(
    IN OUT PDEVICE_INFO_SET        DeviceInfoSet,
    IN     PSP_DEVINSTALL_PARAMS   DeviceInstallParams,
    OUT    PDEVINSTALL_PARAM_BLOCK DevInstParamBlock,
    IN     BOOL                    MsgHandlerIsNativeCharWidth
    )
/*++

Routine Description:

    This routine updates an internal parameter block based on the parameters
    supplied in a SP_DEVINSTALL_PARAMS structure.

    Note:  The supplied DeviceInstallParams structure must have its cbSize
    field filled in correctly, or the call will fail.

Arguments:

    DeviceInfoSet - Supplies the address of the device information set
        containing the parameters to be set.

    DeviceInstallParams - Supplies the address of a buffer containing the new
        installation parameters.

    DevInstParamBlock - Supplies the address of an installation parameter
        block to be updated.

    MsgHandlerIsNativeCharWidth - supplies a flag indicating whether the
        InstallMsgHandler in the DeviceInstallParams structure points to
        a callback routine that is expecting arguments in the 'native'
        character format. A value of FALSE is meaningful only in the
        Unicode build and specifies that the callback routine wants
        ANSI parameters.

Return Value:

    If the function succeeds, the return value is NO_ERROR.
    If the function fails, an ERROR_* code is returned.

--*/
{
    DWORD DriverPathLen;
    LONG StringId;
    TCHAR TempString[MAX_PATH];
    HSPFILEQ OldQueueHandle = NULL;
    BOOL bRestoreQueue = FALSE;

    if(DeviceInstallParams->cbSize != sizeof(SP_DEVINSTALL_PARAMS)) {
        return ERROR_INVALID_USER_BUFFER;
    }

    //
    // No validation is currently required for the hwndParent, InstallMsgHandler,
    // InstallMsgHandlerContext, or ClassInstallReserved fields.
    //

    //
    // Validate Flags(Ex)
    //
    if((DeviceInstallParams->Flags & DI_FLAGS_ILLEGAL) ||
       (DeviceInstallParams->FlagsEx & DI_FLAGSEX_ILLEGAL)) {

        return ERROR_INVALID_FLAGS;
    }

    //
    // Make sure that if DI_CLASSINSTALLPARAMS is being set, that we really do have
    // class install parameters.
    //
    if((DeviceInstallParams->Flags & DI_CLASSINSTALLPARAMS) &&
       !(DevInstParamBlock->ClassInstallHeader)) {

        return ERROR_NO_CLASSINSTALL_PARAMS;
    }

    //
    // Make sure that if DI_NOVCP is being set, that we have a caller-supplied file queue.
    //
    if((DeviceInstallParams->Flags & DI_NOVCP) &&
       ((DeviceInstallParams->FileQueue == NULL) || (DeviceInstallParams->FileQueue == INVALID_HANDLE_VALUE))) {

        return ERROR_INVALID_FLAGS;
    }

    //
    // Make sure that if DI_FLAGSEX_ALTPLATFORM_DRVSEARCH is being set, that we
    // have a caller-supplied file queue.
    //
    // NOTE: We don't actually verify at this time that the file queue has
    // alternate platform info associated with it--this association can
    // actually be done later.  We _will_ catch this (and return an error) in
    // SetupDiBuildDriverInfoList if at that time we find that the file queue
    // has no alt platform info.
    //
    if((DeviceInstallParams->FlagsEx & DI_FLAGSEX_ALTPLATFORM_DRVSEARCH) &&
       !(DeviceInstallParams->Flags & DI_NOVCP)) {

        return ERROR_INVALID_PARAMETER;
    }

    //
    // Validate that the DriverPath string is properly NULL-terminated.
    //
    if((DriverPathLen = lstrlen(DeviceInstallParams->DriverPath)) >= MAX_PATH) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Validate the caller-supplied file queue.
    //
    if((DeviceInstallParams->FileQueue == NULL) || (DeviceInstallParams->FileQueue == INVALID_HANDLE_VALUE)) {
        //
        // Store the current file queue handle (if any) to be released later.
        //
        OldQueueHandle = DevInstParamBlock->UserFileQ;
        DevInstParamBlock->UserFileQ = NULL;
        bRestoreQueue = TRUE;

    } else {
        //
        // The caller supplied a file queue handle.  See if it's the same one
        // we already have.
        //
        if(DeviceInstallParams->FileQueue != DevInstParamBlock->UserFileQ) {
            //
            // The caller has supplied a file queue handle that's different
            // from the one we currently have stored.  Remember the old handle
            // (in case we need to restore), and store the new handle.  Also,
            // increment the lock refcount on the new handle (enclose in
            // try/except in case it's a bogus one).
            //
            OldQueueHandle = DevInstParamBlock->UserFileQ;
            bRestoreQueue = TRUE;

            try {
                if(((PSP_FILE_QUEUE)(DeviceInstallParams->FileQueue))->Signature == SP_FILE_QUEUE_SIG) {

                    ((PSP_FILE_QUEUE)(DeviceInstallParams->FileQueue))->LockRefCount++;
                    DevInstParamBlock->UserFileQ = DeviceInstallParams->FileQueue;

                } else {
                    //
                    // Queue's signature isn't valid
                    //
                    bRestoreQueue = FALSE;
                }

            } except(EXCEPTION_EXECUTE_HANDLER) {
                DevInstParamBlock->UserFileQ = OldQueueHandle;
                bRestoreQueue = FALSE;
            }

            if(!bRestoreQueue) {
                //
                // The file queue handle we were given was invalid.
                //
                return ERROR_INVALID_PARAMETER;
            }
        }
    }

    //
    // Store the specified driver path.
    //
    if(DriverPathLen) {
        lstrcpy(TempString, DeviceInstallParams->DriverPath);
        if((StringId = pStringTableAddString(DeviceInfoSet->StringTable,
                                             TempString,
                                             STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                             NULL,0
                                            )) == -1) {
            //
            // We couldn't add the new driver path string to the string table.  Restore the old
            // file queue (if necessary) and return an out-of-memory error.
            //
            if(bRestoreQueue) {

                if(DevInstParamBlock->UserFileQ) {
                    try {
                        ((PSP_FILE_QUEUE)(DevInstParamBlock->UserFileQ))->LockRefCount--;
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        ;   // nothing to do
                    }
                }
                DevInstParamBlock->UserFileQ = OldQueueHandle;
            }
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        DevInstParamBlock->DriverPath = StringId;
    } else {
        DevInstParamBlock->DriverPath = -1;
    }

    //
    // Should be smooth sailing from here on out.  Decrement the refcount on the old queue handle,
    // if there was one.
    //
    if(OldQueueHandle) {
        try {
            MYASSERT(((PSP_FILE_QUEUE)OldQueueHandle)->LockRefCount);
            ((PSP_FILE_QUEUE)OldQueueHandle)->LockRefCount--;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            ; // nothing to do
        }
    }

    //
    // Ignore attempts at modifying read-only flags.
    //
    DevInstParamBlock->Flags   = (DeviceInstallParams->Flags & ~DI_FLAGS_READONLY) |
                                 (DevInstParamBlock->Flags   &  DI_FLAGS_READONLY);

    DevInstParamBlock->FlagsEx = (DeviceInstallParams->FlagsEx & ~DI_FLAGSEX_READONLY) |
                                 (DevInstParamBlock->FlagsEx   &  DI_FLAGSEX_READONLY);

    //
    // Additionally, if we're in non-interactive mode, make sure not to clear
    // our "be quiet" flags.
    //
    if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
        DevInstParamBlock->Flags   |= DI_QUIETINSTALL;
        DevInstParamBlock->FlagsEx |= DI_FLAGSEX_NOUIONQUERYREMOVE;
    }

    //
    // Store the rest of the parameters.
    //
    DevInstParamBlock->hwndParent               = DeviceInstallParams->hwndParent;
    DevInstParamBlock->InstallMsgHandler        = DeviceInstallParams->InstallMsgHandler;
    DevInstParamBlock->InstallMsgHandlerContext = DeviceInstallParams->InstallMsgHandlerContext;
    DevInstParamBlock->ClassInstallReserved     = DeviceInstallParams->ClassInstallReserved;

    DevInstParamBlock->InstallMsgHandlerIsNativeCharWidth = MsgHandlerIsNativeCharWidth;

    return NO_ERROR;
}


DWORD
SetClassInstallParams(
    IN OUT PDEVICE_INFO_SET        DeviceInfoSet,
    IN     PSP_CLASSINSTALL_HEADER ClassInstallParams,    OPTIONAL
    IN     DWORD                   ClassInstallParamsSize,
    OUT    PDEVINSTALL_PARAM_BLOCK DevInstParamBlock
    )
/*++

Routine Description:

    This routine updates an internal class installer parameter block based on
    the parameters supplied in a class installer parameter buffer.  If this
    buffer is not supplied, then the existing class installer parameters (if
    any) are cleared.

Arguments:

    DeviceInfoSet - Supplies the address of the device information set
        for which class installer parameters are to be set.

    ClassInstallParams - Optionally, supplies the address of a buffer containing
        the class installer parameters to be used.    The SP_CLASSINSTALL_HEADER
        structure at the beginning of the buffer must have its cbSize field set to
        be sizeof(SP_CLASSINSTALL_HEADER), and the InstallFunction field must be
        set to the DI_FUNCTION code reflecting the type of parameters supplied in
        the rest of the buffer.

        If this parameter is not supplied, then the current class installer parameters
        (if any) will be cleared for the specified device information set or element.

    ClassInstallParamsSize - Supplies the size, in bytes, of the ClassInstallParams
        buffer.  If the buffer is not supplied (i.e., the class installer parameters
        are to be cleared), then this value must be zero.

    DevInstParamBlock - Supplies the address of an installation parameter
        block to be updated.

Return Value:

    If the function succeeds, the return value is NO_ERROR.
    If the function fails, an ERROR_* code is returned.

--*/
{
    PBYTE NewParamBuffer;

    if(ClassInstallParams) {

        if((ClassInstallParamsSize < sizeof(SP_CLASSINSTALL_HEADER)) ||
           (ClassInstallParams->cbSize != sizeof(SP_CLASSINSTALL_HEADER))) {

            return ERROR_INVALID_USER_BUFFER;
        }

    } else {
        //
        // We are to clear any existing class installer parameters.
        //
        if(ClassInstallParamsSize) {
            return ERROR_INVALID_USER_BUFFER;
        }

        if(DevInstParamBlock->ClassInstallHeader) {
            MyFree(DevInstParamBlock->ClassInstallHeader);
            DevInstParamBlock->ClassInstallHeader = NULL;
            DevInstParamBlock->ClassInstallParamsSize = 0;
            DevInstParamBlock->Flags &= ~DI_CLASSINSTALLPARAMS;
        }

        return NO_ERROR;
    }


    //
    // Validate the new class install parameters w.r.t. the value of the specified
    // InstallFunction code.
    //
    switch(ClassInstallParams->InstallFunction) {

        case DIF_ENABLECLASS :
            //
            // We should have a SP_ENABLECLASS_PARAMS structure.
            //
            if(ClassInstallParamsSize == sizeof(SP_ENABLECLASS_PARAMS)) {

                PSP_ENABLECLASS_PARAMS EnableClassParams;

                EnableClassParams = (PSP_ENABLECLASS_PARAMS)ClassInstallParams;
                //
                // Don't bother validating GUID--just validate EnableMessage field.
                //
                if(EnableClassParams->EnableMessage <= ENABLECLASS_FAILURE) {
                    //
                    // parameter set validated.
                    //
                    break;
                }
            }
            return ERROR_INVALID_PARAMETER;

        case DIF_MOVEDEVICE :
            //
            // We should have a SP_MOVEDEV_PARAMS structure.
            //
            if(ClassInstallParamsSize == sizeof(SP_MOVEDEV_PARAMS)) {

                PSP_MOVEDEV_PARAMS MoveDevParams;

                MoveDevParams = (PSP_MOVEDEV_PARAMS)ClassInstallParams;
                if(FindAssociatedDevInfoElem(DeviceInfoSet,
                                             &(MoveDevParams->SourceDeviceInfoData),
                                             NULL)) {
                    //
                    // parameter set validated.
                    //
                    break;
                }
            }
            return ERROR_INVALID_PARAMETER;

        case DIF_PROPERTYCHANGE :
            //
            // We should have a SP_PROPCHANGE_PARAMS structure.
            //
            if(ClassInstallParamsSize == sizeof(SP_PROPCHANGE_PARAMS)) {

                PSP_PROPCHANGE_PARAMS PropChangeParams;

                PropChangeParams = (PSP_PROPCHANGE_PARAMS)ClassInstallParams;
                if((PropChangeParams->StateChange >= DICS_ENABLE) &&
                   (PropChangeParams->StateChange <= DICS_STOP)) {

                    //
                    // Validate Scope specifier--even though these values are defined like
                    // flags, they are mutually exclusive, so treat them like ordinals.
                    //
                    if((PropChangeParams->Scope == DICS_FLAG_GLOBAL) ||
                       (PropChangeParams->Scope == DICS_FLAG_CONFIGSPECIFIC) ||
                       (PropChangeParams->Scope == DICS_FLAG_CONFIGGENERAL)) {

                        //
                        // DICS_START and DICS_STOP are always config specific.
                        //
                        if(((PropChangeParams->StateChange == DICS_START) || (PropChangeParams->StateChange == DICS_STOP)) &&
                           (PropChangeParams->Scope != DICS_FLAG_CONFIGSPECIFIC)) {

                            goto BadPropChangeParams;
                        }

                        //
                        // parameter set validated
                        //
                        // NOTE: Even though DICS_FLAG_CONFIGSPECIFIC indicates
                        // that the HwProfile field specifies a hardware profile,
                        // there's no need to do validation on that.
                        //
                        break;
                    }
                }
            }

BadPropChangeParams:
            return ERROR_INVALID_PARAMETER;

        case DIF_REMOVE :
            //
            // We should have a SP_REMOVEDEVICE_PARAMS structure.
            //
            if(ClassInstallParamsSize == sizeof(SP_REMOVEDEVICE_PARAMS)) {

                PSP_REMOVEDEVICE_PARAMS RemoveDevParams;

                RemoveDevParams = (PSP_REMOVEDEVICE_PARAMS)ClassInstallParams;
                if((RemoveDevParams->Scope == DI_REMOVEDEVICE_GLOBAL) ||
                   (RemoveDevParams->Scope == DI_REMOVEDEVICE_CONFIGSPECIFIC)) {
                    //
                    // parameter set validated
                    //
                    // NOTE: Even though DI_REMOVEDEVICE_CONFIGSPECIFIC indicates
                    // that the HwProfile field specifies a hardware profile,
                    // there's no need to do validation on that.
                    //
                    break;
                }
            }
            return ERROR_INVALID_PARAMETER;

        case DIF_UNREMOVE :
            //
            // We should have a SP_UNREMOVEDEVICE_PARAMS structure.
            //
            if(ClassInstallParamsSize == sizeof(SP_UNREMOVEDEVICE_PARAMS)) {

                PSP_UNREMOVEDEVICE_PARAMS UnremoveDevParams;

                UnremoveDevParams = (PSP_UNREMOVEDEVICE_PARAMS)ClassInstallParams;
                if(UnremoveDevParams->Scope == DI_UNREMOVEDEVICE_CONFIGSPECIFIC) {
                    //
                    // parameter set validated
                    //
                    // NOTE: Even though DI_UNREMOVEDEVICE_CONFIGSPECIFIC indicates
                    // that the HwProfile field specifies a hardware profile,
                    // there's no need to do validation on that.
                    //
                    break;
                }
            }
            return ERROR_INVALID_PARAMETER;

        case DIF_SELECTDEVICE :
            //
            // We should have a SP_SELECTDEVICE_PARAMS structure.
            //
            if(ClassInstallParamsSize == sizeof(SP_SELECTDEVICE_PARAMS)) {

                PSP_SELECTDEVICE_PARAMS SelectDevParams;

                SelectDevParams = (PSP_SELECTDEVICE_PARAMS)ClassInstallParams;
                //
                // Validate that the string fields are properly NULL-terminated.
                //
                if((lstrlen(SelectDevParams->Title) < MAX_TITLE_LEN) &&
                   (lstrlen(SelectDevParams->Instructions) < MAX_INSTRUCTION_LEN) &&
                   (lstrlen(SelectDevParams->ListLabel) < MAX_LABEL_LEN) &&
                   (lstrlen(SelectDevParams->SubTitle) < MAX_SUBTITLE_LEN)) {
                    //
                    // parameter set validated
                    //
                    break;
                }
            }
            return ERROR_INVALID_PARAMETER;

        case DIF_INSTALLWIZARD :
            //
            // We should have a SP_INSTALLWIZARD_DATA structure.
            //
            if(ClassInstallParamsSize == sizeof(SP_INSTALLWIZARD_DATA)) {

                PSP_INSTALLWIZARD_DATA InstallWizData;
                DWORD i;

                InstallWizData = (PSP_INSTALLWIZARD_DATA)ClassInstallParams;
                //
                // Validate the propsheet handle list.
                //
                if(InstallWizData->NumDynamicPages <= MAX_INSTALLWIZARD_DYNAPAGES) {

                    for(i = 0; i < InstallWizData->NumDynamicPages; i++) {
                        //
                        // For now, just verify that all handles are non-NULL.
                        //
                        if(!(InstallWizData->DynamicPages[i])) {
                            //
                            // Invalid property sheet page handle
                            //
                            return ERROR_INVALID_PARAMETER;
                        }
                    }

                    //
                    // Handles are verified, now verify Flags.
                    //
                    if(!(InstallWizData->Flags & NDW_INSTALLFLAG_ILLEGAL)) {

                        if(!(InstallWizData->DynamicPageFlags & DYNAWIZ_FLAG_ILLEGAL)) {
                            //
                            // parameter set validated
                            //
                            break;
                        }
                    }
                }
            }
            return ERROR_INVALID_PARAMETER;

        case DIF_NEWDEVICEWIZARD_PRESELECT :
        case DIF_NEWDEVICEWIZARD_SELECT :
        case DIF_NEWDEVICEWIZARD_PREANALYZE :
        case DIF_NEWDEVICEWIZARD_POSTANALYZE :
        case DIF_NEWDEVICEWIZARD_FINISHINSTALL :
        case DIF_ADDPROPERTYPAGE_ADVANCED:
        case DIF_ADDPROPERTYPAGE_BASIC:
        case DIF_ADDREMOTEPROPERTYPAGE_ADVANCED:
            //
            // We should have a SP_NEWDEVICEWIZARD_DATA structure.
            //
            if(ClassInstallParamsSize == sizeof(SP_NEWDEVICEWIZARD_DATA)) {

                PSP_NEWDEVICEWIZARD_DATA NewDevWizData;
                DWORD i;

                NewDevWizData = (PSP_NEWDEVICEWIZARD_DATA)ClassInstallParams;
                //
                // Validate the propsheet handle list.
                //
                if(NewDevWizData->NumDynamicPages <= MAX_INSTALLWIZARD_DYNAPAGES) {

                    for(i = 0; i < NewDevWizData->NumDynamicPages; i++) {
                        //
                        // For now, just verify that all handles are non-NULL.
                        //
                        if(!(NewDevWizData->DynamicPages[i])) {
                            //
                            // Invalid property sheet page handle
                            //
                            return ERROR_INVALID_PARAMETER;
                        }
                    }

                    //
                    // Handles are verified, now verify Flags.
                    //
                    if(!(NewDevWizData->Flags & NEWDEVICEWIZARD_FLAG_ILLEGAL)) {
                        //
                        // parameter set validated
                        //
                        break;
                    }
                }
            }
            return ERROR_INVALID_PARAMETER;

        case DIF_DETECT :
            //
            // We should have a SP_DETECTDEVICE_PARAMS structure.
            //
            if(ClassInstallParamsSize == sizeof(SP_DETECTDEVICE_PARAMS)) {

                PSP_DETECTDEVICE_PARAMS DetectDeviceParams;

                DetectDeviceParams = (PSP_DETECTDEVICE_PARAMS)ClassInstallParams;
                //
                // Make sure there's an entry point for the progress notification callback.
                //
                if(DetectDeviceParams->DetectProgressNotify) {
                    //
                    // parameter set validated.
                    //
                    break;
                }
            }
            return ERROR_INVALID_PARAMETER;

        case DIF_GETWINDOWSUPDATEINFO:
            //
            // We should have a SP_WINDOWSUPDATE_PARAMS structure.
            //
            if(ClassInstallParamsSize == sizeof(SP_WINDOWSUPDATE_PARAMS)) {

                break;
            }
            return ERROR_INVALID_PARAMETER;

        case DIF_TROUBLESHOOTER:
            //
            // We should have a SP_TROUBLESHOOTER_PARAMS structure.
            //
            if (ClassInstallParamsSize == sizeof(SP_TROUBLESHOOTER_PARAMS)) {

                break;
            }
            return ERROR_INVALID_PARAMETER;

        case DIF_POWERMESSAGEWAKE:
            //
            // We should have a SP_POWERMESSAGEWAKE_PARAMS structure.
            //
            if (ClassInstallParamsSize == sizeof(SP_POWERMESSAGEWAKE_PARAMS)) {

                break;
            }
            return ERROR_INVALID_PARAMETER;

    case DIF_INTERFACE_TO_DEVICE:
#ifdef UNICODE
            //
            // We should have a SP_INTERFACE_TO_DEVICE_PARAMS_W structure
            //
            if (ClassInstallParamsSize == sizeof(SP_INTERFACE_TO_DEVICE_PARAMS_W)) {
                PSP_INTERFACE_TO_DEVICE_PARAMS_W InterfaceToDeviceParams;
                InterfaceToDeviceParams = (PSP_INTERFACE_TO_DEVICE_PARAMS_W)ClassInstallParams;
                if(!InterfaceToDeviceParams->Interface) {
                    //
                    // this must be defined
                    //
                    return ERROR_INVALID_PARAMETER;
                }
                //
                // Validated
                //
                break;
            }
#endif
            return ERROR_INVALID_PARAMETER;

        default :
            //
            // Some generic buffer.  No validation to be done.
            //
            break;
    }

    //
    // The class install parameters have been validated.  Allocate a buffer for the
    // new parameter structure.
    //
    if(!(NewParamBuffer = MyMalloc(ClassInstallParamsSize))) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    try {

        CopyMemory(NewParamBuffer,
                   ClassInstallParams,
                   ClassInstallParamsSize
                  );

    } except(EXCEPTION_EXECUTE_HANDLER) {
        MyFree(NewParamBuffer);
        NewParamBuffer = NULL;
    }

    if(!NewParamBuffer) {
        //
        // Then an error occurred and we couldn't store the new parameters.
        //
        return ERROR_INVALID_PARAMETER;
    }

    if(DevInstParamBlock->ClassInstallHeader) {
        MyFree(DevInstParamBlock->ClassInstallHeader);
    }
    DevInstParamBlock->ClassInstallHeader = (PSP_CLASSINSTALL_HEADER)NewParamBuffer;
    DevInstParamBlock->ClassInstallParamsSize = ClassInstallParamsSize;
    DevInstParamBlock->Flags |= DI_CLASSINSTALLPARAMS;

    return NO_ERROR;
}


DWORD
GetDrvInstallParams(
    IN  PDRIVER_NODE          DriverNode,
    OUT PSP_DRVINSTALL_PARAMS DriverInstallParams
    )
/*++

Routine Description:

    This routine fills in a SP_DRVINSTALL_PARAMS structure based on the
    driver node supplied

    Note:  The supplied DriverInstallParams structure must have its cbSize
    field filled in correctly, or the call will fail.

Arguments:

    DriverNode - Supplies the address of the driver node containing the
        installation parameters to be retrieved.

    DriverInstallParams - Supplies the address of a SP_DRVINSTALL_PARAMS
        structure that will receive the installation parameters.

Return Value:

    If the function succeeds, the return value is NO_ERROR.
    If the function fails, an ERROR_* code is returned.

NOTE:

    This routine _does not_ set the Win98-compatible DNF_CLASS_DRIVER or
    DNF_COMPATIBLE_DRIVER flags that indicate whether or not the driver node is
    from a class or compatible driver list, respectively.

--*/
{
    if(DriverInstallParams->cbSize != sizeof(SP_DRVINSTALL_PARAMS)) {
        return ERROR_INVALID_USER_BUFFER;
    }

    //
    // Copy the parameters.
    //
    DriverInstallParams->Rank = DriverNode->Rank;
    DriverInstallParams->Flags = DriverNode->Flags;
    DriverInstallParams->PrivateData = DriverNode->PrivateData;

    //
    // The 'Reserved' field of the SP_DRVINSTALL_PARAMS structure isn't currently
    // used.
    //

    return NO_ERROR;
}


DWORD
SetDrvInstallParams(
    IN  PSP_DRVINSTALL_PARAMS DriverInstallParams,
    OUT PDRIVER_NODE          DriverNode
    )
/*++

Routine Description:

    This routine sets the driver installation parameters for the specified
    driver node based on the caller-supplied SP_DRVINSTALL_PARAMS structure.

    Note:  The supplied DriverInstallParams structure must have its cbSize
    field filled in correctly, or the call will fail.

Arguments:

    DriverInstallParams - Supplies the address of a SP_DRVINSTALL_PARAMS
        structure containing the installation parameters to be used.

    DriverNode - Supplies the address of the driver node whose installation
        parameters are to be set.

Return Value:

    If the function succeeds, the return value is NO_ERROR.
    If the function fails, an ERROR_* code is returned.

--*/
{
    if(DriverInstallParams->cbSize != sizeof(SP_DRVINSTALL_PARAMS)) {
        return ERROR_INVALID_USER_BUFFER;
    }

    //
    // Validate the flags.
    //
    if(DriverInstallParams->Flags & DNF_FLAGS_ILLEGAL) {
        return ERROR_INVALID_FLAGS;
    }

    //
    // No validation currently being done on Rank and PrivateData fields.
    //
    // We're ready to copy the parameters.
    //
    DriverNode->Rank = DriverInstallParams->Rank;
    DriverNode->PrivateData = DriverInstallParams->PrivateData;
    //
    // Ignore attempts at modifying read-only flags.
    //
    DriverNode->Flags = (DriverInstallParams->Flags & ~DNF_FLAGS_READONLY) |
                        (DriverNode->Flags          &  DNF_FLAGS_READONLY);

    return NO_ERROR;
}


LONG
AddMultiSzToStringTable(
    IN  PVOID   StringTable,
    IN  PTCHAR  MultiSzBuffer,
    OUT PLONG   StringIdList,
    IN  DWORD   StringIdListSize,
    IN  BOOL    CaseSensitive,
    OUT PTCHAR *UnprocessedBuffer    OPTIONAL
    )
/*++

Routine Description:

    This routine adds every string in the MultiSzBuffer to the specified
    string table, and stores the resulting IDs in the supplied output buffer.

Arguments:

    StringTable - Supplies the handle of the string table to add the strings to.

    MultiSzBuffer - Supplies the address of the REG_MULTI_SZ buffer containing
        the strings to be added.

    StringIdList - Supplies the address of an array of LONGs that receives the
        list of IDs for the added strings (the ordering of the IDs in this
        list will be the same as the ordering of the strings in the MultiSzBuffer.

    StringIdListSize - Supplies the size, in LONGs, of the StringIdList.  If the
        number of strings in MultiSzBuffer exceeds this amount, then only the
        first StringIdListSize strings will be added, and the position in the
        buffer where processing was halted will be stored in UnprocessedBuffer.

    CaseSensitive - Specifies whether the string should be added case-sensitively.

    UnprocessedBuffer - Optionally, supplies the address of a character pointer
        that receives the position where processing was aborted because the
        StringIdList buffer was filled.  If all strings in the MultiSzBuffer were
        processed, then this pointer will be set to NULL.

Return Value:

    If successful, the return value is the number of strings added.
    If failure, the return value is -1 (this happens if a string cannot be
    added because of an out-of-memory condition).

--*/
{
    PTSTR CurString;
    LONG StringCount = 0;

    for(CurString = MultiSzBuffer;
        (*CurString && (StringCount < (LONG)StringIdListSize));
        CurString += (lstrlen(CurString)+1)) {

        if((StringIdList[StringCount] = pStringTableAddString(
                                            StringTable,
                                            CurString,
                                            CaseSensitive
                                                ? STRTAB_CASE_SENSITIVE
                                                : STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                            NULL,0
                                           )) == -1)
        {
            StringCount = -1;
            break;
        }

        StringCount++;
    }

    if(UnprocessedBuffer) {
        *UnprocessedBuffer = (*CurString ? CurString : NULL);
    }

    return StringCount;
}


LONG
LookUpStringInDevInfoSet(
    IN HDEVINFO DeviceInfoSet,
    IN PTSTR    String,
    IN BOOL     CaseSensitive
    )
/*++

Routine Description:

    This routine looks up the specified string in the string table associated with
    the specified device information set.

Arguments:

    DeviceInfoSet - Supplies the pointer to the device information set containing
        the string table to look the string up in.

    String - Specifies the string to be looked up.  This string is not specified as
        const, so that the lookup routine may modify it (i.e., lower-case it) without
        having to allocate a temporary buffer.

    CaseSensitive - If TRUE, then a case-sensitive lookup is performed, otherwise, the
        lookup is case-insensitive.

Return Value:

    If the function succeeds, the return value is the string's ID in the string table.
    device information set.

    If the function fails, the return value is -1.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    LONG StringId;
    DWORD StringLen;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        return -1;
    }

    try {

        StringId = pStringTableLookUpString(pDeviceInfoSet->StringTable,
                                            String,
                                            &StringLen,
                                            NULL,
                                            NULL,
                                            STRTAB_BUFFER_WRITEABLE |
                                                (CaseSensitive ? STRTAB_CASE_SENSITIVE
                                                               : STRTAB_CASE_INSENSITIVE),
                                            NULL,0
                                           );

    } except(EXCEPTION_EXECUTE_HANDLER) {
        StringId = -1;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    return StringId;
}


BOOL
ShouldClassBeExcluded(
    IN LPGUID ClassGuid,
    IN BOOL   ExcludeNoInstallClass
    )
/*++

Routine Description:

    This routine determines whether a class should be excluded from
    some operation, based on whether it has a NoInstallClass or
    NoUseClass value entry in its registry key.

Arguments:

    ClassGuidString - Supplies the address of the class GUID to be
        filtered.

    ExcludeNoInstallClass - TRUE if NoInstallClass classes should be
        excluded and FALSE if they should not be excluded.

Return Value:

    If the class should be excluded, the return value is TRUE, otherwise
    it is FALSE.

--*/
{
    HKEY hk;
    BOOL ExcludeClass = FALSE;

    if((hk = SetupDiOpenClassRegKey(ClassGuid, KEY_READ)) != INVALID_HANDLE_VALUE) {

        try {

            if(RegQueryValueEx(hk,
                               pszNoUseClass,
                               NULL,
                               NULL,
                               NULL,
                               NULL) == ERROR_SUCCESS) {

                ExcludeClass = TRUE;

            } else if (ExcludeNoInstallClass &&
                       RegQueryValueEx(hk,
                                  pszNoInstallClass,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL) == ERROR_SUCCESS) {

                ExcludeClass = TRUE;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            //
            // Nothing to do.
            //
            ;
        }

        RegCloseKey(hk);
    }

    return ExcludeClass;
}


BOOL
ClassGuidFromInfVersionNode(
    IN  PINF_VERSION_NODE VersionNode,
    OUT LPGUID            ClassGuid
    )
/*++

Routine Description:

    This routine retrieves the class GUID for the INF whose version node
    is specified.  If the version node doesn't have a ClassGUID value,
    then the Class value is retrieved, and all class GUIDs matching this
    class name are retrieved.  If there is exactly 1 match found, then
    this GUID is returned, otherwise, the routine fails.

Arguments:

    VersionNode - Supplies the address of an INF version node that
        must contain either a ClassGUID or Class entry.

    ClassGuid - Supplies the address of the variable that receives the
        class GUID.

Return Value:

    If a class GUID was retrieved, the return value is TRUE, otherwise,
    it is FALSE.

--*/
{
    PCTSTR GuidString, NameString;
    DWORD NumGuids;

    if(GuidString = pSetupGetVersionDatum(VersionNode, pszClassGuid)) {

        if(pSetupGuidFromString(GuidString, ClassGuid) == NO_ERROR) {
            return TRUE;
        }

    } else {

        NameString = pSetupGetVersionDatum(VersionNode, pszClass);
        if(NameString &&
           SetupDiClassGuidsFromName(NameString,
                                     ClassGuid,
                                     1,
                                     &NumGuids) && NumGuids) {
            return TRUE;
        }
    }

    return FALSE;
}


DWORD
EnumSingleDrvInf(
    IN     PCTSTR                       InfName,
    IN OUT LPWIN32_FIND_DATA            InfFileData,
    IN     DWORD                        SearchControl,
    IN     InfCacheCallback             EnumInfCallback,
    IN     PSETUP_LOG_CONTEXT           LogContext,
    IN OUT PDRVSEARCH_CONTEXT           Context
    )
/*++

Routine Description:

    This routine finds and opens the specified INF, and calls the
    supplied callback routine for it. It's primary purpose is to
    provide the callback with the same information the cache-search
    does.

Arguments:

    InfName - Supplies the name of the INF to call the callback for.

    InfFileData - Supplies data returned from FindFirstFile/FindNextFile
        for this INF.  This parameter is used as input if the
        INFINFO_INF_NAME_IS_ABSOLUTE SearchControl value is specified.
        If any other SearchControl value is specified, then this buffer
        is used to retrieve the Win32 Find Data for the specified INF.

    SearchControl - Specifies where the INF should be searched for.  May
        be one of the following values:

        INFINFO_INF_NAME_IS_ABSOLUTE - Open the specified INF name as-is.
        INFINFO_DEFAULT_SEARCH - Look in INF dir, then System32
        INFINFO_REVERSE_DEFAULT_SEARCH - reverse of the above
        INFINFO_INF_PATH_LIST_SEARCH - search each dir in 'DevicePath' list
                                       (stored in registry).

    EnumInfCallback - Supplies the address of the callback routine
        to use.  The prototype for this callback is as follows:

        typedef BOOL (CALLBACK * InfCacheCallback)(
            IN PSETUP_LOG_CONTEXT LogContext,
            IN PCTSTR InfPath,
            IN PLOADED_INF pInf,
            IN PVOID Context
            );

        The callback routine returns TRUE to continue enumeration,
        or FALSE to abort it (with GetLastError set to ERROR_CANCELLED)

    Context - Supplies the address of a buffer that the callback may
        use to retrieve/return data.

Return Value:

    If the function succeeds, and the enumeration callback returned
    TRUE (continue enumeration), the return value is NO_ERROR.

    If the function succeeds, and the enumeration callback returned
    FALSE (abort enumeration), the return value is ERROR_CANCELLED.

    If the function fails, the return value is an ERROR_* status code.

--*/
{
    TCHAR PathBuffer[MAX_PATH];
    PCTSTR InfFullPath;
    DWORD Err;
    BOOL TryPnf = FALSE;
    PLOADED_INF Inf;
    BOOL PnfWasUsed;
    UINT ErrorLineNumber;
    BOOL Continue;

    if(SearchControl == INFINFO_INF_NAME_IS_ABSOLUTE) {
        InfFullPath = InfName;
    } else {
        //
        // The specified INF name should be searched for based
        // on the SearchControl type.
        //
        if(Err = SearchForInfFile(InfName,
                                  InfFileData,
                                  SearchControl,
                                  PathBuffer,
                                  SIZECHARS(PathBuffer),
                                  NULL) != NO_ERROR) {
            return Err;
        } else {
            InfFullPath = PathBuffer;
        }
    }

    //
    // If the 'try pnf' flag isn't set, then we need to examine this particular filename,
    // to see whether it's a pnf candidate.
    //
    if(Context->Flags & DRVSRCH_TRY_PNF) {
        TryPnf = TRUE;
    } else {
        InfSourcePathFromFileName(InfName, NULL, &TryPnf);
    }

    //
    // Attempt to load the INF file.  Note that throughout this routine, we don't do any
    // explicit locking of the INF before searching for sections, etc.  That's because we
    // know that this INF handle will never be exposed to anyone else, and thus there are
    // no concurrency problems.
    //
    if((Err = LoadInfFile(InfFullPath,
                   InfFileData,
                   INF_STYLE_WIN4 | ((Context->Flags & DRVSRCH_USEOLDINFS) ? INF_STYLE_OLDNT : 0),
                   LDINF_FLAG_IGNORE_VOLATILE_DIRIDS | (TryPnf ? LDINF_FLAG_ALWAYS_TRY_PNF : LDINF_FLAG_MATCH_CLASS_GUID),
                   (Context->Flags & DRVSRCH_FILTERCLASS) ? Context->ClassGuidString : NULL,
                   NULL,
                   NULL,
                   NULL,
                   LogContext,
                   &Inf,
                   &ErrorLineNumber,
                   &PnfWasUsed)) != NO_ERROR) {

        WriteLogEntry(
            LogContext,
            DRIVER_LOG_ERROR,
            MSG_LOG_COULD_NOT_LOAD_INF,
            NULL,
            InfFullPath);

        return NO_ERROR;
    }

    //
    // Call the supplied callback routine.
    //
    Err = EnumInfCallback(LogContext, InfFullPath, Inf, PnfWasUsed, Context) ? NO_ERROR : GetLastError();
    MYASSERT(Err == NO_ERROR || Err == ERROR_CANCELLED);

    FreeInfFile(Inf);

    return Err;
}

DWORD
EnumDrvInfsInDirPathList(
    IN     PCTSTR                       DirPathList,   OPTIONAL
    IN     DWORD                        SearchControl,
    IN     InfCacheCallback             EnumInfCallback,
    IN     BOOL                         IgnoreNonCriticalErrors,
    IN     PSETUP_LOG_CONTEXT           LogContext,
    IN OUT PDRVSEARCH_CONTEXT           Context
    )
/*++

Routine Description:

    This routine enumerates all INFs present in the search list specified
    by SearchControl, using the accelerated search cache

Arguments:

    DirPathList - Optionally, specifies the search path listing all
        directories to be enumerated.  This string may contain multiple
        paths, separated by semicolons (;).  If this parameter is not
        specified, then the SearchControl value will determine the
        search path to be used.

    SearchControl - Specifies the set of directories to be enumerated.
        If SearchPath is specified, this parameter is ignored.  May be
        one of the following values:

        INFINFO_DEFAULT_SEARCH : enumerate %windir%\inf, then
            %windir%\system32

        INFINFO_REVERSE_DEFAULT_SEARCH : reverse of the above

        INFINFO_INF_PATH_LIST_SEARCH : enumerate INFs in each of the
            directories listed in the DevicePath value entry under:

            HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion.

    EnumInfCallback - Supplies the address of the callback routine
        to use.  The prototype for this callback is as follows:

        typedef BOOL (CALLBACK * InfCacheCallback)(
            IN PSETUP_LOG_CONTEXT LogContext,
            IN PCTSTR InfPath,
            IN PLOADED_INF pInf,
            IN PVOID Context
            );

        The callback routine returns TRUE to continue enumeration,
        or FALSE to abort it (with GetLastError set to ERROR_CANCELLED)

    IgnoreNonCriticalErrors - If TRUE, then all errors are ignored
        except those that prevent enumeration from continuing.

    Context - Supplies the address of a buffer that the callback may
        use to retrieve/return data.

Return Value:

    If the function succeeds, and enumeration has not been aborted,
    then the return value is NO_ERROR.

    If the function succeeds, and enumeration has been aborted,
    then the return value is ERROR_CANCELLED.

    If the function fails, the return value is an ERROR_* status code.

--*/
{
    DWORD Err = NO_ERROR;
    PCTSTR PathList, CurPath;
    BOOL FreePathList = TRUE;
    DWORD Action;
    PTSTR ClassIdList = NULL;
    PTSTR HwIdList = NULL;

    if(DirPathList) {
        //
        // Use the specified search path(s).
        //
        PathList = GetFullyQualifiedMultiSzPathList(DirPathList);

    } else if(SearchControl == INFINFO_INF_PATH_LIST_SEARCH) {
        //
        // Use our global list of INF search paths.
        //
        PathList = InfSearchPaths;
        FreePathList = FALSE;

    } else {
        //
        // Retrieve the path list.
        //
        PathList = AllocAndReturnDriverSearchList(SearchControl);
    }

    if(!PathList) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        FreePathList = FALSE;
        goto clean0;
    }

    //
    // If we're doing a non-native driver search, we want to search INFs the
    // old-fashioned way (i.e., sans INF cache).
    //
    if(Context->AltPlatformInfo) {
        Action = INFCACHE_ENUMALL;
    } else {
        Action = INFCACHE_DEFAULT;
    }

    if(Context->Flags & DRVSRCH_TRY_PNF) {
        //
        // TRY_PNF also forces us to build/use cache, except when we're doing
        // non-native driver searching.
        //
        Action |= INFCACHE_FORCE_PNF;

        if(!Context->AltPlatformInfo) {
            Action |= INFCACHE_FORCE_CACHE;
        }
    }
    if(!(Context->Flags & DRVSRCH_USEOLDINFS)) {
        //
        // don't report old inf's
        //
        Action |= INFCACHE_EXC_OLDINFS;
    }
    if (Context->Flags & DRVSRCH_EXCLUDE_OLD_INET_DRIVERS) {
        //
        // exclude old internet INF's from search
        //
        Action |= INFCACHE_EXC_URL;
    }
    Action |= INFCACHE_EXC_NOMANU;    // exclude INF's that have no/empty [Manufacturer] section
    Action |= INFCACHE_EXC_NULLCLASS; // exclude INF's that have a ClassGuid = {<nill>}
    Action |= INFCACHE_EXC_NOCLASS;   // exclude INF's that don't have class information

    //
    // build class list if needed
    //
    // this must consist of (1) the class GUID (string form)
    //                      (2) name of class
    //                      (3) if USEOLDINF's specified, legacy name of class
    //
    if (Context->Flags & DRVSRCH_FILTERCLASS) {
        DWORD len = 2;
        DWORD reqsize;
        TCHAR clsnam[MAX_CLASS_NAME_LEN];

        MYASSERT(Context->ClassGuidString);
        len += 1 + lstrlen(Context->ClassGuidString);

        //
        // Call SetupDiClassNameFromGuid to retrieve the class name
        // corresponding to this class GUID.
        // this allows us to find INF's that list this specific class name
        // but not the GUID, or list this class name but a different GUID
        //
        if(SetupDiClassNameFromGuid(&Context->ClassGuid,
                                     clsnam,
                                     SIZECHARS(clsnam),
                                     NULL) && clsnam[0]) {
            len += 1+lstrlen(clsnam);
        } else {
            clsnam[0]=TEXT('\0');
        }

        if (Context->Flags & DRVSRCH_USEOLDINFS) {
            len += 1 + lstrlen(Context->LegacyClassName);
        }
        ClassIdList = (PTSTR)MyMalloc(len*sizeof(TCHAR));
        if(!ClassIdList) {
            goto clean0;
        }
        len = 0;

        lstrcpy(ClassIdList+len,Context->ClassGuidString);
        len += 1 + lstrlen(ClassIdList+len);

        if(clsnam[0]) {
            lstrcpy(ClassIdList+len,clsnam);
            len += 1 + lstrlen(ClassIdList+len);
        }
        if (Context->Flags & DRVSRCH_USEOLDINFS) {
            lstrcpy(ClassIdList+len,Context->LegacyClassName);
            len += 1 + lstrlen(ClassIdList+len);
        }
        ClassIdList[len++]=TEXT('\0');
    } else {
        MYASSERT(!(Context->Flags & DRVSRCH_USEOLDINFS));
    }


    //
    // build HwIdList if needed
    //
    if (!Context->BuildClassDrvList) {
        DWORD len = 2;
        PLONG pDevIdNum;
        PCTSTR CurDevId;
        int i;

        //
        // first pass, obtain size
        //
        for(i = 0; i < 2; i++) {

            for(pDevIdNum = Context->IdList[i]; *pDevIdNum != -1; pDevIdNum++) {
                //
                // First, obtain the device ID string corresponding to our stored-away
                // string table ID.
                //
                CurDevId = pStringTableStringFromId(Context->StringTable, *pDevIdNum);
                MYASSERT(CurDevId);
                len += 1+lstrlen(CurDevId);
            }
        }
        HwIdList = (PTSTR)MyMalloc(len*sizeof(TCHAR));
        if(!HwIdList) {
            goto clean0;
        }

        //
        // second pass, write list
        //
        len = 0;
        for(i = 0; i < 2; i++) {

            for(pDevIdNum = Context->IdList[i]; *pDevIdNum != -1; pDevIdNum++) {
                //
                // First, obtain the device ID string corresponding to our stored-away
                // string table ID.
                //
                CurDevId = pStringTableStringFromId(Context->StringTable, *pDevIdNum);
                lstrcpy(HwIdList+len,CurDevId);
                len += 1+lstrlen(HwIdList+len);
            }
        }
        HwIdList[len++]=TEXT('\0');
    }

    Err = InfCacheSearchPath(LogContext,
                                Action,
                                PathList,
                                EnumInfCallback,
                                Context,
                                ClassIdList,
                                HwIdList
                                );

clean0:

    if (ClassIdList) {
        MyFree(ClassIdList);
    }
    if (HwIdList) {
        MyFree(HwIdList);
    }
    if(FreePathList) {
        MyFree(PathList);
    }

    if((Err == ERROR_CANCELLED) || !IgnoreNonCriticalErrors) {
        return Err;
    } else {
        return NO_ERROR;
    }
}


DWORD
CreateDriverNode(
    IN  UINT          Rank,
    IN  PCTSTR        DevDescription,
    IN  PCTSTR        DrvDescription,
    IN  PCTSTR        ProviderName,   OPTIONAL
    IN  PCTSTR        MfgName,
    IN  PFILETIME     InfDate,
    IN  PCTSTR        InfFileName,
    IN  PCTSTR        InfSectionName,
    IN  PVOID         StringTable,
    IN  LONG          InfClassGuidIndex,
    OUT PDRIVER_NODE *DriverNode
    )
/*++

Routine Description:

    This routine creates a new driver node, and initializes it with
    the supplied information.

Arguments:

    Rank - The rank match of the driver node being created.  This is a
        value in [0..n], where a lower number indicates a higher level of
        compatibility between the driver represented by the node, and the
        device being installed.

    DevDescription - Supplies the description of the device that will be
        supported by this driver.

    DrvDescription - Supplies the description of this driver.

    ProviderName - Supplies the name of the provider of this INF.

    MfgName - Supplies the name of the manufacturer of this device.

    InfDate - Supplies the address of the variable containing the date
        when the INF was last written to.

    InfFileName - Supplies the full name of the INF file for this driver.

    InfSectionName - Supplies the name of the install section in the INF
        that would be used to install this driver.

    StringTable - Supplies the string table that the specified strings are
        to be added to.

    InfClassGuidIndex - Supplies the index into the containing HDEVINFO set's
        GUID table where the class GUID for this INF is stored.

    DriverNode - Supplies the address of a DRIVER_NODE pointer that will
        receive a pointer to the newly-allocated node.

Return Value:

    If the function succeeds, the return value is NO_ERROR, otherwise the
    ERROR_* code is returned.

--*/
{
    PDRIVER_NODE pDriverNode;
    DWORD Err = ERROR_NOT_ENOUGH_MEMORY;
    TCHAR TempString[MAX_PATH];  // an INF path is the longest string we'll store in here.

    //
    // validate the sizes of the strings passed in
    // certain assumptions are made about the strings thoughout
    // but at this point the sizes are not yet within our control
    //
    if((DevDescription && (lstrlen(DevDescription) >= LINE_LEN)) ||
       (DrvDescription && (lstrlen(DrvDescription) >= LINE_LEN)) ||
       (ProviderName && (lstrlen(ProviderName) >= LINE_LEN)) ||
       (MfgName && (lstrlen(MfgName) >= LINE_LEN)) ||
       (InfFileName && (lstrlen(InfFileName) >= MAX_PATH)) ||
       (InfSectionName && (lstrlen(InfSectionName) >= LINE_LEN))
       ) {
        //
        // any of these could potentially cause a buffer overflow later
        // on, so not allowed
        //
        return ERROR_BUFFER_OVERFLOW;
    }


    if(!(pDriverNode = MyMalloc(sizeof(DRIVER_NODE)))) {
        return Err;
    }

    //
    // Initialize the various fields in the driver node structure.
    //
    ZeroMemory(pDriverNode, sizeof(DRIVER_NODE));

    pDriverNode->Rank = Rank;
    pDriverNode->InfDate = *InfDate;
    pDriverNode->HardwareId = -1;

    pDriverNode->GuidIndex = InfClassGuidIndex;

    //
    // Now, add the strings to the associated string table, and store the string IDs.
    //
    // Cast the DrvDescription string being added case-sensitively as PTSTR instead of PCTSTR.
    // Case sensitive string additions don't modify the buffer passed in, so we're safe in
    // doing so.
    //
    if((pDriverNode->DrvDescription = pStringTableAddString(StringTable,
                                                            (PTSTR)DrvDescription,
                                                            STRTAB_CASE_SENSITIVE,
                                                            NULL,0)) == -1) {
        goto clean0;
    }

    //
    // For DevDescription, ProviderName, and MfgName, we use the string table IDs to do fast
    // comparisons for driver nodes.  Thus, we need to store case-insensitive IDs.  However,
    // these strings are also used for display, so we have to store them in their case-sensitive
    // form as well.
    //
    // We must first copy the strings into a modifiable buffer, since we're going to need to add
    // them case-insensitively.
    //
    lstrcpyn(TempString, DevDescription, SIZECHARS(TempString));
    if((pDriverNode->DevDescriptionDisplayName = pStringTableAddString(StringTable,
                                                                       TempString,
                                                                       STRTAB_CASE_SENSITIVE,
                                                                       NULL,0)) == -1) {
        goto clean0;
    }

    if((pDriverNode->DevDescription = pStringTableAddString(
                                          StringTable,
                                          TempString,
                                          STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                          NULL,0)) == -1) {
        goto clean0;
    }

    if(ProviderName) {
        lstrcpyn(TempString, ProviderName, SIZECHARS(TempString));
        if((pDriverNode->ProviderDisplayName = pStringTableAddString(
                                                    StringTable,
                                                    TempString,
                                                    STRTAB_CASE_SENSITIVE,
                                                    NULL,0)) == -1) {
            goto clean0;
        }

        if((pDriverNode->ProviderName = pStringTableAddString(
                                            StringTable,
                                            TempString,
                                            STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                            NULL,0)) == -1) {
            goto clean0;
        }

    } else {
        pDriverNode->ProviderName = pDriverNode->ProviderDisplayName = -1;
    }

    lstrcpyn(TempString, MfgName, SIZECHARS(TempString));
    if((pDriverNode->MfgDisplayName = pStringTableAddString(StringTable,
                                                            TempString,
                                                            STRTAB_CASE_SENSITIVE,
                                                            NULL,0)) == -1) {
        goto clean0;
    }

    if((pDriverNode->MfgName = pStringTableAddString(
                                    StringTable,
                                    TempString,
                                    STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                    NULL,0)) == -1) {
        goto clean0;
    }

    lstrcpyn(TempString, InfFileName, SIZECHARS(TempString));
    if((pDriverNode->InfFileName = pStringTableAddString(
                                        StringTable,
                                        TempString,
                                        STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                        NULL,0)) == -1) {
        goto clean0;
    }

    //
    // Add INF section name case-sensitively, since we may have a legacy driver node, which requires
    // that the original case be maintained.
    //
    if((pDriverNode->InfSectionName = pStringTableAddString(StringTable,
                                                            (PTSTR)InfSectionName,
                                                            STRTAB_CASE_SENSITIVE,
                                                            NULL,0)) == -1) {
        goto clean0;
    }

    //
    // If we get to here, then we've successfully stored all strings.
    //
    Err = NO_ERROR;

clean0:

    if(Err == NO_ERROR) {
        *DriverNode = pDriverNode;
    } else {
        DestroyDriverNodes(pDriverNode, (PDEVICE_INFO_SET)NULL);
    }

    return Err;
}

BOOL
pRemoveDirectory(
    PTSTR Path
    )
/*++

Routine Description:

    This routine recursively deletes the specified directory and all the
    files in it.


Arguments:

    Path - Path to remove.

Return Value:

    TRUE - if the directory was sucessfully deleted.
    FALSE - if the directory was not successfully deleted.

--*/
{
    WIN32_FIND_DATA FindFileData;
    HANDLE          hFind;
    BOOL            bFind = TRUE;
    BOOL            Ret = TRUE;
    TCHAR           szTemp[MAX_PATH];
    TCHAR           FindPath[MAX_PATH];
    DWORD           dwAttributes;

    //
    //If this is a directory then tack on *.* to the end of the path
    //
    lstrcpyn(FindPath, Path,SIZECHARS(FindPath));
    dwAttributes = GetFileAttributes(Path);
    if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY) {

        pSetupConcatenatePaths(FindPath,TEXT("*.*"),SIZECHARS(FindPath),NULL);
    }

    hFind = FindFirstFile(FindPath, &FindFileData);

    while (hFind != INVALID_HANDLE_VALUE && bFind == TRUE) {

        lstrcpyn(szTemp, Path,SIZECHARS(szTemp));
        pSetupConcatenatePaths(szTemp,FindFileData.cFileName,SIZECHARS(szTemp),NULL);

        //
        //This is a directory
        //
        if ((FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            (FindFileData.cFileName[0] != TEXT('.'))) {

            if (!pRemoveDirectory(szTemp)) {

                Ret = FALSE;
            }

            RemoveDirectory(szTemp);
        }

        //
        //This is a file
        //
        else if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

            DeleteFile(szTemp);
        }

        bFind = FindNextFile(hFind, &FindFileData);
    }

    FindClose(hFind);

    //
    //Remove the root directory
    //
    dwAttributes = GetFileAttributes(Path);
    if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY) {

        if (!RemoveDirectory(Path)) {

            Ret = FALSE;
        }
    }

    return Ret;
}

BOOL
RemoveCDMDirectory(
  IN PTSTR FullPathName
  )
/*++

Routine Description:

    This routine deletes the Code Download Manager temporary directory. It will
    only delete the directory and all of it's contents if:

    1) it is a subdirectory of the Windows TEMP directory.

    Note that we also assume that this is a full path (including a filename at the end).
    We will strip off the filename and remove the entire directory where this INF file
    is located.

Arguments:

    FullPathName - Full path to the directory that might be deleted.

Return Value:

    TRUE - if the directory was sucessfully deleted.
    FALSE - if the directory was not successfully deleted.

--*/
{
    TCHAR Directory[MAX_PATH];
    TCHAR TempPath[MAX_PATH];
    PTSTR FileName;

    //
    //First stip off the file name so we are just left with the directory.
    //
    lstrcpyn(Directory, FullPathName,SIZECHARS(Directory));

    if ((FileName = (PTSTR)pSetupGetFileTitle((PCTSTR)Directory))) {

        *FileName = TEXT('\0');
    }

    if (Directory[0] == TEXT('\0')) {

        return FALSE;
    }

    if (GetTempPath(SIZECHARS(TempPath), TempPath) == 0) {

        lstrcpy(TempPath, TEXT("UNKNOWN"));
    }

    //
    // Only remove this directory if it is a subdirectory of the TEMP path
    //
    if (_tcsnicmp(TempPath, Directory, sizeof(TempPath) / sizeof(TCHAR))) {

        //
        //Remove the directory
        //
        return pRemoveDirectory(Directory);

    } else {

            TCHAR Debug[512];
            wsprintf(Debug, TEXT("SETUPAPI: RemoveCDMDirectory(%s) -> bogus path\n"), FullPathName);
            DebugPrintEx(DPFLTR_ERROR_LEVEL, Debug);
            MYASSERT (FALSE);
    }

    return FALSE;
}

VOID
DestroyDriverNodes(
    IN PDRIVER_NODE DriverNode,
    IN PDEVICE_INFO_SET pDeviceInfoSet
    )
/*++

Routine Description:

    This routine destroys the specified driver node linked list, freeing
    all resources associated with it.

Arguments:

    DriverNode - Supplies a pointer to the head of the driver node linked
    list to be destroyed.

Return Value:

    None.

--*/
{
    PDRIVER_NODE NextNode;
    PTSTR szInfFileName = NULL;

    while(DriverNode) {

        NextNode = DriverNode->Next;

        if(DriverNode->CompatIdList) {
            MyFree(DriverNode->CompatIdList);
        }

        //
        // If this driver was from the Internet then we want to delete the directory where
        // it lives.
        //
        if (pDeviceInfoSet && (DriverNode->Flags & PDNF_CLEANUP_SOURCE_PATH)) {

            szInfFileName = NULL;
            szInfFileName = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                     DriverNode->InfFileName);

            if (*szInfFileName) {

                RemoveCDMDirectory(szInfFileName);
            }
        }

        MyFree(DriverNode);

        DriverNode = NextNode;
    }
}


PTSTR
GetFullyQualifiedMultiSzPathList(
    IN PCTSTR PathList
    )
/*++

Routine Description:

    This routine takes a list of semicolon-delimited directory paths, and returns a
    newly-allocated buffer containing a multi-sz list of those paths, fully qualified.
    The buffer returned from this routine must be freed with MyFree().

Arguments:

    PathList - list of directories to be converted.

Return Value:

    If the function succeeds, the return value is a pointer to the allocated buffer
    containing the multi-sz list.

    If failure (due to out-of-memory), the return value is NULL.

--*/
{
    TCHAR PathListBuffer[MAX_PATH + 1];  // extra char 'cause this is a multi-sz list
    PTSTR CurPath, CharPos, NewBuffer, TempPtr;
    DWORD RequiredSize;

    //
    // First, convert this semicolon-delimited list into a multi-sz list.
    //
    lstrcpyn(PathListBuffer, PathList,SIZECHARS(PathListBuffer));
    RequiredSize = DelimStringToMultiSz(PathListBuffer,
                                        SIZECHARS(PathListBuffer),
                                        TEXT(';')
                                       );

    RequiredSize = (RequiredSize * MAX_PATH * sizeof(TCHAR)) + sizeof(TCHAR);

    if(!(NewBuffer = MyMalloc(RequiredSize * sizeof(TCHAR)))) {
        return NULL;
    }

    //
    // Now fill in the buffer with the fully-qualified directory paths.
    //
    CharPos = NewBuffer;

    for(CurPath = PathListBuffer; *CurPath; CurPath += (lstrlen(CurPath) + 1)) {

        RequiredSize = GetFullPathName(CurPath,
                                       MAX_PATH,
                                       CharPos,
                                       &TempPtr
                                      );
        if(!RequiredSize || (RequiredSize >= MAX_PATH)) {
            //
            // If we start failing because MAX_PATH isn't big enough anymore, we
            // wanna know about it!
            //
            MYASSERT(RequiredSize < MAX_PATH);
            MyFree(NewBuffer);
            return NULL;
        }

        CharPos += (RequiredSize + 1);
    }

    *(CharPos++) = TEXT('\0');  // add extra NULL to terminate the multi-sz list.

    //
    // Trim this buffer down to just the size required (this should never fail, but
    // it's no big deal if it does).
    //
    if(TempPtr = MyRealloc(NewBuffer, (DWORD)((PBYTE)CharPos - (PBYTE)NewBuffer))) {
        return TempPtr;
    }

    return NewBuffer;
}


BOOL
InitMiniIconList(
    VOID
    )
/*++

Routine Description:

    This routine initializes the global mini-icon list, including setting up
    the synchronization lock.  When this global structure is no longer needed,
    DestroyMiniIconList must be called.

Arguments:

    None.

Return Value:

    If the function succeeds, the return value is TRUE, otherwise it is FALSE.

--*/
{
    ZeroMemory(&GlobalMiniIconList, sizeof(MINI_ICON_LIST));
    return InitializeSynchronizedAccess(&GlobalMiniIconList.Lock);
}


BOOL
DestroyMiniIconList(
    VOID
    )
/*++

Routine Description:

    This routine destroys the global mini-icon list created by a call to
    InitMiniIconList.

Arguments:

    None.

Return Value:

    If the function succeeds, the return value is TRUE, otherwise it is FALSE.

--*/
{

    if(LockMiniIconList(&GlobalMiniIconList)) {
        DestroyMiniIcons();
        DestroySynchronizedAccess(&GlobalMiniIconList.Lock);
        return TRUE;
    }

    return FALSE;
}


DWORD
GetModuleEntryPoint(
    IN     HKEY                    hk,                    OPTIONAL
    IN     LPCTSTR                 RegistryValue,
    IN     LPCTSTR                 DefaultProcName,
    OUT    HINSTANCE              *phinst,
    OUT    FARPROC                *pEntryPoint,
    OUT    HANDLE                 *pFusionContext,
    OUT    BOOL                   *pMustAbort,            OPTIONAL
    IN     PSETUP_LOG_CONTEXT      LogContext,            OPTIONAL
    IN     HWND                    Owner,                 OPTIONAL
    IN     CONST GUID             *DeviceSetupClassGuid,  OPTIONAL
    IN     SetupapiVerifyProblem   Problem,
    IN     LPCTSTR                 DeviceDesc,            OPTIONAL
    IN     DWORD                   DriverSigningPolicy,
    IN     DWORD                   NoUI,
    IN OUT HCATADMIN              *hCatAdmin              OPTIONAL
    )
/*++

Routine Description:

    This routine is used to retrieve the procedure address of a specified
    function in a specified module.

Arguments:

    hk - Optionally, supplies an open registry key that contains a value entry
        specifying the module (and optionally, the entry point) to be retrieved.
        If this parameter is not specified (set to INVALID_HANDLE_VALUE), then
        the RegistryValue parameter is interpreted as the data itself, instead
        of the value containing the entry.

    RegistryValue - If hk is supplied, this specifies the name of the registry
        value that contains the module and entry point information.  Otherwise,
        it contains the actual data specifying the module/entry point to be
        used.

    DefaultProcName - Supplies the name of a default procedure to use if one
        is not specified in the registry value.

    phinst - Supplies the address of a variable that receives a handle to the
        specified module, if it is successfully loaded and the entry point found.

    pEntryPoint - Supplies the address of a function pointer that receives the
        specified entry point in the loaded module.

    pFusionContext - Supplies a handle to a fusion context for the dll
        if the dll has a manifest, NULL otherwise.

    pMustAbort - Optionally, supplies the address of a boolean variable that is
        set upon return to indicate whether a failure (i.e., return code other
        than NO_ERROR) should abort the device installer action underway.  This
        variable is always set to FALSE when the function succeeds.

        If this argument is not supplied, then the arguments below are ignored.

    LogContext - Optionally, supplies the log context to be used when logging
        entries into the setupapi logfile.  Not used if pMustAbort isn't
        specified.

    Owner - Optionally, supplies window to own driver signing dialogs, if any.
        Not used if pMustAbort isn't specified.

    DeviceSetupClassGuid - Optionally, supplies the address of a GUID that
        indicates the device setup class associated with this operation.  This
        is used for retrieval of validation platform information, as well as
        for retrieval of the DeviceDesc to be used for driver signing errors
        (if the caller doesn't specify a DeviceDesc).  Not used if pMustAbort
        isn't specified.

    Problem - Supplies the problem type to use if driver signing error occurs.
        Not used if pMustAbort isn't specified.

    DeviceDesc - Optionally, supplies the device description to use if driver
        signing error occurs.  Not used if pMustAbort isn't specified.

    DriverSigningPolicy - Supplies policy to be employed if a driver signing
        error is encountered.  Not used if pMustAbort isn't specified.

    NoUI - Set to true if driver signing popups are to be suppressed (e.g.,
        because the user has previously responded to a warning dialog and
        elected to proceed.  Not used if pMustAbort isn't specified.

    hCatAdmin - optionally, supplies the address of an HCATADMIN handle.  If
        the handle pointed to is NULL, a handle will be acquired (if possible)
        via CryptCATAdminAcquireContext and returned to the caller.  If the
        handle pointed to is non-NULL, then that handle will be used for any
        validation done via this routine.  If the pointer itself is NULL, then
        an hCatAdmin will be acquired for the duration of this call, and
        released before returning.

        NOTE: it is the caller's responsibility to free the crypto context
        handle returned by this routine by calling CryptCATAdminReleaseContext.
        This handle may be opened in either success or failure cases, so the
        caller must check for non-NULL returned handle in both cases.

Return Value:

    If the function succeeds, the return value is NO_ERROR.
    If the specified value entry could not be found, the return value is
    ERROR_DI_DO_DEFAULT.
    If any other error is encountered, an ERROR_* code is returned.

Remarks:

    This function is useful for loading a class installer or property provider,
    and receiving the procedure address specified.  The syntax of the registry
    entry is: value=dll[,proc name] where dll is the name of the module to load,
    and proc name is an optional procedure to search for.  If proc name is not
    specified, the procedure specified by DefaultProcName will be used.

--*/
{
    DWORD Err = ERROR_INVALID_DATA; // relevent only if we execute 'finally' due to exception
    DWORD RegDataType, BufferSize;
    TCHAR TempBuffer[MAX_PATH];
    TCHAR ModulePath[MAX_PATH];
    SPFUSIONINSTANCE spFusionInstance;
#if UNICODE
    //
    // this used to be ModulePath reused... to reduce chance of breaking anything, kept size the same
    // I've seperated this out as we want ModulePath for logging
    //
    CHAR ProcBuffer[MAX_PATH*sizeof(TCHAR)];
#endif
    PTSTR StringPtr;
    PSTR  ProcName;   // ANSI-only, because it's used for GetProcAddress.
    PSP_ALTPLATFORM_INFO_V2 ValidationPlatform;
    PTSTR LocalDeviceDesc;

    *phinst = NULL;
    *pEntryPoint = NULL;
    *pFusionContext = NULL;

    if(pMustAbort) {
        *pMustAbort = FALSE;
    }

    if(hk != INVALID_HANDLE_VALUE) {
        //
        // See if the specified value entry is present (and of the right data type).
        //
        BufferSize = sizeof(TempBuffer);
        if((RegQueryValueEx(hk,
                            RegistryValue,
                            NULL,
                            &RegDataType,
                            (PBYTE)TempBuffer,
                            &BufferSize) != ERROR_SUCCESS) ||
           (RegDataType != REG_SZ)) {

            return ERROR_DI_DO_DEFAULT;
        }

    } else {
        //
        // Copy the specified data into the buffer as if we'd just retrieved it from
        // the registry.
        //
        BufferSize = (lstrlen(RegistryValue) + 1) * sizeof(TCHAR);
        CopyMemory(TempBuffer, RegistryValue, BufferSize);
    }

    lstrcpyn(ModulePath, SystemDirectory, MAX_PATH);

    //
    // Find the beginning of the entry point name, if present.
    //
    for(StringPtr = TempBuffer + ((BufferSize / sizeof(TCHAR)) - 2);
        StringPtr >= TempBuffer;
        StringPtr--) {

        if(*StringPtr == TEXT(',')) {
            *(StringPtr++) = TEXT('\0');
            break;
        }
        //
        // If we hit a double-quote mark, then set the character pointer
        // to the beginning of the string so we'll terminate the search.
        //
        if(*StringPtr == TEXT('\"')) {
            StringPtr = TempBuffer;
        }
    }

    if(StringPtr > TempBuffer) {
        //
        // We encountered a comma in the string.  Scan forward from that point
        // to ensure that there aren't any leading spaces in the entry point
        // name.
        //
        for(; (*StringPtr && IsWhitespace(StringPtr)); StringPtr++);

        if(!(*StringPtr)) {
            //
            // Then there was no entry point given after all.
            //
            StringPtr = TempBuffer;
        }
    }

    pSetupConcatenatePaths(ModulePath, TempBuffer, MAX_PATH, NULL);

    //
    // If requested, check the digital signature of this module before loading
    // it.
    //
    if(pMustAbort) {
        //
        // Retrieve validation information relevant to this device setup class.
        //
        LocalDeviceDesc = NULL;

        IsInfForDeviceInstall(LogContext,
                              DeviceSetupClassGuid,
                              NULL,
                              DeviceDesc ? NULL : &LocalDeviceDesc,
                              &ValidationPlatform,
                              NULL,
                              NULL
                             );

        Err = _VerifyFile(LogContext,
                          hCatAdmin,
                          NULL,
                          NULL,
                          NULL,
                          0,
                          pSetupGetFileTitle(ModulePath),
                          ModulePath,
                          NULL,
                          NULL,
                          FALSE,
                          ValidationPlatform,
                          (VERIFY_FILE_USE_OEM_CATALOGS | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                          NULL,
                          NULL,
                          NULL,
                          NULL
                         );

        if(Err != NO_ERROR) {

            if(!pSetupHandleFailedVerification(Owner,
                                               Problem,
                                               ModulePath,
                                               DeviceDesc ? DeviceDesc : LocalDeviceDesc,
                                               DriverSigningPolicy,
                                               NoUI,
                                               Err,
                                               LogContext,
                                               NULL,
                                               NULL)) {
                //
                // The operation should be aborted.
                //
                *pMustAbort = TRUE;
            }
        }

        //
        // Free buffers we may have retrieved when calling
        // IsInfForDeviceInstall().
        //
        if(LocalDeviceDesc) {
            MyFree(LocalDeviceDesc);
        }

        if(ValidationPlatform) {
            MyFree(ValidationPlatform);
        }

        if(*pMustAbort) {
            MYASSERT(Err != NO_ERROR);
            return Err;
        }
    }

    try {
        *pFusionContext = spFusionContextFromModule(ModulePath);
        spFusionEnterContext(*pFusionContext,&spFusionInstance);

        if(!(*phinst = LoadLibrary(ModulePath))) {
            Err = GetLastError();
            if (LogContext) {
                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                    MSG_LOG_MOD_LOADFAIL_ERROR,
                    NULL,
                    ModulePath);
                WriteLogError(
                    LogContext,
                    DRIVER_LOG_ERROR,
                    Err);
            }
            leave;
        }

        //
        // We've successfully loaded the module, now get the entry point.
        // (GetProcAddress is an ANSI-only API, so if we're compiled UNICODE,
        // we have to convert the proc name to ANSI here.
        //
#ifdef UNICODE
        ProcName = ProcBuffer;
#endif

        if(StringPtr > TempBuffer) {
            //
            // An entry point was specified in the value entry--use it instead
            // of the default provided.
            //
#ifdef UNICODE
            WideCharToMultiByte(CP_ACP,
                                0,
                                StringPtr,
                                -1,
                                ProcName,
                                sizeof(ProcBuffer),
                                NULL,
                                NULL
                               );
#else // !UNICODE
            ProcName = StringPtr;
#endif // !UNICODE

        } else {
            //
            // No entry point was specified--use default.
            //
#ifdef UNICODE
            WideCharToMultiByte(CP_ACP,
                                0,
                                DefaultProcName,
                                -1,
                                ProcName,
                                sizeof(ProcBuffer),
                                NULL,
                                NULL
                               );
#else // !UNICODE
            ProcName = (PSTR)DefaultProcName;
#endif // !UNICODE

        }

        if(!(*pEntryPoint = (FARPROC)GetProcAddress(*phinst, ProcName))) {
            Err = GetLastError();
            FreeLibrary(*phinst);
            *phinst = NULL;
            if (LogContext) {
                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                    MSG_LOG_MOD_PROCFAIL_ERROR,
                    NULL,
                    ModulePath,
                    (StringPtr > TempBuffer ? StringPtr : DefaultProcName));
                WriteLogError(
                    LogContext,
                    DRIVER_LOG_ERROR,
                    Err);
            }
            leave;
        }
        if (LogContext) {
            WriteLogEntry(
                LogContext,
                DRIVER_LOG_VERBOSE1,
                MSG_LOG_MOD_LIST_PROC,
                NULL,
                ModulePath,
                (StringPtr > TempBuffer ? StringPtr : DefaultProcName));
        }

        Err = NO_ERROR;
    } finally {
        if(Err && *phinst) {
            FreeLibrary(*phinst);
            *phinst = NULL;
        }
        spFusionLeaveContext(&spFusionInstance);
        if(Err != NO_ERROR) {
            spFusionKillContext(*pFusionContext);
            *pFusionContext = NULL;
        }
    }
    return Err;
}


DWORD
pSetupGuidFromString(
    IN  PCTSTR GuidString,
    OUT LPGUID Guid
    )
/*++

Routine Description:

    This routine converts the character representation of a GUID into its binary
    form (a GUID struct).  The GUID is in the following form:

    {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}

    where 'x' is a hexadecimal digit.

Arguments:

    GuidString - Supplies a pointer to the null-terminated GUID string.  The

    Guid - Supplies a pointer to the variable that receives the GUID structure.

Return Value:

    If the function succeeds, the return value is NO_ERROR.
    If the function fails, the return value is RPC_S_INVALID_STRING_UUID.

--*/
{
    TCHAR UuidBuffer[GUID_STRING_LEN - 1];

    //
    // Since we're using a RPC UUID routine, we need to strip off the surrounding
    // curly braces first.
    //
    if(*GuidString++ != TEXT('{')) {
        return RPC_S_INVALID_STRING_UUID;
    }

    lstrcpyn(UuidBuffer, GuidString, SIZECHARS(UuidBuffer));

    if((lstrlen(UuidBuffer) != GUID_STRING_LEN - 2) ||
       (UuidBuffer[GUID_STRING_LEN - 3] != TEXT('}'))) {

        return RPC_S_INVALID_STRING_UUID;
    }

    UuidBuffer[GUID_STRING_LEN - 3] = TEXT('\0');

    return ((UuidFromString(UuidBuffer, Guid) == RPC_S_OK) ? NO_ERROR : RPC_S_INVALID_STRING_UUID);
}


DWORD
pSetupStringFromGuid(
    IN  CONST GUID *Guid,
    OUT PTSTR       GuidString,
    IN  DWORD       GuidStringSize
    )
/*++

Routine Description:

    This routine converts a GUID into a null-terminated string which represents
    it.  This string is of the form:

    {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}

    where x represents a hexadecimal digit.

    This routine comes from ole32\common\ccompapi.cxx.  It is included here to avoid linking
    to ole32.dll.  (The RPC version allocates memory, so it was avoided as well.)

Arguments:

    Guid - Supplies a pointer to the GUID whose string representation is
        to be retrieved.

    GuidString - Supplies a pointer to character buffer that receives the
        string.  This buffer must be _at least_ 39 (GUID_STRING_LEN) characters
        long.

Return Value:

    If success, the return value is NO_ERROR.
    if failure, the return value is

--*/
{
    CONST BYTE *GuidBytes;
    INT i;

    if(GuidStringSize < GUID_STRING_LEN) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    GuidBytes = (CONST BYTE *)Guid;

    *GuidString++ = TEXT('{');

    for(i = 0; i < sizeof(GuidMap); i++) {

        if(GuidMap[i] == '-') {
            *GuidString++ = TEXT('-');
        } else {
            *GuidString++ = szDigits[ (GuidBytes[GuidMap[i]] & 0xF0) >> 4 ];
            *GuidString++ = szDigits[ (GuidBytes[GuidMap[i]] & 0x0F) ];
        }
    }

    *GuidString++ = TEXT('}');
    *GuidString   = TEXT('\0');

    return NO_ERROR;
}


BOOL
pSetupIsGuidNull(
    IN CONST GUID *Guid
    )
{
    return IsEqualGUID(Guid, &GUID_NULL);
}


VOID
GetRegSubkeysFromDeviceInterfaceName(
    IN OUT PTSTR  DeviceInterfaceName,
    OUT    PTSTR *SubKeyName
    )
/*++

Routine Description:

    This routine breaks up a device interface path into 2 parts--the symbolic link
    name and the (optional) reference string.  It then munges the symbolic link
    name part into the subkey name as it appears under the interface class key.

    NOTE: The algorithm for parsing the device interface name must be kept in sync
    with the kernel-mode implementation of IoOpenDeviceInterfaceRegistryKey.

Arguments:

    DeviceInterfaceName - Supplies the name of the device interface to be parsed
        into registry subkey names.  Upon return, this name will have been terminated
        at the backslash preceding the reference string (if there is one), and all
        backslashes will have been replaced with '#' characters.

    SubKeyName - Supplies the address of a character pointer that receives the
        address of the reference string (within the DeviceInterfaceName string).
        If there is no reference string, this parameter will be filled in with NULL.

Return Value:

    none

--*/
{
    PTSTR p;

    //
    // Scan across the name to find the beginning of the refstring component (if
    // there is one).  The format of the symbolic link name is:
    //
    // \\?\munged_name[\refstring]
    //
    MYASSERT(DeviceInterfaceName[0] == TEXT('\\'));
    MYASSERT(DeviceInterfaceName[1] == TEXT('\\'));
    //
    // Allow both '\\.\' and '\\?\' for now, since Memphis currently uses the former.
    //
    MYASSERT((DeviceInterfaceName[2] == TEXT('?')) || (DeviceInterfaceName[2] == TEXT('.')));
    MYASSERT(DeviceInterfaceName[3] == TEXT('\\'));

    p = _tcschr(&(DeviceInterfaceName[4]), TEXT('\\'));

    if(p) {
        *p = TEXT('\0');
        *SubKeyName = p + 1;
    } else {
        *SubKeyName = NULL;
    }

    for(p = DeviceInterfaceName; *p; p++) {
        if(*p == TEXT('\\')) {
            *p = TEXT('#');
        }
    }
}


LONG
OpenDeviceInterfaceSubKey(
    IN     HKEY   hKeyInterfaceClass,
    IN     PCTSTR DeviceInterfaceName,
    IN     REGSAM samDesired,
    OUT    PHKEY  phkResult,
    OUT    PTSTR  OwningDevInstName,    OPTIONAL
    IN OUT PDWORD OwningDevInstNameSize OPTIONAL
    )
/*++

Routine Description:

    This routine munges the specified device interface symbolic link name into
    a subkey name that is then opened underneath the specified interface class key.

    NOTE:  This munging algorithm must be kept in sync with the kernel-mode routines
    that generate these keys (e.g., IoRegisterDeviceInterface).

Arguments:

    hKeyInterfaceClass - Supplies the handle of the currently-open interface class key
        under which the device interface subkey is to be opened.

    DeviceInterfaceName - Supplies the symbolic link name ('\\?\' form) of the device
        interface for which the subkey is to be opened.

    samDesired - Specifies the access desired on the key to be opened.

    phkResult - Supplies the address of a variable that receives the registry handle,
        if successfully opened.

    OwningDevInstName - Optionally, supplies a character buffer that receives the name
        of the device instance that owns this interface.

    OwningDevInstNameSize - Optionally, supplies the address of a variable that, on input,
        contains the size of the OwningDevInstName buffer (in bytes).  Upon return, it
        receives that actual number of bytes stored in OwningDevInstName (including
        terminating NULL).

Return Value:

    If success, the return value is ERROR_SUCCESS.
    if failure, the return value is either ERROR_NOT_ENOUGH_MEMORY, ERROR_MORE_DATA, or
    ERROR_NO_SUCH_INTERFACE_DEVICE.

--*/
{
    DWORD BufferLength;
    LONG Err;
    PTSTR TempBuffer = NULL, RefString;
    TCHAR NoRefStringSubKeyName[2];
    HKEY hKey;
    DWORD RegDataType;

    Err = ERROR_SUCCESS;
    hKey = INVALID_HANDLE_VALUE;

    try {
        //
        // We need to allocate a temporary buffer to hold the symbolic link name while we munge it.
        //
        BufferLength = (lstrlen(DeviceInterfaceName) + 1) * sizeof(TCHAR);

        if(!(TempBuffer = MyMalloc(BufferLength))) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        memcpy(TempBuffer, DeviceInterfaceName, BufferLength);

        //
        // Parse this device interface name into the (munged) symbolic link name and
        // (optional) refstring.
        //
        GetRegSubkeysFromDeviceInterfaceName(TempBuffer, &RefString);

        //
        // Now open the symbolic link subkey under the interface class key.
        //
        if(ERROR_SUCCESS != RegOpenKeyEx(hKeyInterfaceClass,
                                         TempBuffer,
                                         0,
                                         KEY_READ,
                                         &hKey)) {
            //
            // Ensure the key handle is still invalid, so we won't try to free it.
            //
            hKey = INVALID_HANDLE_VALUE;
            Err = ERROR_NO_SUCH_DEVICE_INTERFACE;
            goto clean0;
        }

        //
        // If the caller requested it, retrieve the device instance that owns this interface.
        //
        if(OwningDevInstName) {

            Err = RegQueryValueEx(hKey,
                                  pszDeviceInstance,
                                  NULL,
                                  &RegDataType,
                                  (LPBYTE)OwningDevInstName,
                                  OwningDevInstNameSize
                                 );

            if((Err != ERROR_SUCCESS) || (RegDataType != REG_SZ)) {
                if(Err != ERROR_MORE_DATA) {
                    Err = ERROR_NO_SUCH_DEVICE_INTERFACE;
                }
                goto clean0;
            }
        }

        //
        // Now open up the subkey representing the particular 'instance' of this interface
        // (this is based on the refstring).
        //
        if(RefString) {
            //
            // Back up the pointer one character.  We know we're somewhere within TempBuffer
            // (but not at the beginning) so this is safe.
            //
            RefString--;
        } else {
            RefString = NoRefStringSubKeyName;
            NoRefStringSubKeyName[1] = TEXT('\0');
        }
        *RefString = TEXT('#');

        if(ERROR_SUCCESS != RegOpenKeyEx(hKey,
                                         RefString,
                                         0,
                                         samDesired,
                                         phkResult)) {

            Err = ERROR_NO_SUCH_DEVICE_INTERFACE;
            goto clean0;
        }

clean0:
        ; // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        //
        // Access the following variables so that the compiler will respect statement
        // ordering w.r.t. their assignment.
        //
        TempBuffer = TempBuffer;
        hKey = hKey;
    }

    if(TempBuffer) {
        MyFree(TempBuffer);
    }

    if(hKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKey);
    }

    return Err;
}


LONG
AddOrGetGuidTableIndex(
    IN PDEVICE_INFO_SET  DeviceInfoSet,
    IN CONST GUID       *ClassGuid,
    IN BOOL              AddIfNotPresent
    )
/*++

Routine Description:

    This routine retrieves the index of a class GUID within the devinfo set's GUID
    list (optionally, adding the GUID if not already present).
    This is used to allow DWORD comparisons instead of 16-byte GUID comparisons
    (and to save space).

Arguments:

    DeviceInfoSet - Supplies a pointer to the device information set containing the
        list of class GUIDs for which an index is to be retrieved.

    InterfaceClassGuid - Supplies a pointer to the GUID for which an index is to
        be added/retrieved.

    AddIfNotPresent - If TRUE, the class GUID will be added to the list if it's not
        already there.

Return Value:

    If success, the return value is an index into the devinfo set's GuidTable array.

    If failure, the return value is -1.  If adding, this indicates an out-of-memory
    condition.  If simply retrieving, then this indicates that the GUID is not in
    the list.

--*/
{
    LONG i;
    LPGUID NewGuidList;

    for(i = 0; (DWORD)i < DeviceInfoSet->GuidTableSize; i++) {

        if(IsEqualGUID(ClassGuid, &(DeviceInfoSet->GuidTable[i]))) {
            return i;
        }
    }

    if(AddIfNotPresent) {

        if(DeviceInfoSet->GuidTable) {
            NewGuidList = MyRealloc(DeviceInfoSet->GuidTable, (i + 1) * sizeof(GUID));
        } else {
            NewGuidList = MyMalloc(sizeof(GUID));
        }

        if(NewGuidList) {

            CopyMemory(&(NewGuidList[i]),
                       ClassGuid,
                       sizeof(GUID)
                      );

            DeviceInfoSet->GuidTable     = NewGuidList;
            DeviceInfoSet->GuidTableSize = i + 1;

            return i;

        } else {
            //
            // We couldn't allocate/grow the list; return -1 indicating an out-of-memory condition.
            //
            return -1;
        }

    } else {
        //
        // We didn't find the interface class GUID in our list, and we aren't supposed
        // to add it.
        //
        return -1;
    }
}


PINTERFACE_CLASS_LIST
AddOrGetInterfaceClassList(
    IN PDEVICE_INFO_SET DeviceInfoSet,
    IN PDEVINFO_ELEM    DevInfoElem,
    IN LONG             InterfaceClassGuidIndex,
    IN BOOL             AddIfNotPresent
    )
/*++

Routine Description:

    This routine retrieves the interface device list of the specified class that
    is 'owned' by the specified devinfo element.  This list can optionally be
    created if it doesn't already exist.

Arguments:

    DeviceInfoSet - Supplies a pointer to the device information set containing the
        devinfo element for which an interface device list is to be retrieved.

    DevInfoElem - Supplies a pointer to the devinfo element for which an interface
        device list is to be retrieved.

    InterfaceClassGuidIndex - Supplies the index of the interface class GUID within
        the hdevinfo set's InterfaceClassGuidList array.

    AddIfNotPresent - If TRUE, then a new interface device list of the specified class
        will be created for this devinfo element, if it doesn't already exist.

Return Value:

    If successful, the return value is a pointer to the requested interface device list
    for this devinfo element.

    If failure, the return value is NULL.  If AddIfNotPresent is TRUE, then this
    indicates an out-of-memory condition, otherwise, it indicates that the requested
    interface class list was not present for the devinfo element.

--*/
{
    DWORD i;
    PINTERFACE_CLASS_LIST NewClassList;

    for(i = 0; i < DevInfoElem->InterfaceClassListSize; i++) {

        if(DevInfoElem->InterfaceClassList[i].GuidIndex == InterfaceClassGuidIndex) {

            return (&(DevInfoElem->InterfaceClassList[i]));
        }
    }

    //
    // The requested interface class list doesn't presently exist for this devinfo element.
    //
    if(AddIfNotPresent) {

        if(DevInfoElem->InterfaceClassList) {
            NewClassList = MyRealloc(DevInfoElem->InterfaceClassList, (i + 1) * sizeof(INTERFACE_CLASS_LIST));
        } else {
            NewClassList = MyMalloc(sizeof(INTERFACE_CLASS_LIST));
        }

        if(NewClassList) {

            ZeroMemory(&(NewClassList[i]), sizeof(INTERFACE_CLASS_LIST));

            NewClassList[i].GuidIndex = InterfaceClassGuidIndex;

            DevInfoElem->InterfaceClassList     = NewClassList;
            DevInfoElem->InterfaceClassListSize = i + 1;

            return (&(DevInfoElem->InterfaceClassList[i]));

        } else {
            //
            // We couldn't allocate/grow this list; return NULL indicating an out-of-memory condition.
            //
            return NULL;
        }

    } else {
        //
        // We aren't supposed to add the class list if it doesn't already exist.
        //
        return NULL;
    }
}


BOOL
InterfaceDeviceDataFromNode(
    IN  PINTERFACE_DEVICE_NODE     InterfaceDeviceNode,
    IN  CONST GUID                *InterfaceClassGuid,
    OUT PSP_DEVICE_INTERFACE_DATA  InterfaceDeviceData
    )
/*++

Routine Description:

    This routine fills in a PSP_DEVICE_INTERFACE_DATA structure based
    on the information in the supplied interface device node.

    Note:  The supplied InterfaceDeviceData structure must have its cbSize
    field filled in correctly, or the call will fail.

Arguments:

    InterfaceDeviceNode - Supplies the address of the interface device node
        to be used in filling in the interface device data buffer.

    InterfaceClassGuid - Supplies a pointer to the class GUID for this
        interface device.

    InterfaceDeviceData - Supplies the address of the buffer to retrieve
        the interface device data.

Return Value:

    If the function succeeds, the return value is TRUE, otherwise, it
    is FALSE.

--*/
{
    if(InterfaceDeviceData->cbSize != sizeof(SP_DEVICE_INTERFACE_DATA)) {
        return FALSE;
    }

    CopyMemory(&(InterfaceDeviceData->InterfaceClassGuid),
               InterfaceClassGuid,
               sizeof(GUID)
              );

    InterfaceDeviceData->Flags = InterfaceDeviceNode->Flags;

    InterfaceDeviceData->Reserved = (ULONG_PTR)InterfaceDeviceNode;

    return TRUE;
}


PDEVINFO_ELEM
FindDevInfoElemForInterfaceDevice(
    IN PDEVICE_INFO_SET          DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA InterfaceDeviceData
    )
/*++

Routine Description:

    This routine searches through all elements of a device information
    set, looking for one that corresponds to the devinfo element pointer
    stored in the OwningDevInfoElem backpointer of the interface device
    node referenced in the Reserved field of the interface device data.  If a
    match is found, a pointer to the device information element is returned.

Arguments:

    DeviceInfoSet - Specifies the set to be searched.

    InterfaceDeviceData - Supplies a pointer to the interface device data
        for which the corresponding devinfo element is to be returned.

Return Value:

    If a device information element is found, the return value is a
    pointer to that element, otherwise, the return value is NULL.

--*/
{
    PDEVINFO_ELEM DevInfoElem;
    PINTERFACE_DEVICE_NODE InterfaceDeviceNode;

    if(InterfaceDeviceData->cbSize != sizeof(SP_DEVICE_INTERFACE_DATA)) {
        return NULL;
    }

    //
    // The Reserved field contains a pointer to the underlying interface device node.
    //
    InterfaceDeviceNode = (PINTERFACE_DEVICE_NODE)(InterfaceDeviceData->Reserved);

    for(DevInfoElem = DeviceInfoSet->DeviceInfoHead;
        DevInfoElem;
        DevInfoElem = DevInfoElem->Next) {

        if(DevInfoElem == InterfaceDeviceNode->OwningDevInfoElem) {

            return DevInfoElem;
        }
    }

    return NULL;
}


DWORD
MapCrToSpError(
    IN CONFIGRET CmReturnCode,
    IN DWORD     Default
    )
/*++

Routine Description:

    This routine maps some CM error return codes to setup api (Win32) return codes,
    and maps everything else to the value specied by Default.

Arguments:

    CmReturnCode - Specifies the ConfigMgr return code to be mapped.

    Default - Specifies the default value to use if no explicit mapping applies.

Return Value:

    Setup API (Win32) error code.

--*/
{
    switch(CmReturnCode) {

        case CR_SUCCESS :
            return NO_ERROR;

        case CR_CALL_NOT_IMPLEMENTED :
            return ERROR_CALL_NOT_IMPLEMENTED;

        case CR_OUT_OF_MEMORY :
            return ERROR_NOT_ENOUGH_MEMORY;

        case CR_INVALID_POINTER :
            return ERROR_INVALID_USER_BUFFER;

        case CR_INVALID_DEVINST :
            return ERROR_NO_SUCH_DEVINST;

        case CR_INVALID_DEVICE_ID :
            return ERROR_INVALID_DEVINST_NAME;

        case CR_ALREADY_SUCH_DEVINST :
            return ERROR_DEVINST_ALREADY_EXISTS;

        case CR_INVALID_REFERENCE_STRING :
            return ERROR_INVALID_REFERENCE_STRING;

        case CR_INVALID_MACHINENAME :
            return ERROR_INVALID_MACHINENAME;

        case CR_REMOTE_COMM_FAILURE :
            return ERROR_REMOTE_COMM_FAILURE;

        case CR_MACHINE_UNAVAILABLE :
            return ERROR_MACHINE_UNAVAILABLE;

        case CR_NO_CM_SERVICES :
            return ERROR_NO_CONFIGMGR_SERVICES;

        case CR_ACCESS_DENIED :
            return ERROR_ACCESS_DENIED;

        case CR_NOT_DISABLEABLE:
            return ERROR_NOT_DISABLEABLE;

        default :
            return Default;
    }
}

LPQUERY_SERVICE_LOCK_STATUS GetServiceLockStatus(
    IN  SC_HANDLE  SCMHandle
    )
/*++

Routine Description:

    Obtain service lock status - called when service is locked

Arguments:

    SCMHandle - supplies a handle to the SCM to lock

Return Value:

    NULL if failed (GetLastError contains error) otherwise buffer
    allocated by MyMalloc

--*/
{
    PBYTE Buffer = NULL;
    LPQUERY_SERVICE_LOCK_STATUS LockStatus = NULL;
    DWORD BufferSize = sizeof(QUERY_SERVICE_LOCK_STATUS)+MAX_PATH;
    DWORD ReqBufferSize = 0;

    Buffer = MyMalloc(BufferSize);
    while(Buffer) {
        LockStatus = (LPQUERY_SERVICE_LOCK_STATUS)Buffer;
        if(QueryServiceLockStatus(SCMHandle,LockStatus,BufferSize,&ReqBufferSize)) {
            return LockStatus;
        }
        if(GetLastError()!=ERROR_INSUFFICIENT_BUFFER) {
            MyFree(LockStatus);
            return NULL;
        }
        Buffer = MyRealloc(LockStatus,ReqBufferSize);
    }
    if(LockStatus) {
        MyFree(LockStatus);
    }
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return NULL;
}

DWORD
pAcquireSCMLock(
    IN  SC_HANDLE  SCMHandle,
    OUT SC_LOCK   *pSCMLock,
    IN  PSETUP_LOG_CONTEXT LogContext
    )
/*++

Routine Description:

    This routine attempts to lock the SCM database.  If it is already locked it will retry
    ACQUIRE_SCM_LOCK_ATTEMPTS times at intervals of ACQUIRE_SCM_LOCK_INTERVAL.

Arguments:

    SCMHandle - supplies a handle to the SCM to lock
    pSCMLock - receives the lock handle

Return Value:

    NO_ERROR if the lock is acquired, otherwise a Win32 error code

Remarks:

    The value of *pSCMLock is guaranteed to be NULL if the lock is not acquired

--*/
{
    DWORD Err;
    ULONG Attempts = ACQUIRE_SCM_LOCK_ATTEMPTS;
    LPQUERY_SERVICE_LOCK_STATUS LockStatus = NULL;

    MYASSERT(pSCMLock);
    *pSCMLock = NULL;

retry:
    while((*pSCMLock = LockServiceDatabase(SCMHandle)) == NULL && Attempts > 0) {
        //
        // Check if the error is that someone else has locked the SCM
        //
        if((Err = GetLastError()) == ERROR_SERVICE_DATABASE_LOCKED) {

            Attempts--;
            //
            // Sleep for specified time
            //
            Sleep(ACQUIRE_SCM_LOCK_INTERVAL);
        } else {
            //
            // Unrecoverable error occured
            //
            break;
        }
    }

    if(!*pSCMLock) {
        Err = GetLastError();
        if(Err == ERROR_SERVICE_DATABASE_LOCKED) {
            LockStatus =  GetServiceLockStatus(SCMHandle);
            if(LockStatus && !LockStatus->fIsLocked) {
                MYASSERT(LockStatus->fIsLocked);
                MyFree(LockStatus);
                //
                // just became free, may as well try again
                //
                goto retry;
            } else if(LockStatus) {
                WriteLogEntry(LogContext,
                                SETUP_LOG_ERROR,
                                MSG_LOG_SCM_LOCKED_INFO,
                                NULL,
                                LockStatus->lpLockOwner,
                                LockStatus->dwLockDuration);
                MyFree(LockStatus);
            } else {
                WriteLogEntry(LogContext,
                                SETUP_LOG_ERROR,
                                MSG_LOG_SCM_LOCKED_INFO,
                                NULL,
                                TEXT("?"),
                                0);
            }
        }
        //
        // We have been unable to lock the SCM
        //
        return Err;
    }

    return NO_ERROR;


}

DWORD
pSetupAcquireSCMLock(
    IN SC_HANDLE SCMHandle,
    OUT SC_LOCK *pSCMLock
    )
/*++

Routine Description:

    variation of pAcquireSCMLock used by SysSetup
    See pAcquireSCMLock

--*/
{
    return pAcquireSCMLock(SCMHandle,pSCMLock,NULL);
}


DWORD
InvalidateHelperModules(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN DWORD            Flags
    )
/*++

Routine Description:

    This routine resets the list of 'helper modules' (class installer, property
    page providers, and co-installers), and either frees them immediately or
    migrates the module handles to the devinfo set's list of things to clean up
    when the HDEVINFO is destroyed.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        a list of 'helper' modules to be invalidated.

    DeviceInfoData - Optionally, specifies a particular device information
        element containing a list of 'helper' modules to be invalidated.  If
        this parameter is not specified, then the list of modules for the
        set itself will be invalidated.

    Flags - Supplies flags that control the behavior of this routine.  May be
        a combination of the following values:

        IHM_COINSTALLERS_ONLY - If this flag is set, only the co-installers list
                                will be invalidated.  Otherwise, the class
                                installer and property page providers will also
                                be invalidated.

        IHM_FREE_IMMEDIATELY  - If this flag is set, then the modules will be
                                freed immediately.  Otherwise, the modules will
                                be added to the HDEVINFO set's list of things to
                                clean up at handle close time.

Return Value:

    If successful, the return value is NO_ERROR, otherwise it is ERROR_NOT_ENOUGH_MEMORY.
    (This routine cannot fail if the IHM_FREE_IMMEDIATELY flag is set.)

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err, i;
    PDEVINFO_ELEM DevInfoElem;
    PDEVINSTALL_PARAM_BLOCK InstallParamBlock;
    DWORD NumModulesToInvalidate;
    PMODULE_HANDLE_LIST_NODE NewModuleHandleNode;
    BOOL UnlockDevInfoElem;
    LONG CoInstallerIndex;
    SPFUSIONINSTANCE spFusionInstance;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        //
        // The handle's no longer valid--the user must've already destroyed the
        // set.  We have nothing to do.
        //
        return NO_ERROR;
    }

    Err = NO_ERROR;
    UnlockDevInfoElem = FALSE;
    DevInfoElem = NULL;
    NewModuleHandleNode = NULL;

    try {
        //
        // If we're invalidating helper modules for a particular devinfo element,
        // then find that element.
        //
        if(DeviceInfoData) {
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                //
                // The element must've been deleted--we've nothing to do.
                //
                goto clean0;
            }
            InstallParamBlock = &(DevInfoElem->InstallParamBlock);
        } else {
            InstallParamBlock = &(pDeviceInfoSet->InstallParamBlock);
        }

        //
        // Count the number of module handles we need to free/migrate.
        //
        if(InstallParamBlock->CoInstallerCount == -1) {
            NumModulesToInvalidate = 0;
        } else {
            MYASSERT(InstallParamBlock->CoInstallerCount >= 0);
            NumModulesToInvalidate = (DWORD)(InstallParamBlock->CoInstallerCount);
        }

        if(!(Flags & IHM_COINSTALLERS_ONLY)) {
            if(InstallParamBlock->hinstClassInstaller) {
                NumModulesToInvalidate++;
            }
            if(InstallParamBlock->hinstClassPropProvider) {
                NumModulesToInvalidate++;
            }
            if(InstallParamBlock->hinstDevicePropProvider) {
                NumModulesToInvalidate++;
            }
            if(InstallParamBlock->hinstBasicPropProvider) {
                NumModulesToInvalidate++;
            }
        }

        if(NumModulesToInvalidate) {
            //
            // If we can't unload these modules at this time, then create a node to store
            // these module handles until the devinfo set is destroyed.
            //
            if(!(Flags & IHM_FREE_IMMEDIATELY)) {

                NewModuleHandleNode = MyMalloc(offsetof(MODULE_HANDLE_LIST_NODE, ModuleList)
                                               + (NumModulesToInvalidate * sizeof(MODULE_HANDLE_LIST_INSTANCE))
                                              );

                if(!NewModuleHandleNode) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean0;
                }
            }

            //
            // Give the class installers/co-installers a DIF_DESTROYPRIVATEDATA
            // notification.  NOTE: We don't unlock the HDEVINFO set here, so the
            // class/co-installers can't make any calls where nesting level > 1
            // is disallowed.  This means that SetupDiSelectDevice, for example,
            // will fail if the class installer tries to call it now.  This is
            // necessary, because otherwise it would deadlock.
            //
            if(DevInfoElem) {
                //
                // (Also, lock down the devinfo element, so that the class/co-installers
                // can't make any 'dangerous' calls (e.g., SetupDiDeleteDeviceInfo),
                // during the clean-up notification.)
                //
                if(!(DevInfoElem->DiElemFlags & DIE_IS_LOCKED)) {
                    DevInfoElem->DiElemFlags |= DIE_IS_LOCKED;
                    UnlockDevInfoElem = TRUE;
                }
            }

            _SetupDiCallClassInstaller(DIF_DESTROYPRIVATEDATA,
                                       DeviceInfoSet,
                                       DeviceInfoData,
                                       CALLCI_CALL_HELPERS
                                      );

            //
            // Clear the flag we set above...
            //
            if(UnlockDevInfoElem) {
                DevInfoElem->DiElemFlags &= ~DIE_IS_LOCKED;
                UnlockDevInfoElem = FALSE;
            }

            //
            // Store the module handles in the node we allocated, and link it into the
            // list of module handles associated with this devinfo set.
            //
            i = 0;

            if(!(Flags & IHM_COINSTALLERS_ONLY)) {
                //
                // Either free the modules now, or store them in our 'to do' list...
                //
                if(Flags & IHM_FREE_IMMEDIATELY) {
                    if(InstallParamBlock->hinstClassInstaller) {
                        spFusionEnterContext(InstallParamBlock->ClassInstallerFusionContext,
                                                &spFusionInstance);
                        FreeLibrary(InstallParamBlock->hinstClassInstaller);
                        spFusionLeaveContext(&spFusionInstance);
                        spFusionKillContext(InstallParamBlock->ClassInstallerFusionContext);
                    }
                    if(InstallParamBlock->hinstClassPropProvider) {
                        spFusionEnterContext(InstallParamBlock->ClassEnumPropPagesFusionContext,
                                                &spFusionInstance);
                        FreeLibrary(InstallParamBlock->hinstClassPropProvider);
                        spFusionLeaveContext(&spFusionInstance);
                        spFusionKillContext(InstallParamBlock->ClassEnumPropPagesFusionContext);
                    }
                    if(InstallParamBlock->hinstDevicePropProvider) {
                        spFusionEnterContext(InstallParamBlock->DeviceEnumPropPagesFusionContext,
                                                &spFusionInstance);
                        FreeLibrary(InstallParamBlock->hinstDevicePropProvider);
                        spFusionLeaveContext(&spFusionInstance);
                        spFusionKillContext(InstallParamBlock->DeviceEnumPropPagesFusionContext);
                    }
                    if(InstallParamBlock->hinstBasicPropProvider) {
                        spFusionEnterContext(InstallParamBlock->EnumBasicPropertiesFusionContext,
                                                &spFusionInstance);
                        FreeLibrary(InstallParamBlock->hinstBasicPropProvider);
                        spFusionLeaveContext(&spFusionInstance);
                        spFusionKillContext(InstallParamBlock->EnumBasicPropertiesFusionContext);
                    }
                } else {
                    if(InstallParamBlock->hinstClassInstaller) {
                        NewModuleHandleNode->ModuleList[i].ModuleHandle = InstallParamBlock->hinstClassInstaller;
                        NewModuleHandleNode->ModuleList[i++].FusionContext = InstallParamBlock->ClassInstallerFusionContext;
                    }
                    if(InstallParamBlock->hinstClassPropProvider) {
                        NewModuleHandleNode->ModuleList[i].ModuleHandle = InstallParamBlock->hinstClassPropProvider;
                        NewModuleHandleNode->ModuleList[i++].FusionContext = InstallParamBlock->ClassEnumPropPagesFusionContext;
                    }
                    if(InstallParamBlock->hinstDevicePropProvider) {
                        NewModuleHandleNode->ModuleList[i].ModuleHandle = InstallParamBlock->hinstDevicePropProvider;
                        NewModuleHandleNode->ModuleList[i++].FusionContext = InstallParamBlock->DeviceEnumPropPagesFusionContext;
                    }
                    if(InstallParamBlock->hinstBasicPropProvider) {
                        NewModuleHandleNode->ModuleList[i].ModuleHandle = InstallParamBlock->hinstBasicPropProvider;
                        NewModuleHandleNode->ModuleList[i++].FusionContext = InstallParamBlock->EnumBasicPropertiesFusionContext;
                    }
                }
            }

            for(CoInstallerIndex = 0;
                CoInstallerIndex < InstallParamBlock->CoInstallerCount;
                CoInstallerIndex++)
            {
                if(Flags & IHM_FREE_IMMEDIATELY) {
                    spFusionEnterContext(InstallParamBlock->CoInstallerList[CoInstallerIndex].CoInstallerFusionContext,
                                            &spFusionInstance);
                    FreeLibrary(InstallParamBlock->CoInstallerList[CoInstallerIndex].hinstCoInstaller);
                    spFusionLeaveContext(&spFusionInstance);
                    spFusionKillContext(InstallParamBlock->CoInstallerList[CoInstallerIndex].CoInstallerFusionContext);
                } else {
                    NewModuleHandleNode->ModuleList[i].ModuleHandle =
                        InstallParamBlock->CoInstallerList[CoInstallerIndex].hinstCoInstaller;
                    NewModuleHandleNode->ModuleList[i++].FusionContext =
                        InstallParamBlock->CoInstallerList[CoInstallerIndex].CoInstallerFusionContext;
                }
            }

            //
            // Unless we're freeing these modules immediately, our modules-to-free list
            // index should now match the number of modules we're supposed to be
            // invalidating.
            //
            MYASSERT((Flags & IHM_FREE_IMMEDIATELY) || (i == NumModulesToInvalidate));

            if(!(Flags & IHM_FREE_IMMEDIATELY)) {

                NewModuleHandleNode->ModuleCount = NumModulesToInvalidate;

                NewModuleHandleNode->Next = pDeviceInfoSet->ModulesToFree;
                pDeviceInfoSet->ModulesToFree = NewModuleHandleNode;

                //
                // Now, clear the node pointer, so we won't try to free it if we hit an exception.
                //
                NewModuleHandleNode = NULL;
            }

            //
            // Clear all the module handles (and entry points).  They will be retrieved
            // anew the next time they're needed.
            //
            if(!(Flags & IHM_COINSTALLERS_ONLY)) {
                InstallParamBlock->hinstClassInstaller              = NULL;
                InstallParamBlock->ClassInstallerEntryPoint         = NULL;
                InstallParamBlock->ClassInstallerFusionContext      = NULL;

                InstallParamBlock->hinstClassPropProvider           = NULL;
                InstallParamBlock->ClassEnumPropPagesEntryPoint     = NULL;
                InstallParamBlock->ClassEnumPropPagesFusionContext  = NULL;

                InstallParamBlock->hinstDevicePropProvider          = NULL;
                InstallParamBlock->DeviceEnumPropPagesEntryPoint    = NULL;
                InstallParamBlock->DeviceEnumPropPagesFusionContext = NULL;

                InstallParamBlock->hinstBasicPropProvider           = NULL;
                InstallParamBlock->EnumBasicPropertiesEntryPoint    = NULL;
                InstallParamBlock->EnumBasicPropertiesFusionContext = NULL;
            }

            if(InstallParamBlock->CoInstallerCount != -1) {
                if(InstallParamBlock->CoInstallerList) {
                    MyFree(InstallParamBlock->CoInstallerList);
                    InstallParamBlock->CoInstallerList = NULL;
                }
            }
        }

        //
        // Set the co-installer count back to -1, even if their weren't any co-installers
        // to unload.  That will ensure that we'll re-load the co-installers for the next
        // class installer request we receive.
        //
        InstallParamBlock->CoInstallerCount = -1;

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // We should never encounter an exception, but if we do, just make sure we
        // do any necessary clean-up.  Don't return an error in this case--the only
        // error this routine is supposed to return is out-of-memory.
        //
        if(UnlockDevInfoElem) {
            MYASSERT(DevInfoElem);
            DevInfoElem->DiElemFlags &= ~DIE_IS_LOCKED;
        }
        if(NewModuleHandleNode) {
            MyFree(NewModuleHandleNode);
        }
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    return Err;
}


DWORD
DoInstallActionWithParams(
    IN DI_FUNCTION             InstallFunction,
    IN HDEVINFO                DeviceInfoSet,
    IN PSP_DEVINFO_DATA        DeviceInfoData,         OPTIONAL
    IN OUT PSP_CLASSINSTALL_HEADER ClassInstallParams,     OPTIONAL
    IN DWORD                   ClassInstallParamsSize,
    IN DWORD                   Flags
    )
/*++

Routine Description:

    This routine performs a requested installation action, using the specified
    class install parameters.  Any existing class install parameters are
    preserved.

Arguments:

    InstallFunction - Specifies the DIF_* action to be performed.

    DeviceInfoSet - Supplies a handle to the device information set for which
        the installation action is to be performed.

    DeviceInfoData - Optionally, supplies the address of a device information
        structure specifying a particular element for which the installation
        action is to be performed.

    ClassInstallParams - Optionally, supplies the address of a class install
        parameter buffer to be used for this action.  If this parameter is not
        specified, then no class install params will be available to the class
        installer during this call (even if there were pre-existing parameters
        coming into this function).

    ClassInstallParamsSize - Supplies the size, in bytes, of the ClassInstallParams
        buffer, or zero if ClassInstallParams is not specified.

    Flags - Supplies flags that control the behavior of this routine.  May be
        a combination of the following values:

        INSTALLACTION_CALL_CI - Call the class installer for this action request.

        INSTALLACTION_NO_DEFAULT - Don't perform the default action (if this flag
            is specified without INSTALLACTION_CALL_CI, then this routine is a
            no-op).

Return Value:

    If the request was handled successfully, the return value is NO_ERROR.

    If the request was not handled (but no error occurred), the return value is
    ERROR_DI_DO_DEFAULT.

    Otherwise, the return value is a Win32 error code indicating the cause of
    failure.

--*/
{
    PBYTE OldCiParams;
    DWORD OldCiParamsSize, Err;
    SP_PROPCHANGE_PARAMS PropChangeParams;
    SP_DEVINSTALL_PARAMS DevInstallParams;
    DWORD FlagsToClear;

    //
    // Retrieve any existing class install parameters, then write out
    // parameters for DIF_PROPERTYCHANGE.
    //
    OldCiParams = NULL;
    OldCiParamsSize = 0;

    while(!SetupDiGetClassInstallParams(DeviceInfoSet,
                                        DeviceInfoData,
                                        (PSP_CLASSINSTALL_HEADER)OldCiParams,
                                        OldCiParamsSize,
                                        &OldCiParamsSize)) {
        Err = GetLastError();

        //
        // Before going any further, free our existing buffer (if there is one).
        //
        if(OldCiParams) {
            MyFree(OldCiParams);
            OldCiParams = NULL;
        }

        if(Err == ERROR_INSUFFICIENT_BUFFER) {
            //
            // Allocate a buffer of the size required, and try again.
            //
            MYASSERT(OldCiParamsSize >= sizeof(SP_CLASSINSTALL_HEADER));

            if(!(OldCiParams = MyMalloc(OldCiParamsSize))) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }

            ((PSP_CLASSINSTALL_HEADER)OldCiParams)->cbSize = sizeof(SP_CLASSINSTALL_HEADER);

        } else {
            //
            // Treat any other error as if there are no class install params
            // (since ERROR_NO_CLASSINSTALL_PARAMS is really the only error
            // we should ever see here anyway).
            //
            OldCiParamsSize = 0;
            break;
        }
    }

    //
    // Retrieve the device install params for the set or element we're working with.
    //
    DevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if(!SetupDiGetDeviceInstallParams(DeviceInfoSet,
                                      DeviceInfoData,
                                      &DevInstallParams)) {
        Err = GetLastError();
        goto clean0;
    }

    FlagsToClear = 0;

    //
    // It's possible that the class install params we just retrieved are 'turned off'
    // (i.e., the DI_CLASSINSTALLPARAMS bit is cleared).  Check for that condition now,
    // so we can restore the parameters to the same state later.
    //
    if(OldCiParams && !(DevInstallParams.Flags & DI_CLASSINSTALLPARAMS)) {
        FlagsToClear |= DI_CLASSINSTALLPARAMS;
    }

    //
    // If the caller doesn't want us to do the default action, then check to see whether
    // we need to temporarily set the DI_NODI_DEFAULTACTION flag.
    //
    if((Flags & INSTALLACTION_NO_DEFAULT) &&
       !(DevInstallParams.Flags & DI_NODI_DEFAULTACTION)) {

        FlagsToClear |= DI_NODI_DEFAULTACTION;

        DevInstallParams.Flags |= DI_NODI_DEFAULTACTION;

        if(!SetupDiSetDeviceInstallParams(DeviceInfoSet,
                                          DeviceInfoData,
                                          &DevInstallParams)) {
            Err = GetLastError();
            goto clean0;
        }
    }

    if(!SetupDiSetClassInstallParams(DeviceInfoSet,
                                     DeviceInfoData,
                                     ClassInstallParams,
                                     ClassInstallParamsSize)) {

        Err = GetLastError();
        goto clean1;
    }

    //
    // OK, now call the class installer.
    //
    if(_SetupDiCallClassInstaller(InstallFunction,
                                  DeviceInfoSet,
                                  DeviceInfoData,
                                  (Flags & INSTALLACTION_CALL_CI) ? (CALLCI_LOAD_HELPERS | CALLCI_CALL_HELPERS) : 0)) {
        //
        // mission accomplished
        //
        Err = NO_ERROR;
    } else {
        Err = GetLastError();
    }

    //
    // Save the class install params results in the ClassInstallParams
    // value that was passed in.
    //
    if (ClassInstallParams) {

        SetupDiGetClassInstallParams(DeviceInfoSet,
                                     DeviceInfoData,
                                     ClassInstallParams,
                                     ClassInstallParamsSize,
                                     NULL);
    }

    //
    // Restore the previous class install params.
    //
    SetupDiSetClassInstallParams(DeviceInfoSet,
                                 DeviceInfoData,
                                 (PSP_CLASSINSTALL_HEADER)OldCiParams,
                                 OldCiParamsSize
                                );

clean1:

    if(FlagsToClear) {

        if(SetupDiGetDeviceInstallParams(DeviceInfoSet,
                                         DeviceInfoData,
                                         &DevInstallParams)) {

            DevInstallParams.Flags &= ~FlagsToClear;

            SetupDiSetDeviceInstallParams(DeviceInfoSet,
                                          DeviceInfoData,
                                          &DevInstallParams
                                         );
        }
    }

clean0:

    if(OldCiParams) {
        MyFree(OldCiParams);
    }

    return Err;
}


BOOL
GetBestDeviceDesc(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,  OPTIONAL
    OUT PTSTR            DeviceDescBuffer
    )
/*++

Routine Description:

    This routine retrieves the best possible description to be displayed for
    the specified devinfo set or element (e.g., for driver signing popups). We
    will try to retrieve this string by doing the following things (in order)
    until one of them succeeds:

        1.  If there's a selected driver, retrieve the DeviceDesc in that
            driver node.
        2.  If this is for a device information element, then use devnode's
            DeviceDesc property.
        3.  Retrieve the description of the class (via
            SetupDiGetClassDescription).
        4.  Use the (localized) string "Unknown driver software package".

    ASSUMES THAT THE CALLING ROUTINE HAS ALREADY ACQUIRED THE LOCK!

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set for which
        a description is to be retrieved (unless DeviceInfoData is also
        supplied, in which case we retrieve the description for that particular
        element instead.

    DeviceInfoData - Optionally, supplies the device information element for
        which a description is to be retrieved.

    DeviceDescBuffer - Supplies the address of a character buffer that must be
        at least LINE_LEN characters long.  Upon successful return, this buffer
        will be filled in with a device description

Return Value:

    TRUE if some description was retrieved, FALSE otherwise.

--*/
{
    SP_DRVINFO_DATA DriverInfoData;
    GUID ClassGuid;
    BOOL b;

    //
    // First, see if there's a selected driver for this device information set
    // or element.
    //
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if(SetupDiGetSelectedDriver(DeviceInfoSet, DeviceInfoData, &DriverInfoData)) {
        //
        // Copy the description into the caller-supplied buffer and return.
        //
        lstrcpy(DeviceDescBuffer, DriverInfoData.Description);
        return TRUE;
    }

    //
    // OK, next try to retrieve the DeviceDesc property (if we're working on a
    // device information element.
    //
    if(DeviceInfoData) {

        if(SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                            DeviceInfoData,
                                            SPDRP_DEVICEDESC,
                                            NULL,
                                            (PBYTE)DeviceDescBuffer,
                                            LINE_LEN * sizeof(TCHAR),
                                            NULL)) {
            return TRUE;
        }
    }

    //
    // Next, try to retrieve the class's friendly name.
    //
    if(DeviceInfoData) {
        CopyMemory(&ClassGuid, &(DeviceInfoData->ClassGuid), sizeof(GUID));
    } else {
        b = SetupDiGetDeviceInfoListClass(DeviceInfoSet, &ClassGuid);
        MYASSERT(b);
        if(!b) {
            return FALSE;
        }
    }

    if(SetupDiGetClassDescription(&ClassGuid,
                                  DeviceDescBuffer,
                                  LINE_LEN,
                                  NULL)) {
        return TRUE;

    } else {
        //
        // We have a class that isn't already installed.  Therefore, we just
        // give it a generic description.
        //
        if(LoadString(MyDllModuleHandle,
                      IDS_UNKNOWN_DRIVER,
                      DeviceDescBuffer,
                      LINE_LEN)) {

            return TRUE;
        }
    }

    return FALSE;
}


BOOL
GetDecoratedModelsSection(
    IN  PSETUP_LOG_CONTEXT      LogContext,            OPTIONAL
    IN  PLOADED_INF             Inf,
    IN  PINF_LINE               MfgListLine,
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,       OPTIONAL
    OUT PTSTR                   DecoratedModelsSection OPTIONAL
    )
/*++

Routine Description:

    This routine examines each (optional) TargetDecoration field within the
    specified manufacturer's entry in the [Manufacturer] section, to see if any
    are applicable to the current OS.  If so, the most-appropriate one (based
    on OS major and minor version) is chosen, and the TargetDecoration string
    is appended to the manufacturer's models section name, and returned to the
    caller.

    The format of the TargetDecoration field is as follows:

    NT[architecture][.[OSMajorVer][.[OSMinorVer][.[ProductType][.[SuiteMask]]]]]

    Where:

    architecture may be x86, IA64, AXP64, or AMD64.

    OSMajorVer is the OS major version (e.g., for Whistler, it's 5)

    OSMinorVer is the OS minor version (e.g., for Whistler, it's 1)

    ProductType indicates the type of product, and may be one of the following
    values (as defined in winnt.h):

        VER_NT_WORKSTATION              0x0000001
        VER_NT_DOMAIN_CONTROLLER        0x0000002
        VER_NT_SERVER                   0x0000003

    SuiteMask is a combination of the following flags identifying the product
    suites available on the system (as defined in winnt.h):

        VER_SUITE_SMALLBUSINESS             0x00000001
        VER_SUITE_ENTERPRISE                0x00000002
        VER_SUITE_BACKOFFICE                0x00000004
        VER_SUITE_COMMUNICATIONS            0x00000008
        VER_SUITE_TERMINAL                  0x00000010
        VER_SUITE_SMALLBUSINESS_RESTRICTED  0x00000020
        VER_SUITE_EMBEDDEDNT                0x00000040
        VER_SUITE_DATACENTER                0x00000080
        VER_SUITE_SINGLEUSERTS              0x00000100

    Refer to the discussion in the SDK for the OSVERSIONINFOEX structure for
    more information.

    THIS ROUTINE DOES NOT DO LOCKING ON THE INF!!!

Arguments:

    LogContext - optionally, supplies the log context to use if an error is
        encountered (e.g., decorated section name is too long)

    Inf - supplies a pointer to the inf descriptor for the loaded device INF.

    MfgListLine - supplies a pointer to the line descriptor for the
        manufacturer's entry within the [Manufacturer] section.  THIS LINE MUST
        BE CONTAINED WITHIN THE SPECIFIED INF!!

    AltPlatformInfo - optionally, supplies alternate platform information to be
        used when selecting the most-appropriate models section.

        NOTE: If this parameter is supplied, then we must do our own version
        comparisons, as VerifyVersionInfo() has no clue about non-native
        matters.  This also means that we do not take into account either
        ProductType or SuiteMask in our comparison.

    DecoratedModelsSection - upon successful return, receives the decorated
        models section name based on the most-appropriate TargetDecoration
        field in the manufacturer's entry.

        This character buffer must be at least MAX_SECT_NAME_LEN characters.

Return Value:

    If an applicable TargetDecoration entry was found (thus
    DecoratedModelsSection was filled in), the return value is TRUE.

    Otherwise, the return value is FALSE.

--*/
{
    #define DEC_INCLUDES_ARCHITECTURE  4
    #define DEC_INCLUDES_PRODUCTTYPE   2
    #define DEC_INCLUDES_SUITEMASK     1

    DWORD CurFieldIndex;
    PCTSTR CurTargetDecoration, ModelsSectionName;
    PCTSTR BestTargetDecoration = NULL;
    INT SectionNameLen;
    TCHAR DecBuffer[MAX_SECT_NAME_LEN];
    PTSTR CurDecPtr, NextDecPtr;
    DWORD BestMajorVer = 0, BestMinorVer = 0;
    DWORD BestDecIncludesMask = 0;
    DWORD CurMajorVer, CurMinorVer;
    BYTE ProductType;
    WORD SuiteMask;
    INT   TempInt;
    DWORD CurDecIncludesMask;
    BOOL NewBestFound;
    OSVERSIONINFOEX OsVersionInfoEx;
    DWORDLONG ConditionMask;
    DWORD TypeMask;
    DWORD Platform;
    PCTSTR NtArchSuffix;

    //
    // Set OsVersionInfoEx size field to zero as a flag to indicate that
    // structure initialization is necessary if we end up needing to call
    // VerifyVersionInfo later.
    //
    OsVersionInfoEx.dwOSVersionInfoSize = 0;

    //
    // Determine which platform we should be looking for...
    //
    Platform = AltPlatformInfo ? AltPlatformInfo->Platform
                               : OSVersionInfo.dwPlatformId;

    //
    // ...as well as which OS/architecture decoration.  (Note that we skip the
    // first character of the platform suffix, since we don't want the
    // leading '.')
    //
    if(AltPlatformInfo) {

        switch(AltPlatformInfo->ProcessorArchitecture) {

            case PROCESSOR_ARCHITECTURE_INTEL :
                NtArchSuffix = &(pszNtX86Suffix[1]);
                break;

            case PROCESSOR_ARCHITECTURE_ALPHA :
                NtArchSuffix = &(pszNtAlphaSuffix[1]);
                break;

            case PROCESSOR_ARCHITECTURE_IA64 :
                NtArchSuffix = &(pszNtIA64Suffix[1]);
                break;

            case PROCESSOR_ARCHITECTURE_ALPHA64 :
                NtArchSuffix = &(pszNtAXP64Suffix[1]);
                break;

            case PROCESSOR_ARCHITECTURE_AMD64 :
                NtArchSuffix = &(pszNtAMD64Suffix[1]);
                break;

            default:
                //
                // Unknown/invalid architecture
                //
                return FALSE;
        }

    } else {
        NtArchSuffix = &(pszNtPlatformSuffix[1]);
    }

    //
    // TargetDecoration fields start at field index 2...
    //
    for(CurFieldIndex = 2;
        CurTargetDecoration = InfGetField(Inf, MfgListLine, CurFieldIndex, NULL);
        CurFieldIndex++)
    {
        //
        // Copy the TargetDecoration into a scratch buffer so we can extract
        // the various fields from it.
        //
        lstrcpyn(DecBuffer, CurTargetDecoration, SIZECHARS(DecBuffer));

        //
        // First part is traditional per-OS/architecture decoration.
        //
        CurMajorVer = CurMinorVer = 0;
        CurDecIncludesMask = 0;

        CurDecPtr = _tcschr(DecBuffer, TEXT('.'));

        if(CurDecPtr) {
            *CurDecPtr = TEXT('\0');
        }

        if(Platform == VER_PLATFORM_WIN32_NT) {
            //
            // We're on NT, so first try the NT architecture-specific
            // extension, then the generic NT extension.
            //
            if(!lstrcmpi(DecBuffer, NtArchSuffix)) {

                CurDecIncludesMask |= DEC_INCLUDES_ARCHITECTURE;

            } else if(lstrcmpi(DecBuffer, &(pszNtSuffix[1]))) {
                //
                // TargetDecoration isn't applicable for this OS/architecture.
                // Skip it and continue on to the next one.
                //
                continue;
            }

        } else {
            //
            // We're on Win9x, so try the Windows-specific extension
            //
            if(lstrcmpi(DecBuffer, &(pszWinSuffix[1]))) {
                //
                // TargetDecoration isn't applicable for this OS.
                // Skip it and continue on to the next one.
                //
                continue;
            }
        }

        //
        // If we get to here, then the decoration is applicable to the
        // OS/architecture under which we're running (or for which alt platform
        // info was specified)
        //
        if(CurDecPtr) {
            //
            // Version info is included--extract the supplied components and
            // use VerifyVersionInfo to see if they're valid for the OS version
            // under which we're running.
            //

            //
            // Get major version...
            //
            NextDecPtr = _tcschr(++CurDecPtr, TEXT('.'));

            if(NextDecPtr) {
                *NextDecPtr = TEXT('\0');
            }

            if(!pAToI(CurDecPtr, &TempInt) || (TempInt < 0)) {
                continue;
            }

            CurMajorVer = (DWORD)TempInt;

            if(NextDecPtr) {
                CurDecPtr = NextDecPtr + 1;
            } else {
                //
                // No more fields to retrieve--assume minor version of 0.
                //
                CurMinorVer = 0;
                goto AllFieldsRetrieved;
            }

            //
            // Get minor version...
            //
            NextDecPtr = _tcschr(CurDecPtr, TEXT('.'));

            if(NextDecPtr) {
                *NextDecPtr = TEXT('\0');
            }

            if(!pAToI(CurDecPtr, &TempInt) || (TempInt < 0)) {
                continue;
            }

            CurMinorVer = (DWORD)TempInt;

            //
            // If minor version is supplied, then major version must be
            // supplied as well.
            //
            if(CurMinorVer && !CurMajorVer) {
                continue;
            }

            if(NextDecPtr && !AltPlatformInfo) {
                CurDecPtr = NextDecPtr + 1;
            } else {
                //
                // No more fields to retrieve
                //
                goto AllFieldsRetrieved;
            }

            //
            // Get product type
            //
            NextDecPtr = _tcschr(CurDecPtr, TEXT('.'));

            if(NextDecPtr) {
                *NextDecPtr = TEXT('\0');
            }

            if(!pAToI(CurDecPtr, &TempInt) ||
               (TempInt < 0) || (TempInt > 0xff)) {
                continue;
            }

            ProductType = (BYTE)TempInt;

            if(ProductType) {
                CurDecIncludesMask |= DEC_INCLUDES_PRODUCTTYPE;
            }

            if(NextDecPtr) {
                CurDecPtr = NextDecPtr + 1;
            } else {
                //
                // No more fields to retrieve
                //
                goto AllFieldsRetrieved;
            }

            //
            // Get suite mask.  If we find another '.' in the TargetDecoration
            // field, this indicates additional fields we don't know about
            // (e.g., a future version of setupapi has added more fields, say,
            // for service pack info).  Since we don't know how to interpret
            // these additional fields, an entry containing them must be
            // skipped.
            //
            if(_tcschr(CurDecPtr, TEXT('.'))) {
                continue;
            }

            if(!pAToI(CurDecPtr, &TempInt) ||
               (TempInt < 0) || (TempInt > 0xffff)) {
                continue;
            }

            SuiteMask = (WORD)TempInt;

            if(SuiteMask) {
                CurDecIncludesMask |= DEC_INCLUDES_SUITEMASK;
            }

AllFieldsRetrieved :

            if(AltPlatformInfo) {
                //
                // We're doing a non-native driver search, so we're on our own
                // to do version comparison...
                //
                if((AltPlatformInfo->MajorVersion < CurMajorVer) ||
                   ((AltPlatformInfo->MajorVersion == CurMajorVer) &&
                    (AltPlatformInfo->MinorVersion < CurMinorVer))) {

                    //
                    // The alternate platform info is for an older (lower-
                    // versioned) OS than the current TargetDecoration.
                    //
                    continue;
                }

            } else {
                //
                // We're doing native driver searching, we can use the handy
                // API, VerifyVersionInfo.
                //
                if(!OsVersionInfoEx.dwOSVersionInfoSize) {
                    //
                    // First time we've needed to call VerifyVersionInfo--must
                    // initialize the structure first...
                    //
                    ZeroMemory(&OsVersionInfoEx, sizeof(OsVersionInfoEx));
                    OsVersionInfoEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
                }

                TypeMask = 0;
                ConditionMask = 0;

                OsVersionInfoEx.dwMajorVersion = CurMajorVer;
                OsVersionInfoEx.dwMinorVersion = CurMinorVer;

                if(CurMajorVer) {

                    TypeMask |= (VER_MAJORVERSION | VER_MINORVERSION);

                    VER_SET_CONDITION(ConditionMask,
                                      VER_MAJORVERSION,
                                      VER_GREATER_EQUAL
                                     );

                    VER_SET_CONDITION(ConditionMask,
                                      VER_MINORVERSION,
                                      VER_GREATER_EQUAL
                                     );
                }

                if(CurDecIncludesMask & DEC_INCLUDES_PRODUCTTYPE) {

                    OsVersionInfoEx.wProductType = ProductType;

                    TypeMask |= VER_PRODUCT_TYPE;

                    VER_SET_CONDITION(ConditionMask,
                                      VER_PRODUCT_TYPE,
                                      VER_EQUAL
                                     );
                } else {
                    OsVersionInfoEx.wProductType = 0;
                }

                if(CurDecIncludesMask & DEC_INCLUDES_SUITEMASK) {

                    OsVersionInfoEx.wSuiteMask = SuiteMask;

                    TypeMask |= VER_SUITENAME;

                    VER_SET_CONDITION(ConditionMask,
                                      VER_SUITENAME,
                                      VER_AND
                                     );
                } else {
                    OsVersionInfoEx.wSuiteMask = 0;
                }

                //
                // Only call VerifyVersionInfo if one or more criteria were
                // supplied (otherwise, assume this TargetDecoration is applicable)
                //
                if(TypeMask) {

                    if(!VerifyVersionInfo(&OsVersionInfoEx, TypeMask, ConditionMask)) {
                        //
                        // TargetDecoration isn't applicable to current OS version.
                        //
                        continue;
                    }
                }
            }
        }

        //
        // If we get to here, we have an applicable TargetDecoration--see if
        // it's the best one we've seen thus far...
        //
        NewBestFound = FALSE;

        if((CurMajorVer > BestMajorVer) ||
           ((CurMajorVer == BestMajorVer) && (CurMinorVer > BestMinorVer))) {
            //
            // Newer version
            //
            NewBestFound = TRUE;

        } else if((CurMajorVer == BestMajorVer) && (CurMinorVer == BestMinorVer)) {
            //
            // Version is same as current best.  Is it as-specific or more so?
            // NOTE: we update on "as-specific" (i.e., equal) matches to catch
            // the case where our only applicable decoration is "NT".  In that
            // case, our best and current version is "0.0", and our masks are
            // both zero as well.
            //
            if(CurDecIncludesMask >= BestDecIncludesMask) {
                NewBestFound = TRUE;
            }
        }

        if(NewBestFound) {
            BestTargetDecoration = CurTargetDecoration;
            BestMajorVer = CurMajorVer;
            BestMinorVer = CurMinorVer;
            BestDecIncludesMask = CurDecIncludesMask;
        }
    }

    if(!BestTargetDecoration) {
        //
        // No applicable TargetDecoration was found.
        //
        return FALSE;
    }

    //
    // Construct the decorated section name by appending the TargetDecoration
    // to the models section name.
    //
    if(!(ModelsSectionName = InfGetField(Inf, MfgListLine, 1, NULL))) {
        //
        // Should never happen
        //
        MYASSERT(ModelsSectionName);
        return FALSE;
    }

    lstrcpyn(DecoratedModelsSection, ModelsSectionName, MAX_SECT_NAME_LEN);
    SectionNameLen = lstrlen(DecoratedModelsSection);

    //
    // Do we have enough space left for decoration + '.' + terminating NULL?
    //
    if((MAX_SECT_NAME_LEN - SectionNameLen) < (lstrlen(BestTargetDecoration) + 2)) {
        //
        // Decorated section name exceeds maximum length of a section name!
        //
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_ERROR,
            MSG_LOG_DEC_MODELS_SEC_TOO_LONG,
            NULL,
            ModelsSectionName,
            BestTargetDecoration,
            MAX_SECT_NAME_LEN
           );

        return FALSE;
    }

    DecoratedModelsSection[SectionNameLen++] = TEXT('.');
    lstrcpy(&(DecoratedModelsSection[SectionNameLen]), BestTargetDecoration);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\fileq.h ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    fileq.h

Abstract:

    Private header file for setup file queue routines.
    A setup file queue is a list of pending rename, delete,
    and copy operations.

Author:

    Ted Miller (tedm) 15-Feb-1995

Revision History:

    Jamie Hunter (jamiehun) 13-Jan-1998
        Added backup & un-windable copying
    Gabe Schaffer (t-gabes) 19-Jul-1998
        Added LogCotext to SP_FILE_QUEUE

--*/

//
// Declare this forward reference here so structures below can use it
// before it's defined.
//
struct _SP_FILE_QUEUE;
struct _SP_FILE_QUEUE_NODE;

//
// Define structure that describes a source media in use
// in a particular file queue.
//
typedef struct _SOURCE_MEDIA_INFO {

    struct _SOURCE_MEDIA_INFO *Next;

    //
    // String IDs for description and tagfile.
    //
    LONG Description;
    LONG DescriptionDisplayName; // case-sensitive form for display.

    LONG Tagfile;                // Tagfile & Cabfile would be the same string
    LONG Cabfile;                // unless an explicit cabfile has been given

    //
    // String ID for source root path
    //
    LONG SourceRootPath;

    //
    // Copy queue for this media.
    //
    struct _SP_FILE_QUEUE_NODE *CopyQueue;
    UINT CopyNodeCount;

    //
    // Flags for this source media descriptor
    //
    DWORD Flags;

} SOURCE_MEDIA_INFO, *PSOURCE_MEDIA_INFO;

//
// Define valid flags for SOURCE_MEDIA_INFO.Flags
//
#define SMI_FLAG_NO_SOURCE_ROOT_PATH            0x1
#define SMI_FLAG_USE_SVCPACK_SOURCE_ROOT_PATH   0x2
#define SMI_FLAG_USE_LOCAL_SOURCE_CAB           0x4

//
// Define structure that describes a catalog, used for signing
// and file verification.
//
typedef struct _SPQ_CATALOG_INFO {

    struct _SPQ_CATALOG_INFO *Next;

    //
    // String ID for original filename of the catalog file,
    // such as specified in CatalogFile= in the [Version] section
    // of an inf file.
    //
    // This field may be -1, which indicates no CatalogFile= line
    // was specified in the INF.
    //
    LONG CatalogFileFromInf;

    //
    // String ID for original filename of the catalog file specified by the
    // INF for an alternate platform (the alternate platform having been setup
    // by a call to SetupSetFileQueueAlternatePlatform).  This field is only
    // valid when the containing file queue has the FQF_USE_ALT_PLATFORM flag
    // set.
    //
    // This field may be -1, which indicates that no CatalogFile= line was
    // specified in the INF (or at least not one that can be used given the
    // currently active alternate platform parameters).
    //
    LONG AltCatalogFileFromInf;
    //
    // Also, maintain a temporary storage for the new alternate catalog string
    // ID to be used while we're processing the catalog list, retrieving the
    // platform-specific entries associated with each INF.  This is done so that
    // if we encounter an error part-way through (e.g, out-of-memory or couldn't
    // load INF), then we don't have to maintain a separate list in order to do
    // a rollback.
    //
    LONG AltCatalogFileFromInfPending;

    //
    // String ID for the full (source) path of the INF.
    //
    LONG InfFullPath;

    //
    // String ID for the source INF's original (simple) name (may be -1 if the
    // source INF's original name is the same as its current name.
    //
    LONG InfOriginalName;

    //
    // String ID for the INF's final resting place (i.e., its name in the INF
    // directory, unless it's been part of an alternate catalog install, in
    // which case it will be the same as InfFullPath).  This value will be -1
    // until the catalog node has been processed by _SetupVerifyQueuedCatalogs.
    // After that, its value will be equal to InfFullPath if the INF was in the
    // Inf directory in the first place, or was part of an alternate catalog
    // installation.  Otherwise, it'll be the string ID for the unique name we
    // used when copying the INF into the Inf directory.
    //
    LONG InfFinalPath;

#if 0
    //
    // Pointer to media descriptor for first file that caused this
    // catalog node to be enqueued. This gives a pretty good indicator
    // of which media we expect the catalog file to be on.
    //
    PSOURCE_MEDIA_INFO SourceMediaInfo;
#endif

    //
    // Error code indicating the cause of failure to validate the catalog.
    //
    DWORD VerificationFailureError;

    //
    // CATINFO_FLAG flags containing information about this catalog node such
    // as whether it is the 'primary device INF' for a device installation.
    //
    DWORD Flags;

    //
    // Full filepath of catalog file. This is the catalog file as
    // it's been installed on the system.
    //
    TCHAR CatalogFilenameOnSystem[MAX_PATH];

} SPQ_CATALOG_INFO, *PSPQ_CATALOG_INFO;

//
// Catalog node flags.
//
#define CATINFO_FLAG_PRIMARY_DEVICE_INF  0x00000001 // primary device INF for a
                                                    // device installation queue

#define CATINFO_FLAG_NEWLY_COPIED        0x00000002 // indicates whether INF/CAT
                                                    // were newly copied when
                                                    // this catalog node was
                                                    // verified.

//
// Define structure that describes a node in a file queue.
//
typedef struct _SP_FILE_QUEUE_NODE {

    struct _SP_FILE_QUEUE_NODE *Next;

    //
    // Operation: copy, delete, rename
    //
    UINT Operation;

    //
    // Copy:
    //
    // String ID for source root path
    // (such as F:\ or \\SERVER\SHARE\SUBDIR).
    //
    // Delete: unused
    // Rename: unused
    //
    LONG SourceRootPath;

    //
    // Copy:
    //
    // String ID for rest of the path (between the root and the filename).
    // Generally this is the directory specified for the source media
    // in [SourceDisksNames].
    //
    // Not always specified (-1 if not specified).
    //
    // Delete: unused
    //
    // Rename: source path of file to be renamed
    //
    LONG SourcePath;

    //
    // Copy: String ID for source filename (filename only, no path).
    // Delete: unused
    // Rename: source filename of file to be renamed. If not specified
    //         SourcePath contains complete full path of file.
    //
    LONG SourceFilename;

    //
    // Copy: String ID for the target directory (no filename).
    // Delete: part 1 of the full path of the file to delete (ie, path part)
    // Rename: Target directory for file (ie, rename is actually a move).
    //         If not specified rename is a rename only (TargetFilename
    //         contains the new filename).
    //
    LONG TargetDirectory;

    //
    // Copy: String ID for the target filename (filename only, no path),
    // Delete: part 2 of the full path of the file to delete (ie, file part)
    //         If not specified then TargetDirectory contains complete full path.
    // Rename: supplies new filename for rename/move operation. Filename part only.
    //
    LONG TargetFilename;

    //
    //  Copy  : String ID for Security Descriptor information
    //  Delete: Unused
    //  Rename: Unused
    LONG SecurityDesc;


    //
    // Copy: Information about the source media on which this file can be found.
    // Delete: unused
    // Rename: unused
    //
    PSOURCE_MEDIA_INFO SourceMediaInfo;

    //
    // Style flags for file operation
    //
    DWORD StyleFlags;

    //
    // Internal-use flags: In-use disposition, etc.
    //
    UINT InternalFlags;

    //
    // Pointer to catalog info for this file, used for file signing.
    // May be NULL.
    //
    PSPQ_CATALOG_INFO CatalogInfo;

} SP_FILE_QUEUE_NODE, *PSP_FILE_QUEUE_NODE;

//
// Internal flags.
//
#define INUSE_IN_USE            0x00000001  // file was in use
#define INUSE_INF_WANTS_REBOOT  0x00000002  // file was in use and inf file
                                            // want reboot if this file was in use
#define IQF_PROCESSED           0x00000004  // queue node was already processed
#define IQF_DELAYED_DELETE_OK   0x00000008  // Use delayed delete if delete fails
#define IQF_MATCH               0x00000010  // Node matches current file in cabinet
#define IQF_LAST_MATCH          0x00000020  // Node is last in chain of matches
#define IQF_FROM_BAD_OEM_INF    0x00000040  // Copynode from invalid (w.r.t. codesigning) OEM INF
#define IQF_ALLOW_UNSIGNED      0x00000080  // node is unsigned but allow installation
                                            //   (w.r.t. system file protection)
#define IQF_TARGET_PROTECTED    0x00000100  // node is replacing a system file

#define ST_SCE_SET 0
#define ST_SCE_DELETE 1
#define ST_SCE_RENAME 2
#define ST_SCE_UNWIND 3
#define ST_SCE_SERVICES 4


//
// Define structure describing a setup file operation queue.
//
typedef struct _SP_FILE_QUEUE {
    //
    // We'll maintain separate lists internally for each type
    // of queued operation. Each source media has its own copy queue.
    //
    //
    PSP_FILE_QUEUE_NODE BackupQueue;
    PSP_FILE_QUEUE_NODE DeleteQueue;
    PSP_FILE_QUEUE_NODE RenameQueue;

    //
    // Number of nodes in the various queues.
    //
    UINT CopyNodeCount;
    UINT DeleteNodeCount;
    UINT RenameNodeCount;
    UINT BackupNodeCount;

    //
    // Pointer to first source media descriptor.
    //
    PSOURCE_MEDIA_INFO SourceMediaList;

    //
    // Number of source media descriptors.
    //
    UINT SourceMediaCount;

    //
    // Pointer to head of linked list of catalog descriptor structures.
    // There will be one item in this list for each catalog file
    // referenced in any file's (copy) queue node.
    //
    PSPQ_CATALOG_INFO CatalogList;

    //
    // Specifies what driver signing policy was in effect when this file queue
    // was created.  This will have been retrieved from the registry, or from
    // the DS, if applicable.  This field can take one of three values:
    //
    //   DRIVERSIGN_NONE    -  silently succeed installation of unsigned/
    //                         incorrectly-signed files.  A PSS log entry will
    //                         be generated, however (as it will for all 3 types)
    //   DRIVERSIGN_WARNING -  warn the user, but let them choose whether or not
    //                         they still want to install the problematic file
    //   DRIVERSIGN_BLOCKING - do not allow the file to be installed
    //
    // Note:  the use of the term "file" above refers generically to both
    // individual files and packages (i.e., INF/CAT/driver file combinations)
    //
    DWORD DriverSigningPolicy;

    //
    // Specifies the window handle that owns any UI dealing with driver signing.
    // This is filled in based on the Owner argument passed into
    // _SetupVerifyQueuedCatalogs.
    //
    HWND hWndDriverSigningUi;

    //
    // If this queue has been marked as a device install queue, store the
    // description of the device being installed in case we need to popup a
    // digital signature verification failure dialog.
    //
    // (This value may be -1)
    //
    LONG DeviceDescStringId;

    //
    // Structure that contains alternate platform information that was
    // associated with the queue via SetupSetFileQueueAlternatePlatform.  This
    // embedded structure is only valid if the FQF_USE_ALT_PLATFORM flag is set.
    //
    SP_ALTPLATFORM_INFO_V2 AltPlatformInfo;

    //
    // String ID of override catalog file to use (typically, goes hand-in-hand
    // with an AltPlatformInfo).  If no catalog override is in effect, this
    // string ID will be -1.
    //
    LONG AltCatalogFile;

    //
    // Pointer to platform info structure to be used for digital signature
    // verification when there is no AltPlatformInfo associated with this file
    // queue.  This is used when certclas.inf identifies a range of valid OS
    // versions to be used when validating drivers of a particular device setup
    // class.  This field may be NULL, indicating that certclas.inf didn't
    // specify such an override, or that the queue isn't related to device
    // installation at all.
    //
    // This pointer must be freed when the structure is destroyed.
    //
    PSP_ALTPLATFORM_INFO_V2 ValidationPlatform;

    //
    // String table that all data structures associated with
    // this queue make use of.
    //
    // (NOTE: Since there is no locking mechanism on the enclosing
    // SP_FILE_QUEUE structure, this StringTable must handle its own
    // synchronization.  Therefore, this string table contains 'live'
    // locks, and must be accessed with the public versions (in spapip.h)
    // of the StringTable* APIs.)
    //
    PVOID StringTable;

    //
    // Maintain a lock refcount for user-supplied queues contained in device
    // information elements.  This ensures that the queue can't be deleted as
    // long as its being referenced in at least one device installation parameter
    // block.
    //
    DWORD LockRefCount;

    //
    // Queue flags.
    //
    DWORD Flags;

    //
    // SIS-related fields.
    //
    HANDLE SisSourceHandle;
    PCTSTR SisSourceDirectory;

    //
    // Backup and unwind fields
    //
    LONG BackupInfID;               // stringID (relative to StringTable) of Inf file associated with backup
    LONG BackupInstanceID;
    LONG BackupDisplayNameID;
    LONG BackupDeviceInstanceID;
    LONG BackupDeviceDescID;
    LONG BackupMfgID;
    LONG BackupProviderNameID;
    LONG RestorePathID;             // restore-point
    PVOID TargetLookupTable;        // all entries here have associated data
    PSP_UNWIND_NODE UnwindQueue;    // order of restore and file info
    PSP_DELAYMOVE_NODE DelayMoveQueue;    // order of delayed renames
    PSP_DELAYMOVE_NODE DelayMoveQueueTail; // last of delayed renames

    //
    // Signature used for a primitive form of validation.
    //
    DWORD Signature;

    //
    // Pointer to log context for error logging
    //
    PSETUP_LOG_CONTEXT LogContext;

    //
    // crypto context handle acquired during digital signature verification
    // (starts out as NULL, if non-NULL when freeing queue, must release via
    // CryptCATAdminReleaseContext)
    //
    HCATADMIN hCatAdmin;

    //
    // handle to bad driver database acquired during check for blocked driver
    // (starts out as NULL, if non-NULL when freeing queue, must release via
    // SdbReleaseDatabase)
    //
    HSDB hSDBDrvMain;

} SP_FILE_QUEUE, *PSP_FILE_QUEUE;



#define SP_FILE_QUEUE_SIG   0xc78e1098

//
// Internal-use queue commit routine.
//
BOOL
_SetupCommitFileQueue(
    IN HWND     Owner,         OPTIONAL
    IN HSPFILEQ QueueHandle,
    IN PVOID    MsgHandler,
    IN PVOID    Context,
    IN BOOL     IsMsgHandlerNativeCharWidth
    );
//
// Internal-use, add a single copy to the queue
//
BOOL
pSetupQueueSingleCopy(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,  OPTIONAL
    IN PCTSTR   SectionName,    OPTIONAL
    IN PCTSTR   SourceRootPath,
    IN PCTSTR   SourceFilename,
    IN PCTSTR   TargetFilename,
    IN DWORD    CopyStyle,
    IN PCTSTR   SecurityDescriptor,
    IN PCTSTR   CacheName
    );

//
// Internal-use
//

PTSTR
pSetupFormFullPath(
    IN PVOID  StringTable,
    IN LONG   PathPart1,
    IN LONG   PathPart2,    OPTIONAL
    IN LONG   PathPart3     OPTIONAL
    );

DWORD
pGetInfOriginalNameAndCatalogFile(
    IN  PLOADED_INF             Inf,                     OPTIONAL
    IN  LPCTSTR                 CurrentName,             OPTIONAL
    OUT PBOOL                   DifferentName,           OPTIONAL
    OUT LPTSTR                  OriginalName,            OPTIONAL
    IN  DWORD                   OriginalNameSize,
    OUT LPTSTR                  OriginalCatalogName,     OPTIONAL
    IN  DWORD                   OriginalCatalogNameSize,
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo          OPTIONAL
    );


DWORD
_SetupVerifyQueuedCatalogs(
    IN  HWND           Owner,
    IN  PSP_FILE_QUEUE Queue,
    IN  DWORD          Flags,
    OUT PTSTR          DeviceInfFinalName,  OPTIONAL
    OUT PBOOL          DeviceInfNewlyCopied OPTIONAL
    );

BOOL
pSetupProtectedRenamesFlag(
    BOOL bSet
    );


#ifdef UNICODE

DWORD
pSetupCallSCE(
    IN DWORD Operation,
    IN PCWSTR FullName,
    IN PSP_FILE_QUEUE Queue,
    IN PCWSTR String1,
    IN DWORD Index1,
    IN PSECURITY_DESCRIPTOR SecDesc  OPTIONAL
    );

#endif





#define VERCAT_INSTALL_INF_AND_CAT          0x00000001
#define VERCAT_NO_PROMPT_ON_ERROR           0x00000002
#define VERCAT_PRIMARY_DEVICE_INF_FROM_INET 0x00000004


#define FILEOP_INTERNAL_FAILED              ((UINT)(-1)) // not a valid fileop, GetLastError has status
#define FILEOP_RETURN_STATUS                ((UINT)(-2)) // convert error to return value
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\dll.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    dll.c

Abstract:

    Initialization/de-initialization of setupapi.dll

Author:

    Lonny McMichael (lonnym) 10-May-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef ANSI_SETUPAPI

#include <locale.h>

#endif

HANDLE MyDllModuleHandle;

OSVERSIONINFOEX OSVersionInfo;

//
// TLS Data
//
DWORD TlsIndex = (DWORD)(-1);           // no data
PSETUP_TLS pLastTlsAlloc = NULL;        // for cleanup


//
// Static strings we retreive once. Listed in order they are retrieved
//
PCTSTR OsLoaderRelativePath = NULL;     // (can be NULL)
PCTSTR OsSystemPartitionRoot = NULL;    // eg: \\?\GLOBALROOT\Device\HarddiskVolume1
PCTSTR ProcessFileName = NULL;          // Filename of app calling setupapi
PCTSTR WindowsDirectory = NULL;         // %windir%, GetSystemWindowsDirectory()
PCTSTR InfDirectory = NULL;             // %windir%\INF
PCTSTR System16Directory = NULL;        // %windir%\SYSTEM
PCTSTR LastGoodDirectory = NULL;        // %windir%\LastGood
PCTSTR SystemDirectory = NULL;          // <sys>, %windir%\SYSTEM or %windir%\System32
PCTSTR WindowsBackupDirectory = NULL;   // <sys>\ReinstallBackups
PCTSTR ConfigDirectory = NULL;          // <sys>\CONFIG
PCTSTR DriversDirectory = NULL;         // <sys>\DRIVERS
PCTSTR SystemSourcePath = NULL;         // location system installed from
PCTSTR ServicePackSourcePath = NULL;    // location service pack installed from (can be NULL)
PCTSTR DriverCacheSourcePath = NULL;    // location of driver cache (can be NULL)
BOOL   GuiSetupInProgress = FALSE;      // set if we determine we're in GUI setup
PCTSTR InfSearchPaths = NULL;           // Multi-sz list of fully-qualified directories where INFs are to be searched for.
#ifndef _WIN64
BOOL   IsWow64 = FALSE;                 // set if we're running under WOW64
#endif
CRITICAL_SECTION InitMutex;             // for one-time initializations
CRITICAL_SECTION ImageHlpMutex;         // for dealing with IMAGEHLP library
CRITICAL_SECTION DelayedComponentMutex; // for any delayed initialization of certain components
CRITICAL_SECTION PlatformPathOverrideCritSect;
CRITICAL_SECTION LogUseCountCs;
CRITICAL_SECTION MruCritSect;
CRITICAL_SECTION NetConnectionListCritSect;
BOOL   InInitialization = FALSE;
DWORD  DoneInitialization = 0;          // bitmask of items we've initialized
DWORD  DoneCleanup = 0;                 // bitmask of items we've cleaned up
DWORD  DoneComponentInitialize = 0;     // bitmask of components we've done delayed initialization
DWORD  FailedComponentInitialize = 0;   // bitmask of components we've failed initialization
HANDLE GlobalNoDriverPromptsEventFlag = NULL;  // event that acts as a flag during setup
BOOL DoneCriticalSections = FALSE;

#ifdef UNICODE
DWORD Seed;
#endif

#define DONEINIT_TLS          (0x0000001)
#define DONEINIT_UTILS        (0x0000002)
#define DONEINIT_MEM          (0x0000004)
#define DONEINIT_CTRL         (0x0000008)
#define DONEINIT_FUSION       (0x0000010)
#define DONEINIT_STUBS        (0x0000020)
#define DONEINIT_COMMON       (0x0000040)
#define DONEINIT_DIAMOND      (0x0000080)
#define DONEINIT_LOGGING      (0x0000100)
#define DONEINIT_CFGMGR32     (0x0000200)
#define DONEINIT_COMPLETE     (0x8000000)



//
// various control flags
//
DWORD GlobalSetupFlags = 0;
DWORD GlobalSetupFlagsOverride = PSPGF_MINIMAL_EMBEDDED | PSPGF_NO_SCE_EMBEDDED;     // flags that cannot be modified

//
// Declare a (non-CONST) array of strings that specifies what lines to look for
// in an INF's [ControlFlags] section when determining whether a particular device
// ID should be excluded.  These lines are of the form "ExcludeFromSelect[.<suffix>]",
// where <suffix> is determined and filled in during process attach as an optimization.
//
// The max string length (including NULL) is 32, and there can be a maximum of 3
// such strings.  E.g.: ExcludeFromSelect, ExcludeFromSelect.NT, ExcludeFromSelect.NTAlpha
//
// WARNING!! Be very careful when mucking with the order/number of these entries.  Check
// the assumptions made in devdrv.c!pSetupShouldDevBeExcluded.
//
TCHAR pszExcludeFromSelectList[3][32] = { INFSTR_KEY_EXCLUDEFROMSELECT,
                                          INFSTR_KEY_EXCLUDEFROMSELECT,
                                          INFSTR_KEY_EXCLUDEFROMSELECT
                                        };

DWORD ExcludeFromSelectListUb;  // contains the number of strings in the above list (2 or 3).


#ifndef _WIN64
BOOL
GetIsWow64 (
    VOID
    );
#endif

BOOL
CommonProcessAttach(
    IN BOOL Attach
    );

PCTSTR
GetDriverCacheSourcePath(
    VOID
    );

PCTSTR
pSetupGetOsLoaderPath(
    VOID
    );

PCTSTR
pSetupGetSystemPartitionRoot(
    VOID
    );

PCTSTR
pSetupGetProcessPath(
    VOID
    );

BOOL
pGetGuiSetupInProgress(
    VOID
    );


BOOL
CfgmgrEntry(
    PVOID hModule,
    ULONG Reason,
    PCONTEXT pContext
    );


BOOL
ThreadTlsInitialize(
    IN BOOL Init
    );

VOID
ThreadTlsCleanup(
    );

BOOL
IsNoDriverPrompts(
    VOID
    );

DWORD
GetEmbeddedFlags(
    VOID
    );

DWORD
GetSeed(
    VOID
    );


BOOL
ProcessAttach(
    IN HANDLE DllHandle,
    IN DWORD  Reason,
    IN LPVOID Reserved
    )
/*++

Routine Description:

    Handles DLL_PROCESS_ATTACH in a way that can be unwound

Arguments:

    Reserved = 'Reserved' value passed into DllMain

Return Value:

    TRUE if processed initialized
    FALSE if partially/not initialized

--*/
{
    BOOL b = FALSE;

    if(DoneCleanup) {
        //
        // if we get here, this means someone lied to us
        //
        MYASSERT(!DoneCleanup);
        DoneInitialization &= ~DoneCleanup;
        DoneCleanup = 0;
    }
    //
    // nothing should already be initialized
    //
    MYASSERT(!DoneInitialization);

    try {
        MyDllModuleHandle = DllHandle;

        //
        // initialize TLS before anything else - hence why we use LocalAlloc
        //
        TlsIndex = TlsAlloc();
        if (TlsIndex!=(DWORD)(-1)) {
            DoneInitialization |= DONEINIT_TLS;
        } else {
            leave;
        }

#ifndef UNICODE
        //
        // Initialize the C runtime locale (ANSI version of setupapi.dll only)
        //
        setlocale(LC_ALL,"");
#endif

        //
        // always do pSetupInitializeUtils and MemoryInitializeEx first
        // (pSetupInitializeUtils sets up memory functions)
        //
        if(pSetupInitializeUtils()) {
            DoneInitialization |= DONEINIT_UTILS;
        } else {
            leave;
        }
        if(MemoryInitializeEx(TRUE)) {
            DoneInitialization |= DONEINIT_MEM;
        } else {
            leave;
        }
#ifdef FUSIONAWARE
        if(spFusionInitialize()) {
            DoneInitialization |= DONEINIT_FUSION;
        }
#else
        InitCommonControls();
        DoneInitialization |= DONEINIT_CTRL;
#endif
        //
        // Dynamically load proc addresses of NT-specific APIs
        // must be before CommonProcessAttach etc
        // however memory must be initialized
        //
        InitializeStubFnPtrs();
        DoneInitialization |= DONEINIT_STUBS;
        //
        // most of the remaining initialization
        //
        if(CommonProcessAttach(TRUE)) {
            DoneInitialization |= DONEINIT_COMMON;
        } else {
            leave;
        }
        if(DiamondProcessAttach(TRUE)) {
            DoneInitialization |= DONEINIT_DIAMOND;
        } else {
            leave;
        }
        if(InitializeContextLogging(TRUE)) {
            DoneInitialization |= DONEINIT_LOGGING;
        } else {
            leave;
        }

#ifdef UNICODE
        //
        // Since we've incorporated cfgmgr32 into setupapi, we need
        // to make sure it gets initialized just like it did when it was
        // its own DLL. - must do AFTER everything else
        //
        if(CfgmgrEntry(DllHandle, Reason, Reserved)) {
            DoneInitialization |= DONEINIT_CFGMGR32;
        }
#endif
        DoneInitialization |= DONEINIT_COMPLETE;
        b = TRUE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    return b;
}

void
DestroySetupTlsData(
    )
/*++

Routine Description:

    Destroy all TLS data from every thread
    calling any cleanup routines as required

Arguments:

    NONE

Return Value:

    NONE

--*/
{
    PSETUP_TLS pTLS;

    if(pLastTlsAlloc) {
        pLastTlsAlloc->Prev->Next = NULL;
        while(pLastTlsAlloc) {
            pTLS = pLastTlsAlloc;
            pLastTlsAlloc = pTLS->Next;
            TlsSetValue(TlsIndex,pTLS); // switch specific data into this thread
            ThreadTlsCleanup();
            LocalFree(pTLS);
        }
    }
    TlsSetValue(TlsIndex,NULL); // don't leave invalid pointer hanging around
}

void
ProcessDetach(
    IN HANDLE DllHandle,
    IN DWORD  Reason,
    IN LPVOID Reserved
    )
/*++

Routine Description:

    Handles DLL_PROCESS_DETACH

Arguments:

    Reserved = 'Reserved' value passed into DllMain
        Which is actually TRUE for Process Exit, FALSE otherwise

Return Value:

    None
--*/
{
    DWORD ToCleanup = DoneInitialization & ~ DoneCleanup;
    if(!ToCleanup) {
        //
        // nothing to cleanup
        //
        return;
    }
    try {
        if (ToCleanup & DONEINIT_COMPLETE) {
            DoneCleanup |= DONEINIT_COMPLETE;
        }

        if(DoneInitialization & DONEINIT_TLS) {
            //
            // cleanup all remaining Tls data
            //
            if(!Reserved) {
                //
                // only do this for FreeLibrary/ failed LoadLibrary
                //
                DestroySetupTlsData();
            }
        }
        if(ToCleanup & DONEINIT_TLS) {
            //
            // destroy our allocated TLS index
            // do this now so that we don't try allocating
            // TLS storage during this cleanup
            //
            TlsFree(TlsIndex);
            TlsIndex = (DWORD)(-1);
            DoneCleanup |= DONEINIT_TLS;
        }

        //
        // do things generally in reverse order of ProcessAttach
        //

#ifdef UNICODE
        // Since we've incorporated cfgmgr32 into setupapi, we need
        // to make sure it gets uninitialized just like it did when it was
        // its own DLL. - must do BEFORE anything else
        //
        if(ToCleanup & DONEINIT_CFGMGR32) {
            CfgmgrEntry(DllHandle, Reason, Reserved);
            DoneCleanup |= DONEINIT_CFGMGR32;
        }
#endif

        if(ToCleanup & DONEINIT_DIAMOND) {
            DiamondProcessAttach(FALSE);
            DoneCleanup |= DONEINIT_DIAMOND;
        }

#if 0   // see ComponentCleanup at end of file
        ComponentCleanup(DoneComponentInitialize);
#endif
#ifdef FUSIONAWARE
        if(ToCleanup & DONEINIT_FUSION) {
            //
            // Fusion cleanup
            // only do full if this is FreeLibrary (or failed attach)
            //
            spFusionUninitialize((Reserved == NULL) ? TRUE : FALSE);
            DoneCleanup |= DONEINIT_FUSION;
        }
#endif

        if(ToCleanup & DONEINIT_COMMON) {
            //
            // Most of remaining cleanup
            //
            CommonProcessAttach(FALSE);
            DoneCleanup |= DONEINIT_COMMON;
        }
        if(ToCleanup & DONEINIT_STUBS) {
            //
            // Clean up stub functions
            //
            CleanUpStubFns();
            DoneCleanup |= DONEINIT_STUBS;
        }
        if(ToCleanup & DONEINIT_LOGGING) {
            //
            // Clean up context logging
            //
            InitializeContextLogging(FALSE);
            DoneCleanup |= DONEINIT_LOGGING;
        }
        //
        // *THESE MUST ALWAYS BE* very last things, in this order
        //
        if(ToCleanup & DONEINIT_MEM) {
            //
            // Clean up context logging
            //
            MemoryInitializeEx(FALSE);
            DoneCleanup |= DONEINIT_MEM;
        }
        if(ToCleanup & DONEINIT_UTILS) {
            //
            // Clean up context logging
            //
            pSetupUninitializeUtils();
            DoneCleanup |= DONEINIT_UTILS;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
    }
}

//
// Called by CRT when _DllMainCRTStartup is the DLL entry point
//
BOOL
WINAPI
DllMain(
    IN HANDLE DllHandle,
    IN DWORD  Reason,
    IN LPVOID Reserved
    )
{
    BOOL b;

    InInitialization = TRUE;

    b = TRUE;

    switch(Reason) {

    case DLL_PROCESS_ATTACH:
        b = ProcessAttach(DllHandle,Reason,Reserved);
        if(!b) {
            ProcessDetach(DllHandle,DLL_THREAD_DETACH,NULL);
        }
        break;

    case DLL_THREAD_ATTACH:
        //
        // don't do anything here
        // any TLS must be done on demand
        // via SetupGetTlsData
        //
        break;

    case DLL_PROCESS_DETACH:
        //
        // any TLS cleanup must be done in ThreadTlsCleanup
        //
        ProcessDetach(DllHandle,Reason,Reserved);
        break;

    case DLL_THREAD_DETACH:
        ThreadTlsInitialize(FALSE);
        break;
    }

    InInitialization = FALSE;
    return(b);
}

PSETUP_TLS
SetupGetTlsData(
    )
/*++

Routine Description:

    Called to obtain a pointer to TLS data

Arguments:

    NONE

Return Value:

    Pointer to TLS data, or NULL

--*/
{
    PSETUP_TLS pTLS;

    if (TlsIndex==(DWORD)(-1)) {
        return NULL;
    }
    pTLS = (PSETUP_TLS)TlsGetValue(TlsIndex);
    if (!pTLS) {
        ThreadTlsInitialize(TRUE);
        pTLS = (PSETUP_TLS)TlsGetValue(TlsIndex);
    }
    return pTLS;
}

VOID
ThreadTlsCleanup(
    )
/*++

Routine Description:

    Called to uninitialize some pTLS data
    might be a different thread to initialize
    but SetupAPI TLS data will have been switched in

Arguments:

    pTLS - data to cleanup

Return Value:

    NONE.

--*/
{
    DiamondTlsInit(FALSE);
    ContextLoggingTlsInit(FALSE);
}

BOOL
ThreadTlsUnlink(
    IN PSETUP_TLS pTLS
    )
{
    BOOL b;
    try {
        EnterCriticalSection(&InitMutex);
        if(pTLS->Next == pTLS->Prev) {
            pLastTlsAlloc = NULL;
        } else {
            pTLS->Prev->Next = pTLS->Next;
            pTLS->Next->Prev = pTLS->Prev;
            pLastTlsAlloc = pTLS->Prev; // anything but pTLS
        }
        LeaveCriticalSection(&InitMutex);
        b = TRUE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    return b;
}

PSETUP_TLS
ThreadTlsCreate(
    )
/*++

Routine Description:

    Called to create pTLS data for this thread

Arguments:

    NONE

Return Value:

    per-thread data, or NULL on failure

--*/
{
    BOOL b;
    PSETUP_TLS pTLS;
    if (TlsIndex==(DWORD)(-1)) {
        return NULL;
    }
    pTLS = (PSETUP_TLS)LocalAlloc(LMEM_ZEROINIT,sizeof(SETUP_TLS));
    if(!pTLS) {
        return NULL;
    }
    b = TlsSetValue(TlsIndex,pTLS);
    if(!b) {
        LocalFree(pTLS);
        return NULL;
    }
    try {
        EnterCriticalSection(&InitMutex);
        if(pLastTlsAlloc) {
            pTLS->Prev = pLastTlsAlloc;
            pTLS->Next = pTLS->Prev->Next;
            pTLS->Prev->Next = pTLS;
            pTLS->Next->Prev = pTLS;
        } else {
            pTLS->Next = pTLS;
            pTLS->Prev = pTLS;
        }
        pLastTlsAlloc = pTLS;
        LeaveCriticalSection(&InitMutex);
        b = TRUE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if(!b) {
        LocalFree(pTLS);
        TlsSetValue(TlsIndex,NULL);
        return NULL;
    }
    //
    // TLS data initialized, now specific Init routines
    //
    b = DiamondTlsInit(TRUE);
    if(b) {
        b = ContextLoggingTlsInit(TRUE);
        if(b) {
            //
            // all done ok
            //
            return pTLS;
        }
        //
        // cleanup DiamondTlsInit
        //
        DiamondTlsInit(FALSE);
    }
    //
    // cleanup memory
    //
    TlsSetValue(TlsIndex,NULL);
    if(ThreadTlsUnlink(pTLS)) {
        LocalFree(pTLS);
    }
    return NULL;
}

BOOL
ThreadTlsInitialize(
    IN BOOL Init
    )
/*++

Routine Description:

    Called with TRUE to initialize TLS, if FALSE, to uninitialize

Arguments:

    Init - indicates if we are to initialize vs uninitialize

Return Value:

    NONE.

--*/
{
    BOOL b = FALSE;
    PSETUP_TLS pTLS = NULL;
    if (TlsIndex!=(DWORD)(-1)) {
        if (Init) {
            pTLS = ThreadTlsCreate();
            b = pTLS ? TRUE : FALSE;
        } else {
            pTLS = (PSETUP_TLS)TlsGetValue(TlsIndex);
            if(pTLS) {
                ThreadTlsCleanup();
                TlsSetValue(TlsIndex,NULL);
                if(ThreadTlsUnlink(pTLS)) {
                    LocalFree(pTLS);
                }
            }
            b = TRUE;
        }
    }
    return b;
}

BOOL
IsInteractiveWindowStation(
    )
/*++

Routine Description:

    Determine if we are running on an interactive station vs non-interactive station (i.e., service)

Arguments:

    none

Return Value:

    True if interactive

--*/
{
    HWINSTA winsta;
    USEROBJECTFLAGS flags;
    BOOL interactive = TRUE; // true unless we determine otherwise
    DWORD lenNeeded;

    winsta = GetProcessWindowStation();
    if(!winsta) {
        return interactive;
    }
    if(GetUserObjectInformation(winsta,UOI_FLAGS,&flags,sizeof(flags),&lenNeeded)) {
        interactive = (flags.dwFlags & WSF_VISIBLE) ? TRUE : FALSE;
    }
    //
    // don't call CLoseWindowStation
    //
    return interactive;
}

BOOL
CommonProcessAttach(
    IN BOOL Attach
    )
{
    BOOL b;
    TCHAR Buffer[MAX_PATH+32];
    PTCHAR p;
    UINT u;

    b = !Attach;

    if(Attach) {

        //
        // remaining critical sections
        //
        try {
            InitializeCriticalSection(&InitMutex);
            InitializeCriticalSection(&ImageHlpMutex);
            InitializeCriticalSection(&DelayedComponentMutex);
            InitializeCriticalSection(&PlatformPathOverrideCritSect);
            InitializeCriticalSection(&LogUseCountCs);
            InitializeCriticalSection(&MruCritSect);
            InitializeCriticalSection(&NetConnectionListCritSect);
            DoneCriticalSections = TRUE;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // DoneCriticalSections remains FALSE
            //
        }
        if(!DoneCriticalSections) {
            return FALSE;
        }
        try {

#ifndef _WIN64
            IsWow64 = GetIsWow64();
#endif
            //
            // flag indicating we're running in context of GUI setup
            //
            GuiSetupInProgress = pGetGuiSetupInProgress();
            //
            // determine if we're interactive or not
            //
            if(!IsInteractiveWindowStation()) {
                GlobalSetupFlagsOverride |= PSPGF_NONINTERACTIVE;   // don't allow this to be changed
                GlobalSetupFlags |= PSPGF_NONINTERACTIVE;           // actual value
            }
            if(IsNoDriverPrompts()) {
                GlobalSetupFlagsOverride |= PSPGF_UNATTENDED_SETUP; // don't allow this to be changed
                GlobalSetupFlags |= PSPGF_UNATTENDED_SETUP;         // actual value
            }

            GlobalSetupFlags |= GetEmbeddedFlags();

#ifdef UNICODE
            Seed = GetSeed();
#endif

            pSetupInitNetConnectionList(TRUE);
            pSetupInitPlatformPathOverrideSupport(TRUE);
            OsLoaderRelativePath = pSetupGetOsLoaderPath();         // ok to fail
            OsSystemPartitionRoot = pSetupGetSystemPartitionRoot(); // ok to fail

            //
            // Fill in system and windows directories.
            //
            if ((ProcessFileName = pSetupGetProcessPath()) == NULL) {
                goto cleanAll;
            }

            //
            // determine %windir%
            //
            if(((u = GetSystemWindowsDirectory(Buffer,MAX_PATH)) == 0) || u>MAX_PATH) {
                goto cleanAll;
            }
            p = Buffer + u; // offset past directory to do all the sub-directories

            //
            // %windir% ==> WindowsDirectory
            //
            if((WindowsDirectory = DuplicateString(Buffer)) == NULL) {
                goto cleanAll;
            }

            //
            // %windir%\INF ==> InfDirectory
            //
            *p = 0;
            if(!pSetupConcatenatePaths(Buffer,TEXT("INF"),MAX_PATH,NULL)
               || ((InfDirectory = DuplicateString(Buffer)) == NULL)) {
                goto cleanAll;
            }

            //
            // %windir%\SYSTEM ==> System16Directory
            //
            *p = 0;
            if(!pSetupConcatenatePaths(Buffer,TEXT("SYSTEM"),MAX_PATH,NULL)
               || ((System16Directory = DuplicateString(Buffer))==NULL)) {
                goto cleanAll;
            }

            //
            // %windir%\LastGood ==> LastGoodDirectory
            //
            *p = 0;
            if(!pSetupConcatenatePaths(Buffer,SP_LASTGOOD_NAME,MAX_PATH,NULL)
               || ((LastGoodDirectory = DuplicateString(Buffer))==NULL)) {
                goto cleanAll;
            }

            //
            // determine system directory
            //
            if(((u = GetSystemDirectory(Buffer,MAX_PATH)) == 0) || u>MAX_PATH) {
                goto cleanAll;
            }
            p = Buffer + u; // offset past directory to do all the sub-directories

            //
            // <sys> ==> SystemDirectory (%windir%\System or %windir%\System32)
            //
            if((SystemDirectory = DuplicateString(Buffer)) == NULL) {
                goto cleanAll;
            }

            //
            // <sys>\ReinstallBackups ==> WindowsBackupDirectory
            //
            *p = 0;
            if(!pSetupConcatenatePaths(Buffer,TEXT("ReinstallBackups"),MAX_PATH,NULL)
               || ((WindowsBackupDirectory = DuplicateString(Buffer))==NULL)) {
                goto cleanAll;
            }

            //
            // <sys>\CONFIG ==> ConfigDirectory
            //
            *p = 0;
            if(!pSetupConcatenatePaths(Buffer,TEXT("CONFIG"),MAX_PATH,NULL)
               || ((ConfigDirectory = DuplicateString(Buffer))==NULL)) {
                goto cleanAll;
            }

            //
            // <sys>\DRIVERS ==> DriversDirectory
            //
            *p = 0;
            if(!pSetupConcatenatePaths(Buffer,TEXT("DRIVERS"),MAX_PATH,NULL)
               || ((DriversDirectory = DuplicateString(Buffer))==NULL)) {
                goto cleanAll;
            }

            //
            // location system installed from
            //
            if((SystemSourcePath = GetSystemSourcePath())==NULL) {
                goto cleanAll;
            }

            //
            // location service pack installed from (may be NULL)
            //
            ServicePackSourcePath = GetServicePackSourcePath();
            //
            // location of driver cache (may be NULL)
            //
            DriverCacheSourcePath = GetDriverCacheSourcePath();

            //
            // determine driver search path
            //
            if((InfSearchPaths = AllocAndReturnDriverSearchList(INFINFO_INF_PATH_LIST_SEARCH))==NULL) {
                goto cleanAll;
            }

            //
            // note that InitMiniIconList, InitDrvSearchInProgressList, and
            // InitDrvSignPolicyList need to be explicitly cleaned up on failure
            //

            //
            // initialize mini icons
            //
            if(!InitMiniIconList()) {
                goto cleanAll;
            }

            //
            // allows aborting of search
            //
            if(!InitDrvSearchInProgressList()) {
                DestroyMiniIconList();
                goto cleanAll;
            }

            //
            // global list of device setup classes subject to driver signing policy
            //
            if(!InitDrvSignPolicyList()) {
                DestroyMiniIconList();
                DestroyDrvSearchInProgressList();
                goto cleanAll;
            }

            //
            // common version initialization
            //
            ZeroMemory(&OSVersionInfo,sizeof(OSVersionInfo));
            OSVersionInfo.dwOSVersionInfoSize = sizeof(OSVersionInfo);
            if(!GetVersionEx((LPOSVERSIONINFO)&OSVersionInfo)) {
                OSVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
                if(!GetVersionEx((LPOSVERSIONINFO)&OSVersionInfo)) {
                    //
                    // should never get here
                    //
                    MYASSERT(FALSE);
                    DestroyMiniIconList();
                    DestroyDrvSearchInProgressList();
                    DestroyDrvSignPolicyList();
                    goto cleanAll;
                }
            }

            //
            // Fill in our ExcludeFromSelect string list which
            // we pre-compute as an optimization.
            //
            if(OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
                lstrcat(pszExcludeFromSelectList[1],
                        pszNtSuffix
                       );
                lstrcat(pszExcludeFromSelectList[2],
                        pszNtPlatformSuffix
                       );
                ExcludeFromSelectListUb = 3;
            } else {
                lstrcat(pszExcludeFromSelectList[1],
                        pszWinSuffix
                       );
                ExcludeFromSelectListUb = 2;
            }
            //
            // Now lower-case all the strings in this list, so that it
            // doesn't have to be done at each string table lookup.
            //
            for(u = 0; u < ExcludeFromSelectListUb; u++) {
                CharLower(pszExcludeFromSelectList[u]);
            }

            b = TRUE;
cleanAll: ;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Unexpected exception occurred, drop into cleanup
            //
        }
        if(b) {
            //
            // succeeded
            //
            goto Done;
        }
    } else {
        //
        // Detach
        //
        DestroyMiniIconList();
        DestroyDrvSearchInProgressList();
        DestroyDrvSignPolicyList();
        if(DoneCriticalSections) {
            DeleteCriticalSection(&InitMutex);
            DeleteCriticalSection(&ImageHlpMutex);
            DeleteCriticalSection(&DelayedComponentMutex);
            DeleteCriticalSection(&PlatformPathOverrideCritSect);
            DeleteCriticalSection(&LogUseCountCs);
            DeleteCriticalSection(&MruCritSect);
            DeleteCriticalSection(&NetConnectionListCritSect);
        }
        if(GlobalNoDriverPromptsEventFlag) {
            CloseHandle(GlobalNoDriverPromptsEventFlag);
        }
    }
    if (InfSearchPaths) {
        MyFree(InfSearchPaths);
        InfSearchPaths = NULL;
    }
    if (DriverCacheSourcePath) {
        MyFree(DriverCacheSourcePath);
        DriverCacheSourcePath = NULL;
    }
    if (ServicePackSourcePath) {
        MyFree(ServicePackSourcePath);
        ServicePackSourcePath = NULL;
    }
    if (SystemSourcePath) {
        MyFree(SystemSourcePath);
        SystemSourcePath = NULL;
    }
    if (SystemDirectory) {
        MyFree(SystemDirectory);
        SystemDirectory = NULL;

        if (WindowsBackupDirectory) {
            MyFree(WindowsBackupDirectory);
            WindowsBackupDirectory = NULL;
        }
        if (ConfigDirectory) {
            MyFree(ConfigDirectory);
            ConfigDirectory = NULL;
        }
        if (DriversDirectory) {
            MyFree(DriversDirectory);
            DriversDirectory = NULL;
        }
    }
    if (WindowsDirectory) {
        MyFree(WindowsDirectory);
        WindowsDirectory = NULL;

        if (InfDirectory) {
            MyFree(InfDirectory);
            InfDirectory = NULL;
        }
        if (System16Directory) {
            MyFree(System16Directory);
            System16Directory = NULL;
        }
        if (LastGoodDirectory) {
            MyFree(LastGoodDirectory);
        }   LastGoodDirectory = NULL;
    }
    if (ProcessFileName) {
        MyFree(ProcessFileName);
        ProcessFileName = NULL;
    }
    if (OsLoaderRelativePath) {
        MyFree(OsLoaderRelativePath);
        OsLoaderRelativePath = NULL;
    }
    if (OsSystemPartitionRoot) {
        MyFree(OsSystemPartitionRoot);
        OsSystemPartitionRoot = NULL;
    }
    pSetupInitNetConnectionList(FALSE);
    pSetupInitPlatformPathOverrideSupport(FALSE);
Done:
    return(b);
}

#if MEM_DBG
#undef GetSystemSourcePath          // defined again below
#endif

PCTSTR
GetSystemSourcePath(
    TRACK_ARG_DECLARE
    )
/*++

Routine Description:

    This routine returns a newly-allocated buffer containing the source path from
    which the system was installed, or "A:\" if that value cannot be determined.
    This value is retrieved from the following registry location:

    \HKLM\Software\Microsoft\Windows\CurrentVersion\Setup

        SourcePath : REG_SZ : "\\ntalpha1\1300fre.wks"  // for example.

Arguments:

    None.

Return Value:

    If the function succeeds, the return value is a pointer to the path string.
    This memory must be freed via MyFree().

    If the function fails due to out-of-memory, the return value is NULL.

--*/
{
    HKEY hKey;
    TCHAR CharBuffer[CSTRLEN(REGSTR_PATH_SETUP) + SIZECHARS(REGSTR_KEY_SETUP)];
    DWORD Err, DataType, DataSize;
    PTSTR Value;
    PCTSTR ReturnVal;

    TRACK_PUSH

    CopyMemory(CharBuffer,
               pszPathSetup,
               sizeof(pszPathSetup) - sizeof(TCHAR)
              );
    CopyMemory((PBYTE)CharBuffer + (sizeof(pszPathSetup) - sizeof(TCHAR)),
               pszKeySetup,
               sizeof(pszKeySetup)
              );

    if((Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           CharBuffer,
                           0,
                           KEY_READ,
                           &hKey)) == ERROR_SUCCESS) {
        //
        // Attempt to read the the "SourcePath" value.
        //
        Err = QueryRegistryValue(hKey, pszSourcePath, &Value, &DataType, &DataSize);

        RegCloseKey(hKey);
    }

    ReturnVal = NULL;

    if(Err == NO_ERROR) {

        ReturnVal = Value;

    }

    if(!ReturnVal && Err != ERROR_NOT_ENOUGH_MEMORY) {
        //
        // We failed to retrieve the SourcePath value, and it wasn't due to an out-of-memory
        // condition.  Fall back to our default of "A:\".
        //
        ReturnVal = DuplicateString(pszOemInfDefaultPath);
    }

    TRACK_POP

    return ReturnVal;
}

#if MEM_DBG
#define GetSystemSourcePath()   GetSystemSourcePath(TRACK_ARG_CALL)
#endif



#if MEM_DBG
#undef GetServicePackSourcePath         // defined again below
#endif

PCTSTR
GetServicePackSourcePath(
    TRACK_ARG_DECLARE
    )
/*++

Routine Description:

    This routine returns a newly-allocated buffer containing the service pack source path
    where we should look for service pack source files, or "CDM" if that value cannot be determined.
    This value is retrieved from the following registry location:

    \HKLM\Software\Microsoft\Windows\CurrentVersion\Setup

        ServicePackSourcePath : REG_SZ : "\\ntalpha1\1300fre.wks"  // for example.

Arguments:

    None.

Return Value:

    If the function succeeds, the return value is a pointer to the path string.
    This memory must be freed via MyFree().

    If the function fails due to out-of-memory, the return value is NULL.

--*/
{
    HKEY hKey;
    TCHAR CharBuffer[CSTRLEN(REGSTR_PATH_SETUP) + SIZECHARS(REGSTR_KEY_SETUP)];
    DWORD Err, DataType, DataSize;
    PTSTR Value;
    PCTSTR ReturnStr = NULL;

    TRACK_PUSH

    CopyMemory(CharBuffer,
               pszPathSetup,
               sizeof(pszPathSetup) - sizeof(TCHAR)
              );
    CopyMemory((PBYTE)CharBuffer + (sizeof(pszPathSetup) - sizeof(TCHAR)),
               pszKeySetup,
               sizeof(pszKeySetup)
              );

    if((Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           CharBuffer,
                           0,
                           KEY_READ,
                           &hKey)) == ERROR_SUCCESS) {
        //
        // Attempt to read the the "ServicePackSourcePath" value.
        //
        Err = QueryRegistryValue(hKey, pszSvcPackPath, &Value, &DataType, &DataSize);

        RegCloseKey(hKey);
    }

    if(Err == NO_ERROR) {

        ReturnStr = Value;

    }

    if(!ReturnStr && Err != ERROR_NOT_ENOUGH_MEMORY) {
        //
        // We failed to retrieve the ServicePackSourcePath value, and it wasn't due to an out-of-memory
        // condition.  Fall back to the SourcePath value in the registry
        //

        ReturnStr = GetSystemSourcePath();
    }

    TRACK_POP

    return ReturnStr;
}

#if MEM_DBG
#define GetServicePackSourcePath()   GetServicePackSourcePath(TRACK_ARG_CALL)
#endif



PCTSTR
GetDriverCacheSourcePath(
    VOID
    )
/*++

Routine Description:

    This routine returns a newly-allocated buffer containing the source path to the local driver cache
    cab-file.

    This value is retrieved from the following registry location:

    \HKLM\Software\Microsoft\Windows\CurrentVersion\Setup

        DriverCachePath : REG_SZ : "\\ntalpha1\1300fre.wks"  // for example.

Arguments:

    None.

Return Value:

    If the function succeeds, the return value is a pointer to the path string.
    This memory must be freed via MyFree().

    If the function fails due to out-of-memory, the return value is NULL.

--*/
{
    HKEY hKey;
    TCHAR CharBuffer[CSTRLEN(REGSTR_PATH_SETUP) + SIZECHARS(REGSTR_KEY_SETUP)];
    DWORD Err, DataType, DataSize;
    PTSTR Value;
    TCHAR Path[MAX_PATH];

    CopyMemory(CharBuffer,
               pszPathSetup,
               sizeof(pszPathSetup) - sizeof(TCHAR)
              );
    CopyMemory((PBYTE)CharBuffer + (sizeof(pszPathSetup) - sizeof(TCHAR)),
               pszKeySetup,
               sizeof(pszKeySetup)
              );

    if((Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           CharBuffer,
                           0,
                           KEY_READ,
                           &hKey)) == ERROR_SUCCESS) {
        //
        // Attempt to read the the "DriverCachePath" value.
        //
        Err = QueryRegistryValue(hKey, pszDriverCachePath, &Value, &DataType, &DataSize);

        RegCloseKey(hKey);
    }

    if(Err == NO_ERROR) {
        if(Value) {

            ExpandEnvironmentStrings(Value,Path,MAX_PATH);

            MyFree(Value);

            Value = NULL;

            if (*Path) {
                Value = DuplicateString( Path );
            }

            return (PCTSTR)Value;
        }
    } else if(Err == ERROR_NOT_ENOUGH_MEMORY) {
        return NULL;
    }

    return NULL;

}




BOOL
pSetupSetSystemSourcePath(
    IN PCTSTR NewSourcePath,
    IN PCTSTR NewSvcPackSourcePath
    )
/*++

Routine Description:

    This routine is used to override the system source path used by setupapi (as
    retrieved by GetSystemSourcePath during DLL initialization).  This is used by
    syssetup.dll to set the system source path appropriately during GUI-mode setup,
    so that the device installer APIs will copy files from the correct source location.

    We do the same thing for the service pack source path

    NOTE:  This routine IS NOT thread safe!

Arguments:

    NewSourcePath - supplies the new source path to be used.
    NewSvcPackSourcePath - supplies the new svcpack source path to be used.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails (due to out-of-memory), the return value is FALSE.

--*/
{
    PCTSTR p,q;

    p = (PCTSTR)DuplicateString(NewSourcePath);
    q = (PCTSTR)DuplicateString(NewSvcPackSourcePath);

    if(p) {
        MyFree(SystemSourcePath);
        SystemSourcePath = p;
    }

    if (q) {
        MyFree(ServicePackSourcePath);
        ServicePackSourcePath = q;
    }

    if (!p || !q) {
        //
        // failed due to out of memory!
        //
        return(FALSE);
    }

    return TRUE;
}


PCTSTR
pSetupGetOsLoaderPath(
    VOID
    )
/*++

Routine Description:

    This routine returns a newly-allocated buffer containing the path to the OsLoader
    (relative to the system partition drive).  This value is retrieved from the
    following registry location:

        HKLM\System\Setup
            OsLoaderPath : REG_SZ : <path>    // e.g., "\os\winnt40"

Arguments:

    None.

Return Value:

    If the registry entry is found, the return value is a pointer to the string containing
    the path.  The caller must free this buffer via MyFree().

    If the registry entry is not found, or memory cannot be allocated for the buffer, the
    return value is NULL.

--*/
{
    HKEY hKey;
    PTSTR Value;
    DWORD Err, DataType, DataSize;

    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    TEXT("SYSTEM\\Setup"),
                    0,
                    KEY_READ,
                    &hKey) == ERROR_SUCCESS) {

        Err = QueryRegistryValue(hKey, TEXT("OsLoaderPath"), &Value, &DataType, &DataSize);

        RegCloseKey(hKey);

        return (Err == NO_ERROR) ? (PCTSTR)Value : NULL;
    }

    return NULL;
}

PCTSTR
pSetupGetSystemPartitionRoot(
    VOID
    )
/*++

Routine Description:

    This routine returns a newly-allocated buffer containing the path to the OsLoader
    (relative to the system partition drive).  This value is retrieved from the
    following registry location:

        HKLM\System\Setup
            SystemPartition : REG_SZ : <path>    // e.g., "\Device\HarddiskVolume1"

Arguments:

    None.

Return Value:

    If the registry entry is found, the return value is a pointer to the string containing
    the path.  The caller must free this buffer via MyFree().

    If the registry entry is not found, or memory cannot be allocated for the buffer, the
    return value is NULL.

--*/
{
#ifdef UNICODE
    HKEY hKey;
    PTSTR Value;
    DWORD Err, DataType, DataSize;
    TCHAR Path[MAX_PATH];

    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    TEXT("SYSTEM\\Setup"),
                    0,
                    KEY_READ,
                    &hKey) == ERROR_SUCCESS) {

        Err = QueryRegistryValue(hKey, TEXT("SystemPartition"), &Value, &DataType, &DataSize);

        RegCloseKey(hKey);

        if(Err == NO_ERROR) {
            //
            // prepend \\?\GLOBALROOT\
            //
            lstrcpy(Path,TEXT("\\\\?\\GLOBALROOT\\"));
            if(pSetupConcatenatePaths(Path,Value,MAX_PATH,NULL)) {
                MyFree(Value);
                Value = DuplicateString(Path);
                if(!Value) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                }
            } else {
                Err = GetLastError();
                MyFree(Value);
            }
        }

        return (Err == NO_ERROR) ? (PCTSTR)Value : NULL;
    }
#endif

    return NULL;
}

PCTSTR
pSetupGetProcessPath(
    VOID
    )
/*++

Routine Description:

    Get the name of the EXE that we're running in.

Arguments:

    NONE.

Return Value:

    Pointer to a dynamically allocated string containing the name.

--*/

{
    LPTSTR modname;

    modname = MyMalloc(MAX_PATH * sizeof(TCHAR));

    if(modname != NULL) {
        if(GetModuleFileName(NULL, modname, MAX_PATH) > 0) {
            LPTSTR modname2;
            modname2 = MyRealloc(modname, (lstrlen(modname)+1)*sizeof(TCHAR));
            if(modname2) {
                modname = modname2;
            }
            return modname;
        } else {
#ifdef PRERELEASE
            OutputDebugStringA("GetModuleFileName returned 0\r\n");
            DebugBreak();
#endif
            MyFree(modname);
        }
    }

    return NULL;
}

#ifdef UNICODE
BOOL
pGetGuiSetupInProgress(
    VOID
    )
/*++

Routine Description:

    This routine determines if we're doing a gui-mode setup.

    This value is retrieved from the following registry location:

    \HKLM\System\Setup\

        SystemSetupInProgress : REG_DWORD : 0x00 (where nonzero means we're doing a gui-setup)

Arguments:

    None.

Return Value:

    If the function succeeds, the return value is a pointer to the path string.
    This memory must be freed via MyFree().

    If the function fails due to out-of-memory, the return value is NULL.

--*/
{
    HKEY hKey;
    TCHAR CharBuffer[CSTRLEN(REGSTR_PATH_SETUP) + SIZECHARS(REGSTR_KEY_SETUP)];
    DWORD Err, DataType, DataSize = sizeof(DWORD);
    DWORD Value;

    if((Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           TEXT("System\\Setup"),
                           0,
                           KEY_READ,
                           &hKey)) == ERROR_SUCCESS) {
        //
        // Attempt to read the the "DriverCachePath" value.
        //
        Err = RegQueryValueEx(
                    hKey,
                    TEXT("SystemSetupInProgress"),
                    NULL,
                    &DataType,
                    (LPBYTE)&Value,
                    &DataSize);

        RegCloseKey(hKey);
    }

    if(Err == NO_ERROR) {
        if(Value) {
            return(TRUE);
        }
    }

    return(FALSE);

}

#else

BOOL
pGetGuiSetupInProgress(
    VOID
    )
{
    return FALSE;
}

#endif

VOID pSetupSetGlobalFlags(
    IN DWORD Value
    )
/*++

    exported as a private function

Routine Description:

    Sets global flags to change certain setupapi features,
    such as "should we call runonce after installing every device" (set if we will manually call it)
    or "should we backup every file"
    Used to initialize value

Arguments:

    Value: combination of:

        PSPGF_NO_RUNONCE     - set to inhibit runonce calls (e.g., during GUI-
                               mode setup)

        PSPGF_NO_BACKUP      - set to inhibit automatic backup (e.g., during
                               GUI-mode setup)

        PSPGF_NONINTERACTIVE - set to inhibit _all_ UI (e.g., for server-side
                               device installation)

        PSPGF_SERVER_SIDE_RUNONCE - batch RunOnce entries for server-side
                                    processing (for use only by umpnpmgr)

        PSPGF_NO_VERIFY_INF  - set to inhibit verification (digital signature) of
                               INF files until after the cyrpto DLLs have been registered.

        PSPGF_UNATTENDED_SETUP - similar to NONINTERACTIVE - but specific to unattended setup

        PSPGF_AUTOFAIL_VERIFIES - automatically fail all calls to crypto

Return Value:

    none

--*/
{
    pSetupModifyGlobalFlags((DWORD)(-1),Value);
}

VOID
pSetupModifyGlobalFlags(
    IN DWORD Flags,
    IN DWORD Value
    )
/*++

    exported as a private function

Routine Description:

    Modifies global setup flags

    such as "should we call runonce after installing every device" (set if we will manually call it)
    or "should we backup every file"
    only modifies specified flags to given value

Arguments:

    Flags: what actual flags to modify, combination of:

        PSPGF_NO_RUNONCE     - set to inhibit runonce calls (e.g., during GUI-
                               mode setup)

        PSPGF_NO_BACKUP      - set to inhibit automatic backup (e.g., during
                               GUI-mode setup)

        PSPGF_NONINTERACTIVE - set to inhibit _all_ UI (e.g., for server-side
                               device installation)

        PSPGF_SERVER_SIDE_RUNONCE - batch RunOnce entries for server-side
                                    processing (for use only by umpnpmgr)

        PSPGF_NO_VERIFY_INF  - set to inhibit verification (digital signature) of
                               INF files until after the cyrpto DLLs have been registered.

        PSPGF_UNATTENDED_SETUP - similar to PSPGF_NONINTERACTIVE, but specific to setup

        PSPGF_AUTOFAIL_VERIFIES - automatically fail all calls to crypto

    Value: new value of bits specified in Flags

Return Value:

    none

--*/
{
    Flags &= ~GlobalSetupFlagsOverride; // exclusion
#ifdef UNICODE
    if((Flags & PSPGF_NO_VERIFY_INF) && !(Value & PSPGF_NO_VERIFY_INF) && (GlobalSetupFlags & PSPGF_NO_VERIFY_INF)) {
        Seed = GetSeed();
    }
#endif
    GlobalSetupFlags = (Value & Flags) | (GlobalSetupFlags & ~Flags);
}

DWORD pSetupGetGlobalFlags(
    VOID
    )
/*++

    exported as a private function, also called internally

Routine Description:

    Return flags previously set

Arguments:

    none

Return value:

    Flags (combination of values described above for pSetupSetGlobalFlags)

--*/
{
    return GlobalSetupFlags;
}

BOOL
WINAPI
SetupSetNonInteractiveMode(
    IN BOOL NonInteractiveFlag
    )
/*++

    Global access to the flag PSPGF_NONINTERACTIVE

Routine Description:

    Set/Reset the NonInteractiveMode flag, and return previous flag value
    (can't clear override)

Arguments:

    New flag value

Return value:

    Old flag value

--*/
{
    BOOL f = (GlobalSetupFlags & PSPGF_NONINTERACTIVE) ? TRUE : FALSE;
    if (NonInteractiveFlag) {
        pSetupModifyGlobalFlags(PSPGF_NONINTERACTIVE,PSPGF_NONINTERACTIVE);
    } else {
        pSetupModifyGlobalFlags(PSPGF_NONINTERACTIVE,0);
    }
    return f;
}

BOOL
WINAPI
SetupGetNonInteractiveMode(
    VOID
    )
/*++

    Global access to the flag PSPGF_NONINTERACTIVE

Routine Description:

    Get current flag value

Arguments:

    none

Return value:

    Current flag value

--*/
{
    return (GlobalSetupFlags & PSPGF_NONINTERACTIVE) ? TRUE : FALSE;
}

#ifndef _WIN64
BOOL
GetIsWow64 (
    VOID
    )
/*++

Routine Description:

    Determine if we're running on WOW64 or not (not supported on ANSI builds)

Arguments:

    none

Return value:

    TRUE if running under WOW64 (and special Wow64 features available)

--*/
{
#ifdef UNICODE
    ULONG_PTR       ul = 0;
    NTSTATUS        st;

    //
    // If this call succeeds and sets ul non-zero
    // it's a 32-bit process running on Win64
    //

    st = NtQueryInformationProcess(NtCurrentProcess(),
                                   ProcessWow64Information,
                                   &ul,
                                   sizeof(ul),
                                   NULL);

    if (NT_SUCCESS(st) && (0 != ul)) {
        // 32-bit code running on Win64
        return TRUE;
    }
#endif
    return FALSE;
}
#endif // _WIN64

#if 0 // deleted code
//
// this will be useful at somepoint, but not used right now
//
BOOL
InitComponents(
    DWORD Components
    )
/*++

Routine Description:

    Called at a point we want certain components initialized

Arguments:

    bitmask of components to initialize

Return value:

    TRUE if all initialized ok

--*/
{
    BOOL success = FALSE;
    PSETUP_TLS pPerThread = SetupGetTlsData();
    BOOL locked = FALSE;

    if(!pPerThread) {
        MYASSERT(pPerThread);
        return FALSE;
    }

    try {
        EnterCriticalSection(&DelayedComponentMutex);
        locked = TRUE;
        Components &= ~ DoneComponentInitialize;
        Components &= ~ pPerThread->PerThreadDoneComponent;

        if (!Components) {
            //
            // already done
            //
            success = TRUE;
            leave;
        }
        if (Components & FailedComponentInitialize) {
            //
            // previously failed
            //
            leave;
        }
        if (Components & pPerThread->PerThreadFailedComponent) {
            //
            // previously failed
            //
            leave;
        }
        MYASSERT(((DoneComponentInitialize | pPerThread->PerThreadDoneComponent) & Components) == Components);
        MYASSERT(((FailedComponentInitialize | pPerThread->PerThreadFailedComponent) & Components) == 0);
        success = TRUE;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        MYASSERT(FALSE);
    }
    if(locked) {
        LeaveCriticalSection(&DelayedComponentMutex);
    }
    return success;
}

VOID
ComponentCleanup(
    DWORD Components
    )
/*++

Routine Description:

    Called to cleanup components

Arguments:

    bitmask of components to uninitialize

Return value:

    none

--*/
{
    PSETUP_TLS pPerThread = SetupGetTlsData();
    BOOL locked = FALSE;

    try {
        EnterCriticalSection(&DelayedComponentMutex);
        locked = TRUE;
        Components &= (DoneComponentInitialize | (pPerThread? pPerThread->PerThreadDoneComponent : 0));
        if (!Components) {
            //
            // already done
            //
            leave;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        MYASSERT(FALSE);
    }
    MYASSERT(((DoneComponentInitialize | (pPerThread ? pPerThread->PerThreadDoneComponent : 0)) & Components) == 0);
    if(locked) {
        LeaveCriticalSection(&DelayedComponentMutex);
    }
}
#endif // deleted code

#ifdef UNICODE
BOOL
pSetupSetNoDriverPrompts(
    BOOL Flag
    )
/*++

    exported as a private function

Routine Description:

    Sets system into headless/non-headless mode

Arguments:

    Flag - indicating mode

--*/
{
    //
    //
    if(!GuiSetupInProgress) {
        return FALSE;
    }
    if(GlobalNoDriverPromptsEventFlag == NULL) {
        GlobalNoDriverPromptsEventFlag = CreateEvent(NULL,TRUE,Flag,SETUP_NODRIVERPROMPTS_MODE);
        if(GlobalNoDriverPromptsEventFlag == NULL) {
            return FALSE;
        }
    }
    if(Flag) {
        //
        // force this process's setupapi to be non-interative, and any future setupapi's
        //
        GlobalSetupFlagsOverride |= PSPGF_UNATTENDED_SETUP;   // don't allow this to be changed
        GlobalSetupFlags |= PSPGF_UNATTENDED_SETUP;           // actual value
        SetEvent(GlobalNoDriverPromptsEventFlag);
    } else {
        //
        // can't reset flag for this/existing processes, but can reset it for all future processes
        //
        ResetEvent(GlobalNoDriverPromptsEventFlag);
    }
    return TRUE;
}
#endif

BOOL
IsNoDriverPrompts(
    VOID
    )
/*++

    internal

Routine Description:

    Obtains headless state

Arguments:

    Flag - indicating mode

--*/
{
#ifdef UNICODE
    if(!GuiSetupInProgress) {
        return FALSE;
    }
    if(GlobalNoDriverPromptsEventFlag == NULL) {
        GlobalNoDriverPromptsEventFlag = OpenEvent(SYNCHRONIZE,FALSE,SETUP_NODRIVERPROMPTS_MODE);
        if(GlobalNoDriverPromptsEventFlag == NULL) {
            return FALSE;
        }
    }
    //
    // poll event, returning TRUE if it's signalled
    //
    return WaitForSingleObject(GlobalNoDriverPromptsEventFlag,0) == WAIT_OBJECT_0;
#else
    return FALSE;
#endif
}


DWORD
GetEmbeddedFlags(
    VOID
    )
/*++

Routine Description:

    This routine determines whether or not we are running on an embedded
    product, and if so, whether:

    * The "minimize setupapi footprint" option is enabled.  This causes us to
      modify our default behaviors as follows:

          1.  Never call any crypto APIs, and just assume everything is signed
          2.  Never generate PNFs.

    * The "disable SCE" option is enabled.  This causes us to avoid all use of
      the Security Configuration Editor (SCE) routines (as the corresponding
      DLLs won't be available on that embedded configuration).

Arguments:

    none

Return value:

    Combination of the following flags:

    PSPGF_MINIMAL_EMBEDDED if we're running in "minimize footprint" mode

    PSPGF_NO_SCE_EMBEDDED if we're running in "disable SCE" mode

--*/
{
    OSVERSIONINFOEX osvix;
    DWORDLONG dwlConditionMask = 0;
    HKEY hKey;
    TCHAR CharBuffer[CSTRLEN(REGSTR_PATH_SETUP) + SIZECHARS(REGSTR_KEY_SETUP)];
    DWORD RegDataType, Data, DataSize;
    DWORD Flags;

    //
    // Are we on the embedded product suite?
    //
    ZeroMemory(&osvix, sizeof(OSVERSIONINFOEX));
    osvix.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osvix.wSuiteMask = VER_SUITE_EMBEDDEDNT;
    VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

    if(!VerifyVersionInfo(&osvix,
                          VER_SUITENAME,
                          dwlConditionMask)) {
        return 0;
    }

    Flags = 0;

    //
    // OK, we running on embedded.  Now we need to find out whether or not we
    // should run in "minimal footprint" mode.  This is stored in a REG_DWORD
    // value entry called "MinimizeFootprint" under
    // HKLM\Software\Microsoft\Windows\CurrentVersion\Setup.
    //
    CopyMemory(CharBuffer,
               pszPathSetup,
               sizeof(pszPathSetup) - sizeof(TCHAR)
              );
    CopyMemory((PBYTE)CharBuffer + (sizeof(pszPathSetup) - sizeof(TCHAR)),
               pszKeySetup,
               sizeof(pszKeySetup)
              );

    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                     CharBuffer,
                                     0,
                                     KEY_READ,
                                     &hKey)) {
        DataSize = sizeof(Data);

        if((ERROR_SUCCESS == RegQueryValueEx(hKey,
                                             pszMinimizeFootprint,
                                             NULL,
                                             &RegDataType,
                                             (LPBYTE)&Data,
                                             &DataSize))
           && (RegDataType == REG_DWORD) && (DataSize == sizeof(Data))) {

            Flags |= PSPGF_MINIMAL_EMBEDDED;
        }

        RegCloseKey(hKey);
    }

    //
    // Now look under HKLM\Software\Microsoft\EmbeddedNT\Security for a
    // DisableSCE REG_DWORD value entry, indicating we shouldn't call SCE.
    //
    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                     pszEmbeddedNTSecurity,
                                     0,
                                     KEY_READ,
                                     &hKey)) {
        DataSize = sizeof(Data);

        if((ERROR_SUCCESS == RegQueryValueEx(hKey,
                                             pszDisableSCE,
                                             NULL,
                                             &RegDataType,
                                             (LPBYTE)&Data,
                                             &DataSize))
           && (RegDataType == REG_DWORD) && (DataSize == sizeof(Data))) {

            Flags |= PSPGF_NO_SCE_EMBEDDED;
        }

        RegCloseKey(hKey);
    }

    return Flags;
}

#ifdef UNICODE
DWORD
GetSeed(
    VOID
    )
{
    HKEY hKey;
    DWORD val = 0;
    DWORD valsize, valdatatype;

    if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
        return val;
    }

    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                     L"System\\WPA\\PnP",
                                     0,
                                     KEY_READ,
                                     &hKey)) {

        valsize = sizeof(val);
        if((ERROR_SUCCESS != RegQueryValueEx(hKey,
                                             L"seed",
                                             NULL,
                                             &valdatatype,
                                             (PBYTE)&val,
                                             &valsize))
           || (valdatatype != REG_DWORD) || (valsize != sizeof(val))) {

            val = 0;
        }

        RegCloseKey(hKey);
    }

    return val;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\filelog.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    filelog.c

Abstract:

    Routines for logging files in copy logs.

Author:

    Ted Miller (tedm) 14-Jun-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// Define name of system log file and various strings used
// within it.
//
PCTSTR SystemLogFileName = TEXT("repair\\setup.log");
PCTSTR NtFileSectionName = TEXT("Files.WinNT");

//
// Define structure used internally to represent a file log file.
//
typedef struct _SETUP_FILE_LOG {
    PCTSTR FileName;
    BOOL QueryOnly;
    BOOL SystemLog;
} SETUP_FILE_LOG, *PSETUP_FILE_LOG;


#ifdef UNICODE
//
// ANSI version
//
HSPFILELOG
SetupInitializeFileLogA(
    IN PCSTR LogFileName,   OPTIONAL
    IN DWORD Flags
    )
{
    PWSTR p;
    DWORD d;
    HSPFILELOG h;

    if(LogFileName) {
        d = pSetupCaptureAndConvertAnsiArg(LogFileName,&p);
        if(d != NO_ERROR) {
            SetLastError(d);
            return(INVALID_HANDLE_VALUE);
        }
    } else {
        p = NULL;
    }

    h = SetupInitializeFileLogW(p,Flags);
    d = GetLastError();

    if(p) {
        MyFree(p);
    }

    SetLastError(d);
    return(h);
}
#else
//
// Unicode stub
//
HSPFILELOG
SetupInitializeFileLogW(
    IN PCWSTR LogFileName,  OPTIONAL
    IN DWORD  Flags
    )
{
    UNREFERENCED_PARAMETER(LogFileName);
    UNREFERENCED_PARAMETER(Flags);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(INVALID_HANDLE_VALUE);
}
#endif

HSPFILELOG
SetupInitializeFileLog(
    IN PCTSTR LogFileName,  OPTIONAL
    IN DWORD  Flags
    )

/*++

Routine Description:

    Initialize a file for logging or query. The caller may specify that he
    wishes to use the system log, which is where the system tracks which
    files are installed as part of Windows NT; or the caller may specify
    any other random file to be used as a log.

    If the user specifies the system log not for query only, the function fails
    unless the user is administrator. However this only guarantees security
    on the log when the system is installed on a drive with a filesystem that
    supports ACLs; the log is simply a file and anyone can access it unless
    setup can secure it via ACLs.

Arguments:

    LogFileName - if specified, supplies the filename of the file to be used
        as the log file. Must be specified if Flags does not include
        SPFILELOG_SYSTEMLOG. Must not be specified if Flags includes
        SPFILELOG_SYSTEMLOG.

    Flags - supplies a combination of the following values:

        SPFILELOG_SYSTEMLOG - use the Windows NT system file log, which is used
            to track what files are installed as part of Windows NT. The user must
            be administrator to specify this option unless SPFILELOG_QUERYONLY
            is specified, and LogFileName must not be specified. May not be specified
            in combination with SPFILELOG_FORCENEW.

        SPFILELOG_FORCENEW - if the log file exists, it will be overwritten.
            If the log file exists and this flag is not specified then additional
            files are added to the existing log. May not be specified in combination
            with SPFILELOG_SYSTEMLOG.

        SPFILELOG_QUERYONLY - open the log file for querying only. The user

Return Value:

    Handle to file log or INVALID_HANDLE_VALUE if the function fails;
    extended error info is available via GetLastError() in this case.

--*/

{
    TCHAR SysLogFileName[MAX_PATH];
    PCTSTR FileName;
    PSETUP_FILE_LOG FileLog;
    DWORD Err;
    HANDLE hFile;

    //
    // Validate args.
    //
    Err = ERROR_INVALID_PARAMETER;
    if(Flags & SPFILELOG_SYSTEMLOG) {
        if((Flags & SPFILELOG_FORCENEW) || LogFileName) {
            goto clean0;
        }
        //
        // User must be administrator to gain write access to system log.
        //
        if(!(Flags & SPFILELOG_QUERYONLY) && !pSetupIsUserAdmin()) {
            Err = ERROR_ACCESS_DENIED;
            goto clean0;
        }

        //
        // uses actual windows directory instead of hydra remapped
        //
        lstrcpyn(SysLogFileName,WindowsDirectory,MAX_PATH);
        pSetupConcatenatePaths(SysLogFileName,SystemLogFileName,MAX_PATH,NULL);
        FileName = SysLogFileName;
    } else {
        if(LogFileName) {
            if(!lstrcpyn(SysLogFileName,LogFileName,MAX_PATH)) {
                //
                // lstrcpyn faulted, LogFileName must be bad
                //
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }
            FileName = SysLogFileName;
        } else {
            goto clean0;
        }
    }

    //
    // Allocate a log file structure.
    //
    Err = ERROR_NOT_ENOUGH_MEMORY;
    if(FileLog = MyMalloc(sizeof(SETUP_FILE_LOG))) {
        FileLog->FileName = DuplicateString(FileName);
        if(!FileLog->FileName) {
            goto clean1;
        }
    } else {
        goto clean0;
    }

    FileLog->QueryOnly = ((Flags & SPFILELOG_QUERYONLY) != 0);
    FileLog->SystemLog = ((Flags & SPFILELOG_SYSTEMLOG) != 0);

    //
    // See if the file exists.
    //
    if(FileExists(FileName,NULL)) {

        //
        // If it's the system log, take ownership of the file.
        //
        if(FileLog->SystemLog) {
            Err = TakeOwnershipOfFile(FileName);
            if(Err != NO_ERROR) {
                goto clean2;
            }
        }

        //
        // Set attribute to normal. This ensures we can delete/open/create the file
        // as appropriate below.
        //
        if(!SetFileAttributes(FileName,FILE_ATTRIBUTE_NORMAL)) {
            Err = GetLastError();
            goto clean2;
        }

        //
        // Delete the file now if the caller specified the force_new flag.
        //
        if((Flags & SPFILELOG_FORCENEW) && !DeleteFile(FileName)) {
            Err = GetLastError();
            goto clean2;
        }
    }

    //
    // Make sure we can open/create the file by attempting to do that now.
    //
    hFile = CreateFile(
                FileName,
                GENERIC_READ | (FileLog->QueryOnly ? 0 : GENERIC_WRITE),
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_ALWAYS,            // Open if exists, create if not
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if(hFile == INVALID_HANDLE_VALUE) {
        Err = GetLastError();
        goto clean2;
    }

    CloseHandle(hFile);
    return((HSPFILELOG)FileLog);

clean2:
    MyFree(FileLog->FileName);
clean1:
    MyFree(FileLog);
clean0:
    SetLastError(Err);
    return(INVALID_HANDLE_VALUE);
}


BOOL
SetupTerminateFileLog(
    IN HSPFILELOG FileLogHandle
    )

/*++

Routine Description:

    Releases resources associated with a file log.

Arguments:

    FileLogHandle - supplies the handle to the file log, as returned
        by SetupInitializeLogFile.

Return Value:

    Boolean value indicating outcome. If FALSE, the caller can use
    GetLastError() to get extended error info.

--*/

{
    PSETUP_FILE_LOG FileLog;
    DWORD Err;

    FileLog = (PSETUP_FILE_LOG)FileLogHandle;
    Err = NO_ERROR;

    try {
        MyFree(FileLog->FileName);
        MyFree(FileLog);

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupLogFileA(
    IN HSPFILELOG FileLogHandle,
    IN PCSTR      LogSectionName,   OPTIONAL
    IN PCSTR      SourceFilename,
    IN PCSTR      TargetFilename,
    IN DWORD      Checksum,         OPTIONAL
    IN PCSTR      DiskTagfile,      OPTIONAL
    IN PCSTR      DiskDescription,  OPTIONAL
    IN PCSTR      OtherInfo,        OPTIONAL
    IN DWORD      Flags
    )
{
    PWSTR logsectionname = NULL;
    PWSTR sourcefilename = NULL;
    PWSTR targetfilename = NULL;
    PWSTR disktagfile = NULL;
    PWSTR diskdescription = NULL;
    PWSTR otherinfo = NULL;
    DWORD d;
    BOOL b;

    if(LogSectionName) {
        d = pSetupCaptureAndConvertAnsiArg(LogSectionName,&logsectionname);
    } else {
        d = NO_ERROR;
    }
    if(d == NO_ERROR) {
        d = pSetupCaptureAndConvertAnsiArg(SourceFilename,&sourcefilename);
    }
    if(d == NO_ERROR) {
        d = pSetupCaptureAndConvertAnsiArg(TargetFilename,&targetfilename);
    }
    if((d == NO_ERROR) && DiskTagfile) {
        d = pSetupCaptureAndConvertAnsiArg(DiskTagfile,&disktagfile);
    }
    if((d == NO_ERROR) && DiskDescription) {
        d = pSetupCaptureAndConvertAnsiArg(DiskDescription,&diskdescription);
    }
    if((d == NO_ERROR) && OtherInfo) {
        d = pSetupCaptureAndConvertAnsiArg(OtherInfo,&otherinfo);
    }

    if(d == NO_ERROR) {

        b = SetupLogFileW(
                FileLogHandle,
                logsectionname,
                sourcefilename,
                targetfilename,
                Checksum,
                disktagfile,
                diskdescription,
                otherinfo,
                Flags
                );

        d = GetLastError();

    } else {
        b = FALSE;
    }

    if(logsectionname) {
        MyFree(logsectionname);
    }
    if(sourcefilename) {
        MyFree(sourcefilename);
    }
    if(targetfilename) {
        MyFree(targetfilename);
    }
    if(disktagfile) {
        MyFree(disktagfile);
    }
    if(diskdescription) {
        MyFree(diskdescription);
    }
    if(otherinfo) {
        MyFree(otherinfo);
    }

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupLogFileW(
    IN HSPFILELOG FileLogHandle,
    IN PCWSTR     LogSectionName,   OPTIONAL
    IN PCWSTR     SourceFilename,
    IN PCWSTR     TargetFilename,
    IN DWORD      Checksum,         OPTIONAL
    IN PCWSTR     DiskTagfile,      OPTIONAL
    IN PCWSTR     DiskDescription,  OPTIONAL
    IN PCWSTR     OtherInfo,        OPTIONAL
    IN DWORD      Flags
    )
{
    UNREFERENCED_PARAMETER(FileLogHandle);
    UNREFERENCED_PARAMETER(LogSectionName);
    UNREFERENCED_PARAMETER(SourceFilename);
    UNREFERENCED_PARAMETER(TargetFilename);
    UNREFERENCED_PARAMETER(Checksum);
    UNREFERENCED_PARAMETER(DiskTagfile);
    UNREFERENCED_PARAMETER(DiskDescription);
    UNREFERENCED_PARAMETER(OtherInfo);
    UNREFERENCED_PARAMETER(Flags);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupLogFile(
    IN HSPFILELOG FileLogHandle,
    IN PCTSTR     LogSectionName,   OPTIONAL
    IN PCTSTR     SourceFilename,
    IN PCTSTR     TargetFilename,
    IN DWORD      Checksum,         OPTIONAL
    IN PCTSTR     DiskTagfile,      OPTIONAL
    IN PCTSTR     DiskDescription,  OPTIONAL
    IN PCTSTR     OtherInfo,        OPTIONAL
    IN DWORD      Flags
    )

/*++

Routine Description:

    Logs a file into a file log.

Arguments:

    FileLogHandle - supplies the handle to the file log, as returned
        by SetupInitializeLogFile(). The caller must not have passed
        SPFILELOG_QUERYONLY when the log file was opened/initialized.

    LogSectionName - required if SPFILELOG_SYSTEMLOG was not passed when
        the file log was opened/initialized; optional otherwise.
        Supplies the name for a logical grouping of files within the log.

    SourceFilename - supplies the name of the file as it exists on the
        source media from which it was installed. This name should be in
        whatever format is meaningful to the caller.

    TargetFilename - supplies the name of the file as it exists on the
        Target. This name should be in whatever format is meaningful to
        the caller.

    Checksum - supplies a 32-bit checksum value. Required for the system log.

    DiskTagfile - Gives the tagfile for the media from which the file
        was installed. Required for the system log if SPFILELOG_OEMFILE
        is specified. Ignored for the system log if SPFILELOG_OEMFILE is
        not specified.

    DiskDescription - Gives the human-readable description for the media
        from which the file was installed. Required for the system log if
        SPFILELOG_OEMFILE is specified. Ignored for the system log if
        SPFILELOG_OEMFILE is not specified.

    OtherInfo - supplies additional information to be associated with the
        file.

    Flags - may supply SPFILELOG_OEMFILE, which is meaningful only for
        the system log and indicates that the file is not an MS-supplied file.
        Can be used to convert an existing file's entry such as when an oem
        overwrites an MS-supplied system file.

Return Value:

    Boolean value indicating outcome. If FALSE, the caller can use
    GetLastError() to get extended error info.

--*/

{
    PSETUP_FILE_LOG FileLog;
    DWORD Err;
    BOOL b;
    TCHAR LineToWrite[512];
    TCHAR sourceFilename[MAX_PATH];
    PTSTR p,Directory;

    FileLog = (PSETUP_FILE_LOG)FileLogHandle;

    try {
        //
        // Validate params. Handle must be for non-queryonly.
        // If for the system log and oem file is specified,
        // caller must have passed disk tagfile and description.
        // There's really no way to validate the checksum because
        // 0 is a perfectly valid one.
        // If not the system log, caller must have passed a section name.
        //
        if(FileLog->QueryOnly
        || (  FileLog->SystemLog
            && (Flags & SPFILELOG_OEMFILE)
            && (!DiskTagfile || !DiskDescription))
        || (!FileLog->SystemLog && !LogSectionName))
        {
            Err = ERROR_INVALID_PARAMETER;

        } else {
            //
            // Use default section if not specified.
            //
            if(!LogSectionName) {
                MYASSERT(FileLog->SystemLog);
                LogSectionName = NtFileSectionName;
            }

            //
            // IF THIS LOGIC IS CHANGED BE SURE TO CHANGE
            // SetupQueryFileLog() AS WELL!
            //
            // Split up the source filename into filename and
            // directory if appropriate.
            //
            lstrcpyn(sourceFilename,SourceFilename,MAX_PATH);
            if(FileLog->SystemLog && (Flags & SPFILELOG_OEMFILE)) {
                if(p = _tcsrchr(sourceFilename,TEXT('\\'))) {
                    *p++ = 0;
                    Directory = p;
                } else {
                    Directory = TEXT("\\");
                }
            } else {
                Directory = TEXT("");
            }

            _sntprintf(
                LineToWrite,
                sizeof(LineToWrite)/sizeof(LineToWrite[0]),
                TEXT("%s,%x,%s,%s,\"%s\""),
                sourceFilename,
                Checksum,
                Directory,
                DiskTagfile ? DiskTagfile : TEXT(""),
                DiskDescription ? DiskDescription : TEXT("")
                );


            b = WritePrivateProfileString(
                    LogSectionName,
                    TargetFilename,
                    LineToWrite,
                    FileLog->FileName
                    );

            Err = b ? NO_ERROR : GetLastError();
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupRemoveFileLogEntryA(
    IN HSPFILELOG FileLogHandle,
    IN PCSTR      LogSectionName,   OPTIONAL
    IN PCSTR      TargetFilename    OPTIONAL
    )
{
    PWSTR logsectionname,targetfilename;
    DWORD d;
    BOOL b;

    if(LogSectionName) {
        d = pSetupCaptureAndConvertAnsiArg(LogSectionName,&logsectionname);
        if(d != NO_ERROR) {
            SetLastError(d);
            return(FALSE);
        }
    } else {
        logsectionname = NULL;
    }
    if(TargetFilename) {
        d = pSetupCaptureAndConvertAnsiArg(TargetFilename,&targetfilename);
        if(d != NO_ERROR) {
            if(logsectionname) {
                MyFree(logsectionname);
            }
            SetLastError(d);
            return(FALSE);
        }
    } else {
        targetfilename = NULL;
    }

    b = SetupRemoveFileLogEntryW(FileLogHandle,logsectionname,targetfilename);
    d = GetLastError();

    if(logsectionname) {
        MyFree(logsectionname);
    }
    if(targetfilename) {
        MyFree(targetfilename);
    }

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupRemoveFileLogEntryW(
    IN HSPFILELOG FileLogHandle,
    IN PCWSTR     LogSectionName,   OPTIONAL
    IN PCWSTR     TargetFilename    OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(FileLogHandle);
    UNREFERENCED_PARAMETER(LogSectionName);
    UNREFERENCED_PARAMETER(TargetFilename);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupRemoveFileLogEntry(
    IN HSPFILELOG FileLogHandle,
    IN PCTSTR     LogSectionName,   OPTIONAL
    IN PCTSTR     TargetFilename    OPTIONAL
    )

/*++

Routine Description:

    Removes an entry or section from a file log.

Arguments:

    FileLogHandle - supplies the handle to the file log, as returned
        by SetupInitializeLogFile(). The caller must not have passed
        SPFILELOG_QUERYONLY when the log file was opened/initialized.

    LogSectionName - Supplies the name for a logical grouping of files
        within the log. Required for non-system logs; optional for the
        system log.

    TargetFilename - supplies the name of the file as it exists on the
        Target. This name should be in whatever format is meaningful to
        the caller. If not specified, the entire section specified by
        LogSectionName is removed. Removing the main section for NT files
        is not allowed.

Return Value:

    Boolean value indicating outcome. If FALSE, the caller can use
    GetLastError() to get extended error info.

--*/

{
    DWORD Err;
    PSETUP_FILE_LOG FileLog;
    BOOL b;

    FileLog = (PSETUP_FILE_LOG)FileLogHandle;

    try {

        Err = NO_ERROR;
        if(FileLog->QueryOnly) {
            Err = ERROR_INVALID_PARAMETER;
        } else {
            if(!LogSectionName) {
                if(FileLog->SystemLog) {
                    LogSectionName = NtFileSectionName;
                } else {
                    Err = ERROR_INVALID_PARAMETER;
                }
            }
            //
            // Diallow removing the main nt files section.
            //
            if((Err == NO_ERROR)
            && FileLog->SystemLog
            && !TargetFilename
            && !lstrcmpi(LogSectionName,NtFileSectionName))
            {
                Err = ERROR_INVALID_PARAMETER;
            }
        }

        if(Err == NO_ERROR) {
            b = WritePrivateProfileString(LogSectionName,TargetFilename,NULL,FileLog->FileName);
            Err = b ? NO_ERROR : GetLastError();
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    return(Err == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupQueryFileLogA(
    IN  HSPFILELOG       FileLogHandle,
    IN  PCSTR            LogSectionName,   OPTIONAL
    IN  PCSTR            TargetFilename,
    IN  SetupFileLogInfo DesiredInfo,
    OUT PSTR             DataOut,          OPTIONAL
    IN  DWORD            ReturnBufferSize,
    OUT PDWORD           RequiredSize      OPTIONAL
    )
{
    PWSTR logsectionname;
    PWSTR targetfilename;
    PWSTR unicodeBuffer = NULL;
    DWORD unicodeSize = 2048;
    PSTR ansidata;
    DWORD requiredsize;
    DWORD d;
    BOOL b;

    d = pSetupCaptureAndConvertAnsiArg(TargetFilename,&targetfilename);
    if(d != NO_ERROR) {
        SetLastError(d);
        return(FALSE);
    }
    if(LogSectionName) {
        d = pSetupCaptureAndConvertAnsiArg(LogSectionName,&logsectionname);
        if(d != NO_ERROR) {
            MyFree(targetfilename);
            SetLastError(d);
            return(FALSE);
        }
    } else {
        logsectionname = NULL;
    }
    unicodeBuffer = MyMalloc(unicodeSize*sizeof(WCHAR));
    if(!unicodeBuffer) {
        if(targetfilename) {
            MyFree(targetfilename);
        }
        if(logsectionname) {
            MyFree(logsectionname);
        }
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    b = SetupQueryFileLogW(
            FileLogHandle,
            logsectionname,
            targetfilename,
            DesiredInfo,
            unicodeBuffer,
            unicodeSize,
            &requiredsize
            );

    d = GetLastError();

    if(b) {
        d = NO_ERROR;

        if(ansidata = pSetupUnicodeToAnsi(unicodeBuffer)) {

            requiredsize = lstrlenA(ansidata)+1;

            if(RequiredSize) {
                try {
                    *RequiredSize = requiredsize;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    b = FALSE;
                    d = ERROR_INVALID_PARAMETER;
                }
            }

            if(b && DataOut) {
                if(ReturnBufferSize >= requiredsize) {
                    if(!lstrcpyA(DataOut,ansidata)) {
                        //
                        // lstrcpy faulted, ReturnBuffer must be invalid
                        //
                        d = ERROR_INVALID_PARAMETER;
                        b = FALSE;
                    }
                } else {
                    d = ERROR_INSUFFICIENT_BUFFER;
                    b = FALSE;
                }
            }

            MyFree(ansidata);
        } else {
            b = FALSE;
            d = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    MyFree(targetfilename);
    if(logsectionname) {
        MyFree(logsectionname);
    }
    if(unicodeBuffer) {
        MyFree(unicodeBuffer);
    }

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupQueryFileLogW(
    IN  HSPFILELOG       FileLogHandle,
    IN  PCWSTR           LogSectionName,   OPTIONAL
    IN  PCWSTR           TargetFilename,
    IN  SetupFileLogInfo DesiredInfo,
    OUT PWSTR            DataOut,          OPTIONAL
    IN  DWORD            ReturnBufferSize,
    OUT PDWORD           RequiredSize      OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(FileLogHandle);
    UNREFERENCED_PARAMETER(LogSectionName);
    UNREFERENCED_PARAMETER(TargetFilename);
    UNREFERENCED_PARAMETER(DesiredInfo);
    UNREFERENCED_PARAMETER(DataOut);
    UNREFERENCED_PARAMETER(ReturnBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupQueryFileLog(
    IN  HSPFILELOG       FileLogHandle,
    IN  PCTSTR           LogSectionName,   OPTIONAL
    IN  PCTSTR           TargetFilename,
    IN  SetupFileLogInfo DesiredInfo,
    OUT PTSTR            DataOut,          OPTIONAL
    IN  DWORD            ReturnBufferSize,
    OUT PDWORD           RequiredSize      OPTIONAL
    )

/*++

Routine Description:

     Returns information from a setup file log.

Arguments:

    FileLogHandle - supplies handle to open file log, as returned by
        SetupInitializeFileLog().

    LogSectionName - required for non-system logs; if not specified
        for the system log a default is supplied. Supplies the name
        for a logical grouping within the log that is meaningful
        to the caller.

    TargetFilename - supplies name of file for which log information
        is desired.

    DesiredInfo - supplies an ordinal indicating what information
        is desired about the file.

    DataOut - If specified, points to a buffer that receives the
        requested information for the file. Note that not all info
        is provided for every file; an error is not returned if an entry
        for the file exists in the log but is empty.

    ReturnBufferSize - supplies size of the buffer (in chars) pointed to
        by DataOut. If the buffer is too small and DataOut is specified,
        no data is stored and the function returns FALSE. If DataOut is
        not specified this value is ignored.

    RequiredSize - receives the number of characters (including the
        terminating nul) required to hold the result.

Return Value:

    Boolean value indicating result. If FALSE, extended error info is
    available from GetLastError().

--*/

{
    DWORD Err;
    PSETUP_FILE_LOG FileLog;
    BOOL b;
    TCHAR ProfileValue[2*MAX_PATH];
    INT n;
    DWORD d;
    PTCHAR Field,End,Info;
    UINT InfoLength;
    BOOL Quoted;

    FileLog = (PSETUP_FILE_LOG)FileLogHandle;

    try {
        //
        // Validate arguments.
        // Section name must be supplied for non-system log.
        //
        if((!FileLog->SystemLog && !LogSectionName)
        || (DesiredInfo >= SetupFileLogMax) || !TargetFilename) {
            Err = ERROR_INVALID_PARAMETER;
        } else {

            if(!LogSectionName) {
                MYASSERT(FileLog->SystemLog);
                LogSectionName = NtFileSectionName;
            }

            //
            // Query the log file via profile API.
            //
            d = GetPrivateProfileString(
                    LogSectionName,
                    TargetFilename,
                    TEXT(""),
                    ProfileValue,
                    sizeof(ProfileValue)/sizeof(ProfileValue[0]),
                    FileLog->FileName
                    );

            if(d) {
                //
                // We want to retreive the Nth item in the value we just
                // retreived, where N is based on what the caller wants.
                // This routine assumes that the SetupFileLogInfo enum is
                // in the same order as items appear in a line in the log!
                //
                Field = ProfileValue;
                n = 0;

                nextfield:
                //
                // Find the end of the current field, which is
                // the first comma, or the end of the value.
                // Skip leading spaces.
                //
                while(*Field == TEXT(' ')) {
                    Field++;
                }
                End = Field;
                Quoted = FALSE;
                while(*End) {
                    if(*End == TEXT('\"')) {
                        Quoted = !Quoted;
                    } else {
                        if(!Quoted && *End == TEXT(',')) {
                            //
                            // Got the end of the field.
                            //
                            break;
                        }
                    }
                    End++;
                }
                //
                // At this point, Field points to the start of the field
                // and End points at the character that terminated it.
                //
                if(n == DesiredInfo) {
                    Info = Field;
                    InfoLength = (UINT)(End-Field);
                    //
                    // Compensate for trailing space.
                    //
                    while (*--End == TEXT(' ')) {
                        InfoLength--;
                    }
                } else {
                    //
                    // Skip trailing spaces and the comma, if any.
                    //
                    while(*End == ' ') {
                        End++;
                    }
                    if(*End == ',') {
                        //
                        // More fields exist.
                        //
                        Field = End+1;
                        n++;
                        goto nextfield;
                    } else {
                        //
                        // Item doesn't exist.
                        //
                        Info = TEXT("");
                        InfoLength = 0;
                    }
                }

                if(RequiredSize) {
                    *RequiredSize = InfoLength+1;
                }
                Err = NO_ERROR;
                if(DataOut) {
                    if(ReturnBufferSize > InfoLength) {
                        lstrcpyn(DataOut,Info,InfoLength+1);
                    } else {
                        Err = ERROR_INSUFFICIENT_BUFFER;
                    }
                }
            } else {
                Err = ERROR_FILE_NOT_FOUND;
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\fileq1.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    fileq1.c

Abstract:

    Miscellaneous setup file queue routines.

Author:

    Ted Miller (tedm) 15-Feb-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


HSPFILEQ
WINAPI
SetupOpenFileQueue(
    VOID
    )

/*++

Routine Description:

    Create a setup file queue.

Arguments:

    None.

Return Value:

    Handle to setup file queue. INVALID_HANDLE_VALUE if error occurs (GetLastError reports the error)

--*/

{
    PSP_FILE_QUEUE Queue = NULL;
    DWORD rc;
    DWORD status = ERROR_INVALID_DATA;

    try {
        //
        // Allocate a queue structure.
        //
        Queue = MyMalloc(sizeof(SP_FILE_QUEUE));
        if(!Queue) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            leave;
        }
        ZeroMemory(Queue,sizeof(SP_FILE_QUEUE));

        //
        // Create a string table for this queue.
        //
        Queue->StringTable = pSetupStringTableInitialize();
        if(!Queue->StringTable) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            leave;
        }

        Queue->TargetLookupTable = pSetupStringTableInitializeEx( sizeof(SP_TARGET_ENT), 0 );
        if(!Queue->TargetLookupTable) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            leave;
        }
        Queue->BackupInfID = -1;        // no Backup INF
        Queue->BackupInstanceID = -1;   // no Backup INF
        Queue->RestorePathID = -1;      // no Restore directory

        Queue->Flags = FQF_TRY_SIS_COPY;
        Queue->SisSourceDirectory = NULL;
        Queue->SisSourceHandle = INVALID_HANDLE_VALUE;

        Queue->Signature = SP_FILE_QUEUE_SIG;

        //
        // Retrieve the codesigning policy currently in effect (policy in
        // effect is for non-driver signing behavior until we are told
        // otherwise).
        //
        Queue->DriverSigningPolicy = pSetupGetCurrentDriverSigningPolicy(FALSE);

        //
        // Initialize the device description field to the null string id.
        //
        Queue->DeviceDescStringId = -1;

        //
        // Initialize the override catalog filename to the null string id.
        //
        Queue->AltCatalogFile = -1;

        //
        // Createa a generic log context
        //
        rc = CreateLogContext(NULL, TRUE, &Queue->LogContext);
        if (rc != NO_ERROR) {
            status = rc;
            leave;
        }

        status = NO_ERROR;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing; this just allows us to catch errors
        //
    }

    if (status == NO_ERROR) {
        //
        // The address of the queue structure is the queue handle.
        //
        return(Queue);
    }
    //
    // failure cleanup
    //
    if (Queue != NULL) {
        if (Queue->StringTable) {
            pSetupStringTableDestroy(Queue->StringTable);
        }
        if (Queue->TargetLookupTable) {
            pSetupStringTableDestroy(Queue->TargetLookupTable);
        }
        if(Queue->LogContext) {
            DeleteLogContext(Queue->LogContext);
        }
        MyFree(Queue);
    }
    //
    // return with this on error
    //
    SetLastError(status);
    return (HSPFILEQ)INVALID_HANDLE_VALUE;
}


BOOL
WINAPI
SetupCloseFileQueue(
    IN HSPFILEQ QueueHandle
    )

/*++

Routine Description:

    Destroy a setup file queue. Enqueued operations are not performed.

Arguments:

    QueueHandle - supplies handle to setup file queue to be destroyed.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.  Presently, the only error that can be
    encountered is ERROR_INVALID_HANDLE or ERROR_FILEQUEUE_LOCKED, which will occur if someone (typically,
    a device installation parameter block) is referencing this queue handle.

--*/

{
    PSP_FILE_QUEUE Queue;
    PSP_FILE_QUEUE_NODE Node,NextNode;
    PSP_DELAYMOVE_NODE DelayMoveNode,NextDelayMoveNode;
    PSP_UNWIND_NODE UnwindNode,NextUnwindNode;
    PSOURCE_MEDIA_INFO Media,NextMedia;
    BOOL b;
    PSPQ_CATALOG_INFO Catalog,NextCatalog;

    DWORD status = ERROR_INVALID_HANDLE;

    if (QueueHandle == NULL || QueueHandle == (HSPFILEQ)INVALID_HANDLE_VALUE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Queue = (PSP_FILE_QUEUE)QueueHandle;

    //
    // Primitive queue validation.
    //
    b = TRUE;
    try {
        if(Queue->Signature != SP_FILE_QUEUE_SIG) {
            b = FALSE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if(!b) {
        SetLastError(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    try {
        //
        // Don't close the queue if someone is still referencing it.
        //
        if(Queue->LockRefCount) {
            WriteLogEntry(
                Queue->LogContext,
                SETUP_LOG_ERROR,
                MSG_LOG_FILEQUEUE_IN_USE,
                NULL);       // text message

            status = ERROR_FILEQUEUE_LOCKED;
            leave;
        }

        //
        // we may have some unwinding to do, but assume we succeeded
        // ie, delete temp files and cleanup memory used
        //
        pSetupUnwindAll(Queue, TRUE);

        //
        // If the queue wasn't committed and we are backup aware and this is
        // a device install then we need to clean up any backup directories and
        // registry entries that we created since we have already unwound the
        // queue up above.
        //
        if (!(Queue->Flags & FQF_QUEUE_ALREADY_COMMITTED) &&
            (Queue->Flags & FQF_DEVICE_BACKUP)) {

            pSetupCleanupBackup(Queue);
        }

        Queue->Signature = 0;

        //
        // Free the DelayMove list
        //
        for(DelayMoveNode = Queue->DelayMoveQueue; DelayMoveNode; DelayMoveNode = NextDelayMoveNode) {
            NextDelayMoveNode = DelayMoveNode->NextNode;
            MyFree(DelayMoveNode);
        }
        //
        // Free the queue nodes.
        //
        for(Node=Queue->DeleteQueue; Node; Node=NextNode) {
            NextNode = Node->Next;
            MyFree(Node);
        }
        for(Node=Queue->RenameQueue; Node; Node=NextNode) {
            NextNode = Node->Next;
            MyFree(Node);
        }
        // Free the backup queue nodes
        for(Node=Queue->BackupQueue; Node; Node=NextNode) {
            NextNode = Node->Next;
            MyFree(Node);
        }
        // Free the unwind queue nodes
        for(UnwindNode=Queue->UnwindQueue; UnwindNode; UnwindNode=NextUnwindNode) {
            NextUnwindNode = UnwindNode->NextNode;
            MyFree(UnwindNode);
        }

        //
        // Free the media structures and associated copy queues.
        //
        for(Media=Queue->SourceMediaList; Media; Media=NextMedia) {

            for(Node=Media->CopyQueue; Node; Node=NextNode) {
                NextNode = Node->Next;
                MyFree(Node);
            }

            NextMedia = Media->Next;
            MyFree(Media);
        }

        //
        // Free the catalog nodes.
        //
        for(Catalog=Queue->CatalogList; Catalog; Catalog=NextCatalog) {

            NextCatalog = Catalog->Next;
            MyFree(Catalog);
        }

        //
        // Free the validation platform information (if any)
        //
        if(Queue->ValidationPlatform) {
            MyFree(Queue->ValidationPlatform);
        }

        //
        // Free the string table.
        //
        pSetupStringTableDestroy(Queue->StringTable);
        //
        // (jamiehun) Free the target lookup table.
        //
        pSetupStringTableDestroy(Queue->TargetLookupTable);

        //
        // Free SIS-related fields.
        //
        if (Queue->SisSourceHandle != INVALID_HANDLE_VALUE) {
            CloseHandle(Queue->SisSourceHandle);
        }
        if (Queue->SisSourceDirectory != NULL) {
            MyFree(Queue->SisSourceDirectory);
        }

        //
        // Unreference log context
        //
        DeleteLogContext(Queue->LogContext);

        //
        // Release the crypto context (if there is one)
        //
        if(Queue->hCatAdmin) {
            CryptCATAdminReleaseContext(Queue->hCatAdmin, 0);
        }

        //
        // Release the handle to the bad driver database (if there is one)
        //
#ifdef UNICODE
        if(Queue->hSDBDrvMain) {
            SdbReleaseDatabase(Queue->hSDBDrvMain);
        }
#else
        MYASSERT(!(Queue->hSDBDrvMain));
#endif

        //
        // Free the queue structure itself.
        //
        MyFree(Queue);

        status = NO_ERROR;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing; this just allows us to catch errors
        //
    }

    if (status != NO_ERROR) {
        SetLastError(status);
        return FALSE;
    }
    return TRUE;
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupSetFileQueueAlternatePlatformA(
    IN HSPFILEQ                QueueHandle,
    IN PSP_ALTPLATFORM_INFO_V2 AlternatePlatformInfo,      OPTIONAL
    IN PCSTR                   AlternateDefaultCatalogFile OPTIONAL
    )
{
    PWSTR UAlternateDefaultCatalogFile;
    DWORD Err;

    if(AlternateDefaultCatalogFile) {
        Err = pSetupCaptureAndConvertAnsiArg(AlternateDefaultCatalogFile,
                                             &UAlternateDefaultCatalogFile
                                            );
        if(Err != NO_ERROR) {
            SetLastError(Err);
            return FALSE;
        }
    } else {
        UAlternateDefaultCatalogFile = NULL;
    }

    if(SetupSetFileQueueAlternatePlatformW(QueueHandle,
                                           AlternatePlatformInfo,
                                           UAlternateDefaultCatalogFile)) {
        Err = NO_ERROR;
    } else {
        Err = GetLastError();
        MYASSERT(Err != NO_ERROR);
    }

    if(UAlternateDefaultCatalogFile) {
        MyFree(UAlternateDefaultCatalogFile);
    }

    SetLastError(Err);

    return (Err == NO_ERROR);
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupSetFileQueueAlternatePlatformW(
    IN HSPFILEQ                QueueHandle,
    IN PSP_ALTPLATFORM_INFO_V2 AlternatePlatformInfo,      OPTIONAL
    IN PCWSTR                  AlternateDefaultCatalogFile OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(QueueHandle);
    UNREFERENCED_PARAMETER(AlternatePlatformInfo);
    UNREFERENCED_PARAMETER(AlternateDefaultCatalogFile);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupSetFileQueueAlternatePlatform(
    IN HSPFILEQ                QueueHandle,
    IN PSP_ALTPLATFORM_INFO_V2 AlternatePlatformInfo,      OPTIONAL
    IN PCTSTR                  AlternateDefaultCatalogFile OPTIONAL
    )

/*++

Routine Description:

    This API associates the specified file queue with an alternate platform in
    order to allow for non-native signature verification (e.g., verifying Win98
    files on Windows NT, verifying x86 Windows NT files on Alpha, etc.).  The
    verification is done using the corresponding catalog files specified via
    platform-specific CatalogFile= entries in the source media descriptor INFs
    (i.e., INFs containing [SourceDisksNames] and [SourceDisksFiles] sections
    used when queueing files to be copied).

    The caller may also optionally specify a default catalog file, to be used
    for verification of files that have no associated catalog, thus would
    otherwise be globally validated (e.g., files queued up from the system
    layout.inf).  A side-effect of this is that INFs with no CatalogFile= entry
    are considered valid, even if they exist outside of %windir%\Inf.

    If this file queue is subsequently committed, the nonnative catalogs will be
    installed into the system catalog database, just as native catalogs would.

Arguments:

    QueueHandle - supplies a handle to the file queue with which the alternate
        platform is to be associated.

    AlternatePlatformInfo - optionally, supplies the address of a structure
        containing information regarding the alternate platform that is to be
        used for subsequent validation of files contained in the specified file
        queue.  If this parameter is not supplied, then the queue's association
        with an alternate platform is reset, and is reverted back to the default
        (i.e., native) environment.  This information is also used in
        determining the appropriate platform-specific CatalogFile= entry to be
        used when finding out which catalog file is applicable for a particular
        source media descriptor INF.

        (NOTE: caller may actually pass in a V1 struct instead--we detect this
        case and convert the V1 struct into a V2 one.)

    AlternateDefaultCatalogFile - optionally, supplies the full path to the
        catalog file to be used for verification of files contained in the
        specified file queue that are not associated with any particular catalog
        (hence would normally be globally validated).

        If this parameter is NULL, then the file queue will no longer be
        associated with any 'override' catalog, and all validation will take
        place normally (i.e., using the standard rules for digital signature
        verification via system-supplied and 3rd-party provided INFs/CATs).

        If this alternate default catalog is still associated with the file
        queue at commit time, it will be installed using its present name, and
        will overwrite any existing installed catalog file having that name.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    PSP_FILE_QUEUE Queue;
    DWORD Err;
    TCHAR PathBuffer[MAX_PATH];
    DWORD RequiredSize;
    PTSTR TempCharPtr;
    LONG AltCatalogStringId;
    PSPQ_CATALOG_INFO CatalogNode;
    LPCTSTR InfFullPath;
    SP_ALTPLATFORM_INFO_V2 AltPlatformInfoV2;

    Err = NO_ERROR; // assume success

    try {
        Queue = (PSP_FILE_QUEUE)QueueHandle;

        //
        // Now validate the AlternatePlatformInfo parameter.
        //
        if(AlternatePlatformInfo) {

            if(AlternatePlatformInfo->cbSize != sizeof(SP_ALTPLATFORM_INFO_V2)) {
                //
                // The caller may have passed us in a Version 1 struct, or they
                // may have passed us in bad data...
                //
                if(AlternatePlatformInfo->cbSize == sizeof(SP_ALTPLATFORM_INFO_V1)) {
                    //
                    // Flags/Reserved field is reserved in V1
                    //
                    if(AlternatePlatformInfo->Reserved) {
                        Err = ERROR_INVALID_PARAMETER;
                        goto clean0;
                    }
                    //
                    // Convert the caller-supplied data into Version 2 format.
                    //
                    ZeroMemory(&AltPlatformInfoV2, sizeof(AltPlatformInfoV2));

                    AltPlatformInfoV2.cbSize                = sizeof(SP_ALTPLATFORM_INFO_V2);
                    AltPlatformInfoV2.Platform              = ((PSP_ALTPLATFORM_INFO_V1)AlternatePlatformInfo)->Platform;
                    AltPlatformInfoV2.MajorVersion          = ((PSP_ALTPLATFORM_INFO_V1)AlternatePlatformInfo)->MajorVersion;
                    AltPlatformInfoV2.MinorVersion          = ((PSP_ALTPLATFORM_INFO_V1)AlternatePlatformInfo)->MinorVersion;
                    AltPlatformInfoV2.ProcessorArchitecture = ((PSP_ALTPLATFORM_INFO_V1)AlternatePlatformInfo)->ProcessorArchitecture;
                    AltPlatformInfoV2.Flags                 = 0;
                    AlternatePlatformInfo = &AltPlatformInfoV2;

                } else {
                    Err = ERROR_INVALID_USER_BUFFER;
                    goto clean0;
                }
            }

            //
            // Gotta be either Windows or Windows NT
            //
            if((AlternatePlatformInfo->Platform != VER_PLATFORM_WIN32_WINDOWS) &&
               (AlternatePlatformInfo->Platform != VER_PLATFORM_WIN32_NT)) {

                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }

            //
            // Processor had better be either i386, alpha, ia64, or amd64
            //
            if((AlternatePlatformInfo->ProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) &&
               (AlternatePlatformInfo->ProcessorArchitecture != PROCESSOR_ARCHITECTURE_ALPHA) &&
               (AlternatePlatformInfo->ProcessorArchitecture != PROCESSOR_ARCHITECTURE_IA64) &&
               (AlternatePlatformInfo->ProcessorArchitecture != PROCESSOR_ARCHITECTURE_ALPHA64) &&
               (AlternatePlatformInfo->ProcessorArchitecture != PROCESSOR_ARCHITECTURE_AMD64)) {

                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }

            //
            // MajorVersion field must be non-zero (MinorVersion field can be
            // anything)
            //
            if(!AlternatePlatformInfo->MajorVersion) {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }
            //
            // Validate structure parameter flags (bits indicating what
            // parts of the structure are valid).
            //
            if((AlternatePlatformInfo->Flags & ~ (SP_ALTPLATFORM_FLAGS_VERSION_RANGE)) != 0) {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }
            //
            // fill in version validation range if none supplied by caller
            //
            if((AlternatePlatformInfo->Flags & SP_ALTPLATFORM_FLAGS_VERSION_RANGE) == 0) {
                //
                // If caller does not know about FirstValidate*Version,
                // version upper and lower bounds are equal.
                //
                AlternatePlatformInfo->FirstValidatedMajorVersion = AlternatePlatformInfo->MajorVersion;
                AlternatePlatformInfo->FirstValidatedMinorVersion = AlternatePlatformInfo->MinorVersion;
                AlternatePlatformInfo->Flags |= SP_ALTPLATFORM_FLAGS_VERSION_RANGE;
            }


        }

        //
        // OK, the platform info structure checks out.  Now, associate the
        // default catalog (if supplied) with the file queue, otherwise reset
        // any existing association with a default catalog.
        //
        if(AlternateDefaultCatalogFile) {

            RequiredSize = GetFullPathName(AlternateDefaultCatalogFile,
                                           SIZECHARS(PathBuffer),
                                           PathBuffer,
                                           &TempCharPtr
                                          );

            if(!RequiredSize) {
                Err = GetLastError();
                goto clean0;
            } else if(RequiredSize >= SIZECHARS(PathBuffer)) {
                MYASSERT(0);
                Err = ERROR_BUFFER_OVERFLOW;
                goto clean0;
            }

            AltCatalogStringId = pSetupStringTableAddString(Queue->StringTable,
                                            PathBuffer,
                                            STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                           );
            if(AltCatalogStringId == -1) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }

        } else {
            //
            // Caller has not supplied an alternate default catalog, so reset
            // any existing association.
            //
            AltCatalogStringId = -1;
        }

        //
        // If we've been passed an AltPlatformInfo structure, then we need to
        // process each existing catalog node in our file queue and retrieve the
        // appropriate platform-specific CatalogFile= entry.
        //
        if(AlternatePlatformInfo) {

            for(CatalogNode = Queue->CatalogList; CatalogNode; CatalogNode = CatalogNode->Next) {
                //
                // Get the INF name associated with this catalog node.
                //
                InfFullPath = pSetupStringTableStringFromId(Queue->StringTable,
                                                      CatalogNode->InfFullPath
                                                     );

                Err = pGetInfOriginalNameAndCatalogFile(NULL,
                                                        InfFullPath,
                                                        NULL,
                                                        NULL,
                                                        0,
                                                        PathBuffer,
                                                        SIZECHARS(PathBuffer),
                                                        AlternatePlatformInfo
                                                       );
                if(Err != NO_ERROR) {
                    goto clean0;
                }

                if(*PathBuffer) {
                    //
                    // We retrieved a CatalogFile= entry that's pertinent for
                    // the specified platform from the INF.
                    //
                    CatalogNode->AltCatalogFileFromInfPending = pSetupStringTableAddString(
                                                                  Queue->StringTable,
                                                                  PathBuffer,
                                                                  STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                                                 );

                    if(CatalogNode->AltCatalogFileFromInfPending == -1) {
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        goto clean0;
                    }

                } else {
                    //
                    // The INF doesn't specify a CatalogFile= entry for this
                    // platform.
                    //
                    CatalogNode->AltCatalogFileFromInfPending = -1;
                }
            }

            //
            // OK, if we get to this point, then we've added all the strings to
            // the string table we need to, and we're done opening INFs.  We
            // should encounter no problems from this point forward, so it's
            // safe to commit our changes.
            //
            for(CatalogNode = Queue->CatalogList; CatalogNode; CatalogNode = CatalogNode->Next) {
                CatalogNode->AltCatalogFileFromInf = CatalogNode->AltCatalogFileFromInfPending;
            }
        }

        Queue->AltCatalogFile = AltCatalogStringId;

        //
        // Finally, update (or reset) the AltPlatformInfo structure in the queue
        // with the data the caller specified.
        //
        if(AlternatePlatformInfo) {
            CopyMemory(&(Queue->AltPlatformInfo),
                       AlternatePlatformInfo,
                       sizeof(SP_ALTPLATFORM_INFO_V2)
                      );
            Queue->Flags |= FQF_USE_ALT_PLATFORM;
        } else {
            Queue->Flags &= ~FQF_USE_ALT_PLATFORM;
        }

        //
        // Clear the "catalog verifications done" flags in the queue, so that
        // we'll redo them the next time _SetupVerifyQueuedCatalogs is called.
        // Also, clear the FQF_DIGSIG_ERRORS_NOUI flag so that the next
        // verification error we encounter will relayed to the user (based on
        // policy).
        //
        Queue->Flags &= ~(FQF_DID_CATALOGS_OK | FQF_DID_CATALOGS_FAILED | FQF_DIGSIG_ERRORS_NOUI);

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    SetLastError(Err);

    return (Err == NO_ERROR);
}


BOOL
pSetupSetQueueFlags(
    IN HSPFILEQ QueueHandle,
    IN DWORD flags
    )
{
    PSP_FILE_QUEUE Queue;
    DWORD Err = NO_ERROR;

    try {
        Queue = (PSP_FILE_QUEUE)QueueHandle;
        Queue->Flags = flags;

        if (Queue->Flags & FQF_QUEUE_FORCE_BLOCK_POLICY) {
            Queue->DriverSigningPolicy = DRIVERSIGN_BLOCKING;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
          Err = GetExceptionCode();
    }

    SetLastError(Err);
    return (Err == NO_ERROR);

}


DWORD
pSetupGetQueueFlags(
    IN HSPFILEQ QueueHandle
    )
{
    PSP_FILE_QUEUE Queue;

    try {
        Queue = (PSP_FILE_QUEUE)QueueHandle;
        return Queue->Flags;
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    return 0;

}


WINSETUPAPI
BOOL
WINAPI
SetupGetFileQueueCount(
    IN  HSPFILEQ            FileQueue,
    IN  UINT                SubQueueFileOp,
    OUT PUINT               NumOperations
    )
/*++

Routine Description:

    This API obtains a count of a sub-queue in advance of submitting the queue

Arguments:

    FileQueue      - Queue to query
    SubQueueFileOp - operation
                      FILEOP_COPY FILEOP_DELETE FILEOP_RENAME FILEOP_BACKUP
    NumOperations  - ptr to hold the return value - number of files in that queue

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    PSP_FILE_QUEUE Queue;
    BOOL b;
    DWORD status = ERROR_INVALID_HANDLE;

    if (FileQueue == NULL || FileQueue == (HSPFILEQ)INVALID_HANDLE_VALUE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }
    Queue = (PSP_FILE_QUEUE)FileQueue;

    b = TRUE;

    try {
        if(Queue->Signature != SP_FILE_QUEUE_SIG) {
            b = FALSE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if(!b) {
        SetLastError(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    try {

        //
        // Invalid/NULL NumOperations ptr will be caught by exception handling
        //
        switch (SubQueueFileOp) {
            case FILEOP_COPY:
                *NumOperations=Queue->CopyNodeCount;
                status = NO_ERROR;
                break;

            case FILEOP_RENAME:
                *NumOperations=Queue->RenameNodeCount;
                status = NO_ERROR;
                break;

            case FILEOP_DELETE:
                *NumOperations=Queue->DeleteNodeCount;
                status = NO_ERROR;
                break;

            case FILEOP_BACKUP:
                *NumOperations=Queue->BackupNodeCount;
                status = NO_ERROR;
                break;

            default:
                status = ERROR_INVALID_PARAMETER;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
          status = ERROR_INVALID_DATA;
    }
    SetLastError(status);
    return (status==NO_ERROR);
}


WINSETUPAPI
BOOL
WINAPI
SetupGetFileQueueFlags(
    IN  HSPFILEQ            FileQueue,
    OUT PDWORD              Flags
    )
/*++

Routine Description:

    This API obtains public viewable flags for FileQueue

Arguments:

    FileQueue      - Queue to query
    Flags          - ptr to hold the return value - flags, includes:
                     SPQ_FLAG_BACKUP_AWARE
                     SPQ_FLAG_ABORT_IF_UNSIGNED

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    PSP_FILE_QUEUE Queue;
    BOOL b;
    DWORD status = ERROR_INVALID_HANDLE;

    if (FileQueue == NULL || FileQueue == (HSPFILEQ)INVALID_HANDLE_VALUE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }
    Queue = (PSP_FILE_QUEUE)FileQueue;

    b = TRUE;

    try {
        if(Queue->Signature != SP_FILE_QUEUE_SIG) {
            b = FALSE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if(!b) {
        SetLastError(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    try {

        //
        // Invalid/NULL Flags ptr will be caught by exception handling
        //
        *Flags = (((Queue->Flags & FQF_BACKUP_AWARE)      ? SPQ_FLAG_BACKUP_AWARE      : 0)  |
                  ((Queue->Flags & FQF_ABORT_IF_UNSIGNED) ? SPQ_FLAG_ABORT_IF_UNSIGNED : 0)  |
                  ((Queue->Flags & FQF_FILES_MODIFIED   ) ? SPQ_FLAG_FILES_MODIFIED    : 0));

        status = NO_ERROR;

    } except(EXCEPTION_EXECUTE_HANDLER) {
          status = ERROR_INVALID_DATA;
    }
    SetLastError(status);
    return (status==NO_ERROR);
}


VOID
ResetQueueState(
    IN PSP_FILE_QUEUE Queue
    )

/*++

Routine Description:

    This routine resets an aborted filequeue so that it can be committed yet
    again.  This is used when a client (e.g., newdev) requests that queue
    committal be aborted when unsigned files are encountered (i.e., so they can
    set a system restore point), then they want to re-commit the file queue
    once the restore point has been established.

Arguments:

    Queue - supplies a pointer to the file queue to be reset.

Return Value:

    none.

--*/

{
    PSP_DELAYMOVE_NODE DelayMoveNode, NextDelayMoveNode;
    PSP_UNWIND_NODE UnwindNode, NextUnwindNode;
    PSP_FILE_QUEUE_NODE QueueNode;
    PSOURCE_MEDIA_INFO Media;
    SP_TARGET_ENT TargetInfo;

    //
    // There should be no need to unwind the queue here, as that should've
    // already happened when we failed during _SetupCommitFileQueue.
    //

    //
    // Free the DelayMove list
    //
    for(DelayMoveNode = Queue->DelayMoveQueue; DelayMoveNode; DelayMoveNode = NextDelayMoveNode) {
        NextDelayMoveNode = DelayMoveNode->NextNode;
        MyFree(DelayMoveNode);
    }
    Queue->DelayMoveQueue = Queue->DelayMoveQueueTail = NULL;

    //
    // Free the unwind queue nodes
    //
    for(UnwindNode = Queue->UnwindQueue; UnwindNode; UnwindNode = NextUnwindNode) {
        NextUnwindNode = UnwindNode->NextNode;
        MyFree(UnwindNode);
    }
    Queue->UnwindQueue = NULL;

    //
    // Clear the "catalog verifications done" flags in the queue, so that we'll
    // redo them the next time _SetupVerifyQueuedCatalogs is called.
    //
    Queue->Flags &= ~(FQF_DID_CATALOGS_OK | FQF_DID_CATALOGS_FAILED);

    //
    // Clear the flag that indicates we've already committed the file queue.
    //
    Queue->Flags &= ~FQF_QUEUE_ALREADY_COMMITTED;

    //
    // Clear the flag that indicates we didn't successfully back-up all files.
    // Since we already unwound out of that queue committal, this flag is no
    // longer relevant (although we'll quite likely hit this problem again when
    // the client re-commits the file queue).
    //
    Queue->Flags &= ~FQF_BACKUP_INCOMPLETE;

    //
    // Clear certain internal flags on all the file queue nodes.
    //
#define QUEUE_NODE_BITS_TO_RESET (  INUSE_IN_USE           \
                                  | INUSE_INF_WANTS_REBOOT \
                                  | IQF_PROCESSED          \
                                  | IQF_MATCH              \
                                  | IQF_LAST_MATCH )
    //
    // Note:  neither the IQF_ALLOW_UNSIGNED nor IQF_TARGET_PROTECTED flags
    // should be set for any queue nodes, because we should only do this if we
    // previously committed the queue with the SPQ_FLAG_ABORT_IF_UNSIGNED flag
    // was set.  In this scenario, we never check to see if a file is protected,
    // nor do we request that an exception be granted).
    //

    for(QueueNode = Queue->BackupQueue; QueueNode; QueueNode = QueueNode->Next) {
        QueueNode->InternalFlags &= ~QUEUE_NODE_BITS_TO_RESET;
        MYASSERT(!(QueueNode->InternalFlags & (IQF_ALLOW_UNSIGNED | IQF_TARGET_PROTECTED)));
    }

    for(QueueNode = Queue->DeleteQueue; QueueNode; QueueNode = QueueNode->Next) {
        QueueNode->InternalFlags &= ~QUEUE_NODE_BITS_TO_RESET;
        MYASSERT(!(QueueNode->InternalFlags & (IQF_ALLOW_UNSIGNED | IQF_TARGET_PROTECTED)));
    }

    for(QueueNode = Queue->RenameQueue; QueueNode; QueueNode = QueueNode->Next) {
        QueueNode->InternalFlags &= ~QUEUE_NODE_BITS_TO_RESET;
        MYASSERT(!(QueueNode->InternalFlags & (IQF_ALLOW_UNSIGNED | IQF_TARGET_PROTECTED)));
    }

    for(Media = Queue->SourceMediaList; Media; Media = Media->Next) {
        for(QueueNode = Media->CopyQueue; QueueNode; QueueNode = QueueNode->Next) {
            QueueNode->InternalFlags &= ~QUEUE_NODE_BITS_TO_RESET;
            MYASSERT(!(QueueNode->InternalFlags & (IQF_ALLOW_UNSIGNED | IQF_TARGET_PROTECTED)));
        }
    }

    //
    // Iterate through all the entries in the TargetLookupTable string table,
    // and clear some flags in their associated SP_TARGET_ENT data.
    //
    pSetupStringTableEnum(Queue->TargetLookupTable,
                          &TargetInfo,
                          sizeof(TargetInfo),
                          pSetupResetTarget,
                          (LPARAM)0
                         );

}


WINSETUPAPI
BOOL
WINAPI
SetupSetFileQueueFlags(
    IN  HSPFILEQ            FileQueue,
    IN  DWORD               FlagMask,
    IN  DWORD               Flags
    )
/*++

Routine Description:

    This API modifies public settable flags for FileQueue

Arguments:

    FileQueue      - Queue in which flags are to be set.
    FlagMask       - Flags to modify, must not be zero
    Flags          - New value of flags, must be a subset of FlagMask

                     FlagMask and Flags include:
                     SPQ_FLAG_BACKUP_AWARE
                     SPQ_FLAG_ABORT_IF_UNSIGNED

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    PSP_FILE_QUEUE Queue;
    BOOL b;
    DWORD status = ERROR_INVALID_HANDLE;
    DWORD RemapFlags = 0;
    DWORD RemapFlagMask = 0;

    if (FileQueue == NULL || FileQueue == (HSPFILEQ)INVALID_HANDLE_VALUE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }
    Queue = (PSP_FILE_QUEUE)FileQueue;

    b = TRUE;

    try {
        if(Queue->Signature != SP_FILE_QUEUE_SIG) {
            b = FALSE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if(!b) {
        SetLastError(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    try {

        //
        // validate FlagMask and Flags
        //
        if (!FlagMask
            || (FlagMask & ~SPQ_FLAG_VALID)
            || (Flags & ~FlagMask)) {
            status = ERROR_INVALID_PARAMETER;
            leave;
        }
        //
        // remap SPQ_FLAG_BACKUP_AWARE to FQF_BACKUP_AWARE
        //
        if (FlagMask & SPQ_FLAG_BACKUP_AWARE) {
            RemapFlagMask |= FQF_BACKUP_AWARE;
            if (Flags & SPQ_FLAG_BACKUP_AWARE) {
                RemapFlags |= FQF_BACKUP_AWARE;
            }
        }
        //
        // remap SPQ_FLAG_ABORT_IF_UNSIGNED to FQF_ABORT_IF_UNSIGNED
        //
        if (FlagMask & SPQ_FLAG_ABORT_IF_UNSIGNED) {
            RemapFlagMask |= FQF_ABORT_IF_UNSIGNED;
            if (Flags & SPQ_FLAG_ABORT_IF_UNSIGNED) {
                RemapFlags |= FQF_ABORT_IF_UNSIGNED;
            } else {
                //
                // If we're clearing this flag, then we also need to go reset
                // the queue state so that it can be committed again, just like
                // it was the very first time (except that no driver signing UI
                // will happen in the subsequent queue committal).
                //
                if(Queue->Flags & FQF_ABORT_IF_UNSIGNED) {
                    ResetQueueState(Queue);
                }
            }
        }
        //
        // remap SPQ_FLAG_FILES_MODIFIED to FQF_FILES_MODIFIED
        // allows explicit setting/resetting of this state
        // which is informational only
        //
        if (FlagMask & SPQ_FLAG_FILES_MODIFIED) {
            RemapFlagMask |= FQF_FILES_MODIFIED;
            if (Flags & SPQ_FLAG_FILES_MODIFIED) {
                RemapFlags |= FQF_FILES_MODIFIED;
            }
        }

        //
        // now modify real flags
        //
        Queue->Flags = (Queue->Flags & ~RemapFlagMask) | RemapFlags;

        status = NO_ERROR;

    } except(EXCEPTION_EXECUTE_HANDLER) {
          status = ERROR_INVALID_DATA;
    }

    SetLastError(status);
    return (status==NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\fileq3.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    fileq3.c

Abstract:

    Setup file queue routines for enqueing delete and rename
    operations.

Author:

    Ted Miller (tedm) 15-Feb-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


BOOL
_SetupQueueDelete(
    IN HSPFILEQ QueueHandle,
    IN PCTSTR   PathPart1,
    IN PCTSTR   PathPart2,      OPTIONAL
    IN UINT     Flags
    )

/*++

Routine Description:

    Place a delete operation on a setup file queue.

    Note that delete operations are assumed to be on fixed media.
    No prompting will be performed for delete operations when the
    queue is committed.

Arguments:

    QueueHandle - supplies a handle to a setup file queue, as returned
        by SetupOpenFileQueue.

    PathPart1 - Supplies the first part of the path of
        the file to be deleted. If PathPart2 is not specified, then
        this is the full path of the file to be deleted.

    PathPart2 - if specified, supplies the second part of the path
        of the file to be deleted. This is concatenated to PathPart1
        to form the full pathname.

    Flags - specified flags controlling delete operation.

        DELFLG_IN_USE - if the file is in use, queue it for delayed
            delete, on next reboot. Otherwise in-use files are not deleted.

        DELFLG_IN_USE1 - same behavior as DELFLG_IN_USE--used when the
            same file list section is used for both a CopyFiles and DelFiles.
            (Since DELFLG_IN_USE (0x1) is also COPYFLG_WARN_IF_SKIP!)

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information.

--*/

{
    PSP_FILE_QUEUE Queue;
    PSP_FILE_QUEUE_NODE QueueNode, TempNode, PrevQueueNode;

    Queue = (PSP_FILE_QUEUE)QueueHandle;

    //
    // Allocate a queue structure.
    //
    QueueNode = MyMalloc(sizeof(SP_FILE_QUEUE_NODE));
    if(!QueueNode) {
        goto clean0;
    }

    ZeroMemory(QueueNode, sizeof(SP_FILE_QUEUE_NODE));

    //
    // Operation is delete.
    //
    QueueNode->Operation = FILEOP_DELETE;

    //
    // Initialize unused fields.
    //
    QueueNode->SourceRootPath = -1;
    QueueNode->SourcePath = -1;
    QueueNode->SourceFilename = -1;

    //
    // Set internal flag to indicate whether we should queue a delayed delete
    // for this file if it's in-use.
    //
    QueueNode->InternalFlags = (Flags & (DELFLG_IN_USE|DELFLG_IN_USE1)) ?
        IQF_DELAYED_DELETE_OK : 0;

    //
    // NOTE: When adding the following strings to the string table, we cast away
    // their CONST-ness to avoid a compiler warning.  Since we are adding them
    // case-sensitively, we are guaranteed they will not be modified.
    //

    //
    // Set up the target directory.
    //
    QueueNode->TargetDirectory = pSetupStringTableAddString(Queue->StringTable,
                                                      (PTSTR)PathPart1,
                                                      STRTAB_CASE_SENSITIVE
                                                     );
    if(QueueNode->TargetDirectory == -1) {
        goto clean1;
    }

    //
    // Set up the target filename.
    //
    if(PathPart2) {
        QueueNode->TargetFilename = pSetupStringTableAddString(Queue->StringTable,
                                                         (PTSTR)PathPart2,
                                                         STRTAB_CASE_SENSITIVE
                                                        );
        if(QueueNode->TargetFilename == -1) {
            goto clean1;
        }
    } else {
        QueueNode->TargetFilename = -1;
    }

    //
    // Link the node onto the end of the delete queue.
    //
    QueueNode->Next = NULL;
    if(Queue->DeleteQueue) {
        //
        // Check to see if this same rename operation has already been enqueued,
        // and if so, get rid of the new one, to avoid duplicates.  NOTE: We
        // don't check the "InternalFlags" field, since if the node already
        // exists in the queue (based on all the other relevant fields comparing
        // successfully), then any internal flags that were set on the
        // previously-existing node should be preserved (i.e., our new node
        // always is created with InternalFlags set to zero).
        //
        for(TempNode=Queue->DeleteQueue, PrevQueueNode = NULL;
            TempNode;
            PrevQueueNode = TempNode, TempNode=TempNode->Next) {

            if((TempNode->TargetDirectory == QueueNode->TargetDirectory) &&
               (TempNode->TargetFilename == QueueNode->TargetFilename)) {
                //
                // We've found a duplicate.  However, we need to make sure that
                // if our new node specifies "delayed delete OK", then the
                // existing node has that internal flag set as well.
                //
                MYASSERT(!(QueueNode->InternalFlags & ~IQF_DELAYED_DELETE_OK));

                if(QueueNode->InternalFlags & IQF_DELAYED_DELETE_OK) {
                    TempNode->InternalFlags |= IQF_DELAYED_DELETE_OK;
                }

                //
                // Kill the newly-created queue node and return success.
                //
                MyFree(QueueNode);
                return TRUE;
            }
        }
        MYASSERT(PrevQueueNode);
        PrevQueueNode->Next = QueueNode;
    } else {
        Queue->DeleteQueue = QueueNode;
    }

    Queue->DeleteNodeCount++;

    return(TRUE);

clean1:
    MyFree(QueueNode);
clean0:
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return(FALSE);
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupQueueDeleteA(
    IN HSPFILEQ QueueHandle,
    IN PCSTR    PathPart1,
    IN PCSTR    PathPart2       OPTIONAL
    )
{
    PWSTR p1,p2;
    DWORD d;
    BOOL b;

    b = FALSE;
    d = pSetupCaptureAndConvertAnsiArg(PathPart1,&p1);
    if(d == NO_ERROR) {

        if(PathPart2) {
            d = pSetupCaptureAndConvertAnsiArg(PathPart2,&p2);
        } else {
            p2 = NULL;
        }

        if(d == NO_ERROR) {

            b = _SetupQueueDelete(QueueHandle,p1,p2,0);
            d = GetLastError();

            if(p2) {
                MyFree(p2);
            }
        }

        MyFree(p1);
    }

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupQueueDeleteW(
    IN HSPFILEQ QueueHandle,
    IN PCWSTR   PathPart1,
    IN PCWSTR   PathPart2       OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(QueueHandle);
    UNREFERENCED_PARAMETER(PathPart1);
    UNREFERENCED_PARAMETER(PathPart2);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupQueueDelete(
    IN HSPFILEQ QueueHandle,
    IN PCTSTR   PathPart1,
    IN PCTSTR   PathPart2       OPTIONAL
    )

/*++

Routine Description:

    Place a delete operation on a setup file queue.

    Note that delete operations are assumed to be on fixed media.
    No prompting will be performed for delete operations when the
    queue is committed.

Arguments:

    QueueHandle - supplies a handle to a setup file queue, as returned
        by SetupOpenFileQueue.

    PathPart1 - Supplies the first part of the path of
        the file to be deleted. If PathPart2 is not specified, then
        this is the full path of the file to be deleted.

    PathPart2 - if specified, supplies the second part of the path
        of the file to be deleted. This is concatenated to PathPart1
        to form the full pathname.

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information.

--*/

{
    PTSTR p1,p2;
    DWORD d;
    BOOL b;

    b = FALSE;
    d = CaptureStringArg(PathPart1,&p1);
    if(d == NO_ERROR) {

        if(PathPart2) {
            d = CaptureStringArg(PathPart2,&p2);
        } else {
            p2 = NULL;
        }

        if(d == NO_ERROR) {

            b = _SetupQueueDelete(QueueHandle,p1,p2,0);
            d = GetLastError();

            if(p2) {
                MyFree(p2);
            }
        }

        MyFree(p1);
    }

    SetLastError(d);
    return(b);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupQueueDeleteSectionA(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,  OPTIONAL
    IN PCSTR    Section
    )
{
    PWSTR section;
    DWORD d;
    BOOL b;

    d = pSetupCaptureAndConvertAnsiArg(Section,&section);
    if(d == NO_ERROR) {

        b = SetupQueueDeleteSectionW(QueueHandle,InfHandle,ListInfHandle,section);
        d = GetLastError();

        MyFree(section);

    } else {
        b = FALSE;
    }

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupQueueDeleteSectionW(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,  OPTIONAL
    IN PCWSTR   Section
    )
{
    UNREFERENCED_PARAMETER(QueueHandle);
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(ListInfHandle);
    UNREFERENCED_PARAMETER(Section);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupQueueDeleteSection(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,   OPTIONAL
    IN PCTSTR   Section
    )

/*++

Routine Description:

    Queue an entire section in an inf file for delete. The section must be
    in delete-section format and the inf file must contain [DestinationDirs].

Arguments:

    QueueHandle - supplies a handle to a setup file queue, as returned
        by SetupOpenFileQueue.

    InfHandle - supplies a handle to an open inf file, that contains the
        [DestinationDirs] section.

    ListInfHandle - if specified, supplies a handle to the open inf file
        containing the section named by Section. If not specified this
        section is assumed to be in InfHandle.

    Section - supplies the name of the section to be queued for delete.

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information. Some files may have been queued successfully.

--*/

{
    BOOL b;
    PTSTR TargetDirectory;
    PCTSTR TargetFilename;
    INFCONTEXT LineContext;
    DWORD SizeRequired;
    DWORD rc;
    UINT Flags;

    if(!ListInfHandle) {
        ListInfHandle = InfHandle;
    }

    //
    // The section has to exist and there sas to be at least one line in it.
    //
    b = SetupFindFirstLine(ListInfHandle,Section,NULL,&LineContext);
    if(!b) {
        rc = GetLastError();
        pSetupLogSectionError(ListInfHandle,NULL,NULL,QueueHandle,Section,MSG_LOG_NOSECTION_DELETE,rc,NULL);
        SetLastError(ERROR_SECTION_NOT_FOUND); // this is not the real error, but might be what caller expects
        return(FALSE);
    }

    //
    // Iterate every line in the section.
    //
    do {
        //
        // Get the target filename out of the line.
        //
        TargetFilename = pSetupFilenameFromLine(&LineContext,FALSE);
        if(!TargetFilename) {
            SetLastError(ERROR_INVALID_DATA);
            return(FALSE);
        }

        //
        // Determine the target path for the file.
        //
        b = SetupGetTargetPath(InfHandle,&LineContext,NULL,NULL,0,&SizeRequired);
        if(!b) {
            return(FALSE);
        }
        TargetDirectory = MyMalloc(SizeRequired*sizeof(TCHAR));
        if(!TargetDirectory) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(FALSE);
        }
        SetupGetTargetPath(InfHandle,&LineContext,NULL,TargetDirectory,SizeRequired,NULL);

        //
        // If present flags are field 4
        //
        if(!SetupGetIntField(&LineContext,4,(PINT)&Flags)) {
            Flags = 0;
        }

        //
        // Add to queue.
        //
        b = _SetupQueueDelete(QueueHandle,TargetDirectory,TargetFilename,Flags);

        rc = GetLastError();
        MyFree(TargetDirectory);

        if(!b) {
            SetLastError(rc);
            return(FALSE);
        }

    } while(SetupFindNextLine(&LineContext,&LineContext));

    return(TRUE);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupQueueRenameA(
    IN HSPFILEQ QueueHandle,
    IN PCSTR    SourcePath,
    IN PCSTR    SourceFilename, OPTIONAL
    IN PCSTR    TargetPath,     OPTIONAL
    IN PCSTR    TargetFilename
    )
{
    PWSTR sourcepath = NULL;
    PWSTR sourcefilename = NULL;
    PWSTR targetpath = NULL;
    PWSTR targetfilename = NULL;
    DWORD d;
    BOOL b;

    b = FALSE;
    d = pSetupCaptureAndConvertAnsiArg(SourcePath,&sourcepath);
    if((d == NO_ERROR) && SourceFilename) {
        d = pSetupCaptureAndConvertAnsiArg(SourceFilename,&sourcefilename);
    }
    if((d == NO_ERROR) && TargetPath) {
        d = pSetupCaptureAndConvertAnsiArg(TargetPath,&targetpath);
    }
    if(d == NO_ERROR) {
        d = pSetupCaptureAndConvertAnsiArg(TargetFilename,&targetfilename);
    }

    if(d == NO_ERROR) {

        b = SetupQueueRenameW(QueueHandle,sourcepath,sourcefilename,targetpath,targetfilename);
        d = GetLastError();
    }

    if(sourcepath) {
        MyFree(sourcepath);
    }
    if(sourcefilename) {
        MyFree(sourcefilename);
    }
    if(targetpath) {
        MyFree(targetpath);
    }
    if(targetfilename) {
        MyFree(targetfilename);
    }

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupQueueRenameW(
    IN HSPFILEQ QueueHandle,
    IN PCWSTR   SourcePath,
    IN PCWSTR   SourceFilename, OPTIONAL
    IN PCWSTR   TargetPath,     OPTIONAL
    IN PCWSTR   TargetFilename
    )
{
    UNREFERENCED_PARAMETER(QueueHandle);
    UNREFERENCED_PARAMETER(SourcePath);
    UNREFERENCED_PARAMETER(SourceFilename);
    UNREFERENCED_PARAMETER(TargetPath);
    UNREFERENCED_PARAMETER(TargetFilename);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupQueueRename(
    IN HSPFILEQ QueueHandle,
    IN PCTSTR   SourcePath,
    IN PCTSTR   SourceFilename, OPTIONAL
    IN PCTSTR   TargetPath,     OPTIONAL
    IN PCTSTR   TargetFilename
    )

/*++

Routine Description:

    Place a rename operation on a setup file queue.

    Note that rename operations are assumed to be on fixed media.
    No prompting will be performed for rename operations when the
    queue is committed.

Arguments:

    QueueHandle - supplies a handle to a setup file queue, as returned
        by SetupOpenFileQueue.

    SourcePath - Supplies the source path of the file to be renamed.
        If SourceFilename is specified, this is the part part only.
        If SourceFilename is not specified, this is the fully-qualified
        path.

    SourceFilename - if specified, supplies the filename part of the
        file to be renamed. If not specified, SourcePath is the fully-
        qualified path of the file to be renamed.

    TargetPath - if specified, supplies the target directory, and the rename
        is actually a move operation. If not specified, then the rename
        takes place without moving the file.

    TargetFilename - supplies the new name (no path) of the file.

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information.

--*/

{
    PSP_FILE_QUEUE Queue;
    PSP_FILE_QUEUE_NODE QueueNode, TempNode, PrevQueueNode;
    DWORD err = NO_ERROR;

    //
    // validate parameters so that we return correct error
    //
    if(SourcePath == NULL || TargetFilename == NULL) {
        err = ERROR_INVALID_PARAMETER;
        goto clean0;
    }

    Queue = (PSP_FILE_QUEUE)QueueHandle;

    //
    // Allocate a queue structure.
    //
    QueueNode = MyMalloc(sizeof(SP_FILE_QUEUE_NODE));
    if(!QueueNode) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }

    ZeroMemory(QueueNode, sizeof(SP_FILE_QUEUE_NODE));

    //
    // Operation is rename.
    //
    QueueNode->Operation = FILEOP_RENAME;

    //
    // Initialize unused SourceRootPath field.
    //
    QueueNode->SourceRootPath = -1;

    //
    // NOTE: When adding the following strings to the string table, we cast away
    // their CONST-ness to avoid a compiler warning.  Since we are adding them
    // case-sensitively, we are guaranteed they will not be modified.
    //

    //
    // Set up the source path.
    //
    QueueNode->SourcePath = pSetupStringTableAddString(Queue->StringTable,
                                                 (PTSTR)SourcePath,
                                                 STRTAB_CASE_SENSITIVE
                                                );
    if(QueueNode->SourcePath == -1) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean1;
    }

    //
    // Set up the source filename.
    //
    if(SourceFilename) {
        QueueNode->SourceFilename = pSetupStringTableAddString(Queue->StringTable,
                                                         (PTSTR)SourceFilename,
                                                         STRTAB_CASE_SENSITIVE
                                                        );
        if(QueueNode->SourceFilename == -1) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean1;
        }
    } else {
        QueueNode->SourceFilename = -1;
    }

    //
    // Set up the target directory.
    //
    if(TargetPath) {
        QueueNode->TargetDirectory = pSetupStringTableAddString(Queue->StringTable,
                                                          (PTSTR)TargetPath,
                                                          STRTAB_CASE_SENSITIVE
                                                         );
        if(QueueNode->TargetDirectory == -1) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean1;
        }
    } else {
        QueueNode->TargetDirectory = -1;
    }

    //
    // Set up the target filename.
    //
    QueueNode->TargetFilename = pSetupStringTableAddString(Queue->StringTable,
                                                     (PTSTR)TargetFilename,
                                                     STRTAB_CASE_SENSITIVE
                                                    );
    if(QueueNode->TargetFilename == -1) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean1;
    }


    //
    // Link the node onto the end of the rename queue.
    //
    QueueNode->Next = NULL;
    if(Queue->RenameQueue) {
        //
        // Check to see if this same rename operation has already been enqueued,
        // and if so, get rid of the new one, to avoid duplicates.  NOTE: We
        // don't check the "InternalFlags" field, since if the node already
        // exists in the queue (based on all the other relevant fields comparing
        // successfully), then any internal flags that were set on the
        // previously-existing node should be preserved (i.e., our new node
        // always is created with InternalFlags set to zero).
        //
        for(TempNode=Queue->RenameQueue, PrevQueueNode = NULL;
            TempNode;
            PrevQueueNode = TempNode, TempNode=TempNode->Next) {

            if((TempNode->SourcePath == QueueNode->SourcePath) &&
               (TempNode->SourceFilename == QueueNode->SourceFilename) &&
               (TempNode->TargetDirectory == QueueNode->TargetDirectory) &&
               (TempNode->TargetFilename == QueueNode->TargetFilename)) {
                //
                // We have a duplicate--kill the newly-created queue node and
                // return success.
                //
                MYASSERT(TempNode->StyleFlags == 0);
                MyFree(QueueNode);
                return TRUE;
            }
        }
        MYASSERT(PrevQueueNode);
        PrevQueueNode->Next = QueueNode;
    } else {
        Queue->RenameQueue = QueueNode;
    }

    Queue->RenameNodeCount++;

    return(TRUE);

clean1:
    MyFree(QueueNode);
clean0:
    SetLastError(err);
    return(FALSE);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupQueueRenameSectionA(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,  OPTIONAL
    IN PCSTR    Section
    )
{
    PWSTR section;
    DWORD d;
    BOOL b;

    d = pSetupCaptureAndConvertAnsiArg(Section,&section);
    if(d == NO_ERROR) {

        b = SetupQueueRenameSectionW(QueueHandle,InfHandle,ListInfHandle,section);
        d = GetLastError();

        MyFree(section);
    } else {
        b = FALSE;
    }

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupQueueRenameSectionW(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,  OPTIONAL
    IN PCWSTR   Section
    )
{
    UNREFERENCED_PARAMETER(QueueHandle);
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(ListInfHandle);
    UNREFERENCED_PARAMETER(Section);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupQueueRenameSection(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,   OPTIONAL
    IN PCTSTR   Section
    )

/*++

Routine Description:

    Queue an entire section in an inf file for delete. The section must be
    in delete-section format and the inf file must contain [DestinationDirs].

    The format of a rename list section dictates that only renames within the
    same directory is supported (ie, you cannot queue file moves with this API).

Arguments:

    QueueHandle - supplies a handle to a setup file queue, as returned
        by SetupOpenFileQueue.

    InfHandle - supplies a handle to an open inf file, that contains the
        [DestinationDirs] section.

    ListInfHandle - if specified, supplies a handle to the open inf file
        containing the section named by Section. If not specified this
        section is assumed to be in InfHandle.

    Section - supplies the name of the section to be queued for delete.

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information.

--*/

{
    BOOL b;
    INFCONTEXT LineContext;
    PCTSTR TargetFilename;
    PCTSTR SourceFilename;
    PTSTR Directory;
    DWORD SizeRequired;
    DWORD rc;

    if(!ListInfHandle) {
        ListInfHandle = InfHandle;
    }

    //
    // The section has to exist and there has to be at least one line in it.
    //
    b = SetupFindFirstLine(ListInfHandle,Section,NULL,&LineContext);
    if(!b) {
        rc = GetLastError();
        pSetupLogSectionError(ListInfHandle,NULL,NULL,QueueHandle,Section,MSG_LOG_NOSECTION_RENAME,rc,NULL);
        SetLastError(ERROR_SECTION_NOT_FOUND); // this is not the real error, but might be what caller expects
        return(FALSE);
    }

    //
    // Iterate every line in the section.
    //
    do {
        //
        // Get the target filename out of the line.
        //
        TargetFilename = pSetupFilenameFromLine(&LineContext,FALSE);
        if(!TargetFilename) {
            SetLastError(ERROR_INVALID_DATA);
            return(FALSE);
        }
        //
        // Get source filename out of the line.
        //
        SourceFilename = pSetupFilenameFromLine(&LineContext,TRUE);
        if(!SourceFilename || (*SourceFilename == 0)) {
            SetLastError(ERROR_INVALID_DATA);
            return(FALSE);
        }

        //
        // Determine the path of the file.
        //
        b = SetupGetTargetPath(InfHandle,&LineContext,NULL,NULL,0,&SizeRequired);
        if(!b) {
            return(FALSE);
        }
        Directory = MyMalloc(SizeRequired*sizeof(TCHAR));
        if(!Directory) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(FALSE);
        }
        SetupGetTargetPath(InfHandle,&LineContext,NULL,Directory,SizeRequired,NULL);

        //
        // Add to queue.
        //
        b = SetupQueueRename(
                QueueHandle,
                Directory,
                SourceFilename,
                NULL,
                TargetFilename
                );

        rc = GetLastError();
        MyFree(Directory);

        if(!b) {
            SetLastError(rc);
            return(FALSE);
        }

    } while(SetupFindNextLine(&LineContext,&LineContext));

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\fileq2.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    fileq2.c

Abstract:

    Setup file queue routines for enqueing copy operations.

Author:

    Ted Miller (tedm) 15-Feb-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


#define STR_DRIVERCACHEINF  TEXT("drvindex.inf")


//
// Structure used with _SetupQueueCopy
//
typedef struct _SP_FILE_COPY_PARAMS_AEX {
    DWORD    cbSize;
    HSPFILEQ QueueHandle;
    PCSTR    SourceRootPath;     OPTIONAL
    PCSTR    SourcePath;         OPTIONAL
    PCSTR    SourceFilename;
    PCSTR    SourceDescription;  OPTIONAL
    PCSTR    SourceTagfile;      OPTIONAL
    PCSTR    TargetDirectory;
    PCSTR    TargetFilename;     OPTIONAL
    DWORD    CopyStyle;
    HINF     LayoutInf;          OPTIONAL
    PCSTR    SecurityDescriptor; OPTIONAL
    DWORD    SourceFlags;        OPTIONAL
    BOOL     SourceFlagsSet;     OPTIONAL // we need this flag since SourceFlags may be zero
    PCSTR    CacheName;
} SP_FILE_COPY_PARAMS_AEX, *PSP_FILE_COPY_PARAMS_AEX;

typedef struct _SP_FILE_COPY_PARAMS_WEX {
    DWORD    cbSize;
    HSPFILEQ QueueHandle;
    PCWSTR   SourceRootPath;     OPTIONAL
    PCWSTR   SourcePath;         OPTIONAL
    PCWSTR   SourceFilename;
    PCWSTR   SourceDescription;  OPTIONAL
    PCWSTR   SourceTagfile;      OPTIONAL
    PCWSTR   TargetDirectory;
    PCWSTR   TargetFilename;     OPTIONAL
    DWORD    CopyStyle;
    HINF     LayoutInf;          OPTIONAL
    PCWSTR   SecurityDescriptor; OPTIONAL
    DWORD    SourceFlags;        OPTIONAL
    BOOL     SourceFlagsSet;     OPTIONAL // we need this flag since SourceFlags may be zero
    PCWSTR   CacheName;
} SP_FILE_COPY_PARAMS_WEX, *PSP_FILE_COPY_PARAMS_WEX;

#ifdef UNICODE
typedef SP_FILE_COPY_PARAMS_WEX SP_FILE_COPY_PARAMSEX;
typedef PSP_FILE_COPY_PARAMS_WEX PSP_FILE_COPY_PARAMSEX;
#else
typedef SP_FILE_COPY_PARAMS_AEX SP_FILE_COPY_PARAMSEX;
typedef PSP_FILE_COPY_PARAMS_AEX PSP_FILE_COPY_PARAMSEX;
#endif




BOOL
_SetupQueueCopy(
    IN PSP_FILE_COPY_PARAMSEX CopyParams,
    IN PINFCONTEXT          LayoutLineContext, OPTIONAL
    IN HINF                 AdditionalInfs     OPTIONAL
    );

PSOURCE_MEDIA_INFO
pSetupQueueSourceMedia(
    IN OUT PSP_FILE_QUEUE      Queue,
    IN OUT PSP_FILE_QUEUE_NODE QueueNode,
    IN     LONG                SourceRootStringId,
    IN     PCTSTR              SourceDescription,   OPTIONAL
    IN     PCTSTR              SourceTagfile,       OPTIONAL
    IN     PCTSTR              SourceCabfile,       OPTIONAL
    IN     DWORD               MediaFlags
    );

BOOL
pSetupQueueSingleCopy(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,  OPTIONAL
    IN PCTSTR   SectionName,    OPTIONAL
    IN PCTSTR   SourceRootPath,
    IN PCTSTR   SourceFilename,
    IN PCTSTR   TargetFilename,
    IN DWORD    CopyStyle,
    IN PCTSTR   SecurityDescriptor,
    IN PCTSTR   CacheName
    );

BOOL
pSetupGetSourceAllInfo(
    IN  HINF                     InfHandle,
    IN  PINFCONTEXT              LayoutLineContext, OPTIONAL
    IN  UINT                     SourceId,
    IN  PSP_ALTPLATFORM_INFO_V2  AltPlatformInfo,   OPTIONAL
    OUT PCTSTR                  *Description,
    OUT PCTSTR                  *Tagfile,
    OUT PCTSTR                  *RelativePath,
    OUT PUINT                    SourceFlags
    );

BOOL
pIsDriverCachePresent(
    IN PCTSTR DriverName,
    IN PCTSTR SubDirectory,
    OUT PTSTR DriverBuffer
    );

BOOL
pIsFileInDriverCache(
    IN  HINF   CabInf,
    IN  PCTSTR TargetFilename,
    IN  PCTSTR SubDirectory,
    OUT PCTSTR *CacheName
    );



//
// HACK ALERT!!! HACK HACK HACK!!!!
//
// There might be an override platform specified. If this is so,
// we will look for \i386, \mips, etc as the final component of the
// specified path when queuing files, and replace it with the
// override path. This is a TOTAL HACK.
//
PCTSTR PlatformPathOverride;

VOID
pSetupInitPlatformPathOverrideSupport(
    IN BOOL Init
    )
{
    if(Init) {
        PlatformPathOverride = NULL;
    } else {
        if( PlatformPathOverride ) {
            MyFree(PlatformPathOverride);
            PlatformPathOverride = NULL;
        }
    }
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupSetPlatformPathOverrideA(
    IN PCSTR Override   OPTIONAL
    )
{
    BOOL b;
    DWORD rc;
    PCWSTR p;

    if(Override) {
        rc = pSetupCaptureAndConvertAnsiArg(Override,&p);
    } else {
        p = NULL;
        rc = NO_ERROR;
    }

    if(rc == NO_ERROR) {
        b = SetupSetPlatformPathOverrideW(p);
        rc = GetLastError();
    } else {
        b = FALSE;
    }

    if(p) {
        MyFree(p);
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupSetPlatformPathOverrideW(
    IN PCWSTR Override  OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(Override);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupSetPlatformPathOverride(
    IN PCTSTR Override  OPTIONAL
    )
{
    BOOL b = FALSE;
    DWORD rc = ERROR_NOT_ENOUGH_MEMORY;
    BOOL locked = FALSE;

    try {
        EnterCriticalSection(&PlatformPathOverrideCritSect);
        locked = TRUE;
        rc = ERROR_INVALID_DATA;

        if(Override) {
            if(PlatformPathOverride) {
                MyFree(PlatformPathOverride);
                PlatformPathOverride = NULL;
            }

            try {
                b = ((PlatformPathOverride = DuplicateString(Override)) != NULL);
                if(!b) {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
                b = FALSE;
                rc = ERROR_INVALID_PARAMETER;
            }
        } else {
            if(PlatformPathOverride) {
                MyFree(PlatformPathOverride);
                PlatformPathOverride = NULL;
            }
            b = TRUE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    if(locked) {
        LeaveCriticalSection(&PlatformPathOverrideCritSect);
    } else {
        b = FALSE;
        rc = ERROR_NOT_ENOUGH_MEMORY;
    }

    if(!b) {
        SetLastError(rc);
    }
    return(b);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupQueueCopyA(
    IN HSPFILEQ QueueHandle,
    IN PCSTR    SourceRootPath,     OPTIONAL
    IN PCSTR    SourcePath,         OPTIONAL
    IN PCSTR    SourceFilename,
    IN PCSTR    SourceDescription,  OPTIONAL
    IN PCSTR    SourceTagfile,      OPTIONAL
    IN PCSTR    TargetDirectory,
    IN PCSTR    TargetFilename,     OPTIONAL
    IN DWORD    CopyStyle
    )
{
    PCWSTR sourceRootPath;
    PCWSTR sourcePath;
    PCWSTR sourceFilename;
    PCWSTR sourceDescription;
    PCWSTR sourceTagfile;
    PCWSTR targetDirectory;
    PCWSTR targetFilename;
    BOOL b;
    DWORD rc;
    SP_FILE_COPY_PARAMS_WEX CopyParams = {0};

    sourceRootPath = NULL;
    sourcePath = NULL;
    sourceFilename = NULL;
    sourceDescription = NULL;
    sourceTagfile = NULL;
    targetDirectory = NULL;
    targetFilename = NULL;
    rc = NO_ERROR;
    b = FALSE;

    if(SourceRootPath) {
        rc = pSetupCaptureAndConvertAnsiArg(SourceRootPath,&sourceRootPath);
    }
    if((rc == NO_ERROR) && SourcePath) {
        rc = pSetupCaptureAndConvertAnsiArg(SourcePath,&sourcePath);
    }
    if((rc == NO_ERROR) && SourceFilename) {
        rc = pSetupCaptureAndConvertAnsiArg(SourceFilename,&sourceFilename);
    }
    if((rc == NO_ERROR) && SourceDescription) {
        rc = pSetupCaptureAndConvertAnsiArg(SourceDescription,&sourceDescription);
    }
    if((rc == NO_ERROR) && SourceTagfile) {
        rc = pSetupCaptureAndConvertAnsiArg(SourceTagfile,&sourceTagfile);
    }
    if((rc == NO_ERROR) && TargetDirectory) {
        rc = pSetupCaptureAndConvertAnsiArg(TargetDirectory,&targetDirectory);
    }
    if((rc == NO_ERROR) && TargetFilename) {
        rc = pSetupCaptureAndConvertAnsiArg(TargetFilename,&targetFilename);
    }

    if(rc == NO_ERROR) {

        CopyParams.cbSize = sizeof(SP_FILE_COPY_PARAMS_WEX);
        CopyParams.QueueHandle = QueueHandle;
        CopyParams.SourceRootPath = sourceRootPath;
        CopyParams.SourcePath = sourcePath;
        CopyParams.SourceFilename = sourceFilename;
        CopyParams.SourceDescription = sourceDescription;
        CopyParams.SourceTagfile = sourceTagfile;
        CopyParams.TargetDirectory = targetDirectory;
        CopyParams.TargetFilename = targetFilename;
        CopyParams.CopyStyle = CopyStyle;
        CopyParams.LayoutInf = NULL;
        CopyParams.SecurityDescriptor= NULL;

        b = _SetupQueueCopy(&CopyParams, NULL, NULL);
        rc = GetLastError();
    }

    if(sourceRootPath) {
        MyFree(sourceRootPath);
    }
    if(sourcePath) {
        MyFree(sourcePath);
    }
    if(sourceFilename) {
        MyFree(sourceFilename);
    }
    if(sourceDescription) {
        MyFree(sourceDescription);
    }
    if(sourceTagfile) {
        MyFree(sourceTagfile);
    }
    if(targetDirectory) {
        MyFree(targetDirectory);
    }
    if(targetFilename) {
        MyFree(targetFilename);
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupQueueCopyW(
    IN HSPFILEQ QueueHandle,
    IN PCWSTR   SourceRootPath,     OPTIONAL
    IN PCWSTR   SourcePath,         OPTIONAL
    IN PCWSTR   SourceFilename,
    IN PCWSTR   SourceDescription,  OPTIONAL
    IN PCWSTR   SourceTagfile,      OPTIONAL
    IN PCWSTR   TargetDirectory,
    IN PCWSTR   TargetFilename,     OPTIONAL
    IN DWORD    CopyStyle
    )
{
    UNREFERENCED_PARAMETER(QueueHandle);
    UNREFERENCED_PARAMETER(SourceRootPath);
    UNREFERENCED_PARAMETER(SourcePath);
    UNREFERENCED_PARAMETER(SourceFilename);
    UNREFERENCED_PARAMETER(SourceDescription);
    UNREFERENCED_PARAMETER(SourceTagfile);
    UNREFERENCED_PARAMETER(TargetDirectory);
    UNREFERENCED_PARAMETER(TargetFilename);
    UNREFERENCED_PARAMETER(CopyStyle);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupQueueCopy(
    IN HSPFILEQ QueueHandle,
    IN PCTSTR   SourceRootPath,     OPTIONAL
    IN PCTSTR   SourcePath,         OPTIONAL
    IN PCTSTR   SourceFilename,
    IN PCTSTR   SourceDescription,  OPTIONAL
    IN PCTSTR   SourceTagfile,      OPTIONAL
    IN PCTSTR   TargetDirectory,
    IN PCTSTR   TargetFilename,     OPTIONAL
    IN DWORD    CopyStyle
    )

/*++

Routine Description:

    Place a copy operation on a setup file queue.

Arguments:

    QueueHandle - supplies a handle to a setup file queue, as returned
        by SetupOpenFileQueue.

    SourceRootPath - Supplies the root of the source for this copy,
        such as A:\ or \\FOO\BAR\BAZ.  If this parameter isn't supplied, then
        this queue node will be added to a media descriptor's queue that
        matches on SourceDescription and SourceTagfile.  (This merge will take
        place regardless of whether or not the media descriptor entry was
        already in the queue prior to calling SetupQueueCopy.)

        If there is no matching media descriptor that contains SourceRootPath
        information, the path will be set to the directory where the system was
        installed from.

    SourcePath - if specified, supplies the path relative to SourceRootPath
        where the file can be found.

    SourceFilename - supplies the filename part of the file to be copied.

    SourceDescription - if specified, supplies a description of the source
        media, to be used during disk prompts.

    SourceTagfile - if specified, supplies a tag file whose presence at
        SourceRootPath indicates the presence of the source media.
        If not specified, the file itself will be used as the tag file
        if required (tagfiles are used only for removable media).

    TargetDirectory - supplies the directory where the file is to be copied.

    TargetFilename - if specified, supplies the name of the target file.
        If not specified, the target file will have the same name as the source.

    CopyStyle - supplies flags that control the behavior of the copy operation
        for this file.

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information.

--*/

{
    SP_FILE_COPY_PARAMSEX CopyParams = {0};

    //
    // Work is done by common worker routine
    //
    CopyParams.cbSize = sizeof(SP_FILE_COPY_PARAMSEX);
    CopyParams.QueueHandle = QueueHandle;
    CopyParams.SourceRootPath = SourceRootPath;
    CopyParams.SourcePath = SourcePath;
    CopyParams.SourceFilename = SourceFilename;
    CopyParams.SourceDescription = SourceDescription;
    CopyParams.SourceTagfile = SourceTagfile;
    CopyParams.TargetDirectory = TargetDirectory;
    CopyParams.TargetFilename = TargetFilename;
    CopyParams.CopyStyle = CopyStyle;
    CopyParams.LayoutInf = NULL;
    CopyParams.SecurityDescriptor= NULL;
    CopyParams.CacheName = NULL;

    return(_SetupQueueCopy(&CopyParams, NULL, NULL));
}


BOOL
_SetupQueueCopy(
    IN PSP_FILE_COPY_PARAMSEX CopyParams,
    IN PINFCONTEXT            LayoutLineContext, OPTIONAL
    IN HINF                   AdditionalInfs     OPTIONAL
    )

/*++

Routine Description:

    Worker routine for SetupQueueCopy and friends.

Arguments:

    CopyParams - supplies a structure with information about the file
        to be queued. Fields are used as follows.

        cbSize - must be sizeof(SP_FILE_COPY_PARAMS). The caller should
            have verified this before calling this routine.

        QueueHandle - supplies a handle to a setup file queue, as returned
            by SetupOpenFileQueue.

        SourceRootPath - Supplies the root of the source for this copy,
            such as A:\ or \\FOO\BAR\BAZ.   If this field is NULL, then this
            queue node will be added to a media descriptor's queue that matches
            on SourceDescription and SourceTagfile.  (This merge will take
            place regardless of whether or not the media descriptor entry was
            already in the queue prior to calling SetupQueueCopy.)

            If there is no matching media descriptor that contains
            SourceRootPath information, the path will be set to the directory
            where the system was installed from.

        SourcePath - if specified, supplies the path relative to SourceRootPath
            where the file can be found.

        SourceFilename - supplies the filename part of the file to be copied.

        SourceDescription - if specified, supplies a description of the source
            media, to be used during disk prompts.

        SourceTagfile - if specified, supplies a tag file whose presence at
            SourceRootPath indicates the presence of the source media.
            If not specified, the file itself will be used as the tag file
            if required (tagfiles are used only for removable media).

        TargetDirectory - supplies the directory where the file is to be copied.

        TargetFilename - if specified, supplies the name of the target file.  If
            not specified, the target file will have the same name as the source.

        CopyStyle - supplies flags that control the behavior of the copy
            operation for this file.

        LayoutInf - supplies the handle to the inf which contains the source
            layout info for this file, if any.

    LayoutLineContext - if specified, this argument provides the INF context
        for the [SourceDisksFiles] entry pertaining to the file to be copied.
        If not specified, the relevant [SourceDisksFiles] entry will be searched
        for in the LayoutInf handle specified in the CopyParams structure.  This
        context must be contained within either the CopyParams->LayoutInf or
        AdditionalInfs loaded INF handles (because those are the two INFs we're
        gonna lock).  The argument is used to prevent us from having to search
        for the file to be copied in a [SourceDisksFiles] section.  The caller
        has already done that, and is either handing us the context to that INF
        entry, or has passed -1 to indicate that there is no [SourceDisksFiles]
        entry.

    AdditionalInfs - if specified, supplies an additional HINF (potentially
        containing multiple append-loaded INFs) that need to be added to our
        SPQ_CATALOG_INFO list for later validation.  Do not supply this parameter
        if it is identical to the value of the LayoutInf field in the CopyParams
        structure.

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information.

--*/

{
    PSP_FILE_QUEUE Queue;
    PSP_FILE_QUEUE_NODE QueueNode, TempNode, PrevQueueNode;
    PSOURCE_MEDIA_INFO Source;
    TCHAR TempBuffer[MAX_PATH];
    TCHAR TempSubDir[MAX_PATH];
    TCHAR SourceCabfileBuffer[MAX_PATH];
    TCHAR SourceTagfile2Buffer[MAX_PATH];
    TCHAR DriverCache[MAX_PATH] = {0};
    PCTSTR LastPathPart;
    PCTSTR p;
    int Size;
    DWORD d;
    HINF LayoutInfHandle;
    INFCONTEXT LineContext;
    BOOL b;
    PSPQ_CATALOG_INFO CatalogNode, PrevCatalogNode, LastOldCatalogNode;
    LONG l1,l2, l3, l4;
    PLOADED_INF pLoadedInfs[2];
    DWORD LoadedInfCount, i;
    PLOADED_INF pCurLoadedInf;
    DWORD MediaFlags;
    PCTSTR SourcePath, SourceRootPath;
    PCTSTR SourceTagfile = NULL;
    PCTSTR SourceCabfile = NULL;
#if defined(_X86_)
    BOOL ForcePlatform = FALSE;
#endif
    UINT SourceFlags = 0;
    PINFCONTEXT pContext = LayoutLineContext;
    INFCONTEXT tmpContext,tmpContext2;
    UINT SourceId = 0;
    BOOL locked = FALSE;

    d = NO_ERROR;
    LoadedInfCount = 0;
    MediaFlags = 0;

    try {
        MYASSERT(CopyParams->cbSize == sizeof(SP_FILE_COPY_PARAMSEX));
        Queue = (PSP_FILE_QUEUE)CopyParams->QueueHandle;
        if (Queue->Signature != SP_FILE_QUEUE_SIG) {
            d = ERROR_INVALID_PARAMETER;
        }

        LayoutInfHandle = CopyParams->LayoutInf;

        //
        // Maintain local pointers to the SourceRootPath and SourcePath strings,
        // since we may be modifying them, and we don't want to muck with the
        // caller-supplied buffer.
        //
        SourcePath = CopyParams->SourcePath;
        if(CopyParams->SourceRootPath) {
            SourceRootPath = CopyParams->SourceRootPath;
        } else {
            SourceRootPath = SystemSourcePath;
            MediaFlags |= SMI_FLAG_NO_SOURCE_ROOT_PATH;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_PARAMETER;
    }
    if(d != NO_ERROR) {
        goto clean0;
    }

    //
    // Make sure that we weren't passed the same HINF in both CopyParams->LayoutInf
    // and AdditionalInfs (just adds redundant work to process the same
    // LOADED_INF list twice).
    //
    MYASSERT(!LayoutInfHandle || (LayoutInfHandle != AdditionalInfs));

    //
    // Lock inf(s). We do a whole bunch of operations on the inf later,
    // and we don't want anything changing out from under us.
    //
    if(LayoutInfHandle) {
        if(LockInf((PLOADED_INF)LayoutInfHandle)) {
            pLoadedInfs[LoadedInfCount++] = (PLOADED_INF)LayoutInfHandle;
        } else {
            d = ERROR_INVALID_HANDLE;
            goto clean0;
        }
    }

    if(AdditionalInfs) {
        if(LockInf((PLOADED_INF)AdditionalInfs)) {
            pLoadedInfs[LoadedInfCount++] = (PLOADED_INF)AdditionalInfs;
        } else {
            d = ERROR_INVALID_HANDLE;
            goto clean0;
        }
    }

    if(!(Queue->Flags & FQF_DEVICE_INSTALL)) {
        //
        // Look through all the INFs to see if any of them are device INFs.
        //
        for(i = 0; i < LoadedInfCount; i++) {

            if(IsInfForDeviceInstall(Queue->LogContext,
                                     NULL,
                                     pLoadedInfs[i],
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL)) {
                //
                // There be device INFs here!  Mark the queue accordingly.
                //
                d = MarkQueueForDeviceInstall(CopyParams->QueueHandle,
                                              (HINF)(pLoadedInfs[i]),
                                              NULL
                                             );
                if(d == NO_ERROR) {
                    break;
                } else {
                    goto clean0;
                }
            }
        }
    }

    //
    // check if we already have a line context for the file we're adding
    // and if we don't, then try to fetch it
    //
    if (!LayoutLineContext || LayoutLineContext == (PINFCONTEXT) -1) {
        if ((LayoutInfHandle == (PINFCONTEXT) -1) || (LayoutInfHandle == NULL)) {
            pContext = NULL;
        } else {
            //
            // find the sourcerootpaths section
            //
            b = _SetupGetSourceFileLocation(
                    LayoutInfHandle,
                    NULL,
                    CopyParams->SourceFilename,
                    (Queue->Flags & FQF_USE_ALT_PLATFORM)
                       ? &(Queue->AltPlatformInfo)
                       : NULL,
                    NULL,
                    NULL,
                    0,
                    NULL,
                    &tmpContext // location in SourceDisksFiles
                    );

            pContext = b ? &tmpContext : NULL;
        }
    }
    if(pContext) {
        //
        // now obtain the source id (file,*disk*,...)
        //
        SetupGetIntField(pContext,1,&SourceId);
    }

    //
    // if we have a NULL source path, then we should check 2 things:
    // 1) source flag information, which indicates if we have a service
    //    pack or CDM source location.
    // 2) if the relative source path is null, we'll go looking for
    //    a relative path in the inf file, just in case the caller didn't
    //    supply it
    //
    // note that we use the SourceFlagsSet item in the COPY_FILE structure
    // to optimize this path -- the first item contains the source flags,
    // and the second item indicates that we shouldn't bother looking for
    // any information, we've already done a search
    //
    if (CopyParams->SourceFlagsSet) {
        SourceFlags = CopyParams->SourceFlags;
    } else if (pContext && LayoutInfHandle) {
        TCHAR data[32];

        if(pSetupGetSourceInfo(LayoutInfHandle,
                               pContext,
                               SourceId,
                               (Queue->Flags & FQF_USE_ALT_PLATFORM)
                                  ? &(Queue->AltPlatformInfo)
                                  : NULL,
                               SRCINFO_FLAGS,
                               data,
                               SIZECHARS(data),
                               NULL)) {

            pAToI(data,&SourceFlags);
        }
    }

    if (MediaFlags & SMI_FLAG_NO_SOURCE_ROOT_PATH) {
        if(pContext
           && LayoutInfHandle
           && !CopyParams->SourceFlagsSet
           && !SourcePath
           && pSetupGetSourceInfo(LayoutInfHandle,
                                  pContext,
                                  SourceId,
                                  (Queue->Flags & FQF_USE_ALT_PLATFORM)
                                     ? &(Queue->AltPlatformInfo)
                                     : NULL,
                                  SRCINFO_PATH,
                                  TempSubDir,
                                  SIZECHARS(TempSubDir),
                                  NULL)) {

           SourcePath = TempSubDir;
        }
        //
        // override the system source path with the servicepack source path
        // if the flags are set
        //
        if (SourceFlags & SRC_FLAGS_SVCPACK_SOURCE) {
            MediaFlags |= SMI_FLAG_USE_SVCPACK_SOURCE_ROOT_PATH;
            SourceRootPath = ServicePackSourcePath;
        }

    }
    //
    // now determine tag file vs cab file
    //
    SourceTagfile = CopyParams->SourceTagfile;
    if (LayoutInfHandle && pContext && (SourceFlags & SRC_FLAGS_CABFILE)) {
        //
        // the given tagfile is really a cabfile, we may have optionally a real tagfile
        //
        SourceCabfile = CopyParams->SourceTagfile;
        if(SourceCabfile == NULL || SourceCabfile[0]==TEXT('\0')) {
            //
            // cab name hasn't been determined yet
            //
            if(pSetupGetSourceInfo(LayoutInfHandle,
                                   pContext,
                                   SourceId,
                                   (Queue->Flags & FQF_USE_ALT_PLATFORM)
                                      ? &(Queue->AltPlatformInfo)
                                      : NULL,
                                   SRCINFO_TAGFILE,
                                   SourceCabfileBuffer,
                                   SIZECHARS(SourceCabfileBuffer),
                                   NULL
                                   )) {
                SourceCabfile = SourceCabfileBuffer;
            }
        }

        if(SourceCabfile == NULL || SourceCabfile[0]==TEXT('\0')) {
            //
            // cabfilename is erroneous
            //
            SourceCabfile = SourceTagfile = NULL;

        } else if(pSetupGetSourceInfo(LayoutInfHandle,
                               pContext,
                               SourceId,
                               (Queue->Flags & FQF_USE_ALT_PLATFORM)
                                  ? &(Queue->AltPlatformInfo)
                                  : NULL,
                               SRCINFO_TAGFILE2,
                               SourceTagfile2Buffer,
                               SIZECHARS(SourceTagfile2Buffer),
                               NULL
                               )) {
            SourceTagfile = SourceTagfile2Buffer;
        }
    }

    //
    // Allocate a queue structure.
    //
    QueueNode = MyMalloc(sizeof(SP_FILE_QUEUE_NODE));
    if(!QueueNode) {
        d = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }

    //
    // Operation is copy.
    //
    QueueNode->Operation = FILEOP_COPY;
    QueueNode->InternalFlags = 0;

    //
    // HACK ALERT!!! HACK HACK HACK!!!!
    //
    // There might be an override platform specified. If this is so,
    // we will look for \i386, \mips, etc as the final component of the
    // specified path, and replace it with the override path.
    // This is a TOTAL HACK.
    //
    try {
        EnterCriticalSection(&PlatformPathOverrideCritSect);
        locked = TRUE;
        if(PlatformPathOverride) {
            p = SourcePath ? SourcePath : SourceRootPath;
            if(LastPathPart = _tcsrchr(p,L'\\')) {
                LastPathPart++;
            } else {
                LastPathPart = p;
            }
#if defined(_AXP64_)
            if(!lstrcmpi(LastPathPart,TEXT("axp64"))) {
#elif defined(_ALPHA_)
            if(!lstrcmpi(LastPathPart,TEXT("alpha"))) {
#elif defined(_AMD64_)
            if(!lstrcmpi(LastPathPart,TEXT("amd64"))) {
#elif defined(_X86_)
            //
            // NEC98
            //
            // During GUI setup, source path on local disk must be "nec98",
            // so we don't override "i386".
            //
            if (IsNEC98()) {
                HKEY    hKey;
                DWORD   DataType, DataSize;
                PTSTR   ForceOverride;
                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\Setup"), 0, KEY_READ, &hKey) == ERROR_SUCCESS) {
                    if (QueryRegistryValue(hKey, TEXT("ForcePlatform"), &ForceOverride, &DataType, &DataSize)
                        == NO_ERROR) {
                        ForcePlatform = TRUE;
                        MyFree(ForceOverride);
                    }
                    RegCloseKey(hKey);
                }
                // If use driver cache, There is not i386 driver cache on NEC98.
                if ((CopyParams->CopyStyle & PSP_COPY_USE_DRIVERCACHE) && !lstrcmpi(PlatformPathOverride,TEXT("i386"))) {
                    ForcePlatform = TRUE;
                }
            }
            if((!IsNEC98() && (!lstrcmpi(LastPathPart,TEXT("x86")) || !lstrcmpi(LastPathPart,TEXT("i386"))))
            || (IsNEC98()  && (!lstrcmpi(LastPathPart,TEXT("nec98")) && !ForcePlatform))) {
#elif defined(_IA64_)
            if(!lstrcmpi(LastPathPart,TEXT("ia64"))) {
#endif
                Size = (int)(LastPathPart - p);
                Size = min(Size,MAX_PATH);
                Size *= sizeof(TCHAR);

                CopyMemory(TempBuffer,p,Size);
                TempBuffer[Size/sizeof(TCHAR)] = 0;

                //
                // If the path was something like "mips" then TempBuffer
                // will be empty and we don't want to introduce any extra
                // backslashes.
                //
                if(*TempBuffer) {
                    pSetupConcatenatePaths(TempBuffer,PlatformPathOverride,MAX_PATH,NULL);
                } else {
                    lstrcpyn(TempBuffer,PlatformPathOverride,MAX_PATH);
                }

                if(SourcePath) {
                    SourcePath = TempBuffer;
                } else {
                    SourceRootPath = TempBuffer;
                }
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_PARAMETER;
    }
    if(locked) {
        LeaveCriticalSection(&PlatformPathOverrideCritSect);
    } else {
        //
        // if lock not grabbed, this is the cause
        //
        d = ERROR_NOT_ENOUGH_MEMORY;
    }
    if(d != NO_ERROR) {
        goto clean1;
    }

    //
    // check here if the cab-file is present on the disk.
    // if it isn't, then we fall back on the current
    // sourcerootpath
    //
    if (CopyParams->CopyStyle & PSP_COPY_USE_DRIVERCACHE) {
        if (pIsDriverCachePresent(CopyParams->CacheName,
                                  SourcePath,
                                  DriverCache)) {
            SourceRootPath = DriverCache;
            MediaFlags |= SMI_FLAG_USE_LOCAL_SOURCE_CAB;
        }

        SourceTagfile = CopyParams->CacheName;
        SourceCabfile = NULL;
    }



    //
    // NOTE: When adding the following strings to the string table, we cast away
    // their CONST-ness to avoid a compiler warning.  Since we are adding them
    // case-sensitively, we are guaranteed they will not be modified.
    //
    try {
        //
        // Set up the source root path.
        //
        QueueNode->SourceRootPath = pSetupStringTableAddString(
                                        Queue->StringTable,
                                        (PTSTR)SourceRootPath,
                                        STRTAB_CASE_SENSITIVE
                                        );

        if(QueueNode->SourceRootPath == -1) {
            d = ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Set up the source path.
        //
        if(d == NO_ERROR) {
            if(SourcePath) {
                QueueNode->SourcePath = pSetupStringTableAddString(
                                            Queue->StringTable,
                                            (PTSTR)SourcePath,
                                            STRTAB_CASE_SENSITIVE
                                            );

                if(QueueNode->SourcePath == -1) {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                }
            } else {
                QueueNode->SourcePath = -1;
            }
        }

        //
        // Set up the source filename.
        //
        if(d == NO_ERROR) {
            QueueNode->SourceFilename = pSetupStringTableAddString(
                                            Queue->StringTable,
                                            (PTSTR)CopyParams->SourceFilename,
                                            STRTAB_CASE_SENSITIVE
                                            );

            if(QueueNode->SourceFilename == -1) {
                d = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        //
        // Set up the target directory.
        //
        if(d == NO_ERROR) {
            QueueNode->TargetDirectory = pSetupStringTableAddString(
                                            Queue->StringTable,
                                            (PTSTR)CopyParams->TargetDirectory,
                                            STRTAB_CASE_SENSITIVE
                                            );

            if(QueueNode->TargetDirectory == -1) {
                d = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        //
        // Set up the target filename.
        //
        if(d == NO_ERROR) {
            QueueNode->TargetFilename = pSetupStringTableAddString(
                                            Queue->StringTable,
                                            (PTSTR)(CopyParams->TargetFilename ? CopyParams->TargetFilename
                                                                               : CopyParams->SourceFilename),
                                            STRTAB_CASE_SENSITIVE
                                            );

            if(QueueNode->TargetFilename == -1) {
                d = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        //
        // Set up the Security Descriptor
        //
        if(d == NO_ERROR) {
            if( CopyParams->SecurityDescriptor){

                QueueNode->SecurityDesc = pSetupStringTableAddString(
                                              Queue->StringTable,
                                              (PTSTR)(CopyParams->SecurityDescriptor),
                                                STRTAB_CASE_SENSITIVE
                                                );

                if(QueueNode->SecurityDesc == -1) {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                }
            } else {
                QueueNode->SecurityDesc = -1;
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_PARAMETER;
    }

    if(d != NO_ERROR) {
        goto clean1;
    }

    //
    // Initialize a pointer to the end of the queue's current catalog info list.
    // We do this so that later, we can easily back-out our changes by truncating
    // the list after this node, and freeing all subsequent elements.
    //
    LastOldCatalogNode = Queue->CatalogList;
    if(LastOldCatalogNode) {
        while(LastOldCatalogNode->Next) {
            LastOldCatalogNode = LastOldCatalogNode->Next;
        }
    }

    //
    // Now process all members of our pLoadedInfs lists, adding each one to the
    // SPQ_CATALOG_INFO list (avoiding duplicates entries, of course).
    //
    for(i = 0; i < LoadedInfCount; i++) {

        for(pCurLoadedInf = pLoadedInfs[i]; pCurLoadedInf; pCurLoadedInf = pCurLoadedInf->Next) {
            //
            // First, get the (native) CatalogFile= entry from the version block
            // of this INF member.
            //
            if(pSetupGetCatalogFileValue(&(pCurLoadedInf->VersionBlock),
                                         TempBuffer,
                                         SIZECHARS(TempBuffer),
                                         NULL)) {

                l1 = pSetupStringTableAddString(Queue->StringTable,
                                          TempBuffer,
                                          STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                         );
                if(l1 == -1) {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean2;
                }
            } else {
                //
                // This INF doesn't have a CatalogFile= entry.
                //
                l1 = -1;
            }

            //
            // If this file queue is currently setup for a platform override,
            // then retrieve that CatalogFile= entry as well.
            //
            if(Queue->Flags & FQF_USE_ALT_PLATFORM) {

                if(pSetupGetCatalogFileValue(&(pCurLoadedInf->VersionBlock),
                                             TempBuffer,
                                             SIZECHARS(TempBuffer),
                                             &(Queue->AltPlatformInfo))) {

                    l3 = pSetupStringTableAddString(Queue->StringTable,
                                              TempBuffer,
                                              STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                             );
                    if(l3 == -1) {
                        d = ERROR_NOT_ENOUGH_MEMORY;
                        goto clean2;
                    }
                } else {
                    //
                    // This INF doesn't have a CatalogFile= entry.
                    //
                    l3 = -1;
                }
            } else {
                //
                // We're not in a platform override scenario.
                //
                l3 = -1;
            }

            //
            // Now, get the INF's full path.
            //
            lstrcpyn(TempBuffer, pCurLoadedInf->VersionBlock.Filename, SIZECHARS(TempBuffer));
            l2 = pSetupStringTableAddString(Queue->StringTable,
                                      TempBuffer,
                                      STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                     );
            if(l2 == -1) {
                d = ERROR_NOT_ENOUGH_MEMORY;
                goto clean2;
            }

            //
            // Finally, retrieve the INF's original name, if different than the
            // current name.
            //
            if(pCurLoadedInf->OriginalInfName) {
                lstrcpyn(TempBuffer, pCurLoadedInf->OriginalInfName, SIZECHARS(TempBuffer));
                l4 = pSetupStringTableAddString(Queue->StringTable,
                                          TempBuffer,
                                          STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                         );
                if(l4 == -1) {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean2;
                }

            } else {
                //
                // The INF's original name is the same as its current name.
                //
                l4 = -1;
            }

            b = TRUE;
            for(PrevCatalogNode=NULL, CatalogNode=Queue->CatalogList;
                CatalogNode;
                CatalogNode=CatalogNode->Next) {

                if(CatalogNode->InfFullPath == l2) {
                    //
                    // Already in there. No need to create a new node.
                    // Break out here, with CatalogNode pointing at the
                    // proper node for this catalog file.
                    //
                    // In this case, PrevCatalogNode should not be used later,
                    // but it shouldn't need to be used, since we won't be
                    // adding anything new onto the list of catalog nodes.
                    //
                    MYASSERT(CatalogNode->CatalogFileFromInf == l1);
                    MYASSERT(CatalogNode->InfOriginalName == l4);
                    b = FALSE;
                    break;
                }

                //
                // PrevCatalogNode will end up pointing to the final node
                // currently in the linked list, in the case where we need
                // to allocate a new node. This is useful so we don't have to
                // traverse the list again later when we add the new catalog
                // node to the list for this queue.
                //
                PrevCatalogNode = CatalogNode;
            }

            if(b) {
                //
                // Need to create a new catalog node.
                //
                CatalogNode = MyMalloc(sizeof(SPQ_CATALOG_INFO));
                if(!CatalogNode) {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean2;
                }
                ZeroMemory(CatalogNode, sizeof(SPQ_CATALOG_INFO));
                CatalogNode->CatalogFileFromInf = l1;
                CatalogNode->InfFullPath = l2;
                CatalogNode->AltCatalogFileFromInf = l3;
                CatalogNode->InfOriginalName = l4;
                CatalogNode->AltCatalogFileFromInfPending = -1;
                CatalogNode->InfFinalPath = -1;
                //
                // Go ahead and link the new node into the list.  If we
                // encounter a failure later, we can easily back out of this by
                // truncating the list, since we know we always append, and we
                // remembered the original list tail.
                //
                if(Queue->CatalogList) {
                    PrevCatalogNode->Next = CatalogNode;
                } else {
                    Queue->CatalogList = CatalogNode;
                }

                //
                // We've successfully added a new, as yet unvalidated, catalog
                // node.  We must therefore reset the "catalog verifications
                // done" flags so that we'll redo them later.
                //
                Queue->Flags &= ~(FQF_DID_CATALOGS_OK | FQF_DID_CATALOGS_FAILED);
            }
        }
    }

    //
    // At this point, all the INFs involved in this installation (i.e., all INFs
    // in the HINFs we were passed in) have been added to our catalog info list,
    // if they weren't already present.  Now we need to figure out which one of
    // them should be associated with the file to be copied.
    //
    // Note that we want to get the CatalogFile= line from the actual inf
    // that contains source layout information for the file being queued.
    // If the layout inf handle references multiple append-loaded infs,
    // the simple mechanism of just looking up CatalogFile= in the [Version]
    // section using the given handle might give us the value from the
    // wrong inf.
    //
    // To deal with this, we attempt to locate the file in a [SourceDisksFiles]
    // section using the given inf handle, which gives us back a line context.
    // From the line context we can easily get at the [Version] section of the
    // actual inf where the file's layout info is contained.
    //
    // This handles all cases properly. For example, a file that is shipped by
    // a vendor that replaces one of our files. If the OEM's inf has a
    // SourceDisksFiles section with the file in it, it will be found first
    // when we look the file up using the given inf handle because of the way
    // inf append-loading works.
    //
    // If we cannot find the file in a [SourceDisksFiles] section (such as
    // if there is no such section), then we can't associate the file to be
    // copied with any INF/CAT.  If we do find a [SourceDisksFiles] entry, but
    // the containing INF doesn't specify a CatalogFile= entry, then we'll go
    // ahead and associate that with a SPQ_CATALOG_INFO node for that INF, but
    // that catalog info node will have a CatalogFileFromInf field of -1.
    // That's OK for system-provided INFs, but it will fail validation if it's
    // an OEM INF (this check is done later in _SetupVerifyQueuedCatalogs).
    //
    if(LayoutInfHandle || LayoutLineContext) {
        //
        // If we already have a valid layout line context, we don't need to go
        // looking for the file in [SourceDisksFiles] again (the caller is
        // assumed to have done that already). The caller might also have told
        // us that he *knows* that there is no [SourceDisksFiles] by passing us
        // a LayoutLineContext of -1.
        //
        if(LayoutLineContext == (PINFCONTEXT)(-1)) {
            //
            // For driver signing purposes, this may be an invalid file copy,
            // because it's being copied by an INF that contains no source
            // media information, nor does it use a layout file to supply such
            // information.
            //
            // Since we don't have a LayoutLineContext, we don't know exactly
            // which INF contained the CopyFile directive that initiated this
            // copy.  However, since the context is -1, that means that it was
            // INF based (i.e., as opposed to being manually queued up via
            // SetupQueueCopy).  Therefore, we scan all the INFs passed into
            // this routine (i.e., all the INFs in the pLoadedInfs lists), and
            // check to see if they're all located in %windir%\Inf.  If any of
            // them aren't, then we mark this copynode such that later it will
            // result in a signature verification failure of
            // ERROR_NO_CATALOG_FOR_OEM_INF.
            //
            for(i = 0; i < LoadedInfCount; i++) {

                for(pCurLoadedInf = pLoadedInfs[i]; pCurLoadedInf; pCurLoadedInf = pCurLoadedInf->Next) {

                    if(pSetupInfIsFromOemLocation(pCurLoadedInf->VersionBlock.Filename,
                                            TRUE)) {
                        //
                        // INF doesn't exist in %windir%\Inf--mark the copynode
                        // for codesigning verification failure.
                        //
                        QueueNode->InternalFlags |= IQF_FROM_BAD_OEM_INF;
                        break;
                    }

                    //
                    // Even if the INF does exist in %windir%\Inf, it might have
                    // originally been an OEM INF that was installed here--check
                    // its original filename to be sure...
                    //
                    if(pCurLoadedInf->OriginalInfName &&
                       pSetupInfIsFromOemLocation(pCurLoadedInf->OriginalInfName, TRUE)) {
                        //
                        // INF was an OEM INF--in this case, too, we need to
                        // mark the copynode for codesigning verification failure.
                        //
                        QueueNode->InternalFlags |= IQF_FROM_BAD_OEM_INF;
                        break;
                    }
                }

                if(QueueNode->InternalFlags & IQF_FROM_BAD_OEM_INF) {
                    //
                    // We found an OEM INF--no need to look any further.
                    //
                    break;
                }
            }

            LayoutLineContext = NULL;

        } else {
            if(!LayoutLineContext) {
                b = _SetupGetSourceFileLocation(
                        LayoutInfHandle,
                        NULL,
                        CopyParams->SourceFilename,
                        (Queue->Flags & FQF_USE_ALT_PLATFORM)
                           ? &(Queue->AltPlatformInfo)
                           : NULL,
                        NULL,
                        NULL,
                        0,
                        NULL,
                        &LineContext
                        );

                LayoutLineContext = b ? &LineContext : NULL;
            }
        }
    }

    //
    // At this point, a non-NULL LayoutLineContext indicates that we found an
    // INF to associate with the file to be copied (via a [SourceDisksFiles]
    // entry).
    //
    if(LayoutLineContext) {

        pSetupGetPhysicalInfFilepath(LayoutLineContext,
                                     TempBuffer,
                                     SIZECHARS(TempBuffer)
                                    );

        l2 = pSetupStringTableAddString(Queue->StringTable,
                                  TempBuffer,
                                  STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                 );
        //
        // This INF path should already be in the string table, and since we're
        // supplying a writeable buffer, there's no need for memory allocation.
        // Thus the addition of this string can't fail.
        //
        MYASSERT(l2 != -1);

        for(CatalogNode=Queue->CatalogList; CatalogNode; CatalogNode=CatalogNode->Next) {
            if(CatalogNode->InfFullPath == l2) {
                break;
            }
        }

        //
        // This node had better already be in the list!
        //
        MYASSERT(CatalogNode);

        QueueNode->CatalogInfo = CatalogNode;

    } else {
        //
        // There really is no catalog info.
        //
        QueueNode->CatalogInfo = NULL;
    }

    //
    // Unlock the INF(s) here, since the code below potentially returns without
    // hitting the final clean-up code at the bottom of the routine.
    //
    for(i = 0; i < LoadedInfCount; i++) {
        UnlockInf(pLoadedInfs[i]);
    }
    LoadedInfCount = 0;

    //
    // Set up the copy style flags
    //
    QueueNode->StyleFlags = CopyParams->CopyStyle;
    QueueNode->Next = NULL;

    //
    // Set up the source media.
    //
    try {
        Source = pSetupQueueSourceMedia(
                    Queue,
                    QueueNode,
                    QueueNode->SourceRootPath,
                    CopyParams->SourceDescription,
                    SourceTagfile,
                    SourceCabfile,
                    MediaFlags
                    );
        if(!Source) {
            d = ERROR_NOT_ENOUGH_MEMORY;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_PARAMETER;
    }

    if(d != NO_ERROR) {
        goto clean2;
    }

    //
    // Link the node onto the end of the copy queue for this source media.
    //
    if(Source->CopyQueue) {
        //
        // Check to see if this same copy operation has already been enqueued
        // for this source media, and if so, get rid of the new one, to avoid
        // duplicates.  NOTE: We don't check the "InternalFlags" field, since
        // if the node already exists in the queue (based on all the other
        // fields comparing successfully), then any internal flags that were set
        // on the previously-existing node should be preserved.  (I.e., our new
        // node always is created with InternalFlags set to zero, except for
        // possibly IQF_FROM_BAD_OEM_INF, which we'll OR into the original
        // queue node's InternalFlags, if necessary.)
        //
        for(TempNode=Source->CopyQueue, PrevQueueNode = NULL;
            TempNode;
            PrevQueueNode = TempNode, TempNode=TempNode->Next) {

            if((TempNode->SourceRootPath == QueueNode->SourceRootPath) &&
               (TempNode->SourcePath == QueueNode->SourcePath) &&
               (TempNode->SourceFilename == QueueNode->SourceFilename) &&
               (TempNode->TargetDirectory == QueueNode->TargetDirectory) &&
               (TempNode->TargetFilename == QueueNode->TargetFilename) &&
               (TempNode->StyleFlags == QueueNode->StyleFlags) &&
               (TempNode->CatalogInfo == QueueNode->CatalogInfo)) {
                //
                // We have a duplicate.  OR in the IQF_FROM_BAD_OEM_INF flag
                // from our present queue node, if necessary, into the existing
                // queue node's InternalFlags.
                //
                if(QueueNode->InternalFlags & IQF_FROM_BAD_OEM_INF) {
                    TempNode->InternalFlags |= IQF_FROM_BAD_OEM_INF;
                }

                //
                // Now kill the newly-created queue node and return success.
                //
                MyFree(QueueNode);
                return TRUE;
            }
        }
        MYASSERT(PrevQueueNode);
        PrevQueueNode->Next = QueueNode;
    } else {
        Source->CopyQueue = QueueNode;
    }

    Queue->CopyNodeCount++;
    Source->CopyNodeCount++;

    return TRUE;

clean2:
    //
    // Truncate the catalog info node list at its original tail, and free all
    // subsequent (newly-added) nodes.
    //
    if(LastOldCatalogNode) {
        while(LastOldCatalogNode->Next) {
            CatalogNode = LastOldCatalogNode->Next;
            LastOldCatalogNode->Next = CatalogNode->Next;
            MyFree(CatalogNode);
        }
    }

clean1:
    MyFree(QueueNode);

clean0:
    for(i = 0; i < LoadedInfCount; i++) {
        UnlockInf(pLoadedInfs[i]);
    }

    SetLastError(d);
    return FALSE;
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupQueueCopyIndirectA(
    IN PSP_FILE_COPY_PARAMS_A CopyParams
    )
{
    SP_FILE_COPY_PARAMS_WEX copyParams;
    DWORD rc;
    BOOL b;

    ZeroMemory(&copyParams,sizeof(SP_FILE_COPY_PARAMS_W));
    rc = NO_ERROR;
    b = FALSE;

    try {
        if(CopyParams->cbSize == sizeof(SP_FILE_COPY_PARAMS_W)) {
            copyParams.QueueHandle = CopyParams->QueueHandle;
            copyParams.CopyStyle = CopyParams->CopyStyle;
            copyParams.LayoutInf = CopyParams->LayoutInf;
            copyParams.SecurityDescriptor = NULL;
        } else {
            rc = ERROR_INVALID_PARAMETER;
        }
        if((rc == NO_ERROR) && CopyParams->SourceRootPath) {
            rc = pSetupCaptureAndConvertAnsiArg(CopyParams->SourceRootPath,&copyParams.SourceRootPath);
        }
        if((rc == NO_ERROR) && CopyParams->SourcePath) {
            rc = pSetupCaptureAndConvertAnsiArg(CopyParams->SourcePath,&copyParams.SourcePath);
        }
        if((rc == NO_ERROR) && CopyParams->SourceFilename) {
            rc = pSetupCaptureAndConvertAnsiArg(CopyParams->SourceFilename,&copyParams.SourceFilename);
        }
        if((rc == NO_ERROR) && CopyParams->SourceDescription) {
            rc = pSetupCaptureAndConvertAnsiArg(CopyParams->SourceDescription,&copyParams.SourceDescription);
        }
        if((rc == NO_ERROR) && CopyParams->SourceTagfile) {
            rc = pSetupCaptureAndConvertAnsiArg(CopyParams->SourceTagfile,&copyParams.SourceTagfile);
        }
        if((rc == NO_ERROR) && CopyParams->TargetDirectory) {
            rc = pSetupCaptureAndConvertAnsiArg(CopyParams->TargetDirectory,&copyParams.TargetDirectory);
        }
        if((rc == NO_ERROR) && CopyParams->TargetFilename) {
            rc = pSetupCaptureAndConvertAnsiArg(CopyParams->TargetFilename,&copyParams.TargetFilename);
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // This is to catch the case where the CopyParams pointer goes bad.
        //
        rc = ERROR_INVALID_PARAMETER;
    }

    if(rc == NO_ERROR) {

        copyParams.cbSize = sizeof(SP_FILE_COPY_PARAMS_WEX);

        b = _SetupQueueCopy(&copyParams, NULL, NULL);
        rc = GetLastError();
    }

    if(copyParams.SourceRootPath) {
        MyFree(copyParams.SourceRootPath);
    }
    if(copyParams.SourcePath) {
        MyFree(copyParams.SourcePath);
    }
    if(copyParams.SourceFilename) {
        MyFree(copyParams.SourceFilename);
    }
    if(copyParams.SourceDescription) {
        MyFree(copyParams.SourceDescription);
    }
    if(copyParams.SourceTagfile) {
        MyFree(copyParams.SourceTagfile);
    }
    if(copyParams.TargetDirectory) {
        MyFree(copyParams.TargetDirectory);
    }
    if(copyParams.TargetFilename) {
        MyFree(copyParams.TargetFilename);
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupQueueCopyIndirectW(
    IN PSP_FILE_COPY_PARAMS_W CopyParams
    )
{
    UNREFERENCED_PARAMETER(CopyParams);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupQueueCopyIndirect(
    IN PSP_FILE_COPY_PARAMS CopyParams
    )
{
    BOOL b;
    SP_FILE_COPY_PARAMSEX copyParamsEx = {0};

    //
    // All work is done by an internal subroutine.
    // The only thing we need to do here is validate the size
    // of the structure we've been given by the caller.
    //
    try {
        b = (CopyParams->cbSize == sizeof(SP_FILE_COPY_PARAMS));
        if (b) {
            CopyMemory(&copyParamsEx,CopyParams,sizeof(SP_FILE_COPY_PARAMS));
            copyParamsEx.cbSize = sizeof(SP_FILE_COPY_PARAMSEX);
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }

    if(b) {
        b = _SetupQueueCopy(&copyParamsEx, NULL, NULL);
    } else {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return(b);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupQueueCopySectionA(
    IN HSPFILEQ QueueHandle,
    IN PCSTR    SourceRootPath,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,      OPTIONAL
    IN PCSTR    Section,
    IN DWORD    CopyStyle
    )
{
    PWSTR sourcerootpath;
    PWSTR section;
    DWORD rc;
    BOOL b;

    rc = pSetupCaptureAndConvertAnsiArg(SourceRootPath,&sourcerootpath);
    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }
    rc = pSetupCaptureAndConvertAnsiArg(Section,&section);
    if(rc != NO_ERROR) {
        MyFree(sourcerootpath);
        SetLastError(rc);
        return(FALSE);
    }

    b = SetupQueueCopySectionW(
            QueueHandle,
            sourcerootpath,
            InfHandle,
            ListInfHandle,
            section,
            CopyStyle
            );

    rc = GetLastError();

    MyFree(sourcerootpath);
    MyFree(section);

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupQueueCopySectionW(
    IN HSPFILEQ QueueHandle,
    IN PCWSTR   SourceRootPath,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,      OPTIONAL
    IN PCWSTR   Section,
    IN DWORD    CopyStyle
    )
{
    UNREFERENCED_PARAMETER(QueueHandle);
    UNREFERENCED_PARAMETER(SourceRootPath);
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(ListInfHandle);
    UNREFERENCED_PARAMETER(Section);
    UNREFERENCED_PARAMETER(CopyStyle);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupQueueCopySection(
    IN HSPFILEQ QueueHandle,
    IN PCTSTR   SourceRootPath,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,   OPTIONAL
    IN PCTSTR   Section,
    IN DWORD    CopyStyle
    )

/*++

Routine Description:

    Queue an entire section in an inf file for copy. The section must be
    in copy-section format and the inf file must contain [SourceDisksFiles]
    and [SourceDisksNames] sections.

Arguments:

    QueueHandle - supplies a handle to a setup file queue, as returned
        by SetupOpenFileQueue.

    SourceRootPath - supplies the root directory for the intended source.
        This should be a sharepoint or a device root such as a:\ or g:\.

    InfHandle - supplies a handle to an open inf file, that contains the
        [SourceDisksFiles] and [SourceDisksNames] sections, and, if
        ListInfHandle is not specified, contains the section names by Section.
        This handle must be for a win95-style inf.

    ListInfHandle - if specified, supplies a handle to an open inf file
        containing the section to be queued for copy. Otherwise InfHandle
        is assumed to contain the section.

    Section - supplies the name of the section to be queued for copy.

    CopyStyle - supplies flags that control the behavior of the copy operation
        for this file.

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information. Some of the files may have been queued.

--*/

{
    BOOL b;
    INFCONTEXT LineContext;
    PCTSTR SourceFilename;
    PCTSTR TargetFilename;
    PCTSTR SecurityDescriptor = NULL;
    PCTSTR CacheName = NULL;
    UINT Flags;
    DWORD CopyStyleLocal;
    LONG LineCount;
    HINF CabInf = INVALID_HANDLE_VALUE;
    DWORD rc;

    //
    // Note that there are no potential faults here so no try/excepts
    // are necessary. pSetupQueueSingleCopy does all validation.
    //

    if(!ListInfHandle || (ListInfHandle == INVALID_HANDLE_VALUE)) {
        ListInfHandle = InfHandle;
    }

    //
    // Check for missing section
    //
    LineCount = SetupGetLineCount (ListInfHandle, Section);
    if(LineCount == -1) {
        rc = GetLastError();
        pSetupLogSectionError(ListInfHandle,NULL,NULL,QueueHandle,Section,MSG_LOG_NOSECTION_COPY,rc,NULL);
        SetLastError(ERROR_SECTION_NOT_FOUND); // maintain existing error code, log contains correct error code
        return(FALSE);
    }

    //
    // if section is empty, do nothing.
    //
    if(LineCount == 0) {
        return(TRUE);
    }

    //
    // The section has to exist and there has to be at least one line in it.
    //
    b = SetupFindFirstLine(ListInfHandle,Section,NULL,&LineContext);
    if(!b) {
        rc = GetLastError();
        pSetupLogSectionError(ListInfHandle,NULL,NULL,QueueHandle,Section,MSG_LOG_NOSECTION_COPY,rc,NULL);
        SetLastError(ERROR_SECTION_NOT_FOUND); // maintain existing error code, log contains correct error code
        return(FALSE);
    }

    //
    //Get the Security descriptor
    //

    if( !pSetupGetSecurityInfo( ListInfHandle, Section, &SecurityDescriptor ) )
        SecurityDescriptor = NULL;


    //
    // load driver cache inf
    //
    CabInf = SetupOpenInfFile( STR_DRIVERCACHEINF , NULL, INF_STYLE_WIN4, NULL );
    if (CabInf != INVALID_HANDLE_VALUE) {
        CopyStyle |= PSP_COPY_USE_DRIVERCACHE;
    }

    //
    // Iterate every line in the section.
    //
    do {
        CopyStyleLocal = CopyStyle;
        //
        // Get the target filename out of the line.
        // Field 1 is the target so there must be one for the line to be valid.
        //
        TargetFilename = pSetupFilenameFromLine(&LineContext,FALSE);
        if(!TargetFilename) {
            if (CabInf != INVALID_HANDLE_VALUE) {
                SetupCloseInfFile(CabInf);
            }
            try {
                if (QueueHandle != NULL
                    && QueueHandle != (HSPFILEQ)INVALID_HANDLE_VALUE
                    && ((PSP_FILE_QUEUE)QueueHandle)->Signature == SP_FILE_QUEUE_SIG) {

                    WriteLogEntry(
                        ((PSP_FILE_QUEUE)QueueHandle)->LogContext,
                        SETUP_LOG_ERROR,
                        MSG_LOG_COPY_TARGET,
                        NULL,
                        Section);
                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
            }
            SetLastError(ERROR_INVALID_DATA);
            return(FALSE);
        }

        //
        // Get source filename out of the line. If there is none, use
        // the target name as the source name.
        //
        SourceFilename = pSetupFilenameFromLine(&LineContext,TRUE);
        if(!SourceFilename || (*SourceFilename == 0)) {
            SourceFilename = TargetFilename;
        }

        //
        // if we were asked to use the driver cache, then check if the file
        // is in the associated INF for the cab.
        //
        if (CabInf != INVALID_HANDLE_VALUE) {
            if (!pIsFileInDriverCache(CabInf, SourceFilename, NULL, &CacheName)) {
                CopyStyleLocal &= ~PSP_COPY_USE_DRIVERCACHE;
            }
        }

        //
        // If present, flags are field 3.
        //
        if(SetupGetIntField(&LineContext,4,(PINT)&Flags)) {

            if(Flags & COPYFLG_WARN_IF_SKIP) {
                CopyStyleLocal |= SP_COPY_WARNIFSKIP;
            }

            if(Flags & COPYFLG_NOSKIP) {
                CopyStyleLocal |= SP_COPY_NOSKIP;
            }

            if(Flags & COPYFLG_NOVERSIONCHECK) {
                CopyStyleLocal &= ~SP_COPY_NEWER;
            }

            if(Flags & COPYFLG_FORCE_FILE_IN_USE) {
                CopyStyleLocal |= SP_COPY_FORCE_IN_USE;
                CopyStyleLocal |= SP_COPY_IN_USE_NEEDS_REBOOT;
            }

            if(Flags & COPYFLG_NO_OVERWRITE) {
                CopyStyleLocal |= SP_COPY_FORCE_NOOVERWRITE;
            }

            if(Flags & COPYFLG_NO_VERSION_DIALOG) {
                CopyStyleLocal |= SP_COPY_FORCE_NEWER;
            }

            if(Flags & COPYFLG_OVERWRITE_OLDER_ONLY) {
                CopyStyleLocal |= SP_COPY_NEWER_ONLY;
            }

            if(Flags & COPYFLG_REPLACEONLY) {
                CopyStyleLocal |= SP_COPY_REPLACEONLY;
            }

            if(Flags & COPYFLG_NODECOMP) {
                CopyStyleLocal |= SP_COPY_NODECOMP;
            }

            if(Flags & COPYFLG_REPLACE_BOOT_FILE) {
                CopyStyleLocal |= SP_COPY_REPLACE_BOOT_FILE;
            }

            if(Flags & COPYFLG_NOPRUNE) {
                CopyStyleLocal |= SP_COPY_NOPRUNE;
            }

        }

        b = pSetupQueueSingleCopy(
                QueueHandle,
                InfHandle,
                ListInfHandle,
                Section,
                SourceRootPath,
                SourceFilename,
                TargetFilename,
                CopyStyleLocal,
                SecurityDescriptor,
                CacheName
                );

        if (CacheName) {
            MyFree( CacheName );
            CacheName = NULL;
        }

        if(!b) {
            DWORD LastError = GetLastError();

            if (CabInf != INVALID_HANDLE_VALUE) {
                SetupCloseInfFile(CabInf);
            }

            SetLastError( LastError );

            return(FALSE);
        }
    } while(SetupFindNextLine(&LineContext,&LineContext));

    if (CabInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(CabInf);
    }
    return(TRUE);
}


BOOL
pSetupQueueSingleCopy(
    IN HSPFILEQ    QueueHandle,
    IN HINF        InfHandle,
    IN HINF        ListInfHandle,  OPTIONAL
    IN PCTSTR      SectionName,    OPTIONAL
    IN PCTSTR      SourceRootPath,
    IN PCTSTR      SourceFilename,
    IN PCTSTR      TargetFilename,
    IN DWORD       CopyStyle,
    IN PCTSTR      SecurityDescriptor,
    IN PCTSTR      CacheName
    )

/*++

Routine Description:

    Add a single file to the copy queue, using the default source media
    and destination as specified in an inf file.

Arguments:

    QueueHandle - supplies a handle to a setup file queue, as returned
        by SetupOpenFileQueue.

    InfHandle - supplies a handle to an open inf file, that contains the
        [SourceDisksFiles] and [SourceDisksNames] sections.
        This handle must be for a win95-style inf.

    ListInfHandle - if specified, supplies handle to the inf in which
        the file being copied appears (such as in a file copy list section).
        If not specified, this is assumed to be the same inf as InfHandle.

    SourceRootPath - supplies the root directory for the intended source.
        This should be a sharepoint or a device root such as a:\ or g:\.

    SourceFilename - supplies the filename of the source file. Filename part
        only.

    TargetFilename - supplies the filename of the target file. Filename part
        only.

    CopyStyle - supplies flags that control the behavior of the copy operation
        for this file.

    SecurityDescriptor - describes the permissions for the target file

    CacheName - if supplied this is the name of the driver cache we should
                use to copy the file out of instead of the specified source path

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information.

--*/

{
    BOOL b;
    UINT SourceId;
    DWORD SizeRequired;
    PTSTR TargetDirectory;
    PCTSTR SourceDescription,SourceTagfile,SourceRelativePath;
    PCTSTR TmpCacheName = CacheName;
    UINT SourceFlags;
    DWORD rc;
    TCHAR FileSubdir[MAX_PATH];
    TCHAR RelativePath[MAX_PATH];
    INFCONTEXT LineContext;
    PINFCONTEXT pLineContext;
    SP_FILE_COPY_PARAMSEX CopyParams;
    HINF CabInf = INVALID_HANDLE_VALUE;
    PSETUP_LOG_CONTEXT lc = NULL;
    BOOL AlreadyLoggedError = FALSE;

    if(!ListInfHandle || (ListInfHandle == INVALID_HANDLE_VALUE)) {
        ListInfHandle = InfHandle;
    }

    //
    // Determine the source disk id and subdir where the file is located.
    //
    try {

        if((QueueHandle != NULL) &&
           (QueueHandle != INVALID_HANDLE_VALUE) &&
           (((PSP_FILE_QUEUE)QueueHandle)->Signature == SP_FILE_QUEUE_SIG)) {

            lc = ((PSP_FILE_QUEUE)QueueHandle)->LogContext;

            b = _SetupGetSourceFileLocation(
                    InfHandle,
                    NULL,
                    SourceFilename,
                    (((PSP_FILE_QUEUE)QueueHandle)->Flags & FQF_USE_ALT_PLATFORM)
                       ? &(((PSP_FILE_QUEUE)QueueHandle)->AltPlatformInfo)
                       : NULL,
                    &SourceId,
                    FileSubdir,
                    MAX_PATH,
                    &rc,
                    &LineContext
                    );

            if(!b) {
                rc = GetLastError();
            }

        } else {
            b = FALSE;
            rc = ERROR_INVALID_HANDLE;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
        rc = ERROR_INVALID_HANDLE;
        lc = NULL;
    }

    if(!b) {

        if((rc == ERROR_INVALID_PARAMETER) || (rc == ERROR_INVALID_HANDLE)) {
            //
            // if we failed due to a bad parameter, bail now
            //
            goto clean1;
        }

        //
        // Try to fetch just the id and assume there is no subdir.
        //
        try {

            b = _SetupGetSourceFileLocation(
                    InfHandle,
                    NULL,
                    SourceFilename,
                    (((PSP_FILE_QUEUE)QueueHandle)->Flags & FQF_USE_ALT_PLATFORM)
                       ? &(((PSP_FILE_QUEUE)QueueHandle)->AltPlatformInfo)
                       : NULL,
                    &SourceId,
                    NULL,
                    0,
                    NULL,
                    &LineContext
                    );

        } except(EXCEPTION_EXECUTE_HANDLER) {
            b = FALSE;
        }

        if(b) {
            FileSubdir[0] = 0;
        }
    }

    if(b) {
        //
        // Get information about the source. Need the tag file,
        // description, and relative source path.
        //
        try {

            b = pSetupGetSourceAllInfo(
                    InfHandle,
                    &LineContext,
                    SourceId,
                    (((PSP_FILE_QUEUE)QueueHandle)->Flags & FQF_USE_ALT_PLATFORM)
                       ? &(((PSP_FILE_QUEUE)QueueHandle)->AltPlatformInfo)
                       : NULL,
                    &SourceDescription,
                    &SourceTagfile,
                    &SourceRelativePath,
                    &SourceFlags
                    );

            if(!b) {
                rc = GetLastError();
                if((rc == ERROR_LINE_NOT_FOUND) || (rc == ERROR_SECTION_NOT_FOUND)) {
                    WriteLogEntry(
                        lc,
                        SETUP_LOG_ERROR,
                        MSG_LOG_NO_SOURCE,
                        NULL,
                        SourceId
                        );
                    AlreadyLoggedError = TRUE;
                }
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            b = FALSE;
            rc = ERROR_INVALID_PARAMETER;
        }

        if(!b) {
            goto clean1;
        }

        //
        // Set a value that causes _SetupQueueCopy to skip looking for the
        // [SourceDisksFiles] section -- we just found it, so we just pass
        // the info along!
        //
        pLineContext = &LineContext;

    } else {
        //
        // Assume there is no SourceDisksFiles section and fake it as best we can.
        // Assume the media has a description of "Unknown," set the source path to
        // the source root if there is one, and assume no tag file.
        //
        // We also set a special value that tells _SetupQueueCopy not to bother trying
        // to look for the [SourceDisksFiles] section itself, since there isn't one.
        //
        FileSubdir[0] = 0;
        SourceDescription = NULL;
        SourceTagfile = NULL;
        SourceRelativePath = NULL;
        pLineContext = (PINFCONTEXT)(-1);
    }

    if ( CopyStyle & PSP_COPY_CHK_DRIVERCACHE) {
        CabInf = SetupOpenInfFile( STR_DRIVERCACHEINF, NULL, INF_STYLE_WIN4, NULL );
        if (CabInf != INVALID_HANDLE_VALUE) {
            if (pIsFileInDriverCache(CabInf, SourceFilename, SourceRelativePath, &TmpCacheName)) {
                CopyStyle |= PSP_COPY_USE_DRIVERCACHE;
                CopyStyle &= ~PSP_COPY_CHK_DRIVERCACHE;
            }

            SetupCloseInfFile(CabInf);

        }
    }

    if (CopyStyle & PSP_COPY_USE_DRIVERCACHE) {
        //
        // check if the inf we want to copy from is an OEM inf
        //
        if (!pLineContext || pLineContext==(PINFCONTEXT)-1) {
            CopyStyle &= ~PSP_COPY_USE_DRIVERCACHE;
        } else if (pSetupInfIsFromOemLocation( ((PLOADED_INF)pLineContext->CurrentInf)->VersionBlock.Filename,TRUE )) {
            CopyStyle &= ~PSP_COPY_USE_DRIVERCACHE;
        } else if ( ((PLOADED_INF)pLineContext->CurrentInf)->OriginalInfName
                    && pSetupInfIsFromOemLocation( ((PLOADED_INF)pLineContext->CurrentInf)->OriginalInfName, TRUE) ) {
            CopyStyle &= ~PSP_COPY_USE_DRIVERCACHE;
        }
    }

    //
    // Determine the target path for the file.
    //
    if(b = SetupGetTargetPath(ListInfHandle,NULL,SectionName,NULL,0,&SizeRequired)) {

        if(TargetDirectory = MyMalloc(SizeRequired*sizeof(TCHAR))) {

            if(b = SetupGetTargetPath(ListInfHandle,NULL,SectionName,TargetDirectory,SizeRequired,NULL)) {

                try {
                    WriteLogEntry(
                        lc,
                        SETUP_LOG_VVERBOSE,
                        SectionName ? MSG_LOG_COPY_QUEUE : MSG_LOG_DEFCOPY_QUEUE,
                        NULL,
                        SectionName ? SectionName : TEXT(""),
                        ((PLOADED_INF)ListInfHandle)->VersionBlock.Filename,
                        TargetFilename ? TargetFilename : TEXT(""),
                        SourceFilename ? SourceFilename : TEXT(""),
                        CopyStyle,
                        TargetDirectory ? TargetDirectory : TEXT(""));
                    if (pLineContext && (pLineContext != (PINFCONTEXT)(-1))) {
                        LPCTSTR SrcSecName = NULL;
                        LPCTSTR SrcInfName = NULL;
                        PLOADED_INF pInf = (PLOADED_INF)(pLineContext->CurrentInf);

                        MYASSERT(pInf);
                        SrcSecName = pStringTableStringFromId(
                                                pInf->StringTable,
                                                pInf->SectionBlock[pLineContext->Section].SectionName);
                        SrcInfName = pInf->VersionBlock.Filename;
                        WriteLogEntry(
                            lc,
                            SETUP_LOG_VVERBOSE,
                            (CopyStyle & PSP_COPY_USE_DRIVERCACHE) ? MSG_LOG_COPY_QUEUE_DRIVERCACHE : MSG_LOG_COPY_QUEUE_SOURCE,
                            NULL,
                            SrcSecName ? SrcSecName : TEXT(""),
                            SrcInfName ? SrcInfName : TEXT(""),
                            SourceId ? SourceId : TEXT('\0'),
                            SourceDescription ? SourceDescription : TEXT(""),
                            SourceTagfile ? SourceTagfile : TEXT(""),
                            SourceRelativePath ? SourceRelativePath : TEXT(""));

                    } else {
                        WriteLogEntry(
                            lc,
                            SETUP_LOG_VVERBOSE,
                            MSG_LOG_COPY_QUEUE_DEFAULT,
                            NULL);
                    }
                } except(EXCEPTION_EXECUTE_HANDLER) {
                }
                //
                // Append the source relative path and the file subdir.
                //
                if(SourceRelativePath) {
                    lstrcpyn(RelativePath,SourceRelativePath,MAX_PATH);
                    if(FileSubdir[0]) {
                        pSetupConcatenatePaths(RelativePath,FileSubdir,MAX_PATH,NULL);
                    }
                } else {
                    RelativePath[0] = 0;
                }

                //
                // Add to queue.
                //
                CopyParams.cbSize            = sizeof(SP_FILE_COPY_PARAMSEX);
                CopyParams.QueueHandle       = QueueHandle;
                CopyParams.SourceRootPath    = SourceRootPath;
                CopyParams.SourcePath        = RelativePath[0] ? RelativePath : NULL ;
                CopyParams.SourceFilename    = SourceFilename;
                CopyParams.SourceDescription = SourceDescription;
                CopyParams.SourceTagfile     = SourceTagfile;
                CopyParams.TargetDirectory   = TargetDirectory;
                CopyParams.TargetFilename    = TargetFilename;
                CopyParams.CopyStyle         = CopyStyle;
                CopyParams.LayoutInf         = InfHandle;
                CopyParams.SecurityDescriptor= SecurityDescriptor;
                CopyParams.CacheName         = TmpCacheName;
                //
                // first item indicates source flag information
                // second item indicates that we've already retrieved
                // this information, so even if the SourceFlags are zero,
                // we won't go looking for it again
                //
                CopyParams.SourceFlags       = SourceFlags;
                CopyParams.SourceFlagsSet    = TRUE;

                b = _SetupQueueCopy(&CopyParams,
                                    pLineContext,
                                    ((InfHandle == ListInfHandle) ? NULL : ListInfHandle)
                                   );

                rc = GetLastError();
            }

            MyFree(TargetDirectory);

        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        rc = GetLastError();
    }

    if(SourceDescription) {
        MyFree(SourceDescription);
    }
    if(SourceTagfile) {
        MyFree(SourceTagfile);
    }
    if(SourceRelativePath) {
        MyFree(SourceRelativePath);
    }
    if(TmpCacheName && TmpCacheName != CacheName) {
        MyFree(TmpCacheName);
    }

clean1:
    if(!b) {

        BOOL FreeLC = FALSE;

        if(!lc) {
            if(CreateLogContext(NULL, TRUE, &lc) == NO_ERROR) {
                //
                // success
                //
                FreeLC = TRUE;
            } else {
                lc = NULL;
            }
        }

        //
        // If we couldn't create a log context (i.e., due to out-of-memory),
        // don't bother calling WriteLogEntry, because it's not going to have
        // any better luck...
        //
        if(lc) {

            if(!AlreadyLoggedError) {
                try {
                    WriteLogEntry(
                        lc,
                        SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
                        MSG_LOG_COPY_QUEUE_ERROR,
                        NULL,
                        SectionName ? SectionName : TEXT(""),
                        ((PLOADED_INF)ListInfHandle)->VersionBlock.Filename,
                        TargetFilename ? TargetFilename : TEXT(""),
                        SourceFilename ? SourceFilename : TEXT(""));
                    WriteLogError(
                        lc,
                        SETUP_LOG_ERROR,
                        rc
                        );
                } except(EXCEPTION_EXECUTE_HANDLER) {
                }
            }

            if(FreeLC) {
                DeleteLogContext(lc);
            }
        }

        SetLastError(rc);
    }

    return(b);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupQueueDefaultCopyA(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN PCSTR    SourceRootPath,
    IN PCSTR    SourceFilename,
    IN PCSTR    TargetFilename,
    IN DWORD    CopyStyle
    )
{
    PWSTR sourcerootpath;
    PWSTR sourcefilename;
    PWSTR targetfilename;
    DWORD rc;
    BOOL b;

    b = FALSE;
    rc = pSetupCaptureAndConvertAnsiArg(SourceRootPath,&sourcerootpath);
    if(rc == NO_ERROR) {

        rc = pSetupCaptureAndConvertAnsiArg(SourceFilename,&sourcefilename);
        if(rc == NO_ERROR) {

            rc = pSetupCaptureAndConvertAnsiArg(TargetFilename,&targetfilename);
            if(rc == NO_ERROR) {

                b = SetupQueueDefaultCopyW(
                        QueueHandle,
                        InfHandle,
                        sourcerootpath,
                        sourcefilename,
                        targetfilename,
                        CopyStyle
                        );

                rc = GetLastError();

                MyFree(targetfilename);
            }

            MyFree(sourcefilename);
        }

        MyFree(sourcerootpath);
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupQueueDefaultCopyW(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN PCWSTR   SourceRootPath,
    IN PCWSTR   SourceFilename,
    IN PCWSTR   TargetFilename,
    IN DWORD    CopyStyle
    )
{
    UNREFERENCED_PARAMETER(QueueHandle);
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(SourceRootPath);
    UNREFERENCED_PARAMETER(SourceFilename);
    UNREFERENCED_PARAMETER(TargetFilename);
    UNREFERENCED_PARAMETER(CopyStyle);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif


BOOL
SetupQueueDefaultCopy(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN PCTSTR   SourceRootPath,
    IN PCTSTR   SourceFilename,
    IN PCTSTR   TargetFilename,
    IN DWORD    CopyStyle
    )

/*++

Routine Description:

    Add a single file to the copy queue, using the default source media
    and destination as specified in an inf file.

Arguments:

    QueueHandle - supplies a handle to a setup file queue, as returned
        by SetupOpenFileQueue.

    InfHandle - supplies a handle to an open inf file, that contains the
        [SourceDisksFiles] and [SourceDisksNames] sections.
        This handle must be for a win95-style inf.

    SourceRootPath - supplies the root directory for the intended source.
        This should be a sharepoint or a device root such as a:\ or g:\.

    SourceFilename - supplies the filename of the source file. Filename part
        only.

    TargetFilename - supplies the filename of the target file. Filename part
        only.

    CopyStyle - supplies flags that control the behavior of the copy operation
        for this file.

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information.

--*/

{
    BOOL b;

    b = pSetupQueueSingleCopy(
            QueueHandle,
            InfHandle,
            NULL,
            NULL,
            SourceRootPath,
            SourceFilename,
            TargetFilename,
            CopyStyle | PSP_COPY_CHK_DRIVERCACHE,
            NULL,
            NULL
            );

    return(b);
}


PSOURCE_MEDIA_INFO
pSetupQueueSourceMedia(
    IN OUT PSP_FILE_QUEUE      Queue,
    IN OUT PSP_FILE_QUEUE_NODE QueueNode,
    IN     LONG                SourceRootStringId,
    IN     PCTSTR              SourceDescription,   OPTIONAL
    IN     PCTSTR              SourceTagfile,       OPTIONAL
    IN     PCTSTR              SourceCabfile,       OPTIONAL
    IN     DWORD               MediaFlags
    )

/*++

Routine Description:

    Set up a file queue node's source media descriptor pointer, creating a new
    source media descriptor if necessary.

Arguments:

    Queue - supplies pointer to file queue with which the queue node
        is associated.

    QueueNode - supplies file queue node whose source media descriptor pointer
        is to be set.

    SourceRootStringId - supplies string id of root to source (something like a:\).

    SourceDescription - if specified, supplies a description for the media.

    SourceTagfile - if specified, supplies a tag file for the media.

    SourceCabfile - if specified, supplies a cabfile for the media different to the tagfile.

    MediaFlags - specifies additional information used in searching for an
        existing source media descriptor in the specified queue, and in adding
        new source media descriptors to that queue.  May be a combination of
        the following values:

        SMI_FLAG_NO_SOURCE_ROOT_PATH : The caller didn't supply a SourceRootPath
            for this copy action, so we're using a default path.  This flag
            causes us to not include the SourceRootStringId as part of our
            match criteria when searching to see if the specified source media
            information is already present in an existing media descriptor.  If
            we don't find a match (i.e., we have to create a new descriptor),
            we'll store this flag away in the SOURCE_MEDIA_INFO.Flags field so
            that if we come along later to add source media descriptors where
            the caller did specify SourceRootPath, then we'll re-use this
            descriptor and overwrite the existing (default) source root path
            with the caller-specified one.

        SMI_FLAG_USE_SVCPACK_SOURCE_ROOT_PATH : The caller didn't supply a SourceRootPath
            for this copy action, and it's a tagged source media, so we're using a
            service pack path.  This flag  causes us to not include the SourceRootStringId
            as part of our match criteria when searching to see if the specified source media
            information is already present in an existing media descriptor.  If
            we don't find a match (i.e., we have to create a new descriptor),
            we'll store this flag away in the SOURCE_MEDIA_INFO.Flags field so
            that if we come along later to add source media descriptors where
            the caller did specify SourceRootPath, then we'll re-use this
            descriptor and overwrite the existing (default) source root path
            with the caller-specified one.

        SMI_FLAG_USE_LOCAL_SOURCE_CAB : The caller wants to use the local source cab containing
            driver files, etc.  In this case, we supply the source description and tagfile,
            ignoring what the caller passes in.  At this point we know the media is present, as
            the caller provided this check.  If it wasnt't, we default to the OS Source path location.


Return Value:

    Pointer to source media info structure, or NULL if out of memory.

--*/

{
    LONG DescriptionStringId;
    LONG TagfileStringId;
    LONG CabfileStringId;
    PSOURCE_MEDIA_INFO Source,LastSource, TempSource;
    BOOL b1,b2,b3;
    TCHAR TempTagfileString[MAX_PATH];
    TCHAR TempCabfileString[MAX_PATH];
    TCHAR TempSrcDescString[LINE_LEN];


    if (MediaFlags & SMI_FLAG_USE_LOCAL_SOURCE_CAB) {
        LoadString( MyDllModuleHandle, IDS_DRIVERCACHE_DESC, TempSrcDescString, sizeof(TempSrcDescString)/sizeof(TCHAR) );
        SourceDescription = TempSrcDescString;
    } else {
        //
        // For the optional SourceDescription and SourceTagfile parameters, treat
        // empty strings as if the parameter had not been specified.
        //
        if(SourceDescription && !(*SourceDescription)) {
            SourceDescription = NULL;
        }
        if(SourceTagfile && !(*SourceTagfile)) {
            SourceTagfile = NULL;
        }

        //
        // If no description is specified, force the tagfile to none.
        //
        if(!SourceDescription) {
            SourceTagfile = NULL;
        }
    }

    if(SourceDescription) {
        //
        // Description specified. See if it's in the table. If not,
        // no need to search the list of media descriptors because we know
        // we can't find a match.
        //
        // (We must first copy this string to a writeable buffer, to speed up the
        // case-insensitive lookup.
        //
        lstrcpyn(TempSrcDescString, SourceDescription, SIZECHARS(TempSrcDescString));
        DescriptionStringId = pSetupStringTableLookUpString(Queue->StringTable,
                                                      TempSrcDescString,
                                                      STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                                     );
        b1 = (DescriptionStringId != -1);
    } else {
        //
        // No description specified, look for a source media with -1 as the
        // description string id
        //
        DescriptionStringId = -1;
        b1 = TRUE;
    }

    if(SourceTagfile) {
        //
        // Tagfile specified. See if it's in the table. If not,
        // no need to search the list of media descriptors because we know
        // we can't find a match.
        //
        // (Again, we must first copy the string to a writeable buffer.
        //
        lstrcpyn(TempTagfileString, SourceTagfile, SIZECHARS(TempTagfileString));
        TagfileStringId = pSetupStringTableLookUpString(Queue->StringTable,
                                                  TempTagfileString,
                                                  STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                                 );
        b2 = (TagfileStringId != -1);
    } else {
        //
        // No tagfile specified, look for a source media with -1 as the
        // tagfile string id
        //
        TagfileStringId = -1;
        b2 = TRUE;
    }

    if(SourceCabfile) {
        //
        // Cabfile specified. See if it's in the table. If not,
        // no need to search the list of media descriptors because we know
        // we can't find a match.
        //
        // (Again, we must first copy the string to a writeable buffer.
        //
        lstrcpyn(TempCabfileString, SourceCabfile, SIZECHARS(TempCabfileString));
        CabfileStringId = pSetupStringTableLookUpString(Queue->StringTable,
                                                  TempCabfileString,
                                                  STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                                 );
        b3 = (CabfileStringId != -1);
    } else {
        //
        // No cabfile specified, merge Cabfile&Tagfile together
        // since b2==b3, then we have the identities b2|b3 == b2 and b2&b3 == b2
        // ie, old behavior
        //
        CabfileStringId = TagfileStringId;
        b3 = b2;
    }

    //
    // If we think there's a possibility of finding an existing source that
    // matches the caller's parameters, scan the source media list looking
    // for a match.
    //
    if(b1 && b2 && b3) {

        for(Source=Queue->SourceMediaList; Source; Source=Source->Next) {

            if((Source->Description == DescriptionStringId)
               && (Source->Tagfile == TagfileStringId)
               && (Source->Cabfile == CabfileStringId)) {
                //
                // We only consider the SourceRootPath when both existing
                // media descriptor and new media descriptor have actual
                // caller-supplied paths (as opposed to something we made up).
                //
                if((Source->Flags & SMI_FLAG_NO_SOURCE_ROOT_PATH) ||
                   (MediaFlags & SMI_FLAG_NO_SOURCE_ROOT_PATH) ||
                   (Source->SourceRootPath == SourceRootStringId)) {
                    //
                    // Got a match. Point the queue node at this source and return.
                    //
                    QueueNode->SourceMediaInfo = Source;
                    //
                    // If the existing media descriptor had a made-up source
                    // root path, but the new media information had an actual
                    // caller-supplied one, then replace the made-up one with
                    // the real one and clear the no-source-root-path flag.
                    //
                    if((Source->Flags & SMI_FLAG_NO_SOURCE_ROOT_PATH) &&
                       !(MediaFlags & SMI_FLAG_NO_SOURCE_ROOT_PATH)) {

                        Source->SourceRootPath = SourceRootStringId;
                        Source->Flags &= ~SMI_FLAG_NO_SOURCE_ROOT_PATH;
                    }

                    return(Source);
                }
            }
        }
    }

    //
    // Need to add a new source media descriptor.
    // Allocate the structure and fill it in.
    //
    Source = MyMalloc(sizeof(SOURCE_MEDIA_INFO));
    if(!Source) {
        return(NULL);
    }

    Source->Next = NULL;
    Source->CopyQueue = NULL;
    Source->CopyNodeCount = 0;
    Source->Flags = MediaFlags;

    if(SourceDescription) {
        //
        // Since we already passed this in for a case-insensitive lookup with a writeable
        // buffer, we can add it case-sensitively, because it's already lower-cased.
        //
        Source->Description = pSetupStringTableAddString(Queue->StringTable,
                                                   TempSrcDescString,
                                                   STRTAB_CASE_SENSITIVE | STRTAB_ALREADY_LOWERCASE
                                                  );
        //
        // We also must add the description in its original case, since this is a displayable string.
        // (We're safe in casting away the CONST-ness of this string, since it won't be modified.)
        //
        Source->DescriptionDisplayName = pSetupStringTableAddString(Queue->StringTable,
                                                              (PTSTR)SourceDescription,
                                                              STRTAB_CASE_SENSITIVE
                                                             );

        if((Source->Description == -1) || (Source->DescriptionDisplayName == -1)) {
            MyFree(Source);
            return(NULL);
        }
    } else {
        Source->Description = Source->DescriptionDisplayName = -1;
    }

    if(SourceTagfile) {
        //
        // Again, we already lower-cased this in a writeable buffer above.
        //
        Source->Tagfile = pSetupStringTableAddString(Queue->StringTable,
                                               TempTagfileString,
                                               STRTAB_CASE_SENSITIVE | STRTAB_ALREADY_LOWERCASE
                                              );
        if(Source->Tagfile == -1) {
            MyFree(Source);
            return(NULL);
        }
    } else {
        Source->Tagfile = -1;
    }

    if(SourceCabfile) {
        //
        // Again, we already lower-cased this in a writeable buffer above.
        //
        Source->Cabfile = pSetupStringTableAddString(Queue->StringTable,
                                               TempCabfileString,
                                               STRTAB_CASE_SENSITIVE | STRTAB_ALREADY_LOWERCASE
                                              );
        if(Source->Cabfile == -1) {
            MyFree(Source);
            return(NULL);
        }
    } else {
        Source->Cabfile = Source->Tagfile;
    }

    Source->SourceRootPath = SourceRootStringId;

    //
    // insert our media descriptor into the list of descriptors
    // Note: if the new descriptor has the "service pack" or
    // "local cab driver cache" tag set, then we insert it into
    // the head of the list, otherwise we put it into the end
    // of the list.  This ensures that if the user get's a
    // need media complaint for os binaries, and overrides
    // the source path, then the user will first be prompted for service
    // pack media, then the os media. This saves us from adding lots of
    // code to handle need media overrides in this case, since we would
    // potentially have the os source files first in the media list, which
    // would cause us to install the os media files instead of the service
    // pack media files
    //
    // another potential service pack issue is if we get Tag==Cab entries mixed with Tag!=Cab
    // for exactly the same cab
    // nothing much we can do here, other than ensure that any change where Tag!=Cab
    // is done across the board
    //
    LastSource = NULL;
    for(TempSource=Queue->SourceMediaList; TempSource; LastSource=TempSource,TempSource=LastSource->Next) {
        if ((Source->Flags ^ TempSource->Flags) & (SMI_FLAG_USE_LOCAL_SOURCE_CAB | SMI_FLAG_USE_SVCPACK_SOURCE_ROOT_PATH)) {
            //
            // one is either normal, local source cab, or source root path, and the other is different
            //
            // SMI_FLAG_USE_LOCAL_SOURCE_CAB inserted before anything else
            //
            if(TempSource->Flags & SMI_FLAG_USE_LOCAL_SOURCE_CAB) {
                //
                // ISSUE-2002/04/19-JamieHun Source->Flags can have this bit set
                // ordering needs to be performed with this in mind
                //
                //MYASSERT(!(Source->Flags & SMI_FLAG_USE_LOCAL_SOURCE_CAB));
                continue;
            }
            if(Source->Flags & SMI_FLAG_USE_LOCAL_SOURCE_CAB) {
                break;
            }
            //
            // SMI_FLAG_USE_SVCPACK_SOURCE_ROOT_PATH comes next
            //
            if(TempSource->Flags & SMI_FLAG_USE_SVCPACK_SOURCE_ROOT_PATH) {
                //
                // ISSUE-2002/04/19-JamieHun Source->Flags can have this bit set
                // ordering needs to be performed with this in mind
                //
                //MYASSERT(!(Source->Flags & SMI_FLAG_USE_SVCPACK_SOURCE_ROOT_PATH));
                continue;
            }
            if(Source->Flags & SMI_FLAG_USE_SVCPACK_SOURCE_ROOT_PATH) {
                break;
            }
        }
        //
        // group same tagfiles together (needed because of tag+cab combinations)
        //
        if( LastSource && (Source->Tagfile == LastSource->Tagfile)
                       && (Source->Tagfile != TempSource->Tagfile)) {
            break;
        }
    }
    if (LastSource) {
        //
        // insert after this one
        //
        Source->Next = LastSource->Next;
        LastSource->Next = Source;
    } else {
        //
        // TempSource will either be NULL (no media) or first media (insert before first)
        //
        Source->Next = TempSource;
        Queue->SourceMediaList = Source;
    }

    Queue->SourceMediaCount++;

    QueueNode->SourceMediaInfo = Source;
    return(Source);
}


BOOL
pSetupGetSourceAllInfo(
    IN  HINF                     InfHandle,
    IN  PINFCONTEXT              LayoutLineContext, OPTIONAL
    IN  UINT                     SourceId,
    IN  PSP_ALTPLATFORM_INFO_V2  AltPlatformInfo,   OPTIONAL
    OUT PCTSTR                  *Description,
    OUT PCTSTR                  *Tagfile,
    OUT PCTSTR                  *RelativePath,
    OUT PUINT                    SourceFlags
    )
{
    BOOL b;
    DWORD RequiredSize;
    PTSTR p;
    DWORD ec;
    TCHAR Buffer[MAX_PATH];

    //
    // Get path relative to the source.
    //
    b = pSetupGetSourceInfo(InfHandle,
                            LayoutLineContext,
                            SourceId,
                            AltPlatformInfo,
                            SRCINFO_PATH,
                            NULL,
                            0,
                            &RequiredSize
                           );
    if(!b) {
        ec = GetLastError();
        goto clean0;
    }

    p = MyMalloc(RequiredSize*sizeof(TCHAR));
    if(!p) {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }
    pSetupGetSourceInfo(InfHandle,
                        LayoutLineContext,
                        SourceId,
                        AltPlatformInfo,
                        SRCINFO_PATH,
                        p,
                        RequiredSize,
                        NULL
                       );
    *RelativePath = p;

    //
    // Get description.
    //
    b = pSetupGetSourceInfo(InfHandle,
                            LayoutLineContext,
                            SourceId,
                            AltPlatformInfo,
                            SRCINFO_DESCRIPTION,
                            NULL,
                            0,
                            &RequiredSize
                           );
    if(!b) {
        ec = GetLastError();
        goto clean1;
    }

    p = MyMalloc(RequiredSize*sizeof(TCHAR));
    if(!p) {
        ec =  ERROR_NOT_ENOUGH_MEMORY;
        goto clean1;
    }
    pSetupGetSourceInfo(InfHandle,
                        LayoutLineContext,
                        SourceId,
                        AltPlatformInfo,
                        SRCINFO_DESCRIPTION,
                        p,
                        RequiredSize,
                        NULL
                       );
    *Description = p;

    //
    // Get tagfile, if any.
    //
    b = pSetupGetSourceInfo(InfHandle,
                            LayoutLineContext,
                            SourceId,
                            AltPlatformInfo,
                            SRCINFO_TAGFILE,
                            NULL,
                            0,
                            &RequiredSize
                           );
    if(!b) {
        ec = GetLastError();
        goto clean2;
    }

    p = MyMalloc(RequiredSize*sizeof(TCHAR));
    if(!p) {
        ec =  ERROR_NOT_ENOUGH_MEMORY;
        goto clean2;
    }
    pSetupGetSourceInfo(InfHandle,
                        LayoutLineContext,
                        SourceId,
                        AltPlatformInfo,
                        SRCINFO_TAGFILE,
                        p,
                        RequiredSize,
                        NULL
                       );
    if(*p) {
        *Tagfile = p;
    } else {
        MyFree(p);
        *Tagfile = NULL;
    }

    //
    // Get flags, if any.
    //
    b = pSetupGetSourceInfo(InfHandle,
                            LayoutLineContext,
                            SourceId,
                            AltPlatformInfo,
                            SRCINFO_FLAGS,
                            Buffer,
                            SIZECHARS(Buffer),
                            NULL
                           );
    if(!b) {
        ec = GetLastError();
        goto clean3;
    }

    pAToI( Buffer, SourceFlags );


    return(TRUE);

clean3:
    MyFree(*Tagfile);
clean2:
    MyFree(*Description);
clean1:
    MyFree(*RelativePath);
clean0:
    SetLastError(ec);
    return(FALSE);
}


BOOL
pIsFileInDriverCache(
    IN  HINF   CabInf,
    IN  PCTSTR TargetFilename,
    IN  PCTSTR SubDirectory,
    OUT PCTSTR *CacheName
    )
{
    INFCONTEXT Context,SectionContext;
    PCTSTR      SectionName,CabName;
    TCHAR      TempBuffer[MAX_PATH];

    UINT Field, FieldCount;

    MYASSERT(CabInf != INVALID_HANDLE_VALUE);
    MYASSERT(TargetFilename);
    MYASSERT(CacheName);

    if (!SetupFindFirstLine(CabInf, TEXT("Version"), TEXT("CabFiles"), &SectionContext)) {
        return(FALSE);
    }

    do  {


        FieldCount = SetupGetFieldCount(&SectionContext);
        for(Field=1; Field<=FieldCount; Field++) {

            SectionName = pSetupGetField(&SectionContext,Field);

            if (SetupFindFirstLine(CabInf,SectionName,TargetFilename,&Context)) {
                //
                // we found a match
                //
                if (SetupFindFirstLine(CabInf,TEXT("Cabs"),SectionName,&Context)) {
                    CabName= pSetupGetField(&Context,1);
                    //if (pIsDriverCachePresent(CabName,SubDirectory,TempBuffer)) {
                        *CacheName = DuplicateString( CabName );
                        if (*CacheName) {
                            return(TRUE);
                        }
                    //}
                }
            }
        } // end for

    } while (SetupFindNextMatchLine(&SectionContext,TEXT("CabFiles"),&SectionContext));

    return(FALSE);

}

BOOL
pIsDriverCachePresent(
    IN     PCTSTR DriverName,
    IN     PCTSTR Subdirectory,
    IN OUT PTSTR DriverBuffer
    )
/*++

Routine Description:

    Looks at the proper location for the driver cache cab-file, and if it's
    present, return TRUE.  If present, it returns the partial path to the
    cab file

Arguments:

    DriveName    - the cab file we're looking for

    Subdirectory - if specified, use this as the subdirectory from the root of the driver
                   cache, otherwise use the specified architecture's subdirectory

    DriverBuffer - if the cab file is present, return the source root to the cab file


Return Value:

    TRUE if the cab file is present

--*/

{

    TCHAR TempBuffer[MAX_PATH];

    if (!DriverCacheSourcePath || !DriverName) {
        return FALSE;
    }

    if (!Subdirectory) {
        Subdirectory =
#if   defined(_AXP64_)
         TEXT("axp64");
#elif defined(_ALPHA_)
         TEXT("alpha");
#elif defined(_X86_)
         IsNEC98() ? TEXT("nec98") : TEXT("i386");
#elif defined(_IA64_)
         TEXT("ia64");
#elif defined(_AMD64_)
         TEXT("amd64");
#endif
    }

    lstrcpy(TempBuffer, DriverCacheSourcePath);
    pSetupConcatenatePaths(TempBuffer, Subdirectory , MAX_PATH, NULL);
    pSetupConcatenatePaths(TempBuffer, DriverName, MAX_PATH, NULL);

    if (FileExists(TempBuffer,NULL)) {
        lstrcpy(DriverBuffer,DriverCacheSourcePath);
        return(TRUE);
    }

    return(FALSE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\fileq5.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    fileq5.c

Abstract:

    Default queue callback function.

Author:

    Ted Miller (tedm) 24-Feb-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define QUEUECONTEXT_SIGNATURE (DWORD)(0x43515053) // 'CQPS'

typedef struct _QUEUECONTEXT {
    DWORD Signature; // an attempt to catch re-use of deleted queuecontext
    HWND OwnerWindow;
    DWORD MainThreadId;
    HWND ProgressDialog;
    HWND ProgressBar;
    BOOL Cancelled;
    PTSTR CurrentSourceName;
    BOOL ScreenReader;
    BOOL MessageBoxUp;
    WPARAM  PendingUiType;
    PVOID   PendingUiParameters;
    UINT    CancelReturnCode;
    BOOL DialogKilled;
    //
    // If the SetupInitDefaultQueueCallbackEx is used, the caller can
    // specify an alternate handler for progress. This is useful to
    // get the default behavior for disk prompting, error handling, etc,
    // but to provide a gas gauge embedded, say, in a wizard page.
    //
    // The alternate window is sent ProgressMsg once when the copy queue
    // is started (wParam = 0. lParam = number of files to copy).
    // It is then also sent once per file copied (wParam = 1. lParam = 0).
    //
    // NOTE: a silent installation (i.e., no progress UI) can be accomplished
    // by specifying an AlternateProgressWindow handle of INVALID_HANDLE_VALUE.
    //
    HWND AlternateProgressWindow;
    UINT ProgressMsg;
    UINT NoToAllMask;

    HANDLE UiThreadHandle;
    //
    // instead of posting responses to main thread, use an event with flags
    //
    HANDLE hEvent;
    BOOL bDialogExited;
    LPARAM lParam;

#ifdef NOCANCEL_SUPPORT
    BOOL AllowCancel;
#endif

} QUEUECONTEXT, *PQUEUECONTEXT;

typedef struct _VERDLGCONTEXT {
    PQUEUECONTEXT QueueContext;
    UINT Notification;
    UINT_PTR Param1;
    UINT_PTR Param2;
} VERDLGCONTEXT, *PVERDLGCONTEXT;

#define WMX_PROGRESSTHREAD  (WM_APP+0)
#define WMX_KILLDIALOG      (WM_APP+1)
#define WMX_HELLO           (WM_APP+2)
#define WMX_PERFORMUI       (WM_APP+3)

#define UI_NONE             0
#define UI_COPYERROR        1
#define UI_DELETEERROR      2
#define UI_RENAMEERROR      3
#define UI_NEEDMEDIA        4
#define UI_MISMATCHERROR    5
#define UI_BACKUPERROR      6


typedef struct _COPYERRORUI {
    TCHAR       Buffer[MAX_PATH];
    PTCHAR      Filename;
    PFILEPATHS  FilePaths;
    DWORD       Flags;
    PTSTR       PathOut;
} COPYERRORUI, *PCOPYERRORUI;

typedef struct _NEEDMEDIAUI {
    PSOURCE_MEDIA   SourceMedia;
    DWORD           Flags;
    PTSTR           PathOut;
} NEEDMEDIAUI, *PNEEDMEDIAUI;


PCTSTR DialogPropName = TEXT("_context");

INT_PTR
pSetupProgressDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

LPARAM
pPerformUi (
    IN  PQUEUECONTEXT   Context,
    IN  UINT            UiType,
    IN  PVOID           UiParameters
    );


VOID
__cdecl
pSetupProgressThread(
    IN PVOID Context
    )

/*++

Routine Description:

    Thread entry point for setup file progress indicator.
    Puts up a dialog box.

Arguments:

    Context - supplies queue context.

Return Value:

    0 if unsuccessful, non-0 if successful.

--*/

{
    PQUEUECONTEXT context;
    INT_PTR i;
    MSG msg;

    //
    // Force this thread to have a message queue, just in case.
    //
    PeekMessage(&msg,NULL,0,0,PM_NOREMOVE);

    //
    // The thread parameter is the queue context.
    //
    context = Context;

    //
    // Create the progress dialog box.
    //
    i = DialogBoxParam(
            MyDllModuleHandle,
            MAKEINTRESOURCE(IDD_FILEPROGRESS),
            context->OwnerWindow,
            pSetupProgressDlgProc,
            (LPARAM)context
            );

    //
    // flag that this is the very last time hEvent will be set
    //
    context->bDialogExited = TRUE;
    SetEvent(context->hEvent);

    //
    // Done.
    //
    _endthread();
}

BOOL
pWaitForUiResponse(
    IN OUT PQUEUECONTEXT Context
    )
/*++

Routine Description:

    Waits for UI event to be set

Arguments:

    Context - supplies queue-context structure

Return Value:

    FALSE = failure

--*/
{
    BOOL KeepWaiting = TRUE;
    DWORD WaitProcStatus;

    if (Context->hEvent == NULL) {
        MYASSERT(Context->hEvent);
        return FALSE;
    }
    if (Context->bDialogExited) {
        //
        // dialog has already exited, we wont get another event
        //
        return FALSE;
    }

    while (KeepWaiting) {
        WaitProcStatus = MyMsgWaitForMultipleObjectsEx(
            1,
            &Context->hEvent,
            INFINITE,
            QS_ALLINPUT,
            MWMO_ALERTABLE | MWMO_INPUTAVAILABLE);
        switch (WaitProcStatus) {
        case WAIT_OBJECT_0 + 1: { // Process gui messages
            MSG msg;

            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }

            // fall through ...
        }
        case WAIT_IO_COMPLETION:
            break;

        case WAIT_OBJECT_0:
        case WAIT_TIMEOUT:
        default:
            KeepWaiting = FALSE;
            break;
        }
    }

    return TRUE;
}

UINT
PostUiMessage (
    IN      PQUEUECONTEXT Context,
    IN      UINT          UiType,
    IN      UINT          CancelCode,
    IN OUT  PVOID         UiParameters
    )
{
    MSG msg;

    if(IsWindow(Context->ProgressDialog)) {
        //
        // Let progress ui thread handle it.
        //
        Context->lParam = FILEOP_ABORT; // in case nobody gets chance to set Context->lParam
        PostMessage(
            Context->ProgressDialog,
            WMX_PERFORMUI,
            MAKEWPARAM(UiType,CancelCode),
            (LPARAM)UiParameters
            );
        pWaitForUiResponse(Context);
        return (UINT)Context->lParam;
    } else {
        //
        // There is no progress thread so do it synchronously.
        //
        return (UINT)pPerformUi(Context,UiType,UiParameters);
    }

    return 0;
}


UINT
pNotificationStartQueue(
    IN PQUEUECONTEXT Context
    )

/*++

Routine Description:

    Handle SPFILENOTIFY_STARTQUEUE.

    Creates a progress dialog in a separate thread.

Arguments:

    Context - supplies queue context.

Return Value:

    0 if unsuccessful, non-0 if successful.

--*/

{
    ULONG_PTR Thread;
    MSG msg;

    //
    // SetupCommitFileQueue could have been called in a different
    // thread. Adjust the thread id.
    //
    Context->MainThreadId = GetCurrentThreadId();

    //
    // Force this thread to have a message queue. If we don't do this,
    // then PostMessage, PostThreadMessage, etc can fail, which results
    // in hangs in some cases since we rely heavily on these for
    // progress, synchronization, etc.
    //
    PeekMessage(&msg,NULL,0,0,PM_NOREMOVE);

    if(Context->AlternateProgressWindow) {
        //
        // Either the caller is supplying their own window for progress UI,
        // or this is a silent install (AlternateProgressWindow is
        // INVALID_HANDLE_VALUE).
        //
        return(TRUE);
    } else {
        //
        // Fire up the progress dialog in a separate thread.
        // This allows it to be responsive without suspending
        // the file operations.
        //
        Thread = _beginthread(
                    pSetupProgressThread,
                    0,
                    Context
                    );

        if(Thread == -1) {
            //
            // assume OOM
            //
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(0);
        }

        //
        // Wait for notification from the thread about the state
        // of the dialog. Assume out of memory if we fail
        //
        if(!pWaitForUiResponse(Context) || Context->bDialogExited) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        } else {
            return TRUE;
        }
    }
}


UINT
pNotificationStartEndSubqueue(
    IN PQUEUECONTEXT Context,
    IN BOOL          Start,
    IN UINT_PTR      Operation,
    IN UINT_PTR      OpCount
    )

/*++

Routine Description:

    Handle SPFILENOTIFY_STARTSUBQUEUE, SPFILENOTIFY_ENDSUBQUEUE.

    Initializes/terminates a progress control.
    Also sets progress dialog caption.

Arguments:

    Context - supplies queue context.

    Start - if TRUE, then this routine is being called to handle
        a subqueue start notification. Otherwise it's supposed to
        handle a subqueue end notification.

    Operation - one of FILEOP_COPY, FILEOP_DELETE, FILEOP_RENAME.

    OpCount - supplies number of copies, renames, or deletes.

Return Value:

    0 if unsuccessful, non-0 if successful.

--*/

{
    UINT rc;
    UINT CaptionStringId;
    TCHAR ParentText[256];
    BOOL GotParentText;
    PCTSTR CaptionText;
    UINT AnimationId;
    HWND Animation;

    rc = 1;         // assume success.

    if(Context->Cancelled) {
        SetLastError(ERROR_CANCELLED);
        return(0);
    }

    if(Start) {

        if(IsWindow(Context->OwnerWindow)
        && GetWindowText(Context->OwnerWindow,ParentText,256)) {
            GotParentText = TRUE;
        } else {
            GotParentText = FALSE;
        }

        //
        // Clean out the text fields first.
        //
        if(IsWindow(Context->ProgressDialog)) {
            SetDlgItemText(Context->ProgressDialog,IDT_TEXT1,TEXT(""));
            SetDlgItemText(Context->ProgressDialog,IDT_TEXT2,TEXT(""));
        }

        switch(Operation) {

        case FILEOP_COPY:
            //
            // IDT_TEXT1 = target name sans path
            // IDT_TEXT2 = target name with path
            //
            if(IsWindow(Context->ProgressDialog)) {
                ShowWindow(GetDlgItem(Context->ProgressDialog,IDT_TEXT2),SW_SHOW);
            }
            CaptionStringId = GotParentText ? IDS_COPY_CAPTION1 : IDS_COPY_CAPTION2;
            AnimationId = IDA_FILECOPY;
            break;

        case FILEOP_RENAME:
            if(IsWindow(Context->ProgressDialog)) {
                ShowWindow(GetDlgItem(Context->ProgressDialog,IDT_TEXT2),SW_SHOW);
            }
            CaptionStringId = GotParentText ? IDS_RENAME_CAPTION1 : IDS_RENAME_CAPTION2;
            AnimationId = IDA_FILECOPY;
            break;

        case FILEOP_DELETE:
            //
            // IDT_TEXT1 = target name sans path
            // IDT_TEXT2 = path
            //
            if(IsWindow(Context->ProgressDialog)) {
                ShowWindow(GetDlgItem(Context->ProgressDialog,IDT_TEXT2),SW_HIDE);
            }
            CaptionStringId = GotParentText ? IDS_DELETE_CAPTION1 : IDS_DELETE_CAPTION2;
            AnimationId = IDA_FILEDEL;
            break;

        case FILEOP_BACKUP:
            // handle the new backup case (this is for a backup queue as opposed to on demand
            if(IsWindow(Context->ProgressDialog)) {
                ShowWindow(GetDlgItem(Context->ProgressDialog,IDT_TEXT2),SW_SHOW);
            }
            CaptionStringId = GotParentText ? IDS_BACKUP_CAPTION1 : IDS_BACKUP_CAPTION2;
            AnimationId = IDA_FILECOPY;
            break;

        default:
            SetLastError(ERROR_INVALID_PARAMETER);
            rc = 0;
            break;
        }

        if(rc) {
            //
            // Set dialog caption.
            //
            if(GotParentText) {
                CaptionText = FormatStringMessage(CaptionStringId,ParentText);
            } else {
                CaptionText = MyLoadString(CaptionStringId);
            }
            if(CaptionText) {
                if(IsWindow(Context->ProgressDialog)) {
                    if(!SetWindowText(Context->ProgressDialog,CaptionText)) {
                        SetWindowText(Context->ProgressDialog,TEXT(""));
                    }
                }
                MyFree(CaptionText);
            }

            if(Context->AlternateProgressWindow) {
                //
                // If this is really an alternate progress window, notify it
                // about the number of operations. Copy only.
                //
                if((Operation == FILEOP_COPY) &&
                   (Context->AlternateProgressWindow != INVALID_HANDLE_VALUE)) {

                    SendMessage(Context->AlternateProgressWindow,
                                Context->ProgressMsg,
                                0,
                                OpCount
                               );
                }
            } else {
                //
                // Set up the progress control. Each file will be 1 tick.
                //
                if(IsWindow(Context->ProgressBar)) {
                    SendMessage(Context->ProgressBar,PBM_SETRANGE,0,MAKELPARAM(0,OpCount));
                    SendMessage(Context->ProgressBar,PBM_SETSTEP,1,0);
                    SendMessage(Context->ProgressBar,PBM_SETPOS,0,0);
                }

                //
                // And set up the animation control based on the operation type.
                //
                if(OpCount && IsWindow(Context->ProgressDialog)) {

                    Animation = GetDlgItem(Context->ProgressDialog,IDA_ANIMATION);

                    if(Animation) {
                        Animate_Open(Animation,MAKEINTRESOURCE(AnimationId));
                        Animate_Play(Animation,0,-1,-1);
                    }
                }
            }
        }
    } else {
        //
        // Stop the animation control. Note that if the op count was 0
        // then we never started it, so stopping/unloading will give an error,
        // which we ignore. It's not harmful.
        //
        if(!Context->AlternateProgressWindow && IsWindow(Context->ProgressDialog)) {

            Animation = GetDlgItem(Context->ProgressDialog,IDA_ANIMATION);
            if (Animation) {
                Animate_Stop(Animation);
                Animate_Close(Animation);
            }
        }
    }

    return(rc);
}


UINT
pNotificationStartOperation(
    IN PQUEUECONTEXT Context,
    IN PFILEPATHS    FilePaths,
    IN UINT_PTR      Operation
    )

/*++

Routine Description:

    Handle SPFILENOTIFY_STARTRENAME, SPFILENOTIFY_STARTDELETE,
    SPFILENOTIFY_STARTCOPY or SPFILENOTIFY_STARTBACKUP.

    Updates text in the progress dialog to indicate the files
    involved in the operation.

Arguments:

    Context - supplies queue context.

    Start - if TRUE, then this routine is being called to handle
        a subqueue start notification. Otherwise it's supposed to
        handle a subqueue end notification.

    Operation - one of FILEOP_COPY, FILEOP_DELETE, FILEOP_RENAME.

    OpCount - supplies number of copies, renames, or deletes.

Return Value:

    FILEOP_ABORT if error, otherwise FILEOP_DOIT.
--*/

{
    PCTSTR Text1,Text2;
    PTSTR p;
    TCHAR Target[MAX_PATH];
    UINT rc;
    DWORD ec;

    if(Context->Cancelled) {
        SetLastError(ERROR_CANCELLED);
        return(FILEOP_ABORT);
    }

    Text1 = Text2 = NULL;
    rc = FILEOP_ABORT;
    ec = ERROR_NOT_ENOUGH_MEMORY;

    switch(Operation) {
    case FILEOP_COPY:
        lstrcpyn(Target,FilePaths->Target,MAX_PATH);
        if(p = _tcsrchr(Target,TEXT('\\'))) {
            //
            // Ignore the source filename completely.
            //
            *p++ = 0;
            Text1 = DuplicateString(p);
            Text2 = FormatStringMessage(IDS_FILEOP_TO,Target);
        } else {
            //
            // Assume not full path -- strange case, but deal with it anyway.
            //
            Text1 = DuplicateString(FilePaths->Target);
            Text2 = DuplicateString(TEXT(""));
        }
        break;

    case FILEOP_RENAME:

        Text1 = DuplicateString(FilePaths->Source);
        if(p = _tcsrchr(FilePaths->Target,TEXT('\\'))) {
            p++;
        } else {
            p = (PTSTR)FilePaths->Target;
        }
        Text2 = FormatStringMessage(IDS_FILEOP_TO,p);
        break;

    case FILEOP_DELETE:

        lstrcpyn(Target,FilePaths->Target,MAX_PATH);
        if(p = _tcsrchr(Target,TEXT('\\'))) {
            *p++ = 0;
            Text1 = DuplicateString(p);
            Text2 = FormatStringMessage(IDS_FILEOP_FROM,Target);
        } else {
            //
            // Assume not full path -- strange case, but deal with it anyway.
            //
            Text1 = DuplicateString(FilePaths->Target);
            Text2 = DuplicateString(TEXT(""));
        }
        break;

    case FILEOP_BACKUP:
        lstrcpyn(Target,FilePaths->Source,MAX_PATH);
        if(p = _tcsrchr(Target,TEXT('\\'))) {
            //
            // FilePaths->Source = what we're backing up (which is target of a restore)
            // FilePaths->Target = where we're backing up to (block backup) or NULL (demand backup)
            //
            *p++ = 0;
            if (FilePaths->Target == NULL) {
                // Backing up <Filename>
                Text1 = FormatStringMessage(IDS_FILEOP_BACKUP,p);
            } else {
                // <Filename> (title already says Backing up)
                Text1 = DuplicateString(p);
            }
            // From <Directory>
            Text2 = FormatStringMessage(IDS_FILEOP_FROM,Target);
        } else {
            //
            // Assume not full path -- strange case, but deal with it anyway.
            //
            if (FilePaths->Source == NULL) {
                Text1 = FormatStringMessage(IDS_FILEOP_BACKUP,Target);
            } else {
                Text1 = DuplicateString(Target);
            }
            Text2 = DuplicateString(TEXT(""));
        }
        break;


    default:
        ec = ERROR_INVALID_PARAMETER;
        break;
    }

    if(Text1 && Text2) {
        if(IsWindow(Context->ProgressDialog)) {
            SetDlgItemText(Context->ProgressDialog,IDT_TEXT1,Text1);
            SetDlgItemText(Context->ProgressDialog,IDT_TEXT2,Text2);
        }
        rc = FILEOP_DOIT;
    }

    if(Text1) {
        MyFree(Text1);
    }
    if(Text2) {
        MyFree(Text2);
    }
    SetLastError(ec);
    return(rc);
}


UINT
pNotificationErrorCopy(
    IN  PQUEUECONTEXT Context,
    IN  PFILEPATHS    FilePaths,
    OUT PTSTR         PathOut
    )
{
    UINT rc;
    COPYERRORUI CopyError;


    CopyError.FilePaths = FilePaths;
    CopyError.PathOut = PathOut;

    //
    // Buffer gets the pathname part of the source
    // and p points to the filename part of the source.
    //
    lstrcpyn(CopyError.Buffer,FilePaths->Source,MAX_PATH);
    CopyError.Filename = _tcsrchr(CopyError.Buffer,TEXT('\\'));
    *CopyError.Filename++ = 0;

    //
    // The noskip and warnifskip flags are really mutually exclusive
    // but we don't try to enforce that here. Just pass through as
    // appropriate.
    //
    CopyError.Flags = 0;
    if(FilePaths->Flags & SP_COPY_NOSKIP) {
        CopyError.Flags |= IDF_NOSKIP;
    }
    if(FilePaths->Flags & SP_COPY_WARNIFSKIP) {
        CopyError.Flags |= IDF_WARNIFSKIP;
    }
    //
    // Also pass through the 'no browse' flag.
    //
    if(FilePaths->Flags & SP_COPY_NOBROWSE) {
        CopyError.Flags |= IDF_NOBROWSE;
    }

    rc = PostUiMessage (Context, UI_COPYERROR, DPROMPT_CANCEL, &CopyError);

    switch(rc) {

    case DPROMPT_SUCCESS:
        //
        // If a new path is indicated, verify that it actually changed.
        //
        if(CopyError.PathOut[0] &&
            !lstrcmpi(CopyError.Buffer,CopyError.PathOut)) {
            CopyError.PathOut[0] = 0;
        }
        rc = FILEOP_RETRY;
        break;

    case DPROMPT_SKIPFILE:
        rc = FILEOP_SKIP;
        break;

    case DPROMPT_CANCEL:
        SetLastError(ERROR_CANCELLED);
        rc = FILEOP_ABORT;
        break;

    default:
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        rc = FILEOP_ABORT;
        break;
    }

    return(rc);
}

UINT
pNotificationStartRegistration(
    IN  PQUEUECONTEXT Context,
    IN  PSP_REGISTER_CONTROL_STATUS ControlStatus,
    IN  BOOL Register
    )
{

    return FILEOP_DOIT;
}


UINT
pNotificationErrorDelete(
    IN  PQUEUECONTEXT Context,
    IN  PFILEPATHS    FilePaths
    )
{
    UINT rc;

    //
    // Certain errors are not actually errors.
    //
    if((FilePaths->Win32Error == ERROR_FILE_NOT_FOUND)
    || (FilePaths->Win32Error == ERROR_PATH_NOT_FOUND)) {
        return(FILEOP_SKIP);
    }

    rc = PostUiMessage (Context, UI_DELETEERROR, DPROMPT_CANCEL, FilePaths);

    switch(rc) {

    case DPROMPT_SUCCESS:
        return(FILEOP_RETRY);

    case DPROMPT_SKIPFILE:
        return(FILEOP_SKIP);

    case DPROMPT_CANCEL:
        SetLastError(ERROR_CANCELLED);
        return(FILEOP_ABORT);

    default:
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FILEOP_ABORT);
    }
}


UINT
pNotificationErrorRename(
    IN  PQUEUECONTEXT Context,
    IN  PFILEPATHS    FilePaths
    )
{
    UINT rc;

    rc = PostUiMessage (Context, UI_RENAMEERROR, DPROMPT_CANCEL, FilePaths);

    switch(rc) {

    case DPROMPT_SUCCESS:
        return(FILEOP_RETRY);

    case DPROMPT_SKIPFILE:
        return(FILEOP_SKIP);

    case DPROMPT_CANCEL:
        SetLastError(ERROR_CANCELLED);
        return(FILEOP_ABORT);

    default:
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FILEOP_ABORT);
    }
}

UINT
pNotificationErrorBackup(
    IN  PQUEUECONTEXT Context,
    IN  PFILEPATHS    FilePaths
    )
{
    UINT rc;

    if(!(FilePaths->Flags & SP_BACKUP_SPECIAL)) {
        return FILEOP_SKIP;
    }

    rc = PostUiMessage (Context, UI_BACKUPERROR, DPROMPT_CANCEL, FilePaths);

    switch(rc) {

    case DPROMPT_SUCCESS:
        return(FILEOP_RETRY);

    case DPROMPT_SKIPFILE:
        return(FILEOP_SKIP);

    case DPROMPT_CANCEL:
        SetLastError(ERROR_CANCELLED);
        return(FILEOP_ABORT);

    default:
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FILEOP_ABORT);
    }
}


UINT
pNotificationNeedMedia(
    IN  PQUEUECONTEXT Context,
    IN  PSOURCE_MEDIA SourceMedia,
    OUT PTSTR         PathOut
    )
{
    UINT rc;
    TCHAR Buffer[MAX_PATH];
    NEEDMEDIAUI NeedMedia;

    if(Context->Cancelled) {
        SetLastError(ERROR_CANCELLED);
        return(FILEOP_ABORT);
    }

    NeedMedia.SourceMedia = SourceMedia;
    NeedMedia.PathOut = PathOut;

    //
    // Remember the name of this media.
    //
    if(Context->CurrentSourceName) {
        MyFree(Context->CurrentSourceName);
        Context->CurrentSourceName = NULL;
    }
    if(SourceMedia->Description) {
        Context->CurrentSourceName = DuplicateString(SourceMedia->Description);
        if(!Context->CurrentSourceName) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(FILEOP_ABORT);
        }
    }

    //
    // Set the source file in the progress dialog
    // so it matches the file being sought.
    //
    if(!(SourceMedia->Flags & SP_FLAG_CABINETCONTINUATION)) {
        if(IsWindow(Context->ProgressDialog) && !Context->ScreenReader) {
            DWORD chars;
            lstrcpyn(Buffer,SourceMedia->SourcePath,MAX_PATH);
            pSetupConcatenatePaths(Buffer,SourceMedia->SourceFile,MAX_PATH,NULL);
            SetTruncatedDlgItemText(Context->ProgressDialog,IDT_TEXT1,Buffer);
            SetDlgItemText(Context->ProgressDialog,IDT_TEXT2,TEXT(""));
        }
    }

    //
    // The noskip and warnifskip flags are really mutually exclusive
    // but we don't try to enforce that here. Just pass through as
    // appropriate.
    //
    // Allow skip if this is not a cabinet continuation and
    // the noskip flag is not set.
    //
    NeedMedia.Flags = IDF_CHECKFIRST;
    if(SourceMedia->Flags & (SP_FLAG_CABINETCONTINUATION | SP_COPY_NOSKIP)) {
        NeedMedia.Flags |= IDF_NOSKIP;
    }
    if(SourceMedia->Flags & SP_COPY_WARNIFSKIP) {
        NeedMedia.Flags |= IDF_WARNIFSKIP;
    }
    if(SourceMedia->Flags & SP_COPY_NOBROWSE) {
        NeedMedia.Flags |= IDF_NOBROWSE;
    }

    rc = PostUiMessage (Context, UI_NEEDMEDIA, DPROMPT_CANCEL, &NeedMedia);

    switch(rc) {

    case DPROMPT_SUCCESS:
        //
        // If the path really has changed, then return NEWPATH.
        // Otherwise return DOIT. Account for trailing backslash
        // differences.
        //
        lstrcpyn(Buffer,SourceMedia->SourcePath,MAX_PATH);

        rc = lstrlen(Buffer);
        if(rc && (*CharPrev(Buffer,Buffer+rc) == TEXT('\\'))) {
            Buffer[rc-1] = TEXT('\0'); // valid to do if last char is '\'
        }

        rc = lstrlen(NeedMedia.PathOut);
        if(rc && (*CharPrev(NeedMedia.PathOut,NeedMedia.PathOut+rc) == TEXT('\\'))) {
            NeedMedia.PathOut[rc-1] = TEXT('\0'); // valid to do if last char is '\'
        }

        rc = (lstrcmpi(SourceMedia->SourcePath,NeedMedia.PathOut) ?
            FILEOP_NEWPATH : FILEOP_DOIT);

        //
        // Make sure <drive>: ends with a \.
        //
        if(NeedMedia.PathOut[0] && (NeedMedia.PathOut[1] == TEXT(':')) &&
            !NeedMedia.PathOut[2]) {
            NeedMedia.PathOut[2] = TEXT('\\');
            NeedMedia.PathOut[3] = TEXT('\0');
        }

        break;

    case DPROMPT_SKIPFILE:
        rc = FILEOP_SKIP;
        break;

    case DPROMPT_CANCEL:
        SetLastError(ERROR_CANCELLED);
        rc = FILEOP_ABORT;
        break;

    default:
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        rc = FILEOP_ABORT;
        break;
    }

    return(rc);
}


INT_PTR
pNotificationVersionDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    PVERDLGCONTEXT context;
    PFILEPATHS filePaths;
    HWND hwnd;
    TCHAR text[128];
    TCHAR Buffer[MAX_PATH*2];
    PCTSTR message;
    int i;
    TCHAR SourceLangName[128];
    TCHAR TargetLangName[128];

    switch(msg) {

    case WM_INITDIALOG:

        context = (PVERDLGCONTEXT)lParam;
        MYASSERT(context != NULL);

        filePaths = (PFILEPATHS)context->Param1;

        SetProp(hdlg,DialogPropName,(HANDLE)context);

        //
        // Set the source and target filenames. Hack: if the source filename
        // looks like one of our temporary filenames from a cabinet extraction,
        // hide it.
        //
        message = pSetupGetFileTitle(filePaths->Source);
        i = lstrlen(message);
        if((i > 8)
        && ((TCHAR)CharUpper((LPTSTR)message[0]) == TEXT('S'))
        && ((TCHAR)CharUpper((LPTSTR)message[1]) == TEXT('E'))
        && ((TCHAR)CharUpper((LPTSTR)message[2]) == TEXT('T'))
        && ((TCHAR)CharUpper((LPTSTR)message[3]) == TEXT('P'))
        && !lstrcmpi(message+(i-4),TEXT(".TMP"))) {

            ShowWindow(GetDlgItem(hdlg,IDT_TEXT7),SW_HIDE);

        } else {
            GetDlgItemText(hdlg,IDT_TEXT7,text,SIZECHARS(text));
            message = FormatStringMessageFromString(text,filePaths->Source);
            if (message == NULL) goto no_memory;
            SetTruncatedDlgItemText(hdlg,IDT_TEXT7,message);
            MyFree(message);
        }

        GetDlgItemText(hdlg,IDT_TEXT8,text,SIZECHARS(text));
        message = FormatStringMessageFromString(text,filePaths->Target);
        if (message == NULL) goto no_memory;
        SetTruncatedDlgItemText(hdlg,IDT_TEXT8,message);
        MyFree(message);

        if (context->Notification & SPFILENOTIFY_LANGMISMATCH) {
            //
            // Language mismatch has the highest priority.
            //
            context->Notification = SPFILENOTIFY_LANGMISMATCH; // force other bits off, for NoToAll

            //
            // Format the overwrite question.
            //
            if(PRIMARYLANGID(LOWORD(context->Param2))==LANG_NEUTRAL) {
                LoadString(
                    MyDllModuleHandle,
                    IDS_LANG_NEUTRAL,
                    SourceLangName,
                    SIZECHARS(SourceLangName)
                    );
            } else {
                i = GetLocaleInfo(
                        MAKELCID(LOWORD(context->Param2),SORT_DEFAULT),
                        LOCALE_SLANGUAGE,
                        SourceLangName,
                        SIZECHARS(SourceLangName)
                        );
                if(!i) {
                    LoadString(
                        MyDllModuleHandle,
                        IDS_LANG_UNKNOWN,
                        SourceLangName,
                        SIZECHARS(SourceLangName)
                        );
                }
            }


            if(PRIMARYLANGID(HIWORD(context->Param2))==LANG_NEUTRAL) {
                LoadString(
                    MyDllModuleHandle,
                    IDS_LANG_NEUTRAL,
                    TargetLangName,
                    SIZECHARS(TargetLangName)
                    );
            } else {
                i = GetLocaleInfo(
                        MAKELCID(HIWORD(context->Param2),SORT_DEFAULT),
                        LOCALE_SLANGUAGE,
                        TargetLangName,
                        SIZECHARS(TargetLangName)
                        );
                if(!i) {
                    LoadString(
                        MyDllModuleHandle,
                        IDS_LANG_UNKNOWN,
                        TargetLangName,
                        SIZECHARS(TargetLangName)
                        );
                }
            }
            GetDlgItemText(hdlg,IDT_TEXT4,text,SIZECHARS(text));
            message = FormatStringMessageFromString(text,TargetLangName,SourceLangName);
            if (message == NULL) goto no_memory;
            SetDlgItemText(hdlg,IDT_TEXT4,message);
            MyFree(message);

            //
            // Turn off the TARGETNEWER and TARGETEXISTS messages.
            //
            hwnd = GetDlgItem(hdlg,IDT_TEXT2);
            ShowWindow(hwnd,SW_HIDE);
            hwnd = GetDlgItem(hdlg,IDT_TEXT3);
            ShowWindow(hwnd,SW_HIDE);
            hwnd = GetDlgItem(hdlg,IDT_TEXT5);
            ShowWindow(hwnd,SW_HIDE);
            hwnd = GetDlgItem(hdlg,IDT_TEXT6);
            ShowWindow(hwnd,SW_HIDE);

        } else if (context->Notification & SPFILENOTIFY_TARGETNEWER) {
            //
            // Target being newer has second highest priority.
            //
            context->Notification = SPFILENOTIFY_TARGETNEWER; // force other bits off, for NoToAll

            //
            // Turn off the LANGMISMATCH and TARGETEXISTS messages.
            //
            hwnd = GetDlgItem(hdlg,IDT_TEXT1);
            ShowWindow(hwnd,SW_HIDE);
            hwnd = GetDlgItem(hdlg,IDT_TEXT3);
            ShowWindow(hwnd,SW_HIDE);
            hwnd = GetDlgItem(hdlg,IDT_TEXT4);
            ShowWindow(hwnd,SW_HIDE);
            hwnd = GetDlgItem(hdlg,IDT_TEXT6);
            ShowWindow(hwnd,SW_HIDE);

        } else {            // must be exactly SPFILENOTIFY_TARGETEXISTS
            //
            // Target existing has the lowest priority.
            //
            // Turn off the LANGMISMATCH and TARGETNEWER messages.
            //
            hwnd = GetDlgItem(hdlg,IDT_TEXT1);
            ShowWindow(hwnd,SW_HIDE);
            hwnd = GetDlgItem(hdlg,IDT_TEXT2);
            ShowWindow(hwnd,SW_HIDE);
            hwnd = GetDlgItem(hdlg,IDT_TEXT4);
            ShowWindow(hwnd,SW_HIDE);
            hwnd = GetDlgItem(hdlg,IDT_TEXT5);
            ShowWindow(hwnd,SW_HIDE);

        }

        PostMessage(hdlg,WMX_HELLO,0,0);
        break;

    case WMX_HELLO:
        //
        // If this guy has no owner force him to the foreground.
        // This catches cases where people are using a series of
        // dialogs and then some setup apis, because when they
        // close a dialog focus switches away from them.
        //
        hwnd = GetWindow(hdlg,GW_OWNER);
        if(!IsWindow(hwnd)) {
            SetForegroundWindow(hdlg);
        }
        break;

    case WM_COMMAND:
        context = (PVERDLGCONTEXT)GetProp(hdlg,DialogPropName);
        MYASSERT(context != NULL);
        switch (GET_WM_COMMAND_ID(wParam,lParam)) {

        case IDYES:
            EndDialog(hdlg,IDYES);  // copy this file
            break;

        case IDNO:
            EndDialog(hdlg,IDNO);   // skip this file
            break;

        case IDB_NOTOALL:
            //
            // No to All was selected.  Add this notification type to the
            // NoToAllMask so that we don't ask about it again.
            //
            context->QueueContext->NoToAllMask |= context->Notification;
            EndDialog(hdlg,IDNO);   // skip this file
            break;
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;

no_memory:
    pSetupOutOfMemory(
        IsWindow(context->QueueContext->ProgressDialog) ?
            context->QueueContext->ProgressDialog : context->QueueContext->OwnerWindow
        );
    EndDialog(hdlg,IDNO);   // skip this file
    return TRUE;
}


LPARAM
pPerformUi (
    IN  PQUEUECONTEXT   Context,
    IN  UINT            UiType,
    IN  PVOID           UiParameters
    )
{
    PCOPYERRORUI    CopyError;
    PFILEPATHS      FilePaths;
    PNEEDMEDIAUI    NeedMedia;
    INT_PTR         rc;
    HWND            Animation;

    if(!Context->AlternateProgressWindow && IsWindow(Context->ProgressDialog)) {
        Animation = GetDlgItem(Context->ProgressDialog,IDA_ANIMATION);
    } else {
        Animation = NULL;
    }

    switch (UiType) {

    case UI_COPYERROR:
        CopyError = (PCOPYERRORUI)UiParameters;
        if (Animation) {
            Animate_Stop(Animation);
        }
        rc = SetupCopyError(
                IsWindow(Context->ProgressDialog) ? Context->ProgressDialog : Context->OwnerWindow,
                NULL,
                Context->CurrentSourceName,
                CopyError->Buffer,
                CopyError->Filename,
                CopyError->FilePaths->Target,
                CopyError->FilePaths->Win32Error,
                CopyError->Flags,
                CopyError->PathOut,
                MAX_PATH,
                NULL
                );
        if (Animation) {
            Animate_Play(Animation,0,-1,-1);
        }
        break;

    case UI_DELETEERROR:
        FilePaths = (PFILEPATHS)UiParameters;

        if (Animation) {
            Animate_Stop(Animation);
        }
        rc = SetupDeleteError(
                IsWindow(Context->ProgressDialog) ? Context->ProgressDialog : Context->OwnerWindow,
                NULL,
                FilePaths->Target,
                FilePaths->Win32Error,
                0
                );
        if (Animation) {
            Animate_Play(Animation,0,-1,-1);
        }

        break;

    case UI_RENAMEERROR:
        FilePaths = (PFILEPATHS)UiParameters;

        if(Animation) {
            Animate_Stop(Animation);
        }
        rc = SetupRenameError(
                IsWindow(Context->ProgressDialog) ? Context->ProgressDialog : Context->OwnerWindow,
                NULL,
                FilePaths->Source,
                FilePaths->Target,
                FilePaths->Win32Error,
                0
                );
        if(Animation) {
            Animate_Play(Animation,0,-1,-1);
        }

        break;

    case UI_BACKUPERROR:
        FilePaths = (PFILEPATHS)UiParameters;

        if(Animation) {
            Animate_Stop(Animation);
        }
        rc = SetupBackupError(
                IsWindow(Context->ProgressDialog) ? Context->ProgressDialog : Context->OwnerWindow,
                NULL,
                FilePaths->Source,
                FilePaths->Target,
                FilePaths->Win32Error,
                0
                );
        if(Animation) {
            Animate_Play(Animation,0,-1,-1);
        }

        break;

    case UI_NEEDMEDIA:
        NeedMedia = (PNEEDMEDIAUI)UiParameters;

        if(Animation) {
            Animate_Stop(Animation);
        }
        rc = SetupPromptForDisk(
                IsWindow(Context->ProgressDialog) ? Context->ProgressDialog : Context->OwnerWindow,
                NULL,
                NeedMedia->SourceMedia->Description,
                NeedMedia->SourceMedia->SourcePath,
                NeedMedia->SourceMedia->SourceFile,
                NeedMedia->SourceMedia->Tagfile,
                NeedMedia->Flags,
                NeedMedia->PathOut,
                MAX_PATH,
                NULL
                );
        if(Animation) {
            Animate_Play(Animation,0,-1,-1);
        }

        break;

    case UI_MISMATCHERROR:
        if(Animation) {
            Animate_Stop(Animation);
        }
        if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
            rc = DPROMPT_CANCEL;
        } else {
            rc = DialogBoxParam(
                     MyDllModuleHandle,
                     MAKEINTRESOURCE(IDD_REPLACE),
                     IsWindow(Context->ProgressDialog) ?
                        Context->ProgressDialog : Context->OwnerWindow,
                     pNotificationVersionDlgProc,
                     (LPARAM)UiParameters
                     );
        }
        if(Animation) {
            Animate_Play(Animation,0,-1,-1);
        }
        break;

    default:
        MYASSERT (0);
        rc = 0;
    }

    return rc;
}


INT_PTR
pSetupProgressDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;
    PQUEUECONTEXT Context;
    HWND hwnd;
    PTSTR p;
    INT_PTR i;
    MSG m;
    BOOL Cancelled;
    HANDLE h;
    static UINT uQueryCancelAutoPlay = 0;

    switch(msg) {

    case WM_INITDIALOG:

#ifdef PRERELEASE
        if (GuiSetupInProgress) {
            MYASSERT( FALSE && TEXT("bringing up file progress dialog (IDD_FILEPROGRESS) during gui-mode setup, which is a UI violation.  Click yes and retrive a stack trace to determine errant caller.\n"));
        }
#endif

        Context = (PQUEUECONTEXT)lParam;
        MYASSERT(Context != NULL);
        SetProp(hdlg,DialogPropName,(HANDLE)Context);

        #ifdef NOCANCEL_SUPPORT
        //
        // If cancel is not allowed, disable the cancel button.
        //
        if(!Context->AllowCancel) {

            RECT rect;
            RECT rect2;

            hwnd = GetDlgItem(hdlg,IDCANCEL);

            ShowWindow(hwnd,SW_HIDE);
            EnableWindow(hwnd,FALSE);

            GetWindowRect(hdlg,&rect);
            GetWindowRect(hwnd,&rect2);

            SetWindowPos(
                hdlg,
                NULL,
                0,0,
                rect.right - rect.left,
                (rect.bottom - rect.top) - (rect.bottom - rect2.top),
                SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOZORDER
                );
        }
#endif

        //
        // Center the progress dialog relative to the parent window.
        //
        pSetupCenterWindowRelativeToParent(hdlg);

        SetFocus(GetDlgItem(hdlg,IDCANCEL));

        //
        // The main thread is processing SPFILENOTIFY_STARTQUEUE and is
        // waiting for some notification about the state of the UI thread.
        // Let the main thread know we succeeded, and pass back a real
        // handle to this thread that can be used to wait for it to terminate.
        //
        b = DuplicateHandle(
                GetCurrentProcess(),    // source process
                GetCurrentThread(),     // source handle
                GetCurrentProcess(),    // target process
                &h,                     // new handle
                0,                      // ignored with DUPLICATE_SAME_ACCESS
                FALSE,                  // not inheritable
                DUPLICATE_SAME_ACCESS
                );

        if(!b) {
            //
            // Since we cannot duplicate the handle, we must kill this dialog,
            // because otherwise the inter-thread communication will be broken
            // and things go horribly wrong.
            //
            EndDialog(hdlg, -1);
            return TRUE;            // TRUE or FALSE, it really doesn't matter
        }

        //
        // Store the dialog and progress bar handles in the context structure.
        //
        Context->ProgressDialog = hdlg;
        Context->ProgressBar = GetDlgItem(hdlg,IDC_PROGRESS);

        Context->UiThreadHandle = h;
        PostMessage(hdlg,WMX_HELLO,0,0); // put WMX_HELLO on our message queue
        SetEvent(Context->hEvent); // inform caller we've done initialization

        b = FALSE;
        break;

    case WMX_HELLO:
        //
        // If this guy has no owner force him to the foreground.
        // This catches cases where people are using a series of
        // dialogs and then some setup apis, because when they
        // close a dialog focus switches away from them.
        //
        hwnd = GetWindow(hdlg,GW_OWNER);
        if(!IsWindow(hwnd)) {
            SetForegroundWindow(hdlg);
        }

        b = TRUE;

        break;

    case WMX_PERFORMUI:
        b = TRUE;
        Context = (PQUEUECONTEXT)GetProp(hdlg,DialogPropName);
        MYASSERT(Context != NULL);

        //
        // We'd better not already have any UI pending...
        //
        MYASSERT(Context->PendingUiType == UI_NONE);

        if (Context->MessageBoxUp == TRUE) {
            Context->PendingUiType = LOWORD (wParam);
            Context->CancelReturnCode = HIWORD (wParam);
            Context->PendingUiParameters = (PVOID)lParam;
        } else {
            Context->lParam = pPerformUi (Context, LOWORD(wParam), (PVOID)lParam);
            SetEvent(Context->hEvent); // wakeup main thread (lParam has Ui result)
        }

        break;

    case WM_COMMAND:
        Context = (PQUEUECONTEXT)GetProp(hdlg,DialogPropName);
        MYASSERT(Context != NULL);
        if((HIWORD(wParam) == BN_CLICKED) && (LOWORD(wParam) == IDCANCEL)) {
            p = MyLoadString(IDS_CANCELFILEOPS);
            Cancelled = FALSE;
            if(p) {
                //
                // While the message box is up, the main thread is still copying files,
                // and it might just complete. If that happens, the main thread will
                // post us WMX_KILLDIALOG, which would cause this dialog to nuke itself
                // out from under the message box. The main thread would then continue
                // executing while the message box is sitting there. Some components
                // actually unload setupapi.dll at that point, and so when the user
                // dismisses the message box, an AV results.
                //
                // We can't freeze the main thread via SuspendThread because then
                // that thread, which probably owns this dialog's parent window,
                // will not be able to process messages that result from the message box's
                // creation. Result is that the message box never comes up and the process
                // is deadlocked.
                //
                // We'd better not already have a message box up!
                //
                MYASSERT(!Context->MessageBoxUp);

                Context->MessageBoxUp = TRUE;
                i = MessageBox(
                        hdlg,
                        p,
                        TEXT(""),
                        MB_YESNO | MB_APPLMODAL | MB_DEFBUTTON2 | MB_SETFOREGROUND | MB_ICONQUESTION
                        );

                Context->MessageBoxUp = FALSE;

                //
                // We set b to TRUE if the dialog is going away.
                // We set Cancelled to TRUE if the user clicked the CANCEL button.
                //
                if(Context->DialogKilled) {
                    b = TRUE;
                    Cancelled = (i == IDYES);
                } else {
                    b = (i == IDYES);
                    Cancelled = b;
                }
                MyFree(p);
            } else {
                pSetupOutOfMemory(hdlg);
                Cancelled = TRUE;
                b = TRUE;
            }

            if(b) {
                if(Cancelled) {
                    Context->Cancelled = TRUE;
                }
                PostMessage(hdlg,WMX_KILLDIALOG,0,0);

                if (Context->PendingUiType != UI_NONE) {

                    //
                    // We now allow the main thread to continue.  Once we do
                    // so, the UI parameters that we passed to us are invalid.
                    // Cancel the pending UI.
                    //
                    Context->PendingUiType = UI_NONE;
                    Context->lParam = Context->CancelReturnCode;
                    SetEvent(Context->hEvent); // wake up main thread (lParam has UI result)
                }

            } else {
                if (Context->PendingUiType != UI_NONE) {
                    Context->lParam = pPerformUi(Context,
                                                 (UINT)Context->PendingUiType,
                                                 Context->PendingUiParameters);

                    Context->PendingUiType = UI_NONE;
                    SetEvent(Context->hEvent); // wake up main thread (lParam has UI result)
                }
            }
            b = TRUE;
        } else {
            b = FALSE;
        }
        break;

    case WMX_KILLDIALOG:
        //
        // Exit unconditionally. Clean up first.
        //
        b = TRUE;
        Context = (PQUEUECONTEXT)GetProp(hdlg, DialogPropName);
        MYASSERT(Context != NULL);
        if(Context->MessageBoxUp) {
            //
            // The user was still interacting with the "are you sure you
            // want to cancel" dialog and the copying finished. So we don't want
            // to nuke the dialog out from under the message box.
            //
            Context->DialogKilled = TRUE;
            break;
        }

        DestroyWindow(Context->ProgressBar);
        EndDialog(hdlg, 0);

        break;

    default:
        //
        // we disable autorun because it confuses the user.
        //
        if (!uQueryCancelAutoPlay) {
            uQueryCancelAutoPlay = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));
        }

        if (msg == uQueryCancelAutoPlay) {
            SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 1 );
            return 1;       // cancel auto-play
        }

        b = FALSE;
        break;
    }

    return(b);
}


PVOID
SetupInitDefaultQueueCallbackEx(
    IN HWND  OwnerWindow,
    IN HWND  AlternateProgressWindow, OPTIONAL
    IN UINT  ProgressMessage,
    IN DWORD Reserved1,
    IN PVOID Reserved2
    )
{
    PQUEUECONTEXT Context;
    BOOL b;

    Context = MyMalloc(sizeof(QUEUECONTEXT));
    if(Context) {
        ZeroMemory(Context,sizeof(QUEUECONTEXT));

        Context->Signature = QUEUECONTEXT_SIGNATURE;
        Context->hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
        if (Context->hEvent == NULL) {
            MyFree(Context);
            return NULL;
        }
        Context->OwnerWindow = OwnerWindow;
        Context->MainThreadId = GetCurrentThreadId();
        Context->ProgressMsg = ProgressMessage;
        Context->NoToAllMask = 0;

        //
        // If the caller specified NULL for the alternate progress window, and
        // we're running non-interactively, we want to treat this just as if
        // they'd specified INVALID_HANDLE_VALUE (i.e., suppress all progress
        // UI).
        //
        if((GlobalSetupFlags & PSPGF_NONINTERACTIVE) && !AlternateProgressWindow) {
            Context->AlternateProgressWindow = INVALID_HANDLE_VALUE;
        } else {
            Context->AlternateProgressWindow = AlternateProgressWindow;
        }

        if(SystemParametersInfo(SPI_GETSCREENREADER,0,&b,0) && b) {
            Context->ScreenReader = TRUE;
        } else {
            Context->ScreenReader = FALSE;
        }

#ifdef PRERELEASE
        //
        // if we're running in gui-mode setup, we suppress all setupapi progress UI
        // and only allow AlternateProgressWindow UI
        //
        if (GuiSetupInProgress
            && (Context->AlternateProgressWindow != (HWND)INVALID_HANDLE_VALUE)
            && !IsWindow(Context->AlternateProgressWindow)) {
            MYASSERT( FALSE && TEXT("SetupInitDefaultQueueCallbackEx() called in gui-setup without INVALID_HANDLE_VALUE, which means UI may be presented.  Click yes and retrieve the stack trace to detect errant caller.\n"));
        }
#endif

    }

    return(Context);
}


PVOID
SetupInitDefaultQueueCallback(
    IN HWND OwnerWindow
    )
{
#ifdef PRERELEASE
    if (GuiSetupInProgress) {
        MYASSERT( FALSE && TEXT("SetupInitDefaultQueueCallback() called in gui-setup, which means UI may be presented.  Click yes and retrieve the stack trace to detect the errant caller.\n"));
    }
#endif
    return(SetupInitDefaultQueueCallbackEx(OwnerWindow,NULL,0,0,NULL));
}


VOID
SetupTermDefaultQueueCallback(
    IN PVOID Context
    )
{
    PQUEUECONTEXT context;

    context = Context;

    try {
        if(context && context->Signature == QUEUECONTEXT_SIGNATURE) {
            if(context->CurrentSourceName) {
                MyFree(context->CurrentSourceName);
            }
            if (context->hEvent) {
                CloseHandle(context->hEvent);
            }
            context->Signature = 0;
        }
        MyFree(Context);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }
}


#ifdef UNICODE
//
// ANSI version
//
UINT
SetupDefaultQueueCallbackA(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    UINT u;

    u = pSetupCallDefaultMsgHandler(
            Context,
            Notification,
            Param1,
            Param2
            );

    return(u);
}
#else
//
// Unicode stub
//
UINT
SetupDefaultQueueCallbackW(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(Notification);
    UNREFERENCED_PARAMETER(Param1);
    UNREFERENCED_PARAMETER(Param2);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(0);
}
#endif

UINT
SetupDefaultQueueCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    UINT rc;
    DWORD err;
    PQUEUECONTEXT context = Context;
    MSG msg;
    VERDLGCONTEXT dialogContext;
    DWORD waitResult;

    //
    // a little sanity check on context
    //
    err = NO_ERROR;
    try {
        if (context == NULL || context->Signature != QUEUECONTEXT_SIGNATURE) {
            err = ERROR_INVALID_PARAMETER;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        err = ERROR_INVALID_PARAMETER;
    }
    if (err != NO_ERROR) {
        return pGetCallbackErrorReturn(Notification,err);
    }

    switch(Notification) {

    case SPFILENOTIFY_STARTQUEUE:
        rc = pNotificationStartQueue(context);
        break;

    case SPFILENOTIFY_ENDQUEUE:
        //
        // Make sure the progress dialog is dead.
        //
        if(context->AlternateProgressWindow) {
            //
            // If we have an alternate progress window, then we'd better not
            // have our own progress dialog, nor should we have a UI thread
            // handle.
            //
            MYASSERT(!context->ProgressDialog);
            MYASSERT(!context->UiThreadHandle);

        } else {

            if(IsWindow(context->ProgressDialog)) {
                //
                // Post a message to the dialog, instructing it to terminate,
                // then wait for it to confirm.
                //
                PostMessage(context->ProgressDialog, WMX_KILLDIALOG, 0, 0);
            }
            //
            // The dialog may have been marked for delete (thus IsWindow() fails),
            // and yet the dialog has not yet been destroyed.  Therefore, we always
            // want to wait for the thread message that assures us that everything
            // has been cleaned up in the other thread.
            //
            // Also, before returning we need to make sure that the UI thread is
            // really gone, or else there's a hole where our caller could unload
            // the library and then the UI thread would fault.
            // We have seen this happen in stress.
            //
            while (pWaitForUiResponse(context)) /* nothing */;
            if(context->UiThreadHandle) {
                waitResult = WaitForSingleObject(context->UiThreadHandle,INFINITE);
                MYASSERT(waitResult != WAIT_FAILED);
                CloseHandle(context->UiThreadHandle);
            }
        }
        rc = TRUE;  // return value for this notification is actually ignored.
        break;

    case SPFILENOTIFY_STARTSUBQUEUE:
        rc = pNotificationStartEndSubqueue(context,TRUE,Param1,Param2);
        break;

    case SPFILENOTIFY_ENDSUBQUEUE:
        rc = pNotificationStartEndSubqueue(context,FALSE,Param1,0);
        break;

    case SPFILENOTIFY_STARTDELETE:
    case SPFILENOTIFY_STARTRENAME:
    case SPFILENOTIFY_STARTCOPY:
    case SPFILENOTIFY_STARTBACKUP:
        //
        // Update display to indicate the files involved
        // in the operation, unless a screen reader is active.
        //
        if(context->ScreenReader) {
            rc = FILEOP_DOIT;
        } else {
            rc = pNotificationStartOperation(context,(PFILEPATHS)Param1,Param2);
        }
        break;

    case SPFILENOTIFY_ENDDELETE:
    case SPFILENOTIFY_ENDRENAME:
    case SPFILENOTIFY_ENDCOPY:
    case SPFILENOTIFY_ENDBACKUP:
    case SPFILENOTIFY_ENDREGISTRATION:

        if(context->AlternateProgressWindow) {
            //
            // If this is really is an alternate progress window, then 'tick' it.
            // Copy only.
            //
            if((Notification == SPFILENOTIFY_ENDCOPY) &&
               (context->AlternateProgressWindow != INVALID_HANDLE_VALUE)) {

                SendMessage(context->AlternateProgressWindow, context->ProgressMsg, 1, 0);
            }
        } else {
            if(IsWindow(context->ProgressBar)) {
                //
                // Update gas gauge.
                //
                SendMessage(context->ProgressBar,PBM_STEPIT,0,0);
            }
        }
        rc = TRUE;  // return value for these notifications is actually ignored.
        break;

    case SPFILENOTIFY_DELETEERROR:
        rc = pNotificationErrorDelete(context,(PFILEPATHS)Param1);
        break;

    case SPFILENOTIFY_RENAMEERROR:
        rc = pNotificationErrorRename(context,(PFILEPATHS)Param1);
        break;

    case SPFILENOTIFY_BACKUPERROR:
        rc = pNotificationErrorBackup(context,(PFILEPATHS)Param1);
        break;

    case SPFILENOTIFY_COPYERROR:
        rc = pNotificationErrorCopy(context,(PFILEPATHS)Param1,(PTSTR)Param2);
        break;

    case SPFILENOTIFY_NEEDMEDIA:
        //
        // Perform prompt.
        //
        rc = pNotificationNeedMedia(context,(PSOURCE_MEDIA)Param1,(PTSTR)Param2);
        break;

    case SPFILENOTIFY_STARTREGISTRATION:
        rc = pNotificationStartRegistration(context,(PSP_REGISTER_CONTROL_STATUS)Param1,(BOOL)Param2);
        break;

    default:
        //
        // The notification is either an unknown ordinal or a version mismatch.
        //
        if(Notification & (SPFILENOTIFY_LANGMISMATCH | SPFILENOTIFY_TARGETNEWER | SPFILENOTIFY_TARGETEXISTS)) {
            //
            // It's one or more of our known version mismatches.  First
            // check to see whether No to All has already been specified
            // for the mismatch(es).  Turn off the bits in the notification
            // that are set in NoToAllMask; if there are still bits set,
            // we need to notify about this mismatch.  If there are no
            // longer any bits set, then don't copy this file.
            //
            Notification &= ~context->NoToAllMask;
            if (Notification != 0) {
                //
                // Notify about this mismatch.
                //
                dialogContext.QueueContext = context;
                dialogContext.Notification = Notification;
                dialogContext.Param1 = Param1;
                dialogContext.Param2 = Param2;
                rc = PostUiMessage (
                    context, UI_MISMATCHERROR, DPROMPT_CANCEL, &dialogContext);
                rc = (rc == IDYES);
            } else {
                //
                // No To All has already been specified for this notification type.
                // Skip the file.
                //
                rc = 0;
            }

        } else {
            //
            // Unknown notification. Skip the file.
            //
            rc = 0;
        }
        break;
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\fileq4.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    fileq4.c

Abstract:

    Setup file queue routines for commit (ie, performing enqueued actions).

Author:

    Ted Miller (tedm) 15-Feb-1995

Revision History:

    Jamie Hunter (jamiehun) 28-Jan-1997

    Added backup queue capabilities
    backup on demand capabilities
    and unwind capabilities

--*/

#include "precomp.h"
#pragma hdrstop


typedef struct _Q_CAB_CB_DATA {

    PSP_FILE_QUEUE     Queue;
    PSOURCE_MEDIA_INFO SourceMedia;

    PSP_FILE_QUEUE_NODE CurrentFirstNode;

    PVOID              MsgHandler;
    PVOID              Context;
    BOOL               IsMsgHandlerNativeCharWidth;
    PSETUP_LOG_CONTEXT LogContext;

} Q_CAB_CB_DATA, *PQ_CAB_CB_DATA;

typedef struct _CERT_PROMPT {
    LPCTSTR lpszDescription;
    LPCTSTR lpszFile;
    SetupapiVerifyProblem ProblemType;
    ULONG DriverSigningPolicy;
} CERT_PROMPT, *PCERT_PROMPT;

typedef struct _DRIVERBLOCK_PROMPT {
    LPCTSTR lpszFile;
    SDBENTRYINFO entryinfo;
} DRIVERBLOCK_PROMPT, *PDRIVERBLOCK_PROMPT;


DWORD
pSetupCommitSingleBackup(
    IN PSP_FILE_QUEUE    Queue,
    IN PCTSTR            FullTargetPath,
    IN LONG              TargetRootPath,
    IN LONG              TargetSubDir,
    IN LONG              TargetFilename,
    IN PVOID             MsgHandler,
    IN PVOID             Context,
    IN BOOL              IsMsgHandlerNativeCharWidth,
    IN BOOL              RenameExisting,
    OUT PBOOL            InUse
    );

DWORD
pCommitCopyQueue(
    IN PSP_FILE_QUEUE Queue,
    IN PVOID          MsgHandler,
    IN PVOID          Context,
    IN BOOL           IsMsgHandlerNativeCharWidth
    );

DWORD
pCommitBackupQueue(
    IN PSP_FILE_QUEUE Queue,
    IN PVOID          MsgHandler,
    IN PVOID          Context,
    IN BOOL           IsMsgHandlerNativeCharWidth
    );

DWORD
pCommitDeleteQueue(
    IN PSP_FILE_QUEUE Queue,
    IN PVOID          MsgHandler,
    IN PVOID          Context,
    IN BOOL           IsMsgHandlerNativeCharWidth
    );

DWORD
pCommitRenameQueue(
    IN PSP_FILE_QUEUE Queue,
    IN PVOID          MsgHandler,
    IN PVOID          Context,
    IN BOOL           IsMsgHandlerNativeCharWidth
    );

UINT
pSetupCabinetQueueCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR  Param1,
    IN UINT_PTR  Param2
    );


DWORD
pSetupCopySingleQueuedFile(
    IN  PSP_FILE_QUEUE      Queue,
    IN  PSP_FILE_QUEUE_NODE QueueNode,
    IN  PCTSTR              FullSourceName,
    IN  PVOID               MsgHandler,
    IN  PVOID               Context,
    OUT PTSTR               NewSourcePath,
    IN  BOOL                IsMsgHandlerNativeCharWidth,
    IN  DWORD               CopyStyleFlags
    );

DWORD
pSetupCopySingleQueuedFileCabCase(
    IN  PSP_FILE_QUEUE      Queue,
    IN  PSP_FILE_QUEUE_NODE QueueNode,
    IN  PCTSTR              CabinetName,
    IN  PCTSTR              FullSourceName,
    IN  PVOID               MsgHandler,
    IN  PVOID               Context,
    IN  BOOL                IsMsgHandlerNativeCharWidth
    );

VOID
pSetupSetPathOverrides(
    IN     PVOID StringTable,
    IN OUT PTSTR RootPath,
    IN OUT PTSTR SubPath,
    IN     LONG  RootPathId,
    IN     LONG  SubPathId,
    IN     PTSTR NewPath
    );

VOID
pSetupBuildSourceForCopy(
    IN  PCTSTR              UserRoot,
    IN  PCTSTR              UserPath,
    IN  LONG                MediaRoot,
    IN  PSP_FILE_QUEUE      Queue,
    IN  PSP_FILE_QUEUE_NODE QueueNode,
    OUT PTSTR               FullPath
    );

INT_PTR
CALLBACK
CertifyDlgProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
DriverBlockDlgProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

VOID
RestoreBootReplacedFile(
    IN PSP_FILE_QUEUE      Queue,
    IN PSP_FILE_QUEUE_NODE QueueNode
    );

VOID
pSetupExemptFileFromProtection(
    IN  PCTSTR             FileName,
    IN  DWORD              FileChangeFlags,
    IN  PSETUP_LOG_CONTEXT LogContext,      OPTIONAL
    OUT PDWORD             QueueNodeFlags   OPTIONAL
    );

VOID
pSetupUninstallNewCatalogNodes(
    IN PSP_FILE_QUEUE     Queue,
    IN PSETUP_LOG_CONTEXT LogContext OPTIONAL
    );


BOOL
_SetupCommitFileQueue(
    IN HWND     Owner,         OPTIONAL
    IN HSPFILEQ QueueHandle,
    IN PVOID    MsgHandler,
    IN PVOID    Context,
    IN BOOL     IsMsgHandlerNativeCharWidth
    )

/*++

Routine Description:

    Implementation for SetupCommitFileQueue; handles ANSI and Unicode
    callback routines.

Arguments:

    Same as for SetupCommitFileQueue().

    IsMsgHandlerNativeCharWidth - indicates whether the MsgHandler callback
        expects native char width args (or ansi ones, in the unicode build
        of this dll).

Return Value:

    Boolean value indicating outcome.  If FALSE, the GetLastError() indicates
    cause of failure.

--*/

{
    PSP_FILE_QUEUE Queue;
    DWORD rc;
    BOOL Success = TRUE;
    BOOL ChangedThreadLogContext = FALSE;
    PSETUP_LOG_CONTEXT SavedLogContext = NULL;
    PSETUP_LOG_CONTEXT LogContext = NULL;

    //
    // Queue handle is actually a pointer to the queue structure.
    //
    Queue = (PSP_FILE_QUEUE)QueueHandle;

    //
    // do a quick handle validation before anything else
    //
    try {
        Success = ((Queue != NULL) && (Queue != INVALID_HANDLE_VALUE) && (Queue->Signature == SP_FILE_QUEUE_SIG));
        if (Success) {
            LogContext = Queue->LogContext;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Success = FALSE;
    }
    if (!Success) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }
    //
    // If there's nothing to do, bail now. This prevents an empty
    // progress dialog from flashing on the screen. Don't return out
    // of the body of the try -- that is bad news performance-wise.
    //
    try {
        Success = (!Queue->DeleteNodeCount && !Queue->RenameNodeCount && !Queue->CopyNodeCount && !Queue->BackupNodeCount);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_HANDLE);
        return(FALSE);
    }
    if(Success) {

        //
        // We are successful in that we had no file operations to do.  However,
        // we still need to validate the queued catalogs at this time, because
        // we always do validation in the context of file copying.  If we don't
        // do this, we have a hole where a device INF that doesn't copy files
        // (e.g., a modem INF) can circumvent driver signing checking.
        //
        WriteLogEntry(
            LogContext,
            SETUP_LOG_TIME,
            MSG_LOG_BEGIN_VERIFY3_CAT_TIME,
            NULL);       // text message

        rc = _SetupVerifyQueuedCatalogs(Owner,
                                        Queue,
                                        VERCAT_INSTALL_INF_AND_CAT,
                                        NULL,
                                        NULL
                                       );
        WriteLogEntry(
            LogContext,
            SETUP_LOG_TIME,
            MSG_LOG_END_VERIFY3_CAT_TIME,
            NULL);       // text message

        if (rc == NO_ERROR) {

            //
            // If we performed a backup and this is a device install then call
            // the pSetupCompleteBackup API to create the Reinstall instance
            // subkey and do other device rollback cleanup.
            //
            if (Queue->Flags & FQF_DEVICE_BACKUP) {

                pSetupCompleteBackup(Queue);
            }

            Queue->Flags |= FQF_QUEUE_ALREADY_COMMITTED;

        } else {
            //
            // Go uninstall any newly-copied INFs/PNFs/CATs.
            //
            pSetupUninstallNewCatalogNodes(Queue, LogContext);
        }

        SetLastError(rc);
        return(rc == NO_ERROR);
    }

    ASSERT_HEAP_IS_VALID();

    //
    // make a note of default logging context for duration of queue processing
    // this will catch, eg, INF being opened as part of a callback
    //
    MYASSERT(!ChangedThreadLogContext);
    ChangedThreadLogContext = SetThreadLogContext(LogContext,&SavedLogContext);
    if (ChangedThreadLogContext) {
        //
        // add one more ref to protext log context
        //
        RefLogContext(LogContext);
    }

    Success = pSetupCallMsgHandler(
            LogContext,
            MsgHandler,
            IsMsgHandlerNativeCharWidth,
            Context,
            SPFILENOTIFY_STARTQUEUE,
            (UINT_PTR)Owner,
            0
            );
    if(!Success) {
        rc = GetLastError();
        if(!rc) {
            rc = ERROR_OPERATION_ABORTED;
        }
        goto final;
    }

    try {
        //
        // Verify catalogs/infs.
        //
        WriteLogEntry(
            LogContext,
            SETUP_LOG_TIME,
            MSG_LOG_BEGIN_VERIFY2_CAT_TIME,
            NULL);       // text message

        rc = _SetupVerifyQueuedCatalogs(Owner,
                                        Queue,
                                        VERCAT_INSTALL_INF_AND_CAT,
                                        NULL,
                                        NULL
                                       );
        WriteLogEntry(
            LogContext,
            SETUP_LOG_TIME,
            MSG_LOG_END_VERIFY2_CAT_TIME,
            NULL);       // text message

        Success = (rc == NO_ERROR);

        if(rc != NO_ERROR) {
            goto Bail;
        }

        ASSERT_HEAP_IS_VALID();

        //
        // Handle backup first
        // don't commit if there's nothing to do
        //

        rc = Queue->BackupNodeCount
           ? pCommitBackupQueue(Queue,MsgHandler,Context,IsMsgHandlerNativeCharWidth)
           : NO_ERROR;

        Success = (rc == NO_ERROR);

        ASSERT_HEAP_IS_VALID();

        if (!Success) {
            goto Bail;
        }

        //
        // Handle deletes
        // now done after backups, but may incorporate a per-delete backup
        // don't commit if there's nothing to do
        //

        rc = Queue->DeleteNodeCount
           ? pCommitDeleteQueue(Queue,MsgHandler,Context,IsMsgHandlerNativeCharWidth)
           : NO_ERROR;

        Success = (rc == NO_ERROR);

        ASSERT_HEAP_IS_VALID();

        if (!Success) {
            goto Bail;
        }

        //
        // Handle renames next.
        // don't commit if there's nothing to do
        //

        rc = Queue->RenameNodeCount
           ? pCommitRenameQueue(Queue,MsgHandler,Context,IsMsgHandlerNativeCharWidth)
           : NO_ERROR;

        Success = (rc == NO_ERROR);

        ASSERT_HEAP_IS_VALID();

        if (!Success) {
            goto Bail;
        }

        //
        // Handle copies last. Don't bother calling the copy commit routine
        // if there are no files to copy.
        //
        rc = Queue->CopyNodeCount
           ? pCommitCopyQueue(Queue,MsgHandler,Context,IsMsgHandlerNativeCharWidth)
           : NO_ERROR;

        Success = (rc == NO_ERROR);

        ASSERT_HEAP_IS_VALID();

        if (!Success) {
            goto Bail;
        }

        rc = DoAllDelayedMoves(Queue);

        Success = (rc == NO_ERROR);

        if(Success) {
            //
            // Set a flag indicating we've committed the file queue (used to keep
            // us from attempting to prune the queue after having committed it).
            //
            Queue->Flags |= FQF_QUEUE_ALREADY_COMMITTED;
        }

        //
        // If we performed a backup and this is a device install then call
        // the pSetupCompleteBackup API to create the Reinstall instance
        // subkey and do other device rollback cleanup.
        //
        if (Queue->Flags & FQF_DEVICE_BACKUP) {

            pSetupCompleteBackup(Queue);
        }

    Bail:
        ;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Success = FALSE;
        rc = ERROR_INVALID_DATA;
    }

    pSetupCallMsgHandler(
        LogContext,
        MsgHandler,
        IsMsgHandlerNativeCharWidth,
        Context,
        SPFILENOTIFY_ENDQUEUE,
        Success,
        0
        );

    pSetupUnwindAll(Queue, Success);

final:

    //
    // If we didn't succeed, then uninstall any new INFs/PNFs/CATs we may have
    // installed.
    //
    if(!Success) {
        pSetupUninstallNewCatalogNodes(Queue, LogContext);
    }

    if (ChangedThreadLogContext) {
        //
        // restore thread log context
        //
        SetThreadLogContext(SavedLogContext,NULL);
        DeleteLogContext(LogContext); // counter RefLogContext
    }

    SetLastError(rc);

    return(Success);
}

#ifdef UNICODE
//
// ANSI version. Also need undecorated (Unicode) version for compatibility
// with apps that were linked before we had A and W versions.
//
BOOL
SetupCommitFileQueueA(
    IN HWND                Owner,         OPTIONAL
    IN HSPFILEQ            QueueHandle,
    IN PSP_FILE_CALLBACK_A MsgHandler,
    IN PVOID               Context
    )
{
    return(_SetupCommitFileQueue(Owner,QueueHandle,MsgHandler,Context,FALSE));
}

#undef SetupCommitFileQueue
SetupCommitFileQueue(
    IN HWND                Owner,         OPTIONAL
    IN HSPFILEQ            QueueHandle,
    IN PSP_FILE_CALLBACK_W MsgHandler,
    IN PVOID               Context
    )
{
    return(_SetupCommitFileQueue(Owner,QueueHandle,MsgHandler,Context,TRUE));
}
#else
//
// Unicode stub. Also need undecorated (ANSI) version for compatibility
// with apps that were linked before we had A and W versions.
//
BOOL
SetupCommitFileQueueW(
    IN HWND                Owner,         OPTIONAL
    IN HSPFILEQ            QueueHandle,
    IN PSP_FILE_CALLBACK_W MsgHandler,
    IN PVOID               Context
    )
{
    UNREFERENCED_PARAMETER(Owner);
    UNREFERENCED_PARAMETER(QueueHandle);
    UNREFERENCED_PARAMETER(MsgHandler);
    UNREFERENCED_PARAMETER(Context);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}

#undef SetupCommitFileQueue
SetupCommitFileQueue(
    IN HWND                Owner,         OPTIONAL
    IN HSPFILEQ            QueueHandle,
    IN PSP_FILE_CALLBACK_A MsgHandler,
    IN PVOID               Context
    )
{
    return(_SetupCommitFileQueue(Owner,QueueHandle,MsgHandler,Context,TRUE));
}
#endif

BOOL
#ifdef UNICODE
SetupCommitFileQueueW(
#else
SetupCommitFileQueueA(
#endif
    IN HWND              Owner,         OPTIONAL
    IN HSPFILEQ          QueueHandle,
    IN PSP_FILE_CALLBACK MsgHandler,
    IN PVOID             Context
    )

/*++

Routine Description:

    Perform file operations enqueued on a setup file queue.

Arguments:

    OwnerWindow - if specified, supplies the window handle of a window
        that is to be used as the parent of any progress dialogs.

    QueueHandle - supplies a handle to a setup file queue, as returned
        by SetupOpenFileQueue.

    MsgHandler - Supplies a callback routine to be notified
        of various significant events in the queue processing.

    Context - Supplies a value that is passed to the MsgHandler
        callback function.

Return Value:

    Boolean value indicating outcome.

--*/

{
    return(_SetupCommitFileQueue(Owner,QueueHandle,MsgHandler,Context,TRUE));
}


DWORD
pCommitBackupQueue(
    IN PSP_FILE_QUEUE    Queue,
    IN PVOID             MsgHandler,
    IN PVOID             Context,
    IN BOOL              IsMsgHandlerNativeCharWidth
    )
/*++

Routine Description:

    Process the backup Queue
    Backup each file specified in the queue if it exists
    File is marked as backup
    Location of backup is recorded
    Files are not added to unwind queue here
    They get added to unwind queue the first time they are potentially modified

    See also pCommitDeleteQueue, pCommitRenameQueue and pCommitCopyQueue

Arguments:

    Queue - queue that contains the backup sub-queue

    MsgHandler - Supplies a callback routine to be notified
        of various significant events in the queue processing.

    Context - Supplies a value that is passed to the MsgHandler
        callback function.

    IsMsgHandlerNativeCharWidth - For Unicode/Ansi support

Return Value:

    DWORD indicating status or success

--*/
{
    PSP_FILE_QUEUE_NODE QueueNode,queueNode;
    UINT u;
    BOOL b;
    DWORD rc;
    PCTSTR FullTargetPath,FullBackupPath;
    FILEPATHS FilePaths;
    BOOL Skipped = FALSE;
    DWORD BackupFlags = SP_BACKUP_BACKUPPASS;

    MYASSERT(Queue->BackupNodeCount);

    b = pSetupCallMsgHandler(
            Queue->LogContext,
            MsgHandler,
            IsMsgHandlerNativeCharWidth,
            Context,
            SPFILENOTIFY_STARTSUBQUEUE,
            FILEOP_BACKUP,
            Queue->BackupNodeCount
            );

    if(!b) {
        rc = GetLastError();
        if(!rc) {
            rc = ERROR_OPERATION_ABORTED;
        }
        goto clean0;
    }
    for(QueueNode=Queue->BackupQueue; QueueNode; QueueNode=QueueNode->Next) {

        //
        // Form the full path of the file to be backed up
        //
        FullBackupPath = pSetupFormFullPath(
                            Queue->StringTable,
                            QueueNode->SourceRootPath,
                            QueueNode->SourcePath,
                            QueueNode->SourceFilename
                            );

        if(!FullBackupPath) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        FullTargetPath = pSetupFormFullPath(
                            Queue->StringTable,
                            QueueNode->TargetDirectory,
                            QueueNode->TargetFilename,
                            -1
                            );

        if(!FullTargetPath) {
            MyFree(FullBackupPath);
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        FilePaths.Source = FullTargetPath; // copying from
        FilePaths.Target = FullBackupPath; // copying to (backup)
        FilePaths.Win32Error = NO_ERROR;
        FilePaths.Flags = BackupFlags;

        Skipped = FALSE;

        //
        // Inform the callback that we are about to start a backup operation.
        //
        u = pSetupCallMsgHandler(
                Queue->LogContext,
                MsgHandler,
                IsMsgHandlerNativeCharWidth,
                Context,
                SPFILENOTIFY_STARTBACKUP,
                (UINT_PTR)&FilePaths,
                FILEOP_BACKUP
                );

        if(u == FILEOP_ABORT) {
            rc = GetLastError();
            if(!rc) {
                rc = ERROR_OPERATION_ABORTED;
            }
            MyFree(FullTargetPath);
            MyFree(FullBackupPath);
            goto clean0;
        }
        if(u == FILEOP_DOIT) {
            //
            // Attempt the backup. If it fails inform the callback,
            // which may decide to abort, retry. or skip the file.
            //
            //SetFileAttributes(FullTargetPath,FILE_ATTRIBUTE_NORMAL);

            do {
                rc = pSetupBackupFile((HSPFILEQ)Queue,
                    FullTargetPath,
                    FullBackupPath,
                    -1, // TargetID not known
                    QueueNode->TargetDirectory, // what to backup
                    -1, // Queue Node's don't maintain this intermediate path
                    QueueNode->TargetFilename,
                    QueueNode->SourceRootPath, // backup as...
                    QueueNode->SourcePath,
                    QueueNode->SourceFilename,
                    &b
                    );
                if (rc == NO_ERROR) {
                    if (b) {
                        // delayed (in use)

                        QueueNode->InternalFlags |= INUSE_IN_USE;
                        //
                        // Tell the callback.
                        //
                        FilePaths.Win32Error = NO_ERROR;
                        FilePaths.Flags = FILEOP_BACKUP;

                        pSetupCallMsgHandler(
                            Queue->LogContext,
                            MsgHandler,
                            IsMsgHandlerNativeCharWidth,
                            Context,
                            SPFILENOTIFY_FILEOPDELAYED,
                            (UINT_PTR)&FilePaths,
                            0
                            );
                    }
                } else {
                    FilePaths.Win32Error = rc;
                    FilePaths.Flags = BackupFlags;

                    u = pSetupCallMsgHandler(
                            Queue->LogContext,
                            MsgHandler,
                            IsMsgHandlerNativeCharWidth,
                            Context,
                            SPFILENOTIFY_BACKUPERROR,
                            (UINT_PTR)&FilePaths,
                            0
                            );

                    if(u == FILEOP_ABORT) {
                        rc = GetLastError();
                        if(!rc) {
                            rc = ERROR_OPERATION_ABORTED;
                        }
                        MyFree(FullTargetPath);
                        MyFree(FullBackupPath);
                        goto clean0;
                    }
                    if(u == FILEOP_SKIP) {
                        // we skipped the backup
                        Skipped = TRUE;
                        break;
                    }
                }
            } while(rc != NO_ERROR);
        } else {
            // we skipped the backup
            Skipped = TRUE;
            rc = NO_ERROR;
        }

        FilePaths.Win32Error = rc;
        FilePaths.Flags = BackupFlags;

        pSetupCallMsgHandler(
            Queue->LogContext,
            MsgHandler,
            IsMsgHandlerNativeCharWidth,
            Context,
            SPFILENOTIFY_ENDBACKUP,
            (UINT_PTR)&FilePaths,
            0
            );

        MyFree(FullTargetPath);
        MyFree(FullBackupPath);
    }

    pSetupCallMsgHandler(
        Queue->LogContext,
        MsgHandler,
        IsMsgHandlerNativeCharWidth,
        Context,
        SPFILENOTIFY_ENDSUBQUEUE,
        FILEOP_BACKUP,
        0
        );

    rc = NO_ERROR;

clean0:

    SetLastError(rc);

    return rc;
}

DWORD
pSetupCommitSingleBackup(
    IN PSP_FILE_QUEUE    Queue,
    IN PCTSTR            FullTargetPath,
    IN LONG              TargetRootPath,
    IN LONG              TargetSubDir,
    IN LONG              TargetFilename,
    IN PVOID             MsgHandler,
    IN PVOID             Context,
    IN BOOL              IsMsgHandlerNativeCharWidth,
    IN BOOL              RenameExisting,
    OUT PBOOL            InUse
    )
/*++

Routine Description:

    Check a single file that is potentially about to be modified

    If the target file doesn't exist, then this routine does nothing
    If the target file hasn't been backed up, back it up
    If the target file has been backed up, but is not on unwind queue,
        add to unwind queue

    The default target location of the backup is used, which is either
    into a backup directory tree, or a temporary backup location
    Location of backup is recorded

Arguments:

    Queue - queue that contains the backup sub-queue
    FullTargetPath - String giving target path, or NULL if not formed
    TargetRootPath - String ID giving RootPath, or -1 if not specified
    TargetSubDir   - String ID giving SubDir (relative to RootPath),
                     or -1 if not specified
    TargetFilename - String ID giving Filename, or -1 if not specified
    MsgHandler - Supplies a callback routine to be notified
        of various significant events in the queue processing.
    Context - Supplies a value that is passed to the MsgHandler
        callback function.
    IsMsgHandlerNativeCharWidth - For Unicode/Ansi support
    RenameExisting - Should existing file be renamed?
    InUse - if specified, set to indicate if file is in use or not
            This should never be the case

Return Value:

    DWORD indicating status or success

--*/
{
    UINT u;
    BOOL b;
    DWORD rc;
    DWORD rc2;
    FILEPATHS FilePaths;
    LONG TargetID;
    PTSTR TargetPathLocal = NULL;
    PSP_UNWIND_NODE UnwindNode = NULL;
    SP_TARGET_ENT TargetInfo;
    BOOL FileOfSameNameExists;
    BOOL DoBackup = TRUE;
    BOOL NeedUnwind = FALSE;
    BOOL Skipped = FALSE;
    WIN32_FILE_ATTRIBUTE_DATA FileAttribData;
    UINT OldMode;
    BOOL DoRename;
    DWORD BackupFlags = SP_BACKUP_DEMANDPASS;

    //
    // used in this function to init time field
    //
    static const FILETIME zeroTime = {
         0,0
    };

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS); // inhibit unexpected dialog boxes

    MYASSERT(Queue);

    if (FullTargetPath == NULL) {
        TargetPathLocal = pSetupFormFullPath(
                            Queue->StringTable,
                            TargetRootPath,
                            TargetSubDir,
                            TargetFilename);

        if(!TargetPathLocal) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        FullTargetPath = TargetPathLocal;
    }

    FileOfSameNameExists = GetFileAttributesEx(FullTargetPath, GetFileExInfoStandard, &FileAttribData);

    if (!FileOfSameNameExists) {
        // file doesn't exist, so no need to backup
        rc = NO_ERROR;
        goto clean0;
    }

    rc = pSetupBackupGetTargetByPath((HSPFILEQ)Queue,
                                     NULL, // use Queue's string table
                                     FullTargetPath,
                                     TargetRootPath,
                                     TargetSubDir,
                                     TargetFilename,
                                     &TargetID,
                                     &TargetInfo
                                    );

    if (rc != NO_ERROR) {
        // failed for some strange reason
        goto clean0;

    }

    if (TargetInfo.InternalFlags & SP_TEFLG_INUSE) {
        //
        // was "inuse'd" before
        // we mark as still INUSE
        if (InUse != NULL) {
            *InUse = TRUE;
        }
        //
        // Don't consider this an error, unless we were supposed to rename the
        // existing file.
        //
        rc = RenameExisting ? ERROR_SHARING_VIOLATION : NO_ERROR;
        goto clean0;
    }

    if (TargetInfo.InternalFlags & SP_TEFLG_SKIPPED) {
        //
        // was skipped before
        // we can't rely on it now
        //
        rc = NO_ERROR;
        goto clean0;
    }

    //
    // If we've been asked to backup the existing file, then make sure the
    // SP_TEFLG_RENAMEEXISTING flag is set in the TargetInfo.  Also, figure out
    // if we've already done the rename.
    //
    if(RenameExisting &&
       !(TargetInfo.InternalFlags & SP_TEFLG_RENAMEEXISTING)) {
        //
        // We'd better not think we already renamed this file!
        //
        MYASSERT(!(TargetInfo.InternalFlags & SP_TEFLG_MOVED));

        TargetInfo.InternalFlags |= SP_TEFLG_RENAMEEXISTING;

        //
        // update internal info (this call should never fail)
        //
        pSetupBackupSetTargetByID((HSPFILEQ)Queue,
                                  TargetID,
                                  &TargetInfo
                                 );
    }

    //
    // Figure out whether we've been asked to rename the existing file to a
    // temp name in the same directory, but haven't yet done so.
    //
    DoRename = ((TargetInfo.InternalFlags & (SP_TEFLG_RENAMEEXISTING | SP_TEFLG_MOVED)) == SP_TEFLG_RENAMEEXISTING);

    if(TargetInfo.InternalFlags & SP_TEFLG_SAVED) {
        //
        // already backed up
        //
        DoBackup = FALSE;

        if((TargetInfo.InternalFlags & SP_TEFLG_UNWIND) && !DoRename) {
            //
            // already added to unwind queue, and we don't need to do a rename--
            // don't need to do anything at all
            //
            rc = NO_ERROR;
            goto clean0;
        }
        //
        // we don't need to backup
        // but we still need to add to unwind queue, rename the existing file,
        // or both.
        //
    }

    if(DoBackup) {
        BackupFlags |= SP_BACKUP_DEMANDPASS;
    }
    if(DoRename) {
        BackupFlags |= SP_BACKUP_BOOTFILE | SP_BACKUP_SPECIAL;
    }

    FilePaths.Source = FullTargetPath;  // what we are backing up
    FilePaths.Target = NULL;            // indicates an automatic backup
    FilePaths.Win32Error = NO_ERROR;
    FilePaths.Flags = BackupFlags;

    if (DoRename) {
        pSetupExemptFileFromProtection(
                    FullTargetPath,
                    SFC_ACTION_ADDED | SFC_ACTION_REMOVED | SFC_ACTION_MODIFIED
                    | SFC_ACTION_RENAMED_OLD_NAME |SFC_ACTION_RENAMED_NEW_NAME,
                    Queue->LogContext,
                    NULL
                    );
    }

    if (DoBackup && (Queue->Flags & FQF_BACKUP_AWARE)) {
        //
        // Inform the callback that we are about to start a backup operation.
        //
        u = pSetupCallMsgHandler(
                Queue->LogContext,
                MsgHandler,
                IsMsgHandlerNativeCharWidth,
                Context,
                SPFILENOTIFY_STARTBACKUP,
                (UINT_PTR)&FilePaths,
                FILEOP_BACKUP
                );
    } else {
        //
        // no backup, or not backup aware, assume a default
        //
        u = FILEOP_DOIT;
    }

    if(u == FILEOP_ABORT) {
        rc = GetLastError();
        if(!rc) {
            rc = ERROR_OPERATION_ABORTED;
        }
        goto clean0;
    }
    if((u == FILEOP_DOIT) || (BackupFlags & SP_BACKUP_SPECIAL)) {
        //
        // Attempt the backup. If it fails inform the callback,
        // which may decide to abort, retry. or skip the file.
        //
        //SetFileAttributes(FullTargetPath,FILE_ATTRIBUTE_NORMAL);

        //
        // Setup an unwind node, unless we already have one.
        //
        if(!(TargetInfo.InternalFlags & SP_TEFLG_UNWIND)) {

            UnwindNode = MyMalloc(sizeof(SP_UNWIND_NODE));
            if (UnwindNode == NULL) {
                rc = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }
            UnwindNode->NextNode = Queue->UnwindQueue;
            UnwindNode->TargetID = TargetID;
            if (RetreiveFileSecurity( FullTargetPath, &(UnwindNode->SecurityDesc)) != NO_ERROR) {
                // failed, but not fatal
                UnwindNode->SecurityDesc = NULL;
            }
            if (GetSetFileTimestamp( FullTargetPath, &(UnwindNode->CreateTime),
                                                    &(UnwindNode->AccessTime),
                                                    &(UnwindNode->WriteTime),
                                                    FALSE) != NO_ERROR) {
                // failed, but not fatal
                UnwindNode->CreateTime = zeroTime;
                UnwindNode->AccessTime = zeroTime;
                UnwindNode->WriteTime = zeroTime;
            }
        }

        if (DoBackup || DoRename) {
            do {
                rc = pSetupBackupFile((HSPFILEQ)Queue,
                    FullTargetPath,     // since we know this, pass it
                    NULL,               // automatic destination
                    TargetID,           // we got this earlier
                    TargetRootPath,     // since we know this, pass it
                    TargetSubDir,
                    TargetFilename,
                    -1,                 // use the details from TargetID (or temp)
                    -1,
                    -1,
                    &b                  // in use (should always return FALSE)
                    );
                if (rc == NO_ERROR) {
                    if (InUse != NULL) {
                        *InUse = b;
                    }
                    if (b) {
                        //
                        // if file is in use, callback can decide what to do
                        //
                        if (Queue->Flags & FQF_BACKUP_AWARE) {
                            //
                            // Tell the callback.
                            //
                            FilePaths.Win32Error = ERROR_SHARING_VIOLATION;
                            FilePaths.Flags = BackupFlags;

                            if (Queue->Flags & FQF_BACKUP_AWARE) {
                                u = pSetupCallMsgHandler(
                                    Queue->LogContext,
                                    MsgHandler,
                                    IsMsgHandlerNativeCharWidth,
                                    Context,
                                    SPFILENOTIFY_BACKUPERROR,
                                    (UINT_PTR)&FilePaths,
                                    0
                                    );
                                if(u == FILEOP_ABORT) {
                                    rc = GetLastError();
                                    if(!rc) {
                                        rc = ERROR_OPERATION_ABORTED;
                                    }
                                    goto clean0;
                                }
                            } else {
                                rc = ERROR_OPERATION_ABORTED;
                                goto clean0;
                            }
                        }
                    } else {
                        //
                        // success!!!!!
                        // we would have to unwind this if setup fails
                        //
                        NeedUnwind = TRUE;
                    }
                } else {
                    FilePaths.Win32Error = rc;
                    FilePaths.Flags = BackupFlags;

                    if (Queue->Flags & FQF_BACKUP_AWARE) {
                        //
                        // inform about error
                        //
                        u = pSetupCallMsgHandler(
                                Queue->LogContext,
                                MsgHandler,
                                IsMsgHandlerNativeCharWidth,
                                Context,
                                SPFILENOTIFY_BACKUPERROR,
                                (UINT_PTR)&FilePaths,
                                0
                                );
                        if(u == FILEOP_ABORT) {
                            rc = GetLastError();
                            if(!rc) {
                                rc = ERROR_OPERATION_ABORTED;
                            }
                            goto clean0;
                        }
                    } else {
                        //
                        // if caller is not backup aware, abort
                        //
                        rc = ERROR_OPERATION_ABORTED;
                        goto clean0;
                    }

                    if(u == FILEOP_SKIP) {
                        //
                        // we skipped the backup
                        //
                        Skipped = TRUE;
                        break;
                    }
                }
            } while(rc != NO_ERROR);

        } else {
            //
            // didn't need to backup, only need to add to unwind queue
            //
            NeedUnwind = TRUE;
        }

    } else {
        //
        // we skipped the backup
        //
        Skipped = TRUE;
        rc = NO_ERROR;
    }

    if (DoBackup) {

        FilePaths.Win32Error = rc;

        if (Queue->Flags & FQF_BACKUP_AWARE) {
            //
            // report result only if backup aware
            //
            pSetupCallMsgHandler(
                Queue->LogContext,
                MsgHandler,
                IsMsgHandlerNativeCharWidth,
                Context,
                SPFILENOTIFY_ENDBACKUP,
                (UINT_PTR)&FilePaths,
                0
                );
        }
    }

    if (Skipped) {
        //
        // once we return, file may get overwritten or deleted
        // we have to save the fact it has been skipped once
        // so we always skip this file
        //
        if (pSetupBackupGetTargetByID((HSPFILEQ)Queue, TargetID, &TargetInfo) == NO_ERROR) {
            //
            // flag the file should always be skipped
            //
            TargetInfo.InternalFlags|=SP_TEFLG_SKIPPED;
            pSetupBackupSetTargetByID((HSPFILEQ)Queue, TargetID, &TargetInfo);
        }
    }
    else if (NeedUnwind) {
        //
        // We only want to add this to unwind queue
        //
        if (pSetupBackupGetTargetByID((HSPFILEQ)Queue, TargetID, &TargetInfo) == NO_ERROR) {
            if ((TargetInfo.InternalFlags&SP_TEFLG_UNWIND)==FALSE) {
                //
                // node needs to be added to unwind queue
                // we only ever do this once
                //
                Queue->UnwindQueue = UnwindNode;
                //
                // set to NULL so we don't clean it up later
                //
                UnwindNode = NULL;

                //
                // flag that we've added it to unwind queue
                // so we don't try and do it again later
                //
                TargetInfo.InternalFlags|=SP_TEFLG_UNWIND;

                pSetupBackupSetTargetByID((HSPFILEQ)Queue, TargetID, &TargetInfo);
            }

        }
    }


    rc = NO_ERROR;

clean0:

    if (UnwindNode != NULL) {
        //
        // we allocated, but didn't use this structure
        //
        if (UnwindNode->SecurityDesc != NULL) {
            MyFree(UnwindNode->SecurityDesc);
        }
        MyFree(UnwindNode);
    }
    if (TargetPathLocal != NULL) {
        MyFree(TargetPathLocal);
    }

    SetErrorMode(OldMode);

    SetLastError(rc);

    return rc;
}

DWORD
pCommitDeleteQueue(
    IN PSP_FILE_QUEUE    Queue,
    IN PVOID             MsgHandler,
    IN PVOID             Context,
    IN BOOL              IsMsgHandlerNativeCharWidth
    )
/*++

Routine Description:

    Process the delete Queue
    Delete each file specified in the queue
    Files are backed up before they are deleted (if not already backed up)

    See also pCommitBackupQueue, pCommitRenameQueue and pCommitCopyQueue

Arguments:

    Queue - queue that contains the delete sub-queue

    MsgHandler - Supplies a callback routine to be notified
        of various significant events in the queue processing.

    Context - Supplies a value that is passed to the MsgHandler
        callback function.

    IsMsgHandlerNativeCharWidth - For Unicode/Ansi support

Return Value:

    DWORD indicating status or success

--*/
{
    PSP_FILE_QUEUE_NODE QueueNode,queueNode;
    UINT u;
    BOOL b;
    DWORD rc;
    PCTSTR FullTargetPath;
    FILEPATHS FilePaths;
    BOOL BackupInUse = FALSE;
    BOOL TargetIsProtected;

    MYASSERT(Queue->DeleteNodeCount);

    b = pSetupCallMsgHandler(
            Queue->LogContext,
            MsgHandler,
            IsMsgHandlerNativeCharWidth,
            Context,
            SPFILENOTIFY_STARTSUBQUEUE,
            FILEOP_DELETE,
            Queue->DeleteNodeCount
            );

    if(!b) {
        rc = GetLastError();
        if(!rc) {
            rc = ERROR_OPERATION_ABORTED;
        }
        goto clean0;
    }

    for(QueueNode=Queue->DeleteQueue; QueueNode; QueueNode=QueueNode->Next) {

        //
        // Form the full path of the file to be deleted.
        //
        FullTargetPath = pSetupFormFullPath(
                            Queue->StringTable,
                            QueueNode->TargetDirectory,
                            QueueNode->TargetFilename,
                            -1
                            );

        if(!FullTargetPath) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        //
        // Backup the file we're about to delete
        //
        if((rc=pSetupDoLastKnownGoodBackup(Queue,
                                           FullTargetPath,
                                           LASTGOOD_OPERATION_DELETE,
                                           NULL)) != NO_ERROR) {
            MyFree(FullTargetPath);
            goto clean0;
        }
        rc = pSetupCommitSingleBackup(Queue,
                                      FullTargetPath,
                                      QueueNode->TargetDirectory,
                                      -1,
                                      QueueNode->TargetFilename,
                                      MsgHandler,
                                      Context,
                                      IsMsgHandlerNativeCharWidth,
                                      FALSE,
                                      &BackupInUse
                                     );
        if (rc != NO_ERROR) {
            MyFree(FullTargetPath);
            goto clean0;
        }

        FilePaths.Source = NULL;
        FilePaths.Target = FullTargetPath;
        FilePaths.Win32Error = NO_ERROR;
        FilePaths.Flags = 0;

        //
        // Inform the callback that we are about to start a delete operation.
        //
        u = pSetupCallMsgHandler(
                Queue->LogContext,
                MsgHandler,
                IsMsgHandlerNativeCharWidth,
                Context,
                SPFILENOTIFY_STARTDELETE,
                (UINT_PTR)&FilePaths,
                FILEOP_DELETE
                );

        if(u == FILEOP_ABORT) {
            rc = GetLastError();
            if(!rc) {
                rc = ERROR_OPERATION_ABORTED;
            }
            MyFree(FullTargetPath);
            goto clean0;
        }
        if(u == FILEOP_DOIT) {
            //
            // Attempt the delete. If it fails inform the callback,
            // which may decide to abort, retry. or skip the file.
            //
            SetFileAttributes(FullTargetPath,FILE_ATTRIBUTE_NORMAL);

            do {
                if (BackupInUse) {
                    rc = ERROR_SHARING_VIOLATION;
                } else {
                    rc = DeleteFile(FullTargetPath) ? NO_ERROR : GetLastError();
                }
                if((rc == ERROR_ACCESS_DENIED)
                || (rc == ERROR_SHARING_VIOLATION)
                || (rc == ERROR_USER_MAPPED_FILE)) {
                    //
                    // The file is probably in use.
                    //
                    if(QueueNode->InternalFlags & IQF_DELAYED_DELETE_OK) {
                        //
                        // Inf wanted delete on next reboot.  Check to see if
                        // we're being asked to delete a protected system file.
                        // If so (and all the catalog nodes associated with the
                        // queue were OK), then we'll allow this to happen.
                        // Otherwise, we'll silently skip the deletion (and log
                        // it).
                        //
                        MYASSERT((Queue->Flags & FQF_DID_CATALOGS_OK) ||
                                 (Queue->Flags & FQF_DID_CATALOGS_FAILED));

                        if(Queue->Flags & FQF_DID_CATALOGS_OK) {

                            QueueNode->InternalFlags |= INUSE_IN_USE;

                            TargetIsProtected = IsFileProtected(FullTargetPath,
                                                                Queue->LogContext,
                                                                NULL
                                                               );

                            if(b = PostDelayedMove(Queue,
                                                   FullTargetPath,
                                                   NULL,
                                                   -1,
                                                   TargetIsProtected)) {
                                //
                                // Tell the callback.
                                //
                                FilePaths.Source = NULL;
                                FilePaths.Target = FullTargetPath;
                                FilePaths.Win32Error = NO_ERROR;
                                FilePaths.Flags = FILEOP_DELETE;

                                pSetupCallMsgHandler(
                                    Queue->LogContext,
                                    MsgHandler,
                                    IsMsgHandlerNativeCharWidth,
                                    Context,
                                    SPFILENOTIFY_FILEOPDELAYED,
                                    (UINT_PTR)&FilePaths,
                                    0
                                    );
                            }
                        } else {
                            //
                            // We're installing an unsigned package.  Skip the
                            // delayed delete operation, and generate a log
                            // entry about this.
                            //
                            WriteLogEntry(Queue->LogContext,
                                          SETUP_LOG_ERROR,
                                          MSG_LOG_DELAYED_DELETE_SKIPPED_FOR_SFC,
                                          NULL,
                                          FullTargetPath
                                         );
                        }

                    } else {
                        //
                        // Just skip this file.
                        //
                        b = TRUE;
                    }

                    rc = b ? NO_ERROR : GetLastError();

                    if(rc) {
                        WriteLogEntry(
                            Queue->LogContext,
                            SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                            MSG_LOG_DELAYDELETE_FILE_ERROR,
                            NULL,
                            FullTargetPath);
                        WriteLogError(Queue->LogContext,SETUP_LOG_ERROR,rc);
                    } else {
                        WriteLogEntry(
                            Queue->LogContext,
                            SETUP_LOG_INFO,
                            MSG_LOG_DELAYDELETED_FILE,
                            NULL,
                            FullTargetPath);
                    }

                } else if(rc) {
                    WriteLogEntry(
                        Queue->LogContext,
                        DEL_ERR_LOG_LEVEL(rc) | SETUP_LOG_BUFFER,
                        MSG_LOG_DELETE_FILE_ERROR,
                        NULL,
                        FullTargetPath);
                    WriteLogError(Queue->LogContext,DEL_ERR_LOG_LEVEL(rc),rc);
                } else {
                    WriteLogEntry(
                        Queue->LogContext,
                        SETUP_LOG_INFO,
                        MSG_LOG_DELETED_FILE,
                        NULL,
                        FullTargetPath);
                }

#ifdef UNICODE
                if( rc == NO_ERROR )
                {
                    rc = pSetupCallSCE(
                            ST_SCE_DELETE,
                            FullTargetPath,
                            NULL,
                            NULL,
                            -1,
                            NULL
                            );
                    SetLastError( rc );
                }
#endif

                if(rc != NO_ERROR) {
                    FilePaths.Win32Error = rc;

                    u = pSetupCallMsgHandler(
                            Queue->LogContext,
                            MsgHandler,
                            IsMsgHandlerNativeCharWidth,
                            Context,
                            SPFILENOTIFY_DELETEERROR,
                            (UINT_PTR)&FilePaths,
                            0
                            );

                    if(u == FILEOP_ABORT) {
                        rc = GetLastError();
                        if(!rc) {
                            rc = ERROR_OPERATION_ABORTED;
                        }
                        MyFree(FullTargetPath);
                        goto clean0;
                    }
                    if(u == FILEOP_SKIP) {
                        break;
                    }
                }
            } while(rc != NO_ERROR);
        } else {
            rc = NO_ERROR;
        }

        FilePaths.Win32Error = rc;

        pSetupCallMsgHandler(
            Queue->LogContext,
            MsgHandler,
            IsMsgHandlerNativeCharWidth,
            Context,
            SPFILENOTIFY_ENDDELETE,
            (UINT_PTR)&FilePaths,
            0
            );

        MyFree(FullTargetPath);
    }

    pSetupCallMsgHandler(
        Queue->LogContext,
        MsgHandler,
        IsMsgHandlerNativeCharWidth,
        Context,
        SPFILENOTIFY_ENDSUBQUEUE,
        FILEOP_DELETE,
        0
        );

    rc = NO_ERROR;

clean0:
    SetLastError(rc);
    return rc;
}

DWORD
pCommitRenameQueue(
    IN PSP_FILE_QUEUE    Queue,
    IN PVOID             MsgHandler,
    IN PVOID             Context,
    IN BOOL              IsMsgHandlerNativeCharWidth
    )
/*++

Routine Description:

    Process the rename Queue
    Rename each file specified in the queue
    Files are backed up before they are renamed (if not already backed up)
    If the target exists, it is also backed up (if not already backed up)

    Performance: this can get optimized by treating the newly named files
                as a backup

    See also pCommitBackupQueue, pCommitDeleteQueue and pCommitCopyQueue

Arguments:

    Queue - queue that contains the rename sub-queue

    MsgHandler - Supplies a callback routine to be notified
        of various significant events in the queue processing.

    Context - Supplies a value that is passed to the MsgHandler
        callback function.

    IsMsgHandlerNativeCharWidth - For Unicode/Ansi support

Return Value:

    DWORD indicating status or success

--*/
{
    PSP_FILE_QUEUE_NODE QueueNode,queueNode;
    UINT u;
    BOOL b;
    DWORD rc;
    PCTSTR FullTargetPath;
    PCTSTR FullSourcePath;
    FILEPATHS FilePaths;
    BOOL BackupInUse = FALSE;
    BOOL TargetIsProtected;

    MYASSERT(Queue->RenameNodeCount);

    b = pSetupCallMsgHandler(
            Queue->LogContext,
            MsgHandler,
            IsMsgHandlerNativeCharWidth,
            Context,
            SPFILENOTIFY_STARTSUBQUEUE,
            FILEOP_RENAME,
            Queue->RenameNodeCount
            );

    if(!b) {
        rc = GetLastError();
        if(!rc) {
            rc = ERROR_OPERATION_ABORTED;
        }
        goto clean0;
    }
    for(QueueNode=Queue->RenameQueue; QueueNode; QueueNode=QueueNode->Next) {

        //
        // Form the full source path of the file to be renamed.
        //
        FullSourcePath = pSetupFormFullPath(
                            Queue->StringTable,
                            QueueNode->SourcePath,
                            QueueNode->SourceFilename,
                            -1
                            );

        if(!FullSourcePath) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        //
        // Form the full target path of the file to be renamed.
        //
        FullTargetPath = pSetupFormFullPath(
                            Queue->StringTable,
                            QueueNode->TargetDirectory == -1 ? QueueNode->SourcePath : QueueNode->TargetDirectory,
                            QueueNode->TargetFilename,
                            -1
                            );

        if(!FullTargetPath) {
            MyFree(FullSourcePath);
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        //
        // Backup the file we may be overwriting
        //
        if((rc=pSetupDoLastKnownGoodBackup(Queue,
                                           FullTargetPath,
                                           0,
                                           NULL)) != NO_ERROR) {
            MyFree(FullSourcePath);
            MyFree(FullTargetPath);
            goto clean0;
        }
        rc = pSetupCommitSingleBackup(Queue,
                                      FullTargetPath,
                                      QueueNode->TargetDirectory == -1 ? QueueNode->SourcePath : QueueNode->TargetDirectory,
                                      -1, // we don't use this
                                      QueueNode->TargetFilename,
                                      MsgHandler,
                                      Context,
                                      IsMsgHandlerNativeCharWidth,
                                      FALSE,
                                      &BackupInUse
                                     );
        if (rc != NO_ERROR) {
            MyFree(FullSourcePath);
            MyFree(FullTargetPath);
            goto clean0;
        }

        //
        // Backup the file we're about to rename
        //

        if((rc=pSetupDoLastKnownGoodBackup(Queue,
                                           FullSourcePath,
                                           LASTGOOD_OPERATION_DELETE,
                                           NULL)) != NO_ERROR) {
            MyFree(FullSourcePath);
            MyFree(FullTargetPath);
            goto clean0;
        }
        rc = pSetupCommitSingleBackup(Queue,
                                      FullSourcePath,
                                      QueueNode->SourcePath,
                                      -1, // we don't use this????
                                      QueueNode->SourceFilename,
                                      MsgHandler,
                                      Context,
                                      IsMsgHandlerNativeCharWidth,
                                      FALSE,
                                      &b
                                     );
        if (rc != NO_ERROR) {
            MyFree(FullSourcePath);
            MyFree(FullTargetPath);
            goto clean0;
        }
        if (b) {
            //
            // BackupInUse is the "OR" of the two backup In-Use flags
            //
            BackupInUse = TRUE;
        }

        FilePaths.Source = FullSourcePath;
        FilePaths.Target = FullTargetPath;
        FilePaths.Win32Error = NO_ERROR;

        //
        // Inform the callback that we are about to start a rename operation.
        //
        u = pSetupCallMsgHandler(
                Queue->LogContext,
                MsgHandler,
                IsMsgHandlerNativeCharWidth,
                Context,
                SPFILENOTIFY_STARTRENAME,
                (UINT_PTR)&FilePaths,
                FILEOP_RENAME
                );

        if(u == FILEOP_ABORT) {
            rc = GetLastError();
            if(!rc) {
                rc = ERROR_OPERATION_ABORTED;
            }
            MyFree(FullSourcePath);
            MyFree(FullTargetPath);
            goto clean0;
        }
        if(u == FILEOP_DOIT) {
            //
            // Attempt the rename. If it fails inform the callback,
            // which may decide to abort, retry. or skip the file.
            //
            do {
                if (BackupInUse) {
                    //
                    // backup is in use, must delay op.  Check to see if either
                    // the source or target files are protected system files.
                    // If so (and all the catalog nodes associated with the
                    // queue were OK), then we'll allos this to happen.
                    // Otherwise, we'll silently fail the rename (and log it).
                    //
                    MYASSERT((Queue->Flags & FQF_DID_CATALOGS_OK) ||
                             (Queue->Flags & FQF_DID_CATALOGS_FAILED));

                    if(Queue->Flags & FQF_DID_CATALOGS_OK) {

                        TargetIsProtected = IsFileProtected(FullSourcePath,
                                                            Queue->LogContext,
                                                            NULL
                                                           );
                        if(!TargetIsProtected) {
                            TargetIsProtected = IsFileProtected(FullTargetPath,
                                                                Queue->LogContext,
                                                                NULL
                                                               );
                        }

                        if(b = PostDelayedMove(Queue,
                                               FullSourcePath,
                                               FullTargetPath,
                                               -1,
                                               TargetIsProtected)) {
                            rc = NO_ERROR;
                        }
                        else
                        {
                            rc = GetLastError();
                        }
                        if(rc) {
                            WriteLogEntry(
                                Queue->LogContext,
                                DEL_ERR_LOG_LEVEL(rc) | SETUP_LOG_BUFFER,
                                MSG_LOG_DELAYRENAME_FILE_ERROR,
                                NULL,
                                FullSourcePath,
                                FullTargetPath);
                            WriteLogError(Queue->LogContext,DEL_ERR_LOG_LEVEL(rc),rc);
                        } else {
                            WriteLogEntry(
                                Queue->LogContext,
                                SETUP_LOG_INFO,
                                MSG_LOG_DELAYRENAMED_FILE,
                                NULL,
                                FullSourcePath,
                                FullTargetPath);
                        }

                    } else {
                        //
                        // We're installing an unsigned package.  Skip the
                        // delayed rename operation, and generate a log
                        // entry about this.
                        //
                        WriteLogEntry(Queue->LogContext,
                                      SETUP_LOG_ERROR,
                                      MSG_LOG_DELAYED_MOVE_SKIPPED_FOR_SFC,
                                      NULL,
                                      FullTargetPath
                                     );
                        //
                        // act as if no error occurred.
                        //
                        rc = NO_ERROR;
                    }

                } else {
                    rc = MoveFile(FullSourcePath,FullTargetPath) ? NO_ERROR : GetLastError();
                    if(rc) {
                        WriteLogEntry(
                            Queue->LogContext,
                            DEL_ERR_LOG_LEVEL(rc) | SETUP_LOG_BUFFER,
                            MSG_LOG_RENAME_FILE_ERROR,
                            NULL,
                            FullSourcePath,
                            FullTargetPath);
                        WriteLogError(Queue->LogContext,DEL_ERR_LOG_LEVEL(rc),rc);
                    } else {
                        WriteLogEntry(
                            Queue->LogContext,
                            SETUP_LOG_INFO,
                            MSG_LOG_RENAMED_FILE,
                            NULL,
                            FullSourcePath,
                            FullTargetPath);
                    }
                }

#ifdef UNICODE

                if( rc == NO_ERROR )
                {
                    rc = pSetupCallSCE(
                            ST_SCE_RENAME,
                            FullSourcePath,
                            NULL,
                            FullTargetPath,
                            -1,
                            NULL
                            );
                    SetLastError( rc );
                }

#endif

                if((rc == ERROR_FILE_NOT_FOUND) || (rc == ERROR_PATH_NOT_FOUND)) {
                    rc = NO_ERROR;
                }

                if(rc != NO_ERROR) {
                    FilePaths.Win32Error = rc;

                    u = pSetupCallMsgHandler(
                            Queue->LogContext,
                            MsgHandler,
                            IsMsgHandlerNativeCharWidth,
                            Context,
                            SPFILENOTIFY_RENAMEERROR,
                            (UINT_PTR)&FilePaths,
                            0
                            );

                    if(u == FILEOP_ABORT) {
                        rc = GetLastError();
                        if(!rc) {
                            rc = ERROR_OPERATION_ABORTED;
                        }
                        MyFree(FullSourcePath);
                        MyFree(FullTargetPath);
                        goto clean0;
                    }
                    if(u == FILEOP_SKIP) {
                        break;
                    }
                }
            } while(rc != NO_ERROR);
        } else {
            rc = NO_ERROR;
        }

        FilePaths.Win32Error = rc;

        pSetupCallMsgHandler(
            Queue->LogContext,
            MsgHandler,
            IsMsgHandlerNativeCharWidth,
            Context,
            SPFILENOTIFY_ENDRENAME,
            (UINT_PTR)&FilePaths,
            0
            );

        MyFree(FullSourcePath);
        MyFree(FullTargetPath);
    }

    pSetupCallMsgHandler(
        Queue->LogContext,
        MsgHandler,
        IsMsgHandlerNativeCharWidth,
        Context,
        SPFILENOTIFY_ENDSUBQUEUE,
        FILEOP_RENAME,
        0
        );

    rc = NO_ERROR;

clean0:
    SetLastError(rc);
    return rc;
}

DWORD
pCommitCopyQueue(
    IN PSP_FILE_QUEUE    Queue,
    IN PVOID             MsgHandler,
    IN PVOID             Context,
    IN BOOL              IsMsgHandlerNativeCharWidth
    )
/*++

Routine Description:

    Process the copy sub-Queues
    Copy each file specified in the sub-queues
    Files are backed up before they are overwritten (if not already backed up)
    See also pCommitBackupQueue, pCommitDeleteQueue and pCommitRenameQueue

Arguments:

    Queue - queue that contains the copy sub-queues

    MsgHandler - Supplies a callback routine to be notified
        of various significant events in the queue processing.

    Context - Supplies a value that is passed to the MsgHandler
        callback function.

    IsMsgHandlerNativeCharWidth - For Unicode/Ansi support

Return Value:

    DWORD indicating status or success

--*/
{
    PSOURCE_MEDIA_INFO SourceMediaInfo;
    SOURCE_MEDIA SourceMedia;
    PTCHAR p, temp;
    UINT SourcePathLen;
    UINT u;
    DWORD rc;
    Q_CAB_CB_DATA QData;
    BOOL b;
    BOOL FirstIteration;
    PSP_FILE_QUEUE_NODE QueueNode,queueNode;
    TCHAR UserSourceRoot[MAX_PATH];
    TCHAR UserSourcePath[MAX_PATH];
    TCHAR FullSourcePath[MAX_PATH];
    TCHAR UserOverride[MAX_PATH];
    LPCTSTR RestorePath = NULL;
    UINT    DriveType;
    BOOL    IsRemovable, AnyProcessed, AnyNotProcessed, SkipMedia;
    BOOL  SpecialMedia = FALSE;
    BOOL  LocateCab;
    PCTSTR MediaRoot;
    DWORD MediaLogTag;
    LONG Cabfile;
    LONG Tagfile;

    //
    // The caller is supposed to skip calling us if there are no files
    // to be copied.
    //
    MYASSERT(Queue->CopyNodeCount);

    //
    // Inform the callback that we are starting.
    //
    b = pSetupCallMsgHandler(
            Queue->LogContext,
            MsgHandler,
            IsMsgHandlerNativeCharWidth,
            Context,
            SPFILENOTIFY_STARTSUBQUEUE,
            FILEOP_COPY,
            Queue->CopyNodeCount
            );

    if(!b) {
        rc = GetLastError();
        if(!rc) {
            rc = ERROR_OPERATION_ABORTED;
        }
       return(rc);
    }

    if(Queue->RestorePathID != -1) {
        RestorePath = pSetupStringTableStringFromId(Queue->StringTable, Queue->RestorePathID);
        DiskPromptGetDriveType(RestorePath, &DriveType, &IsRemovable);
        if(IsRemovable) {
            //
            // do not allow restore from removable media
            //
            RestorePath = NULL;
        }
    }

    //
    // Initially, no user-specified override path exists.
    //
    UserSourceRoot[0] = TEXT('\0');
    UserSourcePath[0] = TEXT('\0');

    //
    // The outermost loop iterates through all the source media descriptors.
    //
    for(SourceMediaInfo=Queue->SourceMediaList; SourceMediaInfo; SourceMediaInfo=SourceMediaInfo->Next) {

        //
        // If there are no files on this particular media, skip it.
        // Otherwise get pointer to queue node for first file on this media.
        //
        if(!SourceMediaInfo->CopyNodeCount) {
            continue;
        }
        MYASSERT(SourceMediaInfo->CopyQueue);

        //
        // if last media was special media (see long discussion above),
        // then forget about any user override
        //
        if (SpecialMedia) {
            UserSourceRoot[0] = TEXT('\0');
            UserSourcePath[0] = TEXT('\0');
            SpecialMedia = FALSE;
        }

        //
        // see if this media is special media
        //
        if (SourceMediaInfo->Flags & ( SMI_FLAG_USE_SVCPACK_SOURCE_ROOT_PATH |
                                       SMI_FLAG_USE_LOCAL_SOURCE_CAB ) ) {
            SpecialMedia = TRUE;
        }

        //
        // If we're in restore-mode
        // we've been given a directory to restore from
        // ignore the media root, and use restore-point root
        // restore as many files as we can
        //
        // note, we check for file presence via FileExists
        // rather than trying to determine file name
        // since we'll always backup in uncompressed form
        // with same name as listed in [SourceDisksNames]
        //

        if(RestorePath) {
            //
            // Restore Symantics - prior to prompting for media, see
            // if we can restore backup
            //
            QueueNode = NULL;
            for(queueNode = SourceMediaInfo->CopyQueue;
                queueNode;
                queueNode=queueNode->Next) {

                pSetupBuildSourceForCopy(
                    RestorePath,
                    NULL,
                    SourceMediaInfo->SourceRootPath,
                    Queue,
                    queueNode,
                    FullSourcePath
                    );

                //
                // don't allow alternate sourcenames in this case
                //
                if(FileExists(FullSourcePath,NULL)) {
                    //
                    // backup exists, copy it
                    //
                    rc = pSetupCopySingleQueuedFile(
                            Queue,
                            queueNode,
                            FullSourcePath,
                            MsgHandler,
                            Context,
                            UserOverride,
                            IsMsgHandlerNativeCharWidth,
                            SP_COPY_ALREADYDECOMP // backup already decomp'd.
                            );
                    if(rc == NO_ERROR) {
                        //
                        // we restored this file through backup
                        // carry on to next file
                        //
                        queueNode->InternalFlags |= IQF_PROCESSED;
                        continue;
                    }
                    //
                    // we know backup existed so if this failed
                    // consider it major enough to abort restore
                    // (eg, file unsigned, user specified abort)
                    //
                    SetLastError(rc);
                    return(rc);
                }
                if(!QueueNode) {
                    //
                    // first problematic file
                    //
                    QueueNode = queueNode;
                }
            }
            if(!QueueNode) {
                //
                // we copied all files of this media from backup
                // carry on to next media
                //
                continue;
            }
        } else {
            //
            // not restoring, start at first file
            //
            QueueNode = SourceMediaInfo->CopyQueue;
        }


        //
        // We will need to prompt for media, which requires some preparation.
        // We need to get the first file in the queue for this media, because
        // its path is where we will expect to find it or its cabinet or tag
        // file.  If there is no tag file, then we will look for the file
        // itself.
        //

        FirstIteration = TRUE;
        SkipMedia = FALSE;
        LocateCab = FALSE;
        Tagfile = SourceMediaInfo->Tagfile;
        Cabfile = SourceMediaInfo->Cabfile;

RepromptMedia:
        //
        // The case where we have non-removeable media and the path was
        // previously overridden must be handled specially.  For example, we
        // could have files queued on the same source root but different
        // subdirs.  If the user changes the network location, for example,
        // we have to be careful or we'll ignore the change in subdirectories
        // as we move among the media.
        //
        // To work around this, we check on non-removable media to see if the
        // queue node we're presently working with is in a subdirectory.  If it
        // is, then we reset our UserSourcePath string.
        //
        // (andrewr)...I don't get this comment above.  The current code
        // iterates through each source media info structure, which doesn't include
        // subdirectory information, only source root path information.  If it
        // does, then the caller is doing something really wierd, since they
        // should be using the SourcePath to define subdirectories from one master
        // root.
        //
        // It appears that the reasoning behind the code below is as follows:
        //
        // The assumption is that if we have removable media and multiple source
        // paths, then we will have to swap media out of the drive.  We don't
        // override source root paths if we are dealing with removable media.
        // If the source root path is non removable, then all of the source media
        // is "tied together."  If the user overrides the source root path, then
        // we override subsequent fixed media source root paths.
        //
        // In the case of dealing with service pack source media or a local cab-file
        // drivers cache, the source media info for a queue will not be tied together,
        // even though we're dealing with fixed media.
        //
        // To reconcile the comments above and the reasoning it uses with the
        // contradiction that svc pack media imposes, we have 2 options:
        //
        // 1.  If we encounter flags that indicate one of our special cases, then don't
        //     use any user override for the new source media.  (or, put another way,
        //     if we know that the last media was actually one of these special media,
        //     then don't allow an override of the normal media.
        //
        // 2.  Introduce some sort of hueristic that determines if the prior source media
        //     and the current source media are similar.  If they are, then go ahead and
        //     use any user specified override, otherwise use the proper path.
        //
        //
        // For simplicities sake, I use approach 1 above.  This is made a little simpler
        // by following the following rule.  When adding source media to the media list,
        // insert special media (ie, has flags identifying the media as svc pack media)
        // at the head of the list, insert normal media after that.  By following this
        // approach we know that we can just "zero out" the user overrides for the special
        // media and we'll just do the right thing for the regular media.
        //
        // In the case where there is an explicit cab-file to use
        // then we ask the user to point to cab-file instead of source file (first iteration)
        //

        MediaRoot = *UserSourceRoot
                  ? UserSourceRoot
                  : pSetupStringTableStringFromId(Queue->StringTable, SourceMediaInfo->SourceRootPath);

        DiskPromptGetDriveType(MediaRoot, &DriveType, &IsRemovable);
        if(!IsRemovable && (QueueNode->SourcePath != -1)) {
            *UserSourcePath = TEXT('\0');
        }

        pSetupBuildSourceForCopy(
            UserSourceRoot,
            UserSourcePath,
            SourceMediaInfo->SourceRootPath,
            Queue,
            QueueNode,
            FullSourcePath
            );

        if (FirstIteration
            && (Tagfile != Cabfile)
            && (Cabfile != -1)) {

            MYASSERT(!SkipMedia);
            MYASSERT(!(SourceMediaInfo->Flags & SMI_FLAG_USE_LOCAL_SOURCE_CAB));

            //
            // build location of cab file
            //
            temp = _tcsrchr(FullSourcePath,TEXT('\\'));
            MYASSERT( temp );
            if(temp) {
                *(temp+1) = 0;
            } else {
                FullSourcePath[0] = 0;
            }


            //
            // obtain path of (potential) cab file
            //
            pSetupConcatenatePaths( FullSourcePath, pSetupStringTableStringFromId(Queue->StringTable,Cabfile), MAX_PATH, NULL );
            LocateCab = TRUE;

        } else {
            LocateCab = FALSE;
        }

        if((p = _tcsrchr(FullSourcePath,TEXT('\\')))!=NULL) {
            *p++ = TEXT('\0');
        } else {
            //
            // I'm being pedantic here, this should never happen
            //
            MYASSERT(p);
            p = FullSourcePath;
        }

        //
        // Now FullSourcePath has the path part and p has the file part
        // for the first file in the queue for this media (or explicit cab file)
        // Get the media in the drive by calling the callback function.
        //
        // Although it would be nice to not have to
        // call this callback if we know that we don't have to (there is media
        // where the caller said there should be (local media, media already in, etc.)
        // we do need to call this so that we afford the caller the luxury of
        // changing their mind one last time.
        //
        // the only exception to this rule is if we are using the local driver
        // cache cab-file.  In this case, we don't want the user to ever get
        // prompted for this file, so we skip any media prompting.  We know that
        // if we have media added that has this flag set, then the cab already exists
        // and we can just use it (otherwise we wouldn't have initialized it in the
        // first place, we'd just use the os source path!)
        //
        SourceMedia.Tagfile = (Tagfile != -1 && FirstIteration)
                            ?  pSetupStringTableStringFromId(
                                    Queue->StringTable,
                                    Tagfile
                                    )
                            : NULL;

        SourceMedia.Description = (SourceMediaInfo->Description != -1)
                                ? pSetupStringTableStringFromId(
                                        Queue->StringTable,
                                        SourceMediaInfo->DescriptionDisplayName
                                        )
                                : NULL;

        SourceMedia.SourcePath = FullSourcePath;
        SourceMedia.SourceFile = p;
        SourceMedia.Flags = (QueueNode->StyleFlags & (SP_COPY_NOSKIP | SP_COPY_WARNIFSKIP | SP_COPY_NOBROWSE));

        MediaLogTag = AllocLogInfoSlotOrLevel(Queue->LogContext,SETUP_LOG_INFO,FALSE);
        WriteLogEntry(
                    Queue->LogContext,
                    MediaLogTag,
                    MSG_LOG_NEEDMEDIA,
                    NULL,
                    SourceMedia.Tagfile ? SourceMedia.Tagfile : TEXT(""),
                    SourceMedia.Description ? SourceMedia.Description : TEXT(""),
                    SourceMedia.SourcePath ? SourceMedia.SourcePath : TEXT(""),
                    SourceMedia.SourceFile ? SourceMedia.SourceFile : TEXT(""),
                    SourceMedia.Flags
                    );

        if( SkipMedia || (FirstIteration && (SourceMediaInfo->Flags & SMI_FLAG_USE_LOCAL_SOURCE_CAB)) ) {
            u = FILEOP_DOIT;
            WriteLogEntry(
                        Queue->LogContext,
                        SETUP_LOG_VERBOSE,
                        MSG_LOG_NEEDMEDIA_AUTOSKIP,
                        NULL
                        );
        } else {
            u = pSetupCallMsgHandler(
                Queue->LogContext,
                MsgHandler,
                IsMsgHandlerNativeCharWidth,
                Context,
                SPFILENOTIFY_NEEDMEDIA,
                (UINT_PTR)&SourceMedia,
                (UINT_PTR)UserOverride
                );
        }


        if(u == FILEOP_ABORT) {
            rc = GetLastError();
            if(!rc) {
                rc = ERROR_OPERATION_ABORTED;
            }
            WriteLogEntry(
                        Queue->LogContext,
                        SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
                        MSG_LOG_NEEDMEDIA_ABORT,
                        NULL);
            WriteLogError(Queue->LogContext,
                        SETUP_LOG_ERROR,
                        rc
                        );
            ReleaseLogInfoSlot(Queue->LogContext,MediaLogTag);
            MediaLogTag = 0;
            SetLastError(rc);
            return(rc);
        }
        if(u == FILEOP_SKIP) {
            //
            // If this file was a bootfile replacement, then we need to restore
            // the original file that was renamed to a temporary filename.
            //
            WriteLogEntry(
                        Queue->LogContext,
                        SETUP_LOG_WARNING,
                        MSG_LOG_NEEDMEDIA_SKIP,
                        NULL
                        );
            ReleaseLogInfoSlot(Queue->LogContext,MediaLogTag);
            MediaLogTag = 0;
            if(QueueNode->StyleFlags & SP_COPY_REPLACE_BOOT_FILE) {
                RestoreBootReplacedFile(Queue, QueueNode);
            }

            //
            // If there are more files on this media, then try another one.
            // Otherwise we're done with this media.
            //
            QueueNode->InternalFlags |= IQF_PROCESSED;
            for(QueueNode=QueueNode->Next; QueueNode; QueueNode=QueueNode->Next) {
                if(!(QueueNode->InternalFlags & IQF_PROCESSED)) {
                    FirstIteration = FALSE;
                    goto RepromptMedia;
                }
            }
            continue;
        }
        if(u == FILEOP_NEWPATH) {
            //
            // User gave us a new source path. See which parts of the new path
            // match the existing path/overrides we are using.
            //
            WriteLogEntry(
                        Queue->LogContext,
                        SETUP_LOG_INFO,
                        MSG_LOG_NEEDMEDIA_NEWPATH,
                        NULL,
                        UserOverride
                        );
            ReleaseLogInfoSlot(Queue->LogContext,MediaLogTag);
            MediaLogTag = 0;
            pSetupSetPathOverrides(
                        Queue->StringTable,
                        UserSourceRoot,
                        UserSourcePath,
                        SourceMediaInfo->SourceRootPath,
                        QueueNode->SourcePath,
                        UserOverride
                        );
        }
        //
        // logging specific stuff
        //
        if(MediaLogTag!=0) {
            //
            // we explicitly cleared MediaLogTag for each case we handled
            //
            if (u != FILEOP_DOIT) {
                WriteLogEntry(
                            Queue->LogContext,
                            SETUP_LOG_WARNING,
                            MSG_LOG_NEEDMEDIA_BADRESULT,
                            NULL,
                            u);
            }
            ReleaseLogInfoSlot(Queue->LogContext,MediaLogTag);
            MediaLogTag = 0;
        }

        //
        // If we get here, the media is now accessible.
        // Some or all of the files might be in a cabinet whose name is the tagfile.
        //
        // NOTE: Win95 used the tagfile field to be the cabinet name instead.
        // If present it is used as a tagfile of sorts. The absence of a tagfile
        // means the files are not in cabinets. For NT, we don't bother
        // with all of this but instead try to be a little smarter.
        //
        // Scan the media for all source files we expect to find on it.
        // If we find a file, process it. Later we hit the cabinet and only
        // process the files we didn't already find outside the cabinet.
        //
        // exception to this is "explicit cabinet"
        //
        if(LocateCab) {
            //
            // an explicit cabinet was specified
            // this is first iteration
            // we've gone through NEED_MEDIA to obtain disk for this cabinet
            // don't try to process files outside cabinet
            // we know there is at least one file not processed
            //
            b = TRUE;
            queueNode=QueueNode;
        } else {
            //
            // tagfile may also be a cabfile
            // but process all files outside the cabfile first
            //
            for(queueNode=QueueNode; queueNode; queueNode=queueNode->Next) {

                if(queueNode->InternalFlags & IQF_PROCESSED) {
                    //
                    // Already processed. Skip to next file.
                    //
                    continue;
                }

                pSetupBuildSourceForCopy(
                    UserSourceRoot,
                    UserSourcePath,
                    SourceMediaInfo->SourceRootPath,
                    Queue,
                    queueNode,
                    FullSourcePath
                    );

                rc = SetupDetermineSourceFileName(FullSourcePath,&b,&p,NULL);
                if(rc == NO_ERROR || SkipMedia) {
                    //
                    // Found the file outside a cabinet. Process it now.
                    //
                    if(rc == NO_ERROR) {
                        rc = pSetupCopySingleQueuedFile(
                                Queue,
                                queueNode,
                                p,
                                MsgHandler,
                                Context,
                                UserOverride,
                                IsMsgHandlerNativeCharWidth,
                                0
                                );
                        MyFree(p);
                    } else {
                        //
                        // We didn't find the source file, but we're going to try
                        // to copy it anyway since we've decided not to skip the
                        // prompt for media.
                        //
                        rc = pSetupCopySingleQueuedFile(
                                Queue,
                                queueNode,
                                FullSourcePath,
                                MsgHandler,
                                Context,
                                UserOverride,
                                IsMsgHandlerNativeCharWidth,
                                0
                                );
                    }

                    if(rc != NO_ERROR) {
                        return(rc);
                    }

                    //
                    // See if we have a new source path.
                    //
                    if(UserOverride[0]) {
                        pSetupSetPathOverrides(
                            Queue->StringTable,
                            UserSourceRoot,
                            UserSourcePath,
                            SourceMediaInfo->SourceRootPath,
                            queueNode->SourcePath,
                            UserOverride
                            );
                    }
                }
            }
            //
            // See if any files still need to be processed.
            //
            for(b=FALSE,queueNode=QueueNode; queueNode; queueNode=queueNode->Next) {
                if(!(queueNode->InternalFlags & IQF_PROCESSED)) {
                    b = TRUE;
                    break;
                }
            }
        }

        //
        // If any files still need to be processed and we have a potential
        // cabinet file, go try to extract them from a cabinet.
        //
        if(b && (Cabfile != -1) && FirstIteration) {

            pSetupBuildSourceForCopy(
                UserSourceRoot,
                UserSourcePath,
                SourceMediaInfo->SourceRootPath,
                Queue,
                queueNode,
                FullSourcePath
                );

            temp = _tcsrchr(FullSourcePath,TEXT('\\'));
            MYASSERT( temp );
            if(temp) {
                *(temp+1) = 0;
            }

            //
            // obtain path of (potential) cab file
            //
            pSetupConcatenatePaths( FullSourcePath, pSetupStringTableStringFromId(Queue->StringTable,Cabfile), MAX_PATH, NULL );

            if(DiamondIsCabinet(FullSourcePath)) {

                QData.Queue = Queue;
                QData.SourceMedia = SourceMediaInfo;
                QData.MsgHandler = MsgHandler;
                QData.IsMsgHandlerNativeCharWidth = IsMsgHandlerNativeCharWidth;
                QData.Context = Context;
                QData.LogContext = Queue->LogContext;

                rc = DiamondProcessCabinet(
                        FullSourcePath,
                        0,
                        pSetupCabinetQueueCallback,
                        &QData,
                        TRUE
                        );

                if(rc != NO_ERROR) {
                    return(rc);
                }

                //
                // Now reset the cabfile to indicate that there is no cabinet.
                // If we don't do this and there are still files that have not
                // been processed, we'll end up in an infinite loop -- the prompt
                // will come back successfully, and we'll just keep going around
                // and around looking through the cabinet, etc.
                //
                Cabfile = -1;
                Tagfile = -1; // for compatability
            }
        }

        //
        // If we get here and files *still* need to be processed,
        // assume the files are in a different directory somewhere
        // and start all over with this media.
        //
        FirstIteration = FALSE;
        DiskPromptGetDriveType(FullSourcePath, &DriveType, &IsRemovable);
        AnyProcessed = FALSE;
        AnyNotProcessed = FALSE;

        for(QueueNode = SourceMediaInfo->CopyQueue;
            QueueNode;
            QueueNode=QueueNode->Next) {

            if(IsRemovable) {
                if(!(QueueNode->InternalFlags & IQF_PROCESSED)) {
                    if(Tagfile != -1) {
                        SkipMedia = TRUE;
                    }
                    goto RepromptMedia;
                }
            } else { // Fixed media
                if(QueueNode->InternalFlags & IQF_PROCESSED) {
                    AnyProcessed = TRUE;
                } else {
                    AnyNotProcessed = TRUE;
                }
            }
        }

        if(!IsRemovable) {
            if(AnyNotProcessed) {

                //
                // If some of the files are present on fixed media, we don't
                // want to look elsewhere.
                //
                if(AnyProcessed) {
                    SkipMedia = TRUE;
                }

                //
                // Find the first unprocessed file
                //
                for(QueueNode = SourceMediaInfo->CopyQueue;
                    QueueNode;
                    QueueNode = QueueNode->Next) {

                    if(!(QueueNode->InternalFlags & IQF_PROCESSED)) {
                        break;
                    }
                }
                MYASSERT(QueueNode);

                goto RepromptMedia;
            }
        }

    } // end for each source media info

    //
    // Tell handler we're done with the copy queue and return.
    //
    pSetupCallMsgHandler(
        Queue->LogContext,
        MsgHandler,
        IsMsgHandlerNativeCharWidth,
        Context,
        SPFILENOTIFY_ENDSUBQUEUE,
        FILEOP_COPY,
        0
        );

    return(NO_ERROR);
}


VOID
pSetupBuildSourceForCopy(
    IN  PCTSTR              UserRoot,
    IN  PCTSTR              UserPath,
    IN  LONG                MediaRoot,
    IN  PSP_FILE_QUEUE      Queue,
    IN  PSP_FILE_QUEUE_NODE QueueNode,
    OUT PTSTR               FullPath
    )
{
    PCTSTR p;


    //
    // If there is a user-specified override root path, use that instead of
    // the root path specified in the source media descriptor.
    //
    MYASSERT(Queue);
    MYASSERT(QueueNode);
    MYASSERT(FullPath);

    p = (UserRoot && UserRoot[0])
      ? UserRoot
      : pSetupStringTableStringFromId(Queue->StringTable,MediaRoot);


    lstrcpyn(FullPath,p,MAX_PATH);

    //
    // If there is a user-specified override path, use that instead of any
    // path specified in the copy node.
    //
    if(UserPath && UserPath[0]) {
        p = UserPath;
    } else {
        if(QueueNode->SourcePath == -1) {
            p = NULL;
        } else {
            p = pSetupStringTableStringFromId(Queue->StringTable,QueueNode->SourcePath);
        }
    }

    if(p) {
        pSetupConcatenatePaths(FullPath,p,MAX_PATH,NULL);
    }

    //
    // Fetch the filename and append.
    //
    p = pSetupStringTableStringFromId(Queue->StringTable,QueueNode->SourceFilename),
    pSetupConcatenatePaths(FullPath,p,MAX_PATH,NULL);

}

VOID
pSetupSetPathOverrides(
    IN     PVOID StringTable,
    IN OUT PTSTR RootPath,
    IN OUT PTSTR SubPath,
    IN     LONG  RootPathId,
    IN     LONG  SubPathId,
    IN     PTSTR NewPath
    )
{
    PCTSTR root,path;
    UINT u,l;

    //
    // See if the existing root override or root path is a prefix
    // of the path the user gave us.
    //
    MYASSERT(RootPath);
    MYASSERT(SubPath);
    root = RootPath[0] ? RootPath : pSetupStringTableStringFromId(StringTable,RootPathId);
    u = lstrlen(root);

    path = SubPath[0]
         ? SubPath
         : ((SubPathId == -1) ? NULL : pSetupStringTableStringFromId(StringTable,SubPathId));

    if(path && (*path == TEXT('\\'))) {
        path++;
    }

    if(_tcsnicmp(NewPath,root,u)) {
        //
        // Root path does not match what we're currently using, ie, the user
        // supplied a new path. In this case, we will see if the currently in-use
        // subpath matches the suffix of the new path, and if so, we'll assume
        // that is the override subpath and shorten the override root path.
        //
        lstrcpy(RootPath,NewPath);
        if(path) {
            u = lstrlen(NewPath);
            l = lstrlen(path);

            if((u > l) && (NewPath[(u-l)-1] == TEXT('\\')) && !lstrcmpi(NewPath+u-l,path)) {
                //
                // Subpath tail matches. Truncate the root override and
                // leave the subpath override alone.
                //
                RootPath[(u-l)-1] = 0;
            } else {
                //
                // In this case, we need to indicate an override subpath of the root,
                // or else all subsequent accesses will still try to append the subpath
                // specified in the copy node, which is not what we want.
                //
                SubPath[0] = TEXT('\\');
                SubPath[1] = 0;
            }
        }
    } else {
        //
        // Root path matches what we are currently using.
        //
        // See if the tail of the user-specified path matches the existing
        // subpath. If not, then use the rest of the root path as the subpath
        // override. If the tail matches, then extend the user override root.
        //
        // Examples:
        //
        //  File was queued with root = f:\, subpath = \mips
        //
        //  User override path is f:\alpha
        //
        //  The new status will be leave override root alone;
        //  override subpath = \alpha
        //
        //  File was queued with root = \\foo\bar, subpath = \i386
        //
        //  User override path is \\foo\bar\new\i386
        //
        //  The new status will be a root override of \\foo\bar\new;
        //  no override subpath.
        //
        NewPath += u;
        if(*NewPath == TEXT('\\')) {
            NewPath++;
        }

        if(path) {
            u = lstrlen(NewPath);
            l = lstrlen(path);

            if((u >= l) && !lstrcmpi(NewPath+u-l,path)) {
                //
                // Change root override and indicate no override subpath.
                //
                SubPath[0] = TEXT('\0');
                NewPath[u-l] = TEXT('\0');
                lstrcpy(RootPath,root);
                pSetupConcatenatePaths(RootPath,NewPath,MAX_PATH,NULL);
                u = lstrlen(RootPath);
                if(u && (*CharPrev(RootPath,RootPath+u) == TEXT('\\'))) {
                    RootPath[u-1] = TEXT('\0'); // valid to do if last char is '\'
                }
            } else {
                //
                // Leave override root alone but change subpath.
                //
                lstrcpy(SubPath,NewPath);
                if(!SubPath[0]) {
                    SubPath[0] = TEXT('\\');
                    SubPath[1] = TEXT('\0');
                }
            }
        } else {
            //
            // File was queued without a subpath. If there's a subpath
            // in what the user gave us, use it as the override.
            //
            if(*NewPath) {
                lstrcpy(SubPath,NewPath);
            }
        }
    }
}


UINT
pSetupCabinetQueueCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR  Param1,
    IN UINT_PTR  Param2
    )
{
    UINT rc;
    PCABINET_INFO CabinetInfo;
    PFILE_IN_CABINET_INFO FileInfo;
    TCHAR TempPath[MAX_PATH];
    PTSTR CabinetFile;
    PTSTR QueuedFile;
    PTSTR FilePart1,FilePart2;
    PTSTR FullTargetPath;
    PFILEPATHS FilePaths;
    PSP_FILE_QUEUE_NODE QueueNode,FirstNode,LastNode;
    PQ_CAB_CB_DATA QData;
    UINT h;
    SOURCE_MEDIA SourceMedia;
    DWORD status;

    QData = (PQ_CAB_CB_DATA)Context;

    switch(Notification) {

    case SPFILENOTIFY_CABINETINFO:
        //
        // We don't do anything with this.
        //
        rc = NO_ERROR;
        break;

    case SPFILENOTIFY_FILEINCABINET:
        //
        // New file within a cabinet.
        //
        // Determine whether we want to copy this file.
        // The context we get has all the stuff we need in it
        // to make this determination.
        //
        // Note that the queue could contain multiple copy operations
        // involving this file, but we only want to extract it once!
        //
        FileInfo = (PFILE_IN_CABINET_INFO)Param1;
        CabinetFile = (PTSTR)Param2;

        if(FilePart1 = _tcsrchr(FileInfo->NameInCabinet,TEXT('\\'))) {
            FilePart1++;
        } else {
            FilePart1 = (PTSTR)FileInfo->NameInCabinet;
        }

        rc = FILEOP_SKIP;
        FileInfo->Win32Error = NO_ERROR;
        FirstNode = NULL;

        //
        // Find ALL instances of this file in the queue and mark them.
        //
        for(QueueNode=QData->SourceMedia->CopyQueue; QueueNode; QueueNode=QueueNode->Next) {

            if(QueueNode->InternalFlags & IQF_PROCESSED) {
                //
                // This file was already processed. Ignore it.
                //
                continue;
            }

            //
            // Check the filename in the cabinet against the file
            // in the media's copy queue.
            //
            QueuedFile = pSetupStringTableStringFromId(
                            QData->Queue->StringTable,
                            QueueNode->SourceFilename
                            );

            if(FilePart2 = _tcsrchr(QueuedFile,TEXT('\\'))) {
                FilePart2++;
            } else {
                FilePart2 = QueuedFile;
            }

            if(!lstrcmpi(FilePart1,FilePart2)) {
                //
                // We want this file.
                //
                rc = FILEOP_DOIT;
                QueueNode->InternalFlags |= IQF_PROCESSED | IQF_MATCH;
                if(!FirstNode) {
                    FirstNode = QueueNode;
                }
                LastNode = QueueNode;
            }
        }

        if(rc == FILEOP_DOIT) {
            //
            // We want this file. Tell the caller the full target pathname
            // to be used, which is a temporary file in the directory
            // where the first instance of the file will ultimately go.
            // We do this so we can call SetupInstallFile later (perhaps
            // multiple times), which will handle version checks, etc.
            //
            // Before attempting to create a temp file make sure the path exists.
            //
            lstrcpyn(
                TempPath,
                pSetupStringTableStringFromId(QData->Queue->StringTable,FirstNode->TargetDirectory),
                MAX_PATH
                );
            pSetupConcatenatePaths(TempPath,TEXT("x"),MAX_PATH,NULL); // last component ignored
            status = pSetupMakeSurePathExists(TempPath);
            if(status == NO_ERROR) {
                LastNode->InternalFlags |= IQF_LAST_MATCH;
                if(GetTempFileName(
                        pSetupStringTableStringFromId(QData->Queue->StringTable,FirstNode->TargetDirectory),
                        TEXT("SETP"),
                        0,
                        FileInfo->FullTargetName
                        )) {
                    QData->CurrentFirstNode = FirstNode;
                } else {
                    status = GetLastError();
                    if(status == ERROR_ACCESS_DENIED) {
                        FileInfo->Win32Error = ERROR_INVALID_TARGET;
                    } else {
                        FileInfo->Win32Error = status;
                    }
                    rc = FILEOP_ABORT;
                    SetLastError(FileInfo->Win32Error);
                }
            } else {
                if(status == ERROR_ACCESS_DENIED) {
                    FileInfo->Win32Error = ERROR_INVALID_TARGET;
                } else {
                    FileInfo->Win32Error = status;
                }
                rc = FILEOP_ABORT;
                SetLastError(FileInfo->Win32Error);
            }
        }

        break;

    case SPFILENOTIFY_FILEEXTRACTED:

        FilePaths = (PFILEPATHS)Param1;
        //
        // The current file was extracted. If this was successful,
        // then we need to call SetupInstallFile on it to perform version
        // checks and move it into its final location or locations.
        //
        // The .Source member of FilePaths is the cabinet file.
        //
        // The .Target member is the name of the temporary file, which is
        // very useful, as it is the name if the file to use as the source
        // in copy operations.
        //
        // Process each file in the queue that we care about.
        //
        if((rc = FilePaths->Win32Error) == NO_ERROR) {

            for(QueueNode=QData->CurrentFirstNode; QueueNode && (rc==NO_ERROR); QueueNode=QueueNode->Next) {
                //
                // If we don't care about this file, skip it.
                //
                if(!(QueueNode->InternalFlags & IQF_MATCH)) {
                    continue;
                }

                QueueNode->InternalFlags &= ~IQF_MATCH;


                rc = pSetupCopySingleQueuedFileCabCase(
                        QData->Queue,
                        QueueNode,
                        FilePaths->Source,
                        FilePaths->Target,
                        QData->MsgHandler,
                        QData->Context,
                        QData->IsMsgHandlerNativeCharWidth
                        );

                //
                // If this was the last file that matched, break out.
                //
                if(QueueNode->InternalFlags & IQF_LAST_MATCH) {
                    QueueNode->InternalFlags &= ~IQF_LAST_MATCH;
                    break;
                }
            }
        }

        //
        // Delete the temporary file we extracted -- we don't need it any more.
        //
        DeleteFile(FilePaths->Target);

        break;

    case SPFILENOTIFY_NEEDNEWCABINET:
        //
        // Need a new cabinet.
        //
        CabinetInfo = (PCABINET_INFO)Param1;

        SourceMedia.Tagfile = NULL;
        SourceMedia.Description = CabinetInfo->DiskName;
        SourceMedia.SourcePath = CabinetInfo->CabinetPath;
        SourceMedia.SourceFile = CabinetInfo->CabinetFile;
        SourceMedia.Flags = SP_FLAG_CABINETCONTINUATION | SP_COPY_NOSKIP;

        h = pSetupCallMsgHandler(
                QData->LogContext,
                QData->MsgHandler,
                QData->IsMsgHandlerNativeCharWidth,
                QData->Context,
                SPFILENOTIFY_NEEDMEDIA,
                (UINT_PTR)&SourceMedia,
                Param2
                );

        switch(h) {

        case FILEOP_NEWPATH:
        case FILEOP_DOIT:
            rc = NO_ERROR;
            break;

        case FILEOP_ABORT:
            rc = GetLastError();
            if(!rc) {
                rc = ERROR_OPERATION_ABORTED;
            }
            break;

        default:
            rc = ERROR_OPERATION_ABORTED;
            break;

        }
        //
        // in this case, rc is a status code
        // but also set it as last error
        //
        SetLastError(rc);
        break;

    default:
        MYASSERT(0);
        rc = 0; // indeterminate
    }

    return(rc);
}


DWORD
pSetupCopySingleQueuedFile(
    IN  PSP_FILE_QUEUE      Queue,
    IN  PSP_FILE_QUEUE_NODE QueueNode,
    IN  PCTSTR              FullSourceName,
    IN  PVOID               MsgHandler,
    IN  PVOID               Context,
    OUT PTSTR               NewSourcePath,
    IN  BOOL                IsMsgHandlerNativeCharWidth,
    IN  DWORD               CopyStyleFlags
    )
{
    PTSTR FullTargetName;
    FILEPATHS FilePaths;
    UINT u;
    BOOL InUse;
    TCHAR source[MAX_PATH],PathBuffer[MAX_PATH];
    DWORD rc;
    BOOL b;
    BOOL BackupInUse = FALSE;
    BOOL SignatureVerifyFailed;

    NewSourcePath[0] = 0;
    PathBuffer[0] = 0;

    QueueNode->InternalFlags |= IQF_PROCESSED;

    //
    // Form the full target path of the file.
    //
    FullTargetName = pSetupFormFullPath(
                        Queue->StringTable,
                        QueueNode->TargetDirectory,
                        QueueNode->TargetFilename,
                        -1
                        );

    if(!FullTargetName) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    lstrcpyn(source,FullSourceName,MAX_PATH);

    //
    // check if we need to backup before we copy
    //
    if((rc=pSetupDoLastKnownGoodBackup(Queue,
                                       FullTargetName,
                                       0,
                                       NULL)) != NO_ERROR) {
        MyFree(FullTargetName);
        goto clean0;
    }
    rc = pSetupCommitSingleBackup(Queue,
                                  FullTargetName,
                                  QueueNode->TargetDirectory,
                                  -1,
                                  QueueNode->TargetFilename,
                                  MsgHandler,
                                  Context,
                                  IsMsgHandlerNativeCharWidth,
                                  (QueueNode->StyleFlags & SP_COPY_REPLACE_BOOT_FILE),
                                  &BackupInUse
                                 );
    if (rc != NO_ERROR) {
        MyFree(FullTargetName);
        goto clean0;
    }

    if (BackupInUse) {
        //
        // if we couldn't do backup, force the IN_USE flag
        //
        QueueNode->StyleFlags |= SP_COPY_FORCE_IN_USE;

    }

    do {
        //
        // Form the full source name.
        //
        FilePaths.Source = source;
        FilePaths.Target = FullTargetName;
        FilePaths.Win32Error = NO_ERROR;

        //
        // Also, pass the callback routine the CopyStyle flags we're about to
        // use.
        //
        // Callback flags are read-only.
        //
        FilePaths.Flags = QueueNode->StyleFlags;

        //
        // Notify the callback that the copy is starting.
        //
        u = pSetupCallMsgHandler(
                Queue->LogContext,
                MsgHandler,
                IsMsgHandlerNativeCharWidth,
                Context,
                SPFILENOTIFY_STARTCOPY,
                (UINT_PTR)&FilePaths,
                FILEOP_COPY
                );

        if(u == FILEOP_ABORT) {
            rc = GetLastError();
            if(!rc) {
                rc = ERROR_OPERATION_ABORTED;
            }
            WriteLogEntry(
                        Queue->LogContext,
                        SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
                        MSG_LOG_STARTCOPY_ABORT,
                        NULL);
            WriteLogError(Queue->LogContext,
                        SETUP_LOG_ERROR,
                        rc);
            break;
        }

        if(u == FILEOP_DOIT) {

            //
            // Attempt the copy.
            //
            //

            b = _SetupInstallFileEx(
                    Queue,
                    QueueNode,
                    NULL,                   // no inf handle
                    NULL,                   // no inf context
                    source,
                    NULL,                   // source path root is part of FullSourcePath
                    FullTargetName,
                    QueueNode->StyleFlags | SP_COPY_SOURCE_ABSOLUTE | CopyStyleFlags,
                    MsgHandler,
                    Context,
                    &InUse,
                    IsMsgHandlerNativeCharWidth,
                    &SignatureVerifyFailed
                    );

            rc = b ? NO_ERROR : GetLastError();

#ifdef UNICODE

            if(b || (rc == NO_ERROR)) {
                if(!InUse && (QueueNode->SecurityDesc != -1)){
                    //
                    // Set security on the file
                    //
                    rc = pSetupCallSCE(ST_SCE_SET,
                                       FullTargetName,
                                       Queue,
                                       NULL,
                                       QueueNode->SecurityDesc,
                                       NULL
                                      );
                }
            }
#endif

            if(rc == NO_ERROR) {
                //
                // File was copied or not copied, but it if was not copied
                // the callback funtcion was already notified about why
                // (version check failed, etc).
                //
                if(QueueNode->StyleFlags & SP_COPY_REPLACE_BOOT_FILE) {
                    //
                    // _SetupInstallFileEx is responsible for failing the copy
                    // when some yahoo comes and copies over a new file (and
                    // locks it) before we get a chance to.
                    //
                    MYASSERT(!InUse);

                    //
                    // If the file was copied, we need to set the wants-reboot
                    // flag.  Otherwise, we need to put back the original file.
                    //
                    if(b) {
                        QueueNode->InternalFlags |= INUSE_INF_WANTS_REBOOT;
                    } else {
                        RestoreBootReplacedFile(Queue, QueueNode);
                    }

                } else {

                    if(InUse) {
                        QueueNode->InternalFlags |= (QueueNode->StyleFlags & SP_COPY_IN_USE_NEEDS_REBOOT)
                                                  ? INUSE_INF_WANTS_REBOOT
                                                  : INUSE_IN_USE;
                    }
                }

            } else {
                DWORD LogTag = 0;
                //
                // File was not copied and a real error occurred.
                // Notify the callback (unless the failure was due to a signature
                // verification problem). Disallow skip if that is specified
                // in the node's flags.
                //
                if(SignatureVerifyFailed) {
                    break;
                } else {
                    LogTag = AllocLogInfoSlotOrLevel(Queue->LogContext,SETUP_LOG_INFO,FALSE);

                    FilePaths.Win32Error = rc;
                    FilePaths.Flags = QueueNode->StyleFlags & (SP_COPY_NOSKIP | SP_COPY_WARNIFSKIP | SP_COPY_NOBROWSE);

                    WriteLogEntry(
                                Queue->LogContext,
                                LogTag,
                                MSG_LOG_COPYERROR,
                                NULL,
                                FilePaths.Source,
                                FilePaths.Target,
                                FilePaths.Flags,
                                FilePaths.Win32Error
                                );

                    u = pSetupCallMsgHandler(
                            Queue->LogContext,
                            MsgHandler,
                            IsMsgHandlerNativeCharWidth,
                            Context,
                            SPFILENOTIFY_COPYERROR,
                            (UINT_PTR)&FilePaths,
                            (UINT_PTR)PathBuffer
                            );
                    if(u == FILEOP_ABORT) {
                        rc = GetLastError();
                        if(!rc) {
                            rc = ERROR_OPERATION_ABORTED;
                        }
                    }
                }

                if(u == FILEOP_ABORT) {
                    WriteLogEntry(
                                Queue->LogContext,
                                SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
                                MSG_LOG_COPYERROR_ABORT,
                                NULL
                                );
                    WriteLogError(Queue->LogContext,
                                SETUP_LOG_ERROR,
                                rc
                                );
                    ReleaseLogInfoSlot(Queue->LogContext,LogTag);
                    LogTag = 0;

                    break;
                } else {
                    if(u == FILEOP_SKIP) {
                        //
                        // If this file was a bootfile replacement, then we need
                        // to restore the original file that was renamed to a
                        // temporary filename.
                        //
                        if(QueueNode->StyleFlags & SP_COPY_REPLACE_BOOT_FILE) {
                            RestoreBootReplacedFile(Queue, QueueNode);
                        }

                        WriteLogEntry(
                                    Queue->LogContext,
                                    SETUP_LOG_WARNING,
                                    MSG_LOG_COPYERROR_SKIP,
                                    NULL
                                    );
                        ReleaseLogInfoSlot(Queue->LogContext,LogTag);
                        LogTag = 0;
                        //
                        // Force termination of processing for this file.
                        //
                        rc = NO_ERROR;
                        break;

                    } else {
                        if((u == FILEOP_NEWPATH) || ((u == FILEOP_RETRY) && PathBuffer[0])) {
                            WriteLogEntry(
                                        Queue->LogContext,
                                        SETUP_LOG_WARNING,
                                        MSG_LOG_COPYERROR_NEWPATH,
                                        NULL,
                                        u,
                                        PathBuffer
                                        );
                            ReleaseLogInfoSlot(Queue->LogContext,LogTag);
                            LogTag = 0;

                            //
                            // Note that rc is already set to something other than
                            // NO_ERROR or we wouldn't be here.
                            //
                            lstrcpyn(NewSourcePath,PathBuffer,MAX_PATH);
                            lstrcpyn(source,NewSourcePath,MAX_PATH);
                            pSetupConcatenatePaths(
                                source,
                                pSetupStringTableStringFromId(Queue->StringTable,QueueNode->SourceFilename),
                                MAX_PATH,
                                NULL
                                );
                        }

                        //
                        // Else we don't have a new path.
                        // Just keep using the one we had.
                        //
                    }
                }
                if (LogTag != 0) {
                    //
                    // haven't done anything regards logging yet, do it now
                    //
                    WriteLogEntry(
                                Queue->LogContext,
                                SETUP_LOG_INFO,
                                MSG_LOG_COPYERROR_RETRY,
                                NULL,
                                u
                                );
                    ReleaseLogInfoSlot(Queue->LogContext,LogTag);
                    LogTag = 0;
                }
            }
        } else {
            //
            // skip file
            //
            WriteLogEntry(
                        Queue->LogContext,
                        SETUP_LOG_INFO, // info level as this would be due to override of callback
                        MSG_LOG_STARTCOPY_SKIP,
                        NULL,
                        u
                        );
            rc = NO_ERROR;
        }
    } while(rc != NO_ERROR);

    //
    // Notify the callback that the copy is done.
    //
    FilePaths.Win32Error = rc;
    pSetupCallMsgHandler(
        Queue->LogContext,
        MsgHandler,
        IsMsgHandlerNativeCharWidth,
        Context,
        SPFILENOTIFY_ENDCOPY,
        (UINT_PTR)&FilePaths,
        0
        );


    MyFree(FullTargetName);

clean0:

    return(rc);
}


DWORD
pSetupCopySingleQueuedFileCabCase(
    IN  PSP_FILE_QUEUE      Queue,
    IN  PSP_FILE_QUEUE_NODE QueueNode,
    IN  PCTSTR              CabinetName,
    IN  PCTSTR              FullSourceName,
    IN  PVOID               MsgHandler,
    IN  PVOID               Context,
    IN  BOOL                IsMsgHandlerNativeCharWidth
    )
{
    PTSTR FullTargetName;
    FILEPATHS FilePaths;
    UINT u;
    BOOL InUse;
    TCHAR PathBuffer[MAX_PATH];
    DWORD rc;
    BOOL b;
    BOOL BackupInUse = FALSE;
    BOOL SignatureVerifyFailed;
    DWORD LogTag = 0;
    LPCTSTR SourceName;

    //
    // Form the full target path of the file.
    //
    SourceName = pSetupStringTableStringFromId(Queue->StringTable,QueueNode->SourceFilename);
    FullTargetName = pSetupFormFullPath(
                        Queue->StringTable,
                        QueueNode->TargetDirectory,
                        QueueNode->TargetFilename,
                        -1
                        );

    if(!FullTargetName) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }


    LogTag = AllocLogInfoSlotOrLevel(Queue->LogContext,SETUP_LOG_INFO,FALSE);
    WriteLogEntry(
                Queue->LogContext,
                LogTag,
                MSG_LOG_COPY_FROM_CAB,
                NULL,
                CabinetName,
                SourceName,
                FullSourceName,
                FullTargetName
                );

    //
    // check if we need to backup before we copy
    //
    if((rc=pSetupDoLastKnownGoodBackup(Queue,
                                       FullTargetName,
                                       0,
                                       NULL)) != NO_ERROR) {
        MyFree(FullTargetName);
        goto clean0;
    }
    rc = pSetupCommitSingleBackup(Queue,
                                  FullTargetName,
                                  QueueNode->TargetDirectory,
                                  -1,
                                  QueueNode->TargetFilename,
                                  MsgHandler,
                                  Context,
                                  IsMsgHandlerNativeCharWidth,
                                  (QueueNode->StyleFlags & SP_COPY_REPLACE_BOOT_FILE),
                                  &BackupInUse
                                 );
    if (rc != NO_ERROR) {
        MyFree(FullTargetName);
        goto clean0;
    }

    if (BackupInUse) {
        //
        // if we couldn't do backup, force the IN_USE flag
        //
        QueueNode->StyleFlags |= SP_COPY_FORCE_IN_USE;

    }
    //
    // We use the cabinet name as the source name so the display looks right
    // to the user. Otherwise he sees the name of some temp file in the
    // source field.
    //
    FilePaths.Source = CabinetName;
    FilePaths.Target = FullTargetName;
    FilePaths.Win32Error = NO_ERROR;

    //
    // Also, pass the callback routine the CopyStyle flags we're about to
    // use.
    //
    // Callback flags are read-only.
    //
    FilePaths.Flags = QueueNode->StyleFlags;

    do {
        //
        // Notify the callback that the copy is starting.
        //
        u = pSetupCallMsgHandler(
                Queue->LogContext,
                MsgHandler,
                IsMsgHandlerNativeCharWidth,
                Context,
                SPFILENOTIFY_STARTCOPY,
                (UINT_PTR)&FilePaths,
                FILEOP_COPY
                );

        if(u == FILEOP_ABORT) {
            rc = GetLastError();
            if(!rc) {
                rc = ERROR_OPERATION_ABORTED;
            }
            break;
        }

        if(u == FILEOP_DOIT) {
            //
            // Attempt the copy.
            //
            b = _SetupInstallFileEx(
                    Queue,
                    QueueNode,
                    NULL,                   // no inf handle
                    NULL,                   // no inf context
                    FullSourceName,
                    NULL,                   // source path root is part of FullSourcePath
                    FullTargetName,
                    QueueNode->StyleFlags | SP_COPY_SOURCE_ABSOLUTE,
                    MsgHandler,
                    Context,
                    &InUse,
                    IsMsgHandlerNativeCharWidth,
                    &SignatureVerifyFailed
                    );

#ifdef UNICODE
            if(b || ((rc = GetLastError()) == NO_ERROR)) {
                if(!InUse && (QueueNode->SecurityDesc != -1) ){
                    // Set security on the file

                    rc = pSetupCallSCE(
                            ST_SCE_SET,
                            FullTargetName,
                            Queue,
                            NULL,
                            QueueNode->SecurityDesc,
                            NULL
                            );
                    SetLastError( rc );
                }

            }
#endif

            if(b || ((rc = GetLastError()) == NO_ERROR)) {
                //
                // File was copied or not copied, but it if was not copied
                // the callback funtcion was already notified about why
                // (version check failed, etc).
                //
                if(InUse) {
                    QueueNode->InternalFlags |= (QueueNode->StyleFlags & SP_COPY_IN_USE_NEEDS_REBOOT)
                                              ? INUSE_INF_WANTS_REBOOT
                                              : INUSE_IN_USE;
                }
                rc = NO_ERROR;
            } else {
                //
                // File was not copied and a real error occurred.
                // Break out and return the error.
                //
                break;
            }
        } else {
            //
            // skip file
            //
            rc = NO_ERROR;
        }
    } while(rc != NO_ERROR);

    //
    // Notify the callback that the copy is done.
    //
    FilePaths.Win32Error = rc;
    pSetupCallMsgHandler(
        Queue->LogContext,
        MsgHandler,
        IsMsgHandlerNativeCharWidth,
        Context,
        SPFILENOTIFY_ENDCOPY,
        (UINT_PTR)&FilePaths,
        0
        );

    MyFree(FullTargetName);

clean0:
    if(LogTag) {
        ReleaseLogInfoSlot(Queue->LogContext,LogTag);
    }

    return(rc);
}


PTSTR
pSetupFormFullPath(
    IN PVOID  StringTable,
    IN LONG   PathPart1,
    IN LONG   PathPart2,    OPTIONAL
    IN LONG   PathPart3     OPTIONAL
    )

/*++

Routine Description:

    Form a full path based on components whose strings are in a string
    table.

Arguments:

    StringTable - supplies handle to string table.

    PathPart1 - Supplies first part of path

    PathPart2 - if specified, supplies second part of path

    PathPart3 - if specified, supplies third part of path

Return Value:

    Pointer to buffer containing full path. Caller can free with MyFree().
    NULL if out of memory.

--*/

{
    UINT RequiredSize;
    PCTSTR p1,p2,p3;
    TCHAR Buffer[MAX_PATH];

    p1 = pSetupStringTableStringFromId(StringTable,PathPart1);
    if (!p1) {
        return NULL;
    }
    p2 = (PathPart2 == -1) ? NULL : pSetupStringTableStringFromId(StringTable,PathPart2);
    p3 = (PathPart3 == -1) ? NULL : pSetupStringTableStringFromId(StringTable,PathPart3);

    lstrcpy(Buffer,p1);
    if(!p2 || pSetupConcatenatePaths(Buffer,p2,MAX_PATH,NULL)) {
        if(p3) {
            pSetupConcatenatePaths(Buffer,p3,MAX_PATH,NULL);
        }
    }

    return(DuplicateString(Buffer));
}


DWORD
pSetupVerifyQueuedCatalogs(
    IN HSPFILEQ FileQueue
    )
/*++

Routine Description:

    Silently verify all catalog nodes in the specified queue.

Arguments:

    FileQueue - supplies a handle to the file queue containing catalog nodes
        to be verified.

Return Value:

    If all catalog nodes are valid, the return value is NO_ERROR.  Otherwise,
    it is a Win32 error code indicating the problem.

--*/
{
    return _SetupVerifyQueuedCatalogs(NULL,  // No UI, thus no HWND needed
                                      (PSP_FILE_QUEUE)FileQueue,
                                      VERCAT_NO_PROMPT_ON_ERROR,
                                      NULL,
                                      NULL
                                     );
}


DWORD
_SetupVerifyQueuedCatalogs(
    IN  HWND           Owner,
    IN  PSP_FILE_QUEUE Queue,
    IN  DWORD          Flags,
    OUT PTSTR          DeviceInfFinalName,  OPTIONAL
    OUT PBOOL          DeviceInfNewlyCopied OPTIONAL
    )

/*++

Routine Description:

    This routine verifies catalogs and infs in a given queue by traversing
    the catalog node list associated with the queue and operating on the
    catalog/inf pair described by each one.

    If any catalog/inf fails verification, the user is notified via a dialog,
    depending on current policy.

    ** Behavior for native platform verification (w/o catalog override)

    If an INF is from a system location, we assume that the catalog is
    already installed on the system. Really there is no other option here,
    since we would have no idea where to get the catalog in order to install it
    even if we wanted to try. But the inf might have originally been an
    oem inf which was copied and renamed by the Di stuff at device install
    time. The catalog file knows nothing about the renamed file, so we must
    track mappings from current inf filename to original inf filename.

    In this case, we calculate the inf's hash value and then using that,
    we ask the system for a catalog file that contains signing data
    for that hash value. We then ask the system for info
    about that catalog file. We keep repeating this process until we get
    at the catalog we want (based on name). Finally we can call WinVerifyTrust
    verify the catalog itself and the inf.

    If an INF file is instead from an oem location, we copy the oem inf to a
    unique name in the system inf directory (or create a zero-length placeholder
    there, depending on whether or not the VERCAT_INSTALL_INF_AND_CAT flag is
    set), and add the catalog using a filename based on that unique filename.

    ** Behavior for non-native platform verification (w/o catalog override) **

    We will validate the catalogs and INFs using the alternate platform info
    provided in the file queue.  Otherwise, the logic is the same as in the
    native case.

    ** Behavior for verification (w/catalog override) **

    The actual verification will be done using native or non-native parameters
    as discussed above, but INFs without a CatalogFile= entry will be validated
    against the specified overriding catalog.  This means that system INFs won't
    get validated globally, and INF in OEM locations can be validated even if
    they don't have a CatalogFile= entry.  The overriding catalog file will be
    installed under its current name, thus blowing away any existing catalog
    having that name.

    See the documentation on SetupSetFileQueueAlternatePlatform for more
    details.

Arguments:

    Owner - supplies window handle of window to own any ui.  This HWND is stored
        away in the queue for use later if any individual files fail verification.

    Queue - supplies pointer to queue structure.

    Flags - supplies flags that control behavior of this routine.

        VERCAT_INSTALL_INF_AND_CAT - if this flag is set, any infs from
            oem locations will be installed on the system, along with
            their catalog files.

        VERCAT_NO_PROMPT_ON_ERROR - if this flag is set, the user will _not_ be
            notified about verification failures we encounter.  If this flag is
            set, then this was only a 'test', and no user prompting should take
            place (nor should any PSS logging take place).  If this flag is set,
            then the VERCAT_INSTALL_INF_AND_CAT _should not_ be specified.

        VERCAT_PRIMARY_DEVICE_INF_FROM_INET - specifies that the primary device
            INF in the queue is from the internet, and should be marked as such
            in the corresponding PNF when installed into the %windir%\Inf
            directory via _SetupCopyOEMInf.

    DeviceInfFinalName - optionally, supplies the address of a character buffer,
        _at least_ MAX_PATH characters long, that upon success receives the
        final name given to the INF under the %windir%\Inf directory (this will
        be different than the INF's original name if it was an OEM INF).

    DeviceInfNewlyCopied - optionally, supplies the address of a boolean
        variable that, upon success, is set to indicate whether the INF name
        returned in DeviceInfFinalName was newly-created.  If this parameter is
        supplied, then DeviceInfFinalName must also be specified.

Return Value:

    If all catalogs/infs were verified and installed, or the user accepted
        the risk if a verification failed, then the return value is NO_ERROR.

    If one or more catalogs/infs were not verified, the return value is a Win32
        error code indicating the cause of the failure.  NOTE:  This error will
        only be returned if the policy is "block", or it it's "warn" and the
        user decided to abort.  In this case, the error returned is for the
        catalog/INF where the error was encountered, and any subsequent catalog
        nodes will not have been verified.  An exception to this is when the
        VERCAT_NO_PROMPT_ON_ERROR flag is set.  In that case, we'll verify all
        catalogs, even if we encounter improperly-signed ones.

Remarks:

    There are some system INFs (for which global verification is required) that
    don't live in %windir%\Inf.  The OCM INFs are an example of this.  Those
    INFs use layout.inf (which _is_ located in %windir%\Inf) for the source
    media information for any files they copy.  There are other INFs that don't
    live in %windir%\Inf which are extracted out of a binary as-needed (into a
    temporary filename), processed in order to do registry munging, and then
    deleted.  Such INFs do not do file copying (thus their 'package' consists
    of just the INF).  To accommodate such INFs, we allow "OEM" INFs (i.e.,
    those INFs not in %windir%\Inf) to be verified globally, but we remember the
    fact that these INFs didn't contain a CatalogFile= entry, and if any files
    are ever queued for copy using such INFs for source media information, then
    we'll fail digital signature verification for such files, since there's no
    way for us to know what catalog should be used for verification.

--*/

{
    PSPQ_CATALOG_INFO CatalogNode;
    LPCTSTR InfFullPath;
    LPCTSTR CatName;
    TCHAR PathBuffer[MAX_PATH];
    TCHAR InfNameBuffer[MAX_PATH];
    TCHAR CatalogName[MAX_PATH];
    TCHAR *p;
    DWORD Err, CatalogNodeStatus, ReturnStatus;
    SetupapiVerifyProblem Problem;
    LPCTSTR ProblemFile;
    BOOL DeleteOemInfOnError;
    BOOL OriginalNameDifferent;
    LPCTSTR AltCatalogFile;
    LONG CatStringId;
    ULONG RequiredSize;
    DWORD InfVerifyType;
    DWORD SCOIFlags;

//
// Define values used to indicate how validation should be done on the INFs.
//
#define VERIFY_INF_AS_OEM       0  // verify solely against the specific
                                   // catalog referenced by the INF

#define VERIFY_INF_AS_SYSTEM    1  // verify globally (using all catalogs)

#define VERIFY_OEM_INF_GLOBALLY 2  // verify OEM INF globally, but remember the
                                   // original error, in case copy operations
                                   // are queued using media descriptor info
                                   // within this INF.


    MYASSERT((Flags & (VERCAT_INSTALL_INF_AND_CAT | VERCAT_NO_PROMPT_ON_ERROR))
             != (VERCAT_INSTALL_INF_AND_CAT | VERCAT_NO_PROMPT_ON_ERROR)
            );

    MYASSERT(!DeviceInfNewlyCopied || DeviceInfFinalName);

    if(Queue->Flags & FQF_DID_CATALOGS_OK) {
        //
        // If the caller wants information about the primary device INF, then
        // find the applicable catalog node.
        //
        if(DeviceInfFinalName) {
            for(CatalogNode=Queue->CatalogList; CatalogNode; CatalogNode=CatalogNode->Next) {

                if(CatalogNode->Flags & CATINFO_FLAG_PRIMARY_DEVICE_INF) {
                    MYASSERT(CatalogNode->InfFinalPath != -1);
                    InfFullPath = pSetupStringTableStringFromId(Queue->StringTable, CatalogNode->InfFinalPath);
                    lstrcpy(DeviceInfFinalName, InfFullPath);
                    if(DeviceInfNewlyCopied) {
                        *DeviceInfNewlyCopied = (CatalogNode->Flags & CATINFO_FLAG_NEWLY_COPIED);
                    }
                }
            }
        }

        return NO_ERROR;
    }

    if(Queue->Flags & FQF_DID_CATALOGS_FAILED) {
        //
        // Scan the catalog nodes until we find the first one that failed
        // verification, and return that failure code.
        //
        for(CatalogNode=Queue->CatalogList; CatalogNode; CatalogNode=CatalogNode->Next) {

            if(CatalogNode->VerificationFailureError != NO_ERROR) {
                return CatalogNode->VerificationFailureError;
            }
        }

        //
        // We didn't find a failed catalog node in our catalog list--something's
        // seriously wrong!
        //
        MYASSERT(0);
        return ERROR_INVALID_DATA;
    }

    //
    // If the queue has an alternate default catalog file associated with it,
    // then retrieve that catalog's name for use later.
    //
    AltCatalogFile = (Queue->AltCatalogFile != -1)
                   ? pSetupStringTableStringFromId(Queue->StringTable, Queue->AltCatalogFile)
                   : NULL;

    Queue->hWndDriverSigningUi = Owner;
    ReturnStatus = NO_ERROR;

    for(CatalogNode=Queue->CatalogList; CatalogNode; CatalogNode=CatalogNode->Next) {
        //
        // Assume success for verification of this catalog node.
        //
        CatalogNodeStatus = NO_ERROR;

        MYASSERT(CatalogNode->InfFullPath != -1);
        InfFullPath = pStringTableStringFromId(Queue->StringTable, CatalogNode->InfFullPath);

        if(Queue->Flags & FQF_USE_ALT_PLATFORM) {
            //
            // We have an alternate platform override, so use the alternate
            // platform's CatalogFile= entry.
            //
            CatStringId = CatalogNode->AltCatalogFileFromInf;
        } else {
            //
            // We're running native--use the native CatalogFile= entry.
            //
            CatStringId = CatalogNode->CatalogFileFromInf;
        }
        CatName = (CatStringId != -1)
                  ? pStringTableStringFromId(Queue->StringTable, CatStringId)
                  : NULL;

        InfVerifyType = pSetupInfIsFromOemLocation(InfFullPath, TRUE)
                      ? VERIFY_INF_AS_OEM
                      : VERIFY_INF_AS_SYSTEM;

        if(InfVerifyType == VERIFY_INF_AS_OEM) {
            //
            // If the caller wants us to, we'll now install the catalog.  In
            // addition, if it's a (native platform) device installation, we'll
            // install the INF as well.
            //
            // (Note: we specify the 'no overwrite' switch so that we won't blow
            // away any existing PNF source path information for this INF.
            // We'll only consider an OEM INF to match up with an existing
            // %windir%\Inf\Oem*.INF entry if the catalogs also match up, so
            // we're not going to get into any trouble doing this.
            //
            if(Flags & VERCAT_INSTALL_INF_AND_CAT) {
                //
                // If we're not doing a device install, then we want to suppress
                // popups and error log entries if the INF doesn't reference a
                // catalog.  This is because we want to allow such INFs to be
                // validated globally, unless they subsequently try to copy files.
                //
                SCOIFlags = (Queue->Flags & FQF_DEVICE_INSTALL)
                          ? 0
                          : SCOI_NO_ERRLOG_ON_MISSING_CATALOG;

                //
                // If we're not supposed to generate popups/log entries at all
                // for signature verification failures (e.g., because we've
                // already done so previously), then set that flag as well.
                //
                if(Queue->Flags & FQF_DIGSIG_ERRORS_NOUI) {
                    SCOIFlags |= SCOI_NO_UI_ON_SIGFAIL;
                }

                if(Queue->Flags & FQF_KEEP_INF_AND_CAT_ORIGINAL_NAMES) {
                    SCOIFlags |= SCOI_KEEP_INF_AND_CAT_ORIGINAL_NAMES;
                }

                if(Queue->Flags & FQF_ABORT_IF_UNSIGNED) {
                    SCOIFlags |= SCOI_ABORT_IF_UNSIGNED;
                }

                if(_SetupCopyOEMInf(InfFullPath,
                                    NULL, // default source location to where INF presently is
                                    ((Flags & VERCAT_PRIMARY_DEVICE_INF_FROM_INET)
                                        ? SPOST_URL
                                        : SPOST_PATH),
                                    (((Queue->Flags & (FQF_DEVICE_INSTALL | FQF_USE_ALT_PLATFORM)) == FQF_DEVICE_INSTALL)
                                        ? SP_COPY_NOOVERWRITE
                                        : SP_COPY_NOOVERWRITE | SP_COPY_OEMINF_CATALOG_ONLY),
                                    PathBuffer,
                                    SIZECHARS(PathBuffer),
                                    NULL,
                                    &p,
                                    ((CatalogNode->InfOriginalName != -1)
                                        ? pStringTableStringFromId(Queue->StringTable,
                                                                   CatalogNode->InfOriginalName)
                                        : pSetupGetFileTitle(InfFullPath)),
                                    CatName,
                                    Owner,
                                    ((Queue->DeviceDescStringId == -1)
                                        ? NULL
                                        : pStringTableStringFromId(Queue->StringTable,
                                                                   Queue->DeviceDescStringId)),
                                    Queue->DriverSigningPolicy,
                                    SCOIFlags,
                                    AltCatalogFile,
                                    ((Queue->Flags & FQF_USE_ALT_PLATFORM)
                                        ? &(Queue->AltPlatformInfo)
                                        : Queue->ValidationPlatform),
                                    &Err,
                                    CatalogNode->CatalogFilenameOnSystem,
                                    Queue->LogContext,
                                    &(Queue->hCatAdmin))) {
                    //
                    // If Err indicates that there was a digital signature
                    // problem that the user chose to ignore (or was silently
                    // ignored), then set a flag in the queue indicating the
                    // user should not be warned about subsequent failures.
                    // Don't set this flag if the queue's policy is "Ignore",
                    // however, on the chance that the policy might be altered
                    // later, and we'd want the user to get informed on any
                    // subsequent errors.
                    //
                    // (Note: if the error was due to the INF not having a
                    // CatalogFile= entry, and if we're supposed to ignore such
                    // problems, then just set the flag to do global validation
                    // later.)
                    //
                    if((Err == ERROR_NO_CATALOG_FOR_OEM_INF) &&
                       (SCOIFlags & SCOI_NO_ERRLOG_ON_MISSING_CATALOG)) {

                        InfVerifyType = VERIFY_OEM_INF_GLOBALLY;

                    } else if((Err != NO_ERROR) && (Queue->DriverSigningPolicy != DRIVERSIGN_NONE)) {

                        Queue->Flags |= FQF_DIGSIG_ERRORS_NOUI;
                    }

                    if(*PathBuffer) {
                        //
                        // Store the INF's final path into our catalog node.
                        // This will be under %windir%\Inf unless the INF didn't
                        // specify a CatalogFile= entry and we did an alternate
                        // catalog installation (i.e., because the file queue had
                        // an associated alternate catalog).
                        //
                        CatalogNode->InfFinalPath = pSetupStringTableAddString(
                                                        Queue->StringTable,
                                                        PathBuffer,
                                                        STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                                       );
                    } else {
                        //
                        // _SetupCopyOEMInf returned an empty string for the
                        // destination INF name, which means that we were doing
                        // a catalog-only install, and it didn't find the INF
                        // already existing in %windir%\Inf.  In this case, just
                        // use the INF's original pathname as its final pathname.
                        //
                        CatalogNode->InfFinalPath = CatalogNode->InfFullPath;
                    }

                    if(CatalogNode->InfFinalPath == -1) {

                        CatalogNodeStatus = ERROR_NOT_ENOUGH_MEMORY;
                        if(Err == NO_ERROR) {
                            Err = CatalogNodeStatus;
                        }

                        //
                        // Since we couldn't add this filename to the string
                        // table, we won't be able to undo this copy later--it
                        // must be done here.  Delete the INF, PNF, and CAT.
                        //
                        // NOTE: we should never get here if we did an alternate
                        // catalog file-only install, because in that case our
                        // new INF name is the same as the INF's original name,
                        // thus the string is already in the buffer and there's
                        // no way we could run out of memory.
                        //
                        MYASSERT(lstrcmpi(PathBuffer, InfFullPath));

                        pSetupUninstallOEMInf(PathBuffer,
                                              Queue->LogContext,
                                              SUOI_FORCEDELETE,
                                              NULL
                                             );

                    } else {
                        //
                        // Set a flag in the catalog node indicating that this
                        // INF was newly-copied into %windir%\Inf.  If the
                        // string ID for our INF's original name and that of its
                        // new name are equal, then we know we did an alternate
                        // catalog installation only, and we don't want to set
                        // this flag.
                        //
                        if(CatalogNode->InfFinalPath != CatalogNode->InfFullPath) {
                            CatalogNode->Flags |= CATINFO_FLAG_NEWLY_COPIED;
                        }

                        //
                        // If this is the primary device INF, and the caller
                        // requested information about that INF's final
                        // pathname, then store that information in the caller-
                        // supplied buffer(s) now.
                        //
                        if(DeviceInfFinalName &&
                           (CatalogNode->Flags & CATINFO_FLAG_PRIMARY_DEVICE_INF)) {
                            //
                            // We'd better not just've done an alternate catalog
                            // installation.
                            //
                            MYASSERT(CatalogNode->InfFinalPath != CatalogNode->InfFullPath);

                            lstrcpy(DeviceInfFinalName, PathBuffer);
                            if(DeviceInfNewlyCopied) {
                                *DeviceInfNewlyCopied = TRUE;
                            }
                        }
                    }

                } else {

                    CatalogNodeStatus = GetLastError();
                    MYASSERT(CatalogNodeStatus != NO_ERROR);

                    if(CatalogNodeStatus == ERROR_FILE_EXISTS) {
                        //
                        // INF and CAT already there--this isn't a failure.
                        //
                        // Store the name under which we found this OEM INF into
                        // the catalog node's InfFinalPath field.
                        //
                        CatalogNode->InfFinalPath = pSetupStringTableAddString(
                                                        Queue->StringTable,
                                                        PathBuffer,
                                                        STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                                       );

                        if(CatalogNode->InfFinalPath == -1) {
                            CatalogNodeStatus = ERROR_NOT_ENOUGH_MEMORY;
                        } else {
                            CatalogNodeStatus = NO_ERROR;
                            //
                            // If Err indicates that there was a digital signature
                            // problem that the user chose to ignore (or was silently
                            // ignored), then set a flag in the queue indicating the
                            // user should not be warned about subsequent failures.
                            // Don't set this flag if the queue's policy is "Ignore",
                            // however, on the chance that the policy might be altered
                            // later, and we'd want the user to get informed on any
                            // subsequent errors.
                            //
                            if((Err != NO_ERROR) && Queue->DriverSigningPolicy != DRIVERSIGN_NONE) {
                                Queue->Flags |= FQF_DIGSIG_ERRORS_NOUI;
                            }

                            //
                            // If this is the primary device INF, and the caller
                            // requested information about that INF's final
                            // pathname, then store that information in the caller-
                            // supplied buffer(s) now.
                            //
                            if(DeviceInfFinalName &&
                               (CatalogNode->Flags & CATINFO_FLAG_PRIMARY_DEVICE_INF)) {

                                lstrcpy(DeviceInfFinalName, PathBuffer);
                                if(DeviceInfNewlyCopied) {
                                    *DeviceInfNewlyCopied = FALSE;
                                }
                            }
                        }

                    } else if(CatalogNodeStatus == ERROR_SET_SYSTEM_RESTORE_POINT) {
                        //
                        // We should only get this error if the queue flag is
                        // set that causes us to abort unsigned installations.
                        //
                        MYASSERT(Queue->Flags & FQF_ABORT_IF_UNSIGNED);

                        //
                        // We don't want the user to see the driver signing
                        // UI again when the queue is re-committed...
                        //
                        if(Queue->DriverSigningPolicy != DRIVERSIGN_NONE) {
                            Queue->Flags |= FQF_DIGSIG_ERRORS_NOUI;
                        }

                        //
                        // Make sure that Err is also set to this same
                        // "special" error code...
                        //
                        Err = CatalogNodeStatus;
                    }

                    //
                    // If we had a real failure from _SetupCopyOEMInf (or we're
                    // out of memory and couldn't add a string to the string
                    // table above), then we need to propagate the value of
                    // CatalogNodeStatus to Err, if Err doesn't already have a
                    // failure code.
                    //
                    if((CatalogNodeStatus != NO_ERROR) && (Err == NO_ERROR)) {
                        Err = CatalogNodeStatus;
                    }
                }
            } else {
                //
                // We were told not to copy any files, but we've encountered an
                // OEM INF that needs to be installed. Hence, we have a failure.
                // Note that we _don't_ look to see if this OEM INF (and its
                // corresponding catalog) might happen to already be properly
                // installed.  That isn't necessary, because
                // _SetupDiInstallDevice calls _SetupVerifyQueuedCatalogs with
                // the VERCAT_INSTALL_INF_AND_CAT flag _before_ calling
                // SetupScanFileQueue, thus all INFs/CATs should be present when
                // we're called to do simple verification of the catalog nodes.
                //
                Err = CatalogNodeStatus = ERROR_CANNOT_COPY;
            }

        }

        if(InfVerifyType != VERIFY_INF_AS_OEM) {
            //
            // Inf is in system location (%windir%\Inf), or we're going to try
            // validating an "OEM" INF globally. Figure out the expected name
            // of the catalog file. If the file was originally copied in by the
            // Di stuff, then we need to use a name based on the name Di gave
            // the inf. Otherwise we use the name from the inf's CatalogFile=
            // entry, if present.  Finally, if the INF doesn't specify a
            // CatalogFile= entry, we assume it's a system component and
            // attempt to validate against any catalog that we find a hash
            // match in.
            //
            Err = NO_ERROR; // assume success

            if(CatalogNode->InfOriginalName != -1) {

                RequiredSize = SIZECHARS(InfNameBuffer);
                if(pSetupStringTableStringFromIdEx(Queue->StringTable,
                                             CatalogNode->InfOriginalName,
                                             InfNameBuffer,
                                             &RequiredSize)) {

                    OriginalNameDifferent = TRUE;
                } else {
                    //
                    // This should never fail!
                    //
                    MYASSERT(0);
                    Err = ERROR_INVALID_DATA;
                }

            } else {
                OriginalNameDifferent = FALSE;
            }

            if(Err == NO_ERROR) {

                if(CatName) {
                    //
                    // If there is a catalog name, then we'd better not be
                    // doing our "verify OEM INF globally" trick!
                    //
                    MYASSERT(InfVerifyType == VERIFY_INF_AS_SYSTEM);

                    if(OriginalNameDifferent) {
                        //
                        // If the INF specified a catalog file, then we know we
                        // would've installed that catalog file using a name based
                        // on the unique name we assigned the INF when copying it
                        // into the INF directory.
                        //
                        lstrcpy(CatalogName, pSetupGetFileTitle(InfFullPath));
                        p = _tcsrchr(CatalogName, TEXT('.'));
                        if(!p) {
                            p = CatalogName + lstrlen(CatalogName);
                        }
                        lstrcpy(p, pszCatSuffix);
                    } else {
                        lstrcpy(CatalogName, CatName);
                    }

                } else {
                    //
                    // This system INF didn't specify a CatalogFile= entry.  If
                    // an alternate catalog is associated with this file queue,
                    // then use that catalog for verification.
                    //
                    if(AltCatalogFile) {
                        lstrcpy(CatalogName, AltCatalogFile);
                        CatName = pSetupGetFileTitle(CatalogName);
                    }
                }

                //
                // (Note: in the call below, we don't want to store the
                // validating catalog filename in our CatalogFilenameOnSystem
                // field if the INF didn't specify a CatalogFile= entry (and
                // there was no alternate catalog specified), because we want
                // any queue nodes that reference this catalog entry to use
                // global validation as well.)
                //
                if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
                    //
                    // Don't attempt to call _VerifyFile, because we're
                    // asking for the validating catalog's name, and that makes
                    // no sense in the "minimal embedded" case.
                    //
                    *(CatalogNode->CatalogFilenameOnSystem) = TEXT('\0');

                    //
                    // (Err is already set to NO_ERROR.)
                    //

                } else {

                    if(!CatName) {
                        *(CatalogNode->CatalogFilenameOnSystem) = TEXT('\0');
                    }

                    Err = _VerifyFile(
                              Queue->LogContext,
                              &(Queue->hCatAdmin),
                              NULL,
                              (CatName ? CatalogName : NULL),
                              NULL,
                              0,
                              (OriginalNameDifferent ? InfNameBuffer : pSetupGetFileTitle(InfFullPath)),
                              InfFullPath,
                              &Problem,
                              PathBuffer,
                              FALSE,
                              ((Queue->Flags & FQF_USE_ALT_PLATFORM)
                                  ? &(Queue->AltPlatformInfo)
                                  : Queue->ValidationPlatform),
                              (VERIFY_FILE_IGNORE_SELFSIGNED
                               | VERIFY_FILE_USE_OEM_CATALOGS
                               | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                              (CatName ? CatalogNode->CatalogFilenameOnSystem : NULL),
                              NULL,
                              NULL,
                              NULL
                             );
                }
            }

            if(Err == NO_ERROR) {
                //
                // INF/CAT was successfully verified--store the INF's final path
                // (which is the same as its current path) into the catalog
                // node.
                //
                CatalogNode->InfFinalPath = CatalogNode->InfFullPath;

            } else {

                if(Problem != SetupapiVerifyCatalogProblem) {

                    MYASSERT(Problem != SetupapiVerifyNoProblem);
                    //
                    // If the problem was not a catalog problem, then it's an
                    // INF problem (the _VerifyFile routine doesn't know the
                    // file we passed it is an INF).
                    //
                    Problem = SetupapiVerifyInfProblem;
                }
                ProblemFile = PathBuffer;

                if((Flags & VERCAT_NO_PROMPT_ON_ERROR)
                   || (Queue->Flags & FQF_QUEUE_FORCE_BLOCK_POLICY)) {
                    //
                    // Don't notify the caller or log anything--just remember
                    // the error.
                    //
                    CatalogNodeStatus = Err;

                } else {
                    //
                    // Notify the caller of the failure (based on policy).
                    //
                    if(pSetupHandleFailedVerification(
                           Owner,
                           Problem,
                           ProblemFile,
                           ((Queue->DeviceDescStringId == -1)
                               ? NULL
                               : pStringTableStringFromId(Queue->StringTable, Queue->DeviceDescStringId)),
                           Queue->DriverSigningPolicy,
                           Queue->Flags & FQF_DIGSIG_ERRORS_NOUI,
                           Err,
                           Queue->LogContext,
                           NULL,
                           NULL))
                    {
                        //
                        // If the caller wants a chance to set a system restore
                        // point prior to doing any unsigned installations,
                        // then we abort now with a "special" error code that
                        // tells them what to do...
                        //
                        if(Queue->Flags & FQF_ABORT_IF_UNSIGNED) {
                            //
                            // We don't want the user to see the driver signing
                            // UI again when the queue is re-committed...
                            //
                            if(Queue->DriverSigningPolicy != DRIVERSIGN_NONE) {
                                Queue->Flags |= FQF_DIGSIG_ERRORS_NOUI;
                            }

                            CatalogNodeStatus = Err = ERROR_SET_SYSTEM_RESTORE_POINT;

                        } else {
                            //
                            // Set a flag in the queue that indicates the user has been
                            // informed of a signature problem with this queue, and has
                            // elected to go ahead and install anyway.  Don't set this
                            // flag if the queue's policy is "Ignore", on the chance
                            // that the policy might be altered later, and we'd want the
                            // user to get informed on any subsequent errors.
                            //
                            if(Queue->DriverSigningPolicy != DRIVERSIGN_NONE) {
                                Queue->Flags |= FQF_DIGSIG_ERRORS_NOUI;
                            }

                            //
                            // Since we're going to use the INF/CAT anyway, in spite of
                            // digital signature problems, then we need to set the INF's
                            // final path to be the same as its current path.
                            //
                            CatalogNode->InfFinalPath = CatalogNode->InfFullPath;
                        }

                    } else {
                        //
                        // The caller doesn't want to proceed.
                        //
                        CatalogNodeStatus = Err;
                    }
                }
            }

            if(CatalogNodeStatus == NO_ERROR) {
                //
                // If this is the primary device INF, and the caller requested
                // information about that INF's final pathname, then store that
                // information in the caller-supplied buffer(s) now.
                //
                if(DeviceInfFinalName &&
                   (CatalogNode->Flags & CATINFO_FLAG_PRIMARY_DEVICE_INF)) {

                    lstrcpy(DeviceInfFinalName, InfFullPath);
                    if(DeviceInfNewlyCopied) {
                        *DeviceInfNewlyCopied = FALSE;
                    }
                }
            }
        }

        if(Err == NO_ERROR) {
            //
            // If we successfully validated an "OEM" INF globally, then we want
            // to remember this fact.  This will allow us to generate a
            // signature verification failure against any file copy nodes
            // associated with this catalog node.
            //
            if(InfVerifyType == VERIFY_OEM_INF_GLOBALLY) {
                CatalogNode->VerificationFailureError = ERROR_NO_CATALOG_FOR_OEM_INF;
            } else {
                CatalogNode->VerificationFailureError = NO_ERROR;
            }

        } else {
            CatalogNode->VerificationFailureError = Err;
            CatalogNode->CatalogFilenameOnSystem[0] = TEXT('\0');
        }

        if((ReturnStatus == NO_ERROR) && (CatalogNodeStatus != NO_ERROR)) {
            //
            // First critical error we've encountered--propagate the failure
            // for this catalog to our return status that will be returned to
            // the caller once we've finished looking at all the catalogs.
            //
            ReturnStatus = CatalogNodeStatus;

            //
            // Unless the VERCAT_NO_PROMPT_ON_ERROR flag has been set, we
            // should abort right now--there's no since in going any further.
            //
            if(!(Flags & VERCAT_NO_PROMPT_ON_ERROR)) {
                break;
            }
        }
    }

    //
    // If the caller requested no prompting, then we don't want to mark this
    // queue as 'failed', since the user never heard about it.  However, if the
    // verification succeeded, then we _do_ want to mark it as successful.
    //
    if(Flags & VERCAT_NO_PROMPT_ON_ERROR) {

        if(ReturnStatus == NO_ERROR) {
            Queue->Flags |= FQF_DID_CATALOGS_OK;
        }

    } else {

        Queue->Flags |= (ReturnStatus == NO_ERROR) ? FQF_DID_CATALOGS_OK
                                                   : FQF_DID_CATALOGS_FAILED;
    }

    return ReturnStatus;
}

VOID
LogFailedVerification(
    IN PSETUP_LOG_CONTEXT LogContext,           OPTIONAL
    IN DWORD MessageId,
    IN DWORD Error,
    IN LPCTSTR ProblemFile,
    IN LPCTSTR DeviceDesc                       OPTIONAL
    )

/*++

Routine Description:

    This routine logs when a verification failed but the file was installed
    anyway.

Arguments:

    LogContext - optionally supplies a pointer to the context for logging.
        If this is not supplied, errors will be logged to the default context.

    MessageId - Message to display

    Error - supplies the code the the error that caused the failure.

    ProblemFile - supplies the file path to the file associated with
        the problem. In some cases this is a full path, in others it's just a
        filename. The caller decides which makes sense in a particular
        scenario. For example, a system catalog is in some funky directory
        and there is no need to tell the user the full path. But in the case
        where a catalog comes from an oem location, there might be some benefit
        to telling the user the full path.

    DeviceDesc - Optionally, supplies the device description to be used in the
        digital signature verification error dialogs that may be popped up.

Return Value:

    NONE.

--*/

{
    PSETUP_LOG_CONTEXT lc = NULL;

    MYASSERT(Error != NO_ERROR);
    MYASSERT(ProblemFile != NULL);

    if (!LogContext) {
        if (CreateLogContext(NULL, TRUE, &lc) == NO_ERROR) {
            //
            // success
            //
            LogContext = lc;
        } else {
            lc = NULL;
        }
    }

    //
    // a device install failed
    //
    WriteLogEntry(
        LogContext,
        SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
        MessageId,
        NULL,
        ProblemFile,
        DeviceDesc);

    WriteLogError(
        LogContext,
        SETUP_LOG_ERROR,
        Error);

    if (lc) {
        DeleteLogContext(lc);
    }
}

BOOL
pSetupHandleFailedVerification(
    IN HWND                  Owner,
    IN SetupapiVerifyProblem Problem,
    IN LPCTSTR               ProblemFile,
    IN LPCTSTR               DeviceDesc,          OPTIONAL
    IN DWORD                 DriverSigningPolicy,
    IN BOOL                  NoUI,
    IN DWORD                 Error,
    IN PVOID                 LogContext,          OPTIONAL
    OUT PDWORD               Flags,               OPTIONAL
    IN LPCTSTR               TargetFile           OPTIONAL
    )

/*++

Routine Description:

    This routine deals with a failed verification.

    System policy is checked. If the policy is block, UI is displayed telling
    the user that they're hosed. If the policy is ask-user, then ui is
    displayed requesting the user's decision about whether to ignore the
    verification failure and take the risk. If the policy is ignore, nothing
    is done.

Arguments:

    Owner - supplies window to own the dialog.

    Problem - supplies a constant indicating what caused the failure. There are
        5 cases:

        Catalog, meaning that the catalog could not be verified

        CatalogInstall, some other problem occured (e.g., INF directory write-
        protected, thus we couldn't install placeholder INF)

        Inf, meaning that an inf could not be verified or installed, etc.

        File, meaning that some random other file failed verification.

        DriverBlocked, meaning the driver was in the bad driver database.

    ProblemFile - supplies the file path to the file associated with
        the problem. In some cases this is a full path, in others it's just a
        filename. The caller decides which makes sense in a particular
        scenario. For example, a system catalog is in some funky directory
        and there is no need to tell the user the full path. But in the case
        where a catalog comes from an oem location, there might be some benefit
        to telling the user the full path.
        NOTE: if this API is being called because of a blocked driver then a
        full path should always be passed in.

    DeviceDesc - Optionally, supplies the device description to be used in the
        digital signature verification error dialogs that may be popped up.

    DriverSigningPolicy - supplies the driver signing policy currently in
        effect.  May be one of the three following values:

        DRIVERSIGN_NONE    -  silently succeed installation of unsigned/
                              incorrectly-signed files.  A PSS log entry will
                              be generated, however.
        DRIVERSIGN_WARNING -  warn the user, but let them choose whether or not
                              they still want to install the problematic file.
                              If the user elects to proceed with the
                              installation,  A PSS log entry will be generated
                              noting this fact.
        DRIVERSIGN_BLOCKING - do not allow the file to be installed

    NoUI - if TRUE, then a dialog box should not be displayed to the user, even
        if policy is warn or block.  This will typically be set to TRUE after
        the user has previously been informed of a digital signature problem
        with the package they're attempting to install, but have elected to
        proceed with the installation anyway.  The behavior of the "Yes" button,
        then, is really a "yes to all".

    Error - supplies the code of the error that caused the failure.

    LogContext - optionally supplies a pointer to the context for logging.
        If this is not supplied, errors will be logged to the default context.
        This is declared as a PVOID so external functions don't need to know
        what a SETUP_LOG_CONTEXT is.

    Flags - optionally supplies a pointer to a DWORD that receives one or more
        of the following file queue node flags indicating that we made an
        exemption for installing a protected system file:

        IQF_TARGET_PROTECTED - TargetFile (see below) is a protected system
                               file.
        IQF_ALLOW_UNSIGNED   - An exception has been granted so that TargetFile
                               (see below) may be replaced by an unsigned file.

    TargetFile - optionally supplies a pointer to a string that specifies a
       destination file if one exists.  This is only used if we want to exempt
       a file operation on this file.  If this parameter is not specified, then
       it is assumed the file will _not_ be replaced (i.e., it may already be
       on the system in its unsigned state), and no SFP exemption will be
       attempted.

Return Value:

    Boolean value indicating whether the caller should continue.
    If FALSE, then the current operation should be aborted, as the combination
    of system policy and user input indicated that the risk should not
    be taken.

--*/

{
    BOOL b;
    INT_PTR iRes;
    CERT_PROMPT CertPrompt;
    HANDLE hDialogEvent = NULL;

    //
    // If we're running non-interactive, then we always silently block,
    // regardless of policy.
    //
    if(GlobalSetupFlags & PSPGF_NONINTERACTIVE) {
        //
        // SPLOG -- log a PSS entry recording this event.
        //
        if (Problem == SetupapiVerifyDriverBlocked) {
            LogFailedVerification(
                (PSETUP_LOG_CONTEXT) LogContext,
                DeviceDesc ? MSG_LOG_DRIVER_BLOCKED_FOR_DEVICE_ERROR_NONINTERACTIVE : MSG_LOG_DRIVER_BLOCKED_ERROR_NONINTERACTIVE,
                Error,
                ProblemFile,
                DeviceDesc);
        } else {
            LogFailedVerification(
                (PSETUP_LOG_CONTEXT) LogContext,
                DeviceDesc ? MSG_LOG_DRIVER_SIGNING_ERROR_NONINTERACTIVE : MSG_LOG_SIGNING_ERROR_NONINTERACTIVE,
                Error,
                ProblemFile,
                DeviceDesc);
        }

        return FALSE;
    }

    if (GuiSetupInProgress) {
        hDialogEvent = CreateEvent(NULL,TRUE,FALSE,SETUP_HAS_OPEN_DIALOG_EVENT);
    }

#ifdef UNICODE
    if (Problem == SetupapiVerifyDriverBlocked) {
        //
        // Handle a driver block failure.
        // only applicable to UNICODE
        // ANSI won't report this problem code
        //
        HSDB hSDBDrvMain = NULL;
        TAGREF tagref = TAGREF_NULL;
        DRIVERBLOCK_PROMPT DriverBlockPrompt = {0};

        //
        // Never continue if the driver is in the bad driver database!
        //
        b = FALSE;

        LogFailedVerification(
            (PSETUP_LOG_CONTEXT) LogContext,
            DeviceDesc ? MSG_LOG_DRIVER_BLOCKED_FOR_DEVICE_ERROR : MSG_LOG_DRIVER_BLOCKED_ERROR,
            Error,
            ProblemFile,
            DeviceDesc);

        if (!(GlobalSetupFlags & PSPGF_UNATTENDED_SETUP)) {
            //
            // Show the driver blocking UI
            //
            DriverBlockPrompt.lpszFile = (TargetFile != NULL)
                                         ? TargetFile
                                         : ProblemFile;

            if ((hSDBDrvMain = SdbInitDatabase(SDB_DATABASE_MAIN_DRIVERS, NULL))) {
                HANDLE hFile = INVALID_HANDLE_VALUE;

                //
                // We are probably dealing with a temp file name at this point,
                // so we need to get a file handle to pass to SdbGetDatabaseMatch
                // along with the final destination file name.
                //
                hFile = CreateFile(ProblemFile,
                                   GENERIC_READ,
                                   FILE_SHARE_READ,
                                   NULL,
                                   OPEN_EXISTING,
                                   0,
                                   NULL
                                  );
                if (hFile != INVALID_HANDLE_VALUE) {
                    //
                    // Pass the TargetFile (the destination filename) to
                    // SdbGetDatabaseMatch because that will be what is
                    // in the bad driver database.
                    //
                    tagref = SdbGetDatabaseMatch(hSDBDrvMain,
                                                 (TargetFile != NULL)
                                                   ? pSetupGetFileTitle(TargetFile)
                                                   : ProblemFile,
                                                 hFile,
                                                 NULL,
                                                 0);

                    if (tagref != TAGREF_NULL) {
                        SdbReadDriverInformation(hSDBDrvMain,
                                                 tagref,
                                                 &(DriverBlockPrompt.entryinfo));
                    }

                    CloseHandle(hFile);
                }

                SdbReleaseDatabase(hSDBDrvMain);
            }

            //
            // Always call the dialog code, even if we could access the database.
            //
            iRes =  DialogBoxParam(MyDllModuleHandle,
                                   MAKEINTRESOURCE(IDD_DRIVERBLOCK),
                                   IsWindow(Owner) ? Owner : NULL,
                                   DriverBlockDlgProc,
                                   (LPARAM)&DriverBlockPrompt
                                   );
        }
    } else
#endif
    {
        //
        // Handle a digital signature failure.
        //
        // If the policy is block, then the user always gets informed of a problem
        // (i.e., there is no "yes" option, hence no "yes to all" semantics).
        //
        MYASSERT((DriverSigningPolicy != DRIVERSIGN_BLOCKING) || !NoUI);

        CertPrompt.lpszDescription = DeviceDesc;
        CertPrompt.lpszFile = ProblemFile;
        CertPrompt.ProblemType = Problem;
        CertPrompt.DriverSigningPolicy = DriverSigningPolicy;

        switch(DriverSigningPolicy) {

            case DRIVERSIGN_NONE :

                //
                // SPLOG -- log a PSS entry recording this event.
                //
                LogFailedVerification(
                    (PSETUP_LOG_CONTEXT) LogContext,
                    DeviceDesc ? MSG_LOG_DRIVER_SIGNING_ERROR_POLICY_NONE : MSG_LOG_SIGNING_ERROR_POLICY_NONE,
                    Error,
                    ProblemFile,
                    DeviceDesc);
                //
                // If requested, find out if the file is protected (we may need to
                // skip it if it's being queued up for delayed copy).
                //
                if(Flags && TargetFile) {

                    if(IsFileProtected(TargetFile,
                                       (PSETUP_LOG_CONTEXT)LogContext,
                                       NULL)) {

                        *Flags = IQF_TARGET_PROTECTED;
                    }
                }

                b = TRUE;
                goto exit;

            case DRIVERSIGN_WARNING :
                if(NoUI) {
                    //
                    // SPLOG -- log a PSS entry recording this event.
                    //
                    LogFailedVerification(
                        (PSETUP_LOG_CONTEXT) LogContext,
                        DeviceDesc ? MSG_LOG_DRIVER_SIGNING_ERROR_AUTO_YES : MSG_LOG_SIGNING_ERROR_AUTO_YES,
                        Error,
                        ProblemFile,
                        DeviceDesc);
                    iRes = IDC_VERIFY_WARN_YES;
                } else if(GlobalSetupFlags & PSPGF_UNATTENDED_SETUP) {
                    //
                    // SPLOG -- log a PSS entry recording this event.
                    //
                    LogFailedVerification(
                        (PSETUP_LOG_CONTEXT) LogContext,
                        DeviceDesc ? MSG_LOG_DRIVER_SIGNING_ERROR_AUTO_NO : MSG_LOG_SIGNING_ERROR_AUTO_NO,
                        Error,
                        ProblemFile,
                        DeviceDesc);
                    iRes = IDC_VERIFY_WARN_NO;
                } else {
                    if (hDialogEvent) {
                       SetEvent(hDialogEvent);
                    }
                    iRes =  DialogBoxParam(MyDllModuleHandle,
                                           CertPrompt.lpszDescription ?
                                               MAKEINTRESOURCE(IDD_DEVICE_VERIFY_WARNING) :
                                               MAKEINTRESOURCE(IDD_SOFTWARE_VERIFY_WARNING),
                                           IsWindow(Owner) ? Owner : NULL,
                                           CertifyDlgProc,
                                           (LPARAM)&CertPrompt
                                          );
                    LogFailedVerification(
                        (PSETUP_LOG_CONTEXT) LogContext,
                        DeviceDesc
                            ?(iRes == IDC_VERIFY_WARN_YES ? MSG_LOG_DRIVER_SIGNING_ERROR_WARN_YES : MSG_LOG_DRIVER_SIGNING_ERROR_WARN_NO)
                            :(iRes == IDC_VERIFY_WARN_YES ? MSG_LOG_SIGNING_ERROR_WARN_YES : MSG_LOG_SIGNING_ERROR_WARN_NO),
                        Error,
                        ProblemFile,
                        DeviceDesc);
                }
                break;

        case DRIVERSIGN_BLOCKING :

                if(GlobalSetupFlags & PSPGF_UNATTENDED_SETUP) {
                    //
                    // During UNATTENDED, we block silently
                    //
                    LogFailedVerification(
                        (PSETUP_LOG_CONTEXT) LogContext,
                        DeviceDesc ? MSG_LOG_DRIVER_SIGNING_ERROR_SILENT_BLOCK : MSG_LOG_SIGNING_ERROR_SILENT_BLOCK,
                        Error,
                        ProblemFile,
                        DeviceDesc);
                    iRes = IDC_VERIFY_BLOCK_OK;
                } else {
                    LogFailedVerification(
                        (PSETUP_LOG_CONTEXT) LogContext,
                        DeviceDesc ? MSG_LOG_DRIVER_SIGNING_ERROR_POLICY_BLOCK : MSG_LOG_SIGNING_ERROR_POLICY_BLOCK,
                        Error,
                        ProblemFile,
                        DeviceDesc);

                    if (hDialogEvent) {
                        SetEvent(hDialogEvent);
                    }
                    iRes =  DialogBoxParam(MyDllModuleHandle,
                                           CertPrompt.lpszDescription ?
                                               MAKEINTRESOURCE(IDD_DEVICE_VERIFY_BLOCK) :
                                               MAKEINTRESOURCE(IDD_SOFTWARE_VERIFY_BLOCK),
                                           IsWindow(Owner) ? Owner : NULL,
                                           CertifyDlgProc,
                                           (LPARAM)&CertPrompt
                                          );
                }
                break;

            default :
                //
                // We don't know about any other policy values!
                //
                MYASSERT(0);
                b = FALSE;
                goto exit;
        }

        switch(iRes) {

            case IDC_VERIFY_WARN_NO:
            case IDC_VERIFY_BLOCK_OK:
                b = FALSE;
                break;

            case IDC_VERIFY_WARN_YES:
                if(TargetFile) {
                    pSetupExemptFileFromProtection(TargetFile,
                                                   (DWORD) -1,
                                                   (PSETUP_LOG_CONTEXT)LogContext,
                                                   Flags
                                                  );
                }

                b = TRUE;
                break;

            default:
                //
                // Shouldn't get any other values.
                //
                MYASSERT(0);
                b = FALSE;
        }
    }

exit:
    if (hDialogEvent) {
        ResetEvent(hDialogEvent);
        CloseHandle(hDialogEvent);
    }


    return b;
}


INT_PTR
CALLBACK
CertifyDlgProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    This is the dialog procedure for the driver signing UI that is presented to
    the user when a verification failure is encountered.  This dialog handles
    both the 'warn' and 'block' cases.

--*/

{
    UINT MessageLen;
    LOGFONT LogFont;
    HFONT hFontBold = NULL;
    HICON hIcon = NULL;

    PCERT_PROMPT lpCertPrompt;

    lpCertPrompt = (PCERT_PROMPT)GetWindowLongPtr(hwnd, DWLP_USER);

    switch(msg) {

        case WM_INITDIALOG:
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);
            MessageBeep(MB_ICONASTERISK);
            lpCertPrompt = (PCERT_PROMPT)lParam;

            //
            // If lpszDescription is not NULL then this is the device verify
            // warning dialog, otherwise it is the software warning dialog.
            //
            if(lpCertPrompt->lpszDescription != NULL) {
                SetDlgItemText(hwnd, IDC_VERIFY_FILENAME, lpCertPrompt->lpszDescription);
                SetDlgText(hwnd, IDC_VERIFY_BOLD, IDS_DEVICE_VERIFY_MSG1, IDS_DEVICE_VERIFY_MSG2);
            } else {
                SetDlgText(hwnd, IDC_VERIFY_BOLD, IDS_SOFTWARE_VERIFY_MSG1, IDS_SOFTWARE_VERIFY_MSG2);
            }

            //
            // Create the bold font and bold any necessary text.
            //
            hFontBold = (HFONT)SendMessage(GetDlgItem(hwnd, IDC_VERIFY_BOLD),
                                           WM_GETFONT, 0, 0);
            GetObject(hFontBold, sizeof(LogFont), &LogFont);
            LogFont.lfWeight = FW_BOLD;
            hFontBold = CreateFontIndirect(&LogFont);
            if (hFontBold) {
                SetWindowFont(GetDlgItem(hwnd, IDC_VERIFY_BOLD), hFontBold, TRUE);
            }

            //
            // Set the appropriate warning or error icon.
            //
            hIcon = LoadIcon(NULL,
                            (lpCertPrompt->DriverSigningPolicy == DRIVERSIGN_WARNING) ?
                                IDI_WARNING :
                                IDI_ERROR
                            );
            SendDlgItemMessage(hwnd, IDC_VERIFY_ICON, STM_SETICON, (WPARAM)hIcon, 0L);

            //
            // The link won't work in GUI mode setup since help center has not yet
            // been installed, so we will just show the static text instead.
            //
            ShowWindow(GetDlgItem(hwnd, IDC_VERIFY_TESTING_LINK), !GuiSetupInProgress);
            ShowWindow(GetDlgItem(hwnd, IDC_VERIFY_TESTING_TEXT), GuiSetupInProgress);

            //
            // If we are in GUI mode setup then we want to change the text of
            // the buttons to be "Yes" and "No".  We also add the following line
            // of text: "Do you want to continue installing the software for
            // this hardware?"
            //
            ShowWindow(GetDlgItem(hwnd, IDC_VERIFY_SETUP_TEXT), GuiSetupInProgress);

            if (GuiSetupInProgress) {
                TCHAR szButtonText[MAX_PATH];

                if (LoadString(MyDllModuleHandle, IDS_YES, szButtonText, SIZECHARS(szButtonText))) {
                    SetDlgItemText(hwnd, IDC_VERIFY_WARN_YES, szButtonText);
                }

                if (LoadString(MyDllModuleHandle, IDS_NO, szButtonText, SIZECHARS(szButtonText))) {
                    SetDlgItemText(hwnd, IDC_VERIFY_WARN_NO, szButtonText);
                }
            }

            //
            // Make sure this dialog is in the foreground (at least for this
            // process).
            //
            SetForegroundWindow(hwnd);

            if (lpCertPrompt->DriverSigningPolicy == DRIVERSIGN_WARNING) {
                SetFocus(GetDlgItem(hwnd, IDC_VERIFY_WARN_NO));
            }

            return FALSE;

        case WM_DESTROY:
            if (hFontBold) {
                DeleteObject(hFontBold);
                hFontBold = NULL;
            }

            if (hIcon) {
                DestroyIcon(hIcon);
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *)lParam)->code) {
            case NM_RETURN:
            case NM_CLICK:
                ShellExecute(hwnd,
                             TEXT("open"),
                             TEXT("HELPCTR.EXE"),
                             TEXT("HELPCTR.EXE -url hcp://services/subsite?node=TopLevelBucket_4/Hardware&topic=MS-ITS%3A%25HELP_LOCATION%25%5Csysdm.chm%3A%3A/logo_testing.htm"),
                             NULL,
                             SW_SHOWNORMAL
                             );
                break;
            }
            break;

        case WM_COMMAND:
            switch(wParam) {

                case IDC_VERIFY_WARN_NO:
                case IDC_VERIFY_WARN_YES:
                case IDC_VERIFY_BLOCK_OK:
                    EndDialog(hwnd, (int)wParam);
                    break;

                default:
                    break;
            }

            break;

        default:
            break;
    }

    return FALSE;
}

#ifdef UNICODE
INT_PTR
CALLBACK
DriverBlockDlgProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    This is the dialog procedure for the driver blocking UI that is presented to
    the user when a a driver that is about to be installed is found in the bad
    driver database.

--*/

{
    UINT MessageLen;
    HICON hIcon = NULL;
    LPTSTR pBuffer = NULL;
    ULONG BufferSize;
    static HAPPHELPINFOCONTEXT hAppHelpInfoContext = NULL;
    static SDBENTRYINFO SdbEntryInfo;

    PDRIVERBLOCK_PROMPT lpDriverBlockPrompt;

    lpDriverBlockPrompt = (PDRIVERBLOCK_PROMPT)GetWindowLongPtr(hwnd, DWLP_USER);

    switch(msg) {

        case WM_INITDIALOG:
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);
            MessageBeep(MB_ICONASTERISK);
            lpDriverBlockPrompt = (PDRIVERBLOCK_PROMPT)lParam;

            hIcon = LoadIcon(MyDllModuleHandle,
                             MAKEINTRESOURCE(IDI_DRIVERBLOCK));

            SendDlgItemMessage(hwnd, IDC_DRIVERBLOCK_ICON, STM_SETICON, (WPARAM)hIcon, 0L);

            hAppHelpInfoContext = SdbOpenApphelpInformation(&lpDriverBlockPrompt->entryinfo.guidDB,
                                                            &lpDriverBlockPrompt->entryinfo.guidID);

            if ((hAppHelpInfoContext) &&
                ((BufferSize = SdbQueryApphelpInformation(hAppHelpInfoContext,
                                                         ApphelpAppName,
                                                         NULL,
                                                         0)) != 0) &&
                (pBuffer = MyMalloc(BufferSize)) &&
                ((BufferSize = SdbQueryApphelpInformation(hAppHelpInfoContext,
                                                         ApphelpAppName,
                                                         pBuffer,
                                                         BufferSize)) != 0)) {
                SetDlgItemText(hwnd, IDC_DRIVERBLOCK_APPNAME, pBuffer);
                MyFree(pBuffer);
            } else if (lpDriverBlockPrompt->lpszFile) {
                SetDlgItemText(hwnd, IDC_DRIVERBLOCK_APPNAME, pSetupGetFileTitle(lpDriverBlockPrompt->lpszFile));
            }

            if ((hAppHelpInfoContext) &&
                ((BufferSize = SdbQueryApphelpInformation(hAppHelpInfoContext,
                                                         ApphelpDetails,
                                                         NULL,
                                                         0)) != 0) &&
                (pBuffer = MyMalloc(BufferSize)) &&
                ((BufferSize = SdbQueryApphelpInformation(hAppHelpInfoContext,
                                                         ApphelpDetails,
                                                         pBuffer,
                                                         BufferSize)) != 0)) {

                SetDlgItemText(hwnd, IDC_DRIVERBLOCK_SUMMARY, pBuffer);
                MyFree(pBuffer);
            }

            //
            // Make sure this dialog is in the foreground (at least for this
            // process).
            //
            SetForegroundWindow(hwnd);
            return FALSE;

        case WM_DESTROY:
            if (hIcon) {
                DestroyIcon(hIcon);
            }
            if (hAppHelpInfoContext) {
                SdbCloseApphelpInformation(hAppHelpInfoContext);
            }
            break;

        case WM_COMMAND:
            switch(LOWORD(wParam)) {
            case IDCANCEL:
                EndDialog(hwnd, (int)wParam);
                break;

            case IDC_DRIVERBLOCK_DETAILS:
                if (hAppHelpInfoContext) {

                    BufferSize = SdbQueryApphelpInformation(hAppHelpInfoContext,
                                                                  ApphelpHelpCenterURL,
                                                                  NULL,
                                                                  0);

                    if (BufferSize && (pBuffer = MyMalloc(BufferSize + (lstrlen(TEXT("HELPCTR.EXE -url ")) * sizeof(TCHAR))))) {
                        lstrcpy(pBuffer, TEXT("HELPCTR.EXE -url "));

                        BufferSize = SdbQueryApphelpInformation(hAppHelpInfoContext,
                                                                ApphelpHelpCenterURL,
                                                                (PVOID)&pBuffer[lstrlen(TEXT("HELPCTR.EXE -url "))],
                                                                BufferSize);

                        if (BufferSize) {
                            ShellExecute(hwnd,
                                         TEXT("open"),
                                         TEXT("HELPCTR.EXE"),
                                         pBuffer,
                                         NULL,
                                         SW_SHOWNORMAL);
                        }

                        MyFree(pBuffer);
                    }
                }
                break;

            default:
                break;
            }

            break;

        default:
            break;
    }

    return FALSE;
}
#endif


DWORD
pGetInfOriginalNameAndCatalogFile(
    IN  PLOADED_INF             Inf,                     OPTIONAL
    IN  LPCTSTR                 CurrentName,             OPTIONAL
    OUT PBOOL                   DifferentName,           OPTIONAL
    OUT LPTSTR                  OriginalName,            OPTIONAL
    IN  DWORD                   OriginalNameSize,
    OUT LPTSTR                  OriginalCatalogName,     OPTIONAL
    IN  DWORD                   OriginalCatalogNameSize,
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo          OPTIONAL
    )

/*++

Routine Description:

    This routine determines whether a specified inf once had a different
    original name, such as in the case where the Di stuff copied and renamed a
    device inf.

    (Information about an INF's original name comes from the PNF.)

    This routine can also optionally return the original name of the catalog
    file for this INF.

Arguments:

    Inf - optionally, supplies a pointer to a LOADED_INF whose original name
        and catalog file are to be queried.  If this parameter isn't specified,
        then CurrentName must be specified.

    CurrentName - optionally, supplies the path to the INF whose original name
        is to be queried.  If Inf parameter is specified, this parameter is
        ignored.

    DifferentName - optionally, supplies the address of a boolean variable that,
        upon successful return, is set to TRUE if the INF's current name is
        different than its original name.

    OriginalName - if this routine returns successfully, and the DifferentName
        boolean was set to TRUE, then this optional buffer receives
        the INF's original name, which _will not_ be the same as the current
        name.

    OriginalNameSize - supplies size of buffer (bytes for ansi, chars for
        unicode) of OriginalName buffer, or zero if OriginalName is NULL.

    OriginalCatalogName - optionally, supplies a buffer that receives the
        original name of the catalog specified by this INF.  If the catalog
        doesn't specify a catalog file, this buffer will be set to an empty
        string.

    OriginalCatalogNameSize - supplies size, in characters, of
        OriginalCatalogName buffer (zero if buffer not supplied).

    AltPlatformInfo - optionally, supplies the address of a structure describing
        the platform parameters that should be used in formulating the decorated
        CatalogFile= entry to be used when searching for the INF's associated
        catalog file.

Return Value:

    If information is successfully retrieved from the INF, the return value is
    NO_ERROR.  Otherwise, it is a Win32 error code indicating the cause of
    failure.

--*/

{
    DWORD d;
    HINF hInf = INVALID_HANDLE_VALUE;

    MYASSERT((DifferentName && OriginalName && OriginalNameSize) ||
             !(DifferentName || OriginalName || OriginalNameSize));

    MYASSERT((OriginalCatalogName && OriginalCatalogNameSize) ||
             !(OriginalCatalogName || OriginalCatalogNameSize));

    MYASSERT(Inf || CurrentName);

    if(DifferentName) {
        *DifferentName = FALSE;
    }

    if(!Inf) {
        //
        // Open the INF.
        //
        hInf = SetupOpenInfFile(CurrentName,
                                NULL,
                                INF_STYLE_OLDNT | INF_STYLE_WIN4,
                                NULL
                               );

        if(hInf == INVALID_HANDLE_VALUE) {
            return GetLastError();
        }

        //
        // We don't need to lock the INF because it'll never be accessible
        // outside of this routine.
        //
        Inf = (PLOADED_INF)hInf;
    }

    //
    // Enclose in try/except in case we hit an inpage error while using this
    // memory-mapped image.
    //
    d = NO_ERROR;
    try {

        if(DifferentName) {
            if(Inf->OriginalInfName) {
                lstrcpyn(OriginalName, Inf->OriginalInfName, OriginalNameSize);
                *DifferentName = TRUE;
            }
        }

        if(OriginalCatalogName) {

            if(!pSetupGetCatalogFileValue(&(Inf->VersionBlock),
                                          OriginalCatalogName,
                                          OriginalCatalogNameSize,
                                          AltPlatformInfo)) {
                //
                // The INF didn't specify an associated catalog file
                //
                *OriginalCatalogName = TEXT('\0');
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // If we hit an AV, then use invalid parameter error, otherwise, assume
        // an inpage error when dealing with a mapped-in file.
        //
        d = (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) ? ERROR_INVALID_PARAMETER : ERROR_READ_FAULT;
    }

    if(hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }

    return d;
}


#ifdef UNICODE

PSECURITY_DESCRIPTOR
pSetupConvertTextToSD(
    IN PCWSTR SDS,
    OUT PULONG SecDescSize
    )
/*++

Routine Description:

    Helper for cfgmgr.lib

    Obtains a binary security descriptor from an SDS
    Resulting buffer must be free'd using LocalFree (not MyFree)
    returns NULL if not supported and sets last error

Arguments:

    SDS - string to obtain security descriptor from

    SecDescSize - filled in with size of security descriptor

Return Value:

    returns security descriptor (use LocalFree to release)
    or NULL with GetLastError indicating error

--*/
{
    SCESTATUS status;
    PSECURITY_DESCRIPTOR pSD = NULL;
    ULONG ulSDSize;
    SECURITY_INFORMATION siSeInfo;

    //
    // If we're in "Disable SCE" mode on embedded, don't do security stuff...
    //
    if(GlobalSetupFlags & PSPGF_NO_SCE_EMBEDDED) {
        SetLastError(ERROR_SCE_DISABLED);
        return NULL;
    }

    try {
        status = SceSvcConvertTextToSD((PWSTR)SDS,&pSD,&ulSDSize,&siSeInfo);
        switch (status ) {
            case SCESTATUS_SUCCESS:
                MYASSERT(pSD);
                MYASSERT(ulSDSize);
                if (SecDescSize) {
                    *SecDescSize = ulSDSize;
                }
                SetLastError(NO_ERROR);
                break;

            case SCESTATUS_INVALID_PARAMETER:
                SetLastError(ERROR_INVALID_PARAMETER);
                pSD = NULL;
                break;

            case SCESTATUS_NOT_ENOUGH_RESOURCE:
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                pSD = NULL;
                break;

            case SCESTATUS_RECORD_NOT_FOUND:
            default:
                SetLastError(ERROR_INVALID_DATA);
                pSD = NULL;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // If we hit an AV, then use invalid parameter error, otherwise, assume
        // an inpage error when dealing with a mapped-in file.
        //
        SetLastError(ERROR_INVALID_DATA);
        pSD = NULL;
    }
    return pSD;
}

PWSTR
pSetupConvertSDToText(
    IN PSECURITY_DESCRIPTOR SD,
    OUT PULONG pSDSSize
    )
/*++

Routine Description:

    Helper for cfgmgr.lib

    Obtains an SDS from a binary security descriptor
    Resulting buffer must be free'd using LocalFree (not MyFree)
    returns NULL if not supported and sets last error

Arguments:

    SD - security descriptor to convert to a string

    pSDSSize - return size of string

Return Value:

    returns security descriptor string (use LocalFree to release)
    or NULL with GetLastError indicating error

--*/
{
    HINSTANCE Dll_Handle;
    FARPROC SceFileProc;
    SCESTATUS status;
    DWORD LoadStatus;
    SECURITY_INFORMATION securityInformation = 0;
    PSID sid;
    PACL acl;
    BOOLEAN tmp,present;
    LPWSTR SDS = NULL;
    ULONG ulSSDSize;
    SECURITY_INFORMATION siSeInfo;

    //
    // If we're in "Disable SCE" mode on embedded, don't do security stuff...
    //
    if(GlobalSetupFlags & PSPGF_NO_SCE_EMBEDDED) {
        //
        // Report an empty string
        //
        return LocalAlloc(LPTR, sizeof(WCHAR)); // LPTR zeroes out the char
    }

    try {
        //
        // find out what relevent information is in the descriptor
        // up a securityInformation block to go with it.
        //

        status = RtlGetOwnerSecurityDescriptor(SD, &sid, &tmp);

        if(NT_SUCCESS(status) && (sid != NULL)) {
            securityInformation |= OWNER_SECURITY_INFORMATION;
        }

        status = RtlGetGroupSecurityDescriptor(SD, &sid, &tmp);

        if(NT_SUCCESS(status) && (sid != NULL)) {
            securityInformation |= GROUP_SECURITY_INFORMATION;
        }

        status = RtlGetSaclSecurityDescriptor(SD,
                                              &present,
                                              &acl,
                                              &tmp);

        if(NT_SUCCESS(status) && (present)) {
            securityInformation |= SACL_SECURITY_INFORMATION;
        }

        status = RtlGetDaclSecurityDescriptor(SD,
                                              &present,
                                              &acl,
                                              &tmp);

        if(NT_SUCCESS(status) && (present)) {
            securityInformation |= DACL_SECURITY_INFORMATION;
        }

        //
        // now obtain an SDS
        //
        status = SceSvcConvertSDToText(SD,securityInformation,&SDS,&ulSSDSize);
        switch (status ) {
            case SCESTATUS_SUCCESS:
                MYASSERT(SDS);
                MYASSERT(ulSSDSize);
                if(pSDSSize != NULL) {
                    *pSDSSize = ulSSDSize;
                }
                SetLastError(NO_ERROR);
                break;

            case SCESTATUS_INVALID_PARAMETER:
                SetLastError(ERROR_INVALID_PARAMETER);
                SDS = NULL;
                break;

            case SCESTATUS_NOT_ENOUGH_RESOURCE:
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                SDS = NULL;
                break;

            case SCESTATUS_RECORD_NOT_FOUND:
            default:
                SetLastError(ERROR_INVALID_DATA);
                SDS = NULL;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        if (SDS) {
            LocalFree(SDS);
        }
        SetLastError(ERROR_INVALID_DATA);
        SDS = NULL;
    }
    return SDS;
}

DWORD
pSetupCallSCE(
    IN DWORD Operation,
    IN PCWSTR FullName,
    IN PSP_FILE_QUEUE Queue,
    IN PCWSTR String1,
    IN DWORD Index1,
    IN PSECURITY_DESCRIPTOR SecDesc  OPTIONAL
    )
/*

    Operation ST_SCE_SET : - Sets security on a File in File Queue and informs SCE database
    FullName : - Filename (Needed)
    Queue    : - Pointer to FileQueue (Needed)
    Index    : - Index in String Table of Queue (Needed)

    Operation ST_SCE_RENAME : - Sets security on a File in File Queue and informs SCE database to
                                record it for the filename mentioned in String1
    FullName : - Filename (Needed)
    Queue    : - Pointer to FileQueue (Needed)
    String1  ; - Filename to record in Database (Needed)
    Index    : - Index in String Table of Queue (Optional - only if it needs to be set otherwise -1)

    Operation ST_SCE_DELETE : - Removes record of file in SCE database
    FullName : - Filename (Needed)

    Operation ST_SCE_UNWIND : - Used for Backup Unwinds when we reset the security on a dirty file
    FullName : - Filename (Needed)
    SecDesc  : - Pointer to Security Descriptor for the original file that we unwind (Needed)

    Operation ST_SCE_SERVICES : - Sets security on a Service and informs SCE database
    FullName : - Service Name (Needed)
    Index    : - Service Style (Needed)
    String1  ; - Security Descriptor string

    Operation ST_SCE_SDS_TO_BIN : - Sets security on a Service and informs SCE database
    FullName : - Service Name (Needed)
    Index    : - Service Style (Needed)
    String1  ; - Security Descriptor string

    In each case, return value is error or NO_ERROR
*/
{

    FARPROC SceFileProc;
    PCWSTR SecurityDescriptor;
    HINSTANCE Dll_Handle;
    DWORD ret, LoadStatus;

    //
    // If we're in "Disable SCE" mode on embedded, don't do security stuff...
    //
    if(GlobalSetupFlags & PSPGF_NO_SCE_EMBEDDED) {
        return NO_ERROR;
    }

    try {
        switch (Operation) {

            case ST_SCE_SET:

                //Get the Security descriptor from the String table of the node

                if( Index1 != -1 ){
                    SecurityDescriptor = pSetupStringTableStringFromId( Queue->StringTable, Index1 );

                    if(!SecurityDescriptor) {
                        ret= NO_ERROR;
                        break;
                    }
                }
                else {
                    ret = NO_ERROR;
                    break;
                }


                ret = SceSetupUpdateSecurityFile((PWSTR)FullName, 0, (PWSTR)SecurityDescriptor );
                break;

            case ST_SCE_RENAME:

                if( Index1 != -1 ) {
                    SecurityDescriptor = pSetupStringTableStringFromId( Queue->StringTable, Index1 );
                } else {
                    SecurityDescriptor = NULL;
                }

                ret = SceSetupMoveSecurityFile( (PWSTR)FullName, (PWSTR)String1, (PWSTR)SecurityDescriptor );
                break;



            case ST_SCE_DELETE:

                ret = SceSetupMoveSecurityFile( (PWSTR)FullName, NULL, NULL );
                break;


            case ST_SCE_UNWIND:

                ret = SceSetupUnwindSecurityFile( (PWSTR)FullName, SecDesc );
                break;

            case ST_SCE_SERVICES:

               if( String1 == NULL ){
                   ret = NO_ERROR;
               } else {
                   ret = SceSetupUpdateSecurityService( (PWSTR)FullName, Index1, (PWSTR)String1 );
               }
               break;

            default:
                MYASSERT(0);
                ret = ERROR_INVALID_DATA;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        ret = ERROR_INVALID_DATA;
    }
    return ret;
}

#endif  // UNICODE


VOID
RestoreBootReplacedFile(
    IN PSP_FILE_QUEUE      Queue,
    IN PSP_FILE_QUEUE_NODE QueueNode
    )
/*++

Routine Description:

    This routine restores a file that was renamed in preparation for a bootfile
    installation.

Arguments:

    Queue - queue that contains the bootfile copy operation

    QueueNode - bootfile copy operation being aborted

Return Value:

    None.

--*/
{
    DWORD rc;
    LONG TargetID;
    SP_TARGET_ENT TargetInfo;
    PCTSTR TargetFilename, RenamedFilename;
    BOOL UnPostSucceeded;

    //
    // First, we need to find the corresponding target info node so
    // we can find out what temporary name our file was renamed to.
    //
    rc = pSetupBackupGetTargetByPath((HSPFILEQ)Queue,
                                     NULL, // use Queue's string table
                                     NULL,
                                     QueueNode->TargetDirectory,
                                     -1,
                                     QueueNode->TargetFilename,
                                     &TargetID,
                                     &TargetInfo
                                    );

    if(rc == NO_ERROR) {
        //
        // Has the file previously been renamed (and not yet
        // restored)?
        //
        if((TargetInfo.InternalFlags & (SP_TEFLG_MOVED | SP_TEFLG_RESTORED)) == SP_TEFLG_MOVED) {

            TargetFilename = pSetupFormFullPath(
                                Queue->StringTable,
                                TargetInfo.TargetRoot,
                                TargetInfo.TargetSubDir,
                                TargetInfo.TargetFilename
                               );
            MYASSERT(TargetFilename);

            RenamedFilename = pSetupStringTableStringFromId(
                                Queue->StringTable,
                                TargetInfo.NewTargetFilename
                               );
            MYASSERT(RenamedFilename);

            //
            // Move the renamed file back to its original name.
            //
            RestoreRenamedOrBackedUpFile(TargetFilename,
                                         RenamedFilename,
                                         TRUE,
                                         Queue->LogContext
                                        );
            //
            // Set the flag indicating that this file has been
            // restored, and save this info.
            //
            TargetInfo.InternalFlags |= SP_TEFLG_RESTORED;
            pSetupBackupSetTargetByID((HSPFILEQ)Queue, TargetID, &TargetInfo);

            //
            // Finally, get rid of the delayed-move node that was to
            // delete the renamed file upon reboot.
            //
            UnPostSucceeded = UnPostDelayedMove(Queue,
                                                RenamedFilename,
                                                NULL
                                               );
            MYASSERT(UnPostSucceeded);
        }
    }
}


VOID
pSetupExemptFileFromProtection(
    IN  PCTSTR             FileName,
    IN  DWORD              FileChangeFlags,
    IN  PSETUP_LOG_CONTEXT LogContext,      OPTIONAL
    OUT PDWORD             QueueNodeFlags   OPTIONAL
    )
/*++

Routine Description:

    This routine checks to see if the specified file is a protected system
    file, and if so, it tells SFC to make a replacement exception for this file.

Arguments:

    FileName - Supplies the name of the file for which an exception is being
        requested.

    FileChangeFlags - Supplies the flags to be passed to SfcFileException, if
        this file is determined to be under the protection of SFP.

    LogContext - Optionally, supplies the log context to be used when logging
        information resulting from this request.

    QueueNodeFlags - Optionally, supplies the address of a variable that
        receives one or more of the following queue node flags indicating
        whether the specified file is a protected system file, and whether an
        exception was granted for its replacement:

        IQF_TARGET_PROTECTED - File is a protected system file.
        IQF_ALLOW_UNSIGNED   - An exception has been granted so that the file
                               may be replaced by an unsigned file.

Return Value:

    None.

--*/
{
#ifdef UNICODE
    HANDLE hSfp;
    PSETUP_LOG_CONTEXT lc = NULL;
    DWORD Result = NO_ERROR;

    if(QueueNodeFlags) {
        *QueueNodeFlags = 0;
    }

    //
    // If the caller didn't supply us with a LogContext, then create our own.
    // We want to do this so that all log entries generated herein will end up
    // in the same section.
    //
    if(!LogContext) {
        if(CreateLogContext(NULL, TRUE, &lc) == NO_ERROR) {
            //
            // success
            //
            LogContext = lc;
        } else {
            lc = NULL;
        }
    }

    if(IsFileProtected(FileName, LogContext, &hSfp)) {

        if(QueueNodeFlags) {
            *QueueNodeFlags = IQF_TARGET_PROTECTED;
        }

        Result = SfcFileException(hSfp,
                                  (PWSTR)FileName,
                                  FileChangeFlags
                                 );

        if(Result == NO_ERROR) {

            WriteLogEntry(
                LogContext,
                SETUP_LOG_ERROR,
                MSG_LOG_SFC_EXEMPT_SUCCESS,
                NULL,
                FileName);

            if(QueueNodeFlags) {
                *QueueNodeFlags |= IQF_ALLOW_UNSIGNED;
            }

        } else {
            WriteLogEntry(
                LogContext,
                SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
                MSG_LOG_SFC_EXEMPT_FAIL,
                NULL,
                FileName);
            WriteLogError(
                LogContext,
                SETUP_LOG_ERROR,
                Result);
        }

        SfcClose(hSfp);

        //
        // If we created our own local LogContext, we can free it now.
        //
        if(lc) {
            DeleteLogContext(lc);
        }
    }
#else // no file protection on win9x
    if(QueueNodeFlags) {
        *QueueNodeFlags = 0;
    }
#endif
}


BOOL
pSetupProtectedRenamesFlag(
    BOOL bSet
    )
{
    HKEY hKey;
    long rslt = ERROR_SUCCESS;

    if (OSVersionInfo.dwPlatformId != VER_PLATFORM_WIN32_NT) {
        return(TRUE);
    }

    rslt = RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 TEXT("System\\CurrentControlSet\\Control\\Session Manager"),
                 0,
                 KEY_SET_VALUE,
                 &hKey);

    if (rslt == ERROR_SUCCESS) {
        DWORD Value = bSet ? 1 : 0;
        rslt = RegSetValueEx(
                 hKey,
                 TEXT("AllowProtectedRenames"),
                 0,
                 REG_DWORD,
                 (LPBYTE)&Value,
                 sizeof(DWORD));

        RegCloseKey(hKey);

        if (rslt != ERROR_SUCCESS) {
            DebugPrintEx( DPFLTR_ERROR_LEVEL, TEXT("couldn't RegSetValueEx, ec = %d\n"), rslt );
        }

    } else {
        DebugPrintEx( DPFLTR_ERROR_LEVEL, TEXT("couldn't RegOpenKeyEx, ec = %d\n"), rslt );
    }

    return(rslt == ERROR_SUCCESS);

}


VOID
pSetupUninstallNewCatalogNodes(
    IN PSP_FILE_QUEUE     Queue,
    IN PSETUP_LOG_CONTEXT LogContext OPTIONAL
    )
/*++

Routine Description:

    This routine uninstalls any newly-copied INFs/PNFs/CATs contained in the
    specified linked list of catalog nodes.

Arguments:

    Queue - Supplies a pointer to the file queue (potentially) containing
        newly-copied catalog nodes to be uninstalled.

Return Value:

    None.

--*/
{
    PSPQ_CATALOG_INFO CatalogNode;
    PTSTR InfToUninstall;
    BOOL Locked = FALSE;

    try {

        if(!_pSpUtilsStringTableLock(Queue->StringTable)) {
            leave;
        }

        Locked = TRUE;

        for(CatalogNode = Queue->CatalogList;
            CatalogNode;
            CatalogNode = CatalogNode->Next) {

            if(CatalogNode->Flags & CATINFO_FLAG_NEWLY_COPIED) {

                InfToUninstall = _pSpUtilsStringTableStringFromId(
                                     Queue->StringTable,
                                     CatalogNode->InfFinalPath
                                     );

                MYASSERT(InfToUninstall);

                if(InfToUninstall) {
                    pSetupUninstallOEMInf(InfToUninstall, LogContext, SUOI_FORCEDELETE, NULL);
                }
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Reference the following variable so the compiler will respect
        // statement ordering w.r.t. its assignment.
        //
        Locked = Locked;
    }

    if(Locked) {
        _pSpUtilsStringTableUnlock(Queue->StringTable);
    }
}


BOOL
WINAPI
SetupUninstallNewlyCopiedInfs(
    IN HSPFILEQ QueueHandle,
    IN DWORD Flags,
    IN PVOID Reserved
    )

/*++

Routine Description:

    This API uninstalls any INFs (and their associated PNFs and CATs) that
    were previously installed during committal of the specified file queue.

Arguments:

    QueueHandle - Supplies a handle to a committed file queue (potentially)
        containing newly-copied INFs to be uninstalled.

    Flags - Supplies flags that alter the behavior of this API.  Presently, no
        flags are defined.  This parameter must be zero.

    Reserved - Reserved for future use.  This parameter must be NULL.

Return Value:

    If all the parameters were valid, the return value is non-zero (TRUE). Note
    that this does _not_ necessarily mean that any newly-copied INFs were
    uninstalled.

    If there was a problem with the parameters passed in, the return value is
    FALSE, and GetLastError provides more information on the problem.

--*/

{
    PSP_FILE_QUEUE Queue;
    BOOL Success;
    PSETUP_LOG_CONTEXT LogContext;

    if(Flags) {
        SetLastError(ERROR_INVALID_FLAGS);
        return FALSE;
    }

    if(Reserved) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Queue handle is actually a pointer to the queue structure.
    //
    Queue = (PSP_FILE_QUEUE)QueueHandle;

    //
    // do a quick handle validation before anything else
    //
    try {
        Success = ((Queue != NULL) && (Queue != INVALID_HANDLE_VALUE) && (Queue->Signature == SP_FILE_QUEUE_SIG));
        if(Success) {
            LogContext = Queue->LogContext;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Success = FALSE;
    }

    if(!Success) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    pSetupUninstallNewCatalogNodes(Queue, LogContext);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\fileq6.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    fileq6.c

Abstract:

    Copy list scanning functions.

Author:

    Ted Miller (tedm) 24-Feb-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Define mask that isolates the action to be performed on the file queue.
//
#define SPQ_ACTION_MASK (SPQ_SCAN_FILE_PRESENCE | SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_USE_CALLBACK | SPQ_SCAN_USE_CALLBACKEX | SPQ_SCAN_USE_CALLBACK_SIGNERINFO)
#define SPQ_SCAN_USE_CALLBACKEX_PRESENCE (SPQ_SCAN_FILE_PRESENCE|SPQ_SCAN_USE_CALLBACKEX)

BOOL
_SetupMarkFileNodeTargetFlags(
    IN  PSP_FILE_QUEUE      FileQueue,
    IN  LONG                RootID,
    IN  LONG                DirID,
    IN  LONG                FileID,
    IN  DWORD               MaskFlags,
    IN  DWORD               Flags,
    OUT PDWORD              PriorFlags
    )
{
    SP_TARGET_ENT TargetInfo;
    LONG TargetID;
    DWORD rc;
    DWORD OldFlags;

    MYASSERT(Flags == (MaskFlags&Flags));

    rc = pSetupBackupGetTargetByPath((HSPFILEQ)FileQueue,
                                     NULL, // use Queue's string table
                                     NULL,
                                     RootID,
                                     DirID,
                                     FileID,
                                     &TargetID,
                                     &TargetInfo
                                    );

    if (rc != NO_ERROR) {
        SetLastError(rc);
        return FALSE;
    }
    OldFlags = TargetInfo.InternalFlags;
    TargetInfo.InternalFlags = (TargetInfo.InternalFlags&~MaskFlags)|Flags;

    if(OldFlags != TargetInfo.InternalFlags) {
        rc = pSetupBackupSetTargetByID((HSPFILEQ)FileQueue,
                                       TargetID,
                                       &TargetInfo
                                       );
    }
    if(PriorFlags) {
        *PriorFlags = OldFlags;
    }

    if (rc != NO_ERROR) {
        SetLastError(rc);
        return FALSE;
    }
    return TRUE;
}

BOOL
_SetupScanFileQueue(
    IN  HSPFILEQ FileQueue,
    IN  DWORD    Flags,
    IN  HWND     Window,            OPTIONAL
    IN  PVOID    CallbackRoutine,   OPTIONAL
    IN  PVOID    CallbackContext,   OPTIONAL
    OUT PDWORD   Result,
    IN  BOOL     IsNativeCharWidth
    )

/*++

Routine Description:

    Implementation for SetupScanFileQueue, handles ANSI and Unicode
    callback functions.

Arguments:

    Same as SetupScanFileQueue().

    IsNativeCharWidth - supplies flag indicating whether callback routine is
        expecting unicode params. Meaningful only in UNICODE version of DLL.

Return Value:

    Same as SetupScanFileQueue().

--*/

{
    DWORD Action;
    PSP_FILE_QUEUE Queue;
    PSP_FILE_QUEUE_NODE QueueNode, TempNode, NextNode;
    PSP_FILE_QUEUE_NODE CheckNode;
    PSOURCE_MEDIA_INFO SourceMedia;
    BOOL Continue;
    TCHAR TargetPath[MAX_PATH];
    BOOL Err;
    int i;
    PTSTR Message;
    DWORD flags;
    DWORD Win32Error;
    SetupapiVerifyProblem Problem;
    TCHAR TempCharBuffer[MAX_PATH];
    TCHAR SourcePath[MAX_PATH];
    TCHAR DigitalSigner[MAX_PATH];
    TCHAR SignerVersion[MAX_PATH];
    TCHAR CatalogFile[MAX_PATH];
    DWORD rc;
    UINT Notification;
    UINT_PTR CallbackParam1;
    FILEPATHS FilePaths;
    FILEPATHS_SIGNERINFO FilePathsSignerInfo;
    BOOL DoPruning, PruneNode;
    PSPQ_CATALOG_INFO CatalogNode;
    PSETUP_LOG_CONTEXT lc = NULL;
    DWORD slot_fileop = 0;

    Queue = (PSP_FILE_QUEUE)FileQueue;

    rc = NO_ERROR;
    try {
        if (Queue->Signature != SP_FILE_QUEUE_SIG) {
            rc = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
       rc = ERROR_INVALID_HANDLE;
    }

    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    lc = Queue->LogContext;

    //
    // Validate arguments. Exactly one action flag must be specified.
    //
    if(Result) {
        *Result = 0;
    } else {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
    Action = (Flags & SPQ_ACTION_MASK);
    switch(Action) {
        case SPQ_SCAN_FILE_PRESENCE:
        case SPQ_SCAN_FILE_VALIDITY:
            break;
        case SPQ_SCAN_USE_CALLBACK:
        case SPQ_SCAN_USE_CALLBACKEX:
        case SPQ_SCAN_USE_CALLBACKEX_PRESENCE:
        case SPQ_SCAN_USE_CALLBACK_SIGNERINFO:
            if(CallbackRoutine) {
                break;
            }
            // else fall through to invalid arg case
        default:
            SetLastError(ERROR_INVALID_PARAMETER);
            return(FALSE);
    }

    DoPruning = Flags & SPQ_SCAN_PRUNE_COPY_QUEUE;
    if(DoPruning) {
        if(Queue->Flags & FQF_QUEUE_ALREADY_COMMITTED) {
            //
            // If we've been asked to prune the copy queue, then make sure the queue
            // hasn't been committed yet.
            //
            SetLastError(ERROR_NO_MORE_ITEMS);
            return FALSE;
        }

        if((Action == SPQ_SCAN_USE_CALLBACK)
           || (Action == SPQ_SCAN_USE_CALLBACKEX)
           || (Action == SPQ_SCAN_USE_CALLBACKEX_PRESENCE)
           || (Action == SPQ_SCAN_USE_CALLBACK_SIGNERINFO)
           || (Flags & SPQ_SCAN_INFORM_USER)) {
            //
            // Presently, pruning the queue is not supported when using a callback.
            // Also, SPQ_SCAN_INFORM_USER and SPQ_SCAN_PRUNE_COPY_QUEUE don't play well
            // together...
            //
            SetLastError(ERROR_INVALID_FLAGS);
            return FALSE;
        }
    }

    //
    // If the caller asked for UI, make sure we're running interactively.
    //
    if((Flags & SPQ_SCAN_INFORM_USER) && (GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP))) {
        SetLastError(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION);
        return FALSE;
    }

    //
    // If we're verifying the digital signatures of the files, then first make
    // sure that we've processed the catalog nodes for this queue.  However, we
    // don't want any copying to take place if there are OEM INFs in the list.
    //
    if((Action == SPQ_SCAN_FILE_VALIDITY) ||
       (Action == SPQ_SCAN_USE_CALLBACKEX) ||
       (Action == SPQ_SCAN_USE_CALLBACK_SIGNERINFO)) {

        WriteLogEntry(
            lc,
            SETUP_LOG_TIME,
            MSG_LOG_BEGIN_VERIFY4_CAT_TIME,
            NULL);       // text message

        rc = _SetupVerifyQueuedCatalogs(Window,
                                        Queue,
                                        VERCAT_NO_PROMPT_ON_ERROR,
                                        NULL,
                                        NULL
                                       );

        WriteLogEntry(
            lc,
            SETUP_LOG_TIME,
            MSG_LOG_END_VERIFY4_CAT_TIME,
            NULL);       // text message

        if((Action == SPQ_SCAN_FILE_VALIDITY) && (rc != NO_ERROR)) {
            WriteLogEntry(
                lc,
                (rc == ERROR_CANNOT_COPY ? SETUP_LOG_VVERBOSE : SETUP_LOG_WARNING) | SETUP_LOG_BUFFER,
                MSG_LOG_SCANQUEUE_VERIFY_FAILED,
                NULL);
            WriteLogError(
                lc,
                (rc == ERROR_CANNOT_COPY ? SETUP_LOG_VVERBOSE : SETUP_LOG_WARNING),
                rc);

            //
            // Result output param has already been initialized to zero
            // above.
            //
            return TRUE;
        }
    } else {
        rc = NO_ERROR;
    }

    //
    // Regardless of whether or not the catalog validation succeeded
    // above, we still want to call the callback for each file.  The
    // failed catalog verifications will be reflected in the failed
    // file verifications that the caller gets informed of via the
    // Win32Error field of the FILEPATHS struct we give the callback.
    //
    // Initialize the static fields of that structure here so we don't
    // have to each pass through the loop below.
    //
    FilePaths.Target = TargetPath;
    FilePaths.Source = SourcePath;
    FilePathsSignerInfo.Target = TargetPath;
    FilePathsSignerInfo.Source = SourcePath;


    //
    // markup delete/rename usage
    // we don't need to do this if we have SPQ_SCAN_PRUNE_DELREN set
    //
    if(!(Flags & SPQ_SCAN_PRUNE_DELREN)) {
        for(TempNode=Queue->DeleteQueue; TempNode; TempNode=TempNode->Next) {
            if(!_SetupMarkFileNodeTargetFlags(Queue,
                                              TempNode->TargetDirectory,
                                              -1,
                                              TempNode->TargetFilename,
                                              SP_TEFLG_PRUNE_DEL,SP_TEFLG_PRUNE_DEL,
                                              NULL)) {
                //
                // this would indicate an out-of-memory condition
                // last error is set
                //
                return FALSE;
            }
        }
        for(TempNode=Queue->RenameQueue; TempNode; TempNode=TempNode->Next) {
            if(!_SetupMarkFileNodeTargetFlags(Queue,
                                              TempNode->SourcePath,
                                              -1,
                                              TempNode->SourceFilename,
                                              SP_TEFLG_PRUNE_RENSRC,SP_TEFLG_PRUNE_RENSRC,
                                              NULL)) {
                //
                // this would indicate an out-of-memory condition
                // last error is set
                //
                return FALSE;
            }
            if(!_SetupMarkFileNodeTargetFlags(Queue,
                                              TempNode->TargetDirectory == -1 ? TempNode->SourcePath : TempNode->TargetDirectory,
                                              -1,
                                              TempNode->TargetFilename,
                                              SP_TEFLG_PRUNE_RENTARG,SP_TEFLG_PRUNE_RENTARG,
                                              NULL)) {
                //
                // this would indicate an out-of-memory condition
                // last error is set
                //
                return FALSE;
            }
        }
    }

    //
    // Process all nodes in the copy queue.
    //
    Err = FALSE;
    Continue = TRUE;
    for(SourceMedia=Queue->SourceMediaList; Continue && SourceMedia; SourceMedia=SourceMedia->Next) {

        TempNode = NULL;
        QueueNode = SourceMedia->CopyQueue;

        while(Continue && QueueNode) {
            DWORD PrevNodeFlags;
            //
            // markup copy usage
            //
            if(!_SetupMarkFileNodeTargetFlags(Queue,
                                              QueueNode->TargetDirectory,
                                              -1,
                                              QueueNode->TargetFilename,
                                              SP_TEFLG_PRUNE_COPY,SP_TEFLG_PRUNE_COPY,
                                              &PrevNodeFlags)) {
                //
                // this would indicate an out-of-memory condition
                // last error is set
                //
                rc = GetLastError();
                Err = TRUE;
                Continue = FALSE;
                break;
            }

            //
            // Form target path.
            //
            lstrcpyn(
                TargetPath,
                pSetupStringTableStringFromId(Queue->StringTable,QueueNode->TargetDirectory),
                MAX_PATH
                );

            pSetupConcatenatePaths(
                TargetPath,
                pSetupStringTableStringFromId(Queue->StringTable,QueueNode->TargetFilename),
                MAX_PATH,
                NULL
                );


            if((PrevNodeFlags & (SP_TEFLG_PRUNE_DEL|SP_TEFLG_PRUNE_RENSRC|SP_TEFLG_PRUNE_RENTARG))
               && !((Flags & SPQ_SCAN_PRUNE_DELREN) || (QueueNode->StyleFlags & SP_COPY_NOPRUNE))) {
                DWORD msg;
                //
                // this file is touched in source/target
                // but the INF author forgot to mark it as SP_COPY_NOPRUNE
                // this typically indicates a mistake on the author's part
                // so we try and handle it best as we can
                // if SPQ_SCAN_PRUNE_DELREN is set, we'll kill the delete/rename entries
                // if it's not set, we enforce the SP_COPY_NOPRUNE
                //
                QueueNode->StyleFlags |= SP_COPY_NOPRUNE;

                if(PrevNodeFlags & SP_TEFLG_PRUNE_DEL) {
                    msg = MSG_LOG_CHANGEPRUNE_DEL;
                } else if(PrevNodeFlags & SP_TEFLG_PRUNE_RENSRC) {
                    msg = MSG_LOG_CHANGEPRUNE_RENSRC;
                } else {
                    msg = MSG_LOG_CHANGEPRUNE_RENTARG;
                }

                WriteLogEntry(
                    lc,
                    SETUP_LOG_WARNING,
                    msg,
                    NULL,
                    TargetPath);
            }

            //
            // Perform check on file.
            //
            PruneNode = FALSE;
            switch(Action) {

            case SPQ_SCAN_FILE_PRESENCE:

                Continue = FileExists(TargetPath,NULL);
                if(DoPruning) {
                    //
                    // File's presence should result in this copy node's removal
                    // from the queue--it's absence should be ignored.
                    //
                    if(Continue) {
                        PruneNode = TRUE;
                    } else {
                        //
                        // Leave copy node alone.
                        //
                        PruneNode = FALSE;
                        Continue = TRUE;
                    }
                } else {
                    if (Continue) {
                        //
                        // we should not continue if the copy node is marked as a "no prune" node
                        //
                        if (QueueNode->StyleFlags & SP_COPY_NOPRUNE) {
                            Continue = FALSE;
                        }
                    }
                }
                break;

            case SPQ_SCAN_FILE_VALIDITY:

                //
                // If we are going to prune the copy queue then:
                //
                // (a) only validate the file against the system catalogs (not
                //     against any OEM catalogs), and
                // (b) don't validate self-signed files.
                //
                // (Note: we will never consider an INF in %windir%\Inf to be
                // signed, since it is invalid to copy an INF there via a file
                // queue.  SetupCopyOEMInf must be used instead.)
                //
                if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
                    //
                    // If we're pruning, then we don't want to consider any
                    // existing files as valid, otherwise we'd never copy
                    // anything!
                    //
                    Continue = !DoPruning;

                    //
                    // We want to prune the queue node if the target exists and the source doesn't
                    //
                    if ( DoPruning && FileExists(TargetPath, NULL) ) {
                        //
                        // The target exists!  Now build the path the source file...
                        //
                        lstrcpyn(SourcePath,
                                 pSetupStringTableStringFromId(Queue->StringTable, QueueNode->SourceRootPath),
                                 SIZECHARS(SourcePath)
                                );

                        if (QueueNode->SourcePath != -1) {
                            pSetupConcatenatePaths(SourcePath,
                                                   pSetupStringTableStringFromId(Queue->StringTable, QueueNode->SourcePath),
                                                   SIZECHARS(SourcePath),
                                                   NULL
                                                  );
                        }

                        pSetupConcatenatePaths(SourcePath,
                                               pSetupStringTableStringFromId(Queue->StringTable, QueueNode->SourceFilename),
                                               SIZECHARS(SourcePath),
                                               NULL
                                              );

                        //
                        // If there's no source file to copy, prune this node
                        //
                        Continue = !FileExists(SourcePath, NULL);
                    }

                } else {

                    Continue = (NO_ERROR == VerifySourceFile(lc,
                                                             Queue,
                                                             QueueNode,
                                                             pSetupGetFileTitle(TargetPath),
                                                             TargetPath,
                                                             NULL,
                                                             ((Queue->Flags & FQF_USE_ALT_PLATFORM)
                                                                 ? &(Queue->AltPlatformInfo)
                                                                 : Queue->ValidationPlatform),
                                                             (DoPruning
                                                                ? (VERIFY_FILE_IGNORE_SELFSIGNED | VERIFY_FILE_FAIL_COPIED_INFS)
                                                                : (VERIFY_FILE_USE_OEM_CATALOGS  | VERIFY_FILE_FAIL_COPIED_INFS)),
                                                             &Problem,
                                                             TempCharBuffer,
                                                             NULL,
                                                             NULL,
                                                             NULL
                                                            ));
                }

                if(DoPruning) {
                    //
                    // File's validity should result in this copy node's removal
                    // from the queue--it's invalidity should be ignored.
                    //
                    if(Continue) {
                        PruneNode = TRUE;
                    } else {
                        //
                        // Leave copy node alone.
                        //
                        PruneNode = FALSE;
                        Continue = TRUE;
                    }
                } else {
                    if (Continue) {
                        //
                        // we should not continue if the copy node is marked as a "no prune" node
                        //
                        if (QueueNode->StyleFlags & SP_COPY_NOPRUNE) {
                            Continue = FALSE;
                        }
                    }
                }
                break;

            case SPQ_SCAN_USE_CALLBACK:
            case SPQ_SCAN_USE_CALLBACKEX:
            case SPQ_SCAN_USE_CALLBACKEX_PRESENCE:
            case SPQ_SCAN_USE_CALLBACK_SIGNERINFO:

                flags = (QueueNode->InternalFlags & (INUSE_INF_WANTS_REBOOT | INUSE_IN_USE))
                      ? SPQ_DELAYED_COPY
                      : 0;

                if((Action == SPQ_SCAN_USE_CALLBACKEX) ||
                   (Action == SPQ_SCAN_USE_CALLBACKEX_PRESENCE) ||
                   (Action == SPQ_SCAN_USE_CALLBACK_SIGNERINFO)) {

                    //
                    // The caller requested the extended version of the queue
                    // scan callback--we need to build the source file path.
                    //
                    lstrcpyn(SourcePath,
                             pSetupStringTableStringFromId(Queue->StringTable, QueueNode->SourceRootPath),
                             SIZECHARS(SourcePath)
                            );

                    if(QueueNode->SourcePath != -1) {

                        pSetupConcatenatePaths(SourcePath,
                                         pSetupStringTableStringFromId(Queue->StringTable, QueueNode->SourcePath),
                                         SIZECHARS(SourcePath),
                                         NULL
                                        );
                    }

                    pSetupConcatenatePaths(SourcePath,
                                     pSetupStringTableStringFromId(Queue->StringTable, QueueNode->SourceFilename),
                                     SIZECHARS(SourcePath),
                                     NULL
                                    );

                    if((Action == SPQ_SCAN_USE_CALLBACKEX_PRESENCE)) {
                        Win32Error = NO_ERROR;
                    } else {

                        CatalogFile[0] = TEXT('\0');
                        DigitalSigner[0] = TEXT('\0');
                        SignerVersion[0] = TEXT('\0');

                        if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
                            //
                            // We can't call our internal VerifySourceFile
                            // routine, because it doesn't expect to be asked
                            // for signer info when in "minimal embedded" mode
                            // (plus, it doesn't make sense to ask for such
                            // info anyway, since we have no idea who signed
                            // the file, or even if it was signed).
                            //
                            Win32Error = NO_ERROR;

                        } else {

                            Win32Error = VerifySourceFile(lc,
                                                          Queue,
                                                          QueueNode,
                                                          pSetupGetFileTitle(TargetPath),
                                                          TargetPath,
                                                          NULL,
                                                          ((Queue->Flags & FQF_USE_ALT_PLATFORM)
                                                                ? &(Queue->AltPlatformInfo)
                                                                : Queue->ValidationPlatform),
                                                          VERIFY_FILE_USE_OEM_CATALOGS | VERIFY_FILE_FAIL_COPIED_INFS,
                                                          &Problem,
                                                          TempCharBuffer,
                                                          (Action == SPQ_SCAN_USE_CALLBACK_SIGNERINFO)
                                                              ? CatalogFile
                                                              : NULL,
                                                          (Action == SPQ_SCAN_USE_CALLBACK_SIGNERINFO)
                                                              ? DigitalSigner
                                                              : NULL,
                                                          (Action == SPQ_SCAN_USE_CALLBACK_SIGNERINFO)
                                                              ? SignerVersion
                                                              : NULL
                                                         );
                        }
                    }

                    if ((Action == SPQ_SCAN_USE_CALLBACKEX) ||
                        (Action == SPQ_SCAN_USE_CALLBACKEX_PRESENCE)) {
                        FilePaths.Win32Error = Win32Error;
                        FilePaths.Flags  = QueueNode->StyleFlags;
                        CallbackParam1 = (UINT_PTR)(&FilePaths);
                        Notification = SPFILENOTIFY_QUEUESCAN_EX;
                    } else {
                        FilePathsSignerInfo.Win32Error = Win32Error;
                        FilePathsSignerInfo.Flags  = QueueNode->StyleFlags;
                        FilePathsSignerInfo.DigitalSigner = (DigitalSigner[0] != TEXT('\0'))
                                                                ? DigitalSigner
                                                                : NULL;
                        FilePathsSignerInfo.Version = (SignerVersion[0] != TEXT('\0'))
                                                                ? SignerVersion
                                                                : NULL;
                        FilePathsSignerInfo.CatalogFile = (CatalogFile[0] != TEXT('\0'))
                                                                ? CatalogFile
                                                                : NULL;
                        CallbackParam1 = (UINT_PTR)(&FilePathsSignerInfo);
                        Notification = SPFILENOTIFY_QUEUESCAN_SIGNERINFO;
                    }
                } else {
                    CallbackParam1 = (UINT_PTR)TargetPath;
                    Notification = SPFILENOTIFY_QUEUESCAN;
                }

                rc = (DWORD)pSetupCallMsgHandler(
                                    lc,
                                    CallbackRoutine,
                                    IsNativeCharWidth,
                                    CallbackContext,
                                    Notification,
                                    CallbackParam1,
                                    flags
                                    );
                *Result = rc;
                Err = (rc != NO_ERROR);
                Continue = !Err;
                break;
            }

            if(DoPruning && PruneNode) {
                BOOL ReallyPrune = TRUE;
                MYASSERT(Continue == TRUE);

                //
                // before we remove the item from the queue, we must check if the copy item
                // also exists in the rename or delete queues.  if it does, then we cannot
                // prune the item from the copy queue
                //
                if (QueueNode->StyleFlags & SP_COPY_NOPRUNE) {
                    ReallyPrune = FALSE;
                    TempNode = QueueNode;
                    QueueNode = QueueNode->Next;
                }

                if (ReallyPrune) {

                    WriteLogEntry(
                        lc,
                        SETUP_LOG_VERBOSE,
                        MSG_LOG_PRUNE,
                        NULL,
                        TargetPath);

                    NextNode = QueueNode->Next;
                    if(TempNode) {
                        TempNode->Next = NextNode;
                    } else {
                        SourceMedia->CopyQueue = NextNode;
                    }
                    MyFree(QueueNode);
                    QueueNode = NextNode;

                    //
                    // Adjust the queue node counts.
                    //
                    Queue->CopyNodeCount--;
                    SourceMedia->CopyNodeCount--;
                }


            } else {
                TempNode = QueueNode;
                QueueNode = QueueNode->Next;
            }
        }
    }

    if(Flags & SPQ_SCAN_PRUNE_DELREN) {
        //
        // flag tells us to rip out of Delete/Rename queues
        // files that are (or was) in the copy queue.
        // we'll only be asked to do this in limited cases
        // (eg, GUI setup)
        //
        TempNode = NULL;
        QueueNode = Queue->DeleteQueue;
        while(QueueNode) {
            DWORD PrevFlags;
            NextNode = QueueNode->Next;

            if(_SetupMarkFileNodeTargetFlags(Queue,
                                              QueueNode->TargetDirectory,
                                              -1,
                                              QueueNode->TargetFilename,
                                              0,0,
                                              &PrevFlags)) {
                if(PrevFlags & SP_TEFLG_PRUNE_COPY) {
                    //
                    // warn about this
                    //
                    lstrcpyn(
                        TargetPath,
                        pSetupStringTableStringFromId(Queue->StringTable,QueueNode->TargetDirectory),
                        MAX_PATH
                        );
                    pSetupConcatenatePaths(
                        TargetPath,
                        pSetupStringTableStringFromId(Queue->StringTable,QueueNode->TargetFilename),
                        MAX_PATH,
                        NULL
                        );
                    WriteLogEntry(
                        lc,
                        SETUP_LOG_WARNING,
                        MSG_LOG_PRUNE_DEL,
                        NULL,
                        TargetPath);

                    if(TempNode) {
                        TempNode->Next = NextNode;
                    } else {
                        Queue->DeleteQueue = NextNode;
                    }
                    MyFree(QueueNode);
                    Queue->DeleteNodeCount--;
                    QueueNode = NextNode;
                    continue;
                }
            }
            TempNode = QueueNode;
            QueueNode = NextNode;
        }
        TempNode = NULL;
        QueueNode = Queue->RenameQueue;
        while(QueueNode) {
            DWORD PrevFlags;
            NextNode = QueueNode->Next;

            if(_SetupMarkFileNodeTargetFlags(Queue,
                                              QueueNode->SourcePath,
                                              -1,
                                              QueueNode->SourceFilename,
                                              0,0,
                                              &PrevFlags)) {
                if(PrevFlags & SP_TEFLG_PRUNE_COPY) {
                    //
                    // warn about this
                    //
                    lstrcpyn(
                        TargetPath,
                        pSetupStringTableStringFromId(Queue->StringTable,QueueNode->SourcePath),
                        MAX_PATH
                        );
                    pSetupConcatenatePaths(
                        TargetPath,
                        pSetupStringTableStringFromId(Queue->StringTable,QueueNode->SourceFilename),
                        MAX_PATH,
                        NULL
                        );
                    WriteLogEntry(
                        lc,
                        SETUP_LOG_WARNING,
                        MSG_LOG_PRUNE_RENSRC,
                        NULL,
                        TargetPath);

                    if(TempNode) {
                        TempNode->Next = NextNode;
                    } else {
                        Queue->RenameQueue = NextNode;
                    }
                    MyFree(QueueNode);
                    Queue->RenameNodeCount--;
                    QueueNode = NextNode;
                    continue;
                }
            }
            if(_SetupMarkFileNodeTargetFlags(Queue,
                                              QueueNode->TargetDirectory == -1 ? QueueNode->SourcePath : QueueNode->TargetDirectory,
                                              -1,
                                              QueueNode->TargetFilename,
                                              0,0,
                                              &PrevFlags)) {
                if(PrevFlags & SP_TEFLG_PRUNE_COPY) {
                    //
                    // warn about this
                    //
                    lstrcpyn(
                        TargetPath,
                        pSetupStringTableStringFromId(Queue->StringTable,QueueNode->TargetDirectory == -1 ? QueueNode->SourcePath : QueueNode->TargetDirectory),
                        MAX_PATH
                        );
                    pSetupConcatenatePaths(
                        TargetPath,
                        pSetupStringTableStringFromId(Queue->StringTable,QueueNode->TargetFilename),
                        MAX_PATH,
                        NULL
                        );
                    WriteLogEntry(
                        lc,
                        SETUP_LOG_WARNING,
                        MSG_LOG_PRUNE_RENTARG,
                        NULL,
                        TargetPath);

                    if(TempNode) {
                        TempNode->Next = NextNode;
                    } else {
                        Queue->RenameQueue = NextNode;
                    }
                    MyFree(QueueNode);
                    Queue->RenameNodeCount--;
                    QueueNode = NextNode;
                    continue;
                }
            }
            TempNode = QueueNode;
            QueueNode = NextNode;
        }
    }
    //
    // If the case of SPQ_SCAN_USE_CALLBACK(EX), *Result is already set up
    // when we get here. If Continue is TRUE then we visited all nodes
    // and the presence/validity check passed on all of them. Note that
    // if Continue is TRUE then Err must be FALSE.
    //
    if((Action == SPQ_SCAN_FILE_PRESENCE) || (Action == SPQ_SCAN_FILE_VALIDITY)) {

        if(DoPruning) {
            //
            // Set result based on whether any of the queues have nodes in them.
            //
            if(Queue->CopyNodeCount) {
                *Result = 0;
            } else {
                *Result = (Queue->DeleteNodeCount || Queue->RenameNodeCount || Queue->BackupNodeCount) ? 2 : 1;
            }
        } else {
            //
            // If we weren't doing pruning, then we know that the Continue
            // variable indicates whether or not we bailed partway through.
            //
            if(Continue) {
                //
                // Need to set up Result.
                //
                if((Flags & SPQ_SCAN_INFORM_USER) && Queue->CopyNodeCount
                && (Message = RetreiveAndFormatMessage(MSG_NO_NEED_TO_COPY))) {

                    //
                    // Overload TargetPath for use as the caption string.
                    //
                    GetWindowText(Window,TargetPath,sizeof(TargetPath)/sizeof(TargetPath[0]));

                    i = MessageBox(
                            Window,
                            Message,
                            TargetPath,
                            MB_APPLMODAL | MB_YESNO | MB_ICONINFORMATION
                            );

                    MyFree(Message);

                    if(i == IDYES) {
                        //
                        // User wants to skip copying.
                        //
                        *Result = (Queue->DeleteNodeCount || Queue->RenameNodeCount || Queue->BackupNodeCount) ? 2 : 1;
                    } else {
                        //
                        // User wants to perform copy.
                        //
                        *Result = 0;
                    }
                } else {
                    //
                    // Don't want to ask user. Set up Result based on whether
                    // there are items in the delete, rename or backup queues.
                    //
                    *Result = (Queue->DeleteNodeCount || Queue->RenameNodeCount || Queue->BackupNodeCount) ? 2 : 1;
                }
            } else {
                //
                // Presence/validity check failed.
                //
                *Result = 0;
            }

            //
            // Empty the copy queue if necessary.
            //
            if(*Result) {
                for(SourceMedia=Queue->SourceMediaList; Continue && SourceMedia; SourceMedia=SourceMedia->Next) {
                    for(QueueNode=SourceMedia->CopyQueue; QueueNode; QueueNode=TempNode) {
                        TempNode = QueueNode->Next;
                        MyFree(QueueNode);
                    }
                    Queue->CopyNodeCount -= SourceMedia->CopyNodeCount;
                    SourceMedia->CopyQueue = NULL;
                    SourceMedia->CopyNodeCount = 0;
                }
                //
                // We think we just removed all files in all copy queues.
                // The 2 counts we maintain should be in sync -- meaning that
                // the total copy node count should now be 0.
                //
                MYASSERT(Queue->CopyNodeCount == 0);
            }
        }
    }

    SetLastError(rc);
    return(!Err);
}

#ifdef UNICODE
//
// ANSI version for UNICODE
//
BOOL
SetupScanFileQueueA(
    IN  HSPFILEQ            FileQueue,
    IN  DWORD               Flags,
    IN  HWND                Window,            OPTIONAL
    IN  PSP_FILE_CALLBACK_A CallbackRoutine,   OPTIONAL
    IN  PVOID               CallbackContext,   OPTIONAL
    OUT PDWORD              Result
    )
{
    BOOL b;

    try {
        b = _SetupScanFileQueue(
                FileQueue,
                Flags,
                Window,
                CallbackRoutine,
                CallbackContext,
                Result,
                FALSE
                );
    } except(EXCEPTION_EXECUTE_HANDLER) {
       b = FALSE;
       SetLastError(ERROR_INVALID_DATA);
    }

    return(b);
}

#else
//
// UNICODE version for Win9x
//
BOOL
SetupScanFileQueueW(
    IN  HSPFILEQ            FileQueue,
    IN  DWORD               Flags,
    IN  HWND                Window,            OPTIONAL
    IN  PSP_FILE_CALLBACK_W CallbackRoutine,   OPTIONAL
    IN  PVOID               CallbackContext,   OPTIONAL
    OUT PDWORD              Result
    )
{
    UNREFERENCED_PARAMETER(FileQueue);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(Window);
    UNREFERENCED_PARAMETER(CallbackRoutine);
    UNREFERENCED_PARAMETER(CallbackContext);
    UNREFERENCED_PARAMETER(Result);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}

#endif


BOOL
SetupScanFileQueue(
    IN  HSPFILEQ          FileQueue,
    IN  DWORD             Flags,
    IN  HWND              Window,            OPTIONAL
    IN  PSP_FILE_CALLBACK CallbackRoutine,   OPTIONAL
    IN  PVOID             CallbackContext,   OPTIONAL
    OUT PDWORD            Result
    )

/*++

Routine Description:

    This routine scans a setup file queue, performing an operation on each
    node in its copy list. The operation is specified by a set of flags.

    A caller can use this API to determine whether all files that have been
    enqueued for copy already exist on the target, and if so, to inform the
    user, who may elect to skip the file copying. This can spare the user from
    having to furnish Setup media in many cases.

Arguments:

    FileQueue - supplies handle to Setup file queue whose copy list is to
        be scanned/iterated.

    Flags - supplies a set of values that control operation of the API. A
        combination of the following values:

        SPQ_SCAN_FILE_PRESENCE - determine whether all target files in the
            copy queue are already present on the target.

        SPQ_SCAN_FILE_VALIDITY - determine whether all target files in the
            copy queue are already present on the target, and verify their
            digital signatures.

        SPQ_SCAN_USE_CALLBACK - for each node in the queue, call the
            callback routine with SPFILENOTIFY_QUEUESCAN.  If the callback
            routine returns non-0 then queue processing is stopped and this
            routine returns FALSE immediately.

        SPQ_SCAN_USE_CALLBACKEX - same as SPQ_SCAN_USE_CALLBACK except that
            SPFILENOTIFY_QUEUESCAN_EX is used instead.  This supplies a pointer
            to a FILEPATHS structure in Param1, thus you get both source and
            destination info.  You also get the results of the file presence
            check (and if present, of its digital signature verification) in
            the Win32Error field, and the CopyStyle flags in effect for that
            copy queue node in the Flags field.

        SPQ_SCAN_USE_CALLBACK_SIGNERINFO - same as SPQ_SCAN_USE_CALLBACK except
            that SPFILENOTIFY_QUEUESCAN_SIGNERINFO is used instead.  This
            supplies a pointer to a FILEPATHS_SIGNERINFO structure in Param1,
            thus you get both source and destination info.  You also get the
            results of the file presence check (and if present, of its digital
            signature verification) in the Win32Error field, and the CopyStyle
            flags in effect for that copy queue node in the Flags field. In
            addition you get who digitaly signed the file in the DigitalSigner
            field and the SHA1 key in the SignerId field.

        Exactly one of SPQ_SCAN_FILE_PRESENCE, SPQ_SCAN_FILE_VALIDITY,
        SPQ_SCAN_USE_CALLBACK, SPQ_SCAN_USE_CALLBACKEX, or
        SPQ_SCAN_USE_CALLBACK_SIGNERINFO must be specified.

        SPQ_SCAN_INFORM_USER - if specified and all files in the queue
            pass the presence/validity check, then this routine will inform
            the user that the operation he is attempting requires files but
            that we believe all files are already present. Ignored if
            SPQ_SCAN_FILE_PRESENCE or SPQ_SCAN_FILE_VALIDITY is not specified.
            Not valid if specified in combination with SPQ_SCAN_PRUNE_COPY_QUEUE.

        SPQ_SCAN_PRUNE_COPY_QUEUE - if specified, the copy queue will be pruned
            of any nodes that are deemed unnecessary.  This determination is
            made based on the type of queue scan being performed:

            If SPQ_SCAN_FILE_PRESENCE, then the presence of a file having the
            destination filename is sufficient to consider this copy operation
            unnecessary.

            If SPQ_SCAN_FILE_VALIDITY, then the destination file must not only
            be present, but also valid in order for the copy operation to be
            considered unnecessary.

            If SPQ_SCAN_USE_CALLBACK, SPQ_SCAN_USE_CALLBACKEX or
            SPQ_SCAN_USE_CALLBACK_SIGNERINFO, then the queue callback routine
            should return zero to mark the copy node as unnecessary, or non-zero
            to leave the node in the copy queue.

            NOTE: This flag may only be specified _before_ the queue has been
            committed.  This means that the flags contained in Param2 will
            always be zero.  If SetupScanFileQueue is called with
            SPQ_SCAN_PRUNE_COPY_QUEUE after committing the queue, the API will
            fail and GetLastError() will return
            ERROR_NO_MORE_ITEMS.

            This flag is not valid if specified in combination with
            SPQ_SCAN_INFORM_USER.

    Window - specifies the window to own any dialogs, etc, that may be
        presented. Unused if Flags does not contain one of
        SPQ_SCAN_FILE_PRESENCE or SPQ_SCAN_FILE_VALIDITY, or if Flags does not
        contain SPQ_SCAN_INFORM_USER.

    CallbackRoutine - required if Flags includes SPQ_SCAN_USE_CALLBACK.
        Specifies a callback function to be called on each node in
        the copy queue. The notification code passed to the callback is
        SPFILENOTIFY_QUEUESCAN.

    CallbackContext - caller-defined data to be passed to CallbackRoutine.

    Result - receives result of routine. See below.

Return Value:

    If FALSE, then an error occurred or the callback function returned non-0.
    Check Result -- if it is non-0, then it is the value returned by
    the callback function which stopped queue processing.
    If Result is 0, then extended error information is available from
    GetLastError().

    If TRUE, then all nodes were processed. Result is 0 if a callback was
    specified. If SPQ_SCAN_USE_CALLBACK(EX) or SPQ_SCAN_USE_CALLBACK_SIGNERINFO
    was not specified, then Result indicates whether the queue passed the
    presence/validity check:

        Result = 0: queue failed the check, or the queue passed the
        check but SPQ_SCAN_INFORM_USER was specified and the user indicated
        that he wants new copies of the files.  There are still nodes in the
        copy queue, although if SPQ_SCAN_PRUNE_COPY_QUEUE is specified, then
        any nodes that were validated have been pruned.

        Result = 1: queue passed the check, and, if SPQ_SCAN_INFORM_USER was
        specified, the user indicated that no copying is required. If Result is
        1, the copy queue has been emptied, and there are no elements on the
        delete or rename queues, so the caller may skip queue commit.

        Result = 2: queue passed the check, and, if SPQ_SCAN_INFORM_USER was
        specified, the user indicated that no copying is required. In this case,
        the copy queue has been emptied, however there are elements on the
        delete or rename queues, so the caller may not skip queue commit.

--*/

{
    BOOL b;

    try {
        b = _SetupScanFileQueue(
                FileQueue,
                Flags,
                Window,
                CallbackRoutine,
                CallbackContext,
                Result,
                TRUE
                );
    } except(EXCEPTION_EXECUTE_HANDLER) {
       b = FALSE;
       SetLastError(ERROR_INVALID_DATA);
    }

    return(b);
}


INT
SetupPromptReboot(
    IN HSPFILEQ FileQueue,  OPTIONAL
    IN HWND     Owner,
    IN BOOL     ScanOnly
    )

/*++

Routine Description:

    This routine asks the user whether he wants to reboot the system,
    optionally dependent on whether any files in a committed file queue
    were in use (and are thus now pending operations via MoveFileEx()).
    A reboot is also required if any files were installed as boot files
    (e.g., marked as COPYFLG_REPLACE_BOOT_FILE in the INF).

    If the user answers yes to the prompt, shutdown is initiated
    before this routine returns.

Arguments:

    FileQueue - if specified, supplies a file queue upon which
        to base the decision about whether shutdown is necessary.
        If not specified, then this routine assumes shutdown is
        necessary and asks the user what to do.

    Owner - supplies window handle for parent window to own windows
        created by this routine.

    ScanOnly - if TRUE, then the user is never asked whether he wants
        to reboot and no shutdown is initiated. In this case FileQueue
        must be specified. If FALSE then this routine functions as
        described above.

        This flags is used when the caller wants to determine whether
        shutdown is necessary separately from actually performing
        the shutdown.

Return Value:

    A combination of the following flags or -1 if an error occured:

    SPFILEQ_FILE_IN_USE: at least one file was in use and thus there are
        delayed file operations pending. This flag will never be set
        when FileQueue is not specified.

    SPFILEQ_REBOOT_RECOMMENDED: it is recommended that the system
        be rebooted. Depending on other flags and user response to
        the shutdown query, shutdown may already be happening.

    SPFILEQ_REBOOT_IN_PROGRESS: shutdown is in progress.

--*/

{
    PSP_FILE_QUEUE Queue;
    PSP_FILE_QUEUE_NODE QueueNode;
    PSOURCE_MEDIA_INFO SourceMedia;
    INT Flags;
    int i;
    DWORD Reason = REASON_PLANNED_FLAG;

    //
    // If only scanning, there must be a FileQueue to scan!
    //
    if(ScanOnly && !FileQueue) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return -1;
    }

    //
    // If we're not just scanning (i.e., we're potentially going to popup UI,
    // then we'd better be interactive.
    //
    if(!ScanOnly && (GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP))) {
        SetLastError(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION);
        return -1;
    }

    Queue = (PSP_FILE_QUEUE)FileQueue;
    Flags = 0;

    //
    // Scan file queue if the caller so desires.
    //
    if(FileQueue) {
        try {
            if(Queue->Flags & FQF_DEVICE_INSTALL) {
                Reason |= REASON_HWINSTALL;
            }
            //
            // Check delete queue for in-use files.
            //
            for(QueueNode=Queue->DeleteQueue; QueueNode; QueueNode=QueueNode->Next) {

                if(QueueNode->InternalFlags & INUSE_INF_WANTS_REBOOT) {
                    Flags |= SPFILEQ_REBOOT_RECOMMENDED;
                }

                if(QueueNode->InternalFlags & INUSE_IN_USE) {
                    Flags |= SPFILEQ_FILE_IN_USE;
                }
            }

            //
            // Check copy queues for in-use files.
            //
            for(SourceMedia=Queue->SourceMediaList; SourceMedia; SourceMedia=SourceMedia->Next) {
                for(QueueNode=SourceMedia->CopyQueue; QueueNode; QueueNode=QueueNode->Next) {

                    if(QueueNode->InternalFlags & INUSE_INF_WANTS_REBOOT) {
                        Flags |= SPFILEQ_REBOOT_RECOMMENDED;
                    }

                    if(QueueNode->InternalFlags & INUSE_IN_USE) {
                        Flags |= SPFILEQ_FILE_IN_USE;
                    }
                }
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            SetLastError(ERROR_INVALID_PARAMETER);
            Flags = -1;
        }
    } else {
        Flags = SPFILEQ_REBOOT_RECOMMENDED;
    }

    //
    // Ask the user if he wants to shut down, if necessary.
    //
    if(!ScanOnly &&
       (Flags & (SPFILEQ_REBOOT_RECOMMENDED | SPFILEQ_FILE_IN_USE)) &&
       (Flags != -1)) {
        if(RestartDialogEx(Owner,NULL,EWX_REBOOT,Reason) == IDYES) {
            Flags |= SPFILEQ_REBOOT_IN_PROGRESS;
        }
    }

    return(Flags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\fileqcb.c ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    fileqcb.c

Abstract:

    Routines to call out to file queue callbacks, translating
    character types as necessary.

Author:

    Ted Miller (tedm) Feb-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Define structure that describes, for a given structure, how to
// thunk it back and forth between ANSI and Unicode.
//
typedef struct _STRUCT_THUNK_DATA {
    //
    // Size of the structure
    //
    unsigned StructureSize;
    //
    // Offsets of members that are pointers to strings
    // that need conversion before calling the callback function.
    // A -1 terminates the list.
    //
    int StringMemberOffsets[5];
    //
    // Offsets of DWORD members that need to be copied back from
    // the temporary structure back into the caller's one.
    //
    int OutputDwordOffsets[2];
    //
    // Offsets of strings that need to be converted in place
    // after the callback has occurred.
    //
    int OutputStringOffsets[2];

} STRUCT_THUNK_DATA, *PSTRUCT_THUNK_DATA;

//
// Define enum for data types we care about for the setup message
// notification mechanism.
//
typedef enum {
    FileMsgFilepaths,           // FILEPATHS
    FileMsgSourcemedia,         // SOURCE_MEDIA
    FileMsgCabinetinfo,         // CABINET_INFO
    FileMsgFileincabinfo,       // FILE_IN_CABINET_INFO
    FileMsgControlStatus,       // SP_REGISTER_CONTROL_STATUS
    FileMsgNone,                // No translation (special case)
    FileMsgString,              // Plain string (special case)
    FileMsgStringOut            // String written by callback (special case)
} FileMsgStruct;

//
// Instantiate structure thunk data for structures we care about.
//
STRUCT_THUNK_DATA StructThunkData[] = {

                //
                // FILEPATHS structure
                //
                {
                    sizeof(FILEPATHS),

                    {
                        offsetof(FILEPATHS,Target),
                        offsetof(FILEPATHS,Source),
                        -1
                    },

                    { offsetof(FILEPATHS,Win32Error),-1 }, { -1 }
                },

                //
                // SOURCE_MEDIA structure
                //
                {
                    sizeof(SOURCE_MEDIA),

                    {
                        offsetof(SOURCE_MEDIA,Tagfile),
                        offsetof(SOURCE_MEDIA,Description),
                        offsetof(SOURCE_MEDIA,SourcePath),
                        offsetof(SOURCE_MEDIA,SourceFile),
                        -1
                    },

                    { -1 }, { -1 }
                },

                //
                // CABINET_INFO structure
                //
                {
                    sizeof(CABINET_INFO),

                    {
                        offsetof(CABINET_INFO,CabinetPath),
                        offsetof(CABINET_INFO,CabinetFile),
                        offsetof(CABINET_INFO,DiskName),
                        -1
                    },

                    { -1 }, { -1 }
                },

                //
                // FILE_IN_CABINET_INFO structure
                //
                {
                    sizeof(FILE_IN_CABINET_INFO),

                    {
                        offsetof(FILE_IN_CABINET_INFO,NameInCabinet),
                        -1
                    },

                    { offsetof(FILE_IN_CABINET_INFO,Win32Error),-1 },
                    { offsetof(FILE_IN_CABINET_INFO,FullTargetName),-1 }
                },

                //
                // SP_REGISTER_CONTROL_STATUS structure
                //
                {
                    sizeof(SP_REGISTER_CONTROL_STATUS),

                    {
                        offsetof(SP_REGISTER_CONTROL_STATUS,FileName),
                        -1
                    },

                    { -1 }, { -1 }

                }
            };


//
// Define structure that describes how to translate messages
// from ANSI<-->Unicode for all notification messages that we send out.
// and special return codes
//
typedef struct _MSG_THUNK_DATA {
    DWORD Notification;
    BOOL UseMask;
    FileMsgStruct Param1Type;
    FileMsgStruct Param2Type;
    UINT ExceptionReturn;
} MSG_THUNK_DATA, *PMSG_THUNK_DATA;

//
// Instantiate message thunk data.
// Entries marked as FILEOP_RETURN_STATUS indicate that the return value is a
// windows error code.
//
MSG_THUNK_DATA MsgThunkData[] =
{
 { SPFILENOTIFY_STARTQUEUE,        FALSE,FileMsgNone         ,FileMsgNone     ,FALSE               },
 { SPFILENOTIFY_ENDQUEUE,          FALSE,FileMsgNone         ,FileMsgNone     ,0                   },
 { SPFILENOTIFY_STARTSUBQUEUE,     FALSE,FileMsgNone         ,FileMsgNone     ,FALSE               },
 { SPFILENOTIFY_ENDSUBQUEUE,       FALSE,FileMsgNone         ,FileMsgNone     ,FALSE               },
 { SPFILENOTIFY_STARTDELETE,       FALSE,FileMsgFilepaths    ,FileMsgNone     ,FILEOP_ABORT        },
 { SPFILENOTIFY_ENDDELETE,         FALSE,FileMsgFilepaths    ,FileMsgNone     ,0                   },
 { SPFILENOTIFY_DELETEERROR,       FALSE,FileMsgFilepaths    ,FileMsgNone     ,FILEOP_ABORT        },
 { SPFILENOTIFY_STARTRENAME,       FALSE,FileMsgFilepaths    ,FileMsgNone     ,FILEOP_ABORT        },
 { SPFILENOTIFY_ENDRENAME,         FALSE,FileMsgFilepaths    ,FileMsgNone     ,0                   },
 { SPFILENOTIFY_RENAMEERROR,       FALSE,FileMsgFilepaths    ,FileMsgNone     ,FILEOP_ABORT        },
 { SPFILENOTIFY_STARTCOPY,         FALSE,FileMsgFilepaths    ,FileMsgNone     ,FILEOP_ABORT        },
 { SPFILENOTIFY_ENDCOPY,           FALSE,FileMsgFilepaths    ,FileMsgNone     ,0                   },
 { SPFILENOTIFY_COPYERROR,         FALSE,FileMsgFilepaths    ,FileMsgStringOut,FILEOP_ABORT        },
 { SPFILENOTIFY_NEEDMEDIA,         FALSE,FileMsgSourcemedia  ,FileMsgStringOut,FILEOP_ABORT        },
 { SPFILENOTIFY_QUEUESCAN,         FALSE,FileMsgString       ,FileMsgNone     ,FILEOP_RETURN_STATUS},
 { SPFILENOTIFY_QUEUESCAN_EX,      FALSE,FileMsgFilepaths    ,FileMsgNone     ,FILEOP_RETURN_STATUS},
 { SPFILENOTIFY_CABINETINFO,       FALSE,FileMsgCabinetinfo  ,FileMsgNone     ,FILEOP_RETURN_STATUS},
 { SPFILENOTIFY_FILEINCABINET,     FALSE,FileMsgFileincabinfo,FileMsgString   ,FILEOP_INTERNAL_FAILED},
 { SPFILENOTIFY_NEEDNEWCABINET,    FALSE,FileMsgCabinetinfo  ,FileMsgStringOut,FILEOP_RETURN_STATUS},
 { SPFILENOTIFY_FILEEXTRACTED,     FALSE,FileMsgFilepaths    ,FileMsgNone     ,FILEOP_RETURN_STATUS},
 { SPFILENOTIFY_FILEOPDELAYED,     FALSE,FileMsgFilepaths    ,FileMsgNone     ,0                   },
 { SPFILENOTIFY_STARTBACKUP,       FALSE,FileMsgFilepaths    ,FileMsgNone     ,FILEOP_ABORT        },
 { SPFILENOTIFY_ENDBACKUP,         FALSE,FileMsgFilepaths    ,FileMsgNone     ,0                   },
 { SPFILENOTIFY_BACKUPERROR,       FALSE,FileMsgFilepaths    ,FileMsgNone     ,FILEOP_ABORT        },
 { SPFILENOTIFY_STARTREGISTRATION, FALSE,FileMsgControlStatus,FileMsgNone     ,FILEOP_ABORT        },
 { SPFILENOTIFY_ENDREGISTRATION,   FALSE,FileMsgControlStatus,FileMsgNone     ,FILEOP_ABORT        },

 { SPFILENOTIFY_LANGMISMATCH
 | SPFILENOTIFY_TARGETEXISTS
 | SPFILENOTIFY_TARGETNEWER,       TRUE ,FileMsgFilepaths    ,FileMsgNone     ,FALSE               }
};

//
// Forward references.
//
BOOL
pSetupConvertMsgHandlerArgs(
    IN  UINT  Notification,
    IN  UINT_PTR Param1,
    IN  UINT_PTR Param2,
    OUT PUINT_PTR NewParam1,
    OUT PUINT_PTR NewParam2,
    IN  BOOL  ToAnsi,
    OUT PMSG_THUNK_DATA *ThunkData
    );

BOOL
pThunkSetupMsgParam(
    IN  FileMsgStruct StructType,
    IN  UINT_PTR      Param,
    OUT UINT_PTR     *NewParam,
    IN  BOOL          ToAnsi
    );

VOID
pUnthunkSetupMsgParam(
    IN     FileMsgStruct StructType,
    IN OUT UINT_PTR      OriginalParam,
    IN OUT UINT_PTR      ThunkedParam,
    IN     BOOL          FreeOnly,
    IN     BOOL          ThunkedToAnsi
    );

UINT
pGetCallbackErrorReturn(
    IN UINT Notification,
    IN DWORD ReturnStatus
    )
/*++

Routine Description:

    Determine return value for given notification and given ReturnStatus.

Arguments:

    Notification - supplies notification

Return Value:

    Return code specific to the notification.

--*/
{
    unsigned u;
    PMSG_THUNK_DATA thunkData;
    BOOL KnownMessage;

    MYASSERT(ReturnStatus);

    //
    // Locate the msg-specific thunk data descriptor.
    //
    KnownMessage = FALSE;
    for(u=0; !KnownMessage && (u<(sizeof(MsgThunkData)/sizeof(MsgThunkData[0]))); u++) {

        thunkData = &MsgThunkData[u];

        if(thunkData->UseMask) {
            KnownMessage = ((thunkData->Notification & Notification) != 0);
        } else {
            KnownMessage = (thunkData->Notification == Notification);
        }
    }
    SetLastError(ReturnStatus);
    if (!KnownMessage) {
        MYASSERT(KnownMessage);
        SetLastError(ReturnStatus);
        return 0;
    } else if(thunkData->ExceptionReturn == FILEOP_RETURN_STATUS) {
        return ReturnStatus;
    } else {
        return thunkData->ExceptionReturn;
    }
}

#ifdef UNICODE

UINT
pSetupCallMsgHandler(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN PVOID MsgHandler,
    IN BOOL  MsgHandlerIsNativeCharWidth,
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )

/*++

Routine Description:

    Call out to a SP_FILE_CALLBACK routine, translating arguments from
    Unicode to ANSI as necessary, and marshalling data back into Unicode
    as necessary.

    Conversions and marshalling occur only for messages we recognize
    (ie, that are in the MsgThunkData array). Unrecognized messages
    are assumed to be private and are passed through unchanged.

    If a Unicode->ANSI conversion fails due to an out of memory condition,
    this routine sets last error to ERROR_NOT_ENOUGH_MEMORY and returns
    the value specified in the relevent MsgThunkData structure.

Arguments:

    LogContext - context for logging errors

    MsgHandler - supplies pointer to callback routine. Can be either
        a routine expecting ANSI args or Unicode args, as specified
        by MsgHandlerIsNativeCharWidth.

    MsgHandlerIsNativeCharWidth - supplies flag indicating whether callback
        functionexpects Unicode (TRUE) or ANSI (FALSE) arguments.

    Context - supplies context data meaningful to the callback
        routine. Not interpreted by this routine, merely passed on.

    Notification - supplies notification code to be passed to the callback.

    Param1 - supplies first notification-specific parameter to be passed
        to the callback.

    Param2 - supplies second notification-specific parameter to be passed
        to the callback.

Return Value:

    Return code specific to the notification.

--*/

{
    PSP_FILE_CALLBACK_A MsgHandlerA;
    PSP_FILE_CALLBACK_W MsgHandlerW;
    UINT rc,ec;
    UINT_PTR Param1A,Param2A;
    BOOL b;
    PMSG_THUNK_DATA ThunkData;

    //
    // If already unicode, nothing to do, just call the msghandler.
    //
    if(MsgHandlerIsNativeCharWidth) {
        MsgHandlerW = (PSP_FILE_CALLBACK_W)MsgHandler;
        try {
            SetLastError(NO_ERROR);
            rc = MsgHandlerW(Context,Notification,Param1,Param2);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            WriteLogEntry(
              LogContext,
              SETUP_LOG_ERROR,
              MSG_LOG_QUEUE_CALLBACK_FAILED,
              NULL,
              GetExceptionCode());
            rc = pGetCallbackErrorReturn(Notification,ERROR_INVALID_DATA);
        }
        return rc;
    }

    //
    // Optimization: if we are going to call the ANSI version of the
    // default queue callback routine SetupDefaultQueueCallbackA(),
    // we can avoid converting the args, since they'll just be converted
    // right back again by that API as a prelude to calling the
    // actual implementation SetupDefaultQueueCallbackW().
    //
    if(MsgHandler == SetupDefaultQueueCallbackA) {
        SetLastError(NO_ERROR);
        return(SetupDefaultQueueCallbackW(Context,Notification,Param1,Param2));
    }

    //
    // Target callback function is expecting ANSI arguments.
    //
    b = pSetupConvertMsgHandlerArgs(
            Notification,
            Param1,
            Param2,
            &Param1A,
            &Param2A,
            TRUE,
            &ThunkData
            );

    if(!b) {
        return pGetCallbackErrorReturn(Notification,ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Agrs are ready; call out to the ANSI callback.
    //
    MsgHandlerA = MsgHandler;
    try {
        SetLastError(NO_ERROR);
        rc = MsgHandlerA(Context,Notification,Param1A,Param2A);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        WriteLogEntry(
            LogContext,
            SETUP_LOG_ERROR,
            MSG_LOG_QUEUE_CALLBACK_FAILED,
            NULL,
            GetExceptionCode());
        rc = pGetCallbackErrorReturn(Notification,ERROR_INVALID_DATA);
    }
    ec = GetLastError();

    //
    // Free the temporary thunk structs and marshall data back into
    // the original structures as necessary.
    //
    if(ThunkData) {
        pUnthunkSetupMsgParam(ThunkData->Param1Type,Param1,Param1A,FALSE,TRUE);
        pUnthunkSetupMsgParam(ThunkData->Param2Type,Param2,Param2A,FALSE,TRUE);
    }

    SetLastError(ec);
    return(rc);
}


UINT
pSetupCallDefaultMsgHandler(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    UINT_PTR Param1U,Param2U;
    BOOL b;
    PMSG_THUNK_DATA ThunkData;
    UINT rc,ec;

    //
    // Thunk args to Unicode.
    //
    b = pSetupConvertMsgHandlerArgs(
            Notification,
            Param1,
            Param2,
            &Param1U,
            &Param2U,
            FALSE,
            &ThunkData
            );

    if(!b) {
        return pGetCallbackErrorReturn(Notification,ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Agrs are ready; call the default queue callback.
    //
    rc = SetupDefaultQueueCallbackW(Context,Notification,Param1U,Param2U);
    ec = GetLastError();

    //
    // Free the temporary thunk structs and marshall data back into
    // the original structures as necessary.
    //
    if(ThunkData) {
        pUnthunkSetupMsgParam(ThunkData->Param1Type,Param1,Param1U,FALSE,FALSE);
        pUnthunkSetupMsgParam(ThunkData->Param2Type,Param2,Param2U,FALSE,FALSE);
    }

    SetLastError(ec);
    return(rc);
}



BOOL
pSetupConvertMsgHandlerArgs(
    IN  UINT  Notification,
    IN  UINT_PTR Param1,
    IN  UINT_PTR Param2,
    OUT PUINT_PTR NewParam1,
    OUT PUINT_PTR NewParam2,
    IN  BOOL  ToAnsi,
    OUT PMSG_THUNK_DATA *ThunkData
    )

/*++

Routine Description:

    Locate thunk description data for a given notification and convert
    parameters from Unicode to ANSI or ANSI to Unicode.

Arguments:

    Notification - supplies notification code to be passed to the callback.

    Param1 - supplies first notification-specific parameter to be passed
        to the callback, which is to be converted.

    Param2 - supplies second notification-specific parameter to be passed
        to the callback, which is to be converted.

    NewParam1 - receives first notification-specific parameter to be passed
        to the callback.

    NewParam2 - receives second notification-specific parameter to be passed
        to the callback.

    ToAnsi - supplies flag indicating whether parameters are to be converted
        from ANSI to Unicode or Unicode to ANSI.

    ThunkData - if the Notification is recognized, receives a pointer to
        the MSG_THUNK_DATA for the given Notification. If not recognized,
        receives NULL.

Return Value:

    Boolean value indicating whether conversion was successful.
    If FALSE, the caller can assume out of memory.

--*/

{
    unsigned u;
    PMSG_THUNK_DATA thunkData;
    BOOL KnownMessage;

    //
    // Locate the msg-specific thunk data descriptor.
    //
    KnownMessage = FALSE;
    for(u=0; !KnownMessage && (u<(sizeof(MsgThunkData)/sizeof(MsgThunkData[0]))); u++) {

        thunkData = &MsgThunkData[u];

        if(thunkData->UseMask) {
            KnownMessage = ((thunkData->Notification & Notification) != 0);
        } else {
            KnownMessage = (thunkData->Notification == Notification);
        }
    }

    if(!KnownMessage) {
        //
        // Unknown message; must be private. Just pass args on as-is.
        //
        *NewParam1 = Param1;
        *NewParam2 = Param2;
        *ThunkData = NULL;
    } else {
        //
        // Got a message we understand. Thunk it.
        //
        *ThunkData = thunkData;

        if(!pThunkSetupMsgParam(thunkData->Param1Type,Param1,NewParam1,ToAnsi)) {
            return(FALSE);
        }

        if(!pThunkSetupMsgParam(thunkData->Param2Type,Param2,NewParam2,ToAnsi)) {
            pUnthunkSetupMsgParam(thunkData->Param1Type,Param1,*NewParam1,TRUE,ToAnsi);
            return(FALSE);
        }
    }

    return(TRUE);
}


BOOL
pThunkSetupMsgParam(
    IN  FileMsgStruct StructType,
    IN  UINT_PTR      Param,
    OUT UINT_PTR     *NewParam,
    IN  BOOL          ToAnsi
    )

/*++

Routine Description:

    Convert a parameter to a setup notification callback from ANSI to
    Unicode or Unicode to ANSI as necessary. Allocates all required memory
    and performs conversions.

Arguments:

    StructType - supplies type of data represented by Param.

    Param - supplies parameter to be converted.

    NewParam - receives new parameter. Caller should free via
        pUnthunkSetupMsgParam when done.

    ToAnsi - if FALSE, Param is to be converted from ANSI to Unicode.
        If TRUE, Param is to be converted from Unicode to ANSI.

Return Value:

    Boolean value indicating whether conversion occured successfully.
    If FALSE, the caller can assume out of memory.

--*/

{
    unsigned u,v;
    PUCHAR newStruct;
    PVOID OldString;
    PVOID NewString;

    //
    // Handle special cases here.
    //
    switch(StructType) {

    case FileMsgNone:
        *NewParam = Param;
        return(TRUE);

    case FileMsgStringOut:
        //
        // Callee will write string data which we will convert later.
        //
        if(*NewParam = (UINT_PTR)MyMalloc(MAX_PATH * (ToAnsi ? sizeof(CHAR) : sizeof(WCHAR)))) {
            if(ToAnsi) {
                *(PCHAR)(*NewParam) = 0;
            } else {
                *(PWCHAR)(*NewParam) = 0;
            }
        }
        return(*NewParam != 0);

    case FileMsgString:
        if(ToAnsi) {
            *NewParam = (UINT_PTR)pSetupUnicodeToAnsi((PCWSTR)Param);
        } else {
            *NewParam = (UINT_PTR)pSetupAnsiToUnicode((PCSTR)Param);
        }
        return(*NewParam != 0);
    }

    newStruct = MyMalloc(StructThunkData[StructType].StructureSize);
    if(!newStruct) {
        return(FALSE);
    }

    CopyMemory(newStruct,(PVOID)Param,StructThunkData[StructType].StructureSize);

    for(u=0; StructThunkData[StructType].StringMemberOffsets[u] != -1; u++) {

        OldString = *(PVOID *)((PUCHAR)Param + StructThunkData[StructType].StringMemberOffsets[u]);

        if(OldString) {
            if(ToAnsi) {
                NewString = pSetupUnicodeToAnsi(OldString);
            } else {
                NewString = pSetupAnsiToUnicode(OldString);
            }

            if(!NewString) {
                for(v=0; v<u; v++) {
                    MyFree(*(PVOID *)(newStruct + StructThunkData[StructType].StringMemberOffsets[v]));
                }

                MyFree(newStruct);
                return(FALSE);
            }

            *(PVOID *)(newStruct + StructThunkData[StructType].StringMemberOffsets[u]) = NewString;
        }
    }

    *NewParam = (UINT_PTR)newStruct;
    return(TRUE);
}


VOID
pUnthunkSetupMsgParam(
    IN     FileMsgStruct StructType,
    IN OUT UINT_PTR      OriginalParam,
    IN OUT UINT_PTR      ThunkedParam,
    IN     BOOL          FreeOnly,
    IN     BOOL          ThunkedToAnsi
    )

/*++

Routine Description:

    Marshal data output by a callback function back into the original
    Unicode or ANSI structure. Also, free the temporary structure and all
    its resources.

Arguments:

    StructType - supplies type of data being operated on.

    OriginalParam - supplies original parameter. DWORD fields and
        in-place strings in this structure will be updated by this routine.

    ThunkedParam - supplies temporary ANSI or Unicode parameter.

    FreeOnly - if TRUE, no marshalling occurs but ThunkedParam will be freed.

Return Value:

    None.

--*/

{
    unsigned u;
    PVOID String;
    PVOID SourceString;
    DWORD d;

    //
    // Special cases here.
    //
    switch(StructType) {

    case FileMsgNone:
        //
        // Nothing to do for this one.
        //
        return;

    case FileMsgStringOut:
        //
        // Callee wrote string data; convert as appropriate.
        //
        if(!FreeOnly) {

            if(ThunkedToAnsi) {

                MultiByteToWideChar(
                    CP_ACP,
                    0,
                    (PCSTR)ThunkedParam,
                    -1,
                    (PWCHAR)OriginalParam,
                    MAX_PATH
                    );

            } else {

                WideCharToMultiByte(
                    CP_ACP,
                    0,
                    (PCWSTR)ThunkedParam,
                    -1,
                    (PCHAR)OriginalParam,
                    MAX_PATH,
                    NULL,
                    NULL
                    );
            }
        }
        MyFree((PVOID)ThunkedParam);
        return;

    case FileMsgString:
        //
        // Simple string.
        //
        MyFree((PVOID)ThunkedParam);
        return;
    }

    //
    // Free all strings.
    //
    for(u=0; StructThunkData[StructType].StringMemberOffsets[u] != -1; u++) {

        String = *(PVOID *)((PUCHAR)ThunkedParam + StructThunkData[StructType].StringMemberOffsets[u]);

        if(String) {
            MyFree(String);
        }
    }

    //
    // Marshall data back to Unicode structure
    //
    if(!FreeOnly) {
        //
        // Copy DWORD data from the thunk struct back to the original struct.
        //
        for(u=0; StructThunkData[StructType].OutputDwordOffsets[u] != -1; u++) {

            d = *(DWORD *)((PUCHAR)ThunkedParam + StructThunkData[StructType].OutputDwordOffsets[u]);

            *(DWORD *)((PUCHAR)OriginalParam + StructThunkData[StructType].OutputDwordOffsets[u]) = d;
        }

        //
        // Convert output strings.
        //
        for(u=0; StructThunkData[StructType].OutputStringOffsets[u] != -1; u++) {

            SourceString = (PUCHAR)ThunkedParam  + StructThunkData[StructType].OutputStringOffsets[u];
            String       = (PUCHAR)OriginalParam + StructThunkData[StructType].OutputStringOffsets[u];

            if(ThunkedToAnsi) {
                MultiByteToWideChar(
                    CP_ACP,
                    0,
                    SourceString,
                    -1,
                    String,
                    MAX_PATH
                    );
            } else {
                WideCharToMultiByte(
                    CP_ACP,
                    0,
                    SourceString,
                    -1,
                    String,
                    MAX_PATH,
                    NULL,
                    NULL
                    );
            }
        }
    }

    MyFree((PVOID)ThunkedParam);
}



#else

UINT
pSetupCallMsgHandler(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN PVOID MsgHandler,
    IN BOOL  MsgHandlerIsNativeCharWidth,
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    PSP_FILE_CALLBACK_A msghandler;
    UINT result = 0;

    UNREFERENCED_PARAMETER(MsgHandlerIsNativeCharWidth);
    MYASSERT(MsgHandlerIsNativeCharWidth);

    //
    // ANSI version has no thunking
    //
    try {

        msghandler = (PSP_FILE_CALLBACK_A)MsgHandler;
        result = msghandler(Context,Notification,Param1,Param2);

    } except(EXCEPTION_EXECUTE_HANDLER) {
        WriteLogEntry(
            LogContext,
            SETUP_LOG_ERROR,
            MSG_LOG_QUEUE_CALLBACK_FAILED,
            NULL,
            GetExceptionCode());
        result = pGetCallbackErrorReturn(Notification,ERROR_INVALID_DATA);
    }

    return result;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\fusion.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    fusion.c

Abstract:

    Wrappers and functions for fusionizing SetupAPI
    without effecting 3rd party DLL's
    and without dll-load overhead

Author:

    Jamie Hunter (JamieHun) 12/4/2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef FUSIONAWARE

#undef CreateWindow
#undef CreateWindowEx
#undef CreateDialogParam
#undef CreateDialogIndirectParam
#undef DialogBoxParam
#undef DialogBoxIndirectParam
#undef MessageBox
#undef CreatePropertySheetPage
#undef DestroyPropertySheetPage
#undef PropertySheet
#undef ImageList_Create
#undef ImageList_Destroy
#undef ImageList_GetImageCount
#undef ImageList_SetImageCount
#undef ImageList_Add
#undef ImageList_ReplaceIcon
#undef ImageList_SetBkColor
#undef ImageList_GetBkColor
#undef ImageList_SetOverlayImage

#include <shfusion.h>

static CRITICAL_SECTION spFusionInitCritSec;
static BOOL spInitFusionCritSec = FALSE;
static BOOL spFusionDoneInit = FALSE;

BOOL spFusionInitialize()
/*++

Routine Description:

    Called on DllLoad
    do minimum possible


Arguments:

    none

Return Value:

    TRUE successful initialization

--*/
{
    try {
        InitializeCriticalSection(&spFusionInitCritSec);
        spInitFusionCritSec = TRUE;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // spInitFusionCritSec remains FALSE
        //
    }
    return spInitFusionCritSec;
}


VOID
spFusionInitLong()
/*++

Routine Description:

    Called by internal stub to do real initialization


Arguments:

    none

Return Value:

    none

--*/
{
    BOOL locked = FALSE;
    BOOL success = FALSE;
    INITCOMMONCONTROLSEX CommCtrl;

    if(!spInitFusionCritSec) {
        //
        // critical section not initialized
        // probably out of memory
        // bail
        //
        MYASSERT(spInitFusionCritSec);
        spFusionDoneInit = TRUE;
        return;
    }
    try {
        EnterCriticalSection(&spFusionInitCritSec);
        locked = TRUE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }
    if(!locked) {
        //
        // wasn't able to grab lock - probably out of memory
        // bail
        //
        spFusionDoneInit = TRUE;
        return;
    }

    if(spFusionDoneInit) {
        //
        // by the time we grabbed critical section
        // initialization was done
        // bail
        //
        LeaveCriticalSection(&spFusionInitCritSec);
        return;
    }

    //
    // call shell's fusion enabler
    //
    success = SHFusionInitializeFromModuleID(MyDllModuleHandle,IDR_MANIFEST);
    MYASSERT(success);
    ZeroMemory(&CommCtrl,sizeof(CommCtrl));
    CommCtrl.dwSize = sizeof(CommCtrl);
    CommCtrl.dwICC = ICC_WIN95_CLASSES | ICC_LINK_CLASS;
    success = InitCommonControlsEx(&CommCtrl);
    MYASSERT(success);

    //
    // at this point, it's now safe for anyone else to assume initialization is done
    // even if we haven't released critical section
    //
    spFusionDoneInit = TRUE;

    LeaveCriticalSection(&spFusionInitCritSec);
}

__inline
VOID
spFusionCheckInit()
/*++

Routine Description:

    Calls spFusionInitLong iff needed

Arguments:

    none

Return Value:

    none

--*/
{
    if(!spFusionDoneInit) {
        //
        // either not initialized, or currently going through initialization
        //
        spFusionInitLong();
    }
}

BOOL spFusionUninitialize(BOOL Full)
/*++

Routine Description:

    Called at DLL exit (if DLL being unloaded but not process Exit)

Arguments:

    none

Return Value:

    TRUE successful cleanup

--*/
{
    //
    // cleanup anything initialized at spFusionInitialize
    //
    if(spInitFusionCritSec) {
        DeleteCriticalSection(&spFusionInitCritSec);
        spInitFusionCritSec = FALSE;
    }
    if(Full && spFusionDoneInit) {
        SHFusionUninitialize();
    }
    return TRUE;
}

//
// generic functions for dealing with 3rd party DLL's
// that might be fusionized
//

HANDLE
spFusionContextFromModule(
    IN PCTSTR ModuleName
    )
/*++

Routine Description:

    Called to get a fusion context for specified module name
    given blah.dll look for
        1) blah.dll.manifest in same directory as blah.dll
        2) blah.dll with a fusion resource ID 123.
    If either of these provide a valid manifest, use it
    otherwise use app global manifest.

Arguments:

    name of module that'll later be passed into LoadLibrary

Return Value:

    fusion context

--*/
{
    ACTCTX act = { 0 };
    HANDLE hContext;
    TCHAR ManifestName[MAX_PATH+10];
    PTSTR End;
    DWORD len;

    act.cbSize = sizeof(act);

    //
    // based loosely on rundll32 code
    // however we look for manifest in same directory as the dll
    // so look for dll first
    //
    len = SearchPath(NULL,ModuleName,NULL,MAX_PATH,ManifestName,NULL);
    if(len>=MAX_PATH) {
        //
        // path length of DLL too big, just use global context
        //
        goto deflt;
    }
    if(!len) {
        len = lstrlen(ModuleName);
        if(len>=MAX_PATH) {
            goto deflt;
        }
        lstrcpy(ManifestName,ModuleName);
    }
    if(GetFileAttributes(ManifestName) == -1) {
        //
        // didn't find DLL?
        //
        goto deflt;
    }

    lstrcpy(ManifestName+len,TEXT(".Manifest"));
    if(GetFileAttributes(ManifestName) != -1) {
        //
        // found manifest
        //
        act.lpSource = ManifestName;
        act.dwFlags = 0;
        hContext = CreateActCtx(&act);
        if(hContext != INVALID_HANDLE_VALUE) {
            //
            // we created context based on manifest file
            //
            return hContext;
        }
    }

deflt:
    //
    // if the dll has a manifest resource
    // then use that
    //
    act.lpSource = ModuleName;
//    act.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID;
//    act.lpResourceName = MAKEINTRESOURCE(123);
    act.dwFlags = 0;

    hContext = CreateActCtx(&act);

    if(hContext != INVALID_HANDLE_VALUE) {
        //
        // we created context based on resource
        //
        return hContext;
    }
    //
    // if we couldn't find an alternative, use app-global
    //
    return NULL;
}

BOOL
spFusionKillContext(
    IN HANDLE hContext
    )
/*++

Routine Description:

    Release a context previously obtained by
    spFusionContextFromModule

Arguments:

    fusion context

Return Value:

    TRUE (always)

--*/
{
    if(hContext) {
        ReleaseActCtx(hContext);
    }
    return TRUE;
}

BOOL
spFusionEnterContext(
    IN  HANDLE hContext,
    OUT PSPFUSIONINSTANCE pInst
    )
/*++

Routine Description:

    Enter into a manifest context
    status of call is saved into pInst
    so that return value does not need
    to be checked

Arguments:

    hContext = fusion context
    pInst    = structure to save the "push" information

Return Value:

    TRUE if success, FALSE otherwise

--*/
{
    pInst->Acquired = ActivateActCtx(hContext,&pInst->Cookie);
    MYASSERT(pInst->Acquired);
    return pInst->Acquired;
}

BOOL
spFusionLeaveContext(
    IN PSPFUSIONINSTANCE pInst
    )
/*++

Routine Description:

    If pInst indicates that spFusionEnterContext
    succeeded, leave same context

Arguments:

    pInst = structure initialized by spFusionEnterContext

Return Value:

    TRUE if spFusionEnterContext succeeded, FALSE otherwise

--*/
{
    if(pInst->Acquired) {
        pInst->Acquired = FALSE;
        DeactivateActCtx(0,pInst->Cookie);
        return TRUE;
    } else {
        return FALSE;
    }
}

HWND spFusionCreateWindow(
            LPCTSTR lpClassName,  // registered class name
            LPCTSTR lpWindowName, // window name
            DWORD dwStyle,        // window style
            int x,                // horizontal position of window
            int y,                // vertical position of window
            int nWidth,           // window width
            int nHeight,          // window height
            HWND hWndParent,      // handle to parent or owner window
            HMENU hMenu,          // menu handle or child identifier
            HINSTANCE hInstance,  // handle to application instance
            LPVOID lpParam        // window-creation data
            )
{
    spFusionCheckInit();
    return SHFusionCreateWindow(lpClassName,
                                lpWindowName,
                                dwStyle,
                                x,
                                y,
                                nWidth,
                                nHeight,
                                hWndParent,
                                hMenu,
                                hInstance,
                                lpParam
                                );
}

HWND spFusionCreateWindowEx(
            DWORD dwExStyle,      // extended window style
            LPCTSTR lpClassName,  // registered class name
            LPCTSTR lpWindowName, // window name
            DWORD dwStyle,        // window style
            int x,                // horizontal position of window
            int y,                // vertical position of window
            int nWidth,           // window width
            int nHeight,          // window height
            HWND hWndParent,      // handle to parent or owner window
            HMENU hMenu,          // menu handle or child identifier
            HINSTANCE hInstance,  // handle to application instance
            LPVOID lpParam        // window-creation data
            )
{
    spFusionCheckInit();
    return SHFusionCreateWindowEx(dwExStyle,
                                  lpClassName,
                                  lpWindowName,
                                  dwStyle,
                                  x,
                                  y,
                                  nWidth,
                                  nHeight,
                                  hWndParent,
                                  hMenu,
                                  hInstance,
                                  lpParam
                                  );
}

HWND spFusionCreateDialogParam(
            HINSTANCE hInstance,     // handle to module
            LPCTSTR lpTemplateName,  // dialog box template
            HWND hWndParent,         // handle to owner window
            DLGPROC lpDialogFunc,    // dialog box procedure
            LPARAM dwInitParam       // initialization value
    )
{
    spFusionCheckInit();
    return SHFusionCreateDialogParam(
                            hInstance,
                            lpTemplateName,
                            hWndParent,
                            lpDialogFunc,
                            dwInitParam
                            );
}

HWND spFusionCreateDialogIndirectParam(
            HINSTANCE hInstance,        // handle to module
            LPCDLGTEMPLATE lpTemplate,  // dialog box template
            HWND hWndParent,            // handle to owner window
            DLGPROC lpDialogFunc,       // dialog box procedure
            LPARAM lParamInit           // initialization value
    )
{
    spFusionCheckInit();
    return SHFusionCreateDialogIndirectParam(
                            hInstance,
                            lpTemplate,
                            hWndParent,
                            lpDialogFunc,
                            lParamInit
                            );
}

INT_PTR spFusionDialogBoxParam(
            HINSTANCE hInstance,     // handle to module
            LPCTSTR lpTemplateName,  // dialog box template
            HWND hWndParent,         // handle to owner window
            DLGPROC lpDialogFunc,    // dialog box procedure
            LPARAM dwInitParam       // initialization value
    )
{
    spFusionCheckInit();
    return SHFusionDialogBoxParam(
                            hInstance,
                            lpTemplateName,
                            hWndParent,
                            lpDialogFunc,
                            dwInitParam
                            );
}

INT_PTR spFusionDialogBoxIndirectParam(
            HINSTANCE hInstance,             // handle to module
            LPCDLGTEMPLATE hDialogTemplate,  // dialog box template
            HWND hWndParent,                 // handle to owner window
            DLGPROC lpDialogFunc,            // dialog box procedure
            LPARAM dwInitParam               // initialization value
    )
{
    spFusionCheckInit();
    return SHFusionDialogBoxIndirectParam(
                            hInstance,
                            hDialogTemplate,
                            hWndParent,
                            lpDialogFunc,
                            dwInitParam
                            );
}

int spFusionMessageBox(
            IN HWND hWnd,
            IN LPCTSTR lpText,
            IN LPCTSTR lpCaption,
            IN UINT uType
            )
{
    ULONG_PTR dwCookie;
    BOOL act;
    int iRes = 0;
    spFusionCheckInit();
    act = SHActivateContext(&dwCookie);
    try {
        iRes = MessageBoxW(
                        hWnd,
                        lpText,
                        lpCaption,
                        uType
                        );
    } finally {
        if(act) {
            SHDeactivateContext(dwCookie);
        }
    }
    return iRes;
}

INT_PTR spFusionPropertySheet(
            LPCPROPSHEETHEADER pPropSheetHeader
    )
{
    spFusionCheckInit();
    return PropertySheetW(pPropSheetHeader);
}

HPROPSHEETPAGE spFusionCreatePropertySheetPage(
            LPPROPSHEETPAGE pPropSheetPage
    )
{
    spFusionCheckInit();
    MYASSERT(pPropSheetPage->dwFlags & PSP_USEFUSIONCONTEXT);
    MYASSERT(!pPropSheetPage->hActCtx);
    MYASSERT(pPropSheetPage->dwSize >= sizeof(PROPSHEETPAGE));

    return CreatePropertySheetPageW(pPropSheetPage);
}

BOOL spFusionDestroyPropertySheetPage(
            HPROPSHEETPAGE hPropSheetPage
            )
{
    spFusionCheckInit();
    return DestroyPropertySheetPage(
                            hPropSheetPage
                            );
}


HIMAGELIST spFusionImageList_Create(int cx, int cy, UINT flags, int cInitial, int cGrow)
{
    spFusionCheckInit();
    return ImageList_Create(
                            cx,
                            cy,
                            flags,
                            cInitial,
                            cGrow
                            );
}

BOOL spFusionImageList_Destroy(HIMAGELIST himl)
{
    spFusionCheckInit();
    return ImageList_Destroy(
                            himl
                            );
}

int spFusionImageList_Add(HIMAGELIST himl, HBITMAP hbmImage, HBITMAP hbmMask)
{
    spFusionCheckInit();
    return ImageList_Add(
                            himl,
                            hbmImage,
                            hbmMask
                            );

}

int spFusionImageList_ReplaceIcon(HIMAGELIST himl, int i, HICON hicon)
{
    spFusionCheckInit();
    return ImageList_ReplaceIcon(
                            himl,
                            i,
                            hicon
                            );
}

COLORREF spFusionImageList_SetBkColor(HIMAGELIST himl, COLORREF clrBk)
{
    spFusionCheckInit();
    return ImageList_SetBkColor(
                            himl,
                            clrBk
                            );
}

BOOL spFusionImageList_SetOverlayImage(HIMAGELIST himl, int iImage, int iOverlay)
{
    spFusionCheckInit();
    return ImageList_SetOverlayImage(
                            himl,
                            iImage,
                            iOverlay
                            );
}

BOOL spFusionGetOpenFileName(LPOPENFILENAME lpofn)
{
    spFusionCheckInit();
    return GetOpenFileNameW(lpofn);
}


#endif // FUSIONAWARE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\fileutil.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    fileutil.c

Abstract:

    File-related functions for Windows NT Setup API dll.

Author:

    Ted Miller (tedm) 11-Jan-1995

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop
#include <ntverp.h>

//
// This guid is used for file signing/verification.
//
GUID DriverVerifyGuid = DRIVER_ACTION_VERIFY;

//
// Instantiate exception class GUID.
//
#include <initguid.h>
DEFINE_GUID( GUID_DEVCLASS_WINDOWS_COMPONENT_PUBLISHER, 0xF5776D81L, 0xAE53, 0x4935, 0x8E, 0x84, 0xB0, 0xB2, 0x83, 0xD8, 0xBC, 0xEF );

// Bit 0 indicates policy for filters (0 = critical, 1 = non-critical)
#define DDB_DRIVER_POLICY_CRITICAL_BIT      (1 << 0)
// Bit 1 indicates policy for user-mode setup blocking (0 = block, 1 = no-block)
#define DDB_DRIVER_POLICY_SETUP_NO_BLOCK_BIT   (1 << 1)


//
// Global list of device setup classes subject to driver signing policy, along
// validation platform overrides (where applicable).
//
DRVSIGN_POLICY_LIST GlobalDrvSignPolicyList;

//
// private function prototypes
//
BOOL
ClassGuidInDrvSignPolicyList(
    IN  PSETUP_LOG_CONTEXT       LogContext,           OPTIONAL
    IN  CONST GUID              *DeviceSetupClassGuid, OPTIONAL
    OUT PSP_ALTPLATFORM_INFO_V2 *ValidationPlatform    OPTIONAL
    );

//
// helper to determine log level to use
//
__inline
DWORD
GetCatLogLevel(DWORD Err)
{
    switch(Err) {
        case ERROR_FILE_NOT_FOUND:
        case ERROR_PATH_NOT_FOUND:
        case E_NOTIMPL:
            return SETUP_LOG_VVERBOSE;

        default:
            return SETUP_LOG_INFO;
    }
}

DWORD
ReadAsciiOrUnicodeTextFile(
    IN  HANDLE                FileHandle,
    OUT PTEXTFILE_READ_BUFFER Result,
    IN  PSETUP_LOG_CONTEXT    LogContext OPTIONAL
    )

/*++

Routine Description:

    Read in a text file that may be in either ascii or unicode format.
#ifdef UNICODE
    If the file is ascii, it is assumed to be ANSI format and is converted
    to Unicode.
#else
    If the file is unicode, it will be converted to ascii using the ANSI
    codepage.

    NOTE:  On Windows 95, the IsTextUnicode API is not implemented, thus
    the unicode file must have a byte order mark (BOM) in order for us to
    recognize it under Win95.
#endif

Arguments:

    FileHandle - Supplies the handle of the text file to be read.

    Result - supplies the address of a TEXTFILE_READ_BUFFER structure that
        receives information about the text file buffer read.  The structure
        is defined as follows:

            typedef struct _TEXTFILE_READ_BUFFER {
                PCTSTR  TextBuffer;
                DWORD   TextBufferSize;
                HANDLE  FileHandle;
                HANDLE  MappingHandle;
                PVOID   ViewAddress;
            } TEXTFILE_READ_BUFFER, *PTEXTFILE_READ_BUFFER;

            TextBuffer - pointer to the read-only character string containing
                the entire text of the file.
                (NOTE: If the file is a Unicode file with a Byte Order Mark
                prefix, this Unicode character is not included in the returned
                buffer.)
            TextBufferSize - size of the TextBuffer (in characters).
            FileHandle - If this is a valid handle (i.e., it's not equal to
                INVALID_HANDLE_VALUE), then the file was already the native
                character type, so the TextBuffer is simply the mapped-in image
                of the file.  This field is reserved for use by the
                DestroyTextFileReadBuffer routine, and should not be accessed.
            MappingHandle - If FileHandle is valid, then this contains the
                mapping handle for the file image mapping.
                This field is reserved for use by the DestroyTextFileReadBuffer
                routine, and should not be accessed.
            ViewAddress - If FileHandle is valid, then this contains the
                starting memory address where the file image was mapped in.
                This field is reserved for use by the DestroyTextFileReadBuffer
                routine, and should not be accessed.

    LogContext - for logging of errors/tracing

Return Value:

    Win32 error value indicating the outcome.

Remarks:

    Upon return from this routine, the caller MUST NOT attempt to close FileHandle.
    This routine with either close the handle itself (after it's finished with it, or
    upon error), or it will store the handle away in the TEXTFILE_READ_BUFFER struct,
    to be later closed via DestroyTextFileReadBuffer().

--*/

{
    DWORD rc;
    DWORD FileSize;
    HANDLE MappingHandle;
    PVOID ViewAddress, TextStartAddress;
    BOOL IsNativeChar;
#ifdef UNICODE
    UINT SysCodePage = CP_ACP;
#endif
    //
    // Map the file for read access.
    //
    rc = pSetupMapFileForRead(
            FileHandle,
            &FileSize,
            &MappingHandle,
            &ViewAddress
            );

    if(rc != NO_ERROR) {
        //
        // We couldn't map the file--close the file handle now.
        //
        CloseHandle(FileHandle);

    } else {

        //
        // Determine whether the file is unicode.  Guard with try/except in
        // case we get an inpage error.
        //
        try {
            //
            // Check to see if the file starts with a Unicode Byte Order Mark
            // (BOM) character (0xFEFF).  If so, then we know that the file
            // is Unicode, and don't have to go through the slow process of
            // trying to figure it out.
            //
            TextStartAddress = ViewAddress;

            if((FileSize >= sizeof(WCHAR)) && (*(PWCHAR)TextStartAddress == 0xFEFF)) {
                //
                // The file has the BOM prefix.  Adjust the pointer to the
                // start of the text, so that we don't include the marker
                // in the text buffer we return.
                //
#ifdef UNICODE
                IsNativeChar = TRUE;
#else
                IsNativeChar = FALSE;
#endif // UNICODE

                ((PWCHAR)TextStartAddress)++;
                FileSize -= sizeof(WCHAR);
            } else {

                IsNativeChar = IsTextUnicode(TextStartAddress,FileSize,NULL);
#ifndef UNICODE
                IsNativeChar = !IsNativeChar;
#endif // !UNICODE

            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            rc = ERROR_READ_FAULT;
        }

        if(rc == NO_ERROR) {

            if(IsNativeChar) {
                //
                // No conversion is required--we'll just use the mapped-in
                // image in memory.
                //
                Result->TextBuffer = TextStartAddress;
                Result->TextBufferSize = FileSize / sizeof(TCHAR);
                Result->FileHandle = FileHandle;
                Result->MappingHandle = MappingHandle;
                Result->ViewAddress = ViewAddress;

            } else {

                DWORD NativeCharCount;
                PTCHAR Buffer;

                //
                // Need to convert the file to the native character type.
                // Allocate a buffer that is maximally sized.
#ifdef UNICODE
                // The maximum size of the unicode text is
                // double the size of the oem text, and would occur
                // when each oem character is single-byte.
#else
                // The maximum size of the ANSI text is the same number
                // of bytes that the Unicode text occupies.
                //
#endif // UNICODE

                if(Buffer = MyMalloc(FileSize * sizeof(TCHAR))) {
                    try {
#ifdef UNICODE
                        //
                        // RAID#397463-1999/09/01-JamieHun Implement ANSI Inf Language=xxxx
                        // come up with a better way of determining what code-page to interpret INF file under
                        // currently we use the install-base
                        //
                        SysCodePage = CP_ACP;
                        NativeCharCount = MultiByteToWideChar(SysCodePage,
                                                              MB_PRECOMPOSED,
                                                              TextStartAddress,
                                                              FileSize,
                                                              Buffer,
                                                              FileSize
                                                             );
#else
                        NativeCharCount = WideCharToMultiByte(CP_ACP,
                                                              0,
                                                              TextStartAddress,
                                                              FileSize / sizeof(WCHAR),
                                                              Buffer,
                                                              FileSize,
                                                              NULL,
                                                              NULL
                                                             );
#endif // UNICODE
                        if(!NativeCharCount) {
                            rc = GetLastError();
                        }
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        rc = ERROR_READ_FAULT;
                    }
                } else {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                }

                if(rc == NO_ERROR) {
                    //
                    // If the converted buffer doesn't require the entire block
                    // we allocated, attempt to reallocate the buffer to its
                    // correct size.  We don't care if this fails, since the
                    // buffer we have is perfectly fine (just bigger than we
                    // need).
                    //
                    if(!(Result->TextBuffer = MyRealloc(Buffer, NativeCharCount * sizeof(TCHAR)))) {
                        Result->TextBuffer = Buffer;
                    }

                    Result->TextBufferSize = NativeCharCount;
                    Result->FileHandle = INVALID_HANDLE_VALUE;

                } else {
                    //
                    // Free the buffer, if it was previously allocated.
                    //
                    if(Buffer) {
                        MyFree(Buffer);
                    }
                }
            }
        }

        //
        // If the file was already in native character form and we didn't
        // enounter any errors, then we don't want to close it, because we
        // use the mapped-in view directly.
        //
        if((rc != NO_ERROR) || !IsNativeChar) {
            pSetupUnmapAndCloseFile(FileHandle, MappingHandle, ViewAddress);
        }
    }

    return rc;
}


BOOL
DestroyTextFileReadBuffer(
    IN PTEXTFILE_READ_BUFFER ReadBuffer
    )
/*++

Routine Description:

    Destroy a textfile read buffer created by ReadAsciiOrUnicodeTextFile.

Arguments:

    ReadBuffer - supplies the address of a TEXTFILE_READ_BUFFER structure
        for the buffer to be destroyed.

Return Value:

    BOOLean value indicating success or failure.

--*/
{
    //
    // If our ReadBuffer structure has a valid FileHandle, then we must
    // unmap and close the file, otherwise, we simply need to free the
    // allocated buffer.
    //
    if(ReadBuffer->FileHandle != INVALID_HANDLE_VALUE) {

        return pSetupUnmapAndCloseFile(ReadBuffer->FileHandle,
                                 ReadBuffer->MappingHandle,
                                 ReadBuffer->ViewAddress
                                );

    } else {

        MyFree(ReadBuffer->TextBuffer);
        return TRUE;

    }
}


BOOL
GetVersionInfoFromImage(
    IN  PCTSTR      FileName,
    OUT PDWORDLONG  Version,
    OUT LANGID     *Language
    )

/*++

Routine Description:

    Retrieve file version and language info from a file.

    The version is specified in the dwFileVersionMS and dwFileVersionLS fields
    of a VS_FIXEDFILEINFO, as filled in by the win32 version APIs. For the
    language we look at the translation table in the version resources and assume
    that the first langid/codepage pair specifies the language.

    If the file is not a coff image or does not have version resources,
    the function fails. The function does not fail if we are able to retrieve
    the version but not the language.

Arguments:

    FileName - supplies the full path of the file whose version data is desired.

    Version - receives the version stamp of the file. If the file is not a coff image
        or does not contain the appropriate version resource data, the function fails.

    Language - receives the language id of the file. If the file is not a coff image
        or does not contain the appropriate version resource data, this will be 0
        and the function succeeds.

Return Value:

    TRUE if we were able to retreive at least the version stamp.
    FALSE otherwise.

--*/

{
    DWORD d;
    PVOID VersionBlock;
    VS_FIXEDFILEINFO *FixedVersionInfo;
    UINT DataLength;
    BOOL b;
    PWORD Translation;
    DWORD Ignored;

    //
    // Assume failure
    //
    b = FALSE;

    //
    // Get the size of version info block.
    //
    if(d = GetFileVersionInfoSize((PTSTR)FileName,&Ignored)) {
        //
        // Allocate memory block of sufficient size to hold version info block
        //
        VersionBlock = MyMalloc(d*sizeof(TCHAR));
        if(VersionBlock) {

            //
            // Get the version block from the file.
            //
            if(GetFileVersionInfo((PTSTR)FileName,0,d*sizeof(TCHAR),VersionBlock)) {

                //
                // Get fixed version info.
                //
                if(VerQueryValue(VersionBlock,TEXT("\\"),&FixedVersionInfo,&DataLength)) {

                    //
                    // If we get here, we declare success, even if there is
                    // no language.
                    //
                    b = TRUE;

                    //
                    // Return version to caller.
                    //
                    *Version = (((DWORDLONG)FixedVersionInfo->dwFileVersionMS) << 32)
                             + FixedVersionInfo->dwFileVersionLS;

                    //
                    // Attempt to get language of file. We'll simply ask for the
                    // translation table and use the first language id we find in there
                    // as *the* language of the file.
                    //
                    // The translation table consists of LANGID/Codepage pairs.
                    //
                    if(VerQueryValue(VersionBlock,TEXT("\\VarFileInfo\\Translation"),&Translation,&DataLength)
                    && (DataLength >= (2*sizeof(WORD)))) {

                        *Language = Translation[0];
                    } else {
                        //
                        // No language
                        //
                        *Language = 0;
                    }
                }
            }

            MyFree(VersionBlock);
        }
    }

    return(b);
}

BOOL
pSetupGetVersionInfoFromImage(
    IN  PCTSTR          FileName,
    OUT PULARGE_INTEGER Version,
    OUT LANGID         *Language
    )
/*++

Routine Description:

    See GetVersionInfoFromImage for description
    Semi-public version that uses the more friendly ULARGE_INTEGER

Arguments:

    FileName - supplies the full path of the file whose version data is desired.

    Version - receives the version stamp of the file. If the file is not a coff image
        or does not contain the appropriate version resource data, the function fails.

    Language - receives the language id of the file. If the file is not a coff image
        or does not contain the appropriate version resource data, this will be 0
        and the function succeeds.

Return Value:

    TRUE if we were able to retreive at least the version stamp.
    FALSE otherwise.

--*/
{
    DWORDLONG privateVersion=0;
    BOOL result;

    result = GetVersionInfoFromImage(FileName,&privateVersion,Language);
    if (result && Version) {
        Version->QuadPart = privateVersion;
    }
    return result;
}

DWORD
GetSetFileTimestamp(
    IN  PCTSTR    FileName,
    OUT FILETIME *CreateTime,   OPTIONAL
    OUT FILETIME *AccessTime,   OPTIONAL
    OUT FILETIME *WriteTime,    OPTIONAL
    IN  BOOL      Set
    )

/*++

Routine Description:

    Get or set a file's timestamp values.

Arguments:

    FileName - supplies full path of file to get or set timestamps

    CreateTime - if specified and the underlying filesystem supports it,
        receives the creation time of the file.

    AccessTime - if specified and the underlying filesystem supports it,
        receives the last access time of the file.

    WriteTime - if specified, receives the last write time of the file.

Return Value:

    If successful, returns NO_ERROR, otherwise returns the Win32 error
    indicating the cause of failure.

--*/

{
    HANDLE h;
    DWORD d;
    BOOL b;

    h = CreateFile(
            FileName,
            Set ? GENERIC_WRITE : GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            0,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        return(GetLastError());
    }

    b = Set
      ? SetFileTime(h,CreateTime,AccessTime,WriteTime)
      : GetFileTime(h,CreateTime,AccessTime,WriteTime);

    d = b ? NO_ERROR : GetLastError();

    CloseHandle(h);

    return(d);
}


DWORD
RetreiveFileSecurity(
    IN  PCTSTR                FileName,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    )

/*++

Routine Description:

    Retreive security information from a file and place it into a buffer.

Arguments:

    FileName - supplies name of file whose security information is desired.

    SecurityDescriptor - If the function is successful, receives pointer
        to buffer containing security information for the file. The pointer
        may be NULL, indicating that there is no security information
        associated with the file or that the underlying filesystem does not
        support file security.

Return Value:

    Win32 error code indicating outcome. If NO_ERROR check the value returned
    in SecurityDescriptor.

    The caller can free the buffer with MyFree() when done with it.

--*/

{
    BOOL b;
    DWORD d;
    DWORD BytesRequired;
    PSECURITY_DESCRIPTOR p;


    BytesRequired = 1024;

    while (TRUE) {

        //
        // Allocate a buffer of the required size.
        //
        p = MyMalloc(BytesRequired);
        if(!p) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // Get the security.
        //
        b = GetFileSecurity(
                FileName,
                OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
                p,
                BytesRequired,
                &BytesRequired
                );

        //
        // Return with sucess
        //
        if(b) {
            *SecurityDescriptor = p;
            return(NO_ERROR);
        }

        //
        // Return an error code, unless we just need a bigger buffer
        //
        MyFree(p);
        d = GetLastError();
        if(d != ERROR_INSUFFICIENT_BUFFER) {
            return (d);
        }

        //
        // There's a bug in GetFileSecurity that can cause it to ask for a
        // REALLY big buffer.  In that case, we return an error.
        //
        if (BytesRequired > 0xF0000000) {
            return (ERROR_INVALID_DATA);
        }

        //
        // Otherwise, we'll try again with a bigger buffer
        //
    }
}


DWORD
StampFileSecurity(
    IN PCTSTR               FileName,
    IN PSECURITY_DESCRIPTOR SecurityInfo
    )

/*++

Routine Description:

    Set security information on a file.

Arguments:

    FileName - supplies name of file whose security information is desired.

    SecurityDescriptor - supplies pointer to buffer containing security information
        for the file. This buffer should have been returned by a call to
        RetreiveFileSecurity.  If the underlying filesystem does not support
        file security, the function fails.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    BOOL b;

    b = SetFileSecurity(
            FileName,
            OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
            SecurityInfo
            );

    return(b ? NO_ERROR : GetLastError());
}


DWORD
TakeOwnershipOfFile(
    IN PCTSTR Filename
    )

/*++

Routine Description:

    Sets the owner of a given file to the default owner specified in
    the current process token.

Arguments:

    FileName - supplies name of the file of which to take ownership.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    BOOL b;
    SECURITY_DESCRIPTOR SecurityDescriptor;
    DWORD Err;
    HANDLE Token;
    DWORD BytesRequired;
    PTOKEN_OWNER OwnerInfo;

    //
    // Open the process token.
    //
    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&Token)) {
        Err = GetLastError();
        goto clean0;
    }

    //
    // Get the current process's default owner sid.
    //
    GetTokenInformation(Token,TokenOwner,NULL,0,&BytesRequired);
    Err = GetLastError();
    if(Err != ERROR_INSUFFICIENT_BUFFER) {
        goto clean1;
    }

    OwnerInfo = MyMalloc(BytesRequired);
    if(!OwnerInfo) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean1;
    }

    b = GetTokenInformation(Token,TokenOwner,OwnerInfo,BytesRequired,&BytesRequired);
    if(!b) {
        Err = GetLastError();
        goto clean2;
    }

    //
    // Initialize the security descriptor.
    //
    if(!InitializeSecurityDescriptor(&SecurityDescriptor,SECURITY_DESCRIPTOR_REVISION)
    || !SetSecurityDescriptorOwner(&SecurityDescriptor,OwnerInfo->Owner,FALSE)) {

        Err = GetLastError();
        goto clean2;
    }

    //
    // Set file security.
    //
    Err = SetFileSecurity(Filename,OWNER_SECURITY_INFORMATION,&SecurityDescriptor)
        ? NO_ERROR
        : GetLastError();

    //
    // Not all filesystems support this operation.
    //
    if(Err == ERROR_NOT_SUPPORTED) {
        Err = NO_ERROR;
    }

clean2:
    MyFree(OwnerInfo);
clean1:
    CloseHandle(Token);
clean0:
    return(Err);
}


DWORD
SearchForInfFile(
    IN  PCTSTR            InfName,
    OUT LPWIN32_FIND_DATA FindData,
    IN  DWORD             SearchControl,
    OUT PTSTR             FullInfPath,
    IN  UINT              FullInfPathSize,
    OUT PUINT             RequiredSize     OPTIONAL
    )
/*++

Routine Description:

    This routine searches for an INF file in the manner specified
    by the SearchControl parameter.  If the file is found, its
    full path is returned.

Arguments:

    InfName - Supplies name of INF to search for.  This name is simply
        appended to the two search directory paths, so if the name
        contains directories, the file will searched for in the
        subdirectory under the search directory.  I.e.:

            \foo\bar.inf

        will be searched for as %windir%\inf\foo\bar.inf and
        %windir%\system32\foo\bar.inf.

    FindData - Supplies the address of a Win32 Find Data structure that
        receives information about the file specified (if it is found).

    SearchControl - Specifies the order in which directories should
        be searched:

        INFINFO_DEFAULT_SEARCH : search %windir%\inf, then %windir%\system32

        INFINFO_REVERSE_DEFAULT_SEARCH : reverse of the above

        INFINFO_INF_PATH_LIST_SEARCH : search for the INF in each of the
            directories listed in the DevicePath value entry under:

            HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion.

    FullInfPath - If the file is found, receives the full path of the INF.

    FullInfPathSize - Supplies the size of the FullInfPath buffer (in
        characters).

    RequiredSize - Optionally, receives the number of characters (including
        terminating NULL) required to store the FullInfPath.

Return Value:

    Win32 error code indicating whether the function was successful.  Common
    return values are:

        NO_ERROR if the file was found, and the INF file path returned
            successfully.

        ERROR_INSUFFICIENT_BUFFER if the supplied buffer was not large enough
            to hold the full INF path (RequiredSize will indicated how large
            the buffer needs to be)

        ERROR_FILE_NOT_FOUND if the file was not found.

        ERROR_INVALID_PARAMETER if the SearchControl parameter is invalid.

--*/

{
    PCTSTR PathList;
    TCHAR CurInfPath[MAX_PATH];
    PCTSTR PathPtr, InfPathLocation;
    DWORD PathLength;
    BOOL b, FreePathList;
    DWORD d;

    //
    // Retrieve the path list.
    //
    if(SearchControl == INFINFO_INF_PATH_LIST_SEARCH) {
        //
        // Just use our global list of INF search paths.
        //
        PathList = InfSearchPaths;
        FreePathList = FALSE;
    } else {
        if(!(PathList = AllocAndReturnDriverSearchList(SearchControl))) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        FreePathList = TRUE;
    }

    //
    // Now look for the INF in each path in our MultiSz list.
    //
    InfPathLocation = NULL;
    d = NO_ERROR;

    for(PathPtr = PathList; *PathPtr; PathPtr += (lstrlen(PathPtr) + 1)) {
        //
        // Concatenate the INF file name with the current search path.
        //
        lstrcpy(CurInfPath, PathPtr);
        pSetupConcatenatePaths(CurInfPath,
                         InfName,
                         SIZECHARS(CurInfPath),
                         &PathLength
                        );

        if(b = FileExists(CurInfPath, FindData)) {
            if(!(FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                InfPathLocation = CurInfPath;
                break;
            }
        } else {
            //
            // See if we got a 'real' error
            //
            d = GetLastError();
            if((d == ERROR_NO_MORE_FILES) || (d == ERROR_FILE_NOT_FOUND) || (d == ERROR_PATH_NOT_FOUND)) {
                //
                // Not really an error--continue looking.
                //
                d = NO_ERROR;

            } else {
                //
                // This is a 'real' error, abort the search.
                //
                break;
            }
        }
    }

    //
    // Whatever the outcome, we're through with the PathList buffer.
    //
    if(FreePathList) {
        MyFree(PathList);
    }

    if(d != NO_ERROR) {
        return d;
    } else if(!InfPathLocation) {
        return ERROR_FILE_NOT_FOUND;
    }

    if(RequiredSize) {
        *RequiredSize = PathLength;
    }

    if(PathLength > FullInfPathSize) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    CopyMemory(FullInfPath,
               InfPathLocation,
               PathLength * sizeof(TCHAR)
              );

    return NO_ERROR;
}


DWORD
MultiSzFromSearchControl(
    IN  DWORD  SearchControl,
    OUT PTCHAR PathList,
    IN  DWORD  PathListSize,
    OUT PDWORD RequiredSize  OPTIONAL
    )
/*++

Routine Description:

    This routine takes a search control ordinal and builds a MultiSz list
    based on the search list it specifies.

Arguments:

    SearchControl - Specifies the directory list to be built.  May be one
        of the following values:

        INFINFO_DEFAULT_SEARCH : %windir%\inf, then %windir%\system32

        INFINFO_REVERSE_DEFAULT_SEARCH : reverse of the above

        INFINFO_INF_PATH_LIST_SEARCH : Each of the directories listed in
            the DevicePath value entry under:

            HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion.

    PathList - Supplies the address of a character buffer that will receive
        the MultiSz list.

    PathListSize - Supplies the size, in characters, of the PathList buffer.

    RequiredSize - Optionally, receives the number of characters required
        to store the MultiSz PathList.

        (NOTE:  The user-supplied buffer is used to retrieve the value entry
        from the registry.  Therefore, if the value is a REG_EXPAND_SZ entry,
        the RequiredSize parameter may be set too small on an
        ERROR_INSUFFICIENT_BUFFER error.  This will happen if the buffer was
        too small to retrieve the value entry, before expansion.  In this case,
        calling the API again with a buffer sized according to the RequiredSize
        output may fail with an ERROR_INSUFFICIENT_BUFFER yet again, since
        expansion may require an even larger buffer.)

Return Value:

    If successful, returns NO_ERROR.
    If failure, returns an ERROR_* status code.
--*/

{
    HKEY hk;
    PCTSTR Path1, Path2;
    PTSTR PathBuffer;
    DWORD RegDataType, PathLength, PathLength1, PathLength2;
    DWORD NumPaths, Err;
    BOOL UseDefaultDevicePath;

    if(PathList) {
        Err = NO_ERROR;  // assume success.
    } else {
        return ERROR_INVALID_PARAMETER;
    }

    UseDefaultDevicePath = FALSE;

    if(SearchControl == INFINFO_INF_PATH_LIST_SEARCH) {
        //
        // Retrieve the INF search path list from the registry.
        //
        if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        pszPathSetup,
                        0,
                        KEY_READ,
                        &hk) != ERROR_SUCCESS) {
            //
            // Fall back to default (just the Inf directory).
            //
            UseDefaultDevicePath = TRUE;

        } else {

            PathBuffer = NULL;

            try {
                //
                // Get the DevicePath value entry.  Support REG_SZ or REG_EXPAND_SZ data.
                //
                PathLength = PathListSize * sizeof(TCHAR);
                Err = RegQueryValueEx(hk,
                                      pszDevicePath,
                                      NULL,
                                      &RegDataType,
                                      (LPBYTE)PathList,
                                      &PathLength
                                     );
                //
                // Need path length in characters from now on.
                //
                PathLength /= sizeof(TCHAR);

                if(Err == ERROR_SUCCESS) {

                    //
                    // Check if the callers buffer has room for extra NULL terminator.
                    //
                    if (PathLength >= PathListSize) {

                        PathLength++;
                        Err = ERROR_INSUFFICIENT_BUFFER;

                    } else if((RegDataType == REG_SZ) || (RegDataType == REG_EXPAND_SZ)) {
                        //
                        // Convert this semicolon-delimited list to a REG_MULTI_SZ.
                        //
                        NumPaths = DelimStringToMultiSz(PathList,
                                                        PathLength,
                                                        TEXT(';')
                                                       );

#if 0
                        if(RegDataType == REG_EXPAND_SZ) {
#endif
                        //
                        // Allocate a temporary buffer large enough to hold the number
                        // of paths in the MULTI_SZ list, each having maximum length
                        // (plus an extra terminating NULL at the end).
                        //
                        if(!(PathBuffer = MyMalloc((NumPaths * MAX_PATH * sizeof(TCHAR))
                                                   + sizeof(TCHAR)))) {
                            Err = ERROR_NOT_ENOUGH_MEMORY;
                            goto clean0;
                        }

                        PathLength = 0;
                        for(Path1 = PathList;
                            *Path1;
                            Path1 += lstrlen(Path1) + 1) {

                            if(RegDataType == REG_EXPAND_SZ) {
                                PathLength += ExpandEnvironmentStrings(Path1,
                                                                       PathBuffer + PathLength,
                                                                       MAX_PATH
                                                                      );
                            } else {
                                lstrcpy(PathBuffer + PathLength, Path1);
                                PathLength += lstrlen(Path1) + 1;
                            }
                            //
                            // If the last character in this path is a backslash, then strip
                            // it off.
                            // PathLength at this point includes terminating NULL
                            // char at PathBuffer[PathLength-1] is (or should be) NULL
                            // char at PathBuffer[PathLength-2] may be '\'
                            //

                            if(*CharPrev(PathBuffer,PathBuffer + PathLength - 1) == TEXT('\\')) {
                                *(PathBuffer + PathLength - 2) = TEXT('\0');
                                PathLength--;
                            }
                        }
                        //
                        // Add additional terminating NULL at the end.
                        //
                        *(PathBuffer + PathLength) = TEXT('\0');

                        if(++PathLength > PathListSize) {
                            Err = ERROR_INSUFFICIENT_BUFFER;
                        } else {
                            CopyMemory(PathList,
                                       PathBuffer,
                                       PathLength * sizeof(TCHAR)
                                      );
                        }

                        MyFree(PathBuffer);
                        PathBuffer = NULL;
#if 0
                        }
#endif

                    } else {
                        //
                        // Bad data type--just use the Inf directory.
                        //
                        UseDefaultDevicePath = TRUE;
                    }

                } else if(Err == ERROR_MORE_DATA){
                    Err = ERROR_INSUFFICIENT_BUFFER;
                } else {
                    //
                    // Fall back to default (just the Inf directory).
                    //
                    UseDefaultDevicePath = TRUE;
                }

clean0:         ;   // nothing to do

            } except(EXCEPTION_EXECUTE_HANDLER) {
                //
                // Fall back to default (just the Inf directory).
                //
                UseDefaultDevicePath = TRUE;

                if(PathBuffer) {
                    MyFree(PathBuffer);
                }
            }

            RegCloseKey(hk);
        }
    }

    if(UseDefaultDevicePath) {

        PathLength = lstrlen(InfDirectory) + 2;

        if(PathLength > PathListSize) {
            Err = ERROR_INSUFFICIENT_BUFFER;
        } else {
            Err = NO_ERROR;
            CopyMemory(PathList, InfDirectory, (PathLength - 1) * sizeof(TCHAR));
            //
            // Add extra NULL to terminate the list.
            //
            PathList[PathLength - 1] = TEXT('\0');
        }

    } else if((Err == NO_ERROR) && (SearchControl != INFINFO_INF_PATH_LIST_SEARCH)) {

        switch(SearchControl) {

            case INFINFO_DEFAULT_SEARCH :
                Path1 = InfDirectory;
                Path2 = SystemDirectory;
                break;

            case INFINFO_REVERSE_DEFAULT_SEARCH :
                Path1 = SystemDirectory;
                Path2 = InfDirectory;
                break;

            default :
                return ERROR_INVALID_PARAMETER;
        }

        PathLength1 = lstrlen(Path1) + 1;
        PathLength2 = lstrlen(Path2) + 1;
        PathLength = PathLength1 + PathLength2 + 1;

        if(PathLength > PathListSize) {
            Err = ERROR_INSUFFICIENT_BUFFER;
        } else {

            CopyMemory(PathList, Path1, PathLength1 * sizeof(TCHAR));
            CopyMemory(&(PathList[PathLength1]), Path2, PathLength2 * sizeof(TCHAR));
            //
            // Add additional terminating NULL at the end.
            //
            PathList[PathLength - 1] = 0;
        }
    }

    if(((Err == NO_ERROR) || (Err == ERROR_INSUFFICIENT_BUFFER)) && RequiredSize) {
        *RequiredSize = PathLength;
    }

    return Err;
}


PTSTR
AllocAndReturnDriverSearchList(
    IN DWORD SearchControl
    )
/*++

Routine Description:

    This routine returns a buffer contains a multi-sz list of all directory paths in our
    driver search path list.

    The buffer returned must be freed with MyFree().

Arguments:

    SearchControl - Specifies the directory list to be retrieved.  May be one
        of the following values:

        INFINFO_DEFAULT_SEARCH : %windir%\inf, then %windir%\system32

        INFINFO_REVERSE_DEFAULT_SEARCH : reverse of the above

        INFINFO_INF_PATH_LIST_SEARCH : Each of the directories listed in
            the DevicePath value entry under:

            HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion.

Returns:

    Pointer to the allocated buffer containing the list, or NULL if out-of-memory.

--*/
{
    PTSTR PathListBuffer, TrimBuffer;
    DWORD BufferSize;
    DWORD Err;

    //
    // Start out with a buffer of MAX_PATH length, which should cover most cases.
    //
    BufferSize = MAX_PATH;
    if(PathListBuffer = MyMalloc((BufferSize+2) * sizeof(TCHAR))) {
        //
        // Loop on a call to MultiSzFromSearchControl until we succeed or hit some
        // error other than buffer-too-small.  There are two reasons for this.  1st, it
        // is possible that someone could have added a new path to the registry list
        // between calls, and 2nd, since that routine uses our buffer to retrieve the
        // original (non-expanded) list, it can only report the size it needs to retrieve
        // the unexpanded list.  After it is given enough space to retrieve it, _then_ it
        // can tell us how much space we really need.
        //
        // With all that said, we'll almost never see this call made more than once.
        //
        while(TRUE) {

            if((Err = MultiSzFromSearchControl(SearchControl,
                                               PathListBuffer,
                                               BufferSize,
                                               &BufferSize)) == NO_ERROR) {
                //
                // We've successfully retrieved the path list.  If the list is larger
                // than necessary (the normal case), then trim it down before returning.
                // (If this fails it's no big deal--we'll just keep on using the original
                // buffer.)
                //
                if(TrimBuffer = MyRealloc(PathListBuffer, (BufferSize+2) * sizeof(TCHAR))) {
                    return TrimBuffer;
                } else {
                    return PathListBuffer;
                }

            } else {
                //
                // Free our current buffer before we find out what went wrong.
                //
                MyFree(PathListBuffer);

                if((Err != ERROR_INSUFFICIENT_BUFFER) ||
                   !(PathListBuffer = MyMalloc((BufferSize+2) * sizeof(TCHAR)))) {
                    //
                    // We failed.
                    //
                    return NULL;
                }
            }
        }
    }

    return NULL;
}


BOOL
DoMove(
    IN PCTSTR CurrentName,
    IN PCTSTR NewName
    )
/*++

Routine Description:

    Wrapper for MoveFileEx on NT, DeleteFile followed by MoveFile on Win9x.

Arguments:

    CurrentName - supplies the name of the file as it exists currently.

    NewName - supplies the new name

Returns:

    Boolean value indicating outcome. If failure, last error is set.

--*/
{
    BOOL b;

    //
    // Try to be as efficient as possible on Windows NT.
    //
    if(OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        b = MoveFileEx(CurrentName,NewName,MOVEFILE_REPLACE_EXISTING);
    } else {
        DeleteFile(NewName);
        b = MoveFile(CurrentName,NewName);
    }

    return(b);
}


BOOL
DelayedMove(
    IN PCTSTR CurrentName,
    IN PCTSTR NewName       OPTIONAL
    )

/*++

Routine Description:

    Queue a file for copy or delete on next reboot.

    On Windows NT this means using MoveFileEx(). On Win95 this means
    using the wininit.ini mechanism.

    It is assumed that the target file already exists. On Win95, we need
    to know the short filename since the wininit.ini mechanism only understands
    SFNs and we have to do a bunch of special crud to make this all work.
    Note: we do NOT attempt to deal with the long filename of the target
    when renaming on Win95. In other words, if the target name is not 8.3,
    it will wind up as 8.3 after processing of wininit.ini is done!
    If a referenced file does not exist we have no choice but to use
    the name passed in, which better be 8.3!

Arguments:

    CurrentName - supplies the name of the file as it exists currently.

    NewName - if specified supplies the new name. If not specified
        then the file named by CurrentName is deleted on next reboot.

Returns:

    Boolean value indicating outcome. If failure, last error is set.

--*/

{
    BOOL b;
    DWORD err;

    if(OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {

        b = MoveFileEx(
                CurrentName,
                NewName,
                MOVEFILE_REPLACE_EXISTING | MOVEFILE_DELAY_UNTIL_REBOOT
                );

    } else {

#ifdef UNICODE
        //
        // The code below runs only on Win95 because of the version check
        // just above. Thus we should never get here. The code below makes
        // assumptions about maximum section lengths, etc, that are only
        // valid on Win95. The SDK says that sections are limited to 32K,
        // for example, and there are several hard-coded constants that take
        // advantage of this.
        //
        b = FALSE;
        err = ERROR_CALL_NOT_IMPLEMENTED;
#else
        CHAR WininitFile[MAX_PATH];
        CHAR NewSFN[MAX_PATH];
        CHAR CurrentSFN[MAX_PATH];
        CHAR *Buffer;
        CHAR *p,*q;
        DWORD Size;
        DWORD d;

        //
        // Calculate full path of wininit.ini and get short filenames.
        // We want to calculate the length of the data we're adding to
        // wininit.ini up front, so we can leave room in the buffer
        // (taking advantage of the 32K max section size on Win95).
        // Trial and error dictates that when you get to that magic 32K
        // number things can go really haywire unless you ensure you
        // don't overflow a 16 bit signed 16-bit number, so we limit
        // everything to 32767 to be safe.
        //
        // For renames, we add a line to delete the target file first.
        // Not sure if this is really necessary, but it won't hurt anything.
        //
        if(Buffer = MyMalloc(32767)) {

            lstrcpyn(WininitFile,WindowsDirectory,MAX_PATH);
            pSetupConcatenatePaths(WininitFile,"WININIT.INI",MAX_PATH,NULL);

            if(!GetShortPathName(CurrentName,CurrentSFN,MAX_PATH)) {
                lstrcpyn(CurrentSFN,CurrentName,MAX_PATH);
            }
            if(NewName) {
                if(!GetShortPathName(NewName,NewSFN,MAX_PATH)) {
                    lstrcpyn(NewSFN,NewName,MAX_PATH);
                }

                //
                // NUL=NewSFN
                // NewSFN=CurrentSFN
                //
                // plus terminating nul chars for each line.
                //
                Size = 3 + 1 + lstrlen(NewSFN) + 1
                     + lstrlen(NewSFN) + 1 + lstrlen(CurrentSFN) + 1;

            } else {
                //
                // NUL=CurrentSFN
                //
                // plus terminating nul char for the line
                //
                Size = 3 + 1 + lstrlen(CurrentSFN) + 1;
                lstrcpy(NewSFN,"NUL");
            }

            //
            // Fetch the section and see if the line is already in there.
            // If so, we're done.
            //
            d = GetPrivateProfileSection("Rename",Buffer,32767,WininitFile);
            for(p=Buffer; *p; p+=lstrlen(p)+1) {
                if(q = _mbschr(p,'=')) {
                    *q = 0;
                    if(!lstrcmpi(p,NewSFN) && !lstrcmpi(q+1,CurrentSFN)) {
                        break;
                    }
                    *q = '=';
                }
            }

            if((*p == 0) && (Size <= 32766-d)) {
                //
                // Add our line(s), and make sure we have that extra nul
                // to terminate things properly. We guaranteed that there'd be
                // enough room by the checks above.
                //
                if(NewName) {
                    d += wsprintf(Buffer+d,"NUL=%s",NewSFN) + 1;
                    d += wsprintf(Buffer+d,"%s=%s",NewSFN,CurrentSFN) + 1;
                } else {
                    d += wsprintf(Buffer+d,"NUL=%s",CurrentSFN) + 1;
                }

                Buffer[d] = 0;

                //
                // Write the section back out.
                //
                b = WritePrivateProfileSection("Rename",Buffer,WininitFile);
                err = b ? NO_ERROR : GetLastError();
            } else {
                //
                // The section is full or the line was already there.
                // Just ignore it (in the section full case there's nothing
                // the user can do anyway).
                //
                b = TRUE;
                err = NO_ERROR;
            }

            MyFree(Buffer);
        } else {
            b = FALSE;
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
#endif
        SetLastError(err);

    }

    return(b);
}


DWORD
IsInstalledCatalogFromOem(
    IN  PCTSTR                CatalogFile
    )

/*++

Routine Description:

    Determin if a catalog is an OEM catalog.

Arguments:

    CatalogFile - supplies name of catalog file.

Return Value:

    BOOL. TRUE if the CatalogFile is an OEM Catalog file, and FALSE otherwise.

--*/

{
    PTSTR p;

    //
    // First check that the first 3 characters are OEM
    //
    if (_tcsnicmp(CatalogFile, TEXT("oem"), 3)) {

        return FALSE;
    }

    //
    // Next verify that any characters after "oem" and before ".cat"
    // are digits.
    //
    p = (PTSTR)CatalogFile;
    p = CharNext(p);
    p = CharNext(p);
    p = CharNext(p);

    while ((*p != TEXT('\0')) && (*p != TEXT('.'))) {

        if ((*p < TEXT('0')) || (*p > TEXT('9'))) {

            return FALSE;
        }

        p = CharNext(p);
    }

    //
    // Finally, verify that the last 4 characters are ".cat"
    //
    if (lstrcmpi(p, TEXT(".cat"))) {

        return FALSE;
    }

    //
    // This is an OEM catalog file
    //
    return TRUE;
}


DWORD
pSetupInstallCatalog(
    IN  LPCTSTR CatalogFullPath,
    IN  LPCTSTR NewBaseName,        OPTIONAL
    OUT LPTSTR  NewCatalogFullPath  OPTIONAL
    )

/*++

Routine Description:

    This routine installs a catalog file. The file is copied by the system
    into a special directory, and is optionally renamed.

Arguments:

    CatalogFullPath - supplies the fully-qualified win32 path of the catalog
        to be installed on the system.

    NewBaseName - optionally specifies the new base name to use when the
        catalog file is copied into the catalog store. If not specified,
        the basename will be generated by CryptCATAdminAddCatalog.

    NewCatalogFullPath - optionally receives the fully-qualified path of the
        catalog file within the catalog store. This buffer should be at least
        MAX_PATH bytes (ANSI version) or chars (Unicode version).

        ** NOTE: If we're running in "minimal embedded" mode, then we don't **
        ** actually call any of the Crypto APIs, and instead always simply  **
        ** report success.  In this case, the caller had better not have    **
        ** specified an OUT buffer for NewCatalogFullPath, because we won't **
        ** have a path to report.  If we run into this case, we'll instead  **
        ** report failure.  What this really says is that nobody other than **
        ** setupapi should ever be passing a non-NULL value for this arg.   **

Return Value:

    If successful, the return value is NO_ERROR.
    If failure, the return value is a Win32 error code indicating the cause of
    the failure.

--*/

{
    DWORD Err;
    HCATADMIN hCatAdmin;
    HCATINFO hCatInfo;
    CATALOG_INFO CatalogInfo;
    LPWSTR catalogFullPath;
    LPWSTR newBaseName;

    if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
        //
        // If someone called us expecting the new catalog's full path to be
        // returned, they're outta luck...
        //
        MYASSERT(!NewCatalogFullPath);
        if(NewCatalogFullPath) {
            //
            // In minimal embedded mode, a non-NULL NewCatalogFullPath arg is
            // an invalid parameter...
            //
            return ERROR_INVALID_PARAMETER;

        } else {
            //
            // Simply report success.
            //
            return NO_ERROR;
        }
    }

    if(GlobalSetupFlags & PSPGF_AUTOFAIL_VERIFIES) {
        return TRUST_E_FAIL;
    }

    Err = NO_ERROR;
    catalogFullPath = NULL;
    newBaseName = NULL;

    if(!CryptCATAdminAcquireContext(&hCatAdmin,&DriverVerifyGuid,0)) {
        Err = GetLastError();
        MYASSERT(Err != NO_ERROR);
        if(Err == NO_ERROR) {
            Err = ERROR_INVALID_DATA;
        }
    } else {

#ifdef UNICODE
        //
        // We do this even for the Unicode case because CryptCATAdminAddCatalog
        // takes non-const strings and I have no idea whatsoever whether this
        // was just sloppiness or a real requirement, and no desire to mess
        // around trying to figure it out.
        //
        if(catalogFullPath = DuplicateString(CatalogFullPath)) {
            if(NewBaseName) {
                newBaseName = DuplicateString(NewBaseName);
                if(!newBaseName) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        } else {
            Err = ERROR_NOT_ENOUGH_MEMORY;
        }
#else
        if(catalogFullPath = pSetupAnsiToUnicode(CatalogFullPath)) {
            if(NewBaseName) {
                newBaseName = pSetupAnsiToUnicode(NewBaseName);
                if(!newBaseName) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        } else {
            Err = ERROR_NOT_ENOUGH_MEMORY;
        }
#endif

        if(Err == NO_ERROR) {

            hCatInfo = CryptCATAdminAddCatalog(hCatAdmin,catalogFullPath,newBaseName,0);

            if(!hCatInfo) {
                Err = GetLastError();
                MYASSERT(Err != NO_ERROR);
                if(Err == NO_ERROR) {
                    Err = ERROR_INVALID_DATA;
                }

                //
                // If the error we received is ERROR_ALREADY_EXISTS, then that
                // indicates that the exact same catalog was already present
                // (and installed under the same name).  Treat this as a
                // success (assuming we can get the full pathname of the
                // existing catalog).
                //
                if(Err == ERROR_ALREADY_EXISTS) {
                    //
                    // We should never get this if we asked crypto to auto-
                    // generate a name for us...
                    //
                    MYASSERT(newBaseName);

                    if(NewCatalogFullPath) {

                        if(newBaseName) {
                            //
                            // Resolve the catalog base filename to a fully-
                            // qualified path.
                            //
                            CatalogInfo.cbStruct = sizeof(CATALOG_INFO);

                            if(CryptCATAdminResolveCatalogPath(hCatAdmin,
                                                               newBaseName,
                                                               &CatalogInfo,
                                                               0)) {
                                //
                                // We successfully resolved the filename, so we
                                // can report success
                                //
                                Err = NO_ERROR;
                            }
                        }

                    } else {
                        //
                        // Caller isn't interested in finding out what pathname
                        // the catalog was installed under...
                        //
                        Err = NO_ERROR;
                    }
                }

            } else {
                //
                // If the caller wants to know the full path under which the
                // catalog got installed, then find that out now.
                //
                if(NewCatalogFullPath) {

                    CatalogInfo.cbStruct = sizeof(CATALOG_INFO);
                    if(!CryptCATCatalogInfoFromContext(hCatInfo,&CatalogInfo,0)) {
                        Err = GetLastError();
                        MYASSERT(Err != NO_ERROR);
                        if(Err == NO_ERROR) {
                            Err = ERROR_INVALID_DATA;
                        }
                    }
                }

                CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
            }

            //
            // If we succeeded in retrieving the installed catalog's full path
            // (and the caller requested it), fill in the caller's buffer now.
            //
            if((Err == NO_ERROR) && NewCatalogFullPath) {

#ifdef UNICODE
                lstrcpyn(NewCatalogFullPath, CatalogInfo.wszCatalogFile, MAX_PATH);
#else
                WideCharToMultiByte(
                    CP_ACP,
                    0,
                    CatalogInfo.wszCatalogFile,
                    -1,
                    NewCatalogFullPath,
                    MAX_PATH,
                    NULL,
                    NULL
                    );
#endif
            }
        }
        CryptCATAdminReleaseContext(hCatAdmin, 0);
    }

    if(catalogFullPath) {
        MyFree(catalogFullPath);
    }
    if(newBaseName) {
        MyFree(newBaseName);
    }

    return Err;
}


DWORD
pSetupVerifyCatalogFile(
    IN LPCTSTR CatalogFullPath
    )

/*++

Routine Description:

    This routine verifies a single catalog file. A catalog file is
    "self-verifying" in that there is no additional file or data required
    to verify it.

Arguments:

    CatalogFullPath - supplies the fully-qualified Win32 path of
        the catalog file to be verified.

Return Value:

    If successful, the return value is ERROR_SUCCESS.
    If failure, the return value is the error returned from WinVerifyTrust.

--*/

{
    WINTRUST_DATA WintrustData;
    WINTRUST_FILE_INFO WintrustFileInfo;
#ifndef UNICODE
    WCHAR UnicodeBuffer[MAX_PATH];
#endif

    if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
        return ERROR_SUCCESS;
    }

    if(GlobalSetupFlags & PSPGF_AUTOFAIL_VERIFIES) {
        return TRUST_E_FAIL;
    }

    ZeroMemory(&WintrustData, sizeof(WINTRUST_DATA));
    WintrustData.cbStruct = sizeof(WINTRUST_DATA);
    WintrustData.dwUIChoice = WTD_UI_NONE;
    WintrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
    WintrustData.dwUnionChoice = WTD_CHOICE_FILE;
    WintrustData.pFile = &WintrustFileInfo;
    WintrustData.dwProvFlags = WTD_REVOCATION_CHECK_NONE;
    ZeroMemory(&WintrustFileInfo, sizeof(WINTRUST_FILE_INFO));
    WintrustFileInfo.cbStruct = sizeof(WINTRUST_FILE_INFO);

#ifdef UNICODE
    WintrustFileInfo.pcwszFilePath = CatalogFullPath;
#else
    MultiByteToWideChar(CP_ACP, 0, CatalogFullPath, -1, UnicodeBuffer, MAX_PATH);
    WintrustFileInfo.pcwszFilePath = UnicodeBuffer;
#endif

    return (DWORD)WinVerifyTrust(NULL, &DriverVerifyGuid, &WintrustData);
}


DWORD
pSetupUninstallCatalog(
    IN LPCTSTR CatalogFilename
    )

/*++

Routine Description:

    This routine uninstalls a catalog, so it can no longer be used to validate
    digital signatures.

Arguments:

    CatalogFilename - supplies the simple filename of the catalog to be
        uninstalled.

Return Value:

    If successful, the return value is NO_ERROR.
    If failure, the return value is a Win32 error code indicating the cause of
    the failure.

--*/

{
    DWORD Err;
    HCATADMIN hCatAdmin;
#ifdef UNICODE
    //
    // Presently, the crypto API CryptCATAdminRemoveCatalog defines its 2nd
    // parameter as a PWSTR, even though it's an IN param that should be CONST.
    // ReidK is going to fix this to be PCWSTR instead, so I'm safe in casting
    // away the const-ness of my CatalogFilename arg here.  (Once Reid's
    // check-in happens, I can remove this cast.)
    //
    #define LocalCatName ((PWSTR)CatalogFilename)
#else
    WCHAR LocalCatName[MAX_PATH];

    //
    // Crypto APIs are Unicode-only, so convert the catalog filename from
    // ANSI to Unicode...
    //
    if(!MultiByteToWideChar(CP_ACP,
                            MB_PRECOMPOSED,
                            CatalogFilename,
                            -1,
                            LocalCatName,
                            SIZECHARS(LocalCatName))) {

        return GetLastError();
    }
#endif

    if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
        return NO_ERROR;
    }

    if(GlobalSetupFlags & PSPGF_AUTOFAIL_VERIFIES) {
        return TRUST_E_FAIL;
    }

    Err = NO_ERROR;

    if(!CryptCATAdminAcquireContext(&hCatAdmin, &DriverVerifyGuid, 0)) {
        Err = GetLastError();
        MYASSERT(Err != NO_ERROR);
        if(Err == NO_ERROR) {
            Err = ERROR_INVALID_DATA;
        }
    } else {

        if(!CryptCATAdminRemoveCatalog(hCatAdmin, LocalCatName, 0)) {
            Err = GetLastError();
            MYASSERT(Err != NO_ERROR);
            if(Err == NO_ERROR) {
                Err = ERROR_INVALID_DATA;
            }
        }
        CryptCATAdminReleaseContext(hCatAdmin, 0);
    }

    return Err;
}


BOOL
pAnyDeviceUsingInf(
    IN  LPCTSTR            InfFullPath,
    IN  PSETUP_LOG_CONTEXT LogContext   OPTIONAL
    )

/*++

Routine Description:

    This routine checks if any device, live or phantom, is using this INF file,
    and logs if they are.

Arguments:

    InfFullPath - supplies the full path of the INF.

    LogContext - optionally, Supplies the log context to be used if
        a device using this INF is encountered.

Return Value:

    TRUE if any device is still using this INF, FALSE if no devices are using
    this INF.

--*/

{
    DWORD Err = NO_ERROR;
    HDEVINFO DeviceInfoSet;
    SP_DEVINFO_DATA DeviceInfoData;
    DWORD MemberIndex = 0;
    HKEY hkey;
    TCHAR CurrentDeviceInfFile[MAX_PATH];
    TCHAR DeviceId[MAX_DEVICE_ID_LEN];
    DWORD cbSize, dwType;
    PTSTR pInfFile;

    //
    // If we are passed a NULL InfFullPath or an enpty string then just
    // return FALSE since nobody is using this.
    //
    if (!InfFullPath || (InfFullPath[0] == TEXT('\0'))) {
        return FALSE;
    }

    pInfFile = (PTSTR)pSetupGetFileTitle(InfFullPath);

    DeviceInfoSet = SetupDiGetClassDevs(NULL, NULL, NULL, DIGCF_ALLCLASSES);

    if (DeviceInfoSet != INVALID_HANDLE_VALUE) {
        DeviceInfoData.cbSize = sizeof(DeviceInfoData);

        while (SetupDiEnumDeviceInfo(DeviceInfoSet,
                                     MemberIndex++,
                                     &DeviceInfoData)) {

            //
            // Open the 'driver' key for this device.
            //
            hkey = SetupDiOpenDevRegKey(DeviceInfoSet,
                                        &DeviceInfoData,
                                        DICS_FLAG_GLOBAL,
                                        0,
                                        DIREG_DRV,
                                        KEY_READ);

            if (hkey != INVALID_HANDLE_VALUE) {

                cbSize = sizeof(CurrentDeviceInfFile);
                dwType = REG_SZ;

                if ((RegQueryValueEx(hkey,
                                     pszInfPath,
                                     NULL,
                                     &dwType,
                                     (LPBYTE)CurrentDeviceInfFile,
                                     &cbSize) == ERROR_SUCCESS) &&
                    (lstrcmpi(CurrentDeviceInfFile, pInfFile) == 0)) {
                    //
                    // This key is using this INF file so the INF can't be
                    // deleted.
                    //
                    Err = ERROR_SHARING_VIOLATION;

                    if (LogContext) {
                        if(CM_Get_Device_ID(DeviceInfoData.DevInst,
                                            DeviceId,
                                            SIZECHARS(DeviceId),
                                            0
                                            ) != CR_SUCCESS ) {
                            DeviceId[0] = TEXT('\0');
                        }

                        WriteLogEntry(LogContext,
                                      SETUP_LOG_WARNING,
                                      MSG_LOG_INF_IN_USE,
                                      NULL,
                                      pInfFile,
                                      DeviceId
                                     );
                    }
                }


                RegCloseKey(hkey);
            }
        }
    } else {
        Err = ERROR_OUTOFMEMORY;
    }

    return (Err != ERROR_SUCCESS);
}


VOID
pSetupUninstallOEMInf(
    IN  LPCTSTR            InfFullPath,
    IN  PSETUP_LOG_CONTEXT LogContext,  OPTIONAL
    IN  DWORD              Flags,
    OUT PDWORD             InfDeleteErr OPTIONAL
    )

/*++

Routine Description:

    This routine uninstalls a 3rd-party INF, PNF, and CAT (if one exists).

    By default this routine will first verify that there aren't any other
    device's, live and phantom, that are pointing their InfPath to this
    INF. This behavior can be overridden by the SUOI_FORCEDELETE flag.

Arguments:

    InfFullPath - supplies the full path of the INF to be uninstalled.

    LogContext - optionally, supplies the log context to be used if we
        encounter an error when attempting to delete the catalog.

    Flags - the following flags are supported:
        SUOI_FORCEDELETE - delete the INF even if other driver keys are
            have their InfPath pointing to it.

    InfDeleteErr - optionally, supplies the address of a variable that receives
        the error (if any) encountered when attempting to delete the INF.
        Note that we delete the INF last (to avoid race conditions), so the
        corresponding CAT and PNF may have already been deleted at this point.

Return Value:

    None.

--*/

{
    DWORD Err;
    TCHAR FileNameBuffer[MAX_PATH+4]; // +4 in case filename is blahblah. not blahblah.inf
    BOOL FreeLogContext = FALSE;
    LPTSTR ExtPtr= NULL;

    if(InfDeleteErr) {
        *InfDeleteErr = NO_ERROR;
    }

    if(!LogContext) {

        if(NO_ERROR == CreateLogContext(NULL, TRUE, &LogContext)) {
            //
            // Remember that we created this log context locally, so we can
            // free it when we're done with this routine.
            //
            FreeLogContext = TRUE;

        } else {
            //
            // Ensure LogContext is still NULL so we won't try to use it.
            //
            LogContext = NULL;
        }
    }

    //
    // Unless the caller passed in the SUOI_FORCEDELETE flag first check that
    // no devices are using this INF file.
    //
    if (!(Flags & SUOI_FORCEDELETE) &&
        pAnyDeviceUsingInf(InfFullPath, LogContext)) {
        //
        // Some device is still using this INF so we can't delete it. We don't
        // need to log anything at this point since we log every device using
        // this INF in pAnyDevicesUsingInf().
        //
        *InfDeleteErr = GetLastError();
        goto clean0;
    }

    //
    // Copy the caller-supplied INF name into a local buffer, so we can modify
    // it when deleting the various files (INF, PNF, and CAT).
    //
    lstrcpyn(FileNameBuffer, InfFullPath, SIZECHARS(FileNameBuffer));

    //
    // Uninstall the catalog (if any) first, because as soon as we delete the
    // INF, that slot is "open" for use by another INF, and we wouldn't want to
    // inadvertently delete someone else's catalog due to a race condition.
    //
    ExtPtr = _tcsrchr(FileNameBuffer, TEXT('.'));
    if(!ExtPtr) {
        //
        // not xxx.inf, so we know there is no catalog to delete
        //
        return;
    }
    lstrcpy(ExtPtr, pszCatSuffix);
    Err = pSetupUninstallCatalog(pSetupGetFileTitle(FileNameBuffer));

    if((Err != NO_ERROR) && LogContext) {
        //
        // It's kinda important that we were unable to delete the catalog, but
        // not important enough to fail the routine.  Log this fact to
        // setupapi.log...
        //
        WriteLogEntry(LogContext,
                      DEL_ERR_LOG_LEVEL(Err) | SETUP_LOG_BUFFER,
                      MSG_LOG_CAT_UNINSTALL_FAILED,
                      NULL,
                      pSetupGetFileTitle(FileNameBuffer)
                     );

        WriteLogError(LogContext,
                      DEL_ERR_LOG_LEVEL(Err),
                      Err
                     );
    }

    //
    // Now delete the PNF (we don't care so much if this succeeds or fails)...
    //
    lstrcpy(_tcsrchr(FileNameBuffer, TEXT('.')), pszPnfSuffix);
    DeleteFile(FileNameBuffer);

    //
    // and finally the INF itself...
    //
    lstrcpy(_tcsrchr(FileNameBuffer, TEXT('.')), pszInfSuffix);

    if(!DeleteFile(FileNameBuffer) && InfDeleteErr) {
        *InfDeleteErr = GetLastError();
    }

clean0:
    if(FreeLogContext) {
        DeleteLogContext(LogContext);
    }
}


DWORD
_VerifyFile(
    IN     PSETUP_LOG_CONTEXT      LogContext,
    IN OUT HCATADMIN              *hCatAdmin,              OPTIONAL
    IN OUT HSDB                   *hSDBDrvMain,            OPTIONAL
    IN     LPCTSTR                 Catalog,                OPTIONAL
    IN     PVOID                   CatalogBaseAddress,     OPTIONAL
    IN     DWORD                   CatalogImageSize,
    IN     LPCTSTR                 Key,
    IN     LPCTSTR                 FileFullPath,
    OUT    SetupapiVerifyProblem  *Problem,                OPTIONAL
    OUT    LPTSTR                  ProblemFile,            OPTIONAL
    IN     BOOL                    CatalogAlreadyVerified,
    IN     PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,        OPTIONAL
    IN     DWORD                   Flags,                  OPTIONAL
    OUT    LPTSTR                  CatalogFileUsed,        OPTIONAL
    OUT    PDWORD                  NumCatalogsConsidered,  OPTIONAL
    OUT    LPTSTR                  DigitalSigner,          OPTIONAL
    OUT    LPTSTR                  SignerVersion           OPTIONAL
    )

/*++

Routine Description:

    This routine verifies a single file against a particular catalog file, or
    against any installed catalog file.

Arguments:

    LogContext - supplies the context to be used when logging information about
        the routine's activities.

    hCatAdmin - optionally, supplies the address of an HCATADMIN handle.  If
        the handle pointed to is NULL, a handle will be acquired (if possible)
        via CryptCATAdminAcquireContext and returned to the caller.  If the
        handle pointed to is non-NULL, then that handle will be used for any
        validation done via this routine.  If the pointer itself is NULL, then
        an hCatAdmin will be acquired for the duration of this call, and
        released before returning.

        NOTE: it is the caller's responsibility to free the crypto context
        handle returned by this routine by calling CryptCATAdminReleaseContext.
        This handle may be opened in either success or failure cases, so the
        caller must check for non-NULL returned handle in both cases.

    hSDBDrvMain - optionally, supplies the address of a handle to the
        drvmain.sdb database.  If the handle pointed to is NULL, a handle will
        be acquired (if possible) via SdbInitDatabase and returned to the
        caller.  If the handle pointed to is non-NULL, then that handle will be
        used for bad driver database lookup (if requested) in this routine.  If
        the pointer itself is NULL, then an HSDB will be acquired for the
        duration of this call (if needed), and released before returning.

        NOTE: it is the caller's responsibility to free the handle returned by
        this routine by calling SdbReleaseDatabase.  This handle may be opened
        in either success or failure cases, so the caller must check for
        non-NULL returned handle in both cases.

    Catalog - optionally, supplies the path of the catalog file to be used for
        the verification.  If this argument is not specified, then this routine
        will attempt to find a catalog that can verify it from among all
        catalogs installed in the system.

        If this path is a simple filename (no path components), then we'll look
        up that catalog file in the CatAdmin's list of installed catalogs, else
        we'll use the name as-is.

    CatalogBaseAddress - optionally, supplies the address of a buffer containing
        the entire catalog image with which our enumerated catalog must match
        before being considered a correct validation.  This is used when copying
        OEM INFs, for example, when there may be multiple installed catalogs
        that can validate an INF, but we want to make sure that we pick _the_
        catalog that matches the one we're contemplating installing before we'll
        consider our INF/CAT files to be duplicates of the previously-existing
        files.

        This parameter (and its partner, CatalogImageSize) are only used when
        Catalog doesn't specify a file path.

    CatalogImageSize - if CatalogBaseAddress is specified, this parameter give
        the size, in bytes, of that buffer.

    Key - supplies a value that "indexes" the catalog, telling the verify APIs
        which signature datum within the catalog it should use. Typically
        the key is the (original) filename of a file.

    FileFullPath - supplies the full path of the file to be verified.

    Problem - if supplied, this parameter points to a variable that will be
        filled in upon unsuccessful return with the cause of failure.  If this
        parameter is not supplied, then the ProblemFile parameter is ignored.

    ProblemFile - if supplied, this parameter points to a character buffer of at
        least MAX_PATH characters that receives the name of the file for which
        a verification error occurred (the contents of this buffer are undefined
        if verification succeeds.

        If the Problem parameter is supplied, then the ProblemFile parameter
        must also be specified.

    CatalogAlreadyVerified - if TRUE, then verification won't be done on the
        catalog--we'll just use that catalog to validate the file of interest.
        If this is TRUE, then Catalog must be specified, must contain the path
        to the catalog file (i.e., it can't be a simple filename).

    AltPlatformInfo - optionally, supplies alternate platform information used
        to fill in a DRIVER_VER_INFO structure (defined in sdk\inc\softpub.h)
        that is passed to WinVerifyTrust.

        **  NOTE:  This structure _must_ have its cbSize field set to        **
        **  sizeof(SP_ALTPLATFORM_INFO_V2) -- validation on client-supplied  **
        **  buffer is the responsibility of the caller.                      **

    Flags - supplies flags that alter that behavior of this routine.  May be a
        combination of the following values:

        VERIFY_FILE_IGNORE_SELFSIGNED - if this bit is set, then this routine
                                        will fail validation for self-signed
                                        binaries.

        VERIFY_FILE_USE_OEM_CATALOGS  - if this bit is set, then all catalogs
                                        installed in the system will be scanned
                                        to verify the given file.  Otherwise,
                                        OEM (3rd party) catalogs will NOT be
                                        scanned to verify the given file.  This
                                        is only applicable if a catalog is not
                                        specified.

        VERIFY_FILE_FAIL_COPIED_INFS  - This flag is ignored.  (It is only used
                                        by the VerifySourceFile routine.)

        VERIFY_FILE_DRIVERBLOCKED_ONLY - Only check if the file is in the bad
                                         driver database, don't do any digital
                                         sigature validation.

        VERIFY_FILE_NO_DRIVERBLOCKED_CHECK - Don't check if the file is blocked
                                             via the Bad Driver Database.

    CatalogFileUsed - if supplied, this parameter points to a character buffer
        at least MAX_PATH characters big that receives the name of the catalog
        file used to verify the specified file.  This is only filled in upon
        successful return, or when the Problem is SetupapiVerifyFileProblem
        (i.e., the catalog verified, but the file did not).  If this buffer is
        set to the empty string upon a SetupapiVerifyFileProblem failure, then
        we didn't find any applicable catalogs to use for validation.

        Also, this buffer will contain an empty string upon successful return
        if the file was validated without using a catalog (i.e., the file
        contains its own signature).

    NumCatalogsConsidered - if supplied, this parameter receives a count of the
        number of catalogs against which verification was attempted.  Of course,
        if Catalog is specified, this number will always be either zero or one.

    DigitalSigner - if supplied, this parameter points to a character buffer of
        at least MAX_PATH characters that receives the name of who digitally
        signed the specified file. This value is only set if the Key is
        correctly signed (i.e. the function returns NO_ERROR).

    SignerVersion - if supplied, this parameter points to a character buffer of
        at least MAX_PATH characters that receives the the signer version as
        returned in the szwVerion field of the DRIVER_VER_INFO structure in
        our call to WinVerifyTrust.

Return Value:

    If successful, the return value is NO_ERROR.
    If failure, the return value is a Win32 error code indicating the cause of
    the failure.

--*/

{
    LPBYTE Hash;
    DWORD HashSize;
    CATALOG_INFO CatInfo;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HCATINFO hCatInfo;
    HCATINFO PrevCat;
    DWORD Err;
    WINTRUST_DATA WintrustData;
    WINTRUST_CATALOG_INFO WintrustCatalogInfo;
    WINTRUST_FILE_INFO WintrustFileInfo;
    DRIVER_VER_INFO VersionInfo;
    LPTSTR CatalogFullPath;
    WCHAR UnicodeKey[MAX_PATH];
#ifndef UNICODE
    CHAR AnsiBuffer[MAX_PATH];
#endif
    WIN32_FILE_ATTRIBUTE_DATA FileAttribData;
    BOOL FoundMatchingImage;
    DWORD CurCatFileSize;
    HANDLE CurCatFileHandle, CurCatMappingHandle;
    PVOID CurCatBaseAddress;
    BOOL LoggedWarning;
    BOOL TrySelfSign;
    DWORD AltPlatSlot;
    TAGREF tagref = TAGREF_NULL;
    HCATADMIN LocalhCatAdmin = NULL;
#ifdef UNICODE
    HSDB LocalhSDBDrvMain = NULL;
#endif

    //
    // Initialize the CatalogFileUsed parameter to an empty string (i.e., no
    // applicable catalog at this point).
    //
    if(CatalogFileUsed) {
        *CatalogFileUsed = TEXT('\0');
    }

    //
    // Initialize the output counter indicating the number of catalog files we
    // processed during the attempted verification.
    //
    if(NumCatalogsConsidered) {
        *NumCatalogsConsidered = 0;
    }

    if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
        //
        // The existing behavior of this API in the ANSI case where the crypto
        // APIs aren't available is to set the CatalogFileUsed OUT param to an
        // empty string and report NO_ERROR.  We'll do the same thing here (but
        // we'll also assert, because no external callers should care, and if
        // they do, an empty string probably isn't going to make them very
        // happy).
        //
        MYASSERT(!CatalogFileUsed);
        MYASSERT(!NumCatalogsConsidered);

        //
        // We'd better not be called in minimal embedded scenarios where we're
        // asked to provide signer info...
        //
        MYASSERT(!DigitalSigner);
        MYASSERT(!SignerVersion);

        return NO_ERROR;
    }

#ifdef ANSI_SETUPAPI

    //
    // If we are on a system that does not have crypt32.dll, then assume the
    // file is valid.
    //
    if(Dyn_CryptCATAdminAcquireContext == Stub_CryptCATAdminAcquireContext) {
        //
        // Same asserts as above (minimal embedded) case apply here as well...
        //
        MYASSERT(!CatalogFileUsed);
        MYASSERT(!NumCatalogsConsidered);
        MYASSERT(!DigitalSigner);
        MYASSERT(!SignerVersion);

        return NO_ERROR;
    }

#endif

    if(GlobalSetupFlags & PSPGF_AUTOFAIL_VERIFIES) {
        if(Problem) {
            *Problem = SetupapiVerifyAutoFailProblem;
            lstrcpy(ProblemFile, FileFullPath);
        }
        return TRUST_E_FAIL;
    }

    Hash = NULL;
    LoggedWarning = FALSE;
    TrySelfSign = FALSE;
    AltPlatSlot = 0;

    //
    // Doesn't make sense to have both these flags set!
    //
    MYASSERT((Flags & (VERIFY_FILE_DRIVERBLOCKED_ONLY | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK))
             != (VERIFY_FILE_DRIVERBLOCKED_ONLY | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK)
            );

    //
    // If Problem is supplied, then ProblemFile must also be supplied.
    //
    MYASSERT(!Problem || ProblemFile);

    //
    // If the caller claims to have already verified the catalog file, make
    // sure they passed us the full path to one.
    //
    MYASSERT(!CatalogAlreadyVerified || (Catalog && (Catalog != pSetupGetFileTitle(Catalog))));

    //
    // If a catalog image is specified, we'd better have been given a size.
    //
    MYASSERT((CatalogBaseAddress && CatalogImageSize) ||
             !(CatalogBaseAddress || CatalogImageSize));

    //
    // If a catalog image was supplied for comparison, there shouldn't be a file
    // path specified in the Catalog parameter.
    //
    MYASSERT(!CatalogBaseAddress || !(Catalog && (Catalog != pSetupGetFileTitle(Catalog))));

    if(AltPlatformInfo) {

        AltPlatSlot = AllocLogInfoSlotOrLevel(LogContext,SETUP_LOG_VERBOSE,FALSE);
        WriteLogEntry(LogContext,
                      AltPlatSlot,
                      MSG_LOG_VERIFYFILE_ALTPLATFORM,
                      NULL,                        // text message
                      AltPlatformInfo->Platform,
                      AltPlatformInfo->MajorVersion,
                      AltPlatformInfo->MinorVersion,
                      AltPlatformInfo->FirstValidatedMajorVersion,
                      AltPlatformInfo->FirstValidatedMinorVersion
                     );
    }

    if(hCatAdmin) {
        //
        // Caller supplied us with a pointer to a crypto context handle.  If
        // it's NULL, we must acquire it now...
        //
        if(*hCatAdmin) {
            LocalhCatAdmin = *hCatAdmin;
        } else {
            if(CryptCATAdminAcquireContext(&LocalhCatAdmin, &DriverVerifyGuid, 0)) {
                //
                // We successfully acquired a context handle.  Store it in the
                // caller-supplied buffer.
                //
                *hCatAdmin = LocalhCatAdmin;
            } else {
                LocalhCatAdmin = NULL;
            }
        }

    } else {
        //
        // Acquire a temporary crypto context handle to be used only for the
        // duration of this routine...
        //
        if(!CryptCATAdminAcquireContext(&LocalhCatAdmin, &DriverVerifyGuid, 0)) {
            LocalhCatAdmin = NULL;
        }
    }

    //
    // Calculate the hash value for the inf.
    //
    if(LocalhCatAdmin) {

        hFile = CreateFile(FileFullPath,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           0,
                           NULL
                          );

        if(hFile == INVALID_HANDLE_VALUE) {
            Err = GetLastError();
            MYASSERT(Err != NO_ERROR);
            if(Problem) {
                *Problem = SetupapiVerifyFileProblem;
                lstrcpy(ProblemFile, FileFullPath);
            }
        } else {
#ifdef UNICODE
            //
            // Only check if the driver is in the defective driver database if
            // we are NOT in GUI setup, and the caller has NOT passed in the
            // VERIFY_FILE_NO_DRIVERBLOCKED_CHECK flag.
            //
            if(!GuiSetupInProgress &&
               !(Flags & VERIFY_FILE_NO_DRIVERBLOCKED_CHECK)) {

                if(hSDBDrvMain) {
                    //
                    // Caller supplied us with a pointer to an SDB handle for
                    // the bad driver database.  If it's NULL, we must acquire
                    // it now...
                    //
                    if(*hSDBDrvMain) {
                        LocalhSDBDrvMain = *hSDBDrvMain;
                    } else {
                        LocalhSDBDrvMain = SdbInitDatabase(SDB_DATABASE_MAIN_DRIVERS, NULL);
                        if(LocalhSDBDrvMain) {
                            *hSDBDrvMain = LocalhSDBDrvMain;
                        }
                    }

                } else {
                    //
                    // Acquire a temporary handle to drvmain.sdb to be used
                    // only for our call to SdbGetDatabaseMatch.
                    //
                    LocalhSDBDrvMain = SdbInitDatabase(SDB_DATABASE_MAIN_DRIVERS, NULL);
                }

                //
                // Check the bad driver database to see if this file is blocked.
                //
                if(LocalhSDBDrvMain) {

                    tagref = SdbGetDatabaseMatch(LocalhSDBDrvMain,
                                                 Key,
                                                 hFile,
                                                 NULL,
                                                 0);

                    if(tagref != TAGREF_NULL) {
                        //
                        // Read the driver policy to see if this should be 
                        // blocked by usermode or not.
                        // If the 1st bit is set then this should NOT be blocked
                        // by usermode.
                        //
                        ULONG type, size, policy;
                        
                        size = sizeof(policy);
                        policy = 0;
                        type = REG_DWORD;
                        if (SdbQueryDriverInformation(LocalhSDBDrvMain,
                                                      tagref,
                                                      TEXT("Policy"),
                                                      &type,
                                                      &policy,
                                                      &size) != ERROR_SUCCESS) {
                            //
                            // If we can't read the policy then default to 0.
                            // This means we will block in usermode!
                            //
                            policy = 0;
                        }

                        if (!(policy & DDB_DRIVER_POLICY_SETUP_NO_BLOCK_BIT)) {
                            //
                            // This driver is in the database and needs to be blocked!
                            //
                            WriteLogEntry(LogContext,
                                          SETUP_LOG_VERBOSE,
                                          MSG_LOG_DRIVER_BLOCKED_ERROR,
                                          NULL,
                                          FileFullPath ? FileFullPath : TEXT("")
                                         );
    
                            if(Problem) {
                                *Problem = SetupapiVerifyDriverBlocked;
                                lstrcpy(ProblemFile, FileFullPath);
                            }
                            LoggedWarning = TRUE;
                            Err = ERROR_DRIVER_BLOCKED;
                            goto clean0;
                        }
                    }
                } else {
                    Err = GetLastError();
                    //
                    // Log an error that we couldn't access the bad driver
                    // database to check if this is a blocked driver.  (We
                    // don't consider this a fatal error.)
                    //
                    WriteLogEntry(LogContext,
                                  SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                                  MSG_LOG_CANT_ACCESS_BDD,
                                  NULL,
                                  FileFullPath
                                 );
                    WriteLogError(LogContext, SETUP_LOG_ERROR, Err);
                }
            }
#endif

            //
            // If the caller only wanted to check if the file was in the bad
            // driver database then we are done.
            //
            if (Flags & VERIFY_FILE_DRIVERBLOCKED_ONLY) {
                Err = NO_ERROR;
                goto clean0;
            }

            //
            // Initialize some of the structures that will be used later on
            // in calls to WinVerifyTrust.  We don't know if we're verifying
            // against a catalog or against a file yet.
            //
            ZeroMemory(&WintrustData, sizeof(WINTRUST_DATA));
            WintrustData.cbStruct = sizeof(WINTRUST_DATA);
            WintrustData.dwUIChoice = WTD_UI_NONE;
            WintrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
            WintrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
            WintrustData.dwProvFlags = WTD_REVOCATION_CHECK_NONE;

            ZeroMemory(&VersionInfo, sizeof(DRIVER_VER_INFO));
            VersionInfo.cbStruct = sizeof(DRIVER_VER_INFO);

            if(AltPlatformInfo) {

                MYASSERT(AltPlatformInfo->cbSize == sizeof(SP_ALTPLATFORM_INFO_V2));

                //
                // Caller wants the file validated for an alternate
                // platform, so we must fill in a DRIVER_VER_INFO structure
                // to be passed to the policy module.
                //
                VersionInfo.dwPlatform = AltPlatformInfo->Platform;
                VersionInfo.dwVersion  = AltPlatformInfo->MajorVersion;

                VersionInfo.sOSVersionLow.dwMajor  = AltPlatformInfo->FirstValidatedMajorVersion;
                VersionInfo.sOSVersionLow.dwMinor  = AltPlatformInfo->FirstValidatedMinorVersion;
                VersionInfo.sOSVersionHigh.dwMajor = AltPlatformInfo->MajorVersion;
                VersionInfo.sOSVersionHigh.dwMinor = AltPlatformInfo->MinorVersion;

            } else {
                //
                // If an AltPlatformInfo was not passed in then set the
                // WTD_USE_DEFAULT_OSVER_CHECK flag. This flag tells
                // WinVerifyTrust to use its default osversion checking, even
                // though a DRIVER_VER_INFO structure was passed in.
                //
                WintrustData.dwProvFlags |= WTD_USE_DEFAULT_OSVER_CHECK;
            }

            //
            // Always specify a DRIVER_VER_INFO structure so we can get back
            // who signed the file and the signer version information.
            // If we don't have an AltPlatformInfo then set the
            // WTD_USE_DEFAULT_OSVER_CHECK flag so that WinVerifyTrust will do
            // its default checking, just as if a DRIVER_VER_INFO structure
            // was not passed in.
            //
            WintrustData.pPolicyCallbackData = (PVOID)&VersionInfo;


            //
            // Start out with a hash buffer size that should be large enough for
            // most requests.
            //
            HashSize = 100;
            do {
                Hash = MyMalloc(HashSize);
                if(!Hash) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                if(CryptCATAdminCalcHashFromFileHandle(hFile, &HashSize, Hash, 0)) {
                    Err = NO_ERROR;
                } else {
                    Err = GetLastError();
                    MYASSERT(Err != NO_ERROR);
                    //
                    // If this API did mess up and not set last error, go ahe