NTEXT pFindCert;           // freed if found
        HCERTSTORE hStore;                  // cached, don't close
        BYTE rgbCertHash[SHA1_HASH_LEN];
        CRYPT_HASH_BLOB CertHash;

        // Open the store where the CA certificate must exist to be trusted.
        // Note, this store is cached with auto resync enabled.
        if (NULL == (hStore = OpenNTAuthStore()))
            goto OpenNTAuthStoreError;

        // Try to find the CA certificate in the store
        CertHash.cbData = sizeof(rgbCertHash);
        CertHash.pbData = rgbCertHash;
        if (!CertGetCertificateContextProperty(
                pChain->rgpElement[1]->pCertContext,
                CERT_SHA1_HASH_PROP_ID,
                CertHash.pbData,
                &CertHash.cbData
                ))
            goto GetHashPropertyError;
        if (NULL == (pFindCert = CertFindCertificateInStore(
                hStore,
                0,                      // dwCertEncodingType
                0,                      // dwFindFlags
                CERT_FIND_SHA1_HASH,
                &CertHash,
                NULL                    // pPrevCertContext
                )))
            goto UntrustedNTAuthCert;
        CertFreeCertificateContext(pFindCert);
    }

    if (dwError) {
        // For NO_REVOCATION or REVOCATION_OFFLINE update indices
        pPolicyStatus->lChainIndex = lChainIndex;
        pPolicyStatus->lElementIndex = lElementIndex;
    }
CommonReturn:
    pPolicyStatus->dwError = dwError;
    return TRUE;

ErrorReturn:
    pPolicyStatus->lChainIndex = 0;
    pPolicyStatus->lElementIndex = 1;
MissingCACert:
    dwError = (DWORD) CERT_E_UNTRUSTEDCA;
    goto CommonReturn;
TRACE_ERROR(OpenNTAuthStoreError)
TRACE_ERROR(GetHashPropertyError)
TRACE_ERROR(UntrustedNTAuthCert)
}

//+-------------------------------------------------------------------------
//  SHA1 Key Identifier of the Microsoft roots
//--------------------------------------------------------------------------
const BYTE MicrosoftRootList[][SHA1_HASH_LEN] = {
#ifndef USE_TEST_ROOT_FOR_TESTING
    // The following is the sha1 key identifier for the Microsoft root
    {
        0x4A, 0x5C, 0x75, 0x22, 0xAA, 0x46, 0xBF, 0xA4, 0x08, 0x9D,
        0x39, 0x97, 0x4E, 0xBD, 0xB4, 0xA3, 0x60, 0xF7, 0xA0, 0x1D
    },

    // The following is the sha1 key identifier for the Microsoft root
    // generated in 2001 with a key length of 4096 bits
    {
        0x0E, 0xAC, 0x82, 0x60, 0x40, 0x56, 0x27, 0x97, 0xE5, 0x25,
        0x13, 0xFC, 0x2A, 0xE1, 0x0A, 0x53, 0x95, 0x59, 0xE4, 0xA4
    },
#else
    // The following is the sha1 key identifier for the test root
    {
        0x9A, 0xA6, 0x58, 0x7F, 0x94, 0xDD, 0x91, 0xD9, 0x1E, 0x63,
        0xDF, 0xD3, 0xF0, 0xCE, 0x5F, 0xAE, 0x18, 0x93, 0xAA, 0xB7
    },
#endif
};

#define MICROSOFT_ROOT_LIST_CNT  (sizeof(MicrosoftRootList) / \
                                        sizeof(MicrosoftRootList[0]))


BOOL
WINAPI
CertDllVerifyMicrosoftRootCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    DWORD dwError;
    LONG lElementIndex;
    PCERT_SIMPLE_CHAIN pChain;
    DWORD cChainElement;
    PCCERT_CONTEXT pCert;   // not refCount'ed
    BYTE rgbKeyId[SHA1_HASH_LEN];
    DWORD cbKeyId;
    DWORD i;

    assert(pPolicyStatus && offsetof(CERT_CHAIN_POLICY_STATUS, lElementIndex) <
            pPolicyStatus->cbSize);

    pChain = pChainContext->rgpChain[0];
    cChainElement = pChain->cElement;

    // Check that the top level certificate contains the public
    // key for the Microsoft root.
    pCert = pChain->rgpElement[cChainElement - 1]->pCertContext;

    cbKeyId = SHA1_HASH_LEN;
    if (!CryptHashPublicKeyInfo(
            NULL,               // hCryptProv
            CALG_SHA1,
            0,                  // dwFlags
            X509_ASN_ENCODING,
            &pCert->pCertInfo->SubjectPublicKeyInfo,
            rgbKeyId,
            &cbKeyId) || SHA1_HASH_LEN != cbKeyId)
        goto HashPublicKeyInfoError;

    for (i = 0; i < MICROSOFT_ROOT_LIST_CNT; i++) {
        if (0 == memcmp(MicrosoftRootList[i], rgbKeyId, SHA1_HASH_LEN))
            goto SuccessReturn;
    }

    goto InvalidMicrosoftRoot;

SuccessReturn:
    dwError = 0;
    lElementIndex = 0;
CommonReturn:
    pPolicyStatus->dwError = dwError;
    pPolicyStatus->lChainIndex = 0;
    pPolicyStatus->lElementIndex = lElementIndex;
    return TRUE;

ErrorReturn:
    dwError = (DWORD) CERT_E_UNTRUSTEDROOT;
    lElementIndex = cChainElement - 1;
    goto CommonReturn;
TRACE_ERROR(HashPublicKeyInfoError)
TRACE_ERROR(InvalidMicrosoftRoot)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\protroot.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       protroot.cpp
//
//  Contents:   Protect Current User (CU) Root Store APIs
//
//  Functions:  I_ProtectedRootDllMain
//              I_CertProtectFunction
//              I_CertSrvProtectFunction
//              IPR_EnableSecurityPrivilege
//              IPR_IsCurrentUserRootsAllowed
//              IPR_IsAuthRootsAllowed
//              IPR_IsNTAuthRequiredDisabled
//              IPR_IsAuthRootAutoUpdateDisabled
//              IPR_InitProtectedRootInfo
//              IPR_DeleteUnprotectedRootsFromStore
//              IPR_ProtectedRootMessageBox
//              IPR_LogCrypt32Event
//              IPR_LogCrypt32Error
//              IPR_LogCertInformation
//              IPR_AddCertInAuthRootAutoUpdateCtl
//
//  History:    23-Nov-97    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <chain.h>
#include <dbgdef.h>

#ifdef STATIC
#undef STATIC
#endif
#define STATIC

// Used for "root" system store's message box
static HMODULE hRegStoreInst;

// # of bytes for a hash. Such as, SHA (20) or MD5 (16)
#define MAX_HASH_LEN                20

#define PROT_ROOT_SUBKEY_NAME       L"ProtectedRoots"
#define PROT_ROOT_CERT_VALUE_NAME   L"Certificates"
#define PROT_ROOT_MAX_CNT           1000000

#define SYSTEM_STORE_REGPATH        L"Software\\Microsoft\\SystemCertificates"
#define PROT_ROOT_REGPATH           \
                SYSTEM_STORE_REGPATH L"\\Root\\" PROT_ROOT_SUBKEY_NAME

//+-------------------------------------------------------------------------
//  Protected root information data structure and defines
//
//  The protected root information is stored in the "Certificates" value of
//  the "root" store's "ProtectedRoots" SubKey.
//--------------------------------------------------------------------------

// In V1, all hashes are SHA1 (length of 20 bytes) and are at the end of
// the info. cbInfo = dwRootOffset + cRoot * 20
typedef struct _PROT_ROOT_INFO {
    DWORD               cbSize;         // sizeof(PROT_ROOT_INFO)
    DWORD               dwVersion;
    FILETIME            LastUpdate;
    DWORD               cRoot;
    DWORD               dwRootOffset;
} PROT_ROOT_INFO, *PPROT_ROOT_INFO;

#define PROT_ROOT_V1            1

// SHA1 hash length
#define PROT_ROOT_HASH_LEN      20


//+-------------------------------------------------------------------------
//  Predefined SIDs allocated once by GetPredefinedSids. Freed at
//  ProcessDetach.
//--------------------------------------------------------------------------
static CRITICAL_SECTION ProtRootCriticalSection;
static BOOL fInitializedPredefinedSids = FALSE;
static PSID psidLocalSystem = NULL;
static PSID psidAdministrators = NULL;
static PSID psidEveryone = NULL;

//+-------------------------------------------------------------------------
//  SID definitions used to set security on the "ProtectedRoots" SubKey.
//--------------------------------------------------------------------------
// Only enable the following if you want to do special testing without
// going through the LocalSystem service.
// #define TESTING_NO_PROT_ROOT_RPC    1

#define PSID_PROT_OWNER             psidAdministrators
#ifdef TESTING_NO_PROT_ROOT_RPC
#define PSID_PROT_SYSTEM            psidAdministrators
#else
#define PSID_PROT_SYSTEM            psidLocalSystem
#endif
#define PSID_PROT_EVERYONE          psidEveryone

//+-------------------------------------------------------------------------
//  ACL definitions used to set security on the "ProtectedRoots" SubKey.
//--------------------------------------------------------------------------
#define PROT_SYSTEM_ACE_MASK        KEY_ALL_ACCESS
#define PROT_EVERYONE_ACE_MASK      KEY_READ
#define PROT_ACE_FLAGS              CONTAINER_INHERIT_ACE

#define PROT_ACE_COUNT              2
#define PROT_SYSTEM_ACE_INDEX       0
#define PROT_EVERYONE_ACE_INDEX     1


//+-------------------------------------------------------------------------
//  Critical Section to Serialize Access to Crypt32 Event Log Data Structures
//--------------------------------------------------------------------------
CRITICAL_SECTION Crypt32EventLogCriticalSection;

//+-------------------------------------------------------------------------
//  Allocate/free predefined SIDs
//--------------------------------------------------------------------------
static BOOL GetPredefinedSids()
{
    if (fInitializedPredefinedSids)
        return TRUE;

    BOOL fResult;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY siaWorldSidAuthority =
        SECURITY_WORLD_SID_AUTHORITY;

    EnterCriticalSection(&ProtRootCriticalSection);

    if (!fInitializedPredefinedSids) {
        if (!AllocateAndInitializeSid(
                &siaNtAuthority,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0, 0, 0, 0, 0, 0, 0,
                &psidLocalSystem
                )) 
            goto AllocateAndInitializeSidError;

        if (!AllocateAndInitializeSid(
                &siaNtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0,
                &psidAdministrators
                ))
            goto AllocateAndInitializeSidError;

        if (!AllocateAndInitializeSid(
                &siaWorldSidAuthority,
                1,
                SECURITY_WORLD_RID,
                0, 0, 0, 0, 0, 0, 0,
                &psidEveryone
                ))
            goto AllocateAndInitializeSidError;

        fInitializedPredefinedSids = TRUE;
    }
    fResult = TRUE;
CommonReturn:
    LeaveCriticalSection(&ProtRootCriticalSection);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(AllocateAndInitializeSidError)
}

static void FreePredefinedSids()
{
    if (fInitializedPredefinedSids) {
        FreeSid(psidLocalSystem);
        FreeSid(psidAdministrators);
        FreeSid(psidEveryone);
    }
}

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
I_ProtectedRootDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL fRet = TRUE;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        // Used for "root" system store's message box
        hRegStoreInst = hInst;

        fRet = Pki_InitializeCriticalSection(&ProtRootCriticalSection);
        if (fRet) {
            fRet = Pki_InitializeCriticalSection(
                &Crypt32EventLogCriticalSection);
            if (!fRet)
                DeleteCriticalSection(&ProtRootCriticalSection);
        }

        I_DBLogAttach();

        break;

    case DLL_PROCESS_DETACH:
        I_DBLogDetach();

        FreePredefinedSids();
        DeleteCriticalSection(&ProtRootCriticalSection);
        DeleteCriticalSection(&Crypt32EventLogCriticalSection);
        break;
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    return fRet;
}

//+=========================================================================
//  Protected root registry flags support function
//==========================================================================

//+-------------------------------------------------------------------------
//  Get the ProtectedRoots Flags DWORD registry value stored in HKLM.
//--------------------------------------------------------------------------
STATIC DWORD GetProtectedRootFlags()
{
    HKEY hKey = NULL;
    LONG err;
    DWORD dwProtRootFlags = 0;

    if (ERROR_SUCCESS != (err = RegOpenKeyExU(
            HKEY_LOCAL_MACHINE,
            CERT_PROT_ROOT_FLAGS_REGPATH,
            0,                      // dwReserved
            KEY_READ,
            &hKey
            ))) goto RegOpenKeyError;
    if (!ILS_ReadDWORDValueFromRegistry(
            hKey,
            CERT_PROT_ROOT_FLAGS_VALUE_NAME,
            &dwProtRootFlags
            )) goto ReadValueError;

CommonReturn:
    ILS_CloseRegistryKey(hKey);
    return dwProtRootFlags;
ErrorReturn:
    dwProtRootFlags = 0;
    goto CommonReturn;

SET_ERROR_VAR(RegOpenKeyError, err)
TRACE_ERROR(ReadValueError)
}

//+=========================================================================
//  Protected root information support functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Open the SubKey containing the protected root information.
//--------------------------------------------------------------------------
STATIC HKEY OpenProtectedRootSubKey(
    IN HKEY hKeyCU,
    IN REGSAM samDesired
    )
{
    LONG err;
    HKEY hKeyProtRoot;

    if (ERROR_SUCCESS != (err = RegOpenKeyExU(
            hKeyCU,
            PROT_ROOT_REGPATH,
            0,                      // dwReserved
            samDesired,
            &hKeyProtRoot)))
        goto RegOpenKeyError;

CommonReturn:
    return hKeyProtRoot;
ErrorReturn:
    hKeyProtRoot = NULL;
    goto CommonReturn;

SET_ERROR_VAR(RegOpenKeyError, err)
}

//+-------------------------------------------------------------------------
//  Create the SubKey containing the protected root information.
//--------------------------------------------------------------------------
STATIC HKEY CreateProtectedRootSubKey(
    IN HKEY hKeyCU,
    IN REGSAM samDesired
    )
{
    LONG err;
    HKEY hKeyProtRoot;
    DWORD dwDisposition;

    if (ERROR_SUCCESS != (err = RegCreateKeyExU(
            hKeyCU,
            PROT_ROOT_REGPATH,
            0,                      // dwReserved
            NULL,                   // lpClass
            REG_OPTION_NON_VOLATILE,
            samDesired,
            NULL,                   // lpSecurityAttributes
            &hKeyProtRoot,
            &dwDisposition)))
        goto RegCreateKeyError;
CommonReturn:
    return hKeyProtRoot;
ErrorReturn:
    hKeyProtRoot = NULL;
    goto CommonReturn;

SET_ERROR_VAR(RegCreateKeyError, err)
}

//+-------------------------------------------------------------------------
//  Allocate, read from registry and verify the protected root info.
//
//  The root hashes are at the end of the info.
//--------------------------------------------------------------------------
STATIC PPROT_ROOT_INFO ReadProtectedRootInfo(
    IN HKEY hKeyProtRoot
    )
{
    PPROT_ROOT_INFO pInfo = NULL;
    DWORD cbInfo;
    DWORD cRoot;
    DWORD dwRootOffset;

    if (!ILS_ReadBINARYValueFromRegistry(
            hKeyProtRoot,
            PROT_ROOT_CERT_VALUE_NAME,
            (BYTE **) &pInfo,
            &cbInfo
            )) goto ReadCertificatesProtInfoValueError;

    if (sizeof(PROT_ROOT_INFO) > cbInfo ||
            sizeof(PROT_ROOT_INFO) > pInfo->cbSize ||
            pInfo->cbSize > cbInfo ||
            PROT_ROOT_V1 != pInfo->dwVersion
            ) goto InvalidProtectedRootInfo;

    // The root hashes must be at the end of the info
    cRoot = pInfo->cRoot;
    dwRootOffset = pInfo->dwRootOffset;
    if (dwRootOffset < pInfo->cbSize || dwRootOffset > cbInfo ||
            PROT_ROOT_MAX_CNT < cRoot ||
            cRoot * PROT_ROOT_HASH_LEN != cbInfo - dwRootOffset
            ) goto InvalidProtectedRootInfo;

CommonReturn:
    return pInfo;
ErrorReturn:
    PkiFree(pInfo);
    pInfo = NULL;
    goto CommonReturn;

TRACE_ERROR(ReadCertificatesProtInfoValueError)
SET_ERROR(InvalidProtectedRootInfo, ERROR_INVALID_DATA)
}

//+-------------------------------------------------------------------------
//  Write the protected root info to the registry.
//
//  The root hashes are at the end of the info. Updates the info's
//  LastUpdate time.
//--------------------------------------------------------------------------
STATIC BOOL WriteProtectedRootInfo(
    IN HKEY hKeyProtRoot,
    IN OUT PPROT_ROOT_INFO pInfo
    )
{
    BOOL fResult;
    LONG err;
    DWORD cbInfo;
    SYSTEMTIME SystemTime;
    FILETIME FileTime;

    cbInfo = pInfo->dwRootOffset + pInfo->cRoot * PROT_ROOT_HASH_LEN;

    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    pInfo->LastUpdate = FileTime;

    if (ERROR_SUCCESS != (err = RegSetValueExU(
            hKeyProtRoot,
            PROT_ROOT_CERT_VALUE_NAME,
            NULL,
            REG_BINARY,
            (BYTE *) pInfo,
            cbInfo
            ))) goto RegSetValueError;
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(RegSetValueError, err)
}


// In the debugger I saw 0x58
#define PROT_ROOT_SD_LEN      0x100

//+-------------------------------------------------------------------------
//  Allocate and get the security descriptor information for the specified
//  registry key.
//--------------------------------------------------------------------------
static PSECURITY_DESCRIPTOR AllocAndGetSecurityDescriptor(
    IN HKEY hKey,
    SECURITY_INFORMATION SecInf
    )
{
    LONG err;
    PSECURITY_DESCRIPTOR psd = NULL;
    DWORD cbsd;

    cbsd = PROT_ROOT_SD_LEN;
    if (NULL == (psd = (PSECURITY_DESCRIPTOR) PkiNonzeroAlloc(cbsd)))
        goto OutOfMemory;

    err = RegGetKeySecurity(
            hKey,
            SecInf,
            psd,
            &cbsd
            );
    if (ERROR_SUCCESS == err)
        goto CommonReturn;
    if (ERROR_INSUFFICIENT_BUFFER != err)
        goto RegGetKeySecurityError;

    if (0 == cbsd)
        goto NoSecurityDescriptor;

    PkiFree(psd);
    psd = NULL;
    if (NULL == (psd = (PSECURITY_DESCRIPTOR) PkiNonzeroAlloc(cbsd)))
        goto OutOfMemory;

    if (ERROR_SUCCESS != (err = RegGetKeySecurity(
            hKey,
            SecInf,
            psd,
            &cbsd
            ))) goto RegGetKeySecurityError;

CommonReturn:
    return psd;
ErrorReturn:
    PkiFree(psd);
    psd = NULL;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(RegGetKeySecurityError, err)
SET_ERROR(NoSecurityDescriptor, ERROR_INVALID_SECURITY_DESCR)
}

//+-------------------------------------------------------------------------
//  Opens the "ProtectedRoots" registry key and verifies its security owner,
//  group, DACLs and SACLs. Must match the security set by
//  SrvGetProtectedRootInfo().
//
//  If the "ProtectedRoots" SubKey has the proper security. Allocates, reads
//  and verifies the "Certificates" value to get the protected root info.
//--------------------------------------------------------------------------
STATIC BOOL GetProtectedRootInfo(
    IN HKEY hKeyCU,
    IN REGSAM samDesired,
    OUT OPTIONAL HKEY *phKeyProtRoot,
    OUT OPTIONAL PPROT_ROOT_INFO *ppInfo
    )
{
    BOOL fResult;
    HKEY hKeyProtRoot = NULL;
    PSECURITY_DESCRIPTOR psd = NULL;
    PPROT_ROOT_INFO pInfo = NULL;
    PSID psidOwner;                 // not allocated
    BOOL fOwnerDefaulted;
    BOOL fDaclPresent;
    PACL pAcl;                      // not allocated
    BOOL fDaclDefaulted;
    DWORD dwAceIndex;
    PACCESS_ALLOWED_ACE rgpAce[PROT_ACE_COUNT];

    if (NULL == (hKeyProtRoot = OpenProtectedRootSubKey(hKeyCU, samDesired)))
        goto OpenProtectedRootSubKeyError;
    if (NULL == (psd = AllocAndGetSecurityDescriptor(
            hKeyProtRoot,
            OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION
            ))) goto GetSecurityDescriptorError;

    if (!GetPredefinedSids())
        goto GetPredefinedSidsError;

    // Verify owner
    if (!GetSecurityDescriptorOwner(psd, &psidOwner, &fOwnerDefaulted))
        goto GetSecurityDescriptorOwnerError;
    if (NULL == psidOwner || !EqualSid(psidOwner, PSID_PROT_OWNER))
        goto InvalidProtectedRootOwner;

    // Verify DACL
    if (!GetSecurityDescriptorDacl(psd, &fDaclPresent, &pAcl,
            &fDaclDefaulted))
        goto GetSecurityDescriptorDaclError;
    if (!fDaclPresent || NULL == pAcl)
        goto MissingProtectedRootDaclError;
    if (PROT_ACE_COUNT != pAcl->AceCount)
        goto InvalidProtectedRootDacl;

    for (dwAceIndex = 0; dwAceIndex < PROT_ACE_COUNT; dwAceIndex++) {
        PACCESS_ALLOWED_ACE pAce;
        if (!GetAce(pAcl, dwAceIndex, (void **) &pAce))
            goto InvalidProtectedRootDacl;
        rgpAce[dwAceIndex] = pAce;

        if (ACCESS_ALLOWED_ACE_TYPE != pAce->Header.AceType ||
                PROT_ACE_FLAGS != pAce->Header.AceFlags)
            goto InvalidProtectedRootDacl;
    }

    if (PROT_SYSTEM_ACE_MASK != rgpAce[PROT_SYSTEM_ACE_INDEX]->Mask ||
            !EqualSid(PSID_PROT_SYSTEM,
                (PSID) &rgpAce[PROT_SYSTEM_ACE_INDEX]->SidStart) ||
            PROT_EVERYONE_ACE_MASK != rgpAce[PROT_EVERYONE_ACE_INDEX]->Mask ||
            !EqualSid(PSID_PROT_EVERYONE,
                (PSID) &rgpAce[PROT_EVERYONE_ACE_INDEX]->SidStart))
        goto InvalidProtectedRootDacl;

    // Get verified protected root info
    if (NULL == (pInfo = ReadProtectedRootInfo(hKeyProtRoot)))
        goto ReadProtectedRootInfoError;

    fResult = TRUE;
CommonReturn:
    PkiFree(psd);
    if (phKeyProtRoot)
        *phKeyProtRoot = hKeyProtRoot;
    else
        ILS_CloseRegistryKey(hKeyProtRoot);
    if (ppInfo)
        *ppInfo = pInfo;
    else
        PkiFree(pInfo);
    return fResult;
ErrorReturn:
    ILS_CloseRegistryKey(hKeyProtRoot);
    hKeyProtRoot = NULL;
    PkiFree(pInfo);
    pInfo = NULL;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenProtectedRootSubKeyError)
TRACE_ERROR(GetSecurityDescriptorError)
TRACE_ERROR(GetPredefinedSidsError)
TRACE_ERROR(GetSecurityDescriptorOwnerError)
TRACE_ERROR(GetSecurityDescriptorDaclError)
SET_ERROR(InvalidProtectedRootOwner, ERROR_INVALID_OWNER)
SET_ERROR(MissingProtectedRootDaclError, ERROR_INVALID_ACL)
SET_ERROR(InvalidProtectedRootDacl, ERROR_INVALID_ACL)
TRACE_ERROR(ReadProtectedRootInfoError)
}


//+=========================================================================
//  Functions to find, add or delete a root hash from the protected root
//  info.
//==========================================================================
STATIC BOOL FindProtectedRoot(
    IN PPROT_ROOT_INFO pInfo,
    IN BYTE rgbFindRootHash[PROT_ROOT_HASH_LEN],
    OUT OPTIONAL DWORD *pdwRootIndex = NULL
    )
{
    BYTE *pbRoot = (BYTE *) pInfo + pInfo->dwRootOffset;
    DWORD cRoot = pInfo->cRoot;
    DWORD dwRootIndex = 0;
    BYTE bFirst = rgbFindRootHash[0];

    for ( ; dwRootIndex < cRoot; dwRootIndex++, pbRoot += PROT_ROOT_HASH_LEN) {
        if (bFirst == *pbRoot &&
                0 == memcmp(rgbFindRootHash, pbRoot, PROT_ROOT_HASH_LEN)) {
            if (pdwRootIndex)
                *pdwRootIndex = dwRootIndex;
            return TRUE;
        }
    }
    if (pdwRootIndex)
        *pdwRootIndex = 0;
    return FALSE;
}

// Root hash is appended to the end of the list
STATIC BOOL AddProtectedRoot(
    IN OUT PPROT_ROOT_INFO *ppInfo,
    IN BYTE rgbAddRootHash[PROT_ROOT_HASH_LEN]
    )
{
    PPROT_ROOT_INFO pInfo = *ppInfo;
    DWORD cRoot = pInfo->cRoot;
    DWORD dwRootOffset = pInfo->dwRootOffset;
    DWORD cbInfo;

    if (PROT_ROOT_MAX_CNT <= cRoot) {
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    cbInfo = dwRootOffset + (cRoot + 1) * PROT_ROOT_HASH_LEN;

    if (NULL == (pInfo = (PPROT_ROOT_INFO) PkiRealloc(pInfo, cbInfo)))
        return FALSE;

    memcpy((BYTE *) pInfo + (dwRootOffset + cRoot * PROT_ROOT_HASH_LEN),
        rgbAddRootHash, PROT_ROOT_HASH_LEN);
    pInfo->cRoot = cRoot + 1;
    *ppInfo = pInfo;
    return TRUE;
}

STATIC void DeleteProtectedRoot(
    IN PPROT_ROOT_INFO pInfo,
    IN DWORD dwDeleteRootIndex
    )
{
    DWORD cRoot = pInfo->cRoot;
    BYTE *pbRoot = (BYTE *) pInfo + pInfo->dwRootOffset;

    assert(0 < cRoot);
    assert(dwDeleteRootIndex < cRoot);
    cRoot--;

    if (cRoot > dwDeleteRootIndex) {
        // Move following roots down
        BYTE *pbDst = pbRoot + dwDeleteRootIndex * PROT_ROOT_HASH_LEN;
        BYTE *pbSrc = pbDst + PROT_ROOT_HASH_LEN;
        DWORD cbMove = (cRoot - dwDeleteRootIndex) * PROT_ROOT_HASH_LEN;
        while (cbMove--)
            *pbDst++ = *pbSrc++;
    }
    // else
    //  last root in list

    pInfo->cRoot = cRoot;
}

//+=========================================================================
//  Certificate store support functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Opens the SystemRegistry "Root" store unprotected and relative to the
//  specifed base SubKey.
//--------------------------------------------------------------------------
STATIC HCERTSTORE OpenUnprotectedRootStore(
    IN HKEY hKeyCU,
    IN DWORD dwOpenFlags = 0
    )
{
    CERT_SYSTEM_STORE_RELOCATE_PARA RelocatePara;

    RelocatePara.hKeyBase = hKeyCU;
    RelocatePara.pwszSystemStore = L"Root";
    return CertOpenStore(
        CERT_STORE_PROV_SYSTEM_REGISTRY_W,
        0,                                  // dwEncodingType
        NULL,                               // hCryptProv
        CERT_SYSTEM_STORE_RELOCATE_FLAG |
            CERT_SYSTEM_STORE_UNPROTECTED_FLAG |
            CERT_SYSTEM_STORE_CURRENT_USER |
            dwOpenFlags,
        (const void *) &RelocatePara
        );
}

//+-------------------------------------------------------------------------
//  Gets the certificate's SHA1 hash property. Rehashes the encoded
//  certificate. Returns TRUE if the property matches the regenerated hash.
//--------------------------------------------------------------------------
static BOOL GetVerifiedCertHashProperty(
    IN PCCERT_CONTEXT pCert,
    OUT BYTE rgbHash[PROT_ROOT_HASH_LEN]
    )
{
    BYTE rgbProp[PROT_ROOT_HASH_LEN];
    DWORD cbData;
    
    cbData = PROT_ROOT_HASH_LEN;
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_SHA1_HASH_PROP_ID,
            rgbProp,
            &cbData
            ) || PROT_ROOT_HASH_LEN != cbData)
        return FALSE;

    // Verify the property
    cbData = PROT_ROOT_HASH_LEN;
    if (!CryptHashCertificate(
            0,                  // hProv
            CALG_SHA1,
            0,                  //dwFlags
            pCert->pbCertEncoded,
            pCert->cbCertEncoded,
            rgbHash,
            &cbData
            ) || PROT_ROOT_HASH_LEN != cbData)
        return FALSE;
    return (0 == memcmp(rgbHash, rgbProp, PROT_ROOT_HASH_LEN));
}


//+=========================================================================
//  FormatMsgBox support functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Formats multi bytes into WCHAR hex. Includes a space after every 4 bytes.
//
//  Needs (cb * 2 + cb/4 + 1) characters in wsz
//--------------------------------------------------------------------------
static void FormatMsgBoxMultiBytes(DWORD cb, BYTE *pb, LPWSTR wsz)
{
    for (DWORD i = 0; i<cb; i++) {
        int b;
        if (i && 0 == (i & 3))
            *wsz++ = L' ';
        b = (*pb & 0xF0) >> 4;
        *wsz++ = (WCHAR)( (b <= 9) ? b + L'0' : (b - 10) + L'A');
        b = *pb & 0x0F;
        *wsz++ = (WCHAR) ((b <= 9) ? b + L'0' : (b - 10) + L'A');
        pb++;
    }
    *wsz++ = 0;
}

//+-------------------------------------------------------------------------
//  Format and allocate a single message box item
//
//  The formatted item needs to be LocalFree'ed.
//--------------------------------------------------------------------------
static void FormatMsgBoxItem(
    OUT LPWSTR *ppwszMsg,
    OUT DWORD *pcchMsg,
    IN UINT nFormatID,
    ...
    )
{
    // get format string from resources
    WCHAR wszFormat[256];
    wszFormat[0] = '\0';
    LoadStringU(hRegStoreInst, nFormatID, wszFormat,
        sizeof(wszFormat)/sizeof(wszFormat[0]));

    // format message into requested buffer
    va_list argList;
    va_start(argList, nFormatID);
    *ppwszMsg = NULL;
    *pcchMsg = FormatMessageU(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        wszFormat,
        0,                  // dwMessageId
        0,                  // dwLanguageId
        (LPWSTR) ppwszMsg,
        0,                  // minimum size to allocate
        &argList);

    va_end(argList);
}


//+=========================================================================
//  Protected root functions called from the services process
//==========================================================================


//+-------------------------------------------------------------------------
//  Enable the specified security privilege for the current process.
//
//  Also, called from logstor.cpp to enable SE_BACKUP_NAME and
//  SE_RESTORE_NAME for CERT_STORE_BACKUP_RESTORE_FLAG.
//--------------------------------------------------------------------------
BOOL
IPR_EnableSecurityPrivilege(
    LPCSTR pszPrivilege
    )
{
    BOOL fResult;
    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES tp;
    LUID luid;
    TOKEN_PRIVILEGES tpPrevious;
    DWORD cbPrevious;

    if (!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            &hToken
            ))
        goto OpenProcessTokenError;

    if (!LookupPrivilegeValueA(NULL, pszPrivilege, &luid))
        goto LookupPrivilegeValueError;

    //
    // first pass.  get current privilege setting
    //
    tp.PrivilegeCount           = 1;
    tp.Privileges[0].Luid       = luid;
    tp.Privileges[0].Attributes = 0;

    cbPrevious = sizeof(TOKEN_PRIVILEGES);
    memset(&tpPrevious, 0, sizeof(TOKEN_PRIVILEGES));
    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tp,
            sizeof(TOKEN_PRIVILEGES),
            &tpPrevious,
            &cbPrevious
            );
    if (ERROR_SUCCESS != GetLastError())
        goto AdjustTokenPrivilegesError;

    //
    // second pass.  enable privilege
    //
    if (0 == tpPrevious.PrivilegeCount)
        tpPrevious.Privileges[0].Attributes = 0;

    tpPrevious.PrivilegeCount       = 1;
    tpPrevious.Privileges[0].Luid   = luid;
    tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tpPrevious,
            cbPrevious,
            NULL,
            NULL
            );
    if (ERROR_SUCCESS != GetLastError())
        goto AdjustTokenPrivilegesError;

    fResult = TRUE;
CommonReturn:
    if (hToken)
        CloseHandle(hToken);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenProcessTokenError)
TRACE_ERROR(LookupPrivilegeValueError)
TRACE_ERROR(AdjustTokenPrivilegesError)
}

//+-------------------------------------------------------------------------
//  Take ownership of the "ProtectedRoots" SubKey
//--------------------------------------------------------------------------
STATIC BOOL SetProtectedRootOwner(
    IN HKEY hKeyCU,
    OUT BOOL *pfNew
    )
{
    BOOL fResult;
    LONG err;
    BOOL fNew = FALSE;
    HKEY hKeyProtRoot = NULL;
    SECURITY_DESCRIPTOR sd;

    if (!IPR_EnableSecurityPrivilege(SE_TAKE_OWNERSHIP_NAME))
        goto EnableTakeOwnershipPrivilegeError;

    if (hKeyProtRoot = OpenProtectedRootSubKey(hKeyCU, WRITE_OWNER))
        fNew = FALSE;
    else {
        if (ERROR_FILE_NOT_FOUND == GetLastError())
            hKeyProtRoot = CreateProtectedRootSubKey(hKeyCU, WRITE_OWNER);
        if (NULL == hKeyProtRoot)
            goto OpenProtectedRootSubKeyError;
        fNew = TRUE;
    }

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
        goto InitializeSecurityDescriptorError;

    if (!SetSecurityDescriptorOwner(&sd, PSID_PROT_OWNER, FALSE))
        goto SetSecurityDescriptorOwnerError;

    if (ERROR_SUCCESS != (err = RegSetKeySecurity(
            hKeyProtRoot,
            OWNER_SECURITY_INFORMATION,
            &sd
            )))
        goto RegSetKeySecurityError;

    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hKeyProtRoot);
    *pfNew = fNew;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(EnableTakeOwnershipPrivilegeError)
TRACE_ERROR(OpenProtectedRootSubKeyError)
TRACE_ERROR(InitializeSecurityDescriptorError)
TRACE_ERROR(SetSecurityDescriptorOwnerError)
SET_ERROR_VAR(RegSetKeySecurityError, err)
}

//+-------------------------------------------------------------------------
//  Allocate and get the specified token info.
//--------------------------------------------------------------------------
static void * AllocAndGetTokenInfo(
    IN HANDLE hToken,
    IN TOKEN_INFORMATION_CLASS tic
    )
{
    void *pvInfo = NULL;
    DWORD cbInfo = 0;
    DWORD cbInfo2;

    if (!GetTokenInformation(
            hToken,
            tic,
            pvInfo,
            0,              // cbInfo
            &cbInfo
            )) {
        if (ERROR_INSUFFICIENT_BUFFER != GetLastError())
            goto GetTokenInfoError;
    }
    if (0 == cbInfo)
        goto NoTokenInfoError;
    if (NULL == (pvInfo = PkiNonzeroAlloc(cbInfo)))
        goto OutOfMemory;

    cbInfo2 = cbInfo;
    if (!GetTokenInformation(
            hToken,
            tic,
            pvInfo,
            cbInfo,
            &cbInfo2
            ))
        goto GetTokenInfoError;

CommonReturn:
    return pvInfo;
ErrorReturn:
    PkiFree(pvInfo);
    pvInfo = NULL;
    goto CommonReturn;
TRACE_ERROR(GetTokenInfoError)
SET_ERROR(NoTokenInfoError, ERROR_NO_TOKEN)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Set the security group, DACLs and SACLs for the "ProtectedRoots" SubKey
//--------------------------------------------------------------------------
STATIC BOOL SetProtectedRootGroupDaclSacl(
    IN HKEY hKeyCU
    )
{
    BOOL fResult;
    LONG err;
    HKEY hKeyProtRoot = NULL;
    SECURITY_DESCRIPTOR sd;
    HANDLE hToken = NULL;
    void *pvTokenInfo = NULL;

    PACL pDacl = NULL;
    PACCESS_ALLOWED_ACE pAce;
    DWORD dwAclSize;
    DWORD i;

    if (!IPR_EnableSecurityPrivilege(SE_SECURITY_NAME))
        goto EnableSecurityNamePrivilegeError;

    if (NULL == (hKeyProtRoot = OpenProtectedRootSubKey(
            hKeyCU,
            WRITE_OWNER | WRITE_DAC | ACCESS_SYSTEM_SECURITY
            )))
        goto OpenProtectedRootSubKeyError;

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
        goto InitializeSecurityDescriptorError;

    // Set group SID using current process token's primary group SID
    if (!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY,
            &hToken
            ))
        goto OpenProcessTokenError;
    if (NULL == (pvTokenInfo = AllocAndGetTokenInfo(hToken, TokenPrimaryGroup)))
        goto GetTokenInfoError;
    else {
        PTOKEN_PRIMARY_GROUP pTokenPrimaryGroup =
            (PTOKEN_PRIMARY_GROUP) pvTokenInfo;
        PSID psidGroup = pTokenPrimaryGroup->PrimaryGroup;

        if (!SetSecurityDescriptorGroup(&sd, psidGroup, FALSE))
            goto SetSecurityDescriptorGroupError;
    }

    // Set DACL

    //
    // compute size of ACL
    //
    dwAclSize = sizeof(ACL) +
        PROT_ACE_COUNT * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
        GetLengthSid(PSID_PROT_SYSTEM) +
        GetLengthSid(PSID_PROT_EVERYONE)
        ;

    //
    // allocate storage for Acl
    //
    if (NULL == (pDacl = (PACL) PkiNonzeroAlloc(dwAclSize)))
        goto OutOfMemory;

    if (!InitializeAcl(pDacl, dwAclSize, ACL_REVISION))
        goto InitializeAclError;

    if (!AddAccessAllowedAce(
            pDacl,
            ACL_REVISION,
            PROT_SYSTEM_ACE_MASK,
            PSID_PROT_SYSTEM
            ))
        goto AddAceError;
    if (!AddAccessAllowedAce(
            pDacl,
            ACL_REVISION,
            PROT_EVERYONE_ACE_MASK,
            PSID_PROT_EVERYONE
            ))
        goto AddAceError;

    //
    // make containers inherit.
    //
    for (i = 0; i < PROT_ACE_COUNT; i++) {
        if(!GetAce(pDacl, i, (void **) &pAce))
            goto GetAceError;
        pAce->Header.AceFlags = PROT_ACE_FLAGS;
    }

    if (!SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE))
        goto SetSecurityDescriptorDaclError;

    // Set SACL
    if (!SetSecurityDescriptorSacl(&sd, FALSE, NULL, FALSE))
        goto SetSecurityDescriptorSaclError;

    if (ERROR_SUCCESS != (err = RegSetKeySecurity(
            hKeyProtRoot,
            GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION |
                SACL_SECURITY_INFORMATION,
            &sd
            )))
        goto RegSetKeySecurityError;

    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hKeyProtRoot);
    if (hToken)
        CloseHandle(hToken);
    PkiFree(pvTokenInfo);
    PkiFree(pDacl);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(EnableSecurityNamePrivilegeError)
TRACE_ERROR(OpenProtectedRootSubKeyError)
TRACE_ERROR(InitializeSecurityDescriptorError)
TRACE_ERROR(OpenProcessTokenError)
TRACE_ERROR(GetTokenInfoError)
TRACE_ERROR(SetSecurityDescriptorGroupError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(InitializeAclError)
TRACE_ERROR(AddAceError)
TRACE_ERROR(GetAceError)
TRACE_ERROR(SetSecurityDescriptorDaclError)
TRACE_ERROR(SetSecurityDescriptorSaclError)
SET_ERROR_VAR(RegSetKeySecurityError, err)
}

//+-------------------------------------------------------------------------
//  Create the initial protected root info.
//
//  If not inhibited, add all the roots in the unprotected CurrentUser
//  "Root" store.
//--------------------------------------------------------------------------
STATIC BOOL InitAndSetProtectedRootInfo(
    IN HKEY hKeyCU,
    IN BOOL fNew
    )
{
    BOOL fResult;
    HKEY hKeyProtRoot = NULL;
    HCERTSTORE hStore = NULL;
    PPROT_ROOT_INFO pInfo = NULL;

    if (NULL == (pInfo = (PPROT_ROOT_INFO) PkiNonzeroAlloc(
            sizeof(PROT_ROOT_INFO))))
        goto OutOfMemory;
    memset(pInfo, 0, sizeof(PROT_ROOT_INFO));
    pInfo->cbSize = sizeof(PROT_ROOT_INFO);
    pInfo->dwVersion = PROT_ROOT_V1;
    pInfo->dwRootOffset = sizeof(PROT_ROOT_INFO);

    if (fNew && 0 == (GetProtectedRootFlags() &
            CERT_PROT_ROOT_INHIBIT_ADD_AT_INIT_FLAG)) {
        if (hStore = OpenUnprotectedRootStore(hKeyCU,
                CERT_STORE_READONLY_FLAG)) {
            PCCERT_CONTEXT pCert = NULL;
            while (pCert = CertEnumCertificatesInStore(hStore, pCert)) {
                BYTE rgbHash[PROT_ROOT_HASH_LEN];
                if (GetVerifiedCertHashProperty(pCert, rgbHash)) {
                    if (!AddProtectedRoot(&pInfo, rgbHash))
                        goto AddProtectedRootError;
                }
            }
        }
    }

    if (NULL == (hKeyProtRoot = OpenProtectedRootSubKey(
            hKeyCU,
            KEY_ALL_ACCESS
            ))) goto OpenProtectedRootSubKeyError;

    if (!WriteProtectedRootInfo(hKeyProtRoot, pInfo))
        goto WritedProtectedRootInfoError;

    fResult = TRUE;
CommonReturn:
    PkiFree(pInfo);
    CertCloseStore(hStore, 0);
    ILS_CloseRegistryKey(hKeyProtRoot);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(AddProtectedRootError)
TRACE_ERROR(OpenProtectedRootSubKeyError)
TRACE_ERROR(WritedProtectedRootInfoError)
}

//+-------------------------------------------------------------------------
//  Open the "ProtectedRoots" SubKey and verify its security. Allocate,
//  read and verify the protected root information.
//
//  If the "ProtectedRoots" SubKey doesn't exist or is invalid, initialize.
//--------------------------------------------------------------------------
STATIC BOOL SrvGetProtectedRootInfo(
    IN HKEY hKeyCU,
    OUT OPTIONAL HKEY *phKeyProtRoot,
    OUT OPTIONAL PPROT_ROOT_INFO *ppProtRootInfo
    )
{
    BOOL fNew;
    if (GetProtectedRootInfo(
            hKeyCU,
            KEY_ALL_ACCESS,
            phKeyProtRoot,
            ppProtRootInfo
            ))
        return TRUE;

    if (!GetPredefinedSids())
        return FALSE;

    if (!SetProtectedRootOwner(hKeyCU, &fNew))
        return FALSE;
    if (!SetProtectedRootGroupDaclSacl(hKeyCU))
        return FALSE;
    if (!InitAndSetProtectedRootInfo(hKeyCU, fNew))
        return FALSE;

    return GetProtectedRootInfo(
        hKeyCU,
        KEY_ALL_ACCESS,
        phKeyProtRoot,
        ppProtRootInfo
        );
}

//+-------------------------------------------------------------------------
//  Initialize the protected list of CurrentUser roots
//--------------------------------------------------------------------------
STATIC BOOL SrvInitProtectedRoots(
    IN HKEY hKeyCU
    )
{
    return SrvGetProtectedRootInfo(
        hKeyCU,
        NULL,           // phKeyProtRoot
        NULL            // ppProtRootInfo
        );
}

//+-------------------------------------------------------------------------
//  Purge all CurrentUser roots from the protected list that also exist
//  in the LocalMachine SystemRegistry "Root" store. Also removes duplicated
//  certificates from the CurrentUser SystemRegistry "Root" store.
//--------------------------------------------------------------------------
STATIC BOOL SrvPurgeLocalMachineProtectedRoots(
    IN HKEY hKeyCU,
    IN LPCWSTR pwszRootStoreName
    )
{
    BOOL fResult;
    HKEY hKeyProtRoot = NULL;
    PPROT_ROOT_INFO pInfo = NULL;
    PCCERT_CONTEXT pCert = NULL;
    HCERTSTORE hCURootStore = NULL;
    HCERTSTORE hLMRootStore = NULL;
    BOOL fProtDeleted;
    BYTE rgbHash[PROT_ROOT_HASH_LEN];
    CRYPT_DATA_BLOB HashBlob;
    DWORD dwRootIndex;

    if (!SrvGetProtectedRootInfo(
            hKeyCU,
            &hKeyProtRoot,
            &pInfo
            )) goto GetProtectedRootInfoError;

    if (GetProtectedRootFlags() & CERT_PROT_ROOT_INHIBIT_PURGE_LM_FLAG)
        goto AccessDenied;

    if (NULL == (hCURootStore = OpenUnprotectedRootStore(hKeyCU)))
        goto OpenCURootStoreError;

    if (NULL == (hLMRootStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_REGISTRY_W,
            0,                                  // dwEncodingType
            NULL,                               // hCryptProv
            CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_READONLY_FLAG,
            (const void *) pwszRootStoreName
            )))
        goto OpenLMRootStoreError;

    HashBlob.pbData = rgbHash;
    HashBlob.cbData = PROT_ROOT_HASH_LEN;
    fProtDeleted = FALSE;
    pCert = NULL;
    while (pCert = CertEnumCertificatesInStore(hCURootStore, pCert)) {
        if (GetVerifiedCertHashProperty(pCert, rgbHash)) {
            PCCERT_CONTEXT pLMCert;

            if (pLMCert = CertFindCertificateInStore(
                    hLMRootStore,
                    0,                  // dwCertEncodingType
                    0,                  // dwFindFlags
                    CERT_FIND_SHA1_HASH,
                    (const void *) &HashBlob,
                    NULL                //pPrevCertContext
                    )) {
                // CurrentUser Root also exists in LocalMachine. Delete
                // it from the CurrentUser Root store.
                PCCERT_CONTEXT pDeleteCert =
                    CertDuplicateCertificateContext(pCert);

                CertFreeCertificateContext(pLMCert);
                if (!CertDeleteCertificateFromStore(pDeleteCert))
                    goto DeleteCertFromRootStoreError;

                if (FindProtectedRoot(pInfo, rgbHash, &dwRootIndex)) {
                    // The CurrentUser Root is in the protected list,
                    // delete it from there.
                    DeleteProtectedRoot(pInfo, dwRootIndex);
                    fProtDeleted = TRUE;
                }
            }
        }
    }

    // If a protected root exists in the LocalMachine, then, delete it
    // from  the protected list. This step is necessary, if the root
    // was removed from the CurrentUser unprotected store.
    dwRootIndex = pInfo->cRoot;
    HashBlob.pbData = (BYTE *) pInfo + pInfo->dwRootOffset +
        PROT_ROOT_HASH_LEN * dwRootIndex;
    while (dwRootIndex--) {
        PCCERT_CONTEXT pLMCert;

        HashBlob.pbData -= PROT_ROOT_HASH_LEN;
        if (pLMCert = CertFindCertificateInStore(
                hLMRootStore,
                0,                  // dwCertEncodingType
                0,                  // dwFindFlags
                CERT_FIND_SHA1_HASH,
                (const void *) &HashBlob,
                NULL                //pPrevCertContext
                )) {
            CertFreeCertificateContext(pLMCert);
            // Cert exists in the LocalMachine store, delete
            // from protected list.
            DeleteProtectedRoot(pInfo, dwRootIndex);
            fProtDeleted = TRUE;
        }
    }

    if (fProtDeleted) {
        if (!WriteProtectedRootInfo(hKeyProtRoot, pInfo))
            goto WriteProtectedRootInfoError;
    }
    
    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hKeyProtRoot);
    PkiFree(pInfo);
    CertFreeCertificateContext(pCert);
    CertCloseStore(hCURootStore, 0);
    CertCloseStore(hLMRootStore, 0);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(OpenCURootStoreError)
TRACE_ERROR(OpenLMRootStoreError)
TRACE_ERROR(GetProtectedRootInfoError)
TRACE_ERROR(DeleteCertFromRootStoreError)
TRACE_ERROR(WriteProtectedRootInfoError)
}

//+-------------------------------------------------------------------------
//  Add the specified certificate to the CurrentUser SystemRegistry "Root"
//  store and the protected list of roots. The user is prompted before doing
//  the add.
//--------------------------------------------------------------------------
STATIC BOOL SrvAddProtectedRoot(
    IN handle_t hRpc,
    IN HKEY hKeyCU,
    IN BYTE *pbSerializedCert,
    IN DWORD cbSerializedCert
    )
{
    BOOL fResult;
    HKEY hKeyProtRoot = NULL;
    PPROT_ROOT_INFO pInfo = NULL;
    PCCERT_CONTEXT pCert = NULL;
    BYTE rgbCertHash[PROT_ROOT_HASH_LEN];
    HCERTSTORE hRootStore = NULL;
    BOOL fProtExists;

    if (!SrvGetProtectedRootInfo(
            hKeyCU,
            &hKeyProtRoot,
            &pInfo
            )) goto GetProtectedRootInfoError;

    if (!CertAddSerializedElementToStore(
            NULL,               // hCertStore, NULL => create context
            pbSerializedCert,
            cbSerializedCert,
            CERT_STORE_ADD_ALWAYS,
            0,                  // dwFlags
            CERT_STORE_CERTIFICATE_CONTEXT_FLAG,
            NULL,               // pdwContextType
            (const void **) &pCert
            )) goto CreateCertContextError;

    if (!GetVerifiedCertHashProperty(pCert, rgbCertHash))
        goto VerifyHashPropertyError;

    fProtExists = FindProtectedRoot(pInfo, rgbCertHash);
    if (!fProtExists) {
        if (IDYES != IPR_ProtectedRootMessageBox(
                hRpc,
                pCert,
                IDS_ROOT_MSG_BOX_ADD_ACTION,
                MB_TOPMOST | MB_SERVICE_NOTIFICATION ))
            goto Cancelled;
    }

    if (NULL == (hRootStore = OpenUnprotectedRootStore(hKeyCU)))
        goto OpenRootStoreError;

    if (!CertAddSerializedElementToStore(
            hRootStore,
            pbSerializedCert,
            cbSerializedCert,
            CERT_STORE_ADD_REPLACE_EXISTING,
            0,                  // dwFlags
            CERT_STORE_CERTIFICATE_CONTEXT_FLAG,
            NULL,               // pdwContextType
            NULL                // ppvContext
            )) goto AddCertToRootStoreError;

    if (!fProtExists) {
        if (!AddProtectedRoot(&pInfo, rgbCertHash))
            goto AddProtectedRootError;
        if (!WriteProtectedRootInfo(hKeyProtRoot, pInfo))
            goto WriteProtectedRootInfoError;
    }
    
    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hKeyProtRoot);
    PkiFree(pInfo);
    CertFreeCertificateContext(pCert);
    CertCloseStore(hRootStore, 0);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(Cancelled, ERROR_CANCELLED)
TRACE_ERROR(CreateCertContextError)
TRACE_ERROR(VerifyHashPropertyError)
TRACE_ERROR(GetProtectedRootInfoError)
TRACE_ERROR(OpenRootStoreError)
TRACE_ERROR(AddCertToRootStoreError)
TRACE_ERROR(AddProtectedRootError)
TRACE_ERROR(WriteProtectedRootInfoError)
}


//+-------------------------------------------------------------------------
//  Delete the specified certificate from the CurrentUser SystemRegistry "Root"
//  store and the protected list of roots. The user is prompted before doing
//  the delete.
//--------------------------------------------------------------------------
STATIC BOOL SrvDeleteProtectedRoot(
    IN handle_t hRpc,
    IN HKEY hKeyCU,
    IN BYTE rgbRootHash[PROT_ROOT_HASH_LEN]
    )
{
    BOOL fResult;
    HKEY hKeyProtRoot = NULL;
    PPROT_ROOT_INFO pInfo = NULL;
    PCCERT_CONTEXT pCert = NULL;
    HCERTSTORE hRootStore = NULL;
    BYTE rgbCertHash[PROT_ROOT_HASH_LEN];
    DWORD dwRootIndex;
    BOOL fProtExists;
    CRYPT_DATA_BLOB RootHashBlob;

    if (!SrvGetProtectedRootInfo(
            hKeyCU,
            &hKeyProtRoot,
            &pInfo
            )) goto GetProtectedRootInfoError;

    if (NULL == (hRootStore = OpenUnprotectedRootStore(hKeyCU)))
        goto OpenRootStoreError;

    RootHashBlob.pbData = rgbRootHash;
    RootHashBlob.cbData = PROT_ROOT_HASH_LEN;
    if (NULL == (pCert = CertFindCertificateInStore(
            hRootStore,
            0,                  // dwCertEncodingType
            0,                  // dwFindFlags
            CERT_FIND_SHA1_HASH,
            (const void *) &RootHashBlob,
            NULL                //pPrevCertContext
            ))) goto FindCertError;

    if (!GetVerifiedCertHashProperty(pCert, rgbCertHash))
        goto VerifyHashPropertyError;

    fProtExists = FindProtectedRoot(pInfo, rgbCertHash, &dwRootIndex);
    if (fProtExists) {
        if (IDYES != IPR_ProtectedRootMessageBox(
                hRpc,
                pCert,
                IDS_ROOT_MSG_BOX_DELETE_ACTION,
                MB_TOPMOST | MB_SERVICE_NOTIFICATION ))
            goto Cancelled;
    }

    fResult = CertDeleteCertificateFromStore(pCert);
    pCert = NULL;
    if (!fResult)
        goto DeleteCertFromRootStoreError;
    if (fProtExists) {
        DeleteProtectedRoot(pInfo, dwRootIndex);
        if (!WriteProtectedRootInfo(hKeyProtRoot, pInfo))
            goto WriteProtectedRootInfoError;
    }
    
    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hKeyProtRoot);
    PkiFree(pInfo);
    CertFreeCertificateContext(pCert);
    CertCloseStore(hRootStore, 0);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(Cancelled, ERROR_CANCELLED)
TRACE_ERROR(OpenRootStoreError)
TRACE_ERROR(FindCertError)
TRACE_ERROR(VerifyHashPropertyError)
TRACE_ERROR(GetProtectedRootInfoError)
TRACE_ERROR(DeleteCertFromRootStoreError)
TRACE_ERROR(WriteProtectedRootInfoError)
}

//+-------------------------------------------------------------------------
//  Delete all CurrentUser roots from the protected list that don't also
//  exist in the CurrentUser SystemRegistry "Root" store. The user is
//  prompted before doing the delete.
//--------------------------------------------------------------------------
STATIC BOOL SrvDeleteUnknownProtectedRoots(
    IN handle_t hRpc,
    IN HKEY hKeyCU
    )
{
    BOOL fResult;
    HKEY hKeyProtRoot = NULL;
    PPROT_ROOT_INFO pInfo = NULL;
    HCERTSTORE hRootStore = NULL;
    DWORD cOrigRoot;
    CRYPT_DATA_BLOB HashBlob;
    DWORD dwRootIndex;

    if (!SrvGetProtectedRootInfo(
            hKeyCU,
            &hKeyProtRoot,
            &pInfo
            )) goto GetProtectedRootInfoError;
    if (NULL == (hRootStore = OpenUnprotectedRootStore(hKeyCU)))
        goto OpenRootStoreError;

    cOrigRoot = pInfo->cRoot;

    HashBlob.pbData = (BYTE *) pInfo + pInfo->dwRootOffset +
        PROT_ROOT_HASH_LEN * cOrigRoot;
    HashBlob.cbData = PROT_ROOT_HASH_LEN;
    dwRootIndex = cOrigRoot;
    while (dwRootIndex--) {
        PCCERT_CONTEXT pCert;

        HashBlob.pbData -= PROT_ROOT_HASH_LEN;
        if (pCert = CertFindCertificateInStore(
                hRootStore,
                0,                  // dwCertEncodingType
                0,                  // dwFindFlags
                CERT_FIND_SHA1_HASH,
                (const void *) &HashBlob,
                NULL                //pPrevCertContext
                ))
            CertFreeCertificateContext(pCert);
        else
            // Cert doesn't exist in the unprotected store, delete
            // from protected list.
            DeleteProtectedRoot(pInfo, dwRootIndex);
    }

    if (cOrigRoot > pInfo->cRoot) {
        // At least one root was deleted above
        int id;
        LPWSTR pwszTitle;
        LPWSTR pwszText;
        DWORD cchText;
        RPC_STATUS RpcStatus = 0;

        FormatMsgBoxItem(&pwszTitle, &cchText, IDS_ROOT_MSG_BOX_TITLE);
        FormatMsgBoxItem(&pwszText, &cchText,
            IDS_ROOT_MSG_BOX_DELETE_UNKNOWN_PROT_ROOTS,
                cOrigRoot - pInfo->cRoot);

        // Do impersonation for TerminalServer clients
        if (hRpc)
            RpcStatus = RpcImpersonateClient(hRpc);
        id = MessageBoxU(
                NULL,       // hwndOwner
                pwszText,
                pwszTitle,
                MB_YESNO | MB_DEFBUTTON2 | MB_ICONWARNING |
                    MB_TOPMOST | MB_SERVICE_NOTIFICATION
                );
        if (hRpc && ERROR_SUCCESS == RpcStatus)
            RpcRevertToSelf();

        LocalFree((HLOCAL) pwszTitle);
        LocalFree((HLOCAL) pwszText);
        if (IDYES != id)
            goto AccessDenied;

        if (!WriteProtectedRootInfo(hKeyProtRoot, pInfo))
            goto WriteProtectedRootInfoError;
    }
    
    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hKeyProtRoot);
    PkiFree(pInfo);
    CertCloseStore(hRootStore, 0);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(GetProtectedRootInfoError)
TRACE_ERROR(OpenRootStoreError)
TRACE_ERROR(WriteProtectedRootInfoError)
}

// Forward reference
STATIC BOOL SrvLogCrypt32Event(
    IN BYTE *pbIn,
    IN DWORD cbIn
    );

STATIC BOOL SrvAddCertInCtl(
    IN BYTE *pbIn,
    IN DWORD cbIn
    );

//+-------------------------------------------------------------------------
//  Called from the services process to process a protected certificate 
//  function.
//
//  Returns the error status, ie, not returned in LastError.
//--------------------------------------------------------------------------
DWORD
WINAPI
I_CertSrvProtectFunction(
    IN handle_t hRpc,
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN LPCWSTR pwszIn,
    IN BYTE *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut,
    IN PFN_CERT_PROT_MIDL_USER_ALLOC pfnAlloc,
    IN PFN_CERT_PROT_MIDL_USER_FREE pfnFree
    )
{
    DWORD dwErr;
    BOOL fResult;
    HKEY hKeyCU = NULL;
    LONG err;
#ifndef TESTING_NO_PROT_ROOT_RPC
    RPC_STATUS RpcStatus;
#endif

#ifdef TESTING_NO_PROT_ROOT_RPC
    // For testing, called from the client's process
    err = RegOpenHKCU(&hKeyCU);
    if (ERROR_SUCCESS != err)
        goto RegOpenHKCUError;
#else
    if (NULL == hRpc)
        goto InvalidArg;

    // Get the client's HKCU.
    if (ERROR_SUCCESS != (RpcStatus = RpcImpersonateClient(hRpc)))
        goto ImpersonateClientError;
    err = RegOpenHKCUEx(&hKeyCU, REG_HKCU_LOCAL_SYSTEM_ONLY_DEFAULT_FLAG);
    RpcRevertToSelf();
    if (ERROR_SUCCESS != err)
        goto RegOpenHKCUError;
#endif

    switch (dwFuncId) {
        case CERT_PROT_INIT_ROOTS_FUNC_ID:
            fResult = SrvInitProtectedRoots(hKeyCU);
            break;
        case CERT_PROT_PURGE_LM_ROOTS_FUNC_ID:
            fResult = SrvPurgeLocalMachineProtectedRoots(hKeyCU, L"Root");
            fResult &= SrvPurgeLocalMachineProtectedRoots(hKeyCU, L"AuthRoot");
            break;
        case CERT_PROT_ADD_ROOT_FUNC_ID:
            if (NULL == pbIn || 0 == cbIn)
                goto InvalidArg;
            if (IsBadReadPtr(pbIn, cbIn))
                goto InvalidData;
            fResult = SrvAddProtectedRoot(hRpc, hKeyCU, pbIn, cbIn);
            break;
        case CERT_PROT_DELETE_ROOT_FUNC_ID:
            if (NULL == pbIn || PROT_ROOT_HASH_LEN != cbIn)
                goto InvalidArg;
            if (IsBadReadPtr(pbIn, cbIn))
                goto InvalidData;
            fResult = SrvDeleteProtectedRoot(hRpc, hKeyCU, pbIn);
            break;
        case CERT_PROT_DELETE_UNKNOWN_ROOTS_FUNC_ID:
            fResult = SrvDeleteUnknownProtectedRoots(hRpc, hKeyCU);
            break;
        case CERT_PROT_ADD_ROOT_IN_CTL_FUNC_ID:
            if (NULL == pbIn || 0 == cbIn)
                goto InvalidArg;
            if (IsBadReadPtr(pbIn, cbIn))
                goto InvalidData;
            fResult = SrvAddCertInCtl(pbIn, cbIn);
            break;
        case CERT_PROT_LOG_EVENT_FUNC_ID:
            if (NULL == pbIn || 0 == cbIn)
                goto InvalidArg;
            if (IsBadReadPtr(pbIn, cbIn))
                goto InvalidData;
            fResult = SrvLogCrypt32Event(pbIn, cbIn);
            break;
        case CERT_PROT_ROOT_LIST_FUNC_ID:
            // Removed support for XAddRoot control
        default:
            goto InvalidArg;
    }

    if (!fResult)
        goto ErrorReturn;
    dwErr = ERROR_SUCCESS;
CommonReturn:
    if (hKeyCU)
        RegCloseHKCU(hKeyCU);
    return dwErr;
ErrorReturn:
    dwErr = GetLastError();
    if (0 == dwErr)
        dwErr = (DWORD) E_UNEXPECTED;
    goto CommonReturn;

SET_ERROR(InvalidData, ERROR_INVALID_DATA)
SET_ERROR(InvalidArg, E_INVALIDARG)
#ifdef TESTING_NO_PROT_ROOT_RPC
#else
SET_ERROR_VAR(ImpersonateClientError, RpcStatus)
#endif
SET_ERROR_VAR(RegOpenHKCUError, err)
}

//+-------------------------------------------------------------------------
// If a cert has a 0 NotAfter and a KeyProvInfo property, convert its
// NotAfter time to +50 years in the future and resign.
//
// Earlier versions of Outlook generated a self signed CTL signer certificate
// with NotAfter set to 0. The UI displayed this as the year 1/1/1601. This
// fix regenerates the same certificate with the NotAfter set to
// NotBefore +50 years
//
// If the certificate is updated, then, the input certificate context is
// deleted from the store. However before deleting, the input certificate
// context is duplicated to preserve its reference count upon input.
//--------------------------------------------------------------------------
STATIC void UpdateZeroNotAfterRoot(
    IN HCERTSTORE hStore,
    IN PCCERT_CONTEXT pCert
    )
{
    PCERT_INFO pCertInfo = pCert->pCertInfo;
    DWORD cbKeyProvInfo;
    PCRYPT_KEY_PROV_INFO pKeyProvInfo;          // _alloca'ed
    HCRYPTPROV hCryptProv = 0;
    CERT_INFO CertInfo;
    SYSTEMTIME st;
    BYTE *pbCertEncoded;                        // _alloca'ed
    DWORD cbCertEncoded;
    PCCERT_CONTEXT pUpdateCert = NULL;

    // Check for 0 NotAfter
    if (pCertInfo->NotAfter.dwLowDateTime ||
            pCertInfo->NotAfter.dwHighDateTime)
        goto CommonReturn;

    // See if it has a KeyProvInfo property
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            NULL,                               // pbData
            &cbKeyProvInfo))
        goto CommonReturn;

    __try {
        pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) _alloca(cbKeyProvInfo);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        goto OutOfMemory;
    }

    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            pKeyProvInfo,
            &cbKeyProvInfo))
        goto GetKeyProvInfoError;

    if (!CryptAcquireCertificatePrivateKey(
            pCert,
            CRYPT_ACQUIRE_COMPARE_KEY_FLAG,
            NULL,                               // pvReserved
            &hCryptProv,
            NULL,                               // pdwKeySpec
            NULL                                // pfCallerFreeProv
            ))
        goto AcquirePrivateKeyError;

    // Update NotAfter to +50 years
    CertInfo = *pCertInfo;
    FileTimeToSystemTime(&CertInfo.NotBefore, &st);
    st.wYear += 50;
    if (!SystemTimeToFileTime(&st, &CertInfo.NotAfter)) {
        // This may fail on the last day of February.
        st.wDay = 1;
        if (!SystemTimeToFileTime(&st, &CertInfo.NotAfter))
            goto SystemTimeToFileTimeError;
    }

    if (!CryptSignAndEncodeCertificate(
            hCryptProv,
            AT_SIGNATURE,
            X509_ASN_ENCODING,
            X509_CERT_TO_BE_SIGNED,
            &CertInfo,
            &CertInfo.SignatureAlgorithm,
            NULL,                           // pvHashAuxInfo
            NULL,                           // pbEncoded
            &cbCertEncoded
            ))
        goto SignAndEncodeCertificateError;

    __try {
        pbCertEncoded = (BYTE *) _alloca(cbCertEncoded);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        goto OutOfMemory;
    }

    if (!CryptSignAndEncodeCertificate(
            hCryptProv,
            AT_SIGNATURE,
            X509_ASN_ENCODING,
            X509_CERT_TO_BE_SIGNED,
            &CertInfo,
            &CertInfo.SignatureAlgorithm,
            NULL,                           // pvHashAuxInfo
            pbCertEncoded,
            &cbCertEncoded
            ))
        goto SignAndEncodeCertificateError;

    if (NULL == (pUpdateCert = CertCreateCertificateContext(
            X509_ASN_ENCODING,
            pbCertEncoded,
            cbCertEncoded
            )))
        goto CreateCertificateContextError;

    if (!CertSetCertificateContextProperty(
            pUpdateCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            0,                              // dwFlags
            pKeyProvInfo
            ))
        goto SetKeyProvInfoError;

    if (!CertAddCertificateContextToStore(
            hStore,
            pUpdateCert,
            CERT_STORE_ADD_ALWAYS,
            NULL                        // ppStoreContext
            ))
        goto AddCertificateContextError;

    CertDuplicateCertificateContext(pCert);
    CertDeleteCertificateFromStore(pCert);

CommonReturn:
    if (pUpdateCert)
        CertFreeCertificateContext(pUpdateCert);
    if (hCryptProv)
        CryptReleaseContext(hCryptProv, 0);
    return;

ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetKeyProvInfoError)
TRACE_ERROR(AcquirePrivateKeyError)
TRACE_ERROR(SystemTimeToFileTimeError)
TRACE_ERROR(SignAndEncodeCertificateError)
TRACE_ERROR(CreateCertificateContextError)
TRACE_ERROR(SetKeyProvInfoError)
TRACE_ERROR(AddCertificateContextError)
}

void
WINAPI
UpdateZeroNotAfterRoots()
{
    HKEY hKeyCU;

    if (!FIsWinNT5())
        return;

    if (ERROR_SUCCESS == RegOpenHKCU(&hKeyCU)) {
        HKEY hKeyProtRoot;

        if (hKeyProtRoot = OpenProtectedRootSubKey(hKeyCU, KEY_READ))
            // Protected root subkey exists
            ILS_CloseRegistryKey(hKeyProtRoot);
        else {
            HCERTSTORE hStore;

            if (hStore = OpenUnprotectedRootStore(hKeyCU,
                    CERT_STORE_OPEN_EXISTING_FLAG)) {
                PCCERT_CONTEXT pCert = NULL;
                while (pCert = CertEnumCertificatesInStore(hStore, pCert)) {
                    UpdateZeroNotAfterRoot(hStore, pCert);
                }

                CertCloseStore(hStore, 0);
            }
        }

        RegCloseHKCU(hKeyCU);
    }
}

#ifdef TESTING_NO_PROT_ROOT_RPC
// For testing: the server stuff resides in the client process
BOOL
WINAPI
I_CertProtectFunction(
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszIn,
    IN OPTIONAL BYTE *pbIn,
    IN DWORD cbIn,
    OUT OPTIONAL BYTE **ppbOut,
    OUT OPTIONAL DWORD *pcbOut
    )
{
    DWORD dwErr;
    dwErr = I_CertSrvProtectFunction(
        NULL,           // hRpc
        dwFuncId,
        dwFlags,
        pwszIn,
        pbIn,
        cbIn,
        NULL,           // ppbOut
        NULL,           // pcbOut
        NULL,           // pfnAlloc
        NULL            // pfnFree
        );

    if (ERROR_SUCCESS == dwErr)
        return TRUE;
    else {
        SetLastError(dwErr);
        return FALSE;
    }
}
#else

BOOL
WINAPI
I_CertProtectFunction(
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszIn,
    IN OPTIONAL BYTE *pbIn,
    IN DWORD cbIn,
    OUT OPTIONAL BYTE **ppbOut,
    OUT OPTIONAL DWORD *pcbOut
    )
{

    // The following is done in the user process to allow access
    // to the user's private key to be used to resign a
    // zero NotAfter cert.
    UpdateZeroNotAfterRoots();

    return I_CertCltProtectFunction(
        dwFuncId,
        dwFlags,
        pwszIn,
        pbIn,
        cbIn,
        ppbOut,
        pcbOut
        );
}
#endif



//+=========================================================================
//  Protected root functions called from the client process in logstor.cpp
//  or in ..\chain\chain.cpp
//==========================================================================
    
//+-------------------------------------------------------------------------
//  Returns TRUE if the protected root flag wasn't set to disable the opening
//  of the CurrentUser's "root\.Default" physical store.
//--------------------------------------------------------------------------
BOOL
IPR_IsCurrentUserRootsAllowed()
{
    DWORD dwProtRootFlags;
    dwProtRootFlags = GetProtectedRootFlags();
    return 0 == (dwProtRootFlags & CERT_PROT_ROOT_DISABLE_CURRENT_USER_FLAG);
}

//+-------------------------------------------------------------------------
//  Returns TRUE if the protected root flag wasn't set to disable the opening
//  of the LocalMachine's "root\.AuthRoot" physical store.
//--------------------------------------------------------------------------
BOOL
IPR_IsAuthRootsAllowed()
{
    DWORD dwProtRootFlags;
    dwProtRootFlags = GetProtectedRootFlags();
    return 0 == (dwProtRootFlags & CERT_PROT_ROOT_DISABLE_LM_AUTH_FLAG);
}

//+-------------------------------------------------------------------------
//  Returns TRUE if the protected root flag was set to disable the
//  requiring of the issuing CA certificate being in the "NTAuth"
//  Enterprise store.
//--------------------------------------------------------------------------
BOOL
IPR_IsNTAuthRequiredDisabled()
{
    DWORD dwProtRootFlags;
    dwProtRootFlags = GetProtectedRootFlags();
    return 0 != (dwProtRootFlags &
                    CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG);
}

//+---------------------------------------------------------------------------
//  Returns TRUE if Auto Update has been disabled
//----------------------------------------------------------------------------
BOOL
IPR_IsAuthRootAutoUpdateDisabled()
{
    HKEY hKey = NULL;
    DWORD dwInstallFlag = 0;

    if (!IPR_IsAuthRootsAllowed())
        return TRUE;

    if (ERROR_SUCCESS != RegOpenKeyExU(
            HKEY_LOCAL_MACHINE,
            CERT_OCM_SUBCOMPONENTS_LOCAL_MACHINE_REGPATH,
            0,                      // dwReserved
            KEY_READ,
            &hKey
            ))
        return TRUE;

    ILS_ReadDWORDValueFromRegistry(
        hKey,
        CERT_OCM_SUBCOMPONENTS_ROOT_AUTO_UPDATE_VALUE_NAME,
        &dwInstallFlag
        );
    ILS_CloseRegistryKey(hKey);

    return 0 == dwInstallFlag;
}


//+-------------------------------------------------------------------------
//  Gets the protected root information containing the list of protected
//  root stores.
//
//  If protected root store isn't supported, returns TRUE with
//  *ppProtRootInfo set to NULL.
//--------------------------------------------------------------------------
BOOL CltGetProtectedRootInfo(
    OUT PPROT_ROOT_INFO *ppInfo
    )
{
    BOOL fResult;
    LONG err;
    HKEY hKeyCU = NULL;

    *ppInfo = NULL;

#ifndef TESTING_NO_PROT_ROOT_RPC
    if (!FIsWinNT5())
        // No protected roots on Win9x or NT4.0
        return TRUE;
#endif

    if (ERROR_SUCCESS != (err = RegOpenHKCU(&hKeyCU)))
        goto RegOpenHKCUError;

    if (GetProtectedRootInfo(
            hKeyCU,
            KEY_READ,
            NULL,                   // phKeyProtRoot
            ppInfo
            )) goto SuccessReturn;

    if (!I_CertProtectFunction(
            CERT_PROT_INIT_ROOTS_FUNC_ID,
            0,                              // dwFlags
            NULL,                           // pwszIn
            NULL,                           // pbIn
            0,                              // cbIn
            NULL,                           // ppbOut
            NULL                            // pcbOut
            )) {
        DWORD dwErr = GetLastError();
        if (ERROR_CALL_NOT_IMPLEMENTED == dwErr || RPC_S_UNKNOWN_IF == dwErr)
            goto SuccessReturn;
        goto ProtFuncError;
    }

    if (!GetProtectedRootInfo(
            hKeyCU,
            KEY_READ,
            NULL,                   // phKeyProtRoot
            ppInfo
            ))
        goto GetProtectedRootInfoError;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    if (hKeyCU)
        RegCloseHKCU(hKeyCU);
    return fResult;
ErrorReturn:
    *ppInfo = NULL;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(RegOpenHKCUError, err)
TRACE_ERROR(GetProtectedRootInfoError)
TRACE_ERROR(ProtFuncError)
}
    
//+-------------------------------------------------------------------------
//  Initializes the protected list of roots.
//--------------------------------------------------------------------------
void
IPR_InitProtectedRootInfo()
{
    HKEY hKeyCU;

#ifndef TESTING_NO_PROT_ROOT_RPC
    if (!FIsWinNT5())
        // No protected roots on Win9x or NT4.0
        return;
#endif

    if (ERROR_SUCCESS == RegOpenHKCU(&hKeyCU)) {
        HKEY hKeyProtRoot;

        if (hKeyProtRoot = OpenProtectedRootSubKey(hKeyCU, KEY_READ))
            // Protected root subkey exists
            ILS_CloseRegistryKey(hKeyProtRoot);
        else {
            I_CertProtectFunction(
                CERT_PROT_INIT_ROOTS_FUNC_ID,
                0,                              // dwFlags
                NULL,                           // pwszIn
                NULL,                           // pbIn
                0,                              // cbIn
                NULL,                           // ppbOut
                NULL                            // pcbOut
                );
        }

        RegCloseHKCU(hKeyCU);
    }
}

//+-------------------------------------------------------------------------
//  Delete certificates not in the protected store list.
//--------------------------------------------------------------------------
BOOL
IPR_DeleteUnprotectedRootsFromStore(
    IN HCERTSTORE hStore,
    OUT BOOL *pfProtected
    )
{
    PPROT_ROOT_INFO pInfo;
    PCCERT_CONTEXT pCert;

    if (!CltGetProtectedRootInfo(&pInfo)) {
        *pfProtected = FALSE;
        // Delete all certificates from the store's cache.
        while (pCert = CertEnumCertificatesInStore(hStore, NULL))
            CertDeleteCertificateFromStore(pCert);
        return FALSE;
    }

    if (NULL == pInfo)
        // Root store isn't protected.
        *pfProtected = FALSE;
    else {
        *pfProtected = TRUE;
        pCert = NULL;
        while (pCert = CertEnumCertificatesInStore(hStore, pCert)) {
            BYTE rgbHash[PROT_ROOT_HASH_LEN];
            if (!GetVerifiedCertHashProperty(pCert, rgbHash) ||
                    !FindProtectedRoot(pInfo, rgbHash)) {
                PCCERT_CONTEXT pDeleteCert =
                    CertDuplicateCertificateContext(pCert);
                CertDeleteCertificateFromStore(pDeleteCert);
            }
        }

        PkiFree(pInfo);
    }
    return TRUE;
}

//+-------------------------------------------------------------------------
//  The add/delete root message box.
//
//  If protected roots aren't supported, called from the client process.
//  Otherwise, called from the services process.
//--------------------------------------------------------------------------
int
IPR_ProtectedRootMessageBox(
    IN handle_t hRpc,
    IN PCCERT_CONTEXT pCert,
    IN UINT wActionID,
    IN UINT uFlags
    )
{
    int id;

    WCHAR wszTmp[256];
    LPWSTR pwszTmp;       // _alloca'ed
    DWORD cchTmp;

// Includes the title
#define MAX_ROOT_BOX_ITEMS 10
    struct {
        LPWSTR  pwszItem;
        DWORD   cchItem;
    } rgItem[MAX_ROOT_BOX_ITEMS];
    DWORD cItem = 0;
    LPWSTR pwszText = NULL;
    DWORD cchText = 0;

    // ACTION: add or delete
    FormatMsgBoxItem(&rgItem[cItem].pwszItem, &rgItem[cItem].cchItem,
        wActionID);
    cchText += rgItem[cItem].cchItem;
    cItem++;

    // SUBJECT
    cchTmp = CertNameToStrW(
            pCert->dwCertEncodingType,
            &pCert->pCertInfo->Subject,
            CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
            NULL,                   // pwsz
            0);                     // cwsz
    __try {
        pwszTmp = (LPWSTR) _alloca(cchTmp * sizeof(WCHAR));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        pwszTmp = NULL;
    }
    if (NULL == pwszTmp) {
        assert(0);
        pwszTmp = L"";
    } else
        CertNameToStrW(
            pCert->dwCertEncodingType,
            &pCert->pCertInfo->Subject,
            CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
            pwszTmp,
            cchTmp);
    FormatMsgBoxItem(&rgItem[cItem].pwszItem, &rgItem[cItem].cchItem,
        IDS_ROOT_MSG_BOX_SUBJECT, pwszTmp);
    cchText += rgItem[cItem].cchItem;
    cItem++;

    // ISSUER. May be self issued
    if (CertCompareCertificateName(
            pCert->dwCertEncodingType,
            &pCert->pCertInfo->Subject,
            &pCert->pCertInfo->Issuer
            ))
        // Self issued
        FormatMsgBoxItem(&rgItem[cItem].pwszItem, &rgItem[cItem].cchItem,
            IDS_ROOT_MSG_BOX_SELF_ISSUED);
    else {
        // Format certificate's issuer
        cchTmp = CertNameToStrW(
                pCert->dwCertEncodingType,
                &pCert->pCertInfo->Issuer,
                CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
                NULL,                   // pwsz
                0);                     // cwsz
        __try {
            pwszTmp = (LPWSTR) _alloca(cchTmp * sizeof(WCHAR));
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            pwszTmp = NULL;
        }
        if (NULL == pwszTmp) {
            assert(0);
            pwszTmp = L"";
        } else
            CertNameToStrW(
                pCert->dwCertEncodingType,
                &pCert->pCertInfo->Issuer,
                CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
                pwszTmp,
                cchTmp);
        FormatMsgBoxItem(&rgItem[cItem].pwszItem, &rgItem[cItem].cchItem,
            IDS_ROOT_MSG_BOX_ISSUER, pwszTmp);
    }
    cchText += rgItem[cItem].cchItem;
    cItem++;

    // TIME VALIDITY
    {
        FILETIME ftLocal;
        SYSTEMTIME stLocal;
        WCHAR wszNotBefore[128];
        WCHAR wszNotAfter[128];
        wszNotBefore[0] = '\0';
        wszNotAfter[0] = '\0';

        FileTimeToLocalFileTime(&pCert->pCertInfo->NotBefore, &ftLocal);
        FileTimeToSystemTime(&ftLocal, &stLocal);
        GetDateFormatU(LOCALE_USER_DEFAULT, DATE_LONGDATE, &stLocal,
            NULL, wszNotBefore, 128);
        FileTimeToLocalFileTime(&pCert->pCertInfo->NotAfter, &ftLocal);
        FileTimeToSystemTime(&ftLocal, &stLocal);
        GetDateFormatU(LOCALE_USER_DEFAULT, DATE_LONGDATE, &stLocal,
            NULL, wszNotAfter, 128);

        FormatMsgBoxItem(&rgItem[cItem].pwszItem,
            &rgItem[cItem].cchItem, IDS_ROOT_MSG_BOX_TIME_VALIDITY,
            wszNotBefore, wszNotAfter);
        cchText += rgItem[cItem].cchItem;
        cItem++;
    }

    // SERIAL NUMBER
    if (pCert->pCertInfo->SerialNumber.cbData) {
        DWORD cb = pCert->pCertInfo->SerialNumber.cbData;
        BYTE *pb;
        if (pb = PkiAsn1AllocAndReverseBytes(
                pCert->pCertInfo->SerialNumber.pbData, cb)) {
            LPWSTR pwsz;
            if (pwsz = (LPWSTR) PkiNonzeroAlloc(
                    (cb*2 + cb/4 + 1) * sizeof(WCHAR))) {
                FormatMsgBoxMultiBytes(cb, pb, pwsz);
                FormatMsgBoxItem(&rgItem[cItem].pwszItem,
                    &rgItem[cItem].cchItem, IDS_ROOT_MSG_BOX_SERIAL_NUMBER,
                    pwsz);
                cchText += rgItem[cItem].cchItem;
                cItem++;
                PkiFree(pwsz);
            }
            PkiAsn1Free(pb);
        }
    }

    // THUMBPRINTS: sha1 and md5
    {
        BYTE    rgbHash[MAX_HASH_LEN];
        DWORD   cbHash = MAX_HASH_LEN;

        // get the sha1 thumbprint
        if (CertGetCertificateContextProperty(
                pCert,
                CERT_SHA1_HASH_PROP_ID,
                rgbHash,
                &cbHash)) {
            FormatMsgBoxMultiBytes(cbHash, rgbHash, wszTmp);
            FormatMsgBoxItem(&rgItem[cItem].pwszItem,
                &rgItem[cItem].cchItem, IDS_ROOT_MSG_BOX_SHA1_THUMBPRINT,
                wszTmp);
            cchText += rgItem[cItem].cchItem;
            cItem++;
        }

        // get the md5 thumbprint
        if (CertGetCertificateContextProperty(
                pCert,
                CERT_MD5_HASH_PROP_ID,
                rgbHash,
                &cbHash)) {
            FormatMsgBoxMultiBytes(cbHash, rgbHash, wszTmp);
            FormatMsgBoxItem(&rgItem[cItem].pwszItem,
                &rgItem[cItem].cchItem, IDS_ROOT_MSG_BOX_MD5_THUMBPRINT,
                wszTmp);
            cchText += rgItem[cItem].cchItem;
            cItem++;
        }
    }

    // Concatenate all the items into a single allocated string
    assert(cchText);
    if (NULL != (pwszText = (LPWSTR) PkiNonzeroAlloc(
            (cchText + 1) * sizeof(WCHAR)))) {
        LPWSTR pwsz = pwszText;
        DWORD ItemIdx;
        RPC_STATUS RpcStatus = 0;

        for (ItemIdx = 0; ItemIdx < cItem; ItemIdx++) {
            DWORD cch = rgItem[ItemIdx].cchItem;
            if (cch) {
                assert(rgItem[ItemIdx].pwszItem);
                memcpy(pwsz, rgItem[ItemIdx].pwszItem, cch * sizeof(WCHAR));
                pwsz += cch;
            }
        }
        assert (pwsz == pwszText + cchText);
        *pwsz = '\0';

        // TITLE
        FormatMsgBoxItem(&rgItem[cItem].pwszItem, &rgItem[cItem].cchItem,
            IDS_ROOT_MSG_BOX_TITLE);

        // Do impersonation for TerminalServer clients
        if (hRpc)
            RpcStatus = RpcImpersonateClient(hRpc);
        id = MessageBoxU(
                NULL,       // hwndOwner
                pwszText,
                rgItem[cItem].pwszItem,
                MB_TOPMOST | MB_YESNO | MB_DEFBUTTON2 | MB_ICONWARNING | uFlags
                );
        if (hRpc && ERROR_SUCCESS == RpcStatus)
            RpcRevertToSelf();

        cItem++;
        PkiFree(pwszText);
    } else
        id = IDNO;


    // Free up all the individually allocated items
    while (cItem--) {
        if (rgItem[cItem].pwszItem)
            LocalFree((HLOCAL) rgItem[cItem].pwszItem);
    }

    return id;
}

//+=========================================================================
//  crypt32 Event Logging Functions
//==========================================================================

#define MAX_CRYPT32_EVENT_LOG_STRINGS           5
#define MAX_CRYPT32_EVENT_LOG_COUNT             50

// 1 hour (in units of seconds)
#define CRYPT32_EVENT_LOG_THRESHOLD_PERIOD      (60*60)

// Count of logged events. Gets reset whenever the interval between
// logged events >= CRYPT32_EVENT_LOG_THRESHOLD_PERIOD. If
// MAX_CRYPT32_EVENT_LOG_COUNT is reached, suspend logging for
// CRYPT32_EVENT_LOG_THRESHOLD_PERIOD.
DWORD dwCrypt32EventLogCnt;

// Time of last logged event.
FILETIME ftLastCrypt32EventLog;

// advapi32.dll Event APIs. Not supported on Win9x.

typedef HANDLE (WINAPI *PFN_REGISTER_EVENT_SOURCE_W)(
    IN LPCWSTR lpUNCServerName,
    IN LPCWSTR lpSourceName
    );

typedef BOOL (WINAPI *PFN_DEREGISTER_EVENT_SOURCE)(
    IN OUT HANDLE hEventLog
    );

typedef BOOL (WINAPI *PFN_REPORT_EVENT_W)(
     IN HANDLE     hEventLog,
     IN WORD       wType,
     IN WORD       wCategory,
     IN DWORD      dwEventID,
     IN PSID       lpUserSid,
     IN WORD       wNumStrings,
     IN DWORD      dwDataSize,
     IN LPCWSTR   *lpStrings,
     IN LPVOID     lpRawData
    );

//+-------------------------------------------------------------------------
//  Logs crypt32 events. Ensures we don't log more than
//  MAX_CRYPT32_EVENT_LOG_COUNT events in any period of
//  CRYPT32_EVENT_LOG_THRESHOLD_PERIOD seconds.
//
//  Also, dynamically detects if event logging is supported by the version
//  of advapi32.dll on the machine.
//--------------------------------------------------------------------------
STATIC BOOL LogCrypt32Event(
    IN WORD wType,
    IN WORD wCategory,
    IN DWORD dwEventID,
    IN WORD wNumStrings,
    IN DWORD dwDataSize,
    IN LPCWSTR *rgpwszStrings,
    IN BYTE *pbData
    )
{
    BOOL fResult;
    FILETIME ftCurrent;
    FILETIME ftNext;
    LONG lThreshold;
    HMODULE hModule;            // No FreeLibary() for GetModuleHandle
    DWORD dwExceptionCode;
    DWORD dwLastErr = 0;

    PFN_REGISTER_EVENT_SOURCE_W pfnRegisterEventSourceW;
    PFN_REPORT_EVENT_W pfnReportEventW;
    PFN_DEREGISTER_EVENT_SOURCE pfnDeregisterEventSource;

    // Check if we have exceeded the crypt32 event log threshold for
    // this time period
    //
    // lThreshold:
    //  -1  - haven't reached it,
    //   0  - reached it this time
    //  +1  - previously reached, won't log this event

    lThreshold = -1;
    EnterCriticalSection(&Crypt32EventLogCriticalSection);

    I_CryptIncrementFileTimeBySeconds(&ftLastCrypt32EventLog,
        CRYPT32_EVENT_LOG_THRESHOLD_PERIOD, &ftNext);
    GetSystemTimeAsFileTime(&ftCurrent);

    if (0 <= CompareFileTime(&ftCurrent, &ftNext))
        dwCrypt32EventLogCnt = 0;
    else if (MAX_CRYPT32_EVENT_LOG_COUNT <= dwCrypt32EventLogCnt)
        lThreshold = 1;

    if (0 >= lThreshold) {
        ftLastCrypt32EventLog = ftCurrent;
        dwCrypt32EventLogCnt++;
        if (MAX_CRYPT32_EVENT_LOG_COUNT <= dwCrypt32EventLogCnt)
            lThreshold = 0;
    }

    LeaveCriticalSection(&Crypt32EventLogCriticalSection);

    if (0 < lThreshold)
        goto ExceededCrypt32EventLogThreshold;

    // Only supported on systems where the event APIs are exported from
    // advapi32.dll. Note, crypt32.dll has a static link dependency on
    // advapi32.dll.
    if (NULL == (hModule = GetModuleHandleA("advapi32.dll")))
        goto GetAdvapi32ModuleError;

    pfnRegisterEventSourceW = (PFN_REGISTER_EVENT_SOURCE_W)
        GetProcAddress(hModule, "RegisterEventSourceW");
    pfnReportEventW = (PFN_REPORT_EVENT_W)
        GetProcAddress(hModule, "ReportEventW");
    pfnDeregisterEventSource = (PFN_DEREGISTER_EVENT_SOURCE)
        GetProcAddress(hModule, "DeregisterEventSource");

    if (NULL == pfnRegisterEventSourceW ||
            NULL == pfnReportEventW ||
            NULL == pfnDeregisterEventSource)
        goto Advapi32EventAPINotSupported;

    fResult = TRUE;
    __try {
        HANDLE hEventLog;

        hEventLog = pfnRegisterEventSourceW(
            NULL,               // lpUNCServerName
            L"crypt32"
            );

        if (hEventLog) {
            if (!pfnReportEventW(
                    hEventLog,
                    wType,
                    wCategory,
                    dwEventID,
                    NULL,       // lpUserSid
                    wNumStrings,
                    dwDataSize,
                    rgpwszStrings,
                    pbData
                    )) {
                fResult = FALSE;
                dwLastErr = GetLastError();
            }

            I_DBLogCrypt32Event(
                wType,
                dwEventID,
                wNumStrings,
                rgpwszStrings
                );

            if (0 == lThreshold) {
                WCHAR wszCnt[34];
                WCHAR wszPeriod[34];
                LPCWSTR rgpwszThresholdStrings[2] = {wszCnt, wszPeriod};

                _ltow(MAX_CRYPT32_EVENT_LOG_COUNT, wszCnt, 10);
                _ltow(CRYPT32_EVENT_LOG_THRESHOLD_PERIOD / 60, wszPeriod, 10);

                if (!pfnReportEventW(
                        hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,          // wCategory
                        MSG_CRYPT32_EVENT_LOG_THRESHOLD_WARNING,
                        NULL,       // lpUserSid
                        2,          // wNumStrings
                        0,          // dwDataSize
                        rgpwszThresholdStrings,
                        NULL        // pbData
                        )) {
                    fResult = FALSE;
                    dwLastErr = GetLastError();
                }

                I_DBLogCrypt32Event(
                    EVENTLOG_WARNING_TYPE,
                    MSG_CRYPT32_EVENT_LOG_THRESHOLD_WARNING,
                    2,          // wNumStrings
                    rgpwszThresholdStrings
                    );
            }

            pfnDeregisterEventSource(hEventLog);
        } else {
            fResult = FALSE;
            dwLastErr = GetLastError();
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwExceptionCode = GetExceptionCode();
        goto ExceptionError;
    }


    if (!fResult)
        goto ReportEventError;

CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(ExceededCrypt32EventLogThreshold, ERROR_CAN_NOT_COMPLETE)
TRACE_ERROR(GetAdvapi32ModuleError)
SET_ERROR(Advapi32EventAPINotSupported, ERROR_PROC_NOT_FOUND)
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
SET_ERROR_VAR(ReportEventError, dwLastErr)
}

//+-------------------------------------------------------------------------
//  Unmarshals the event logging parameter block passed to the service
//  and call's the crypt32 event logging function with the unmarshalled
//  parameters.
//--------------------------------------------------------------------------
STATIC BOOL SrvLogCrypt32Event(
    IN BYTE *pbIn,
    IN DWORD cbIn
    )
{
    BOOL fResult;
    PCERT_PROT_EVENT_LOG_PARA pPara = NULL;
    BYTE *pbExtra;
    DWORD cbExtra;
    LPCWSTR rgpwszStrings[MAX_CRYPT32_EVENT_LOG_STRINGS];
    LPCWSTR pwszStrings;
    DWORD cchStrings;
    WORD i;
    BYTE *pbData;


    if (sizeof(CERT_PROT_EVENT_LOG_PARA) > cbIn)
        goto InvalidArg;

    // Ensure the PARA is aligned.
    pPara = (PCERT_PROT_EVENT_LOG_PARA) PkiNonzeroAlloc(cbIn);
    if (NULL == pPara)
        goto OutOfMemory;
    memcpy(pPara, pbIn, cbIn);
    pbExtra = (BYTE *) &pPara[1];
    cbExtra = cbIn - sizeof(CERT_PROT_EVENT_LOG_PARA);

    // If present, create an array of pointers to the NULL terminated
    // UNICODE strings that immediately follow the PARA structure.
    if (MAX_CRYPT32_EVENT_LOG_STRINGS < pPara->wNumStrings)
        goto InvalidArg;

    cchStrings = cbExtra / sizeof(WCHAR);   // Maximum #, will be less if we
                                            // also have binary data
    pwszStrings = (LPCWSTR) pbExtra;

    for (i = 0; i < pPara->wNumStrings; i++) {
        rgpwszStrings[i] = pwszStrings;

        for ( ; cchStrings > 0; cchStrings--, pwszStrings++) {
            if (L'\0' == *pwszStrings)
                // Have NULL terminated string
                break;
        }

        if (0 == cchStrings)
            // Reached end without a  NULL terminator
            goto InvalidData;

        // Advance past NULL terminator
        cchStrings--;
        pwszStrings++;
    }

    // The optional data immediately follows the above sequence of 
    // NULL terminated strings
    pbData = (BYTE *) pwszStrings;
    assert(cbExtra >= (DWORD) (pbData - pbExtra));
    if ((cbExtra - (pbData - pbExtra)) != pPara->dwDataSize)
        goto InvalidData;

    fResult = LogCrypt32Event(
        pPara->wType,
        pPara->wCategory,
        pPara->dwEventID,
        pPara->wNumStrings,
        pPara->dwDataSize,
        0 == pPara->wNumStrings ? NULL : rgpwszStrings,
        0 == pPara->dwDataSize  ? NULL : pbData
        );

CommonReturn:
    PkiFree(pPara);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidData, ERROR_INVALID_DATA)
TRACE_ERROR(OutOfMemory)
SET_ERROR(InvalidArg, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Marshals the event logging parameters and does an LRPC to the
//  crypt32 service to do the event logging.
//
//  Should only be called in the client.
//--------------------------------------------------------------------------
void
IPR_LogCrypt32Event(
    IN WORD wType,
    IN DWORD dwEventID,
    IN WORD wNumStrings,
    IN LPCWSTR *rgpwszStrings
    )
{
    DWORD rgcchStrings[MAX_CRYPT32_EVENT_LOG_STRINGS];
    LPWSTR pwszStrings;
    DWORD cchStrings;
    WORD i;

    PCERT_PROT_EVENT_LOG_PARA pPara = NULL;
    DWORD cbPara;

    // Get Strings character count
    if (MAX_CRYPT32_EVENT_LOG_STRINGS < wNumStrings)
        goto InvalidArg;

    cchStrings = 0;
    for (i = 0; i < wNumStrings; i++) {
        rgcchStrings[i] = wcslen(rgpwszStrings[i]) + 1;
        cchStrings += rgcchStrings[i];
    }

    // Create one serialized blob to be passed to the service. This will
    // consist of the event log para struct followed immediately by the
    // NULL terminated UNICODE strings

    cbPara = sizeof(CERT_PROT_EVENT_LOG_PARA) + cchStrings * sizeof(WCHAR);

    if (NULL == (pPara = (PCERT_PROT_EVENT_LOG_PARA) PkiZeroAlloc(cbPara)))
        goto OutOfMemory;

    pPara->wType = wType;
    // pPara->wCategory = 0;
    pPara->dwEventID = dwEventID;
    pPara->wNumStrings = wNumStrings;
    // pPara->wPad1 = 0;
    // pPara->dwDataSize = 0;

    pwszStrings = (LPWSTR) &pPara[1];
    for (i = 0; i < wNumStrings; i++) {
        memcpy(pwszStrings, rgpwszStrings[i], rgcchStrings[i] * sizeof(WCHAR));
        pwszStrings += rgcchStrings[i];
    }

    if (!I_CertProtectFunction(
            CERT_PROT_LOG_EVENT_FUNC_ID,
            0,                              // dwFlags
            NULL,                           // pwszIn
            (BYTE *) pPara,
            cbPara,
            NULL,                           // ppbOut
            NULL                            // pcbOut
            ))
        goto ProtFuncError;

CommonReturn:
    PkiFree(pPara);
    return;
ErrorReturn:
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(ProtFuncError)
}

//+-------------------------------------------------------------------------
//  Log a crypt32 error event
//
//  Should only be called in the client.
//--------------------------------------------------------------------------
void
IPR_LogCrypt32Error(
    IN DWORD dwEventID,
    IN LPCWSTR pwszString,      // %1
    IN DWORD dwErr              // %2
    )
{
    WCHAR wszErr[16];
    LPCWSTR rgpwszStrings[2];

    wszErr[0] = L'0';
    wszErr[1] = L'x';
    _ltow((long) dwErr, &wszErr[2], 16);

    rgpwszStrings[0] = pwszString;
    rgpwszStrings[1] = wszErr;

    IPR_LogCrypt32Event(
        EVENTLOG_ERROR_TYPE,
        dwEventID,
        2,                      // wNumStrings
        rgpwszStrings
        );
}


//+-------------------------------------------------------------------------
//  Formats the cert's subject or issuer name string and SHA1 thumbprint.
//--------------------------------------------------------------------------
STATIC BOOL FormatLogCertInformation(
    IN PCCERT_CONTEXT pCert,
    IN BOOL fFormatIssuerName,
    OUT WCHAR wszSha1Hash[SHA1_HASH_LEN * 2 + 1],
    OUT LPWSTR *ppwszName
    )
{
    BOOL fResult;
    DWORD cchName;
    LPWSTR pwszName = NULL;
    DWORD cbData;
    BYTE rgbSha1Hash[SHA1_HASH_LEN];

    PCERT_NAME_BLOB pNameBlob;

    if (fFormatIssuerName)
        pNameBlob = &pCert->pCertInfo->Issuer;
    else
        pNameBlob = &pCert->pCertInfo->Subject;

    cchName = CertNameToStrW(
        pCert->dwCertEncodingType,
        pNameBlob,
        CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
        NULL,                   // pwsz
        0                       // cwsz
        );

    if (NULL == (pwszName = (LPWSTR) PkiNonzeroAlloc(cchName * sizeof(WCHAR))))
        goto OutOfMemory;

    CertNameToStrW(
        pCert->dwCertEncodingType,
        pNameBlob,
        CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
        pwszName,
        cchName
        );

    cbData = SHA1_HASH_LEN;
    if (CertGetCertificateContextProperty(
              pCert,
              CERT_SHA1_HASH_PROP_ID,
              rgbSha1Hash,
              &cbData
              ) && SHA1_HASH_LEN == cbData)
        ILS_BytesToWStr(SHA1_HASH_LEN, rgbSha1Hash, wszSha1Hash);
    else
        wcscpy(wszSha1Hash, L"???");

    fResult = TRUE;
CommonReturn:
    *ppwszName = pwszName;
    return fResult;
ErrorReturn:
    if (pwszName) {
        PkiFree(pwszName);
        pwszName = NULL;
    }
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Get the cert's subject or issuer name string and SHA1 thumbprint. Logs the
//  specified crypt32 event.
//
//  This function is called from the client.
//--------------------------------------------------------------------------
void
IPR_LogCertInformation(
    IN DWORD dwEventID,
    IN PCCERT_CONTEXT pCert,
    IN BOOL fFormatIssuerName
    )
{
    LPWSTR pwszName = NULL;
    WCHAR wszSha1Hash[SHA1_HASH_LEN * 2 + 1];
    LPCWSTR rgpwszStrings[2];

    if (!FormatLogCertInformation(
            pCert,
            fFormatIssuerName,
            wszSha1Hash,
            &pwszName
            ))
        return;

    rgpwszStrings[0] = pwszName;
    rgpwszStrings[1] = wszSha1Hash;
    
    IPR_LogCrypt32Event(
        EVENTLOG_INFORMATION_TYPE,
        dwEventID,
        2,                          // wNumStrings
        rgpwszStrings
        );

    PkiFree(pwszName);
}

//+-------------------------------------------------------------------------
//  Get the cert's subject name string and SHA1 thumbprint. Log the
//  MSG_ROOT_AUTO_UPDATE_INFORMATIONAL crypt32 event.
//
//  This function is called from the service.
//--------------------------------------------------------------------------
STATIC void LogAddAuthRootEvent(
    IN PCCERT_CONTEXT pCert
    )
{
    LPWSTR pwszName = NULL;
    WCHAR wszSha1Hash[SHA1_HASH_LEN * 2 + 1];
    LPCWSTR rgpwszStrings[2];

    if (!FormatLogCertInformation(
            pCert,
            FALSE,                  // fFormatIssuerName
            wszSha1Hash,
            &pwszName
            ))
        return;


    rgpwszStrings[0] = pwszName;
    rgpwszStrings[1] = wszSha1Hash;
    
    LogCrypt32Event(
        EVENTLOG_INFORMATION_TYPE,
        0,                          // wCategory
        MSG_ROOT_AUTO_UPDATE_INFORMATIONAL,
        2,                          // wNumStrings
        0,                          // dwDataSize
        rgpwszStrings,
        NULL                        // pbData
        );

    PkiFree(pwszName);
}

//+=========================================================================
//  Install Cert into AuthRoot Auto Update CTL Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Function that can be called from either the client or service to
//  add the certificate to the specified store. 
//
//  First validates the CTL. The certificate must
//  have an entry in the CTL before it will be added. The CTL entry's
//  property attributes are set on the certificate context to be added.
//--------------------------------------------------------------------------
STATIC
BOOL
AddCertInCtlToStore(
    IN PCCERT_CONTEXT pCert,
    IN PCCTL_CONTEXT pCtl,
    IN OUT HCERTSTORE hStore
    )
{
    BOOL fResult;
    PCTL_ENTRY pCtlEntry;

    if (!IRL_VerifyAuthRootAutoUpdateCtl(pCtl))
        goto InvalidCtl;

    if (NULL == (pCtlEntry = CertFindSubjectInCTL(
            pCert->dwCertEncodingType,
            CTL_CERT_SUBJECT_TYPE,
            (void *) pCert,
            pCtl,
            0                           // dwFlags
            )))
        goto CertNotInCtl;

    // Check if a remove entry
    if (CertFindAttribute(
            szOID_REMOVE_CERTIFICATE,
            pCtlEntry->cAttribute,
            pCtlEntry->rgAttribute
            ))
        goto RemoveCertEntry;

    // Set Ctl Entry Attribute properties
    if (!CertSetCertificateContextPropertiesFromCTLEntry(
            pCert,
            pCtlEntry,
            CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG
            ))
        goto AddCtlEntryAttibutePropertiesError;

     if (!CertAddCertificateContextToStore(
            hStore,
            pCert,
            CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES,
            NULL                // ppStoreContext
            ))
        goto AddCertToStoreError;

    LogAddAuthRootEvent(pCert);

    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(InvalidCtl)
SET_ERROR(CertNotInCtl, CRYPT_E_NOT_FOUND)
SET_ERROR(RemoveCertEntry, CRYPT_E_NOT_FOUND)
TRACE_ERROR(AddCtlEntryAttibutePropertiesError)
TRACE_ERROR(AddCertToStoreError)
}

//+-------------------------------------------------------------------------
//  Unmarshals the ASN.1 encoded X.509 certificate immediately followed by the
//  ASN.1 encoded CTL.
//
//  If the certificate has an entry in a valid CTL, its added to the
//  HKLM "AuthRoot" store.
//--------------------------------------------------------------------------
STATIC
BOOL
SrvAddCertInCtl(
    IN BYTE *pbIn,
    IN DWORD cbIn
    )
{
    BOOL fResult;
    DWORD cbCert;
    PCCERT_CONTEXT pCert = NULL;
    PCCTL_CONTEXT pCtl = NULL;
    HCERTSTORE hAuthRootStore = NULL;

    // The input consists of the encoded certificate immediately followed
    // by the encoded CTL. Extract and create both components.

    cbCert = Asn1UtilAdjustEncodedLength(pbIn, cbIn);

    assert(cbCert <= cbIn);

    if (NULL == (pCert = CertCreateCertificateContext(
            X509_ASN_ENCODING,
            pbIn,
            cbCert
            )))
        goto CreateCertificateContextError;

    if (NULL == (pCtl = CertCreateCTLContext(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            pbIn + cbCert,
            cbIn - cbCert
            )))
        goto CreateCtlContextError;

    if (NULL == (hAuthRootStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_REGISTRY_W,
            0,                                  // dwEncodingType
            NULL,                               // hCryptProv
            CERT_SYSTEM_STORE_LOCAL_MACHINE,
            (const void *) L"AuthRoot"
            )))
        goto OpenAuthRootStoreError;

    fResult = AddCertInCtlToStore(
        pCert,
        pCtl,
        hAuthRootStore
        );

CommonReturn:
    if (pCert)
        CertFreeCertificateContext(pCert);
    if (pCtl)
        CertFreeCTLContext(pCtl);
    if (hAuthRootStore)
        CertCloseStore(hAuthRootStore, 0);

    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CreateCertificateContextError)
TRACE_ERROR(CreateCtlContextError)
TRACE_ERROR(OpenAuthRootStoreError)
}


    
//+-------------------------------------------------------------------------
//  For Pre W2K OS's that don't have a crypt32 service, do the add in
//  client process.
//--------------------------------------------------------------------------
STATIC
BOOL
PreW2KAddCertInCtl(
    IN PCCERT_CONTEXT pCert,
    IN PCCTL_CONTEXT pCtl
    )
{
    BOOL fResult;
    HCERTSTORE hRootStore = NULL;

    // Try opening the HKLM AuthRoot store. If that fails, fall back to
    // adding to the HKCU Root (Unprotected) store
    if (NULL == (hRootStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_REGISTRY_W,
            0,                                  // dwEncodingType
            NULL,                               // hCryptProv
            CERT_SYSTEM_STORE_LOCAL_MACHINE,
            (const void *) L"AuthRoot"
            ))) {
        if (NULL == (hRootStore = CertOpenStore(
                CERT_STORE_PROV_SYSTEM_REGISTRY_W,
                0,                                  // dwEncodingType
                NULL,                               // hCryptProv
                CERT_SYSTEM_STORE_CURRENT_USER |
                    CERT_SYSTEM_STORE_UNPROTECTED_FLAG,
                (const void *) L"Root"
                )))
            goto OpenRootStoreError;
    }

    fResult = AddCertInCtlToStore(
        pCert,
        pCtl,
        hRootStore
        );

CommonReturn:
    if (hRootStore)
        CertCloseStore(hRootStore, 0);

    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenRootStoreError)
}


//+-------------------------------------------------------------------------
//  If the certificate has an entry in a valid CTL, its added to the
//  HKLM "AuthRoot" store.
//--------------------------------------------------------------------------
BOOL
IPR_AddCertInAuthRootAutoUpdateCtl(
    IN PCCERT_CONTEXT pCert,
    IN PCCTL_CONTEXT pCtl
    )
{
    BOOL fResult;
    DWORD cbIn;
    BYTE *pbIn = NULL;

    // Create one serialized blob to be passed to the service. This will
    // consist of the encoded certificate followed immediately by the
    // encoded CTL.

    cbIn = pCert->cbCertEncoded + pCtl->cbCtlEncoded;

    if (NULL == (pbIn = (BYTE *) PkiNonzeroAlloc(cbIn)))
        goto OutOfMemory;

    memcpy(pbIn, pCert->pbCertEncoded, pCert->cbCertEncoded);
    memcpy(pbIn + pCert->cbCertEncoded, pCtl->pbCtlEncoded,
        pCtl->cbCtlEncoded);

    if (!I_CertProtectFunction(
            CERT_PROT_ADD_ROOT_IN_CTL_FUNC_ID,
            0,                              // dwFlags
            NULL,                           // pwszIn
            pbIn,
            cbIn,
            NULL,                           // ppbOut
            NULL                            // pcbOut
            )) {
        DWORD dwErr = GetLastError();
        if (ERROR_CALL_NOT_IMPLEMENTED == dwErr || RPC_S_UNKNOWN_IF == dwErr) {
            if (!PreW2KAddCertInCtl(
                    pCert,
                    pCtl
                    ))
                goto PreW2KAddCertInCtlError;
        } else
            goto ProtFuncError;
    }

    fResult = TRUE;
CommonReturn:
    PkiFree(pbIn);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(PreW2KAddCertInCtlError)
TRACE_ERROR(ProtFuncError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\queryobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:	queryobj.cpp
//
//  Contents:   OID format functions
//
//  Functions:
//              CryptQueryObject
//
//  History:    15-05-97    xiaohs   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>
#include "frmtfunc.h"

#define ASN_ASCII_HEX_PREFIX        "{ASN}"
#define ASN_ASCII_HEX_PREFIX_LEN    ((DWORD) strlen(ASN_ASCII_HEX_PREFIX))

#define NOTEPAD_UNICODE_SPECIAL_WCHAR   L'\xfeff'

//**************************************************************************
//
//     The following section is for CryptQueryObject
//**************************************************************************

//+-------------------------------------------------------------------------
//  CryptStringToBinaryA: Decode the BLOB
//
//--------------------------------------------------------------------------
BOOL    DecodeBlobA(CHAR    *pbByte,
                    DWORD   cbByte,
                    BYTE    **ppbData,
                    DWORD   *pcbData)
{
    DWORD   err=0;
    BOOL    fResult=FALSE;

    *ppbData=NULL;
    *pcbData=0;

    __try {
    if(!CryptStringToBinaryA(pbByte,
                      cbByte,
                      CRYPT_STRING_BASE64,
                      NULL,
                      pcbData,
                      NULL,
                      NULL))
    {
        err = GetLastError();
        goto DecodeErr;
    }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        err = GetExceptionCode();
        goto DecodeErr;
    }

    *ppbData=(BYTE *)malloc(*pcbData);

    if(NULL==*ppbData)
        goto OutOfMemoryErr;

    __try {
    if(!CryptStringToBinaryA(pbByte,
                      cbByte,
                      CRYPT_STRING_BASE64,
                      *ppbData,
                      pcbData,
                      NULL,
                      NULL))
    {
        err = GetLastError();
        goto DecodeErr;
    }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        err = GetExceptionCode();
        goto DecodeErr;
    }

    fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

    if(*ppbData)
    {
        free(*ppbData);
        *ppbData=NULL;
    }

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR_VAR(DecodeErr, err);
SET_ERROR(OutOfMemoryErr, E_OUTOFMEMORY);

}

//+-------------------------------------------------------------------------
//  CryptStringToBinaryW: Decode the BLOB
//
//--------------------------------------------------------------------------
BOOL    DecodeBlobW(WCHAR    *pbByte,
                    DWORD   cbByte,
                    BYTE    **ppbData,
                    DWORD   *pcbData)
{
    DWORD   err=0;
    BOOL    fResult=FALSE;

    *ppbData=NULL;
    *pcbData=0;

    __try {
    if(!CryptStringToBinaryW(pbByte,
                      cbByte,
                      CRYPT_STRING_BASE64,
                      NULL,
                      pcbData,
                      NULL,
                      NULL))
    {
        err = GetLastError();
        goto DecodeErr;
    }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        err = GetExceptionCode();
        goto DecodeErr;
    }

    *ppbData=(BYTE *)malloc(*pcbData);

    if(NULL==*ppbData)
        goto OutOfMemoryErr;

    __try {
    if(!CryptStringToBinaryW(pbByte,
                      cbByte,
                      CRYPT_STRING_BASE64,
                      *ppbData,
                      pcbData,
                      NULL,
                      NULL))
    {
        err = GetLastError();
        goto DecodeErr;
    }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        err = GetExceptionCode();
        goto DecodeErr;
    }


    fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

    if(*ppbData)
    {
        free(*ppbData);
        *ppbData=NULL;
    }

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR_VAR(DecodeErr, err);
SET_ERROR(OutOfMemoryErr, E_OUTOFMEMORY);

}

//+-------------------------------------------------------------------------
//  Decode the BLOB encoded as ASCII HEX.
//
//  Note, pbByte has already been advanced past any leading prefix such as,
//  "{ASN}"
//--------------------------------------------------------------------------
BOOL
DecodeAsciiHex(
    const char  *pch,
    DWORD       cch,
    BYTE        **ppbData,
    DWORD       *pcbData
    )
{
    DWORD   err;
    BOOL    fResult;
    DWORD   cbData;
    BYTE    *pbData = NULL;

    pbData = (BYTE *) malloc(cch/2 + 1);
    if (NULL == pbData)
        goto OutOfMemory;

    __try {
        BYTE    bData;
        BYTE    *pb;
        BOOL    fUpperNibble;

        fUpperNibble = TRUE;
        for (pb = pbData; 0 < cch; cch--, pch++) {
            BYTE b;
            char ch;

            // Convert ascii hex characters 0..9, a..f, A..F
            // silently ignore all others
            ch = *pch;
            if (ch >= '0' && ch <= '9')
                b = (BYTE)( ch - '0' );
            else if (ch >= 'a' && ch <= 'f')
                b = (BYTE)( 10 + ch - 'a' );
            else if (ch >= 'A' && ch <= 'F')
                b = (BYTE)( 10 + ch - 'A' );
            else
                goto InvalidData;

            if (fUpperNibble) {
                bData = (BYTE)( b << 4 );
                fUpperNibble = FALSE;
            } else {
                bData = (BYTE)( bData | b );
                *pb++ = bData;
                fUpperNibble = TRUE;
            }
        }

        cbData = (DWORD) (pb - pbData);
        if (0 == cbData || !fUpperNibble)
            goto InvalidData;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        err = GetExceptionCode();
        goto ExceptionErr;
    }

    fResult = TRUE;

CommonReturn:
    *ppbData = pbData;
    *pcbData = cbData;
	return fResult;

ErrorReturn:
    if (pbData) {
        free(pbData);
        pbData = NULL;
    }
    cbData = 0;
	fResult = FALSE;
	goto CommonReturn;

SET_ERROR_VAR(ExceptionErr, err);
SET_ERROR(OutOfMemory, E_OUTOFMEMORY);
SET_ERROR(InvalidData, ERROR_INVALID_DATA);

}


//+-------------------------------------------------------------------------
//  Skip over the identifier and length octets in an ASN encoded blob.
//  Returns the number of bytes skipped.
//
//  For an invalid identifier or length octet returns 0.
//--------------------------------------------------------------------------
 DWORD SkipOverIdentifierAndLengthOctets(
    IN const BYTE *pbDER,
    IN DWORD cbDER
    )
{
#define TAG_MASK 0x1f
    DWORD   cb;
    DWORD   cbLength;
    const BYTE   *pb = pbDER;

    // Need minimum of 2 bytes
    if (cbDER < 2)
        return 0;

    // Skip over the identifier octet(s)
    if (TAG_MASK == (*pb++ & TAG_MASK)) {
        // high-tag-number form
        for (cb=2; *pb++ & 0x80; cb++) {
            if (cb >= cbDER)
                return 0;
        }
    } else
        // low-tag-number form
        cb = 1;

    // need at least one more byte for length
    if (cb >= cbDER)
        return 0;

    if (0x80 == *pb)
        // Indefinite
        cb++;
    else if ((cbLength = *pb) & 0x80) {
        cbLength &= ~0x80;         // low 7 bits have number of bytes
        cb += cbLength + 1;
        if (cb > cbDER)
            return 0;
    } else
        cb++;

    return cb;
}

//--------------------------------------------------------------------------
//
//	Skip over the tag and length
//----------------------------------------------------------------------------
BOOL SignNoContentWrap(IN const BYTE *pbDER, IN DWORD cbDER)
{
    DWORD cb;

    __try {
    cb = SkipOverIdentifierAndLengthOctets(pbDER, cbDER);
    if (cb > 0 && cb < cbDER && pbDER[cb] == 0x02)
        return TRUE;
    else
        return FALSE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
    }

    return FALSE;
}


//--------------------------------------------------------------------------------
//
//get the bytes from the file name
//
//---------------------------------------------------------------------------------
HRESULT RetrieveBLOBFromFile(LPWSTR	pwszFileName,DWORD *pcb,BYTE **ppb)
{


	HRESULT	hr=E_FAIL;
	HANDLE	hFile=NULL;
    HANDLE  hFileMapping=NULL;

    DWORD   cbData=0;
    BYTE    *pbData=0;
	DWORD	cbHighSize=0;

	if(!pcb || !ppb || !pwszFileName)
		return E_INVALIDARG;

	*ppb=NULL;
	*pcb=0;

    if ((hFile = CreateFileU(pwszFileName,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,                   // lpsa
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL)) == INVALID_HANDLE_VALUE)
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }

    if((cbData = GetFileSize(hFile, &cbHighSize)) == 0xffffffff)
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }

	//we do not handle file more than 4G bytes
	if(cbHighSize != 0)
	{
			hr=E_FAIL;
			goto CLEANUP;
	}

    //create a file mapping object
    if(NULL == (hFileMapping=CreateFileMapping(
                hFile,
                NULL,
                PAGE_READONLY,
                0,
                0,
                NULL)))
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }

    //create a view of the file
	if(NULL == (pbData=(BYTE *)MapViewOfFile(
		hFileMapping,
		FILE_MAP_READ,
		0,
		0,
		cbData)))
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }

	hr=S_OK;

	*pcb=cbData;
	*ppb=pbData;

CLEANUP:

	if(hFile)
		CloseHandle(hFile);

	if(hFileMapping)
		CloseHandle(hFileMapping);

	return hr;

}

//-------------------------------------------------------------------------
//
//   Check to see if the BLOB has an embeded PKCS7 using SIP functions
//
//-------------------------------------------------------------------------
BOOL    GetEmbeddedPKCS7(CERT_BLOB  *pCertBlob,
                         LPWSTR     pwszFileName,
                         BYTE       **ppbData,
                         DWORD      *pcbData,
                         DWORD      *pdwEncodingType)
{
    BOOL                fResult=FALSE;
    CHAR                szTempPath[MAX_PATH];
    CHAR                szTempFileName[MAX_PATH];
    LPSTR               szPreFix="Tmp";     //we should not localize this string
                                            //since it has to be in ANSCII characeter set
    DWORD               dwBytesWritten=0;
    GUID				gSubject;
    SIP_DISPATCH_INFO	SipDispatch;
    SIP_SUBJECTINFO		SubjectInfo;


    HANDLE              hFile=NULL;
    LPWSTR              pwszFileToUse=NULL;

    //init the output
    *ppbData=NULL;
    *pcbData=0;
    *pdwEncodingType=0;

    //create a temporary file since SIP functions only takes a file name
    if(NULL==pwszFileName)
    {
        if(0==GetTempPath(sizeof(szTempPath), szTempPath))
            goto GetTempPathErr;

        if(0==GetTempFileName(szTempPath, szPreFix, 0, szTempFileName))
            goto GetTempFileNameErr;

        if(INVALID_HANDLE_VALUE==(hFile=CreateFile(szTempFileName,
                        GENERIC_WRITE |GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        CREATE_NEW,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL)))
            goto CreateFileErr;

        //write the BLOB to the file
        if(!WriteFile(hFile,
                            pCertBlob->pbData,
                            pCertBlob->cbData,
                            &dwBytesWritten,
                            NULL))
            goto WriteFileErr;

        if(dwBytesWritten != pCertBlob->cbData)
            goto WriteBytesErr;

        //close the file handle
        if(!CloseHandle(hFile))
        {
            hFile=NULL;
            goto CloseHandleErr;
        }

        hFile=NULL;

        //get the unicode version of the file name
        pwszFileToUse=MkWStr(szTempFileName);

        if(NULL==pwszFileToUse)
           goto MkWStrErr;

    }
    else
        pwszFileToUse=pwszFileName;

    //call the sip functions
    //get the GUID
    if (!CryptSIPRetrieveSubjectGuid(
            pwszFileToUse,
            NULL,
            &gSubject))
        goto CryptNoMatchErr;

    //load the dispatch
    memset(&SipDispatch, 0, sizeof(SipDispatch));
    SipDispatch.cbSize = sizeof(SipDispatch);

    if (!CryptSIPLoad(
            &gSubject,
            0,
            &SipDispatch))
        goto CryptNoMatchErr;

    //fill out the subjectInfo
    memset(&SubjectInfo, 0, sizeof(SubjectInfo));
    SubjectInfo.cbSize = sizeof(SubjectInfo);
    SubjectInfo.pgSubjectType = (GUID*) &gSubject;
    SubjectInfo.hFile = INVALID_HANDLE_VALUE;
    SubjectInfo.pwsFileName = pwszFileToUse;
    SubjectInfo.dwEncodingType = *pdwEncodingType;

    //get the embedded PKCS7
    SipDispatch.pfGet(
            &SubjectInfo,
            pdwEncodingType,
            0,                          // dwIndex
            pcbData,
            NULL                        // pbSignedData
            );
    if (0 == (*pcbData))
        goto CryptNoMatchErr;

    if (NULL == (*ppbData=(BYTE *)malloc(*pcbData)))
        goto OutOfMemoryErr;

    if (!SipDispatch.pfGet(
            &SubjectInfo,
            pdwEncodingType,
            0,                          // dwIndex
            pcbData,
            *ppbData
            ))
        goto CryptNoMatchErr;


    fResult=TRUE;


CommonReturn:

    //close the file handle
    if(INVALID_HANDLE_VALUE!=hFile && NULL !=hFile)
        CloseHandle(hFile);

    //delete the file if it was created
    if(NULL==pwszFileName)
    {
        DeleteFileU(pwszFileToUse);

        FreeWStr(pwszFileToUse);
    }

	return fResult;

ErrorReturn:

	fResult=FALSE;

    if(*ppbData)
    {
        free(*ppbData);
        *ppbData=NULL;
    }

	goto CommonReturn;

TRACE_ERROR(GetTempPathErr);
TRACE_ERROR(GetTempFileNameErr);
TRACE_ERROR(CreateFileErr);
TRACE_ERROR(WriteFileErr);
SET_ERROR(WriteBytesErr, E_FAIL);
TRACE_ERROR(CloseHandleErr);
TRACE_ERROR(MkWStrErr);
SET_ERROR(CryptNoMatchErr, CRYPT_E_NO_MATCH);
SET_ERROR(OutOfMemoryErr, E_OUTOFMEMORY);
}

BOOL
AddCertPairToStore(
    IN HCERTSTORE hCertStore,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    )
{
    BOOL fResult;
    PCERT_PAIR pInfo = NULL;
    DWORD cbInfo;
    PCCERT_CONTEXT pCertForward = NULL;

    // CryptDecodeObjectEX should be usable here, but since this object
    // is included with XEnroll and XEnroll must run with Auth2UPD Crypt32
    // we must stick with the old CryptDecodeObject 2 pass calls.
    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            X509_CERT_PAIR,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG,
            NULL,                       // pInfo
            &cbInfo
            ))
        goto DecodeError;
    if (NULL == (pInfo = (PCERT_PAIR) malloc(cbInfo)))
        goto OutOfMemory;
    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            X509_CERT_PAIR,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG,
            pInfo,
            &cbInfo
            ))
        goto DecodeError;

    if (pInfo->Forward.cbData) {
        if (!CertAddEncodedCertificateToStore(
                hCertStore,
                X509_ASN_ENCODING,
                pInfo->Forward.pbData,
                pInfo->Forward.cbData,
                CERT_STORE_ADD_ALWAYS,
                &pCertForward
                ))
            goto AddCertError;
    }

    if (pInfo->Reverse.cbData) {
        if (!CertAddEncodedCertificateToStore(
                hCertStore,
                X509_ASN_ENCODING,
                pInfo->Reverse.pbData,
                pInfo->Reverse.cbData,
                CERT_STORE_ADD_ALWAYS,
                NULL                            // ppCertContext
                ))
            goto AddCertError;
    }

    if (pCertForward)
        CertFreeCertificateContext(pCertForward);

    fResult = TRUE;

CommonReturn:
    if (pInfo)
        free(pInfo);
    return fResult;

DecodeError:
ErrorReturn:
    fResult = FALSE;
    if (pCertForward)
        CertDeleteCertificateFromStore(pCertForward);
    goto CommonReturn;

SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
TRACE_ERROR(AddCertError)
}


//-------------------------------------------------------------------------
//
//   The real implementation of CryptQueryObject
//
//-------------------------------------------------------------------------
BOOL   I_CryptQueryObject(CERT_BLOB      *pCertBlob,
                       LPWSTR           pwszFileName,
                       DWORD            dwContentTypeFlag,
                       DWORD            dwFormatTypeFlag,
                       DWORD            dwFlag,
                       DWORD            *pdwMsgAndCertEncodingType,
                       DWORD            *pdwContentType,
                       DWORD            *pdwFormatType,
                       HCERTSTORE       *phCertStore,
                       HCRYPTMSG        *phMsg,
                       const void       **ppvContext)
{
    BOOL                fResult=FALSE;
    DWORD               dwMsgEncodingType=PKCS_7_ASN_ENCODING;
    DWORD               dwEncodingType=X509_ASN_ENCODING;
    DWORD               dwPKCS7EncodingType=X509_ASN_ENCODING|PKCS_7_ASN_ENCODING;
    DWORD               dwContentType=0;
    DWORD               dwMsgType=0;
    DWORD               cbData=0;
    BOOL                fEmbedded=FALSE;
    CERT_BLOB           PKCS7Blob;

    BYTE                *pbPKCS7=NULL;
    DWORD               cbPKCS7=0;
    HCERTSTORE          hCertStore=NULL;
    HCRYPTMSG           hMsg=NULL;
    PCCERT_CONTEXT      pCertContext=NULL;
    PCCRL_CONTEXT       pCRLContext=NULL;
    PCCTL_CONTEXT       pCTLContext=NULL;
    PCERT_REQUEST_INFO  pReqInfo=NULL;

    //NULL the output
    if(pdwMsgAndCertEncodingType)
        *pdwMsgAndCertEncodingType=0;

    if(pdwContentType)
        *pdwContentType=0;

    if(pdwFormatType)
        *pdwFormatType=0;

    if(phCertStore)
        *phCertStore=NULL;

    if(phMsg)
        *phMsg=NULL;

    if(ppvContext)
        *ppvContext=NULL;

    //open a generic memory store
    hCertStore=CertOpenStore(CERT_STORE_PROV_MEMORY,
						 0,
						 NULL,
						 0,
						 NULL);

    if(NULL == hCertStore)
        goto CertOpenStoreErr;


    //single encoded cert
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_CERT)
    {
        if(CertAddEncodedCertificateToStore(hCertStore,
								dwEncodingType,
								pCertBlob->pbData,
								pCertBlob->cbData,
								CERT_STORE_ADD_ALWAYS,
								&pCertContext))
        {
            dwContentType=CERT_QUERY_CONTENT_CERT;
            goto Found;
        }
    }

    //an encoded CertificatePair (contains forward and/or reverse cross certs)
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_CERT_PAIR)
    {
        if(AddCertPairToStore(hCertStore,
								pCertBlob->pbData,
								pCertBlob->cbData
								))
        {
            dwContentType=CERT_QUERY_CONTENT_CERT_PAIR;
            goto Found;
        }
    }

     //single encoded CTL
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_CTL)
    {

        if(CertAddEncodedCTLToStore(hCertStore,
								dwEncodingType | dwMsgEncodingType,
								pCertBlob->pbData,
								pCertBlob->cbData,
								CERT_STORE_ADD_ALWAYS,
								&pCTLContext))
        {
            dwContentType=CERT_QUERY_CONTENT_CTL;
            dwEncodingType |= dwMsgEncodingType;
            goto Found;
        }
    }

    //single encoded CRL
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_CRL)
    {

        if(CertAddEncodedCRLToStore(hCertStore,
								dwEncodingType,
								pCertBlob->pbData,
								pCertBlob->cbData,
								CERT_STORE_ADD_ALWAYS,
								&pCRLContext))
        {
            dwContentType=CERT_QUERY_CONTENT_CRL;
            goto Found;
        }
    }

    //PFX
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_PFX)
    {
          if(PFXIsPFXBlob((CRYPT_DATA_BLOB*)pCertBlob))
          {
              dwContentType=CERT_QUERY_CONTENT_PFX;
    		//we need to close the temporary store
    		CertCloseStore(hCertStore, 0);
    		hCertStore=NULL;

              goto Found;
          }

    }



    //serialized CERT
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT)
    {

        if(CertAddSerializedElementToStore(hCertStore,
                                pCertBlob->pbData,
                                pCertBlob->cbData,
                                CERT_STORE_ADD_ALWAYS,
                                0,
                                CERT_STORE_CERTIFICATE_CONTEXT_FLAG,
                                NULL,
                                (const void **)&pCertContext))
        {
            dwContentType=CERT_QUERY_CONTENT_SERIALIZED_CERT;
            dwEncodingType=pCertContext->dwCertEncodingType;
            goto Found;
        }

    }

    //serialized CTL
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_SERIALIZED_CTL)
    {

        if(CertAddSerializedElementToStore(hCertStore,
                                pCertBlob->pbData,
                                pCertBlob->cbData,
                                CERT_STORE_ADD_ALWAYS,
                                0,
                                CERT_STORE_CTL_CONTEXT_FLAG,
                                NULL,
                                (const void **)&pCTLContext))
        {
            dwContentType=CERT_QUERY_CONTENT_SERIALIZED_CTL;
            dwEncodingType=pCTLContext->dwMsgAndCertEncodingType;
            goto Found;
        }

    }


    //serialized CRL
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_SERIALIZED_CRL)
    {

        if(CertAddSerializedElementToStore(hCertStore,
                                pCertBlob->pbData,
                                pCertBlob->cbData,
                                CERT_STORE_ADD_ALWAYS,
                                0,
                                CERT_STORE_CRL_CONTEXT_FLAG,
                                NULL,
                                (const void **)&pCRLContext))
        {
            dwContentType=CERT_QUERY_CONTENT_SERIALIZED_CRL;
            dwEncodingType=pCRLContext->dwCertEncodingType;
            goto Found;
        }

    }

    //we need to close the temporary store
    CertCloseStore(hCertStore, 0);

    hCertStore=NULL;


    //serialized store
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE)
    {
        if(hCertStore=CertOpenStore(
                            CERT_STORE_PROV_SERIALIZED,
							dwEncodingType | dwMsgEncodingType,
							NULL,
							0,
							pCertBlob))
        {
            dwContentType=CERT_QUERY_CONTENT_SERIALIZED_STORE;
            dwEncodingType |= dwMsgEncodingType;
            goto Found;
        }
    }

    //PKCS7 signed message
    if((dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED) ||
       (dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED) )
    {

       //get the embedded signed pkcs7
       if((CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED & dwContentTypeFlag))
       {
            if(GetEmbeddedPKCS7(pCertBlob, pwszFileName, &pbPKCS7, &cbPKCS7, &dwPKCS7EncodingType))
                fEmbedded=TRUE;
            else
            {
                if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED)
                {
                    //there is no embedded PKCS7
                    dwPKCS7EncodingType=dwEncodingType | dwMsgEncodingType;

                    pbPKCS7=pCertBlob->pbData;
                    cbPKCS7=pCertBlob->cbData;
                }
                else
                    pbPKCS7=NULL;
            }
       }
       else
       {
            //there is no embedded PKCS7
            dwPKCS7EncodingType=dwEncodingType | dwMsgEncodingType;

            pbPKCS7=pCertBlob->pbData;
            cbPKCS7=pCertBlob->cbData;
        }

        //proceed if there is a pkcs7 to decode
        if(NULL != pbPKCS7)
        {
            //check if the header is missing
            if(SignNoContentWrap(pbPKCS7, cbPKCS7))
                dwMsgType=CMSG_SIGNED;

            if(NULL==(hMsg=CryptMsgOpenToDecode(dwPKCS7EncodingType,
                            0,
                            dwMsgType,
                            NULL,
                            NULL,
                            NULL)))
                goto CryptMsgOpenErr;

            //update the message
            if(CryptMsgUpdate(hMsg,
                        pbPKCS7,
                        cbPKCS7,
                        TRUE))
            {

                //get the message type
                cbData=sizeof(dwMsgType);

                if(!CryptMsgGetParam(hMsg,
                            CMSG_TYPE_PARAM,
                            0,
                            &dwMsgType,
                            &cbData))
                    goto CryptMsgGetParamErr;

                if(CMSG_SIGNED == dwMsgType)
                {
                    PKCS7Blob.cbData=cbPKCS7;
                    PKCS7Blob.pbData=pbPKCS7;

                    //open a certificate store
                    hCertStore=CertOpenStore(CERT_STORE_PROV_PKCS7,
							dwPKCS7EncodingType,
							NULL,
							0,
							&PKCS7Blob);

                    if(NULL==hCertStore)
                        goto CertOpenStoreErr;

                    //we succeeded in opening a signed PKCS7
                    dwEncodingType = dwPKCS7EncodingType;

                    if(TRUE==fEmbedded)
                        dwContentType=CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED;
                    else
                        dwContentType=CERT_QUERY_CONTENT_PKCS7_SIGNED;

                    goto Found;
                }
            }

            //close the message
            CryptMsgClose(hMsg);

            hMsg=NULL;

        }
    }


    //PKCS7 unsigned message, not embedded
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED)
    {
        //no need to check if the header is missing
        if(NULL==(hMsg=CryptMsgOpenToDecode(dwEncodingType | dwMsgEncodingType,
                            0,
                            0,
                            NULL,
                            NULL,
                            NULL)))
            goto CryptMsgOpenErr;

        //update the message
        if(CryptMsgUpdate(hMsg,
                        pCertBlob->pbData,
                        pCertBlob->cbData,
                        TRUE))
        {

            //get the message type
            cbData=sizeof(dwMsgType);

            if(!CryptMsgGetParam(hMsg,
                            CMSG_TYPE_PARAM,
                            0,
                            &dwMsgType,
                            &cbData))
                goto CryptMsgGetParamErr;

            if(CMSG_SIGNED != dwMsgType)
            {
                //we succeeded in opening a unsigned PKCS7
                dwContentType=CERT_QUERY_CONTENT_PKCS7_UNSIGNED;
                dwEncodingType =dwEncodingType | dwMsgEncodingType;

                goto Found;
            }
        }

        //close the message
        CryptMsgClose(hMsg);

        hMsg=NULL;
    }

    //PKCS10
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_PKCS10)
    {
        //try to decode the BLOB
        cbData = 0;
        if(CryptDecodeObject(dwEncodingType,
                            X509_CERT_REQUEST_TO_BE_SIGNED,
                            pCertBlob->pbData,
                            pCertBlob->cbData,
                            0,
                            NULL,
                            &cbData))
        {
            dwContentType=CERT_QUERY_CONTENT_PKCS10;

            // CryptDecodeObjectEX should be usable here, but since this object
            // is included with XEnroll and XEnroll must run with Auth2UPD Crypt32
            // we must stick with the old CryptDecodeObject 2 pass calls.
            if( (dwFlag & CRYPT_DECODE_ALLOC_FLAG) == CRYPT_DECODE_ALLOC_FLAG ) {

                // allocate the space, must use local alloc
                if( NULL == (pReqInfo = (PCERT_REQUEST_INFO) LocalAlloc(LPTR, cbData)) )
                    goto LocalAllocErr;

                // decode the request
                if( !CryptDecodeObject(dwEncodingType,
                            X509_CERT_REQUEST_TO_BE_SIGNED,
                            pCertBlob->pbData,
                            pCertBlob->cbData,
                            0,
                            pReqInfo,
                            &cbData))
                goto CryptDecodeObjectErr;

            }
            goto Found;

        }
    }


    //we give up
    goto NoMatchErr;

Found:

    //fill in the output if required; Free the resources
    if(pdwMsgAndCertEncodingType)
        *pdwMsgAndCertEncodingType=dwEncodingType;

    if(pdwContentType)
        *pdwContentType=dwContentType;

    if(phCertStore)
        *phCertStore=hCertStore;
    else
    {
        if(hCertStore)
            CertCloseStore(hCertStore, 0);
    }

    if(phMsg)
        *phMsg=hMsg;
    else
    {
        if(hMsg)
            CryptMsgClose(hMsg);
    }

    if(ppvContext)
    {
        //only one of pCertContext or pCRLContext or pCRLContext is set
        if(pCertContext)
            *ppvContext=pCertContext;
        else
        {
            if(pCRLContext)
                *ppvContext=pCRLContext;

            else if(pReqInfo)
                *ppvContext=pReqInfo;

            else
                *ppvContext=pCTLContext;
        }
    }
    else
    {
        if(pCertContext)
            CertFreeCertificateContext(pCertContext);

        if(pCRLContext)
            CertFreeCRLContext(pCRLContext);

        if(pCTLContext)
            CertFreeCTLContext(pCTLContext);

        if(pReqInfo)
            LocalFree(pReqInfo);
    }


    fResult=TRUE;


CommonReturn:

    if(pbPKCS7)
    {
        if(TRUE==fEmbedded)
            free(pbPKCS7);
    }

	return fResult;

ErrorReturn:

    //relaset the stores and reset the local parameters
    if(hCertStore)
        CertCloseStore(hCertStore, 0);

    if(hMsg)
        CryptMsgClose(hMsg);

    if(pCertContext)
        CertFreeCertificateContext(pCertContext);

    if(pCRLContext)
        CertFreeCRLContext(pCRLContext);

    if(pCTLContext)
        CertFreeCTLContext(pCTLContext);

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(NoMatchErr,CRYPT_E_NO_MATCH);
SET_ERROR(LocalAllocErr, ERROR_OUTOFMEMORY);
TRACE_ERROR(CryptDecodeObjectErr);
TRACE_ERROR(CryptMsgOpenErr);
TRACE_ERROR(CryptMsgGetParamErr);
TRACE_ERROR(CertOpenStoreErr);
}

//-------------------------------------------------------------------------
//
//  CryptQueryObject takes a CERT_BLOB or a file name and returns the
//  information about the content in the blob or in the file.
//
//  Parameters:
//  INPUT   dwObjectType:
//                       Indicate the type of the object.  Should be one of the
//                       following:
//                          CERT_QUERY_OBJECT_FILE
//                          CERT_QUERY_OBJECT_BLOB
//
//  INPUT   pvObject:
//                        If dwObjectType == CERT_QUERY_OBJECT_FILE, it is a
//                        LPWSTR, that is, the pointer to a wchar file name
//                        if dwObjectType == CERT_QUERY_OBJECT_BLOB, it is a
//                        PCERT_BLOB, that is, a pointer to a CERT_BLOB
//
//  INPUT   dwExpectedContentTypeFlags:
//                        Indicate the expected contenet type.
//                        Can be one of the following:
//                              CERT_QUERY_CONTENT_FLAG_ALL  (the content can be any type)
//                              CERT_QUERY_CONTENT_FLAG_CERT
//                              CERT_QUERY_CONTENT_FLAG_CTL
//                              CERT_QUERY_CONTENT_FLAG_CRL
//                              CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE
//                              CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT
//                              CERT_QUERY_CONTENT_FLAG_SERIALIZED_CTL
//                              CERT_QUERY_CONTENT_FLAG_SERIALIZED_CRL
//                              CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED
//                              CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED
//                              CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED
//                              CERT_QUERY_CONTENT_FLAG_PKCS10
//                              CERT_QUERY_CONTENT_FLAG_PFX
//                              CERT_QUERY_CONTENT_FLAG_CERT_PAIR
//
//  INPUT   dwExpectedFormatTypeFlags:
//                        Indicate the expected format type.
//                        Can be one of the following:
//                              CERT_QUERY_FORMAT_FLAG_ALL (the content can be any format)
//                              CERT_QUERY_FORMAT_FLAG_BINARY
//                              CERT_QUERY_FORMAT_FLAG_BASE64_ENCODED
//                              CERT_QUERY_FORMAT_FLAG_ASN_ASCII_HEX_ENCODED
//
//
//  INPUT   dwFlags
//                        Reserved flag.  Should always set to 0
//
//  OUTPUT  pdwMsgAndCertEncodingType
//                        Optional output.  If NULL != pdwMsgAndCertEncodingType,
//                        it contains the encoding type of the content as any
//                        combination of the following:
//                              X509_ASN_ENCODING
//                              PKCS_7_ASN_ENCODING
//
//  OUTPUT  pdwContentType
//                        Optional output.  If NULL!=pdwContentType, it contains
//                        the content type as one of the the following:
//                              CERT_QUERY_CONTENT_CERT
//                              CERT_QUERY_CONTENT_CTL
//                              CERT_QUERY_CONTENT_CRL
//                              CERT_QUERY_CONTENT_SERIALIZED_STORE
//                              CERT_QUERY_CONTENT_SERIALIZED_CERT
//                              CERT_QUERY_CONTENT_SERIALIZED_CTL
//                              CERT_QUERY_CONTENT_SERIALIZED_CRL
//                              CERT_QUERY_CONTENT_PKCS7_SIGNED
//                              CERT_QUERY_CONTENT_PKCS7_UNSIGNED
//                              CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED
//                              CERT_QUERY_CONTENT_PKCS10
//                              CERT_QUERY_CONTENT_PFX
//                              CERT_QUERY_CONTENT_CERT_PAIR
//
//  OUTPUT  pdwFormatType
//                        Optional output.  If NULL !=pdwFormatType, it
//                        contains the format type of the content as one of the
//                        following:
//                              CERT_QUERY_FORMAT_BINARY
//                              CERT_QUERY_FORMAT_BASE64_ENCODED
//                              CERT_QUERY_FORMAT_ASN_ASCII_HEX_ENCODED
//
//
//  OUTPUT  phCertStore
//                        Optional output.  If NULL !=phStore,
//                        it contains a cert store that includes all of certificates,
//                        CRL, and CTL in the object if the object content type is
//                        one of the following:
//                              CERT_QUERY_CONTENT_CERT
//                              CERT_QUERY_CONTENT_CTL
//                              CERT_QUERY_CONTENT_CRL
//                              CERT_QUERY_CONTENT_SERIALIZED_STORE
//                              CERT_QUERY_CONTENT_SERIALIZED_CERT
//                              CERT_QUERY_CONTENT_SERIALIZED_CTL
//                              CERT_QUERY_CONTENT_SERIALIZED_CRL
//                              CERT_QUERY_CONTENT_PKCS7_SIGNED
//                              CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED
//                              CERT_QUERY_CONTENT_CERT_PAIR
//
//                       Caller should free *phCertStore via CertCloseStore.
//
//
//  OUTPUT  phMsg        Optional output.  If NULL != phMsg,
//                        it contains a handle to a opened message if
//                        the content type is one of the following:
//                              CERT_QUERY_CONTENT_PKCS7_SIGNED
//                              CERT_QUERY_CONTENT_PKCS7_UNSIGNED
//                              CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED
//
//                       Caller should free *phMsg via CryptMsgClose.
//
//  OUTPUT pContext     Optional output.  If NULL != pContext,
//                      it contains either a PCCERT_CONTEXT or PCCRL_CONTEXT,
//                      or PCCTL_CONTEXT based on the content type.
//
//                      If the content type is CERT_QUERY_CONTENT_CERT or
//                      CERT_QUERY_CONTENT_SERIALIZED_CERT, it is a PCCERT_CONTEXT;
//                      Caller should free the pContext via CertFreeCertificateContext.
//
//                      If the content type is CERT_QUERY_CONTENT_CRL or
//                      CERT_QUERY_CONTENT_SERIALIZED_CRL, it is a PCCRL_CONTEXT;
//                      Caller should free the pContext via CertFreeCRLContext.
//
//                      If the content type is CERT_QUERY_CONTENT_CTL or
//                      CERT_QUERY_CONTENT_SERIALIZED_CTL, it is a PCCTL_CONTEXT;
//                      Caller should free the pContext via CertFreeCTLContext.
//
//  If the *pbObject is of type CERT_QUERY_CONTENT_PKCS10 or CERT_QUERY_CONTENT_PFX, CryptQueryObject
//  will not return anything in *phCertstore, *phMsg, or *ppvContext.
//--------------------------------------------------------------------------

BOOL
WINAPI
CryptQueryObject(DWORD            dwObjectType,
                       const void       *pvObject,
                       DWORD            dwExpectedContentTypeFlags,
                       DWORD            dwExpectedFormatTypeFlags,
                       DWORD            dwFlags,
                       DWORD            *pdwMsgAndCertEncodingType,
                       DWORD            *pdwContentType,
                       DWORD            *pdwFormatType,
                       HCERTSTORE       *phCertStore,
                       HCRYPTMSG        *phMsg,
                       const void       **ppvContext)
{
        BOOL        fResult=FALSE;
        DWORD       err;
        CERT_BLOB   CertBlob;
        DWORD       cbData=0;
        BYTE        *pbData=NULL;

        BYTE        *pbToDecode=NULL;
        DWORD       cbToDecode=0;

        DWORD       cbDecodedData=0;
        BYTE        *pbDecodedData=NULL;
        HRESULT     hr=S_OK;
        DWORD       dwFormatType=0;

    __try {

        //check input parameters
        if(NULL==pvObject)
            goto InvalidArgErr;

        //make sure we have a correct dwFormatTypeFlag
        if(0==(dwExpectedFormatTypeFlags & CERT_QUERY_FORMAT_FLAG_ALL))
            goto InvalidArgErr;

        //make sure we have a correct dwContentTypeFlag
        if(0==(dwExpectedContentTypeFlags & CERT_QUERY_CONTENT_FLAG_ALL))
            goto InvalidArgErr;

        //NULL out local variables
        memset(&CertBlob, 0, sizeof(CERT_BLOB));

        //get the BLOB
        if(CERT_QUERY_OBJECT_FILE == dwObjectType)
        {
              if(S_OK!=(hr=RetrieveBLOBFromFile((LPWSTR)pvObject, &cbData, &pbData)))
                    goto  RetrieveBLOBFromFileErr;

        }
        else
        {
            if(CERT_QUERY_OBJECT_BLOB == dwObjectType)
            {
                cbData=((PCERT_BLOB)pvObject)->cbData;
                pbData=((PCERT_BLOB)pvObject)->pbData;

            }
            else
                goto InvalidArgErr;
        }

       //make sure the input are valid
       if(0==cbData || NULL==pbData)
            goto InvalidArgErr;


        //assume the BLOBs are ANSCII
        CertBlob.cbData=cbData;
        CertBlob.pbData=pbData;


        //binary decoding
        if(dwExpectedFormatTypeFlags & CERT_QUERY_FORMAT_FLAG_BINARY)
        {

            if(I_CryptQueryObject(
                        &CertBlob,
                        (CERT_QUERY_OBJECT_FILE == dwObjectType) ? (LPWSTR)pvObject : NULL,
                        dwExpectedContentTypeFlags,
                        dwExpectedFormatTypeFlags,
                        dwFlags,
                        pdwMsgAndCertEncodingType,
                        pdwContentType,
                        pdwFormatType,
                        phCertStore,
                        phMsg,
                        ppvContext))
            {
                dwFormatType=CERT_QUERY_FORMAT_BINARY;
                goto Done;
            }
        }

        if(dwExpectedFormatTypeFlags &
                CERT_QUERY_FORMAT_FLAG_ASN_ASCII_HEX_ENCODED)
        {
            if (ASN_ASCII_HEX_PREFIX_LEN < cbData &&
                    0 == _strnicmp((char *) pbData, ASN_ASCII_HEX_PREFIX,
                            ASN_ASCII_HEX_PREFIX_LEN))
            {
                dwFormatType=CERT_QUERY_FORMAT_ASN_ASCII_HEX_ENCODED;

                if (!DecodeAsciiHex(
                        (char *) (pbData + ASN_ASCII_HEX_PREFIX_LEN),
                        cbData - ASN_ASCII_HEX_PREFIX_LEN,
                        &pbDecodedData,
                        &cbDecodedData
                        ))
                    goto InvalidAsciiHex;

                CertBlob.cbData=cbDecodedData;
                CertBlob.pbData=pbDecodedData;


                if(I_CryptQueryObject(
                        &CertBlob,
                        NULL,
                        dwExpectedContentTypeFlags,
                        dwExpectedFormatTypeFlags,
                        dwFlags,
                        pdwMsgAndCertEncodingType,
                        pdwContentType,
                        pdwFormatType,
                        phCertStore,
                        phMsg,
                        ppvContext))
                {
                    goto Done;
                } else {
                    goto I_CryptQueryObjectErr;
                }
            }
        }

        if(dwExpectedFormatTypeFlags & CERT_QUERY_FORMAT_FLAG_BASE64_ENCODED)
        {

           //try to base64 decode the content
           //1st, try decode as ANSCII character without header,
           //then try decode as ANSCII character with header
			pbToDecode=NULL;
			cbToDecode=0;

            if(cbData > CBBEGINCRL_A)
            {
                if(!strncmp(BEGINCRL_A, (CHAR *)pbData, CBBEGINCRL_A))
                {
                    pbToDecode = (BYTE *)((DWORD_PTR)pbData+CBBEGINCRL_A);
                    cbToDecode = cbData-CBBEGINCRL_A;
                }
                else
				{
					if(cbData > CBBEGINCERT_A)
					{
						if(!strncmp(BEGINCERT_A, (CHAR *)pbData, CBBEGINCERT_A))
						{
							pbToDecode = (BYTE *)((DWORD_PTR)pbData+CBBEGINCERT_A);
							cbToDecode = cbData-CBBEGINCERT_A;
						}
						else
						{
							if(cbData > CBBEGINREQUEST_A)
							{
								if(!strncmp(BEGINREQUEST_A, (CHAR *)pbData, CBBEGINREQUEST_A))
								{
									pbToDecode = (BYTE *)((DWORD_PTR)pbData+CBBEGINREQUEST_A);
									cbToDecode = cbData-CBBEGINREQUEST_A;
								}
							}
						}
					}
				}
            }

			//use the original data if no header is found
            if(NULL == pbToDecode) 
			{
				pbToDecode = pbData;
				cbToDecode = cbData;
			}


            if(!DecodeBlobA((CHAR *)pbToDecode, cbToDecode, &pbDecodedData, &cbDecodedData))
            {
                //now, try the UNICODE without header
                //cbData has to the multiple of sizeof(WCHAR)

                if(cbData % sizeof(WCHAR) == 0)
                {
                    LPWSTR pwszUnicode = (LPWSTR) pbData;
                    DWORD cchUnicode = cbData / sizeof(WCHAR);

                    // Check for the special Notepad UNICODE character
                    // inserted at the beginning and skip past it if present.
                    if (0 < cchUnicode &&
                            NOTEPAD_UNICODE_SPECIAL_WCHAR == *pwszUnicode)
                    {
                        cchUnicode--;
                        pwszUnicode++;
                    }

                    //get rid of the header
					if(cchUnicode > CBBEGINCRL_W)
					{
						if(!wcsncmp(BEGINCRL_W, pwszUnicode, CBBEGINCRL_W))
						{
							pwszUnicode += CBBEGINCRL_W;
                            cchUnicode -= CBBEGINCRL_W;
						}
						else
						{
							if(cchUnicode > CBBEGINCERT_W)
							{
								if(!wcsncmp(BEGINCERT_W, pwszUnicode, CBBEGINCERT_W))
								{
									pwszUnicode += CBBEGINCERT_W;
									cchUnicode -= CBBEGINCERT_W;
								}
								else
								{
									if(cchUnicode > CBBEGINREQUEST_W)
									{
										if(!wcsncmp(BEGINREQUEST_W, pwszUnicode, CBBEGINREQUEST_W))
										{
											pwszUnicode += CBBEGINREQUEST_W;
											cchUnicode -= CBBEGINREQUEST_W;
										}
									}
								}
							}
						}
					}

                    if(!DecodeBlobW(pwszUnicode, cchUnicode, &pbDecodedData, &cbDecodedData))
                            //now we are conviced the BLOB is not base64 encoded
                         goto NoMatchErr;
                }
                else
                    //now we are conviced the BLOB is not base64 encoded
                    goto NoMatchErr;
            }

            //the BLOB has been properly decoded
            dwFormatType=CERT_QUERY_FORMAT_BASE64_ENCODED;

            //make sure the base64 decode routine worked
            if(0==cbDecodedData || NULL==pbDecodedData)
                goto BadEncodeErr;

            CertBlob.cbData=cbDecodedData;
            CertBlob.pbData=pbDecodedData;


            //try the base64 decoded BLOB
            if(!I_CryptQueryObject(
                        &CertBlob,
                        NULL,
                        dwExpectedContentTypeFlags,
                        dwExpectedFormatTypeFlags,
                        dwFlags,
                        pdwMsgAndCertEncodingType,
                        pdwContentType,
                        pdwFormatType,
                        phCertStore,
                        phMsg,
                        ppvContext))
                    goto I_CryptQueryObjectErr;
        }
        else
        {
            goto NoMatchErr;
        }

Done:
        //return the FormatType
        if(NULL != pdwFormatType)
            *pdwFormatType = dwFormatType;

        fResult=TRUE;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        err = GetExceptionCode();
        goto ExceptionErr;
    }

CommonReturn:

    //free memory
    if(CERT_QUERY_OBJECT_FILE == dwObjectType)
    {
        if(pbData)
            UnmapViewOfFile(pbData);
    }

    if(pbDecodedData)
        free(pbDecodedData);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR_VAR(RetrieveBLOBFromFileErr, hr);
SET_ERROR(InvalidArgErr,E_INVALIDARG);
TRACE_ERROR(I_CryptQueryObjectErr);
SET_ERROR(NoMatchErr, CRYPT_E_NO_MATCH);
SET_ERROR(BadEncodeErr, CRYPT_E_BAD_ENCODE);
TRACE_ERROR(InvalidAsciiHex);
SET_ERROR_VAR(ExceptionErr, err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\protroot.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       protroot.h
//
//  Contents:   Public functions in protroot.cpp
//
//  History:    15-Sep-00   philh   created
//--------------------------------------------------------------------------

#ifndef __PROTROOT_H__
#define __PROTROOT_H__

BOOL
IPR_EnableSecurityPrivilege(
    LPCSTR pszPrivilege
    );

BOOL
IPR_IsCurrentUserRootsAllowed();

BOOL
IPR_IsAuthRootsAllowed();

BOOL
IPR_IsNTAuthRequiredDisabled();

BOOL
IPR_IsAuthRootAutoUpdateDisabled();

void
IPR_InitProtectedRootInfo();

BOOL
IPR_DeleteUnprotectedRootsFromStore(
    IN HCERTSTORE hStore,
    OUT BOOL *pfProtected
    );

int
IPR_ProtectedRootMessageBox(
    IN handle_t hRpc,
    IN PCCERT_CONTEXT pCert,
    IN UINT wActionID,
    IN UINT uFlags
    );

//+=========================================================================
//  crypt32 Event Logging Functions
//==========================================================================
void
IPR_LogCrypt32Event(
    IN WORD wType,
    IN DWORD dwEventID,
    IN WORD wNumStrings,
    IN LPCWSTR *rgpwszStrings
    );

void
IPR_LogCrypt32Error(
    IN DWORD dwEventID,
    IN LPCWSTR pwszString,      // %1
    IN DWORD dwErr              // %2
    );

void
IPR_LogCertInformation(
    IN DWORD dwEventID,
    IN PCCERT_CONTEXT pCert,
    IN BOOL fFormatIssuerName
    );

BOOL
IPR_AddCertInAuthRootAutoUpdateCtl(
    IN PCCERT_CONTEXT pCert,
    IN PCCTL_CONTEXT pCtl
    );
#endif  // __PROTROOT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------


#define         IDS_ROOT_MSG_BOX_TITLE                      6100
#define         IDS_ROOT_MSG_BOX_SUBJECT                    6110
#define         IDS_ROOT_MSG_BOX_ISSUER                     6120
#define         IDS_ROOT_MSG_BOX_SELF_ISSUED                6121
#define         IDS_ROOT_MSG_BOX_SERIAL_NUMBER              6130
#define         IDS_ROOT_MSG_BOX_SHA1_THUMBPRINT            6140
#define         IDS_ROOT_MSG_BOX_MD5_THUMBPRINT             6150
#define         IDS_ROOT_MSG_BOX_TIME_VALIDITY              6160
#define         IDS_ROOT_MSG_BOX_ADD_ACTION                 6170
#define         IDS_ROOT_MSG_BOX_DELETE_ACTION              6180
#define         IDS_ROOT_MSG_BOX_DELETE_UNKNOWN_PROT_ROOTS  6190

#define         IDS_INSTALLCA                               6200
#define         IDS_TOO_MANY_CA_CERTS                       6210

// Following resources are used to format chain extended error information
#define         IDS_INVALID_ISSUER_NAME_CONSTRAINT_EXT      6500
#define         IDS_INVALID_SUBJECT_NAME_CONSTRAINT_INFO    6501
#define         IDS_NOT_SUPPORTED_ENTRY_NAME_CONSTRAINT     6502
#define         IDS_NOT_SUPPORTED_PERMITTED_NAME_CONSTRAINT 6503
#define         IDS_NOT_SUPPORTED_EXCLUDED_NAME_CONSTRAINT  6504
#define         IDS_NOT_PERMITTED_ENTRY_NAME_CONSTRAINT     6505
#define         IDS_EXCLUDED_ENTRY_NAME_CONSTRAINT          6506
#define         IDS_NOT_DEFINED_ENTRY_NAME_CONSTRAINT       6507


#define         IDS_BASIC_CONS2_PATH                    7002
#define         IDS_BASIC_CONS2_NONE                    7003
#define         IDS_NONE                                7004
#define         IDS_SUB_EE                              7005
#define         IDS_SUB_CA                              7006
#define         IDS_UNSPECIFIED                         7007
#define         IDS_KEY_COMPROMISE                      7008
#define         IDS_CA_COMPROMISE                       7009
#define         IDS_AFFILIATION_CHANGED                 7010
#define         IDS_SUPERSEDED                          7011
#define         IDS_CESSATION_OF_OPERATION              7012
#define         IDS_CERTIFICATE_HOLD                    7013
#define         IDS_UNKNOWN_VALUE                       7014
#define         IDS_REMOVE_FROM_CRL                     7015
#define         IDS_SUBTREE_CONSTRAINT                  7016
#define         IDS_NO_INFO                             7017
#define         IDS_OTHER_NAME                          7018
#define         IDS_RFC822_NAME                         7019
#define         IDS_DNS_NAME                            7020
#define         IDS_X400_ADDRESS                        7021
#define         IDS_DIRECTORY_NAME                      7022
#define         IDS_EDI_PARTY_NAME                      7023
#define         IDS_URL                                 7024
#define         IDS_IP_ADDRESS                          7025
#define         IDS_REGISTERED_ID                       7026
#define         IDS_ALT_NAME_ENTRY_UNKNOWN              7027
#define         IDS_ALT_NAME_ENTRY                      7030
#define         IDS_YES                                 7031
#define         IDS_NO                                  7032
#define         IDS_AVAILABLE                           7033
#define         IDS_NOT_AVAILABLE                       7034
#define         IDS_SPC_FINANCIAL_NOT_AVAIL             7035
#define         IDS_MIME_CAPABILITY                     7036
#define         IDS_SPC_FINANCIAL_AVAIL                 7037
#define         IDS_AUTH_KEY_ID                         7038
#define         IDS_AUTH_CERT_NUMBER                    7039
#define         IDS_AUTH_CERT_ISSUER                    7040
#define         IDS_DIG_SIG                             7041
#define         IDS_KEY_ENCIPHERMENT                    7042
#define         IDS_DATA_ENCIPHERMENT                   7043
#define         IDS_KEY_AGREEMENT                       7044
#define         IDS_CERT_SIGN                           7045
#define         IDS_OFFLINE_CRL_SIGN                    7046
#define         IDS_CRL_SIGN                            7047
#define         IDS_DECIPHER_ONLY                       7048
#define         IDS_NON_REPUDIATION                     7049
#define         IDS_ENCIPHER_ONLY                       7050
#define         IDS_MIME_CAPABILITY_NO_PARAM            7052
#define         IDS_ENHANCED_KEY_USAGE                  7053
#define         IDS_NO_ALT_NAME                         7054
#define         IDS_UNKNOWN_ACCESS_METHOD               7055
#define         IDS_AUTHORITY_ACCESS_INFO               7056
#define         IDS_CRL_REASON                          7057
#define         IDS_UNKNOWN_KEY_USAGE                   7058
#define         IDS_BIT_BLOB                            7059
#define         IDS_SUNDAY                              7060
#define         IDS_MONDAY                              IDS_SUNDAY+1  
#define         IDS_TUESDAY                             IDS_MONDAY+1  
#define         IDS_WED                                 IDS_TUESDAY+1 
#define         IDS_THUR                                IDS_WED+1     
#define         IDS_FRI                                 IDS_THUR+1    
#define         IDS_SAT                                 IDS_FRI+1     
#define         IDS_JAN                                 7070
#define         IDS_FEB                                 IDS_JAN+1   
#define         IDS_MAR                                 IDS_FEB+1   
#define         IDS_APR                                 IDS_MAR+1   
#define         IDS_MAY                                 IDS_APR+1   
#define         IDS_JUNE                                IDS_MAY+1   
#define         IDS_JULY                                IDS_JUNE+1  
#define         IDS_AUG                                 IDS_JULY+1  
#define         IDS_SEP                                 IDS_AUG+1   
#define         IDS_OCT                                 IDS_SEP+1   
#define         IDS_NOV                                 IDS_OCT+1   
#define         IDS_DEC                                 IDS_NOV+1
#define         IDS_AM                                  7083
#define         IDS_PM                                  7084 
#define         IDS_FILE_TIME                           7085
#define         IDS_FILE_TIME_DWORD                     7086
#define         IDS_KEY_ATTR_ID                         7087
#define         IDS_KEY_ATTR_USAGE                      7088
#define         IDS_KEY_ATTR_AFTER                      7089
#define         IDS_KEY_ATTR_BEFORE                     7090
#define         IDS_KEY_RES_USAGE                       7091
#define         IDS_KEY_RES_ID                          7092
#define         IDS_CRL_DIST_FULL_NAME                  7093
#define         IDS_CRL_DIST_ISSUER_RDN                 7094
#define         IDS_DWORD                               7095
#define         IDS_UNKNOWN_CRL_REASON                  7096
#define         IDS_CRL_DIST_NAME                       7097
#define         IDS_CRL_DIST_REASON                     7098
#define         IDS_CRL_DIST_ENTRY                      7099
#define         IDS_CRL_DIST_ISSUER                     7100
#define         IDS_POLICY_QUALIFIER                    7101
#define         IDS_POLICY_QUALIFIER_NO_BLOB            7102
#define         IDS_POLICY_QUALIFIER_INFO               7103
#define         IDS_CERT_POLICY_NO_QUA                  7104
#define         IDS_CERT_POLICY                         7105
#define         IDS_SPC_URL_LINK                        7107
#define         IDS_SPC_MONIKER_LINK                    7108
#define         IDS_SPC_FILE_LINK                       7109
#define         IDS_SPC_LINK_UNKNOWN                    7110
#define         IDS_IMAGE_LINK                          7111
#define         IDS_IMAGE_BITMAP                        7112
#define         IDS_IMAGE_METAFILE                      7113
#define         IDS_IMAGE_ENHANCED_METAFILE             7114
#define         IDS_IMAGE_GIFFILE                       7115
#define         IDS_AGENCY_POLICY_INFO                  7116
#define         IDS_AGENCY_POLICY_DSPLY                 7117
#define         IDS_AGENCY_LOGO_LINK                    7118
#define         IDS_SPC_OBJECT_NO_BLOB                  7119
#define         IDS_AGENCY_LOGO_IMAGE                   7120
#define         IDS_BASIC_CONS2_PATH_MULTI              7121
#define         IDS_BASIC_CONS2_NONE_MULTI              7122
#define         IDS_SUBTREE_CONSTRAINT_MULTI            7123
#define         IDS_SPC_FINANCIAL_AVAIL_MULTI           7124
#define         IDS_SPC_FINANCIAL_NOT_AVAIL_MULTI       7125
#define         IDS_MIME_CAPABILITY_MULTI               7126
#define         IDS_MIME_CAPABILITY_NO_PARAM_MULTI      7127
#define         IDS_AUTHORITY_ACCESS_INFO_MULTI         7128
#define         IDS_AUTHORITY_ACCESS_NO_METHOD_MULTI    7129
#define         IDS_KEY_ATTR_ID_MULTI                   7130
#define         IDS_KEY_ATTR_USAGE_MULTI                7131
#define         IDS_KEY_ATTR_BEFORE_MULTI               7132
#define         IDS_KEY_ATTR_AFTER_MULTI                7133
#define         IDS_KEY_RES_ID_MULTI                    7134
#define         IDS_KEY_RES_USAGE_MULTI                 7135
#define         IDS_CRL_DIST_FULL_NAME_MULTI            7136
#define         IDS_CRL_DIST_NAME_MULTI                 7137
#define         IDS_CRL_DIST_REASON_MULTI               7138
#define         IDS_CRL_DIST_ISSUER_MULTI               7139
#define         IDS_CRL_DIST_ENTRY_MULTI                7140
#define         IDS_POLICY_QUALIFIER_MULTI              7141
#define         IDS_POLICY_QUALIFIER_INFO_MULTI         7142
#define         IDS_CERT_POLICY_MULTI                   7143
#define         IDS_CERT_POLICY_NO_QUA_MULTI            7144
#define         IDS_SPC_MONIKER_LINK_MULTI              7145
#define         IDS_IMAGE_LINK_MULTI                    7146
#define         IDS_IMAGE_BITMAP_MULTI                  7147
#define         IDS_IMAGE_METAFILE_MULTI                7148
#define         IDS_IMAGE_ENHANCED_METAFILE_MULTI       7149
#define         IDS_IMAGE_GIFFILE_MULTI                 7150
#define         IDS_AGENCY_POLICY_INFO_MULTI            7151
#define         IDS_AGENCY_POLICY_DSPLY_MULTI           7152
#define         IDS_AGENCY_LOGO_IMAGE_MULTI             7153
#define         IDS_AGENCY_LOGO_LINK_MULTI              7154
#define         IDS_AUTH_CERT_ISSUER_MULTI              7155
#define         IDS_AUTHORITY_ACCESS_NO_METHOD          7156
#define         IDS_SPC_OBJECT_DATA                     7157
#define         IDS_SPC_OBJECT_CLASS                    7158
#define         IDS_ONE_TAB                             7159
#define         IDS_TWO_TABS                            7160
#define         IDS_THREE_TABS                          7161
#define         IDS_FOUR_TABS                           7162
#define         IDS_FRMT_SPACE                          7170
#define         IDS_FRMT_A                              7171
#define         IDS_FRMT_ZERO                           7172
#define         IDS_FRMT_HEX                            7173
#define         IDS_DIRECTORY_NAME_MULTI                7174
#define         IDS_UNICODE_STRING                      7175
#define         IDS_UNICODE_STRING_MULTI                7176
#define         IDS_CA_VERSION                          7177
#define         IDS_CA_VERSION_MULTI                    7178
#define         IDS_NETSCAPE_SSL_CLIENT_AUTH            7179
#define         IDS_NETSCAPE_SSL_SERVER_AUTH            7180
#define         IDS_NETSCAPE_SMIME                      7181
#define         IDS_NETSCAPE_SIGN                       7182
#define         IDS_NETSCAPE_SSL_CA                     7183
#define         IDS_NETSCAPE_SMIME_CA                   7184
#define         IDS_NETSCAPE_SIGN_CA                    7185
#define         IDS_UNKNOWN_CERT_TYPE                   7186
#define         IDS_OTHER_NAME_MULTI                    7187
#define         IDS_OTHER_NAME_OIDNAME                  7188
#define         IDS_OTHER_NAME_OID                      7189
#define         IDS_NAME_VALUE                          7190
#define         IDS_NAME_VALUE_MULTI                    7191
#define         IDS_POLICY_QUALIFIER_ELEMENT            7192
#define         IDS_USER_NOTICE_TEXT                    7193                        
#define         IDS_USER_NOTICE_REF_ORG                 7194        
#define         IDS_USER_NOTICE_REF                     7195
#define         IDS_USER_NOTICE_REF_NUMBER              7196
#define         IDS_POLICY_QUALIFIER_NO_BLOB_MULTI      7197
// Post Win2K
#define         IDS_INTEGER                             7198
#define         IDS_STRING                              7199
#define         IDS_GENERIC_OBJECT_ID                   7200
#define         IDS_CRL_NUMBER                          7201
#define         IDS_DELTA_CRL_INDICATOR                 7202
#define         IDS_CRL_VIRTUAL_BASE                    7203
#define         IDS_ONLY_CONTAINS_USER_CERTS            7204
#define         IDS_ONLY_CONTAINS_CA_CERTS              7205
#define         IDS_INDIRECT_CRL                        7206
#define         IDS_ONLY_SOME_CRL_DIST_NAME             7207
#define         IDS_ONLY_SOME_CRL_DIST_NAME_MULTI       7208
#define         IDS_FRESHEST_CRL                        7209
#define         IDS_FRESHEST_CRL_MULTI                  7210
#define         IDS_CRL_SELF_CDP                        7211
#define         IDS_CRL_SELF_CDP_MULTI                  7212
#define         IDS_NAME_CONSTRAINTS_PERMITTED          7213
#define         IDS_NAME_CONSTRAINTS_EXCLUDED           7214
#define         IDS_NAME_CONSTRAINTS_PERMITTED_NONE     7215
#define         IDS_NAME_CONSTRAINTS_EXCLUDED_NONE      7216
#define         IDS_NAME_CONSTRAINTS_SUBTREE            7217
#define         IDS_NAME_CONSTRAINTS_SUBTREE_NO_MAX     7218

#define         IDS_APPLICATION_CERT_POLICY             7219 
#define         IDS_APPLICATION_CERT_POLICY_MULTI       7220 
#define         IDS_APPLICATION_CERT_POLICY_NO_QUA      7221 
#define         IDS_APPLICATION_CERT_POLICY_NO_QUA_MULTI 7222 
#define         IDS_ISSUER_DOMAIN_POLICY                7223
#define         IDS_SUBJECT_DOMAIN_POLICY               7224
#define         IDS_REQUIRED_EXPLICIT_POLICY_SKIP_CERTS 7225
#define         IDS_INHIBIT_POLICY_MAPPING_SKIP_CERTS   7226
#define         IDS_CERTIFICATE_TEMPLATE_MAJOR_VERSION  7227
#define         IDS_CERTIFICATE_TEMPLATE_MINOR_VERSION  7228

#define         IDS_IPADDRESS_V4_4                      7229
#define         IDS_IPADDRESS_V4_8                      7230
#define         IDS_IPADDRESS_V6_16                     7231
#define         IDS_IPADDRESS_V6_32                     7232

#define         IDS_XCERT_DELTA_SYNC_TIME               7233
#define         IDS_XCERT_DIST_POINT                    7234

// CSP resources in range 7500 ... 7600
// THESE RESOURCES ARE LOADED BY THE MS CSPs SO THE
// DEFINE VALUES MAY NOT CHANGE UNLESS THEY ARE
// CHANGED IN THE CSPs
#define         IDS_CSP_RSA_SIG_DESCR                   7501
#define         IDS_CSP_RSA_EXCH_DESCR                  7502
#define         IDS_CSP_IMPORT_SIMPLE                   7503
#define         IDS_CSP_SIGNING_E                       7504
#define         IDS_CSP_CREATE_RSA_SIG                  7505
#define         IDS_CSP_CREATE_RSA_EXCH                 7506
#define         IDS_CSP_DSS_SIG_DESCR                   7507
#define         IDS_CSP_DSS_EXCH_DESCR                  7508
#define         IDS_CSP_CREATE_DSS_SIG                  7509
#define         IDS_CSP_CREATE_DH_EXCH                  7510
#define         IDS_CSP_IMPORT_E_PUB                    7511
#define         IDS_CSP_MIGR                            7512
#define         IDS_CSP_DELETE_SIG                      7513
#define         IDS_CSP_DELETE_KEYX                     7514
#define         IDS_CSP_DELETE_SIG_MIGR                 7515
#define         IDS_CSP_DELETE_KEYX_MIGR                7516
#define         IDS_CSP_SIGNING_S                       7517
#define         IDS_CSP_EXPORT_E_PRIV                   7518
#define         IDS_CSP_EXPORT_S_PRIV                   7519
#define         IDS_CSP_IMPORT_E_PRIV                   7520
#define         IDS_CSP_IMPORT_S_PRIV                   7521
#define         IDS_CSP_AUDIT_CAPI_KEY                  7522

#include "oidinfo.h"
// Note IDS_EXT_*                          in range 8000 .. 8499
// Note IDS_ENHKEY_*                       in range 8500 .. 8999
// Note IDS_SYS_NAME_                      in range 9000 .. 9099
// Note IDS_PHY_NAME_                      in range 9100 .. 9199
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\rootlist.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       rootlist.cpp
//
//  Contents:   Signed List of Trusted Roots Helper Functions
//
//
//  Functions:  IRL_VerifyAuthRootAutoUpdateCtl
//
//  History:    01-Aug-99   philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

#ifdef STATIC
#undef STATIC
#endif
#define STATIC

//+-------------------------------------------------------------------------
// If the certificate has an EKU extension, returns an allocated and
// decoded EKU. Otherwise, returns NULL.
//
// PkiFree() must be called to free the returned EKU.
//--------------------------------------------------------------------------
STATIC
PCERT_ENHKEY_USAGE
WINAPI
GetAndAllocCertEKUExt(
    IN PCCERT_CONTEXT pCert
    )
{
    PCERT_ENHKEY_USAGE pUsage = NULL;
    DWORD cbUsage;

    cbUsage = 0;
    if (!CertGetEnhancedKeyUsage(
            pCert,
            CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
            NULL,                                   // pUsage
            &cbUsage) || 0 == cbUsage)
        goto GetEnhancedKeyUsageError;
    if (NULL == (pUsage = (PCERT_ENHKEY_USAGE) PkiNonzeroAlloc(cbUsage)))
        goto OutOfMemory;
    if (!CertGetEnhancedKeyUsage(
            pCert,
            CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
            pUsage,
            &cbUsage))
        goto GetEnhancedKeyUsageError;

CommonReturn:
    return pUsage;
ErrorReturn:
    if (pUsage) {
        PkiFree(pUsage);
        pUsage = NULL;
    }
    goto CommonReturn;

SET_ERROR(GetEnhancedKeyUsageError, CERT_E_WRONG_USAGE)
TRACE_ERROR(OutOfMemory)
}


//+-------------------------------------------------------------------------
//  The signature of the CTL is verified. The signer of the CTL is verified
//  up to a trusted root containing the predefined Microsoft public key.
//
//  The signer and intermediate certificates must have the
//  szOID_ROOT_LIST_SIGNER enhanced key usage extension.
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
VerifyAuthRootAutoUpdateCtlSigner(
    IN HCRYPTMSG hCryptMsg
    )
{
    BOOL fResult;
    DWORD dwLastError = 0;
    HCERTSTORE hMsgStore = NULL;
    PCCERT_CONTEXT pSignerCert = NULL;
    LPSTR pszUsageOID;
    CERT_CHAIN_PARA ChainPara;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    PCERT_SIMPLE_CHAIN pChain;
    DWORD cChainElement;
    CERT_CHAIN_POLICY_PARA BasePolicyPara;
    CERT_CHAIN_POLICY_STATUS BasePolicyStatus;
    CERT_CHAIN_POLICY_PARA MicrosoftRootPolicyPara;
    CERT_CHAIN_POLICY_STATUS MicrosoftRootPolicyStatus;
    PCERT_ENHKEY_USAGE pUsage = NULL;
    DWORD i;

    if (NULL == (hMsgStore = CertOpenStore(
            CERT_STORE_PROV_MSG,
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            0,                      // hCryptProv
            0,                      // dwFlags
            hCryptMsg               // pvPara
            )))
        goto OpenMsgStoreError;

    if (!CryptMsgGetAndVerifySigner(
            hCryptMsg,
            0,                      // cSignerStore
            NULL,                   // rghSignerStore
            0,                      // dwFlags
            &pSignerCert,
            NULL                    // pdwSignerIndex
            ))
        goto CryptMsgGetAndVerifySignerError;

    pszUsageOID = szOID_ROOT_LIST_SIGNER;
    memset(&ChainPara, 0, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);
    ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
    ChainPara.RequestedUsage.Usage.cUsageIdentifier = 1;
    ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = &pszUsageOID;

    if (!CertGetCertificateChain(
            NULL,                       // hChainEngine
            pSignerCert,
            NULL,                       // pTime
            hMsgStore,
            &ChainPara,
            CERT_CHAIN_DISABLE_AUTH_ROOT_AUTO_UPDATE,
            NULL,                       // pvReserved
            &pChainContext
            ))
        goto GetChainError;

    // Do the basic chain policy verification
    memset(&BasePolicyPara, 0, sizeof(BasePolicyPara));
    BasePolicyPara.cbSize = sizeof(BasePolicyPara);

    // We explicitly check for the Microsoft Root below. It doesn't need
    // to be in the root store.
    BasePolicyPara.dwFlags = 
        CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG |
        CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG;

    memset(&BasePolicyStatus, 0, sizeof(BasePolicyStatus));
    BasePolicyStatus.cbSize = sizeof(BasePolicyStatus);

    if (!CertVerifyCertificateChainPolicy(
            CERT_CHAIN_POLICY_BASE,
            pChainContext,
            &BasePolicyPara,
            &BasePolicyStatus
            ))
        goto VerifyChainBasePolicyError;
    if (0 != BasePolicyStatus.dwError)
        goto ChainBasePolicyError;

    // Check that we have more than just the signer cert.
    pChain = pChainContext->rgpChain[0];
    cChainElement = pChain->cElement;
    if (2 > cChainElement)
        goto MissingSignerChainCertsError;

    // Check that the top level certificate contains the public
    // key for the Microsoft root.
    memset(&MicrosoftRootPolicyPara, 0, sizeof(MicrosoftRootPolicyPara));
    MicrosoftRootPolicyPara.cbSize = sizeof(MicrosoftRootPolicyPara);
    memset(&MicrosoftRootPolicyStatus, 0, sizeof(MicrosoftRootPolicyStatus));
    MicrosoftRootPolicyStatus.cbSize = sizeof(MicrosoftRootPolicyStatus);

    if (!CertVerifyCertificateChainPolicy(
            CERT_CHAIN_POLICY_MICROSOFT_ROOT,
            pChainContext,
            &MicrosoftRootPolicyPara,
            &MicrosoftRootPolicyStatus
            ))
        goto VerifyChainMicrosoftRootPolicyError;
    if (0 != MicrosoftRootPolicyStatus.dwError)
        goto ChainMicrosoftRootPolicyError;


    // Check that the signer and intermediate certs have the RootListSigner
    // Usage extension
    for (i = 0; i < cChainElement - 1; i++) {
        PCCERT_CONTEXT pCert;   // not refCount'ed
        DWORD j;

        pCert = pChain->rgpElement[i]->pCertContext;

        pUsage = GetAndAllocCertEKUExt(pCert);
        if (NULL == pUsage)
            goto GetAndAllocCertEKUExtError;

        for (j = 0; j < pUsage->cUsageIdentifier; j++) {
            if (0 == strcmp(szOID_ROOT_LIST_SIGNER,
                    pUsage->rgpszUsageIdentifier[j]))
                break;
        }

        if (j == pUsage->cUsageIdentifier)
            goto MissingRootListSignerUsageError;

        PkiFree(pUsage);
        pUsage = NULL;
    }

    fResult = TRUE;
CommonReturn:
    if (pChainContext)
        CertFreeCertificateChain(pChainContext);
    if (pUsage)
        PkiFree(pUsage);

    if (pSignerCert)
        CertFreeCertificateContext(pSignerCert);

    if (hMsgStore)
        CertCloseStore(hMsgStore, 0);

    SetLastError(dwLastError);
    return fResult;
ErrorReturn:
    dwLastError = GetLastError();
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenMsgStoreError)
TRACE_ERROR(CryptMsgGetAndVerifySignerError)
TRACE_ERROR(GetChainError)
TRACE_ERROR(VerifyChainBasePolicyError)
SET_ERROR_VAR(ChainBasePolicyError, BasePolicyStatus.dwError)
TRACE_ERROR(VerifyChainMicrosoftRootPolicyError)
SET_ERROR_VAR(ChainMicrosoftRootPolicyError, MicrosoftRootPolicyStatus.dwError)
SET_ERROR(MissingSignerChainCertsError, CERT_E_CHAINING)
TRACE_ERROR(GetAndAllocCertEKUExtError)
SET_ERROR(MissingRootListSignerUsageError, CERT_E_WRONG_USAGE)
}

//+-------------------------------------------------------------------------
// Returns TRUE if all the CTL fields are valid. Checks for the following:
//  - The SubjectUsage is szOID_ROOT_LIST_SIGNER
//  - If NextUpdate isn't NULL, that the CTL is still time valid
//  - Only allow roots identified by their sha1 hash
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
VerifyAuthRootAutoUpdateCtlFields(
    IN PCTL_INFO pCtlInfo
    )
{
    BOOL fResult;

    // Must have the szOID_ROOT_LIST_SIGNER usage
    if (1 != pCtlInfo->SubjectUsage.cUsageIdentifier ||
            0 != strcmp(szOID_ROOT_LIST_SIGNER,
                    pCtlInfo->SubjectUsage.rgpszUsageIdentifier[0]))
        goto InvalidSubjectUsageError;


    // If NextUpdate is present, verify that the CTL hasn't expired.
    if (pCtlInfo->NextUpdate.dwLowDateTime ||
                pCtlInfo->NextUpdate.dwHighDateTime) {
        SYSTEMTIME SystemTime;
        FILETIME FileTime;

        GetSystemTime(&SystemTime);
        SystemTimeToFileTime(&SystemTime, &FileTime);

        if (CompareFileTime(&FileTime, &pCtlInfo->NextUpdate) > 0)
            goto ExpiredCtlError;
    }

    // Only allow roots identified by their sha1 hash
    if (0 != strcmp(szOID_OIWSEC_sha1,
            pCtlInfo->SubjectAlgorithm.pszObjId))
        goto InvalidSubjectAlgorithm;

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidSubjectUsageError, ERROR_INVALID_DATA)
SET_ERROR(ExpiredCtlError, CERT_E_EXPIRED)
SET_ERROR(InvalidSubjectAlgorithm, ERROR_INVALID_DATA)
}

//+-------------------------------------------------------------------------
// Returns TRUE if the CTL doesn't have any critical extensions.
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
VerifyAuthRootAutoUpdateCtlExtensions(
    IN PCTL_INFO pCtlInfo
    )
{
    BOOL fResult;
    PCERT_EXTENSION pExt;
    DWORD cExt;

    // Verify the extensions
    for (cExt = pCtlInfo->cExtension,
         pExt = pCtlInfo->rgExtension; 0 < cExt; cExt--, pExt++)
    {
        if (pExt->fCritical) {
            goto CriticalExtensionError;
        }
    }

    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(CriticalExtensionError, ERROR_INVALID_DATA)
}



//+-------------------------------------------------------------------------
//  Verifies that the CTL contains a valid list of AuthRoots used for
//  Auto Update.
//
//  The signature of the CTL is verified. The signer of the CTL is verified
//  up to a trusted root containing the predefined Microsoft public key.
//  The signer and intermediate certificates must have the
//  szOID_ROOT_LIST_SIGNER enhanced key usage extension.
//
//  The CTL fields are validated as follows:
//   - The SubjectUsage is szOID_ROOT_LIST_SIGNER
//   - If NextUpdate isn't NULL, that the CTL is still time valid
//   - Only allow roots identified by their sha1 hash
//
//  If the CTL contains any critical extensions, then, the
//  CTL verification fails.
//--------------------------------------------------------------------------
BOOL
WINAPI
IRL_VerifyAuthRootAutoUpdateCtl(
    IN PCCTL_CONTEXT pCtl
    )
{
    BOOL fResult;
    PCTL_INFO pCtlInfo;                 // not allocated

    if (!VerifyAuthRootAutoUpdateCtlSigner(pCtl->hCryptMsg))
        goto VerifyCtlSignerError;

    pCtlInfo = pCtl->pCtlInfo;

    if (!VerifyAuthRootAutoUpdateCtlFields(pCtlInfo))
        goto VerifyCtlFieldsError;
    if (!VerifyAuthRootAutoUpdateCtlExtensions(pCtlInfo))
        goto VerifyCtlExtensionsError;

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(VerifyCtlSignerError)
TRACE_ERROR(VerifyCtlFieldsError)
TRACE_ERROR(VerifyCtlExtensionsError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\rootlist.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       rootlist.h
//
//  Contents:   Signed List of Trusted Roots Helper Functions
//
//  History:    01-Aug-99   philh   created
//--------------------------------------------------------------------------

#ifndef __ROOTLIST_H__
#define __ROOTLIST_H__

//+-------------------------------------------------------------------------
//  Verifies that the CTL contains a valid list of AuthRoots used for
//  Auto Update.
//
//  The signature of the CTL is verified. The signer of the CTL is verified
//  up to a trusted root containing the predefined Microsoft public key.
//  The signer and intermediate certificates must have the
//  szOID_ROOT_LIST_SIGNER enhanced key usage extension.
//
//  The CTL fields are validated as follows:
//   - The SubjectUsage is szOID_ROOT_LIST_SIGNER
//   - If NextUpdate isn't NULL, that the CTL is still time valid
//   - Only allow roots identified by their sha1 hash
//
//  If the CTL contains any critical extensions, then, the
//  CTL verification fails.
//--------------------------------------------------------------------------
BOOL
WINAPI
IRL_VerifyAuthRootAutoUpdateCtl(
    IN PCCTL_CONTEXT pCtl
    );

#endif  // __ROOTLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\sca.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       sca.cpp
//
//  Contents:   Simplified Cryptographic APIs (SCA)
//
//              This implementation layers upon the CryptMsg and CertStore
//              APIs.
//
//  Functions:
//              CryptSignMessage
//              CryptVerifyMessageSignature
//              CryptVerifyDetachedMessageSignature
//              CryptGetMessageSignerCount
//              CryptGetMessageCertificates
//              CryptDecodeMessage
//              CryptEncryptMessage
//              CryptDecryptMessage
//              CryptSignAndEncryptMessage
//              CryptDecryptAndVerifyMessageSignature
//              CryptHashMessage
//              CryptVerifyMessageHash
//              CryptVerifyDetachedMessageHash
//              CryptSignMessageWithKey
//              CryptVerifyMessageSignatureWithKey
//
//  History:    14-Feb-96   philh   created
//              21-Feb-96   phil    redid to reflect changes made to sca.h
//              19-Jan-97   philh   removed SET stuff
//              
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

// #define ENABLE_SCA_STREAM_TEST              1
#define SCA_STREAM_ENABLE_FLAG              0x80000000
#define SCA_INDEFINITE_STREAM_FLAG          0x40000000

static const CRYPT_OBJID_TABLE MsgTypeObjIdTable[] = {
    CMSG_DATA,                  szOID_RSA_data              ,
    CMSG_SIGNED,                szOID_RSA_signedData        ,
    CMSG_ENVELOPED,             szOID_RSA_envelopedData     ,
    CMSG_SIGNED_AND_ENVELOPED,  szOID_RSA_signEnvData       ,
    CMSG_HASHED,                szOID_RSA_digestedData      ,
    CMSG_ENCRYPTED,             szOID_RSA_encryptedData
};
#define MSG_TYPE_OBJID_CNT (sizeof(MsgTypeObjIdTable)/sizeof(MsgTypeObjIdTable[0]))


//+-------------------------------------------------------------------------
//  Convert the MsgType to the ASN.1 Object Identifier string
//
//  Returns NULL if there isn't an ObjId corresponding to the MsgType.
//--------------------------------------------------------------------------
static LPCSTR MsgTypeToOID(
    IN DWORD dwMsgType
    )
{

    int i;
    for (i = 0; i < MSG_TYPE_OBJID_CNT; i++)
        if (MsgTypeObjIdTable[i].dwAlgId == dwMsgType)
            return MsgTypeObjIdTable[i].pszObjId;
    return NULL;
}

//+-------------------------------------------------------------------------
//  Convert the ASN.1 Object Identifier string to the MsgType
//
//  Returns 0 if there isn't a MsgType corresponding to the ObjId.
//--------------------------------------------------------------------------
static DWORD OIDToMsgType(
    IN LPCSTR pszObjId
    )
{
    int i;
    for (i = 0; i < MSG_TYPE_OBJID_CNT; i++)
        if (_stricmp(pszObjId, MsgTypeObjIdTable[i].pszObjId) == 0)
            return MsgTypeObjIdTable[i].dwAlgId;
    return 0;
}

//+-------------------------------------------------------------------------
//  SCA allocation and free routines
//--------------------------------------------------------------------------
static void *SCAAlloc(
    IN size_t cbBytes
    );
static void SCAFree(
    IN void *pv
    );

//+-------------------------------------------------------------------------
//  Null implementation of the get signer certificate
//--------------------------------------------------------------------------
static PCCERT_CONTEXT WINAPI NullGetSignerCertificate(
    IN void *pvGetArg,
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pSignerId,
    IN HCERTSTORE hMsgCertStore
    );

//+-------------------------------------------------------------------------
//  Functions for initializing message encode information
//--------------------------------------------------------------------------
static PCMSG_SIGNER_ENCODE_INFO InitSignerEncodeInfo(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara
    );
static void FreeSignerEncodeInfo(
    IN PCMSG_SIGNER_ENCODE_INFO pSigner
    );
static BOOL InitSignedCertAndCrl(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    OUT PCERT_BLOB *ppCertEncoded,
    OUT PCRL_BLOB *ppCrlEncoded
    );
static void FreeSignedCertAndCrl(
    IN PCERT_BLOB pCertEncoded,
    IN PCRL_BLOB pCrlEncoded
    );

static BOOL InitSignedMsgEncodeInfo(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    OUT PCMSG_SIGNED_ENCODE_INFO pSignedMsgEncodeInfo
    );
static void FreeSignedMsgEncodeInfo(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    IN PCMSG_SIGNED_ENCODE_INFO pSignedMsgEncodeInfo
    );


#ifdef CMS_PKCS7
// Returned array of CMSG_RECIPIENT_ENCODE_INFOs needs to be SCAFree'd
static PCMSG_RECIPIENT_ENCODE_INFO InitCmsRecipientEncodeInfo(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[],
    IN DWORD dwFlags
    );
#else
// Returned array of PCERT_INFOs needs to be SCAFree'd
static PCERT_INFO *InitRecipientEncodeInfo(
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[]
    );
#endif  // CMS_PKCS7

static BOOL InitEnvelopedMsgEncodeInfo(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[],
    OUT PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedMsgEncodeInfo
    );
static void FreeEnvelopedMsgEncodeInfo(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedMsgEncodeInfo
    );

//+-------------------------------------------------------------------------
//  Encodes the message.
//--------------------------------------------------------------------------
static BOOL EncodeMsg(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN void *pvMsgEncodeInfo,
    IN DWORD cToBeEncoded,
    IN const BYTE *rgpbToBeEncoded[],
    IN DWORD rgcbToBeEncoded[],
    IN BOOL fBareContent,
    IN DWORD dwInnerContentType,
    OUT BYTE *pbEncodedBlob,
    IN OUT DWORD *pcbEncodedBlob
    );

//+-------------------------------------------------------------------------
//  Decodes the message types:
//      CMSG_SIGNED
//      CMSG_ENVELOPED
//      CMSG_SIGNED_AND_ENVELOPED
//      CMSG_HASHED
//--------------------------------------------------------------------------
static BOOL DecodeMsg(
    IN DWORD dwMsgTypeFlags,
    IN OPTIONAL PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN OPTIONAL PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN const BYTE *pbEncodedBlob,
    IN DWORD cbEncodedBlob,
    IN DWORD cToBeEncoded,
    IN OPTIONAL const BYTE *rgpbToBeEncoded[],
    IN OPTIONAL DWORD rgcbToBeEncoded[],
    IN DWORD dwPrevInnerContentType,
    OUT OPTIONAL DWORD *pdwMsgType,
    OUT OPTIONAL DWORD *pdwInnerContentType,
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    );

#ifdef ENABLE_SCA_STREAM_TEST
//+-------------------------------------------------------------------------
//  Encodes the message using streaming.
//--------------------------------------------------------------------------
static BOOL StreamEncodeMsg(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN void *pvMsgEncodeInfo,
    IN DWORD cToBeEncoded,
    IN const BYTE *rgpbToBeEncoded[],
    IN DWORD rgcbToBeEncoded[],
    IN BOOL fBareContent,
    IN DWORD dwInnerContentType,
    OUT BYTE *pbEncodedBlob,
    IN OUT DWORD *pcbEncodedBlob
    );

//+-------------------------------------------------------------------------
//  Decodes the message types:
//      CMSG_SIGNED
//      CMSG_ENVELOPED
//      CMSG_SIGNED_AND_ENVELOPED
//      CMSG_HASHED
//
//  Uses streaming.
//--------------------------------------------------------------------------
static BOOL StreamDecodeMsg(
    IN DWORD dwMsgTypeFlags,
    IN OPTIONAL PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN OPTIONAL PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN const BYTE *pbEncodedBlob,
    IN DWORD cbEncodedBlob,
    IN DWORD cToBeEncoded,
    IN OPTIONAL const BYTE *rgpbToBeEncoded[],
    IN OPTIONAL DWORD rgcbToBeEncoded[],
    IN DWORD dwPrevInnerContentType,
    OUT OPTIONAL DWORD *pdwMsgType,
    OUT OPTIONAL DWORD *pdwInnerContentType,
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    );
#endif

//+-------------------------------------------------------------------------
//  Decodes the HASHED message type
//--------------------------------------------------------------------------
static BOOL DecodeHashMsg(
    IN PCRYPT_HASH_MESSAGE_PARA pHashPara,
    IN const BYTE *pbEncodedBlob,
    IN DWORD cbEncodedBlob,
    IN DWORD cToBeHashed,
    IN OPTIONAL const BYTE *rgpbToBeHashed[],
    IN OPTIONAL DWORD rgcbToBeHashed[],
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded,
    OUT OPTIONAL BYTE *pbComputedHash,
    IN OUT OPTIONAL DWORD *pcbComputedHash
    );

//+-------------------------------------------------------------------------
//  Get certificate for and verify the message's signer.
//--------------------------------------------------------------------------
static BOOL GetSignerCertAndVerify(
    IN PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN HCRYPTMSG hMsg,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    );
//+-------------------------------------------------------------------------
// Get a certificate with a key provider property for one of the message's
// recipients and use to decrypt the message.
//--------------------------------------------------------------------------
static BOOL GetXchgCertAndDecrypt(
    IN PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN HCRYPTMSG hMsg,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert
    );
//+-------------------------------------------------------------------------
// Allocate and get message parameter
//--------------------------------------------------------------------------
static void * AllocAndMsgGetParam(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex
    );

//+-------------------------------------------------------------------------
//  Sign the message.
//
//  If fDetachedSignature is TRUE, the "to be signed" content isn't included
//  in the encoded signed blob.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptSignMessage(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    IN BOOL fDetachedSignature,
    IN DWORD cToBeSigned,
    IN const BYTE *rgpbToBeSigned[],
    IN DWORD rgcbToBeSigned[],
    OUT BYTE *pbSignedBlob,
    IN OUT DWORD *pcbSignedBlob
    )
{
    BOOL fResult;
    CMSG_SIGNED_ENCODE_INFO SignedMsgEncodeInfo;

    fResult = InitSignedMsgEncodeInfo(
        pSignPara,
        &SignedMsgEncodeInfo
        );
    if (fResult) {
        BOOL fBareContent;
        DWORD dwInnerContentType;
        DWORD dwFlags = 0;

        if (fDetachedSignature)
            dwFlags |= CMSG_DETACHED_FLAG;

        if (pSignPara->cbSize >= STRUCT_CBSIZE(CRYPT_SIGN_MESSAGE_PARA,
                dwInnerContentType)) {
            fBareContent =
                pSignPara->dwFlags & CRYPT_MESSAGE_BARE_CONTENT_OUT_FLAG;
            dwInnerContentType =
                pSignPara->dwInnerContentType;
#ifdef CMS_PKCS7
            if (pSignPara->dwFlags &
                    CRYPT_MESSAGE_ENCAPSULATED_CONTENT_OUT_FLAG)
                dwFlags |= CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
#endif  // CMS_PKCS7
        } else {
            fBareContent = FALSE;
            dwInnerContentType = 0;
        }
#ifdef ENABLE_SCA_STREAM_TEST
        if (pSignPara->cbSize >= STRUCT_CBSIZE(CRYPT_SIGN_MESSAGE_PARA,
                    dwFlags) &&
                (pSignPara->dwFlags & SCA_STREAM_ENABLE_FLAG)) {
            dwFlags |= pSignPara->dwFlags & SCA_INDEFINITE_STREAM_FLAG;

            fResult = StreamEncodeMsg(
                pSignPara->dwMsgEncodingType,
                dwFlags,
                CMSG_SIGNED,
                &SignedMsgEncodeInfo,
                cToBeSigned,
                rgpbToBeSigned,
                rgcbToBeSigned,
                fBareContent,
                dwInnerContentType,
                pbSignedBlob,
                pcbSignedBlob
                );
        } else
#endif
        fResult = EncodeMsg(
            pSignPara->dwMsgEncodingType,
            dwFlags,
            CMSG_SIGNED,
            &SignedMsgEncodeInfo,
            cToBeSigned,
            rgpbToBeSigned,
            rgcbToBeSigned,
            fBareContent,
            dwInnerContentType,
            pbSignedBlob,
            pcbSignedBlob
            );
        FreeSignedMsgEncodeInfo(pSignPara, &SignedMsgEncodeInfo);
    } else
        *pcbSignedBlob = 0;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Verify a signed message.
//
//  For *pcbDecoded == 0 on input, the signer isn't verified.
//
//  A message might have more than one signer. Set dwSignerIndex to iterate
//  through all the signers. dwSignerIndex == 0 selects the first signer.
//
//  pVerifyPara's pfnGetSignerCertificate is called to get the signer's
//  certificate.
//
//  For a verified signer and message, *ppSignerCert is updated
//  with the CertContext of the signer. It must be freed by calling
//  CertFreeCertificateContext. Otherwise, *ppSignerCert is set to NULL.
//  For *pbcbDecoded == 0 on input, *ppSignerCert is always set to
//  NULL.
//
//  ppSignerCert can be NULL, indicating the caller isn't interested
//  in getting the CertContext of the signer.
//
//  pcbDecoded can be NULL, indicating the caller isn't interested in getting
//  the decoded content. Furthermore, if the message doesn't contain any
//  content or signers, then, pcbDecoded must be set to NULL, to allow the
//  pVerifyPara->pfnGetSignerCertificate to be called. Normally, this would be
//  the case when the signed message contains only certficates and CRLs.
//  If pcbDecoded is NULL and the message doesn't have the indicated signer,
//  pfnGetSignerCertificate is called with pSignerId set to NULL.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptVerifyMessageSignature(
    IN PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN const BYTE *pbSignedBlob,
    IN DWORD cbSignedBlob,
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    )
{
#ifdef ENABLE_SCA_STREAM_TEST
    if (pVerifyPara->dwMsgAndCertEncodingType & SCA_STREAM_ENABLE_FLAG)
        return StreamDecodeMsg(
            CMSG_SIGNED_FLAG,
            NULL,               // pDecryptPara
            pVerifyPara,
            dwSignerIndex,
            pbSignedBlob,
            cbSignedBlob,
            0,                  // cToBeEncoded
            NULL,               // rgpbToBeEncoded
            NULL,               // rgcbToBeEncoded
            0,                  // dwPrevInnerContentType
            NULL,               // pdwMsgType
            NULL,               // pdwInnerContentType
            pbDecoded,
            pcbDecoded,
            NULL,               // ppXchgCert
            ppSignerCert
            );
    else
#endif
    return DecodeMsg(
        CMSG_SIGNED_FLAG,
        NULL,               // pDecryptPara
        pVerifyPara,
        dwSignerIndex,
        pbSignedBlob,
        cbSignedBlob,
        0,                  // cToBeEncoded
        NULL,               // rgpbToBeEncoded
        NULL,               // rgcbToBeEncoded
        0,                  // dwPrevInnerContentType
        NULL,               // pdwMsgType
        NULL,               // pdwInnerContentType
        pbDecoded,
        pcbDecoded,
        NULL,               // ppXchgCert
        ppSignerCert
        );
}

//+-------------------------------------------------------------------------
//  Verify a signed message containing detached signature(s).
//  The "to be signed" content is passed in separately. No
//  decoded output. Otherwise, identical to CryptVerifyMessageSignature.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptVerifyDetachedMessageSignature(
    IN PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN const BYTE *pbDetachedSignBlob,
    IN DWORD cbDetachedSignBlob,
    IN DWORD cToBeSigned,
    IN const BYTE *rgpbToBeSigned[],
    IN DWORD rgcbToBeSigned[],
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    )
{
#ifdef ENABLE_SCA_STREAM_TEST
    if (pVerifyPara->dwMsgAndCertEncodingType & SCA_STREAM_ENABLE_FLAG)
        return StreamDecodeMsg(
            CMSG_SIGNED_FLAG,
            NULL,               // pDecryptPara
            pVerifyPara,
            dwSignerIndex,
            pbDetachedSignBlob,
            cbDetachedSignBlob,
            cToBeSigned,
            rgpbToBeSigned,
            rgcbToBeSigned,
            0,                  // dwPrevInnerContentType
            NULL,               // pdwMsgType
            NULL,               // pdwInnerContentType
            NULL,               // pbDecoded
            NULL,               // pcbDecoded
            NULL,               // ppXchgCert
            ppSignerCert
            );
    else
#endif
    return DecodeMsg(
        CMSG_SIGNED_FLAG,
        NULL,               // pDecryptPara
        pVerifyPara,
        dwSignerIndex,
        pbDetachedSignBlob,
        cbDetachedSignBlob,
        cToBeSigned,
        rgpbToBeSigned,
        rgcbToBeSigned,
        0,                  // dwPrevInnerContentType
        NULL,               // pdwMsgType
        NULL,               // pdwInnerContentType
        NULL,               // pbDecoded
        NULL,               // pcbDecoded
        NULL,               // ppXchgCert
        ppSignerCert
        );
}

//+-------------------------------------------------------------------------
//  Returns the count of signers in the signed message. For no signers, returns
//  0. For an error returns -1 with LastError updated accordingly.
//--------------------------------------------------------------------------
LONG
WINAPI
CryptGetMessageSignerCount(
    IN DWORD dwMsgEncodingType,
    IN const BYTE *pbSignedBlob,
    IN DWORD cbSignedBlob
    )
{
    HCRYPTMSG hMsg = NULL;
    LONG lSignerCount;
    DWORD cbData;

    if (NULL == (hMsg = CryptMsgOpenToDecode(
            dwMsgEncodingType,
            0,                          // dwFlags
            0,                          // dwMsgType
            0,                          // hCryptProv,
            NULL,                       // pRecipientInfo
            NULL                        // pStreamInfo
            ))) goto ErrorReturn;
    if (!CryptMsgUpdate(
            hMsg,
            pbSignedBlob,
            cbSignedBlob,
            TRUE                    // fFinal
            )) goto ErrorReturn;

    lSignerCount = 0;
    cbData = sizeof(lSignerCount);
    if (!CryptMsgGetParam(
            hMsg,
            CMSG_SIGNER_COUNT_PARAM,
            0,                      // dwIndex
            &lSignerCount,
            &cbData
            )) goto ErrorReturn;

    goto CommonReturn;

ErrorReturn:
    lSignerCount = -1;
CommonReturn:
    if (hMsg)
        CryptMsgClose(hMsg);
    return lSignerCount;
}

//+-------------------------------------------------------------------------
//  Returns the cert store containing the message's certs and CRLs.
//  For an error, returns NULL with LastError updated.
//--------------------------------------------------------------------------
HCERTSTORE
WINAPI
CryptGetMessageCertificates(
    IN DWORD dwMsgAndCertEncodingType,
    IN HCRYPTPROV hCryptProv,           // passed to CertOpenStore
    IN DWORD dwFlags,                   // passed to CertOpenStore
    IN const BYTE *pbSignedBlob,
    IN DWORD cbSignedBlob
    )
{
    CRYPT_DATA_BLOB SignedBlob;
    SignedBlob.pbData = (BYTE *) pbSignedBlob;
    SignedBlob.cbData = cbSignedBlob;

    return CertOpenStore(
        CERT_STORE_PROV_PKCS7,
        dwMsgAndCertEncodingType,
        hCryptProv,
        dwFlags,
        (const void *) &SignedBlob
        );
}

//+-------------------------------------------------------------------------
//  Encrypts the message for the recipient(s).
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptEncryptMessage(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[],
    IN const BYTE *pbToBeEncrypted,
    IN DWORD cbToBeEncrypted,
    OUT BYTE *pbEncryptedBlob,
    IN OUT DWORD *pcbEncryptedBlob
    )
{
    BOOL fResult;
    CMSG_ENVELOPED_ENCODE_INFO EnvelopedMsgEncodeInfo;

    fResult = InitEnvelopedMsgEncodeInfo(
        pEncryptPara,
        cRecipientCert,
        rgpRecipientCert,
        &EnvelopedMsgEncodeInfo
        );
    if (fResult) {
        BOOL fBareContent;
        DWORD dwInnerContentType;
        DWORD dwFlags = 0;

        if (pEncryptPara->cbSize >= sizeof(CRYPT_ENCRYPT_MESSAGE_PARA)) {
            fBareContent =
                pEncryptPara->dwFlags & CRYPT_MESSAGE_BARE_CONTENT_OUT_FLAG;
            dwInnerContentType =
                pEncryptPara->dwInnerContentType;
#ifdef CMS_PKCS7
            if (pEncryptPara->dwFlags &
                    CRYPT_MESSAGE_ENCAPSULATED_CONTENT_OUT_FLAG)
                dwFlags |= CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
#endif  // CMS_PKCS7
        } else {
            fBareContent = FALSE;
            dwInnerContentType = 0;
        }

#ifdef ENABLE_SCA_STREAM_TEST
        if (pEncryptPara->cbSize >= STRUCT_CBSIZE(CRYPT_ENCRYPT_MESSAGE_PARA,
                    dwFlags) &&
                (pEncryptPara->dwFlags & SCA_STREAM_ENABLE_FLAG)) {
            dwFlags |= pEncryptPara->dwFlags & SCA_INDEFINITE_STREAM_FLAG;

            fResult = StreamEncodeMsg(
                pEncryptPara->dwMsgEncodingType,
                dwFlags,
                CMSG_ENVELOPED,
                &EnvelopedMsgEncodeInfo,
                1,                              // cToBeEncrypted
                &pbToBeEncrypted,
                &cbToBeEncrypted,
                fBareContent,
                dwInnerContentType,
                pbEncryptedBlob,
                pcbEncryptedBlob
                );
        } else
#endif
        fResult = EncodeMsg(
            pEncryptPara->dwMsgEncodingType,
            dwFlags,
            CMSG_ENVELOPED,
            &EnvelopedMsgEncodeInfo,
            1,                              // cToBeEncrypted
            &pbToBeEncrypted,
            &cbToBeEncrypted,
            fBareContent,
            dwInnerContentType,
            pbEncryptedBlob,
            pcbEncryptedBlob
            );
        FreeEnvelopedMsgEncodeInfo(pEncryptPara, &EnvelopedMsgEncodeInfo);
    } else
        *pcbEncryptedBlob = 0;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decrypts the message.
//
//  For *pcbDecrypted == 0 on input, the message isn't decrypted.
//
//  For a successfully decrypted message, *ppXchgCert is updated
//  with the CertContext used to decrypt. It must be freed by calling
//  CertFreeCertificateContext. Otherwise, *ppXchgCert is set to NULL.
//  For *pbcbDecrypted == 0 on input, *ppXchgCert is always set to
//  NULL.
//
//  ppXchgCert can be NULL, indicating the caller isn't interested
//  in getting the CertContext used to decrypt.
//
//  pcbDecrypted can be NULL, indicating the caller isn't interested in
//  getting the decrypted content. However, when pcbDecrypted is NULL,
//  the message is still decrypted.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptDecryptMessage(
    IN PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN const BYTE *pbEncryptedBlob,
    IN DWORD cbEncryptedBlob,
    OUT OPTIONAL BYTE *pbDecrypted,
    IN OUT OPTIONAL DWORD *pcbDecrypted,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert
    )
{
#ifdef ENABLE_SCA_STREAM_TEST
    if (pDecryptPara->dwMsgAndCertEncodingType & SCA_STREAM_ENABLE_FLAG)
        return StreamDecodeMsg(
            CMSG_ENVELOPED_FLAG,
            pDecryptPara,
            NULL,               // pVerifyPara
            0,                  // dwSignerIndex
            pbEncryptedBlob,
            cbEncryptedBlob,
            0,                  // cToBeEncoded
            NULL,               // rgpbToBeEncoded
            NULL,               // rgcbToBeEncoded
            0,                  // dwPrevInnerContentType
            NULL,               // pdwMsgType
            NULL,               // pdwInnerContentType
            pbDecrypted,
            pcbDecrypted,
            ppXchgCert,
            NULL                // ppSignerCert
            );
    else

#endif
    return DecodeMsg(
        CMSG_ENVELOPED_FLAG,
        pDecryptPara,
        NULL,               // pVerifyPara
        0,                  // dwSignerIndex
        pbEncryptedBlob,
        cbEncryptedBlob,
        0,                  // cToBeEncoded
        NULL,               // rgpbToBeEncoded
        NULL,               // rgcbToBeEncoded
        0,                  // dwPrevInnerContentType
        NULL,               // pdwMsgType
        NULL,               // pdwInnerContentType
        pbDecrypted,
        pcbDecrypted,
        ppXchgCert,
        NULL                // ppSignerCert
        );
}

//+-------------------------------------------------------------------------
//  Sign the message and encrypt for the recipient(s)
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptSignAndEncryptMessage(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[],
    IN const BYTE *pbToBeSignedAndEncrypted,
    IN DWORD cbToBeSignedAndEncrypted,
    OUT BYTE *pbSignedAndEncryptedBlob,
    IN OUT DWORD *pcbSignedAndEncryptedBlob
    )
{
#if 1
    BOOL fResult;
    DWORD cbSigned;
    DWORD cbSignedDelta = 0;
    BYTE *pbSigned = NULL;

    if (pbSignedAndEncryptedBlob == NULL)
        *pcbSignedAndEncryptedBlob = 0;

    cbSigned = 0;
    CryptSignMessage(
            pSignPara,
            FALSE,          // fDetachedSignature
            1,              // cToBeSigned
            &pbToBeSignedAndEncrypted,
            &cbToBeSignedAndEncrypted,
            NULL,           // pbSignedBlob
            &cbSigned
            );
    if (cbSigned == 0) goto ErrorReturn;
    if (*pcbSignedAndEncryptedBlob) {
        DWORD cbSignedMax;
        pbSigned = (BYTE *) SCAAlloc(cbSigned);
        if (pbSigned == NULL) goto ErrorReturn;
        cbSignedMax = cbSigned;
        if (!CryptSignMessage(
                pSignPara,
                FALSE,          // fDetachedSignature
                1,              // cToBeSigned
                &pbToBeSignedAndEncrypted,
                &cbToBeSignedAndEncrypted,
                pbSigned,
                &cbSigned
                )) goto ErrorReturn;

        if (cbSignedMax > cbSigned)
            // For DSS, the signature length varies since it consists of
            // a sequence of unsigned integers.
            cbSignedDelta = cbSignedMax - cbSigned;
    }

    fResult = CryptEncryptMessage(
            pEncryptPara,
            cRecipientCert,
            rgpRecipientCert,
            pbSigned,
            cbSigned,
            pbSignedAndEncryptedBlob,
            pcbSignedAndEncryptedBlob
            );
    if (!fResult && 0 != *pcbSignedAndEncryptedBlob)
        // Adjust if necessary for DSS signature length
        *pcbSignedAndEncryptedBlob += cbSignedDelta;
    goto CommonReturn;

ErrorReturn:
    *pcbSignedAndEncryptedBlob = 0;
    fResult = FALSE;
CommonReturn:
    if (pbSigned)
        SCAFree(pbSigned);
    return fResult;

#else
    BOOL fResult;
    CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO SignedAndEnvelopedMsgEncodeInfo;

    SignedAndEnvelopedMsgEncodeInfo.cbSize =
        sizeof(CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO);
    fResult = InitSignedMsgEncodeInfo(
        pSignPara,
        &SignedAndEnvelopedMsgEncodeInfo.SignedInfo
        );
    if (fResult) {
        fResult = InitEnvelopedMsgEncodeInfo(
            pEncryptPara,
            cRecipientCert,
            rgpRecipientCert,
            &SignedAndEnvelopedMsgEncodeInfo.EnvelopedInfo
            );
        if (fResult) {
            fResult = EncodeMsg(
                pSignPara->dwMsgEncodingType,
                CMSG_SIGNED_AND_ENVELOPED,
                &SignedAndEnvelopedMsgEncodeInfo,
                pbToBeSignedAndEncrypted,
                cbToBeSignedAndEncrypted,
                FALSE,                      // fBareContent
                0,                          // dwInnerContentType
                pbSignedAndEncryptedBlob,
                pcbSignedAndEncryptedBlob
                );
            FreeEnvelopedMsgEncodeInfo(pEncryptPara,
                &SignedAndEnvelopedMsgEncodeInfo.EnvelopedInfo);
        }
        FreeSignedMsgEncodeInfo(pSignPara,
            &SignedAndEnvelopedMsgEncodeInfo.SignedInfo);
    }
    return fResult;
#endif
}

//+-------------------------------------------------------------------------
//  Decrypts the message and verifies the signer.
//
//  For *pcbDecrypted == 0 on input, the message isn't decrypted and the
//  signer isn't verified.
//
//  A message might have more than one signer. Set dwSignerIndex to iterate
//  through all the signers. dwSignerIndex == 0 selects the first signer.
//
//  The hVerify's GetSignerCertificate is called to verify the signer's
//  certificate.
//
//  For a successfully decrypted and verified message, *ppXchgCert and
//  *ppSignerCert are updated. They must be freed by calling
//  CertFreeCertificateContext. Otherwise, they are set to NULL.
//  For *pbcbDecrypted == 0 on input, both are always set to NULL.
//
//  ppXchgCert and/or ppSignerCert can be NULL, indicating the
//  caller isn't interested in getting the CertContext.
//
//  pcbDecrypted can be NULL, indicating the caller isn't interested in
//  getting the decrypted content. However, when pcbDecrypted is NULL,
//  the message is still decrypted and verified.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptDecryptAndVerifyMessageSignature(
    IN PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN const BYTE *pbEncryptedBlob,
    IN DWORD cbEncryptedBlob,
    OUT OPTIONAL BYTE *pbDecrypted,
    IN OUT OPTIONAL DWORD *pcbDecrypted,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    )
{
#if 1
    BOOL fResult;
    DWORD cbSignedBlob;
    BYTE *pbSignedBlob = NULL;
    DWORD dwEnvelopeInnerContentType;

    if (ppXchgCert)
        *ppXchgCert = NULL;
    if (ppSignerCert)
        *ppSignerCert = NULL;

#ifdef ENABLE_SCA_STREAM_TEST
    if (pDecryptPara->dwMsgAndCertEncodingType & SCA_STREAM_ENABLE_FLAG) {
        cbSignedBlob = 0;
        StreamDecodeMsg(
                CMSG_ENVELOPED_FLAG,
                pDecryptPara,
                NULL,               // pVerifyPara
                0,                  // dwSignerIndex
                pbEncryptedBlob,
                cbEncryptedBlob,
                0,                  // cToBeEncoded
                NULL,               // rgpbToBeEncoded
                NULL,               // rgcbToBeEncoded
                0,                  // dwPrevInnerContentType
                NULL,               // pdwMsgType
                NULL,               // pdwInnerContentType
                NULL,               // pbDecrypted
                &cbSignedBlob,
                NULL,               // ppXchgCert
                NULL                // ppSignerCert
                );
        if (cbSignedBlob == 0) goto ErrorReturn;
        pbSignedBlob = (BYTE *) SCAAlloc(cbSignedBlob);
        if (pbSignedBlob == NULL) goto ErrorReturn;
        if (!StreamDecodeMsg(
                CMSG_ENVELOPED_FLAG,
                pDecryptPara,
                NULL,               // pVerifyPara
                0,                  // dwSignerIndex
                pbEncryptedBlob,
                cbEncryptedBlob,
                0,                  // cToBeEncoded
                NULL,               // rgpbToBeEncoded
                NULL,               // rgcbToBeEncoded
                0,                  // dwPrevInnerContentType
                NULL,               // pdwMsgType
                &dwEnvelopeInnerContentType,
                pbSignedBlob,
                &cbSignedBlob,
                ppXchgCert,
                NULL                // ppSignerCert
                )) goto ErrorReturn;
    } else {

#endif

    cbSignedBlob = 0;
    DecodeMsg(
            CMSG_ENVELOPED_FLAG,
            pDecryptPara,
            NULL,               // pVerifyPara
            0,                  // dwSignerIndex
            pbEncryptedBlob,
            cbEncryptedBlob,
            0,                  // cToBeEncoded
            NULL,               // rgpbToBeEncoded
            NULL,               // rgcbToBeEncoded
            0,                  // dwPrevInnerContentType
            NULL,               // pdwMsgType
            NULL,               // pdwInnerContentType
            NULL,               // pbDecrypted
            &cbSignedBlob,
            NULL,               // ppXchgCert
            NULL                // ppSignerCert
            );
    if (cbSignedBlob == 0) goto ErrorReturn;
    pbSignedBlob = (BYTE *) SCAAlloc(cbSignedBlob);
    if (pbSignedBlob == NULL) goto ErrorReturn;
    if (!DecodeMsg(
            CMSG_ENVELOPED_FLAG,
            pDecryptPara,
            NULL,               // pVerifyPara
            0,                  // dwSignerIndex
            pbEncryptedBlob,
            cbEncryptedBlob,
            0,                  // cToBeEncoded
            NULL,               // rgpbToBeEncoded
            NULL,               // rgcbToBeEncoded
            0,                  // dwPrevInnerContentType
            NULL,               // pdwMsgType
            &dwEnvelopeInnerContentType,
            pbSignedBlob,
            &cbSignedBlob,
            ppXchgCert,
            NULL                // ppSignerCert
            )) goto ErrorReturn;

#ifdef ENABLE_SCA_STREAM_TEST
    }
#endif

#ifdef ENABLE_SCA_STREAM_TEST
    if (pVerifyPara->dwMsgAndCertEncodingType & SCA_STREAM_ENABLE_FLAG)
        fResult = StreamDecodeMsg(
                CMSG_SIGNED_FLAG,
                NULL,               // pDecryptPara
                pVerifyPara,
                dwSignerIndex,
                pbSignedBlob,
                cbSignedBlob,
                0,                  // cToBeEncoded
                NULL,               // rgpbToBeEncoded
                NULL,               // rgcbToBeEncoded
                dwEnvelopeInnerContentType,
                NULL,               // pdwMsgType
                NULL,               // pdwInnerContentType
                pbDecrypted,
                pcbDecrypted,
                NULL,               // ppXchgCert
                ppSignerCert
                );
    else
#endif
    fResult = DecodeMsg(
            CMSG_SIGNED_FLAG,
            NULL,               // pDecryptPara
            pVerifyPara,
            dwSignerIndex,
            pbSignedBlob,
            cbSignedBlob,
            0,                  // cToBeEncoded
            NULL,               // rgpbToBeEncoded
            NULL,               // rgcbToBeEncoded
            dwEnvelopeInnerContentType,
            NULL,               // pdwMsgType
            NULL,               // pdwInnerContentType
            pbDecrypted,
            pcbDecrypted,
            NULL,               // ppXchgCert
            ppSignerCert
            );
    if (!fResult) goto VerifyError;
    goto CommonReturn;

ErrorReturn:
    if (pcbDecrypted)
        *pcbDecrypted = 0;
VerifyError:
    if (ppXchgCert && *ppXchgCert) {
        CertFreeCertificateContext(*ppXchgCert);
        *ppXchgCert = NULL;
    }
    if (ppSignerCert && *ppSignerCert) {
        CertFreeCertificateContext(*ppSignerCert);
        *ppSignerCert = NULL;
    }
    fResult = FALSE;
CommonReturn:
    if (pbSignedBlob)
        SCAFree(pbSignedBlob);
    return fResult;

#else
    // This needs to be updated if we switch back to this option
    return DecodeMsg(
        CMSG_SIGNED_AND_ENVELOPED_FLAG,
        pDecryptPara,
        pVerifyPara,
        dwSignerIndex,
        pbEncryptedBlob,
        cbEncryptedBlob,
        0,                  // dwPrevInnerContentType
        NULL,               // pdwMsgType
        NULL,               // pdwInnerContentType
        pbDecrypted,
        pcbDecrypted,
        ppXchgCert,
        ppSignerCert
        );
#endif
}


//+-------------------------------------------------------------------------
//  Get the hash length for the specified algorithm identifier.
//
//  Returns 0 for an unknown identifier.
//--------------------------------------------------------------------------
static DWORD GetComputedHashLength(PCRYPT_ALGORITHM_IDENTIFIER pAlgId)
{
    DWORD cbHash;
    DWORD dwAlgId;

    dwAlgId = CertOIDToAlgId(pAlgId->pszObjId);
    switch (dwAlgId) {
        case CALG_SHA:
            cbHash = 20;
            break;
        case CALG_MD2:
        case CALG_MD4:
        case CALG_MD5:
            cbHash = 16;
            break;
        default:
            cbHash = 0;
    }
    return cbHash;
}


//+-------------------------------------------------------------------------
//  Hash the message.
//
//  If fDetachedHash is TRUE, only the ComputedHash is encoded in the
//  pbHashedBlob. Otherwise, both the ToBeHashed and ComputedHash
//  are encoded.
//
//  pcbHashedBlob or pcbComputedHash can be NULL, indicating the caller
//  isn't interested in getting the output.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptHashMessage(
    IN PCRYPT_HASH_MESSAGE_PARA pHashPara,
    IN BOOL fDetachedHash,
    IN DWORD cToBeHashed,
    IN const BYTE *rgpbToBeHashed[],
    IN DWORD rgcbToBeHashed[],
    OUT OPTIONAL BYTE *pbHashedBlob,
    IN OUT OPTIONAL DWORD *pcbHashedBlob,
    OUT OPTIONAL BYTE *pbComputedHash,
    IN OUT OPTIONAL DWORD *pcbComputedHash
    )
{
    BOOL fResult;
    DWORD dwFlags = fDetachedHash ? CMSG_DETACHED_FLAG : 0;
    HCRYPTMSG hMsg = NULL;
    CMSG_HASHED_ENCODE_INFO HashedMsgEncodeInfo;
    DWORD cbHashedBlob;
    DWORD cbComputedHash;

    // Get input lengths and default return lengths to 0
    cbHashedBlob = 0;
    if (pcbHashedBlob) {
        if (pbHashedBlob)
            cbHashedBlob = *pcbHashedBlob;
        *pcbHashedBlob = 0;
    }
    cbComputedHash = 0;
    if (pcbComputedHash) {
        if (pbComputedHash)
            cbComputedHash = *pcbComputedHash;
        *pcbComputedHash = 0;
    }

    assert(pHashPara->cbSize == sizeof(CRYPT_HASH_MESSAGE_PARA));
    if (pHashPara->cbSize != sizeof(CRYPT_HASH_MESSAGE_PARA))
        goto InvalidArg;

    HashedMsgEncodeInfo.cbSize = sizeof(CMSG_HASHED_ENCODE_INFO);
    HashedMsgEncodeInfo.hCryptProv = pHashPara->hCryptProv;
    HashedMsgEncodeInfo.HashAlgorithm = pHashPara->HashAlgorithm;
    HashedMsgEncodeInfo.pvHashAuxInfo = pHashPara->pvHashAuxInfo;

    fResult = TRUE;
    if (0 == cbHashedBlob && 0 == cbComputedHash &&
            (NULL == pcbComputedHash ||
                0 != (*pcbComputedHash = GetComputedHashLength(
                    &pHashPara->HashAlgorithm)))) {
        // Length only

        if (pcbHashedBlob) {
            DWORD c;
            DWORD cbTotal = 0;
            DWORD *pcb;
            for (c = cToBeHashed, pcb = rgcbToBeHashed; c > 0; c--, pcb++)
                cbTotal += *pcb;

            if (0 == (*pcbHashedBlob = CryptMsgCalculateEncodedLength(
                    pHashPara->dwMsgEncodingType,
                    dwFlags,
                    CMSG_HASHED,
                    &HashedMsgEncodeInfo,
                    NULL,                   // pszInnerContentObjID
                    cbTotal
                    ))) goto CalculateEncodedLengthError;
            if (pbHashedBlob) goto LengthError;
        }

        if (pcbComputedHash && pbComputedHash)
            goto LengthError;

    } else {
        if (NULL == (hMsg = CryptMsgOpenToEncode(
                pHashPara->dwMsgEncodingType,
                dwFlags,
                CMSG_HASHED,
                &HashedMsgEncodeInfo,
                NULL,                   // pszInnerContentObjID
                NULL                    // pStreamInfo
                ))) goto OpenToEncodeError;

        if (0 == cToBeHashed) {
            if (!CryptMsgUpdate(
                    hMsg,
                    NULL,           // pbData
                    0,              // cbData
                    TRUE            // fFinal
                    )) goto UpdateError;
        } else {
            DWORD c;
            DWORD *pcb;
            const BYTE **ppb;
            for (c = cToBeHashed,
                 pcb = rgcbToBeHashed,
                 ppb = rgpbToBeHashed; c > 0; c--, pcb++, ppb++) {
                if (!CryptMsgUpdate(
                        hMsg,
                        *ppb,
                        *pcb,
                        c == 1                    // fFinal
                        )) goto UpdateError;
            }
        }

        if (pcbHashedBlob) {
            fResult = CryptMsgGetParam(
                hMsg,
                CMSG_CONTENT_PARAM,
                0,                      // dwIndex
                pbHashedBlob,
                &cbHashedBlob
                );
            *pcbHashedBlob = cbHashedBlob;
        }
        if (pcbComputedHash) {
            DWORD dwErr = 0;
            BOOL fResult2;
            if (!fResult)
                dwErr = GetLastError();
            fResult2 = CryptMsgGetParam(
                hMsg,
                CMSG_COMPUTED_HASH_PARAM,
                0,                      // dwIndex
                pbComputedHash,
                &cbComputedHash
                );
            *pcbComputedHash = cbComputedHash;
            if (!fResult2)
                fResult = FALSE;
            else if (!fResult)
                SetLastError(dwErr);
        }
        if (!fResult)
            goto ErrorReturn;     // NO_TRACE
    }

CommonReturn:
    if (hMsg)
        CryptMsgClose(hMsg);    // for success, preserves LastError
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(LengthError, ERROR_MORE_DATA)
TRACE_ERROR(CalculateEncodedLengthError)
TRACE_ERROR(OpenToEncodeError)
TRACE_ERROR(UpdateError)
}

//+-------------------------------------------------------------------------
//  Verify a hashed message.
//
//  pcbToBeHashed or pcbComputedHash can be NULL,
//  indicating the caller isn't interested in getting the output.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptVerifyMessageHash(
    IN PCRYPT_HASH_MESSAGE_PARA pHashPara,
    IN BYTE *pbHashedBlob,
    IN DWORD cbHashedBlob,
    OUT OPTIONAL BYTE *pbToBeHashed,
    IN OUT OPTIONAL DWORD *pcbToBeHashed,
    OUT OPTIONAL BYTE *pbComputedHash,
    IN OUT OPTIONAL DWORD *pcbComputedHash
    )
{
    return DecodeHashMsg(
        pHashPara,
        pbHashedBlob,
        cbHashedBlob,
        NULL,               // cToBeHashed
        NULL,               // rgpbToBeHashed
        NULL,               // rgcbToBeHashed
        pbToBeHashed,
        pcbToBeHashed,
        pbComputedHash,
        pcbComputedHash
        );
}

//+-------------------------------------------------------------------------
//  Verify a hashed message containing a detached hash.
//  The "to be hashed" content is passed in separately. No
//  decoded output. Otherwise, identical to CryptVerifyMessageHash.
//
//  pcbComputedHash can be NULL, indicating the caller isn't interested
//  in getting the output.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptVerifyDetachedMessageHash(
    IN PCRYPT_HASH_MESSAGE_PARA pHashPara,
    IN BYTE *pbDetachedHashBlob,
    IN DWORD cbDetachedHashBlob,
    IN DWORD cToBeHashed,
    IN const BYTE *rgpbToBeHashed[],
    IN DWORD rgcbToBeHashed[],
    OUT OPTIONAL BYTE *pbComputedHash,
    IN OUT OPTIONAL DWORD *pcbComputedHash
    )
{
    return DecodeHashMsg(
        pHashPara,
        pbDetachedHashBlob,
        cbDetachedHashBlob,
        cToBeHashed,
        rgpbToBeHashed,
        rgcbToBeHashed,
        NULL,               // pbDecoded
        NULL,               // pcbDecoded
        pbComputedHash,
        pcbComputedHash
        );
}

//+-------------------------------------------------------------------------
//  Decodes a cryptographic message which may be one of the following types:
//    CMSG_DATA
//    CMSG_SIGNED
//    CMSG_ENVELOPED
//    CMSG_SIGNED_AND_ENVELOPED
//    CMSG_HASHED
//
//  dwMsgTypeFlags specifies the set of allowable messages. For example, to
//  decode either SIGNED or ENVELOPED messages, set dwMsgTypeFlags to:
//      CMSG_SIGNED_FLAG | CMSG_ENVELOPED_FLAG.
//
//  dwProvInnerContentType is only applicable when processing nested
//  crytographic messages. When processing an outer crytographic message
//  it must be set to 0. When decoding a nested cryptographic message
//  its the dwInnerContentType returned by a previous CryptDecodeMessage
//  of the outer message. The InnerContentType can be any of the CMSG types,
//  for example, CMSG_DATA, CMSG_SIGNED, ...
//
//  The optional *pdwMsgType is updated with the type of message.
//
//  The optional *pdwInnerContentType is updated with the type of the inner
//  message. Unless there is cryptographic message nesting, CMSG_DATA
//  is returned.
//
//  For CMSG_DATA: returns decoded content.
//  For CMSG_SIGNED: same as CryptVerifyMessageSignature.
//  For CMSG_ENVELOPED: same as CryptDecryptMessage.
//  For CMSG_SIGNED_AND_ENVELOPED: same as CryptDecryptMessage plus
//      CryptVerifyMessageSignature.
//  For CMSG_HASHED: verifies the hash and returns decoded content.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptDecodeMessage(
    IN DWORD dwMsgTypeFlags,
    IN PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN const BYTE *pbEncodedBlob,
    IN DWORD cbEncodedBlob,
    IN DWORD dwPrevInnerContentType,
    OUT OPTIONAL DWORD *pdwMsgType,
    OUT OPTIONAL DWORD *pdwInnerContentType,
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    )
{
#ifdef ENABLE_SCA_STREAM_TEST
    if ((pVerifyPara &&
            (pVerifyPara->dwMsgAndCertEncodingType & SCA_STREAM_ENABLE_FLAG))
                    ||
        (pDecryptPara &&
            (pDecryptPara->dwMsgAndCertEncodingType & SCA_STREAM_ENABLE_FLAG)))
        return StreamDecodeMsg(
            dwMsgTypeFlags,
            pDecryptPara,
            pVerifyPara,
            dwSignerIndex,
            pbEncodedBlob,
            cbEncodedBlob,
            0,                  // cToBeEncoded
            NULL,               // rgpbToBeEncoded
            NULL,               // rgcbToBeEncoded
            dwPrevInnerContentType,
            pdwMsgType,
            pdwInnerContentType,
            pbDecoded,
            pcbDecoded,
            ppXchgCert,
            ppSignerCert
            );
    else
#endif
    return DecodeMsg(
        dwMsgTypeFlags,
        pDecryptPara,
        pVerifyPara,
        dwSignerIndex,
        pbEncodedBlob,
        cbEncodedBlob,
        0,                  // cToBeEncoded
        NULL,               // rgpbToBeEncoded
        NULL,               // rgcbToBeEncoded
        dwPrevInnerContentType,
        pdwMsgType,
        pdwInnerContentType,
        pbDecoded,
        pcbDecoded,
        ppXchgCert,
        ppSignerCert
        );
}


//+-------------------------------------------------------------------------
//  Sign the message using the provider's private key specified in the
//  parameters. A dummy SignerId is created and stored in the message.
//
//  Normally used until a certificate has been created for the key.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptSignMessageWithKey(
    IN PCRYPT_KEY_SIGN_MESSAGE_PARA pSignPara,
    IN const BYTE *pbToBeSigned,
    IN DWORD cbToBeSigned,
    OUT BYTE *pbSignedBlob,
    IN OUT DWORD *pcbSignedBlob
    )
{
    BOOL fResult;
    CMSG_SIGNED_ENCODE_INFO SignedMsgEncodeInfo;
    CMSG_SIGNER_ENCODE_INFO SignerEncodeInfo;
    CERT_INFO CertInfo;
    DWORD dwSerialNumber = 0x12345678;

#define NO_CERT_COMMON_NAME     "NO CERT SIGNATURE"
    CERT_RDN rgRDN[1];
    CERT_RDN_ATTR rgAttr[1];
    CERT_NAME_INFO NameInfo;
    BYTE *pbNameEncoded = NULL;
    DWORD cbNameEncoded;

    assert(pSignPara->cbSize >= offsetof(CRYPT_KEY_SIGN_MESSAGE_PARA,
        pvHashAuxInfo) + sizeof(pSignPara->pvHashAuxInfo));
    if (pSignPara->cbSize < offsetof(CRYPT_KEY_SIGN_MESSAGE_PARA,
            pvHashAuxInfo) + sizeof(pSignPara->pvHashAuxInfo))
        goto InvalidArg;

    // Create a dummy issuer name
    NameInfo.cRDN = 1;
    NameInfo.rgRDN = rgRDN;
    rgRDN[0].cRDNAttr = 1;
    rgRDN[0].rgRDNAttr = rgAttr;
    rgAttr[0].pszObjId = szOID_COMMON_NAME;
    rgAttr[0].dwValueType = CERT_RDN_PRINTABLE_STRING;
    rgAttr[0].Value.pbData = (BYTE *) NO_CERT_COMMON_NAME;
    rgAttr[0].Value.cbData = strlen(NO_CERT_COMMON_NAME);

    cbNameEncoded = 0;
    CryptEncodeObject(
        pSignPara->dwMsgAndCertEncodingType,
        X509_NAME,
        &NameInfo,
        NULL,                           // pbEncoded
        &cbNameEncoded
        );
    if (cbNameEncoded == 0) goto ErrorReturn;
    pbNameEncoded = (BYTE *) SCAAlloc(cbNameEncoded);
    if (pbNameEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            pSignPara->dwMsgAndCertEncodingType,
            X509_NAME,
            &NameInfo,
            pbNameEncoded,
            &cbNameEncoded
            )) goto ErrorReturn;

    // CertInfo needs to only be initialized with issuer, serial number
    // and public key algorithm
    memset(&CertInfo, 0, sizeof(CertInfo));
    CertInfo.Issuer.pbData = pbNameEncoded;
    CertInfo.Issuer.cbData = cbNameEncoded;
    CertInfo.SerialNumber.pbData = (BYTE *) &dwSerialNumber;
    CertInfo.SerialNumber.cbData = sizeof(dwSerialNumber);

    if (pSignPara->cbSize >= offsetof(CRYPT_KEY_SIGN_MESSAGE_PARA,
                PubKeyAlgorithm) + sizeof(pSignPara->PubKeyAlgorithm) &&
            pSignPara->PubKeyAlgorithm.pszObjId &&
            '\0' != *pSignPara->PubKeyAlgorithm.pszObjId)
        CertInfo.SubjectPublicKeyInfo.Algorithm = pSignPara->PubKeyAlgorithm;
    else
        CertInfo.SubjectPublicKeyInfo.Algorithm.pszObjId =
            CERT_DEFAULT_OID_PUBLIC_KEY_SIGN;

    memset(&SignerEncodeInfo, 0, sizeof(SignerEncodeInfo));
    SignerEncodeInfo.cbSize = sizeof(SignerEncodeInfo);
    SignerEncodeInfo.pCertInfo = &CertInfo;
    SignerEncodeInfo.hCryptProv = pSignPara->hCryptProv;
    SignerEncodeInfo.dwKeySpec = pSignPara->dwKeySpec;
    SignerEncodeInfo.HashAlgorithm = pSignPara->HashAlgorithm;
    SignerEncodeInfo.pvHashAuxInfo = pSignPara->pvHashAuxInfo;

    memset(&SignedMsgEncodeInfo, 0, sizeof(SignedMsgEncodeInfo));
    SignedMsgEncodeInfo.cbSize = sizeof(SignedMsgEncodeInfo);
    SignedMsgEncodeInfo.cSigners = 1;
    SignedMsgEncodeInfo.rgSigners = &SignerEncodeInfo;

    fResult = EncodeMsg(
        pSignPara->dwMsgAndCertEncodingType,
        0,                              // dwFlags
        CMSG_SIGNED,
        &SignedMsgEncodeInfo,
        1,                              // cToBeSigned
        &pbToBeSigned,
        &cbToBeSigned,
        FALSE,                          // fBareContent
        0,                              // dwInnerContentType
        pbSignedBlob,
        pcbSignedBlob
        );
    goto CommonReturn;

InvalidArg:
    SetLastError((DWORD) E_INVALIDARG);
ErrorReturn:
    fResult = FALSE;
    *pcbSignedBlob = 0;
CommonReturn:
    if (pbNameEncoded)
        SCAFree(pbNameEncoded);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Verify a signed message using the specified public key info.
//
//  Normally called by a CA until it has created a certificate for the
//  key.
//
//  pPublicKeyInfo contains the public key to use to verify the signed
//  message. If NULL, the signature isn't verified (for instance, the decoded
//  content may contain the PublicKeyInfo).
//
//  pcbDecoded can be NULL, indicating the caller isn't interested
//  in getting the decoded content.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptVerifyMessageSignatureWithKey(
    IN PCRYPT_KEY_VERIFY_MESSAGE_PARA pVerifyPara,
    IN OPTIONAL PCERT_PUBLIC_KEY_INFO pPublicKeyInfo,
    IN const BYTE *pbSignedBlob,
    IN DWORD cbSignedBlob,
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded
    )
{
    BOOL fResult = TRUE;
    HCRYPTMSG hMsg = NULL;
    PCERT_INFO pCertInfo = NULL;
    DWORD cbData;
    DWORD dwMsgType;
    DWORD dwFlags;

    assert(pVerifyPara->cbSize == sizeof(CRYPT_KEY_VERIFY_MESSAGE_PARA));
    if (pVerifyPara->cbSize != sizeof(CRYPT_KEY_VERIFY_MESSAGE_PARA))
        goto InvalidArg;

    if (pbDecoded == NULL && pcbDecoded)
        *pcbDecoded = 0;

    if (pcbDecoded && *pcbDecoded == 0 && pPublicKeyInfo == NULL)
        dwFlags = CMSG_LENGTH_ONLY_FLAG;
    else
        dwFlags = 0;

    hMsg = CryptMsgOpenToDecode(
        pVerifyPara->dwMsgEncodingType,
        dwFlags,
        0,                          // dwMsgType
        pVerifyPara->hCryptProv,
        NULL,                       // pRecipientInfo
        NULL                        // pStreamInfo
        );
    if (hMsg == NULL) goto ErrorReturn;

    fResult = CryptMsgUpdate(
        hMsg,
        pbSignedBlob,
        cbSignedBlob,
        TRUE                    // fFinal
        );
    if (!fResult) goto ErrorReturn;

    cbData = sizeof(dwMsgType);
    dwMsgType = 0;
    fResult = CryptMsgGetParam(
        hMsg,
        CMSG_TYPE_PARAM,
        0,                  // dwIndex
        &dwMsgType,
        &cbData
        );
    if (!fResult) goto ErrorReturn;
    if (dwMsgType != CMSG_SIGNED)
    {
        SetLastError((DWORD) CRYPT_E_UNEXPECTED_MSG_TYPE);
        goto ErrorReturn;
    }

    if (pPublicKeyInfo) {
        // Allocate and get the CERT_INFO containing the SignerId 
        // (Issuer and SerialNumber)
        pCertInfo = (PCERT_INFO) AllocAndMsgGetParam(
            hMsg,
            CMSG_SIGNER_CERT_INFO_PARAM,
            0                           // dwSignerIndex
            );
        if (pCertInfo == NULL) goto ErrorReturn;

        pCertInfo->SubjectPublicKeyInfo = *pPublicKeyInfo;

        fResult = CryptMsgControl(
            hMsg,
            0,                  // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE,
            pCertInfo
            );
        if (!fResult)  goto ErrorReturn;
    }

    if (pcbDecoded) {
        fResult = CryptMsgGetParam(
            hMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            pbDecoded,
            pcbDecoded
            );
    }
    goto CommonReturn;

InvalidArg:
    SetLastError((DWORD) E_INVALIDARG);
ErrorReturn:
    if (pcbDecoded)
        *pcbDecoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pCertInfo)
        SCAFree(pCertInfo);
    if (hMsg)
        CryptMsgClose(hMsg);    // for success, preserves LastError
    return fResult;
}

//+-------------------------------------------------------------------------
//  SCA allocation and free routines
//--------------------------------------------------------------------------
static void *SCAAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}
static void SCAFree(
    IN void *pv
    )
{
    if (pv)
        free(pv);
}

//+-------------------------------------------------------------------------
//  Null implementation of the callback get and verify signer certificate
//--------------------------------------------------------------------------
static PCCERT_CONTEXT WINAPI NullGetSignerCertificate(
    IN void *pvGetArg,
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pSignerId,    // Only the Issuer and SerialNumber
                                // fields are used
    IN HCERTSTORE hMsgCertStore
    )
{
    return CertGetSubjectCertificateFromStore(hMsgCertStore, dwCertEncodingType,
        pSignerId);
}


//+-------------------------------------------------------------------------
//  Functions for initializing message encode information
//--------------------------------------------------------------------------

static PCMSG_SIGNER_ENCODE_INFO InitSignerEncodeInfo(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara
    )
{
    BOOL fResult;
    PCMSG_SIGNER_ENCODE_INFO pSigner = NULL;
    BOOL *pfDidCryptAcquire;
    DWORD cbSigner;
#ifdef CMS_PKCS7
    BYTE *pbHash;                   // not allocated
#endif  // CMS_PKCS7
    DWORD dwAcquireFlags;

    if (pSignPara->pSigningCert == NULL)
        return NULL;

    // The flag indicating we did a CryptAcquireContext
    // follows the CMSG_SIGNER_ENCODE_INFO. If set, the HCRYPTPROV will need to be
    // released when SignerEncodeInfo is freed.
    cbSigner = sizeof(CMSG_SIGNER_ENCODE_INFO) + sizeof(BOOL);
#ifdef CMS_PKCS7
    if (pSignPara->dwFlags & CRYPT_MESSAGE_KEYID_SIGNER_FLAG)
        cbSigner += MAX_HASH_LEN;
#endif  // CMS_PKCS7
    pSigner = (PCMSG_SIGNER_ENCODE_INFO) SCAAlloc(cbSigner);
    if (pSigner == NULL) goto ErrorReturn;
    memset(pSigner, 0, cbSigner);
    pSigner->cbSize = sizeof(CMSG_SIGNER_ENCODE_INFO);

    pfDidCryptAcquire =
        (BOOL *) (((BYTE *) pSigner) + sizeof(CMSG_SIGNER_ENCODE_INFO));

    pSigner->pCertInfo = pSignPara->pSigningCert->pCertInfo;
    pSigner->HashAlgorithm = pSignPara->HashAlgorithm;
    pSigner->pvHashAuxInfo = pSignPara->pvHashAuxInfo;

    dwAcquireFlags = CRYPT_ACQUIRE_USE_PROV_INFO_FLAG;
    if (pSignPara->dwFlags & CRYPT_MESSAGE_SILENT_KEYSET_FLAG)
        dwAcquireFlags |= CRYPT_ACQUIRE_SILENT_FLAG;
    fResult = CryptAcquireCertificatePrivateKey(
        pSignPara->pSigningCert,
        dwAcquireFlags,
        NULL,                               // pvReserved
        &pSigner->hCryptProv,
        &pSigner->dwKeySpec,
        pfDidCryptAcquire
        );
    if (!fResult) goto ErrorReturn;

    if (pSignPara->cbSize >= STRUCT_CBSIZE(CRYPT_SIGN_MESSAGE_PARA,
            rgUnauthAttr)) {
    	pSigner->cAuthAttr      = pSignPara->cAuthAttr;
    	pSigner->rgAuthAttr 	= pSignPara->rgAuthAttr;
    	pSigner->cUnauthAttr 	= pSignPara->cUnauthAttr;
    	pSigner->rgUnauthAttr 	= pSignPara->rgUnauthAttr;
    }

#ifdef CMS_PKCS7
    if (pSignPara->dwFlags & CRYPT_MESSAGE_KEYID_SIGNER_FLAG) {
        pbHash = (BYTE *) pfDidCryptAcquire + sizeof(*pfDidCryptAcquire);

        pSigner->SignerId.dwIdChoice = CERT_ID_KEY_IDENTIFIER;
        pSigner->SignerId.KeyId.pbData = pbHash;
        pSigner->SignerId.KeyId.cbData = MAX_HASH_LEN;

        if (!CertGetCertificateContextProperty(
                pSignPara->pSigningCert,
                CERT_KEY_IDENTIFIER_PROP_ID,
                pbHash,
                &pSigner->SignerId.KeyId.cbData
                ))
            goto ErrorReturn;
    }

    if (pSignPara->cbSize >= STRUCT_CBSIZE(CRYPT_SIGN_MESSAGE_PARA,
            pvHashEncryptionAuxInfo)) {
    	pSigner->HashEncryptionAlgorithm = pSignPara->HashEncryptionAlgorithm;
    	pSigner->pvHashEncryptionAuxInfo = pSignPara->pvHashEncryptionAuxInfo;
    }
#endif  // CMS_PKCS7
    
    goto CommonReturn;

ErrorReturn:
    if (pSigner) {
        FreeSignerEncodeInfo(pSigner);
        pSigner = NULL;
    }

CommonReturn:
    return pSigner;
}

static void FreeSignerEncodeInfo(
    IN PCMSG_SIGNER_ENCODE_INFO pSigner
    )
{
    BOOL *pfDidCryptAcquire;

    if (pSigner == NULL)
        return;

    // The flag indicating we did a CryptAcquireContext
    // follows the CMSG_SIGNER_ENCODE_INFO.
    pfDidCryptAcquire =
        (BOOL *) (((BYTE *) pSigner) + sizeof(CMSG_SIGNER_ENCODE_INFO));
    if (*pfDidCryptAcquire) {
        DWORD dwErr = GetLastError();
        CryptReleaseContext(pSigner->hCryptProv, 0);
        SetLastError(dwErr);
    }
    
    SCAFree(pSigner);
}

static BOOL InitSignedCertAndCrl(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    OUT PCERT_BLOB *ppCertEncoded,
    OUT PCRL_BLOB *ppCrlEncoded
    )
{
    PCERT_BLOB pCertEncoded = NULL;
    PCRL_BLOB pCrlEncoded = NULL;
    DWORD cMsgCert = pSignPara->cMsgCert;
    DWORD cMsgCrl = pSignPara->cMsgCrl;

    BOOL fResult;
    DWORD dwIdx;

    if (cMsgCert) {
        pCertEncoded = (PCERT_BLOB) SCAAlloc(sizeof(CERT_BLOB) * cMsgCert);
        if (pCertEncoded == NULL) goto ErrorReturn;
        for (dwIdx = 0; dwIdx < cMsgCert; dwIdx++) {
            pCertEncoded[dwIdx].pbData = pSignPara->rgpMsgCert[dwIdx]->pbCertEncoded;
            pCertEncoded[dwIdx].cbData = pSignPara->rgpMsgCert[dwIdx]->cbCertEncoded;
        }
    }

    if (cMsgCrl) {
        pCrlEncoded = (PCRL_BLOB) SCAAlloc(sizeof(CRL_BLOB) * cMsgCrl);
        if (pCrlEncoded == NULL) goto ErrorReturn;
        for (dwIdx = 0; dwIdx < cMsgCrl; dwIdx++) {
            pCrlEncoded[dwIdx].pbData = pSignPara->rgpMsgCrl[dwIdx]->pbCrlEncoded;
            pCrlEncoded[dwIdx].cbData = pSignPara->rgpMsgCrl[dwIdx]->cbCrlEncoded;
        }
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    FreeSignedCertAndCrl(pCertEncoded, pCrlEncoded);
    pCertEncoded = NULL;
    pCrlEncoded = NULL;
    fResult = FALSE;
CommonReturn:
    *ppCertEncoded = pCertEncoded;
    *ppCrlEncoded = pCrlEncoded;
    return fResult;
}

static void FreeSignedCertAndCrl(
    IN PCERT_BLOB pCertEncoded,
    IN PCRL_BLOB pCrlEncoded
    )
{
    if (pCertEncoded)
        SCAFree(pCertEncoded);
    if (pCrlEncoded)
        SCAFree(pCrlEncoded);
}

static BOOL InitSignedMsgEncodeInfo(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    OUT PCMSG_SIGNED_ENCODE_INFO pSignedMsgEncodeInfo
    )
{
    BOOL fResult = FALSE;

    assert(pSignPara->cbSize >=
        STRUCT_CBSIZE(CRYPT_SIGN_MESSAGE_PARA, rgpMsgCrl));

    if (pSignPara->cbSize < STRUCT_CBSIZE(CRYPT_SIGN_MESSAGE_PARA, rgpMsgCrl))
        SetLastError((DWORD) E_INVALIDARG);
    else {
        memset(pSignedMsgEncodeInfo, 0, sizeof(CMSG_SIGNED_ENCODE_INFO));
        pSignedMsgEncodeInfo->cbSize = sizeof(CMSG_SIGNED_ENCODE_INFO);
        pSignedMsgEncodeInfo->cSigners = 
            (pSignPara->pSigningCert != NULL) ? 1 : 0;
        pSignedMsgEncodeInfo->rgSigners = InitSignerEncodeInfo(pSignPara);
        if (pSignedMsgEncodeInfo->rgSigners ||
            pSignedMsgEncodeInfo->cSigners == 0) {
            pSignedMsgEncodeInfo->cCertEncoded = pSignPara->cMsgCert;
            pSignedMsgEncodeInfo->cCrlEncoded = pSignPara->cMsgCrl;
    
            fResult = InitSignedCertAndCrl(
                pSignPara,
                &pSignedMsgEncodeInfo->rgCertEncoded,
                &pSignedMsgEncodeInfo->rgCrlEncoded
                );
            if(!fResult)
                FreeSignerEncodeInfo(pSignedMsgEncodeInfo->rgSigners);
        }
    }

    if (!fResult)
        memset(pSignedMsgEncodeInfo, 0, sizeof(CMSG_SIGNED_ENCODE_INFO));
    return fResult;
}

static void FreeSignedMsgEncodeInfo(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    IN PCMSG_SIGNED_ENCODE_INFO pSignedMsgEncodeInfo
    )
{
    FreeSignerEncodeInfo(pSignedMsgEncodeInfo->rgSigners);
    FreeSignedCertAndCrl(
        pSignedMsgEncodeInfo->rgCertEncoded,
        pSignedMsgEncodeInfo->rgCrlEncoded
        );
}

#ifdef CMS_PKCS7
// Returned array of CMSG_RECIPIENT_ENCODE_INFOs needs to be SCAFree'd
//
// KeyAgree recipients use RC2 or 3DES wrap according
// to the EncryptPara's ContentEncryptionAlgorithm
static PCMSG_RECIPIENT_ENCODE_INFO InitCmsRecipientEncodeInfo(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[],
    IN DWORD dwFlags
    )
{
    PCMSG_RECIPIENT_ENCODE_INFO pCmsRecipientEncodeInfo = NULL;
    DWORD cbCmsRecipientEncodeInfo;
    PCMSG_RECIPIENT_ENCODE_INFO pEncodeInfo;                // not allocated
    PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTrans;        // not allocated
    PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO pKeyAgree;        // not allocated
    PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO *ppEncryptedKey; // not allocated
    PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO pEncryptedKey; // not allocated
    PCCERT_CONTEXT *ppRecipientCert;                        // not allocated
    BYTE *pbHash = NULL;                                    // not allocated

    assert(cRecipientCert);

    cbCmsRecipientEncodeInfo = 
            sizeof(CMSG_RECIPIENT_ENCODE_INFO) * cRecipientCert +
            sizeof(CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO) * cRecipientCert +
            sizeof(CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO) * cRecipientCert +
            sizeof(CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO *) * cRecipientCert +
            sizeof(CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO) * cRecipientCert;
    if (dwFlags & CRYPT_MESSAGE_KEYID_RECIPIENT_FLAG)
        cbCmsRecipientEncodeInfo += MAX_HASH_LEN * cRecipientCert;

    pCmsRecipientEncodeInfo =
        (PCMSG_RECIPIENT_ENCODE_INFO) SCAAlloc(cbCmsRecipientEncodeInfo);
    if (NULL == pCmsRecipientEncodeInfo)
        goto OutOfMemory;
    memset(pCmsRecipientEncodeInfo, 0, cbCmsRecipientEncodeInfo);

    pEncodeInfo = pCmsRecipientEncodeInfo;
    pKeyTrans = (PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO)
        &pEncodeInfo[cRecipientCert];
    pKeyAgree = (PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO)
        &pKeyTrans[cRecipientCert];
    ppEncryptedKey = (PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO *)
        &pKeyAgree[cRecipientCert];
    pEncryptedKey = (PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO)
        &ppEncryptedKey[cRecipientCert];
    if (dwFlags & CRYPT_MESSAGE_KEYID_RECIPIENT_FLAG)
        pbHash = (BYTE *) &pEncryptedKey[cRecipientCert];

    ppRecipientCert = rgpRecipientCert;
    for ( ; 0 < cRecipientCert; cRecipientCert--,
                                    pEncodeInfo++,
                                    pKeyTrans++,
                                    pKeyAgree++,
                                    ppEncryptedKey++,
                                    pEncryptedKey++,
                                    ppRecipientCert++) {
        PCERT_INFO pCertInfo = (*ppRecipientCert)->pCertInfo;
        PCERT_PUBLIC_KEY_INFO pPublicKeyInfo =
            &pCertInfo->SubjectPublicKeyInfo;

        PCCRYPT_OID_INFO pOIDInfo;
        PCERT_ID pRecipientId;
        ALG_ID aiPubKey;

        if (pOIDInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_OID_KEY,
                pPublicKeyInfo->Algorithm.pszObjId,
                CRYPT_PUBKEY_ALG_OID_GROUP_ID))
            aiPubKey = pOIDInfo->Algid;
        else
            aiPubKey = 0;

        if (aiPubKey == CALG_DH_SF || aiPubKey == CALG_DH_EPHEM) {
            pEncodeInfo->dwRecipientChoice = CMSG_KEY_AGREE_RECIPIENT;
            pEncodeInfo->pKeyAgree = pKeyAgree;
            ALG_ID aiSymKey;

            pKeyAgree->cbSize = sizeof(*pKeyAgree);
            pKeyAgree->KeyEncryptionAlgorithm.pszObjId =
                szOID_RSA_SMIMEalgESDH;
            // pKeyAgree->pvKeyEncryptionAuxInfo =

            if (pOIDInfo = CryptFindOIDInfo(
                    CRYPT_OID_INFO_OID_KEY,
                    pEncryptPara->ContentEncryptionAlgorithm.pszObjId,
                    CRYPT_ENCRYPT_ALG_OID_GROUP_ID))
                aiSymKey = pOIDInfo->Algid;
            else
                aiSymKey = 0;

            if (CALG_3DES == aiSymKey)
                pKeyAgree->KeyWrapAlgorithm.pszObjId =
                    szOID_RSA_SMIMEalgCMS3DESwrap;
            else {
                pKeyAgree->KeyWrapAlgorithm.pszObjId =
                    szOID_RSA_SMIMEalgCMSRC2wrap;
                if (CALG_RC2 == aiSymKey)
                    pKeyAgree->pvKeyWrapAuxInfo =
                        pEncryptPara->pvEncryptionAuxInfo;
            }

            // pKeyAgree->hCryptProv =
            pKeyAgree->dwKeyChoice = CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE;
            pKeyAgree->pEphemeralAlgorithm = &pPublicKeyInfo->Algorithm;
            // pKeyAgree->UserKeyingMaterial = 
            pKeyAgree->cRecipientEncryptedKeys = 1;
            pKeyAgree->rgpRecipientEncryptedKeys = ppEncryptedKey;
            *ppEncryptedKey = pEncryptedKey;

            pEncryptedKey->cbSize = sizeof(*pEncryptedKey);
            pEncryptedKey->RecipientPublicKey = pPublicKeyInfo->PublicKey;
            pRecipientId = &pEncryptedKey->RecipientId;
            // pEncryptedKey->Date =
            // pEncryptedKey->pOtherAttr =
        } else {
            pEncodeInfo->dwRecipientChoice = CMSG_KEY_TRANS_RECIPIENT;
            pEncodeInfo->pKeyTrans = pKeyTrans;

            pKeyTrans->cbSize = sizeof(*pKeyTrans);
            pKeyTrans->KeyEncryptionAlgorithm = pPublicKeyInfo->Algorithm;
            // pKeyTrans->pvKeyEncryptionAuxInfo =
            // pKeyTrans->hCryptProv =
            pKeyTrans->RecipientPublicKey = pPublicKeyInfo->PublicKey;
            pRecipientId = &pKeyTrans->RecipientId;
        }

        if (dwFlags & CRYPT_MESSAGE_KEYID_RECIPIENT_FLAG) {
            pRecipientId->dwIdChoice = CERT_ID_KEY_IDENTIFIER;
            pRecipientId->KeyId.pbData = pbHash;
            pRecipientId->KeyId.cbData = MAX_HASH_LEN;

            if (!CertGetCertificateContextProperty(
                    *ppRecipientCert,
                    CERT_KEY_IDENTIFIER_PROP_ID,
                    pbHash,
                    &pRecipientId->KeyId.cbData
                    ))
                goto GetKeyIdPropError;
            pbHash += MAX_HASH_LEN;
        } else {
            pRecipientId->dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
            pRecipientId->IssuerSerialNumber.Issuer =
                pCertInfo->Issuer;
            pRecipientId->IssuerSerialNumber.SerialNumber =
                pCertInfo->SerialNumber;
        }
    }

CommonReturn:
    return pCmsRecipientEncodeInfo;

ErrorReturn:
    SCAFree(pCmsRecipientEncodeInfo);
    pCmsRecipientEncodeInfo = NULL;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetKeyIdPropError)
}

#else

// Returned array of PCERT_INFOs needs to be SCAFree'd
static PCERT_INFO *InitRecipientEncodeInfo(
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[]
    )
{
    DWORD dwIdx;
    PCERT_INFO *ppRecipientEncodeInfo;

    if (cRecipientCert == 0) {
        SetLastError((DWORD) E_INVALIDARG);
        return NULL;
    }

    ppRecipientEncodeInfo = (PCERT_INFO *)
        SCAAlloc(sizeof(PCERT_INFO) * cRecipientCert);
    if (ppRecipientEncodeInfo != NULL) {
        for (dwIdx = 0; dwIdx < cRecipientCert; dwIdx++)
            ppRecipientEncodeInfo[dwIdx] = rgpRecipientCert[dwIdx]->pCertInfo;
    }

    return ppRecipientEncodeInfo;
}

#endif  // CMS_PKCS7

static BOOL InitEnvelopedMsgEncodeInfo(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[],
    OUT PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedMsgEncodeInfo
    )
{
    BOOL fResult = FALSE;

#ifdef CMS_PKCS7
    PCMSG_RECIPIENT_ENCODE_INFO pCmsRecipientEncodeInfo = NULL;
#else
    PCERT_INFO *ppRecipientEncodeInfo;
#endif  // CMS_PKCS7

    assert(pEncryptPara->cbSize == sizeof(CRYPT_ENCRYPT_MESSAGE_PARA) ||
        pEncryptPara->cbSize == offsetof(CRYPT_ENCRYPT_MESSAGE_PARA, dwFlags));
    if (pEncryptPara->cbSize < offsetof(CRYPT_ENCRYPT_MESSAGE_PARA, dwFlags))
        SetLastError((DWORD) E_INVALIDARG);
    else {
#ifdef CMS_PKCS7
        if (0 == cRecipientCert || (pCmsRecipientEncodeInfo =
                InitCmsRecipientEncodeInfo(
                    pEncryptPara,
                    cRecipientCert,
                    rgpRecipientCert,
                    pEncryptPara->cbSize >= sizeof(CRYPT_ENCRYPT_MESSAGE_PARA) ?
                        pEncryptPara->dwFlags : 0
                    ))) {
#else
        ppRecipientEncodeInfo = InitRecipientEncodeInfo(
            cRecipientCert,
            rgpRecipientCert
            );
    
        if (ppRecipientEncodeInfo) {
#endif  // CMS_PKCS7
            memset(pEnvelopedMsgEncodeInfo, 0,
                sizeof(CMSG_ENVELOPED_ENCODE_INFO));
            pEnvelopedMsgEncodeInfo->cbSize =
                sizeof(CMSG_ENVELOPED_ENCODE_INFO);
            pEnvelopedMsgEncodeInfo->hCryptProv = pEncryptPara->hCryptProv;
            pEnvelopedMsgEncodeInfo->ContentEncryptionAlgorithm =
                pEncryptPara->ContentEncryptionAlgorithm;
            pEnvelopedMsgEncodeInfo->pvEncryptionAuxInfo =
                pEncryptPara->pvEncryptionAuxInfo;
            pEnvelopedMsgEncodeInfo->cRecipients = cRecipientCert;
#ifdef CMS_PKCS7
            pEnvelopedMsgEncodeInfo->rgCmsRecipients = pCmsRecipientEncodeInfo;
#else
            pEnvelopedMsgEncodeInfo->rgpRecipients = ppRecipientEncodeInfo;
#endif  // CMS_PKCS7
            fResult = TRUE;
        } else
            fResult = FALSE;
    }
    if (!fResult) 
        memset(pEnvelopedMsgEncodeInfo, 0, sizeof(CMSG_ENVELOPED_ENCODE_INFO));
    return fResult;
}

static void FreeEnvelopedMsgEncodeInfo(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedMsgEncodeInfo
    )
{
#ifdef CMS_PKCS7
    if (pEnvelopedMsgEncodeInfo->rgCmsRecipients)
        SCAFree(pEnvelopedMsgEncodeInfo->rgCmsRecipients);
#else
    if (pEnvelopedMsgEncodeInfo->rgpRecipients)
        SCAFree(pEnvelopedMsgEncodeInfo->rgpRecipients);
#endif  // CMS_PKCS7
}

//+-------------------------------------------------------------------------
//  Encode the message.
//--------------------------------------------------------------------------
static BOOL EncodeMsg(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN void *pvMsgEncodeInfo,
    IN DWORD cToBeEncoded,
    IN const BYTE *rgpbToBeEncoded[],
    IN DWORD rgcbToBeEncoded[],
    IN BOOL fBareContent,
    IN DWORD dwInnerContentType,
    OUT BYTE *pbEncodedBlob,
    IN OUT DWORD *pcbEncodedBlob
    )
{
    BOOL fResult;
    HCRYPTMSG hMsg = NULL;
    DWORD cbEncodedBlob;
    LPCSTR pszInnerContentOID;

    // Get input length and default return length to 0
    if (pbEncodedBlob == NULL)
        cbEncodedBlob = 0;
    else
        cbEncodedBlob = *pcbEncodedBlob;
    *pcbEncodedBlob = 0;

    if (dwInnerContentType)
        pszInnerContentOID = MsgTypeToOID(dwInnerContentType);
    else
        pszInnerContentOID = NULL;

    if (0 == cbEncodedBlob) {
        DWORD c;
        DWORD cbTotal = 0;
        DWORD *pcb;
        for (c = cToBeEncoded, pcb = rgcbToBeEncoded; c > 0; c--, pcb++)
            cbTotal += *pcb;

        if (fBareContent)
            dwFlags |= CMSG_BARE_CONTENT_FLAG;

        if (0 == (*pcbEncodedBlob = CryptMsgCalculateEncodedLength(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            pvMsgEncodeInfo,
            (LPSTR) pszInnerContentOID,
            cbTotal
            ))) goto CalculateEncodedLengthError;
        if (pbEncodedBlob) goto LengthError;
    } else {
        if (NULL == (hMsg = CryptMsgOpenToEncode(
                dwMsgEncodingType,
                dwFlags,
                dwMsgType,
                pvMsgEncodeInfo,
                (LPSTR) pszInnerContentOID,
                NULL                    // pStreamInfo
                ))) goto OpenToEncodeError;


        if (0 == cToBeEncoded) {
            if (!CryptMsgUpdate(
                    hMsg,
                    NULL,           // pbData
                    0,              // cbData
                    TRUE            // fFinal
                    )) goto UpdateError;
        } else {
            DWORD c;
            DWORD *pcb;
            const BYTE **ppb;
            for (c = cToBeEncoded,
                 pcb = rgcbToBeEncoded,
                 ppb = rgpbToBeEncoded; c > 0; c--, pcb++, ppb++) {
                if (!CryptMsgUpdate(
                        hMsg,
                        *ppb,
                        *pcb,
                        c == 1                    // fFinal
                        )) goto UpdateError;
            }
        }

        fResult = CryptMsgGetParam(
            hMsg,
            fBareContent ? CMSG_BARE_CONTENT_PARAM : CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            pbEncodedBlob,
            &cbEncodedBlob
            );
        *pcbEncodedBlob = cbEncodedBlob;
        if (!fResult) goto ErrorReturn;     // NO_TRACE
    }
    fResult = TRUE;

CommonReturn:
    if (hMsg)
        CryptMsgClose(hMsg);    // for success, preserves LastError
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(LengthError, ERROR_MORE_DATA)
TRACE_ERROR(CalculateEncodedLengthError)
TRACE_ERROR(OpenToEncodeError)
TRACE_ERROR(UpdateError)
}

//+-------------------------------------------------------------------------
//  Decodes the message types:
//      CMSG_SIGNED
//      CMSG_ENVELOPED
//      CMSG_SIGNED_AND_ENVELOPED
//      CMSG_HASHED
//
//  For detached signature (cToBeEncoded != 0), then, pcbDecoded == NULL.
//--------------------------------------------------------------------------
static BOOL DecodeMsg(
    IN DWORD dwMsgTypeFlags,
    IN OPTIONAL PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN OPTIONAL PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN const BYTE *pbEncodedBlob,
    IN DWORD cbEncodedBlob,
    IN DWORD cToBeEncoded,
    IN OPTIONAL const BYTE *rgpbToBeEncoded[],
    IN OPTIONAL DWORD rgcbToBeEncoded[],
    IN DWORD dwPrevInnerContentType,
    OUT OPTIONAL DWORD *pdwMsgType,
    OUT OPTIONAL DWORD *pdwInnerContentType,
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    )
{
    BOOL fResult;
    HCRYPTMSG hMsg = NULL;
    DWORD cbData;
    DWORD dwMsgType;
    DWORD dwFlags;
    HCRYPTPROV hCryptProv;
    DWORD dwMsgEncodingType;
    DWORD cbDecoded;

    // Get input length and default return length to 0
    cbDecoded = 0;
    if (pcbDecoded) {
        if (pbDecoded)
            cbDecoded = *pcbDecoded;
        *pcbDecoded = 0;
    }

    // Default optional return values to 0
    if (pdwMsgType)
        *pdwMsgType = 0;
    if (pdwInnerContentType)
        *pdwInnerContentType = 0;
    if (ppXchgCert)
        *ppXchgCert = NULL;
    if (ppSignerCert)
        *ppSignerCert = NULL;

    if (pDecryptPara) {
        assert(pDecryptPara->cbSize >=
            STRUCT_CBSIZE(CRYPT_DECRYPT_MESSAGE_PARA, rghCertStore));
        if (pDecryptPara->cbSize < 
                STRUCT_CBSIZE(CRYPT_DECRYPT_MESSAGE_PARA, rghCertStore))
            goto InvalidArg;
    }

    if (pVerifyPara) {
        assert(pVerifyPara->cbSize == sizeof(CRYPT_VERIFY_MESSAGE_PARA));
        if (pVerifyPara->cbSize != sizeof(CRYPT_VERIFY_MESSAGE_PARA))
            goto InvalidArg;
        hCryptProv = pVerifyPara->hCryptProv;
        dwMsgEncodingType = pVerifyPara->dwMsgAndCertEncodingType;
    } else {
        hCryptProv = 0;
        if (NULL == pDecryptPara) goto InvalidArg;
        dwMsgEncodingType = pDecryptPara->dwMsgAndCertEncodingType;
    }

    if (cToBeEncoded)
        dwFlags = CMSG_DETACHED_FLAG;
    else if (pcbDecoded && 0 == cbDecoded &&
            NULL == ppXchgCert && NULL == ppSignerCert)
        dwFlags = CMSG_LENGTH_ONLY_FLAG;
    else
        dwFlags = 0;

    if (dwPrevInnerContentType) {
        dwMsgType = dwPrevInnerContentType;
        if (CMSG_DATA == dwMsgType)
            dwMsgType = 0;
    } else
        dwMsgType = 0;
    if (NULL == (hMsg = CryptMsgOpenToDecode(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            hCryptProv,
            NULL,                       // pRecipientInfo
            NULL                        // pStreamInfo
            ))) goto OpenToDecodeError;

    if (!CryptMsgUpdate(
            hMsg,
            pbEncodedBlob,
            cbEncodedBlob,
            TRUE                    // fFinal
            )) goto UpdateError;

    if (cToBeEncoded) {
        // Detached signature
        DWORD c;
        DWORD *pcb;
        const BYTE **ppb;
        for (c = cToBeEncoded,
             pcb = rgcbToBeEncoded,
             ppb = rgpbToBeEncoded; c > 0; c--, pcb++, ppb++) {
            if (!CryptMsgUpdate(
                    hMsg,
                    *ppb,
                    *pcb,
                    c == 1                    // fFinal
                    )) goto UpdateError;
        }
    }

    cbData = sizeof(dwMsgType);
    dwMsgType = 0;
    if (!CryptMsgGetParam(
            hMsg,
            CMSG_TYPE_PARAM,
            0,                  // dwIndex
            &dwMsgType,
            &cbData
            )) goto GetTypeError;
    if (pdwMsgType)
        *pdwMsgType = dwMsgType;
    if (0 == ((1 << dwMsgType) & dwMsgTypeFlags))
        goto UnexpectedMsgTypeError;

    if (pdwInnerContentType) {
        char szInnerContentType[128];
        cbData = sizeof(szInnerContentType);
        if (!CryptMsgGetParam(
                hMsg,
                CMSG_INNER_CONTENT_TYPE_PARAM,
                0,                  // dwIndex
                szInnerContentType,
                &cbData
                )) goto GetInnerContentTypeError;
        *pdwInnerContentType = OIDToMsgType(szInnerContentType);
    }

    if (0 == (dwFlags & CMSG_LENGTH_ONLY_FLAG)) {
        if (dwMsgType == CMSG_ENVELOPED ||
                dwMsgType == CMSG_SIGNED_AND_ENVELOPED) {
            if (pDecryptPara == NULL) goto InvalidArg;
            if (!GetXchgCertAndDecrypt(
                    pDecryptPara,
                    hMsg,
                    ppXchgCert
                    )) goto GetXchgCertAndDecryptError;
        }

        if (dwMsgType == CMSG_SIGNED ||
                dwMsgType == CMSG_SIGNED_AND_ENVELOPED) {
            if (pVerifyPara == NULL) goto InvalidArg;
            if (!GetSignerCertAndVerify(
                    pVerifyPara,
                    dwSignerIndex,
                    hMsg,
                    ppSignerCert
                    )) goto GetSignerCertAndVerifyError;
        }
    }


    if (pcbDecoded) {
        fResult = CryptMsgGetParam(
            hMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            pbDecoded,
            &cbDecoded
            );
        *pcbDecoded = cbDecoded;
        if (!fResult) goto ErrorReturn;     // NO_TRACE
    }

    fResult = TRUE;

CommonReturn:
    if (hMsg)
        CryptMsgClose(hMsg);    // for success, preserves LastError
    return fResult;

ErrorReturn:
    if (ppXchgCert && *ppXchgCert) {
        CertFreeCertificateContext(*ppXchgCert);
        *ppXchgCert = NULL;
    }
    if (ppSignerCert && *ppSignerCert) {
        CertFreeCertificateContext(*ppSignerCert);
        *ppSignerCert = NULL;
    }

    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OpenToDecodeError)
TRACE_ERROR(UpdateError)
TRACE_ERROR(GetTypeError)
TRACE_ERROR(GetInnerContentTypeError)
SET_ERROR(UnexpectedMsgTypeError, CRYPT_E_UNEXPECTED_MSG_TYPE)
TRACE_ERROR(GetXchgCertAndDecryptError)
TRACE_ERROR(GetSignerCertAndVerifyError)
}

#ifdef ENABLE_SCA_STREAM_TEST

typedef struct _STREAM_OUTPUT_INFO {
    BYTE    *pbData;
    DWORD   cbData;
    DWORD   cFinal;
} STREAM_OUTPUT_INFO, *PSTREAM_OUTPUT_INFO;

static void *SCARealloc(
    IN void *pvOrg,
    IN size_t cbBytes
    )
{
    void *pv;
    if (NULL == (pv = pvOrg ? realloc(pvOrg, cbBytes) : malloc(cbBytes)))
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

static BOOL WINAPI StreamOutputCallback(
        IN const void *pvArg,
        IN BYTE *pbData,
        IN DWORD cbData,
        IN BOOL fFinal
        )
{
    BOOL fResult = TRUE;
    PSTREAM_OUTPUT_INFO pInfo = (PSTREAM_OUTPUT_INFO) pvArg;
    if (fFinal)
        pInfo->cFinal++;

    if (cbData) {
        BYTE *pb;

        if (NULL == (pb = (BYTE *) SCARealloc(pInfo->pbData,
                pInfo->cbData + cbData)))
            fResult = FALSE;
        else {
            memcpy(pb + pInfo->cbData, pbData, cbData);
            pInfo->pbData = pb;
            pInfo->cbData += cbData;
        }
    }
    return fResult;
}


//+-------------------------------------------------------------------------
//  Encodes the message using streaming.
//--------------------------------------------------------------------------
static BOOL StreamEncodeMsg(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN void *pvMsgEncodeInfo,
    IN DWORD cToBeEncoded,
    IN const BYTE *rgpbToBeEncoded[],
    IN DWORD rgcbToBeEncoded[],
    IN BOOL fBareContent,
    IN DWORD dwInnerContentType,
    OUT BYTE *pbEncodedBlob,
    IN OUT DWORD *pcbEncodedBlob
    )
{
    BOOL fResult;
    HCRYPTMSG hMsg = NULL;
    DWORD cbEncodedBlob;
    LPCSTR pszInnerContentOID;

    STREAM_OUTPUT_INFO OutputInfo;
    memset(&OutputInfo, 0, sizeof(OutputInfo));

    CMSG_STREAM_INFO StreamInfo;
    memset(&StreamInfo, 0, sizeof(StreamInfo));

    StreamInfo.pfnStreamOutput = StreamOutputCallback;
    StreamInfo.pvArg = (void *) &OutputInfo;
    if (dwFlags & SCA_INDEFINITE_STREAM_FLAG)
        StreamInfo.cbContent = CMSG_INDEFINITE_LENGTH;
    else {
        DWORD c;
        DWORD cbTotal = 0;
        DWORD *pcb;
        for (c = cToBeEncoded, pcb = rgcbToBeEncoded; c > 0; c--, pcb++)
            cbTotal += *pcb;

        StreamInfo.cbContent = cbTotal;
    }
    dwFlags &= ~(SCA_STREAM_ENABLE_FLAG | SCA_INDEFINITE_STREAM_FLAG);

    // Get input length and default return length to 0
    if (pbEncodedBlob == NULL)
        cbEncodedBlob = 0;
    else
        cbEncodedBlob = *pcbEncodedBlob;
    *pcbEncodedBlob = 0;

    if (dwInnerContentType)
        pszInnerContentOID = MsgTypeToOID(dwInnerContentType);
    else
        pszInnerContentOID = NULL;

    {
        if (fBareContent)
            dwFlags |= CMSG_BARE_CONTENT_FLAG;
        if (NULL == (hMsg = CryptMsgOpenToEncode(
                dwMsgEncodingType,
                dwFlags,
                dwMsgType,
                pvMsgEncodeInfo,
                (LPSTR) pszInnerContentOID,
                &StreamInfo
                ))) goto OpenToEncodeError;

        if (0 == cToBeEncoded) {
            if (!CryptMsgUpdate(
                    hMsg,
                    NULL,           // pbData
                    0,              // cbData
                    TRUE            // fFinal
                    )) goto UpdateError;
        } else {
            DWORD c;
            DWORD *pcb;
            const BYTE **ppb;
            for (c = cToBeEncoded,
                 pcb = rgcbToBeEncoded,
                 ppb = rgpbToBeEncoded; c > 0; c--, pcb++, ppb++) {
                BYTE *pbAlloc = NULL;
                const BYTE *pb = *ppb;

                if (NULL == pb) {
                    pbAlloc = (BYTE *) SCAAlloc(*pcb);
                    pb = pbAlloc;
                }
                
                fResult = CryptMsgUpdate(
                        hMsg,
                        pb,
                        *pcb,
                        c == 1                    // fFinal
                        );
                if (pbAlloc)
                    SCAFree(pbAlloc);
                if (!fResult)
                    goto UpdateError;
            }
        }

        if (1 != OutputInfo.cFinal)
            goto BadStreamFinalCountError;

        *pcbEncodedBlob = OutputInfo.cbData;
        if (pbEncodedBlob) {
            if (cbEncodedBlob < OutputInfo.cbData) {
                SetLastError((DWORD) ERROR_MORE_DATA);
                goto ErrorReturn;       // no trace
            }

            if (OutputInfo.cbData > 0)
                memcpy(pbEncodedBlob, OutputInfo.pbData, OutputInfo.cbData);
        }
    }
    fResult = TRUE;

CommonReturn:
    SCAFree(OutputInfo.pbData);
    if (hMsg)
        CryptMsgClose(hMsg);    // for success, preserves LastError
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OpenToEncodeError)
TRACE_ERROR(UpdateError)
SET_ERROR(BadStreamFinalCountError, E_UNEXPECTED)
}

//+-------------------------------------------------------------------------
//  Decodes the message types:
//      CMSG_SIGNED
//      CMSG_ENVELOPED
//      CMSG_SIGNED_AND_ENVELOPED
//      CMSG_HASHED
//
//  Uses streaming.
//--------------------------------------------------------------------------
static BOOL StreamDecodeMsg(
    IN DWORD dwMsgTypeFlags,
    IN OPTIONAL PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN OPTIONAL PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN const BYTE *pbEncodedBlob,
    IN DWORD cbEncodedBlob,
    IN DWORD cToBeEncoded,
    IN OPTIONAL const BYTE *rgpbToBeEncoded[],
    IN OPTIONAL DWORD rgcbToBeEncoded[],
    IN DWORD dwPrevInnerContentType,
    OUT OPTIONAL DWORD *pdwMsgType,
    OUT OPTIONAL DWORD *pdwInnerContentType,
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    )
{
    BOOL fResult;
    HCRYPTMSG hMsg = NULL;
    DWORD cbData;
    DWORD dwMsgType;
    DWORD dwFlags;
    HCRYPTPROV hCryptProv;
    DWORD dwMsgEncodingType;
    DWORD cbDecoded;

    STREAM_OUTPUT_INFO OutputInfo;
    memset(&OutputInfo, 0, sizeof(OutputInfo));
    CMSG_STREAM_INFO StreamInfo;
    memset(&StreamInfo, 0, sizeof(StreamInfo));

    StreamInfo.pfnStreamOutput = StreamOutputCallback;
    StreamInfo.pvArg = (void *) &OutputInfo;
    StreamInfo.cbContent = CMSG_INDEFINITE_LENGTH;

    // Get input length and default return length to 0
    cbDecoded = 0;
    if (pcbDecoded) {
        if (pbDecoded)
            cbDecoded = *pcbDecoded;
        *pcbDecoded = 0;
    }

    // Default optional return values to 0
    if (pdwMsgType)
        *pdwMsgType = 0;
    if (pdwInnerContentType)
        *pdwInnerContentType = 0;
    if (ppXchgCert)
        *ppXchgCert = NULL;
    if (ppSignerCert)
        *ppSignerCert = NULL;

    if (pDecryptPara) {
        assert(pDecryptPara->cbSize >=
            STRUCT_CBSIZE(CRYPT_DECRYPT_MESSAGE_PARA, rghCertStore));
        if (pDecryptPara->cbSize < 
                STRUCT_CBSIZE(CRYPT_DECRYPT_MESSAGE_PARA, rghCertStore))
            goto InvalidArg;
    }

    if (pVerifyPara) {
        assert(pVerifyPara->cbSize == sizeof(CRYPT_VERIFY_MESSAGE_PARA));
        if (pVerifyPara->cbSize != sizeof(CRYPT_VERIFY_MESSAGE_PARA))
            goto InvalidArg;
        hCryptProv = pVerifyPara->hCryptProv;
        dwMsgEncodingType = pVerifyPara->dwMsgAndCertEncodingType;
    } else {
        hCryptProv = 0;
        if (NULL == pDecryptPara) goto InvalidArg;
        dwMsgEncodingType = pDecryptPara->dwMsgAndCertEncodingType;
    }

    dwMsgEncodingType &= ~SCA_STREAM_ENABLE_FLAG;

    if (cToBeEncoded)
        dwFlags = CMSG_DETACHED_FLAG;
    else
        dwFlags = 0;

    if (dwPrevInnerContentType) {
        dwMsgType = dwPrevInnerContentType;
        if (CMSG_DATA == dwMsgType)
            dwMsgType = 0;
    } else
        dwMsgType = 0;
    if (NULL == (hMsg = CryptMsgOpenToDecode(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            hCryptProv,
            NULL,                       // pRecipientInfo
            &StreamInfo
            ))) goto OpenToDecodeError;

    {
#if 1
        DWORD cbDelta = cbEncodedBlob / 10;
#else
        DWORD cbDelta = 1;
#endif
        DWORD cbRemain = cbEncodedBlob;
        const BYTE *pb = pbEncodedBlob;

        do {
            DWORD cb;

            if (cbRemain > cbDelta)
                cb = cbDelta;
            else
                cb = cbRemain;

            if (!CryptMsgUpdate(
                    hMsg,
                    pb,
                    cb,
                    cbRemain == cb     // fFinal
                    )) goto UpdateError;
            pb += cb;
            cbRemain -= cb;
        } while (0 != cbRemain);
    }

    if (cToBeEncoded) {
        // Detached signature
        DWORD c;
        DWORD *pcb;
        const BYTE **ppb;
        for (c = cToBeEncoded,
             pcb = rgcbToBeEncoded,
             ppb = rgpbToBeEncoded; c > 0; c--, pcb++, ppb++) {
            if (!CryptMsgUpdate(
                    hMsg,
                    *ppb,
                    *pcb,
                    c == 1                    // fFinal
                    )) goto UpdateError;
        }
    }

    cbData = sizeof(dwMsgType);
    dwMsgType = 0;
    if (!CryptMsgGetParam(
            hMsg,
            CMSG_TYPE_PARAM,
            0,                  // dwIndex
            &dwMsgType,
            &cbData
            )) goto GetTypeError;
    if (pdwMsgType)
        *pdwMsgType = dwMsgType;
    if (0 == ((1 << dwMsgType) & dwMsgTypeFlags))
        goto UnexpectedMsgTypeError;

    if (pdwInnerContentType) {
        char szInnerContentType[128];
        cbData = sizeof(szInnerContentType);
        if (!CryptMsgGetParam(
                hMsg,
                CMSG_INNER_CONTENT_TYPE_PARAM,
                0,                  // dwIndex
                szInnerContentType,
                &cbData
                )) goto GetInnerContentTypeError;
        *pdwInnerContentType = OIDToMsgType(szInnerContentType);
    }

    if (pcbDecoded && 0 == cbDecoded &&
            NULL == ppXchgCert && NULL == ppSignerCert &&
            dwMsgType != CMSG_ENVELOPED)
        ; // Length only
    else {
        if (dwMsgType == CMSG_ENVELOPED ||
                dwMsgType == CMSG_SIGNED_AND_ENVELOPED) {
            if (pDecryptPara == NULL) goto InvalidArg;
            if (!GetXchgCertAndDecrypt(
                    pDecryptPara,
                    hMsg,
                    ppXchgCert
                    )) goto GetXchgCertAndDecryptError;
        }

        if (dwMsgType == CMSG_SIGNED ||
                dwMsgType == CMSG_SIGNED_AND_ENVELOPED) {
            if (pVerifyPara == NULL) goto InvalidArg;
            if (!GetSignerCertAndVerify(
                    pVerifyPara,
                    dwSignerIndex,
                    hMsg,
                    ppSignerCert
                    )) goto GetSignerCertAndVerifyError;
        }
    }

    if (1 != OutputInfo.cFinal)
        goto BadStreamFinalCountError;

    if (pcbDecoded) {
        *pcbDecoded = OutputInfo.cbData;
        if (pbDecoded) {
            if (cbDecoded < OutputInfo.cbData) {
                SetLastError((DWORD) ERROR_MORE_DATA);
                goto ErrorReturn;       // no trace
            }

            if (OutputInfo.cbData > 0)
                memcpy(pbDecoded, OutputInfo.pbData, OutputInfo.cbData);
        }
    }

    fResult = TRUE;

CommonReturn:
    SCAFree(OutputInfo.pbData);
    if (hMsg)
        CryptMsgClose(hMsg);    // for success, preserves LastError
    return fResult;

ErrorReturn:
    if (ppXchgCert && *ppXchgCert) {
        CertFreeCertificateContext(*ppXchgCert);
        *ppXchgCert = NULL;
    }
    if (ppSignerCert && *ppSignerCert) {
        CertFreeCertificateContext(*ppSignerCert);
        *ppSignerCert = NULL;
    }

    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OpenToDecodeError)
TRACE_ERROR(UpdateError)
TRACE_ERROR(GetTypeError)
TRACE_ERROR(GetInnerContentTypeError)
SET_ERROR(UnexpectedMsgTypeError, CRYPT_E_UNEXPECTED_MSG_TYPE)
TRACE_ERROR(GetXchgCertAndDecryptError)
TRACE_ERROR(GetSignerCertAndVerifyError)
SET_ERROR(BadStreamFinalCountError, E_UNEXPECTED)
}

#endif      // ENABLE_SCA_STREAM_TEST


//+-------------------------------------------------------------------------
//  Decodes the HASHED message type
//
//  For detached hash (cToBeHashed != 0), then, pcbDecoded == NULL.
//--------------------------------------------------------------------------
static BOOL DecodeHashMsg(
    IN PCRYPT_HASH_MESSAGE_PARA pHashPara,
    IN const BYTE *pbEncodedBlob,
    IN DWORD cbEncodedBlob,
    IN DWORD cToBeHashed,
    IN OPTIONAL const BYTE *rgpbToBeHashed[],
    IN OPTIONAL DWORD rgcbToBeHashed[],
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded,
    OUT OPTIONAL BYTE *pbComputedHash,
    IN OUT OPTIONAL DWORD *pcbComputedHash
    )
{
    BOOL fResult;
    HCRYPTMSG hMsg = NULL;
    DWORD cbData;
    DWORD dwMsgType;
    DWORD dwFlags;
    HCRYPTPROV hCryptProv;
    DWORD dwMsgEncodingType;
    DWORD cbDecoded;
    DWORD cbComputedHash;

    // Get input lengths and default return lengths to 0
    cbDecoded = 0;
    if (pcbDecoded) {
        if (pbDecoded)
            cbDecoded = *pcbDecoded;
        *pcbDecoded = 0;
    }
    cbComputedHash = 0;
    if (pcbComputedHash) {
        if (pbComputedHash)
            cbComputedHash = *pcbComputedHash;
        *pcbComputedHash = 0;
    }

    assert(pHashPara->cbSize == sizeof(CRYPT_HASH_MESSAGE_PARA));
    if (pHashPara->cbSize != sizeof(CRYPT_HASH_MESSAGE_PARA))
        goto InvalidArg;

    hCryptProv = pHashPara->hCryptProv;
    dwMsgEncodingType = pHashPara->dwMsgEncodingType;

    if (cToBeHashed)
        dwFlags = CMSG_DETACHED_FLAG;
    else if (0 == cbDecoded && NULL == pcbComputedHash)
        dwFlags = CMSG_LENGTH_ONLY_FLAG;
    else
        dwFlags = 0;

    if (NULL == (hMsg = CryptMsgOpenToDecode(
            dwMsgEncodingType,
            dwFlags,
            0,                          // dwMsgType
            hCryptProv,
            NULL,                       // pRecipientInfo
            NULL                        // pStreamInfo
            ))) goto OpenToDecodeError;

    if (!CryptMsgUpdate(
            hMsg,
            pbEncodedBlob,
            cbEncodedBlob,
            TRUE                    // fFinal
            )) goto UpdateError;

    if (cToBeHashed) {
        // Detached signature or hash
        DWORD c = 0;
        DWORD *pcb;
        const BYTE **ppb;
        for (c = cToBeHashed,
             pcb = rgcbToBeHashed,
             ppb = rgpbToBeHashed; c > 0; c--, pcb++, ppb++) {
            if (!CryptMsgUpdate(
                    hMsg,
                    *ppb,
                    *pcb,
                    c == 1                    // fFinal
                    )) goto UpdateError;
        }
    }

    cbData = sizeof(dwMsgType);
    dwMsgType = 0;
    if (!CryptMsgGetParam(
            hMsg,
            CMSG_TYPE_PARAM,
            0,                  // dwIndex
            &dwMsgType,
            &cbData
            )) goto GetTypeError;
    if (dwMsgType != CMSG_HASHED)
        goto UnexpectedMsgTypeError;

    if (0 == (dwFlags & CMSG_LENGTH_ONLY_FLAG)) {
        if (!CryptMsgControl(
                hMsg,
                0,                      // dwFlags
                CMSG_CTRL_VERIFY_HASH,
                NULL                    // pvCtrlPara
                )) goto ControlError;
    }

    fResult = TRUE;
    if (pcbDecoded) {
        fResult = CryptMsgGetParam(
            hMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            pbDecoded,
            &cbDecoded
            );
        *pcbDecoded = cbDecoded;
    }
    if (pcbComputedHash) {
        DWORD dwErr = 0;
        BOOL fResult2;
        if (!fResult)
            dwErr = GetLastError();
        fResult2 = CryptMsgGetParam(
            hMsg,
            CMSG_COMPUTED_HASH_PARAM,
            0,                      // dwIndex
            pbComputedHash,
            &cbComputedHash
            );
        *pcbComputedHash = cbComputedHash;
        if (!fResult2)
            fResult = FALSE;
        else if (!fResult)
            SetLastError(dwErr);
    }
    if (!fResult)
        goto ErrorReturn;     // NO_TRACE

CommonReturn:
    if (hMsg)
        CryptMsgClose(hMsg);    // for success, preserves LastError
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OpenToDecodeError)
TRACE_ERROR(UpdateError)
TRACE_ERROR(GetTypeError)
SET_ERROR(UnexpectedMsgTypeError, CRYPT_E_UNEXPECTED_MSG_TYPE)
TRACE_ERROR(ControlError)
}

//+-------------------------------------------------------------------------
//  Get certificate for and verify the message's signer.
//--------------------------------------------------------------------------
static BOOL GetSignerCertAndVerify(
    IN PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN HCRYPTMSG hMsg,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    )
{
    BOOL fResult;
    BOOL fNoSigner = FALSE;
    PCERT_INFO pSignerId = NULL;
    PCCERT_CONTEXT pSignerCert = NULL;
    HCERTSTORE hMsgCertStore = NULL;
    DWORD dwLastError = 0;


    {
        // First, get count of signers in the message and verify the
        // dwSignerIndex
        DWORD cSigner = 0;
        DWORD cbData = sizeof(cSigner);
        if (!CryptMsgGetParam(
                hMsg,
                CMSG_SIGNER_COUNT_PARAM,
                0,                      // dwIndex
                &cSigner,
                &cbData
                )) goto ErrorReturn;
        if (cSigner <= dwSignerIndex) fNoSigner = TRUE;
    }

    if (!fNoSigner) {
        // Allocate and get the CERT_INFO containing the SignerId 
        // (Issuer and SerialNumber)
        if (NULL == (pSignerId = (PCERT_INFO) AllocAndMsgGetParam(
                hMsg,
                CMSG_SIGNER_CERT_INFO_PARAM,
                dwSignerIndex
                ))) goto ErrorReturn;
    }

    // Open a cert store initialized with certs and CRLs from the message
    hMsgCertStore = CertOpenStore(
        CERT_STORE_PROV_MSG,
#ifdef ENABLE_SCA_STREAM_TEST
        pVerifyPara->dwMsgAndCertEncodingType &= ~SCA_STREAM_ENABLE_FLAG,
#else
        pVerifyPara->dwMsgAndCertEncodingType,
#endif
        pVerifyPara->hCryptProv,
        CERT_STORE_NO_CRYPT_RELEASE_FLAG,
        hMsg                        // pvPara
        );
    if (hMsgCertStore == NULL) goto ErrorReturn;

    if (pVerifyPara->pfnGetSignerCertificate)
        pSignerCert = pVerifyPara->pfnGetSignerCertificate(
            pVerifyPara->pvGetArg,
#ifdef ENABLE_SCA_STREAM_TEST
            pVerifyPara->dwMsgAndCertEncodingType &= ~SCA_STREAM_ENABLE_FLAG,
#else
            pVerifyPara->dwMsgAndCertEncodingType,
#endif
            pSignerId,
            hMsgCertStore
            );
    else
        pSignerCert = NullGetSignerCertificate(
            NULL,
#ifdef ENABLE_SCA_STREAM_TEST
            pVerifyPara->dwMsgAndCertEncodingType &= ~SCA_STREAM_ENABLE_FLAG,
#else
            pVerifyPara->dwMsgAndCertEncodingType,
#endif
            pSignerId,
            hMsgCertStore
            );
    if (fNoSigner) goto NoSigner;
    if (pSignerCert == NULL) goto ErrorReturn;

#ifdef CMS_PKCS7
    {
        CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA CtrlPara;

        memset(&CtrlPara, 0, sizeof(CtrlPara));
        CtrlPara.cbSize = sizeof(CtrlPara);
        // CtrlPara.hCryptProv =
        CtrlPara.dwSignerIndex = dwSignerIndex;
        CtrlPara.dwSignerType = CMSG_VERIFY_SIGNER_CERT;
        CtrlPara.pvSigner = (void *) pSignerCert;
        if (!CryptMsgControl(
                hMsg,
                0,                  // dwFlags
                CMSG_CTRL_VERIFY_SIGNATURE_EX,
                &CtrlPara
                )) {
            if (CRYPT_E_MISSING_PUBKEY_PARA != GetLastError())
                goto ErrorReturn;
            else {
                PCCERT_CHAIN_CONTEXT pChainContext;
                CERT_CHAIN_PARA ChainPara;

                // Build a chain. Hopefully, the signer inherit's its public key
                // parameters from up the chain

                memset(&ChainPara, 0, sizeof(ChainPara));
                ChainPara.cbSize = sizeof(ChainPara);
                if (CertGetCertificateChain(
                        NULL,                   // hChainEngine
                        pSignerCert,
                        NULL,                   // pTime
                        hMsgCertStore,
                        &ChainPara,
                        CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL,
                        NULL,                   // pvReserved
                        &pChainContext
                        ))
                    CertFreeCertificateChain(pChainContext);

                // Try again. Hopefully the above chain building updated the
                // signer's context property with the missing public key
                // parameters
                if (!CryptMsgControl(
                        hMsg,
                        0,                  // dwFlags
                        CMSG_CTRL_VERIFY_SIGNATURE_EX,
                        &CtrlPara)) goto ErrorReturn;
            }
        }
    }
#else
    if (!CryptMsgControl(
            hMsg,
            0,                  // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE,
            pSignerCert->pCertInfo
            )) goto ErrorReturn;
#endif  // CMS_PKCS7

    if (ppSignerCert)
        *ppSignerCert = pSignerCert;
    else
        CertFreeCertificateContext(pSignerCert);

    fResult = TRUE;
    goto CommonReturn;

NoSigner:
    SetLastError((DWORD) CRYPT_E_NO_SIGNER);
ErrorReturn:
    if (pSignerCert)
        CertFreeCertificateContext(pSignerCert);
    if (ppSignerCert)
        *ppSignerCert = NULL;
    fResult = FALSE;
    dwLastError = GetLastError();
CommonReturn:
    if (pSignerId)
        SCAFree(pSignerId);
    if (hMsgCertStore)
        CertCloseStore(hMsgCertStore, 0);
    if (dwLastError)
        SetLastError(dwLastError);
    return fResult;
}

#ifdef CMS_PKCS7

static BOOL GetXchgCertAndDecrypt(
    IN PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN HCRYPTMSG hMsg,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert
    )
{
    BOOL fResult;
    PCMSG_CMS_RECIPIENT_INFO pRecipientInfo = NULL;
    PCCERT_CONTEXT pXchgCert = NULL;
    DWORD cRecipient;
    DWORD cbData;
    DWORD dwRecipientIdx;

    // Get # of CMS recipients in the message.
    cbData = sizeof(cRecipient);
    cRecipient = 0;
    fResult = CryptMsgGetParam(
        hMsg,
        CMSG_CMS_RECIPIENT_COUNT_PARAM,
        0,                      // dwIndex
        &cRecipient,
        &cbData
        );
    if (!fResult) goto ErrorReturn;
    if (cRecipient == 0) {
        SetLastError((DWORD) CRYPT_E_RECIPIENT_NOT_FOUND);
        goto ErrorReturn;
    }

    // Loop through the recipients in the message until we find a
    // recipient cert in one of the stores with either the
    // CERT_KEY_CONTEXT_PROP_ID or CERT_KEY_PROV_INFO_PROP_ID.
    for (dwRecipientIdx = 0; dwRecipientIdx < cRecipient; dwRecipientIdx++) {
        DWORD dwRecipientChoice;
        PCMSG_KEY_TRANS_RECIPIENT_INFO pKeyTrans = NULL;
        PCMSG_KEY_AGREE_RECIPIENT_INFO pKeyAgree = NULL;
        DWORD cRecipientEncryptedKeys;
        PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO *ppRecipientEncryptedKey = NULL;
        DWORD dwRecipientEncryptedKeyIndex;

        pRecipientInfo = (PCMSG_CMS_RECIPIENT_INFO) AllocAndMsgGetParam(
            hMsg,
            CMSG_CMS_RECIPIENT_INFO_PARAM,
            dwRecipientIdx
            );
        if (pRecipientInfo == NULL) goto ErrorReturn;

        dwRecipientChoice = pRecipientInfo->dwRecipientChoice;
        switch (dwRecipientChoice) {
            case CMSG_KEY_TRANS_RECIPIENT:
                pKeyTrans = pRecipientInfo->pKeyTrans;
                cRecipientEncryptedKeys = 1;
                break;
            case CMSG_KEY_AGREE_RECIPIENT:
                pKeyAgree = pRecipientInfo->pKeyAgree;
                if (CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY !=
                        pKeyAgree->dwOriginatorChoice) {
                    SCAFree(pRecipientInfo);
                    pRecipientInfo = NULL;
                    continue;
                }
                cRecipientEncryptedKeys = pKeyAgree->cRecipientEncryptedKeys;
                ppRecipientEncryptedKey = pKeyAgree->rgpRecipientEncryptedKeys;
                break;
            default:
                SCAFree(pRecipientInfo);
                pRecipientInfo = NULL;
                continue;
        }

        for (dwRecipientEncryptedKeyIndex = 0;
                dwRecipientEncryptedKeyIndex < cRecipientEncryptedKeys;
                    dwRecipientEncryptedKeyIndex++) {
            PCERT_ID pRecipientId;
            DWORD dwStoreIdx;

            if (CMSG_KEY_TRANS_RECIPIENT == dwRecipientChoice)
                pRecipientId = &pKeyTrans->RecipientId;
            else {
                pRecipientId =
                    &ppRecipientEncryptedKey[
                        dwRecipientEncryptedKeyIndex]->RecipientId;
            }

            for (dwStoreIdx = 0;
                    dwStoreIdx < pDecryptPara->cCertStore; dwStoreIdx++) {
                pXchgCert = CertFindCertificateInStore(
                    pDecryptPara->rghCertStore[dwStoreIdx],
                    pDecryptPara->dwMsgAndCertEncodingType,
                    0,                                      // dwFindFlags
                    CERT_FIND_CERT_ID,
                    pRecipientId,
                    NULL                                    // pPrevCertContext
                    );

                if (pXchgCert) {
                    HCRYPTPROV hCryptProv;
                    DWORD dwKeySpec;
                    BOOL fDidCryptAcquire;
                    DWORD dwAcquireFlags;

                    dwAcquireFlags = CRYPT_ACQUIRE_USE_PROV_INFO_FLAG;
                    if (pDecryptPara->cbSize >=
                            STRUCT_CBSIZE(CRYPT_DECRYPT_MESSAGE_PARA, dwFlags)
                                        &&
                            (pDecryptPara->dwFlags &
                                CRYPT_MESSAGE_SILENT_KEYSET_FLAG))
                        dwAcquireFlags |= CRYPT_ACQUIRE_SILENT_FLAG;

                    fResult = CryptAcquireCertificatePrivateKey(
                        pXchgCert,
                        dwAcquireFlags,
                        NULL,                               // pvReserved
                        &hCryptProv,
                        &dwKeySpec,
                        &fDidCryptAcquire
                        );
                    if (fResult) {
                        if (CMSG_KEY_TRANS_RECIPIENT == dwRecipientChoice) {
                            CMSG_CTRL_KEY_TRANS_DECRYPT_PARA Para;

                            memset(&Para, 0, sizeof(Para));
                            Para.cbSize = sizeof(Para);
                            Para.hCryptProv = hCryptProv;
                            Para.dwKeySpec = dwKeySpec;
                            Para.pKeyTrans = pKeyTrans;
                            Para.dwRecipientIndex = dwRecipientIdx;
                            fResult = CryptMsgControl(
                                hMsg,
                                0,                  // dwFlags
                                CMSG_CTRL_KEY_TRANS_DECRYPT,
                                &Para
                                );
                        } else {
                            CMSG_CTRL_KEY_AGREE_DECRYPT_PARA Para;

                            memset(&Para, 0, sizeof(Para));
                            Para.cbSize = sizeof(Para);
                            Para.hCryptProv = hCryptProv;
                            Para.dwKeySpec = dwKeySpec;
                            Para.pKeyAgree = pKeyAgree;
                            Para.dwRecipientIndex = dwRecipientIdx;
                            Para.dwRecipientEncryptedKeyIndex =
                                dwRecipientEncryptedKeyIndex;
                            Para.OriginatorPublicKey =
                                pKeyAgree->OriginatorPublicKeyInfo.PublicKey;
                            fResult = CryptMsgControl(
                                hMsg,
                                0,                  // dwFlags
                                CMSG_CTRL_KEY_AGREE_DECRYPT,
                                &Para
                                );
                        }

                        if (fDidCryptAcquire) {
                            DWORD dwErr = GetLastError();
                            CryptReleaseContext(hCryptProv, 0);
                            SetLastError(dwErr);
                        }
                        if (fResult) {
                            if (ppXchgCert)
                                *ppXchgCert = pXchgCert;
                            else
                                CertFreeCertificateContext(pXchgCert);
                            goto CommonReturn;
                        } else
                            goto ErrorReturn;
                    }
                    CertFreeCertificateContext(pXchgCert);
                    pXchgCert = NULL;
                }
            }
        }
        SCAFree(pRecipientInfo);
        pRecipientInfo = NULL;
    }
    SetLastError((DWORD) CRYPT_E_NO_DECRYPT_CERT);

ErrorReturn:
    if (pXchgCert)
        CertFreeCertificateContext(pXchgCert);
    if (ppXchgCert)
        *ppXchgCert = NULL;
    fResult = FALSE;

CommonReturn:
    if (pRecipientInfo)
        SCAFree(pRecipientInfo);

    return fResult;
}

#else

//+-------------------------------------------------------------------------
// Get a certificate with a key provider property for one of the message's
// recipients and use to decrypt the message.
//--------------------------------------------------------------------------
static BOOL GetXchgCertAndDecrypt(
    IN PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN HCRYPTMSG hMsg,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert
    )
{
    BOOL fResult;
    PCERT_INFO pRecipientId = NULL;
    PCCERT_CONTEXT pXchgCert = NULL;
    DWORD cRecipient;
    DWORD cbData;
    DWORD dwRecipientIdx;
    DWORD dwStoreIdx;

    // Get # of recipients in the message.
    cbData = sizeof(cRecipient);
    cRecipient = 0;
    fResult = CryptMsgGetParam(
        hMsg,
        CMSG_RECIPIENT_COUNT_PARAM,
        0,                      // dwIndex
        &cRecipient,
        &cbData
        );
    if (!fResult) goto ErrorReturn;
    if (cRecipient == 0) {
        SetLastError((DWORD) CRYPT_E_RECIPIENT_NOT_FOUND);
        goto ErrorReturn;
    }

    // Loop through the recipients in the message until we find a
    // recipient cert in one of the stores with either the
    // CERT_KEY_CONTEXT_PROP_ID or CERT_KEY_PROV_INFO_PROP_ID.
    for (dwRecipientIdx = 0; dwRecipientIdx < cRecipient; dwRecipientIdx++) {
        // Allocate and get the CERT_INFO containing the RecipientId 
        // (Issuer and SerialNumber)
        pRecipientId = (PCERT_INFO) AllocAndMsgGetParam(
            hMsg,
            CMSG_RECIPIENT_INFO_PARAM,
            dwRecipientIdx
            );
        if (pRecipientId == NULL) goto ErrorReturn;
        for (dwStoreIdx = 0;
                dwStoreIdx < pDecryptPara->cCertStore; dwStoreIdx++) {
            pXchgCert = CertGetSubjectCertificateFromStore(
                pDecryptPara->rghCertStore[dwStoreIdx],
                pDecryptPara->dwMsgAndCertEncodingType,
                pRecipientId
                );
            if (pXchgCert) {
                CMSG_CTRL_DECRYPT_PARA Para;
                BOOL fDidCryptAcquire;
                Para.cbSize = sizeof(CMSG_CTRL_DECRYPT_PARA);
                fResult = CryptAcquireCertificatePrivateKey(
                    pXchgCert,
                    CRYPT_ACQUIRE_USE_PROV_INFO_FLAG,
                    NULL,                               // pvReserved
                    &Para.hCryptProv,
                    &Para.dwKeySpec,
                    &fDidCryptAcquire
                    );
                if (fResult) {
                    Para.dwRecipientIndex = dwRecipientIdx;
                    fResult = CryptMsgControl(
                        hMsg,
                        0,                  // dwFlags
                        CMSG_CTRL_DECRYPT,
                        &Para
                        );
                    if (fDidCryptAcquire) {
                        DWORD dwErr = GetLastError();
                        CryptReleaseContext(Para.hCryptProv, 0);
                        SetLastError(dwErr);
                    }
                    if (fResult) {
                        if (ppXchgCert)
                            *ppXchgCert = pXchgCert;
                        else
                            CertFreeCertificateContext(pXchgCert);
                        goto CommonReturn;
                    } else
                        goto ErrorReturn;
                }
                CertFreeCertificateContext(pXchgCert);
                pXchgCert = NULL;
            }
        }
        SCAFree(pRecipientId);
        pRecipientId = NULL;
    }
    SetLastError((DWORD) CRYPT_E_NO_DECRYPT_CERT);

ErrorReturn:
    if (pXchgCert)
        CertFreeCertificateContext(pXchgCert);
    if (ppXchgCert)
        *ppXchgCert = NULL;
    fResult = FALSE;

CommonReturn:
    if (pRecipientId)
        SCAFree(pRecipientId);

    return fResult;
}

#endif  // CMS_PKCS7

//+-------------------------------------------------------------------------
// Allocate and get the CMSG_SIGNER_CERT_INFO_PARAM or CMSG_RECIPIENT_INFO_PARAM
// from the message
//--------------------------------------------------------------------------
static void * AllocAndMsgGetParam(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex
    )
{
    BOOL fResult;
    void *pvData;
    DWORD cbData;

    // First get the length of the CertId's CERT_INFO
    cbData = 0;
    CryptMsgGetParam(
        hMsg,
        dwParamType,
        dwIndex,
        NULL,                   // pvData
        &cbData
        );
    if (cbData == 0) return NULL;
    pvData = SCAAlloc(cbData);
    if (pvData == NULL) return NULL;

    fResult = CryptMsgGetParam(
        hMsg,
        dwParamType,
        dwIndex,
        pvData,
        &cbData
        );
    if (fResult)
        return pvData;
    else {
        SCAFree(pvData);
        return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\revfunc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       revfunc.cpp
//
//  Contents:   Certificate Revocation Dispatch Functions
//
//  Functions:  I_CertRevFuncDllMain
//              CertVerifyRevocation
//
//  History:    12-Dec-96    philh   created
//              11-Mar-97    philh   changed signature of CertVerifyRevocation
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

static HCRYPTOIDFUNCSET hRevFuncSet;

typedef BOOL (WINAPI *PFN_CERT_DLL_VERIFY_REVOCATION)(
    IN DWORD dwEncodingType,
    IN DWORD dwRevType,
    IN DWORD cContext,
    IN PVOID rgpvContext[],
    IN DWORD dwFlags,
    IN OPTIONAL PCERT_REVOCATION_PARA pRevPara,
    IN OUT PCERT_REVOCATION_STATUS pRevStatus
    );

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertRevFuncDllMain(
        HMODULE hModule,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL    fRet;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        if (NULL == (hRevFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_VERIFY_REVOCATION_FUNC,
                0)))                                // dwFlags
            goto CryptInitOIDFunctionSetError;
        break;

    case DLL_PROCESS_DETACH:
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CryptInitOIDFunctionSetError)
}

static inline void ZeroRevStatus(OUT PCERT_REVOCATION_STATUS pRevStatus)
{
    DWORD cbSize = pRevStatus->cbSize;
    
    memset(pRevStatus, 0, cbSize);
    pRevStatus->cbSize = cbSize;
}

// Remember the first "interesting" error. *pdwError is initialized to
// CRYPT_E_NO_REVOCATION_DLL.
static void UpdateNoRevocationCheckStatus(
    IN PCERT_REVOCATION_STATUS pRevStatus,
    IN OUT DWORD *pdwError,
    IN OUT DWORD *pdwReason,
    IN OUT BOOL *pfHasFreshnessTime,
    IN OUT DWORD *pdwFreshnessTime
    )
{
    if (pRevStatus->dwError &&
            (*pdwError == (DWORD) CRYPT_E_NO_REVOCATION_DLL ||
                *pdwError == (DWORD) CRYPT_E_NO_REVOCATION_CHECK)) {
        *pdwError = pRevStatus->dwError;
        *pdwReason = pRevStatus->dwReason;

        if (pRevStatus->cbSize >= STRUCT_CBSIZE(CERT_REVOCATION_STATUS,
                dwFreshnessTime)) {
            *pfHasFreshnessTime = pRevStatus->fHasFreshnessTime;
            *pdwFreshnessTime = pRevStatus->dwFreshnessTime;
        }
    }
}

static BOOL VerifyDefaultRevocation(
    IN DWORD dwEncodingType,
    IN DWORD dwRevType,
    IN DWORD cContext,
    IN PVOID rgpvContext[],
    IN DWORD dwFlags,
    IN FILETIME *pftEndUrlRetrieval,
    IN OPTIONAL PCERT_REVOCATION_PARA pRevPara,
    IN OUT PCERT_REVOCATION_STATUS pRevStatus
    )
{
    BOOL fResult;
    DWORD dwError = (DWORD) CRYPT_E_NO_REVOCATION_DLL;
    DWORD dwReason = 0;
    BOOL fHasFreshnessTime = FALSE;
    DWORD dwFreshnessTime = 0;
    LPWSTR pwszDllList;       // _alloca'ed
    DWORD cchDllList;
    DWORD cchDll;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    // Iterate through the installed default functions.
    // Setting pwszDll to NULL searches the installed list. Setting
    // hFuncAddr to NULL starts the search at the beginning.
    hFuncAddr = NULL;
    while (CryptGetDefaultOIDFunctionAddress(
                hRevFuncSet,
                dwEncodingType,
                NULL,               // pwszDll
                0,                  // dwFlags
                &pvFuncAddr,
                &hFuncAddr)) {
        ZeroRevStatus(pRevStatus);

        if (dwFlags & CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG) {
            pRevPara->dwUrlRetrievalTimeout =
                I_CryptRemainingMilliseconds(pftEndUrlRetrieval);
            if (0 == pRevPara->dwUrlRetrievalTimeout)
                pRevPara->dwUrlRetrievalTimeout = 1;
        }

        fResult = ((PFN_CERT_DLL_VERIFY_REVOCATION) pvFuncAddr)(
                dwEncodingType,
                dwRevType,
                cContext,
                rgpvContext,
                dwFlags,
                pRevPara,
                pRevStatus);
        if (fResult || CRYPT_E_REVOKED == pRevStatus->dwError ||
                0 < pRevStatus->dwIndex) {
            // All contexts successfully checked, one of the contexts
            // was revoked or successfully able to check at least one
            // of the contexts.
            CryptFreeOIDFunctionAddress(hFuncAddr, 0);
            goto CommonReturn;
        } else
            // Unable to check revocation for this installed
            // function. However, remember any "interesting"
            // errors such as, offline.
            UpdateNoRevocationCheckStatus(pRevStatus, &dwError, &dwReason,
                &fHasFreshnessTime, &dwFreshnessTime);
    }

    if (!CryptGetDefaultOIDDllList(
            hRevFuncSet,
            dwEncodingType,
            NULL,               // pszDllList
            &cchDllList)) goto GetDllListError;
    __try {
        pwszDllList = (LPWSTR) _alloca(cchDllList * sizeof(WCHAR));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        goto OutOfMemory;
    }
    if (!CryptGetDefaultOIDDllList(
            hRevFuncSet,
            dwEncodingType,
            pwszDllList,
            &cchDllList)) goto GetDllListError;

    for (; 0 != (cchDll = wcslen(pwszDllList)); pwszDllList += cchDll + 1) {
        if (CryptGetDefaultOIDFunctionAddress(
                hRevFuncSet,
                dwEncodingType,
                pwszDllList,
                0,              // dwFlags
                &pvFuncAddr,
                &hFuncAddr)) {
            ZeroRevStatus(pRevStatus);

            if (dwFlags & CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG) {
                pRevPara->dwUrlRetrievalTimeout =
                    I_CryptRemainingMilliseconds(pftEndUrlRetrieval);
                if (0 == pRevPara->dwUrlRetrievalTimeout)
                    pRevPara->dwUrlRetrievalTimeout = 1;
            }

            fResult = ((PFN_CERT_DLL_VERIFY_REVOCATION) pvFuncAddr)(
                    dwEncodingType,
                    dwRevType,
                    cContext,
                    rgpvContext,
                    dwFlags,
                    pRevPara,
                    pRevStatus);
            CryptFreeOIDFunctionAddress(hFuncAddr, 0);
            if (fResult || CRYPT_E_REVOKED == pRevStatus->dwError ||
                    0 < pRevStatus->dwIndex)
                // All contexts successfully checked, one of the contexts
                // was revoked or successfully able to check at least one
                // of the contexts.
                goto CommonReturn;
            else
                // Unable to check revocation for this registered
                // function. However, remember any "interesting"
                // errors such as, offline.
                UpdateNoRevocationCheckStatus(pRevStatus, &dwError, &dwReason,
                    &fHasFreshnessTime, &dwFreshnessTime);
        }
    }

    goto ErrorReturn;

CommonReturn:
    return fResult;
ErrorReturn:
    pRevStatus->dwIndex = 0;
    pRevStatus->dwError = dwError;
    pRevStatus->dwReason = dwReason;

    if (pRevStatus->cbSize >= STRUCT_CBSIZE(CERT_REVOCATION_STATUS,
            dwFreshnessTime)) {
        pRevStatus->fHasFreshnessTime = fHasFreshnessTime;
        pRevStatus->dwFreshnessTime = dwFreshnessTime;
    }

    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetDllListError)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Verifies the array of contexts for revocation. The dwRevType parameter
//  indicates the type of the context data structure passed in rgpvContext.
//  Currently only the revocation of certificates is defined.
//
//  If the CERT_VERIFY_REV_CHAIN_FLAG flag is set, then, CertVerifyRevocation
//  is verifying a chain of certs where, rgpvContext[i + 1] is the issuer
//  of rgpvContext[i]. Otherwise, CertVerifyRevocation makes no assumptions
//  about the order of the contexts.
//
//  To assist in finding the issuer, the pRevPara may optionally be set. See
//  the CERT_REVOCATION_PARA data structure for details.
//
//  The contexts must contain enough information to allow the
//  installable or registered revocation DLLs to find the revocation server. For
//  certificates, this information would normally be conveyed in an
//  extension such as the IETF's AuthorityInfoAccess extension.
//
//  CertVerifyRevocation returns TRUE if all of the contexts were successfully
//  checked and none were revoked. Otherwise, returns FALSE and updates the
//  returned pRevStatus data structure as follows:
//    dwIndex
//      Index of the first context that was revoked or unable to
//      be checked for revocation
//    dwError
//      Error status. LastError is also set to this error status.
//      dwError can be set to one of the following error codes defined
//      in winerror.h:
//        ERROR_SUCCESS - good context
//        CRYPT_E_REVOKED - context was revoked. dwReason contains the
//           reason for revocation
//        CRYPT_E_REVOCATION_OFFLINE - unable to connect to the
//           revocation server
//        CRYPT_E_NOT_IN_REVOCATION_DATABASE - the context to be checked
//           was not found in the revocation server's database.
//        CRYPT_E_NO_REVOCATION_CHECK - the called revocation function
//           wasn't able to do a revocation check on the context
//        CRYPT_E_NO_REVOCATION_DLL - no installed or registered Dll was
//           found to verify revocation
//    dwReason
//      The dwReason is currently only set for CRYPT_E_REVOKED and contains
//      the reason why the context was revoked. May be one of the following
//      CRL reasons defined by the CRL Reason Code extension ("2.5.29.21")
//          CRL_REASON_UNSPECIFIED              0
//          CRL_REASON_KEY_COMPROMISE           1
//          CRL_REASON_CA_COMPROMISE            2
//          CRL_REASON_AFFILIATION_CHANGED      3
//          CRL_REASON_SUPERSEDED               4
//          CRL_REASON_CESSATION_OF_OPERATION   5
//          CRL_REASON_CERTIFICATE_HOLD         6
//
//  For each entry in rgpvContext, CertVerifyRevocation iterates
//  through the CRYPT_OID_VERIFY_REVOCATION_FUNC
//  function set's list of installed DEFAULT functions.
//  CryptGetDefaultOIDFunctionAddress is called with pwszDll = NULL. If no
//  installed functions are found capable of doing the revocation verification,
//  CryptVerifyRevocation iterates through CRYPT_OID_VERIFY_REVOCATION_FUNC's
//  list of registered DEFAULT Dlls. CryptGetDefaultOIDDllList is called to
//  get the list. CryptGetDefaultOIDFunctionAddress is called to load the Dll.
//
//  The called functions have the same signature as CertVerifyRevocation. A
//  called function returns TRUE if it was able to successfully check all of
//  the contexts and none were revoked. Otherwise, the called function returns
//  FALSE and updates pRevStatus. dwIndex is set to the index of
//  the first context that was found to be revoked or unable to be checked.
//  dwError and LastError are updated. For CRYPT_E_REVOKED, dwReason
//  is updated. Upon input to the called function, dwIndex, dwError and
//  dwReason have been zero'ed. cbSize has been checked to be >=
//  sizeof(CERT_REVOCATION_STATUS).
//  
//  If the called function returns FALSE, and dwError isn't set to
//  CRYPT_E_REVOKED, then, CertVerifyRevocation either continues on to the
//  next DLL in the list for a returned dwIndex of 0 or for a returned
//  dwIndex > 0, restarts the process of finding a verify function by
//  advancing the start of the context array to the returned dwIndex and
//  decrementing the count of remaining contexts.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertVerifyRevocation(
    IN DWORD dwEncodingType,
    IN DWORD dwRevType,
    IN DWORD cContext,
    IN PVOID rgpvContext[],
    IN DWORD dwFlags,
    IN OPTIONAL PCERT_REVOCATION_PARA pRevPara,
    IN OUT PCERT_REVOCATION_STATUS pRevStatus
    )
{
    BOOL fResult = FALSE;
    DWORD dwIndex;

    // Following are only used for CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG
    CERT_REVOCATION_PARA RevPara;
    FILETIME ftEndUrlRetrieval;

    assert(pRevStatus->cbSize >= STRUCT_CBSIZE(CERT_REVOCATION_STATUS,
            dwReason));
    if (pRevStatus->cbSize < STRUCT_CBSIZE(CERT_REVOCATION_STATUS,
            dwReason))
        goto InvalidArg;

    if (dwFlags & CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG) {
        // RevPara.dwUrlRetrievalTimeout will be updated with the remaining
        // timeout

        memset(&RevPara, 0, sizeof(RevPara));
        if (pRevPara != NULL)
            memcpy(&RevPara, pRevPara, min(pRevPara->cbSize, sizeof(RevPara)));
        RevPara.cbSize = sizeof(RevPara);
        if (0 == RevPara.dwUrlRetrievalTimeout)
            dwFlags &= ~CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG;
        else {
            FILETIME ftCurrent;

            GetSystemTimeAsFileTime(&ftCurrent);
            I_CryptIncrementFileTimeByMilliseconds(
                &ftCurrent, RevPara.dwUrlRetrievalTimeout, &ftEndUrlRetrieval);

            pRevPara = &RevPara;
        }
    }

    dwIndex = 0;
    while (dwIndex < cContext) {
        fResult = VerifyDefaultRevocation(
                dwEncodingType,
                dwRevType,
                cContext - dwIndex,
                &rgpvContext[dwIndex],
                dwFlags,
                &ftEndUrlRetrieval,
                pRevPara,
                pRevStatus
                );
        if (fResult)
            // All contexts successfully checked.
            break;
        else if (CRYPT_E_REVOKED == pRevStatus->dwError ||
                0 == pRevStatus->dwIndex) {
            // One of the contexts was revoked or unable to check the
            // dwIndex context.
            pRevStatus->dwIndex += dwIndex;
            SetLastError(pRevStatus->dwError);
            break;
        } else
            // Advance past the checked contexts
            dwIndex += pRevStatus->dwIndex;
    }

    if (dwIndex >= cContext) {
        // Able to check all the contexts
        fResult = TRUE;
        pRevStatus->dwIndex = 0;
        pRevStatus->dwError = 0;
        pRevStatus->dwReason = 0;
    }

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\scrdcert.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       scrdcert.cpp
//
//  Contents:   Smart Card Certificate API
//
//  History:    11-24-1997    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <dbgdef.h>
//+---------------------------------------------------------------------------
//
//  Function:   I_CryptRegisterSmartCardStore
//
//  Synopsis:   register smart card store
//
//----------------------------------------------------------------------------
BOOL WINAPI
I_CryptRegisterSmartCardStore (
       IN LPCWSTR pwszCardName,
       IN OPTIONAL LPCWSTR pwszProvider,
       IN OPTIONAL DWORD dwProviderType,
       IN OPTIONAL LPCWSTR pwszContainer,
       IN DWORD dwFlags
       )
{
    BOOL                     fResult;
    DWORD                    cw;
    CHAR                     szProviderType[MAX_PROVIDER_TYPE_STRLEN];
    WCHAR                    wszProviderType[MAX_PROVIDER_TYPE_STRLEN];
    LPWSTR                   pwszOpenFilter;
    DWORD                    dwRegisterFlags = 0;
    CERT_SYSTEM_STORE_INFO   cssi;
    CERT_PHYSICAL_STORE_INFO cpsi;
    
    cw = wcslen( pwszCardName ) + 1;
    
    if ( pwszProvider == NULL )
    {
        pwszProvider = MS_BASE_PROVIDER;
    }
    
    cw += wcslen( pwszProvider ) + 1;
    cw += MAX_PROVIDER_TYPE_STRLEN + 1;
    
    if ( pwszContainer == NULL )
    {
        pwszContainer = pwszCardName;
    }
    
    cw += wcslen( pwszContainer ) + 1;
    
    pwszOpenFilter = new WCHAR [cw];
    if ( pwszOpenFilter == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }
    
    _ultoa( dwProviderType, szProviderType, 10 );
    
    MultiByteToWideChar(
         CP_ACP,
         0,
         szProviderType,
         MAX_PROVIDER_TYPE_STRLEN,
         wszProviderType,
         MAX_PROVIDER_TYPE_STRLEN
         );
    
    wcscpy( pwszOpenFilter, pwszCardName );
    wcscat( pwszOpenFilter, L"\\" );
    wcscat( pwszOpenFilter, pwszProvider );
    wcscat( pwszOpenFilter, L"\\" );
    wcscat( pwszOpenFilter, wszProviderType );
    wcscat( pwszOpenFilter, L"\\" );
    wcscat( pwszOpenFilter, pwszContainer );
    
    memset( &cssi, 0, sizeof( cssi ) );
    cssi.cbSize = sizeof( cssi );
           
    // What about the localized name property?                      
    CertRegisterSystemStore(
        SMART_CARD_SYSTEM_STORE,
        CERT_SYSTEM_STORE_CURRENT_USER,
        &cssi,
        NULL
        );
    
    memset( &cpsi, 0, sizeof( cpsi ) );
    cpsi.cbSize = sizeof( cpsi );
    cpsi.pszOpenStoreProvider = sz_CERT_STORE_PROV_SMART_CARD;
    cpsi.OpenParameters.cbData = cw * sizeof( WCHAR );
    cpsi.OpenParameters.pbData = (LPBYTE)pwszOpenFilter;
    cpsi.dwFlags = CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG;
    cpsi.dwFlags |= CERT_PHYSICAL_STORE_REMOTE_OPEN_DISABLE_FLAG;
    
    if ( !( dwFlags & SMART_CARD_STORE_REPLACE_EXISTING ) )
    {
        dwRegisterFlags |= CERT_STORE_CREATE_NEW_FLAG;
    }
          
    fResult = CertRegisterPhysicalStore(
                  SMART_CARD_SYSTEM_STORE,
                  dwRegisterFlags | CERT_SYSTEM_STORE_CURRENT_USER,
                  pwszCardName,
                  &cpsi,
                  NULL
                  );
                  
    delete pwszOpenFilter;
    
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptUnregisterSmartCardStore
//
//  Synopsis:   unregister a smart card store
//
//----------------------------------------------------------------------------
BOOL WINAPI
I_CryptUnregisterSmartCardStore (
       IN LPCWSTR pwszCardName
       )
{
    return( CertUnregisterPhysicalStore(
                SMART_CARD_SYSTEM_STORE,
                CERT_SYSTEM_STORE_CURRENT_USER,
                pwszCardName
                ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptFindSmartCardCertInStore
//
//  Synopsis:   find a smart card certificate matching the given criteria
//
//----------------------------------------------------------------------------
PCCERT_CONTEXT WINAPI
I_CryptFindSmartCardCertInStore (
       IN HCERTSTORE hStore,
       IN PCCERT_CONTEXT pPrevCert,
       IN OPTIONAL PSMART_CARD_CERT_FIND_DATA pFindData,
       IN OUT OPTIONAL PCRYPT_DATA_BLOB* ppSmartCardData
       )
{
    BOOL             fResult;
    BOOL             fFound = FALSE;
    PCCERT_CONTEXT   pCertContext = pPrevCert;
    DWORD            cb;
    PCRYPT_DATA_BLOB pSmartCardData = NULL;
    DWORD            dwPropId = CERT_SMART_CARD_DATA_PROP_ID;
    
    assert( hStore != NULL );
    
    while ( fFound == FALSE )
    {
        pCertContext = CertFindCertificateInStore(
                           hStore,
                           X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                           0,
                           CERT_FIND_PROPERTY,
                           (const void *)&dwPropId,
                           pCertContext
                           );
                           
        if ( ( ppSmartCardData != NULL ) && ( *ppSmartCardData != NULL ) )
        {
            LocalFree( (HLOCAL)*ppSmartCardData );
            *ppSmartCardData = NULL;
        }
                                                       
        if ( pCertContext != NULL )
        {
            if ( pFindData != NULL )
            {
                PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
                
                fResult = CertGetCertificateContextProperty(
                              pCertContext,
                              CERT_KEY_PROV_INFO_PROP_ID,
                              NULL,
                              &cb
                              );
                              
                if ( fResult == TRUE )
                {
                    pKeyProvInfo = (PCRYPT_KEY_PROV_INFO)new BYTE [cb];
                    if ( pKeyProvInfo != NULL )
                    {
                        fResult = CertGetCertificateContextProperty(
                                      pCertContext,
                                      CERT_KEY_PROV_INFO_PROP_ID,
                                      pKeyProvInfo,
                                      &cb  
                                      );
                    }
                    else
                    {
                        fResult = FALSE;
                    }
                }
                
                if ( fResult == TRUE )
                {
                    fFound = TRUE;
                    
                    if ( ( pFindData->pwszProvider != NULL ) &&
                         ( _wcsicmp( 
                               pKeyProvInfo->pwszProvName, 
                               pFindData->pwszProvider
                               ) != 0 ) )
                    {
                        fFound = FALSE;
                    }
                    
                    if ( ( pFindData->dwProviderType != 0 ) &&
                         ( pKeyProvInfo->dwProvType != 
                           pFindData->dwProviderType ) )
                    {
                        fFound = FALSE;
                    }
                    
                    if ( ( pFindData->pwszContainer != NULL ) &&
                         ( _wcsicmp( 
                               pKeyProvInfo->pwszContainerName, 
                               pFindData->pwszContainer
                               ) != 0 ) )
                    {
                        fFound = FALSE;
                    }
                    
                    if ( ( pFindData->dwKeySpec != 0 ) &&
                         ( pKeyProvInfo->dwKeySpec != 
                           pFindData->dwKeySpec ) )
                    {
                        fFound = FALSE;
                    }
                }
                
                delete (LPBYTE)pKeyProvInfo;
            }
            else
            {
                fFound = TRUE;
            }
        }
        else
        {
            fFound = TRUE;
        }
    }
    
    assert( fFound == TRUE );
    
    if ( ( ppSmartCardData != NULL ) && ( pCertContext != NULL ) )
    {
        fResult = CertGetCertificateContextProperty(
                      pCertContext,
                      CERT_SMART_CARD_DATA_PROP_ID,
                      NULL,
                      &cb
                      );
                      
        if ( fResult == TRUE )
        {
            pSmartCardData = (PCRYPT_DATA_BLOB)LocalAlloc( 
                                                    GPTR, 
                                                    cb + sizeof( CRYPT_DATA_BLOB )
                                                    );
                                          
            if ( pSmartCardData != NULL )
            {
                pSmartCardData->cbData = cb;
                pSmartCardData->pbData = (LPBYTE)pSmartCardData + sizeof( CRYPT_DATA_BLOB );
                
                fResult = CertGetCertificateContextProperty(
                              pCertContext,
                              CERT_SMART_CARD_DATA_PROP_ID,
                              pSmartCardData->pbData,
                              &cb
                              );
            }
            else
            {
                fResult = FALSE;
            }
        }
        
        if ( fResult == TRUE )
        {
            *ppSmartCardData = pSmartCardData;
        }
        else
        {
            if ( pSmartCardData != NULL )
            {
                LocalFree( (HLOCAL)pSmartCardData );
            }
            
            CertFreeCertificateContext( pCertContext );
            pCertContext = NULL;
        }
    }
    
    return( pCertContext );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptAddSmartCardCertToStore
//
//  Synopsis:   add a smart card certificate to the specified store
//
//----------------------------------------------------------------------------
BOOL WINAPI
I_CryptAddSmartCardCertToStore (
       IN HCERTSTORE hStore,
       IN PCRYPT_DATA_BLOB pEncodedCert,
       IN OPTIONAL LPWSTR pwszCertFriendlyName,
       IN PCRYPT_DATA_BLOB pSmartCardData,
       IN PCRYPT_KEY_PROV_INFO pKeyProvInfo
       )
{
    BOOL            fResult = TRUE;
    PCCERT_CONTEXT  pCertContext;
    CRYPT_DATA_BLOB DataBlob;
    
    pCertContext = CertCreateCertificateContext(
                       X509_ASN_ENCODING,
                       pEncodedCert->pbData,
                       pEncodedCert->cbData
                       );
                  
    if ( pCertContext == NULL )
    {
        return( FALSE );
    }
    
    if ( pwszCertFriendlyName != NULL )
    {
        DataBlob.cbData = ( wcslen( pwszCertFriendlyName ) + 1 ) * sizeof( WCHAR );
        DataBlob.pbData = (LPBYTE)pwszCertFriendlyName;
        
        fResult = CertSetCertificateContextProperty(
                      pCertContext,
                      CERT_FRIENDLY_NAME_PROP_ID,
                      0,
                      (const void *)&DataBlob
                      );
    }
    
    if ( fResult == TRUE )
    {
        fResult = CertSetCertificateContextProperty(
                      pCertContext,
                      CERT_SMART_CARD_DATA_PROP_ID,
                      0,
                      (const void *)pSmartCardData
                      );
    }
    
    if ( fResult == TRUE )
    {
        fResult = CertSetCertificateContextProperty(
                      pCertContext,
                      CERT_KEY_PROV_INFO_PROP_ID,
                      0,
                      (const void *)pKeyProvInfo
                      );
    }
    
    if ( fResult == TRUE )
    {
        fResult = CertAddCertificateContextToStore(
                      hStore,
                      pCertContext,
                      CERT_STORE_ADD_REPLACE_EXISTING,
                      NULL
                      );
    }
                  
    CertFreeCertificateContext( pCertContext );
    
    return( fResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\selfsign.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       selfsign.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

PCCERT_CONTEXT
WINAPI
CertCreateSelfSignCertificate(
    IN          HCRYPTPROV                  hProv,          
    IN          PCERT_NAME_BLOB             pSubjectIssuerBlob,
    IN          DWORD                       dwFlags,
    OPTIONAL    PCRYPT_KEY_PROV_INFO        pKeyProvInfo,
    OPTIONAL    PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    OPTIONAL    PSYSTEMTIME                 pStartTime,
    OPTIONAL    PSYSTEMTIME                 pEndTime,
    OPTIONAL    PCERT_EXTENSIONS            pExtensions
    ) {

    PCCERT_CONTEXT              pCertContext    = NULL;
    DWORD                       errBefore       = GetLastError();
    DWORD                       err             = ERROR_SUCCESS;
    DWORD                       cbPubKeyInfo    = 0;
    PCERT_PUBLIC_KEY_INFO       pPubKeyInfo     = NULL;
    BYTE *                      pbCert          = NULL;
    DWORD                       cbCert          = 0;
    LPSTR                       sz              = NULL;
    DWORD                       cb              = 0;

    CERT_INFO                   certInfo;
    GUID                        serialNbr;
    CRYPT_KEY_PROV_INFO         keyProvInfo;
    CERT_SIGNED_CONTENT_INFO    sigInfo;
    
    CRYPT_ALGORITHM_IDENTIFIER  algID;

    LPWSTR                      wsz             = NULL;
    BOOL                        fFreehProv      = FALSE;
    HCRYPTKEY                   hKey            = NULL;
    UUID                        guidContainerName;
    RPC_STATUS                  RpcStatus;

    memset(&certInfo, 0, sizeof(CERT_INFO));
    memset(&serialNbr, 0, sizeof(serialNbr));
    memset(&keyProvInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));
    memset(&sigInfo, 0, sizeof(CERT_SIGNED_CONTENT_INFO));

    // do key spec now because we need it
    if(pKeyProvInfo == NULL) 
        keyProvInfo.dwKeySpec = AT_SIGNATURE;
    else 
        keyProvInfo.dwKeySpec = pKeyProvInfo->dwKeySpec;

    // see if we have an hProv, if not, create one
    if(hProv == NULL) {

        fFreehProv = TRUE;

        // if not prov info, make one up, signing RSA cert, default provider
        if(pKeyProvInfo == NULL) {

            RpcStatus = UuidCreate(&guidContainerName);
            if (!(RPC_S_OK == RpcStatus ||
                    RPC_S_UUID_LOCAL_ONLY == RpcStatus)) {
                // Use stack randomness
                ;
            }
            UuidToStringU(&guidContainerName, &wsz);
        
    	    if( !CryptAcquireContextU(
    	        &hProv,
                 wsz,
                 NULL,
                 PROV_RSA_FULL,
                 CRYPT_NEWKEYSET) ) {
                 hProv = NULL;
                goto ErrorCryptAcquireContext;                
            }
        }
        else {

            // first use the existing keyset
    	    if( !CryptAcquireContextU(
    	        &hProv,
                 pKeyProvInfo->pwszContainerName,
                 pKeyProvInfo->pwszProvName,
                 pKeyProvInfo->dwProvType,
                 pKeyProvInfo->dwFlags) )  {

                // otherwise generate a keyset
        	    if( !CryptAcquireContextU(
        	        &hProv,
                     pKeyProvInfo->pwszContainerName,
                     pKeyProvInfo->pwszProvName,
                     pKeyProvInfo->dwProvType,
                     pKeyProvInfo->dwFlags | CRYPT_NEWKEYSET) )  {
                    hProv = NULL;
                    goto ErrorCryptAcquireContext; 
                }
            }
        }

        // we have the keyset, now make sure we have the key gen'ed
        if( !CryptGetUserKey(   hProv,
                                keyProvInfo.dwKeySpec,
                                &hKey) ) {

            // doesn't exist so gen it                        
            assert(hKey == NULL);
            if(!CryptGenKey(    hProv, 
                                keyProvInfo.dwKeySpec, 
                                0,
                                &hKey) ) {
                goto ErrorCryptGenKey;
            }
        }
    }

    __try {
        // get the exportable public key bits
        if( !CryptExportPublicKeyInfo( hProv,
                                keyProvInfo.dwKeySpec, 
                                X509_ASN_ENCODING,
                                NULL, 
                                &cbPubKeyInfo)                              ||
            (pPubKeyInfo =
                (PCERT_PUBLIC_KEY_INFO) _alloca(cbPubKeyInfo)) == NULL      ||
            !CryptExportPublicKeyInfo( hProv,
                                keyProvInfo.dwKeySpec, 
                                X509_ASN_ENCODING,
                                pPubKeyInfo,
                                &cbPubKeyInfo) )
            goto ErrorCryptExportPublicKeyInfo;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        goto ErrorCryptExportPublicKeyInfo;
    }

    // default if we don't have an algid
    if(pSignatureAlgorithm == NULL) {
        memset(&algID, 0, sizeof(algID));
        algID.pszObjId = szOID_OIWSEC_sha1RSASign;
        pSignatureAlgorithm = &algID;
    }

    // make a temp cert, only care about key info
    // and serial number for uniqueness
    RpcStatus = UuidCreate(&serialNbr);
    if (!(RPC_S_OK == RpcStatus || RPC_S_UUID_LOCAL_ONLY == RpcStatus)) {
        // Use stack randomness.
        ;
    }
    certInfo.dwVersion              = CERT_V3;
    certInfo.SubjectPublicKeyInfo   = *pPubKeyInfo;
    certInfo.SerialNumber.cbData    = sizeof(serialNbr);
    certInfo.SerialNumber.pbData    = (BYTE *) &serialNbr;
    certInfo.SignatureAlgorithm     = *pSignatureAlgorithm;
    certInfo.Issuer                 = *pSubjectIssuerBlob;
    certInfo.Subject                = *pSubjectIssuerBlob;

    // only put in extensions if we have them
    if( pExtensions != NULL) {
        certInfo.cExtension             = pExtensions->cExtension;
        certInfo.rgExtension            = pExtensions->rgExtension;
    }

    //default if we don't have times
    if(pStartTime == NULL)
	GetSystemTimeAsFileTime(&certInfo.NotBefore);
    else if(!SystemTimeToFileTime(pStartTime, &certInfo.NotBefore))
	goto ErrorSystemTimeToFileTime;

    if(pEndTime == NULL)
	*(((DWORDLONG UNALIGNED *) &certInfo.NotAfter)) =
	    *(((DWORDLONG UNALIGNED *) &certInfo.NotBefore)) +
	    0x11F03C3613000i64;
    else if(!SystemTimeToFileTime(pEndTime, &certInfo.NotAfter))
	goto ErrorSystemTimeToFileTime;
    
    __try {
        // encode the cert
        if( !CryptEncodeObject(
                CRYPT_ASN_ENCODING, X509_CERT_TO_BE_SIGNED,
                &certInfo,
                NULL,           // pbEncoded
                &sigInfo.ToBeSigned.cbData
                )                                               ||
            (sigInfo.ToBeSigned.pbData = (BYTE *) 
                _alloca(sigInfo.ToBeSigned.cbData)) == NULL     ||
            !CryptEncodeObject(
                CRYPT_ASN_ENCODING, X509_CERT_TO_BE_SIGNED,
                &certInfo,
                sigInfo.ToBeSigned.pbData,
                &sigInfo.ToBeSigned.cbData
                ) ) 
            goto ErrorEncodeTempCertToBeSigned;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        goto ErrorEncodeTempCertToBeSigned;
    }

    // sign the certificate
    sigInfo.SignatureAlgorithm = certInfo.SignatureAlgorithm;

    // this is to work around an OSS bug of not accepting zero length bit strings
    // this is only needed if we don't actually sign the code.
    sigInfo.Signature.pbData = (BYTE *) &sigInfo;
    sigInfo.Signature.cbData = 1;
    
    if( (CERT_CREATE_SELFSIGN_NO_SIGN & dwFlags) == 0 ) {

        __try {
            if( !CryptSignCertificate(
                    hProv,
                    keyProvInfo.dwKeySpec,
                    CRYPT_ASN_ENCODING,
                    sigInfo.ToBeSigned.pbData,
                    sigInfo.ToBeSigned.cbData,
                    &sigInfo.SignatureAlgorithm,
                    NULL,
                    NULL,
                    &sigInfo.Signature.cbData)      ||
            (sigInfo.Signature.pbData = (BYTE *) 
                _alloca(sigInfo.Signature.cbData)) == NULL     ||
            !CryptSignCertificate(
                    hProv,
                    keyProvInfo.dwKeySpec,
                    CRYPT_ASN_ENCODING,
                    sigInfo.ToBeSigned.pbData,
                    sigInfo.ToBeSigned.cbData,
                    &sigInfo.SignatureAlgorithm,
                    NULL,
                    sigInfo.Signature.pbData,
                    &sigInfo.Signature.cbData)  )
                goto ErrorCryptSignCertificate;
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            goto ErrorCryptSignCertificate;
        }
    }
    
    __try {
        // encode the final cert.
        if( !CryptEncodeObject(
                CRYPT_ASN_ENCODING,
                X509_CERT,
                &sigInfo,
                NULL,
                &cbCert
                )                               ||
            (pbCert = (BYTE *)               
                _alloca(cbCert)) == NULL     ||
            !CryptEncodeObject(
                CRYPT_ASN_ENCODING,
                X509_CERT,
                &sigInfo,
                pbCert, 
                &cbCert ) ) 
            goto ErrorEncodeTempCert;            
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        goto ErrorEncodeTempCert;            
    }

     // get a cert context from the encoding
    if( (pCertContext = CertCreateCertificateContext(
        CRYPT_ASN_ENCODING,
        pbCert,
        cbCert)) == NULL ) 
        goto ErrorCreateTempCertContext;

    if( (CERT_CREATE_SELFSIGN_NO_KEY_INFO & dwFlags) == 0 ) {
    
        // get the key prov info
        if(pKeyProvInfo == NULL)   {
        
            __try {
                // get a key prov info from the hProv
                if( !CryptGetProvParam( hProv,
                                    PP_NAME,
                                    NULL,
                                    &cb,
                                    0)                  ||
                    (sz = (char *) _alloca(cb)) == NULL ||
                    !CryptGetProvParam( hProv,
                                    PP_NAME,
                                    (BYTE *) sz,
                                    &cb,
                                    0) )
                    goto ErrorGetProvName;
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                goto ErrorGetProvName;
            }
            keyProvInfo.pwszProvName = MkWStr(sz);

            cb = 0; 
            sz = NULL;
            __try {
                if( !CryptGetProvParam( hProv,
                                    PP_CONTAINER,
                                    NULL,
                                    &cb,
                                    0)                  ||
                    (sz = (char *) _alloca(cb)) == NULL ||
                    !CryptGetProvParam( hProv,
                                    PP_CONTAINER,
                                    (BYTE *) sz,
                                    &cb,
                                    0) )
                    goto ErrorGetContainerName;
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                goto ErrorGetContainerName;
            }
            keyProvInfo.pwszContainerName = MkWStr(sz);

            cb = sizeof(keyProvInfo.dwProvType);
            if( !CryptGetProvParam( hProv,
                                PP_PROVTYPE,
                                (BYTE *) &keyProvInfo.dwProvType,
                                &cb,
                                0) )
                goto ErrorGetProvType;
            
            pKeyProvInfo = &keyProvInfo;
        }

        // put the key property on the certificate
        if( !CertSetCertificateContextProperty(
                pCertContext,
                CERT_KEY_PROV_INFO_PROP_ID,
                0,
                pKeyProvInfo) )
            goto ErrorSetTempCertPropError;
    }
        
CommonReturn:

    if(hKey != NULL)
        CryptDestroyKey(hKey);
        
    if(fFreehProv && hProv != NULL)
        CryptReleaseContext(hProv, 0);
        
    if(keyProvInfo.pwszProvName != NULL)
        FreeWStr(keyProvInfo.pwszProvName);

    if(keyProvInfo.pwszContainerName != NULL)
        FreeWStr(keyProvInfo.pwszContainerName);

    if(wsz != NULL)
        LocalFree(wsz);

    // don't know if we have an error or not
    // but I do know the errBefore is set properly
    SetLastError(errBefore);

    return(pCertContext);

ErrorReturn:

    if(GetLastError() == ERROR_SUCCESS) 
        SetLastError((DWORD) E_UNEXPECTED);
    err = GetLastError();

    // We have an error, make sure we set it.
    errBefore = GetLastError();

    if(pCertContext != NULL)
        CertFreeCertificateContext(pCertContext);
    pCertContext = NULL;     

    goto CommonReturn;

TRACE_ERROR(ErrorCryptGenKey);
TRACE_ERROR(ErrorCryptAcquireContext);
TRACE_ERROR(ErrorCryptExportPublicKeyInfo);
TRACE_ERROR(ErrorEncodeTempCertToBeSigned);
TRACE_ERROR(ErrorEncodeTempCert);
TRACE_ERROR(ErrorCreateTempCertContext);
TRACE_ERROR(ErrorGetProvName);
TRACE_ERROR(ErrorGetContainerName);
TRACE_ERROR(ErrorGetProvType);
TRACE_ERROR(ErrorSetTempCertPropError);
TRACE_ERROR(ErrorCryptSignCertificate);
TRACE_ERROR(ErrorSystemTimeToFileTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\scstore.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       scstore.cpp
//
//  Contents:   Smart Card Store Provider implementation
//
//  History:    03-Dec-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <dbgdef.h>
//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::CSmartCardStore, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CSmartCardStore::CSmartCardStore ()
                : m_dwOpenFlags( 0 ),
                  m_pwszCardName( NULL ),
                  m_pwszProvider( NULL ),
                  m_dwProviderType( 0 ),
                  m_pwszContainer( NULL ),
                  m_hCacheStore( NULL )
{
    Pki_InitializeCriticalSection( &m_StoreLock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::~CSmartCardStore, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CSmartCardStore::~CSmartCardStore ()
{
    DeleteCriticalSection( &m_StoreLock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::OpenStore, public
//
//  Synopsis:   open store
//
//----------------------------------------------------------------------------
BOOL
CSmartCardStore::OpenStore (
                     LPCSTR pszStoreProv,
                     DWORD dwMsgAndCertEncodingType,
                     HCRYPTPROV hCryptProv,
                     DWORD dwFlags,
                     const void* pvPara,
                     HCERTSTORE hCertStore,
                     PCERT_STORE_PROV_INFO pStoreProvInfo
                     )
{
    BOOL fResult;
    
    assert( m_dwOpenFlags == 0 );
    assert( m_pwszCardName == NULL );
    assert( m_pwszProvider == NULL );
    assert( m_pwszContainer == NULL );
    assert( m_hCacheStore == NULL );
    
    if ( ( pvPara == NULL ) || ( dwFlags & CERT_STORE_DELETE_FLAG ) )
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }
    
    if ( SCStoreParseOpenFilter(
                (LPWSTR)pvPara,
                &m_pwszCardName,
                &m_pwszProvider,
                &m_dwProviderType,
                &m_pwszContainer
                ) == FALSE )
    {
        return( FALSE );
    }
    
    m_dwOpenFlags = dwFlags;
    m_hCacheStore = hCertStore;                                  
                                      
    fResult = FillCacheStore( FALSE );  
    
    if ( fResult == TRUE )
    {
        pStoreProvInfo->cStoreProvFunc = SMART_CARD_PROV_FUNC_COUNT;
        pStoreProvInfo->rgpvStoreProvFunc = (void **)rgpvSmartCardProvFunc;
        pStoreProvInfo->hStoreProv = (HCERTSTOREPROV)this;
    }
    else
    {
        CloseStore( 0 );
    }
    
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::CloseStore, public
//
//  Synopsis:   close store
//
//----------------------------------------------------------------------------
VOID
CSmartCardStore::CloseStore (DWORD dwFlags)
{
    EnterCriticalSection( &m_StoreLock );
    
    delete m_pwszCardName;
    m_pwszCardName = NULL;
    
    delete m_pwszProvider;
    m_pwszProvider = NULL;
    
    delete m_pwszContainer;
    m_pwszContainer = NULL;
    
    LeaveCriticalSection( &m_StoreLock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::DeleteCert, public
//
//  Synopsis:   delete cert
//
//----------------------------------------------------------------------------
BOOL
CSmartCardStore::DeleteCert (PCCERT_CONTEXT pCertContext, DWORD dwFlags)
{
    return( ModifyCertOnCard( pCertContext, TRUE ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::SetCertProperty, public
//
//  Synopsis:   set certificate property
//
//----------------------------------------------------------------------------
BOOL
CSmartCardStore::SetCertProperty (
                    PCCERT_CONTEXT pCertContext,
                    DWORD dwPropId,
                    DWORD dwFlags,
                    const void* pvPara
                    )
{
    // NOTENOTE: Properties are NOT persisted
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::WriteCert, public
//
//  Synopsis:   write certificate
//
//----------------------------------------------------------------------------
BOOL
CSmartCardStore::WriteCert (PCCERT_CONTEXT pCertContext, DWORD dwFlags)
{
    return( ModifyCertOnCard( pCertContext, FALSE ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::StoreControl, public
//
//  Synopsis:   store control
//
//----------------------------------------------------------------------------
BOOL
CSmartCardStore::StoreControl (
                      DWORD dwFlags, 
                      DWORD dwCtrlType, 
                      LPVOID pvCtrlPara
                      )
{
    switch ( dwCtrlType )
    {
    case CERT_STORE_CTRL_RESYNC:
         return( Resync() );
    }
    
    SetLastError( (DWORD) ERROR_NOT_SUPPORTED );                    
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::Resync, public
//
//  Synopsis:   resync store
//
//----------------------------------------------------------------------------
BOOL
CSmartCardStore::Resync ()
{
    BOOL fResult;
    
    EnterCriticalSection( &m_StoreLock );
    
    fResult = FillCacheStore( TRUE );
    
    LeaveCriticalSection( &m_StoreLock );
    
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::FillCacheStore, public
//
//  Synopsis:   fill the cache store
//
//----------------------------------------------------------------------------
BOOL
CSmartCardStore::FillCacheStore (BOOL fClearCache)
{
    BOOL                      fResult = TRUE;
    PCCERT_CONTEXT            pCertContext;
    PCCRL_CONTEXT             pCrlContext;
    PCCTL_CONTEXT             pCtlContext;
    DWORD                     dwFlags = 0;
    SMART_CARD_CERT_FIND_DATA sccfind;
    HCERTSTORE                hMyStore;
    
    if ( fClearCache == TRUE )
    {
        while ( pCertContext = CertEnumCertificatesInStore( m_hCacheStore, NULL ) )
        {
            CertDeleteCertificateFromStore( pCertContext );
        }
        
        while ( pCrlContext = CertGetCRLFromStore( m_hCacheStore, NULL, NULL, &dwFlags ) )
        {
            CertDeleteCRLFromStore( pCrlContext );
        }
            
        while ( pCtlContext = CertEnumCTLsInStore( m_hCacheStore, NULL ) )
        {
            CertDeleteCTLFromStore( pCtlContext );
        }
    }                 
    
    hMyStore = CertOpenSystemStoreW( NULL, L"MY" );
    if ( hMyStore == NULL )
    {
        return( FALSE );
    }
    
    sccfind.cbSize = sizeof( sccfind );
    sccfind.pwszProvider = m_pwszProvider;
    sccfind.dwProviderType = m_dwProviderType;
    sccfind.pwszContainer = m_pwszContainer;
    sccfind.dwKeySpec = 0;
    
    pCertContext = NULL;                       
    while ( ( fResult == TRUE ) && 
            ( ( pCertContext = I_CryptFindSmartCardCertInStore(
                                    hMyStore,
                                    pCertContext,
                                    &sccfind,
                                    NULL
                                    ) ) != NULL ) ) 
    {
        fResult = CertAddCertificateContextToStore(
                      m_hCacheStore,
                      pCertContext,
                      CERT_STORE_ADD_ALWAYS,
                      NULL
                      );
    }
    
    CertCloseStore( hMyStore, 0 );
    
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::ModifyCertOnCard, public
//
//  Synopsis:   modify the cert corresponding to the public key in the given
//              cert context
//
//----------------------------------------------------------------------------
BOOL
CSmartCardStore::ModifyCertOnCard (PCCERT_CONTEXT pCertContext, BOOL fDelete)
{
    BOOL       fResult;
    HCRYPTPROV hContainer = NULL;
    HCRYPTKEY  hKeyPair = 0;
    
    fResult = CryptAcquireContextU(
                   &hContainer,
                   m_pwszContainer,
                   m_pwszProvider,
                   m_dwProviderType,
                   0
                   );
                   
    if ( fResult == TRUE )
    {
        fResult = SCStoreAcquireHandleForCertKeyPair( 
                         hContainer,
                         pCertContext,
                         &hKeyPair
                         );
    }
    
    if ( fResult == TRUE )
    {
        fResult = SCStoreWriteCertToCard(
                         ( fDelete == FALSE ) ? pCertContext : NULL,
                         hKeyPair
                         );
                         
        CryptDestroyKey( hKeyPair );                 
    }
    
    if ( hContainer != NULL )
    {
        CryptReleaseContext( hContainer, 0 );
    }
    
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   SmartCardProvOpenStore
//
//  Synopsis:   provider open store entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI SmartCardProvOpenStore (
                 IN LPCSTR pszStoreProv,
                 IN DWORD dwMsgAndCertEncodingType,
                 IN HCRYPTPROV hCryptProv,
                 IN DWORD dwFlags,
                 IN const void* pvPara,
                 IN HCERTSTORE hCertStore,
                 IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
                 )
{
    BOOL             fResult;
    CSmartCardStore* pSCStore;

    pSCStore = new CSmartCardStore;
    if ( pSCStore == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    fResult = pSCStore->OpenStore(
                            pszStoreProv,
                            dwMsgAndCertEncodingType,
                            hCryptProv,
                            dwFlags,
                            pvPara,
                            hCertStore,
                            pStoreProvInfo
                            );

    if ( fResult == FALSE )
    {
        delete pSCStore;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   SmartCardProvCloseStore
//
//  Synopsis:   provider close store entry point
//
//----------------------------------------------------------------------------
void WINAPI SmartCardProvCloseStore (
                 IN HCERTSTOREPROV hStoreProv,
                 IN DWORD dwFlags
                 )
{
    ( (CSmartCardStore *)hStoreProv )->CloseStore( dwFlags );
    delete (CSmartCardStore *)hStoreProv;
}

//+---------------------------------------------------------------------------
//
//  Function:   SmartCardProvDeleteCert
//
//  Synopsis:   provider delete cert entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI SmartCardProvDeleteCert (
                 IN HCERTSTOREPROV hStoreProv,
                 IN PCCERT_CONTEXT pCertContext,
                 IN DWORD dwFlags
                 )
{
    return( ( (CSmartCardStore *)hStoreProv )->DeleteCert( 
                                                     pCertContext, 
                                                     dwFlags 
                                                     ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   SmartCardProvSetCertProperty
//
//  Synopsis:   provider set cert property entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI SmartCardProvSetCertProperty (
                 IN HCERTSTOREPROV hStoreProv,
                 IN PCCERT_CONTEXT pCertContext,
                 IN DWORD dwPropId,
                 IN DWORD dwFlags,
                 IN const void* pvData
                 )
{
    return( ( (CSmartCardStore *)hStoreProv )->SetCertProperty(
                                                  pCertContext,
                                                  dwPropId,
                                                  dwFlags,
                                                  pvData
                                                  ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   SmartCardProvWriteCert
//
//  Synopsis:   provider write cert entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI SmartCardProvWriteCert (
                 IN HCERTSTOREPROV hStoreProv,
                 IN PCCERT_CONTEXT pCertContext,
                 IN DWORD dwFlags
                 )
{
    return( ( (CSmartCardStore *)hStoreProv )->WriteCert( 
                                                    pCertContext, 
                                                    dwFlags 
                                                    ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   SmartCardProvStoreControl
//
//  Synopsis:   provider store control entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI SmartCardProvStoreControl (
                 IN HCERTSTOREPROV hStoreProv,
                 IN DWORD dwFlags,
                 IN DWORD dwCtrlType,
                 IN LPVOID pvCtrlPara
                 )
{
    return( ( (CSmartCardStore *)hStoreProv )->StoreControl( 
                                                    dwFlags, 
                                                    dwCtrlType, 
                                                    pvCtrlPara 
                                                    ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   SCStoreParseOpenFilter
//
//  Synopsis:   parse open filter
//
//----------------------------------------------------------------------------
BOOL WINAPI
SCStoreParseOpenFilter (
       IN LPWSTR pwszOpenFilter,
       OUT LPWSTR* ppwszCardName,
       OUT LPWSTR* ppwszProvider,
       OUT DWORD* pdwProviderType,
       OUT LPWSTR* ppwszContainer
       )
{
    LPWSTR pwsz;
    DWORD  cw = wcslen( pwszOpenFilter ) + 1;
    DWORD  cParse = 1;
    DWORD  cCount;
    DWORD  aParse[PARSE_ELEM];
    LPWSTR pwszCardName;
    LPWSTR pwszProvider;
    LPSTR  pszProviderType;
    DWORD  dwProviderType;
    LPWSTR pwszContainer;
    
    pwsz = new WCHAR [ cw ];                                   
    if ( pwsz == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }
    
    wcscpy( pwsz, pwszOpenFilter );
    memset( aParse, 0, sizeof( aParse ) );
    
    for ( cCount = 0; ( cCount < cw ) && ( cParse < PARSE_ELEM ); cCount++ )
    {
        if ( pwsz[cCount] == L'\\' )
        {
            aParse[cParse++] = cCount + 1;
            pwsz[cCount] = L'\0';
        }
    }
    
    if ( cParse < PARSE_ELEM - 1 )
    {
        delete pwsz;
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }
    
    pwszCardName = new WCHAR [wcslen( &pwsz[aParse[0]] ) + 1];
    pwszProvider = new WCHAR [wcslen( &pwsz[aParse[1]] ) + 1];
    cw = wcslen( &pwsz[aParse[2]] ) + 1;
    pszProviderType = new CHAR [cw];
    pwszContainer = new WCHAR [wcslen( &pwsz[aParse[3]] ) + 1];
    
    if ( ( pwszCardName == NULL ) || ( pwszProvider == NULL ) ||
         ( pszProviderType == NULL ) || ( pwszContainer == NULL ) )
    {
        delete pwszCardName;
        delete pwszProvider;
        delete pszProviderType;
        delete pwszContainer;
        delete pwsz;
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }
    
    wcscpy( pwszCardName, &pwsz[aParse[0]] );
    wcscpy( pwszProvider, &pwsz[aParse[1]] );
    
    WideCharToMultiByte(
        CP_ACP,
        0,
        &pwsz[aParse[2]],
        cw,
        pszProviderType,
        cw,
        NULL,
        NULL
        );
    
    dwProviderType = atol( pszProviderType );
    wcscpy( pwszContainer, &pwsz[aParse[3]] );
    
    *ppwszCardName = pwszCardName;
    *ppwszProvider = pwszProvider;
    *pdwProviderType = dwProviderType;
    *ppwszContainer = pwszContainer;               
                   
    delete pszProviderType;
    delete pwsz;
    
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   SCStoreAcquireHandleForCertKeyPair
//
//  Synopsis:   get the provider handle corresponding to the key pair
//              identified by the public key given in the cert context
//
//----------------------------------------------------------------------------
BOOL WINAPI
SCStoreAcquireHandleForCertKeyPair (
       IN HCRYPTPROV hContainer,
       IN PCCERT_CONTEXT pCertContext,
       OUT HCRYPTKEY* phKeyPair
       )
{
    BOOL  fResult;
    DWORD dwKeySpec = AT_SIGNATURE;
    
    fResult = I_CertCompareCertAndProviderPublicKey(
                    pCertContext,
                    hContainer,
                    dwKeySpec
                    );
                    
    if ( fResult == FALSE )
    {
        dwKeySpec = AT_KEYEXCHANGE;
        
        fResult = I_CertCompareCertAndProviderPublicKey(
                        pCertContext,
                        hContainer,
                        dwKeySpec
                        );
    }
    
    if ( fResult == TRUE )
    {
        fResult = CryptGetUserKey( hContainer, dwKeySpec, phKeyPair );
    }
    
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   SCStoreWriteCertToCard
//
//  Synopsis:   write the cert to the card
//
//----------------------------------------------------------------------------
BOOL WINAPI
SCStoreWriteCertToCard (
       IN OPTIONAL PCCERT_CONTEXT pCertContext,
       IN HCRYPTKEY hKeyPair
       )
{
    LPBYTE pbEncoded = NULL;
    
    if ( pCertContext != NULL )
    {
        pbEncoded = pCertContext->pbCertEncoded;
    }
    
    return( CryptSetKeyParam( hKeyPair, KP_CERTIFICATE, pbEncoded, 0 ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\syscert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       syscert.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"

HCERTSTORE WINAPI CertOpenSystemStoreA(HCRYPTPROV  hProv,
                                                const char * szSubsystemProtocol) {

    DWORD dwFlags = CERT_STORE_NO_CRYPT_RELEASE_FLAG;
    if (0 == _stricmp(szSubsystemProtocol, "SPC"))
        dwFlags |= CERT_SYSTEM_STORE_LOCAL_MACHINE;
    else
        dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER;
    return CertOpenStore(
        CERT_STORE_PROV_SYSTEM_A,
        0,                          // dwEncodingType
        hProv,
        dwFlags,
        (const void *) szSubsystemProtocol
        );
}

HCERTSTORE WINAPI CertOpenSystemStoreW(HCRYPTPROV  hProv, 
                                                const WCHAR * wcsSubsystemProtocol) {

    DWORD dwFlags = CERT_STORE_NO_CRYPT_RELEASE_FLAG;
    if (0 == _wcsicmp(wcsSubsystemProtocol, L"SPC"))
        dwFlags |= CERT_SYSTEM_STORE_LOCAL_MACHINE;
    else
        dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER;
    return CertOpenStore(
        CERT_STORE_PROV_SYSTEM_W,
        0,                          // dwEncodingType
        hProv,
        dwFlags,
        (const void *) wcsSubsystemProtocol
        );
}

BOOL WINAPI CertAddEncodedCertificateToSystemStoreA(
    const char *    szCertStoreName,
    const BYTE *    pbCertEncoded,
    DWORD           cbCertEncoded
    )
{

    HCERTSTORE      hStore = NULL;
    BOOL            fOk;

    fOk =
          (hStore = CertOpenSystemStoreA(NULL, szCertStoreName)) != NULL                                 &&
          CertAddEncodedCertificateToStore(hStore, X509_ASN_ENCODING,
                pbCertEncoded, cbCertEncoded, CERT_STORE_ADD_USE_EXISTING,
                NULL);

    if(hStore != NULL)
        CertCloseStore(hStore, 0);

    return(fOk);
}

BOOL WINAPI CertAddEncodedCertificateToSystemStoreW(
    const WCHAR *   wcsCertStoreName,
    const BYTE *    pbCertEncoded,
    DWORD           cbCertEncoded
    )
{

    HCERTSTORE      hStore = NULL;
    BOOL            fOk;

    fOk =
          (hStore = CertOpenSystemStoreW(NULL, wcsCertStoreName)) != NULL                                &&
          CertAddEncodedCertificateToStore(hStore, X509_ASN_ENCODING,
            pbCertEncoded, cbCertEncoded, CERT_STORE_ADD_USE_EXISTING, NULL);

    if(hStore != NULL)
        CertCloseStore(hStore, 0);

    return(fOk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\scstore.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       scstore.h
//
//  Contents:   Smart Card Store Provider
//
//  History:    11-25-1997    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__SCSTORE_H__)
#define __SCSTORE_H__

//
// Store provider open store function name
//

#define SMART_CARD_OPEN_STORE_PROV_FUNC "SmartCardProvOpenStore"

//
// CSmartCardStore.  This class implements all callbacks for the Smart Card
// Store provider.  A pointer to an instance of this class is used as the 
// hStoreProv parameter for the callback functions implemented
//

class CSmartCardStore
{
public:

    //
    // Construction
    //

    CSmartCardStore ();
    ~CSmartCardStore ();

    //
    // Store functions
    //

    BOOL OpenStore (
             LPCSTR pszStoreProv,
             DWORD dwMsgAndCertEncodingType,
             HCRYPTPROV hCryptProv,
             DWORD dwFlags,
             const void* pvPara,
             HCERTSTORE hCertStore,
             PCERT_STORE_PROV_INFO pStoreProvInfo
             );

    VOID CloseStore (DWORD dwFlags);

    BOOL DeleteCert (PCCERT_CONTEXT pCertContext, DWORD dwFlags);

    BOOL SetCertProperty (
            PCCERT_CONTEXT pCertContext,
            DWORD dwPropId,
            DWORD dwFlags,
            const void* pvPara
            );

    BOOL WriteCert (PCCERT_CONTEXT pCertContext, DWORD dwFlags);

    BOOL StoreControl (DWORD dwFlags, DWORD dwCtrlType, LPVOID pvCtrlPara);
    
    BOOL Resync ();

private:

    //
    // Object lock
    //
    
    CRITICAL_SECTION m_StoreLock;          
    
    //
    // Open Store flags
    //

    DWORD            m_dwOpenFlags;
    
    //
    // Open filter parameters
    //
    
    LPWSTR           m_pwszCardName;
    LPWSTR           m_pwszProvider;
    DWORD            m_dwProviderType;
    LPWSTR           m_pwszContainer;
    
    //
    // Cache Store
    //
    
    HCERTSTORE       m_hCacheStore;
    
    //
    // Private methods
    //

    BOOL FillCacheStore (BOOL fClearCache);    
    
    BOOL ModifyCertOnCard (PCCERT_CONTEXT pCertContext, BOOL fDelete);
};

//
// Smart Card Store Provider functions
//

BOOL WINAPI SmartCardProvOpenStore (
                 IN LPCSTR pszStoreProv,
                 IN DWORD dwMsgAndCertEncodingType,
                 IN HCRYPTPROV hCryptProv,
                 IN DWORD dwFlags,
                 IN const void* pvPara,
                 IN HCERTSTORE hCertStore,
                 IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
                 );

void WINAPI SmartCardProvCloseStore (
                 IN HCERTSTOREPROV hStoreProv,
                 IN DWORD dwFlags
                 );

BOOL WINAPI SmartCardProvDeleteCert (
                 IN HCERTSTOREPROV hStoreProv,
                 IN PCCERT_CONTEXT pCertContext,
                 IN DWORD dwFlags
                 );

BOOL WINAPI SmartCardProvSetCertProperty (
                 IN HCERTSTOREPROV hStoreProv,
                 IN PCCERT_CONTEXT pCertContext,
                 IN DWORD dwPropId,
                 IN DWORD dwFlags,
                 IN const void* pvData
                 );

BOOL WINAPI SmartCardProvWriteCert (
                 IN HCERTSTOREPROV hStoreProv,
                 IN PCCERT_CONTEXT pCertContext,
                 IN DWORD dwFlags
                 );

BOOL WINAPI SmartCardProvStoreControl (
                 IN HCERTSTOREPROV hStoreProv,
                 IN DWORD dwFlags,
                 IN DWORD dwCtrlType,
                 IN LPVOID pvCtrlPara
                 );

//
// Smart Card Store Provider Function table
//

static void* const rgpvSmartCardProvFunc[] = {

    // CERT_STORE_PROV_CLOSE_FUNC              0
    SmartCardProvCloseStore,
    // CERT_STORE_PROV_READ_CERT_FUNC          1
    NULL,
    // CERT_STORE_PROV_WRITE_CERT_FUNC         2
    SmartCardProvWriteCert,
    // CERT_STORE_PROV_DELETE_CERT_FUNC        3
    SmartCardProvDeleteCert,
    // CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC  4
    SmartCardProvSetCertProperty,
    // CERT_STORE_PROV_READ_CRL_FUNC           5
    NULL,
    // CERT_STORE_PROV_WRITE_CRL_FUNC          6
    NULL,
    // CERT_STORE_PROV_DELETE_CRL_FUNC         7
    NULL,
    // CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC   8
    NULL,
    // CERT_STORE_PROV_READ_CTL_FUNC           9
    NULL,
    // CERT_STORE_PROV_WRITE_CTL_FUNC          10
    NULL,
    // CERT_STORE_PROV_DELETE_CTL_FUNC         11
    NULL,
    // CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC   12
    NULL,
    // CERT_STORE_PROV_CONTROL_FUNC            13
    SmartCardProvStoreControl
};

#define SMART_CARD_PROV_FUNC_COUNT (sizeof(rgpvSmartCardProvFunc) / \
                                    sizeof(rgpvSmartCardProvFunc[0]))
       
//
// Smart Card Store Helper Functions
//

BOOL WINAPI
SCStoreParseOpenFilter (
       IN LPWSTR pwszOpenFilter,
       OUT LPWSTR* ppwszCardName,
       OUT LPWSTR* ppwszProvider,
       OUT DWORD* pdwProviderType,
       OUT LPWSTR* ppwszContainer
       );
          
BOOL WINAPI
SCStoreAcquireHandleForCertKeyPair (
       IN HCRYPTPROV hContainer,
       IN PCCERT_CONTEXT pCertContext,
       OUT HCRYPTKEY* phKeyPair
       );
       
BOOL WINAPI
SCStoreWriteCertToCard (
       IN OPTIONAL PCCERT_CONTEXT pCertContext,
       IN HCRYPTKEY hKeyPair
       );       
       
//
// Open filter parsing definitions
//       

#define PARSE_ELEM 4
       
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\wincert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wincert.cpp
//
//  Contents:   Certificate, Certificate Revocation List (CRL),
//              Certificate Request and Certificate Name
//              Encode/Decode APIs
//
//              ASN.1 implementation uses the ASN1 compiler.
//
//  Functions:  CryptEncodeObject
//              CryptDecodeObject
//              CryptEncodeObjectEx
//              CryptDecodeObjectEx
//
//  History:    29-Feb-96       philh   created
//              20-Jan-98       philh   added "Ex" version
//
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>

#ifndef OSS_CRYPT_ASN1
#define ASN1_SUPPORTS_UTF8_TAG       1
#endif  // OSS_CRYPT_ASN1

// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

static const BYTE NullDer[2] = {0x05, 0x00};
static const CRYPT_OBJID_BLOB NullDerBlob = {2, (BYTE *)&NullDer[0]};

HCRYPTASN1MODULE hX509Asn1Module;

HCRYPTOIDFUNCSET hX509EncodeFuncSet;
HCRYPTOIDFUNCSET hX509DecodeFuncSet;
HCRYPTOIDFUNCSET hX509EncodeExFuncSet;
HCRYPTOIDFUNCSET hX509DecodeExFuncSet;


//+-------------------------------------------------------------------------
//  Function:  GetEncoder/GetDecoder
//
//  Synopsis:  Initialize thread local storage for the asn libs
//
//  Returns:   pointer to an initialized Asn1 encoder/decoder data
//             structures
//--------------------------------------------------------------------------
static inline ASN1encoding_t GetEncoder(void)
{
    return I_CryptGetAsn1Encoder(hX509Asn1Module);
}
static inline ASN1decoding_t GetDecoder(void)
{
    return I_CryptGetAsn1Decoder(hX509Asn1Module);
}

typedef BOOL (WINAPI *PFN_ENCODE_FUNC) (
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const void *pvStructInfo,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

typedef BOOL (WINAPI *PFN_DECODE_FUNC) (
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

typedef BOOL (WINAPI *PFN_ENCODE_EX_FUNC) (
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const void *pvStructInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

typedef BOOL (WINAPI *PFN_DECODE_EX_FUNC) (
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  ASN1 X509 v3 ASN.1 Encode / Decode functions
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CSPProviderEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_CSP_PROVIDER pCSPProvider,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

BOOL WINAPI Asn1CSPProviderDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
        
BOOL WINAPI Asn1NameValueEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ENROLLMENT_NAME_VALUE_PAIR pNameValue,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
        
BOOL WINAPI Asn1NameValueDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509CertInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CertInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509CrlInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRL_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CrlInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509CertRequestInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_REQUEST_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CertRequestInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509KeygenRequestInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_KEYGEN_REQUEST_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509KeygenRequestInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509SignedContentEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_SIGNED_CONTENT_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509SignedContentDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509NameInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509NameInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509NameValueEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_VALUE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509NameValueDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  ASN1 ASN.1 X509 Certificate Extensions Encode / Decode functions
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ExtensionsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_EXTENSIONS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509ExtensionsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );


//+-------------------------------------------------------------------------
//  ASN1 ASN.1 Public Key Info Encode / Decode functions
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509PublicKeyInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_PUBLIC_KEY_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509PublicKeyInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  ASN1 ASN.1 PKCS#1 RSAPublicKey Encode / Decode functions
//--------------------------------------------------------------------------
BOOL WINAPI Asn1RSAPublicKeyStrucEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PUBLICKEYSTRUC *pPubKeyStruc,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1RSAPublicKeyStrucDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  ASN1 X509 v3 Extension ASN.1 Encode / Decode functions
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AuthorityKeyIdEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_AUTHORITY_KEY_ID_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509AuthorityKeyIdDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509AuthorityKeyId2EncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_AUTHORITY_KEY_ID2_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509AuthorityKeyId2DecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509KeyAttributesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_KEY_ATTRIBUTES_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509KeyAttributesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509AltNameEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_ALT_NAME_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509AltNameDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509KeyUsageRestrictionEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_KEY_USAGE_RESTRICTION_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509KeyUsageRestrictionDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509BasicConstraintsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_BASIC_CONSTRAINTS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509BasicConstraintsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509BasicConstraints2EncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_BASIC_CONSTRAINTS2_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509BasicConstraints2DecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509BitsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_BIT_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509BitsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509BitsWithoutTrailingZeroesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_BIT_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CertPoliciesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_POLICIES_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CertPoliciesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509CertPoliciesQualifier1DecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );


BOOL WINAPI Asn1X509PKIXUserNoticeEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_POLICY_QUALIFIER_USER_NOTICE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

BOOL WINAPI Asn1X509PKIXUserNoticeDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509AuthorityInfoAccessEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_AUTHORITY_INFO_ACCESS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509AuthorityInfoAccessDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509CrlDistPointsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRL_DIST_POINTS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CrlDistPointsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509IntegerEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN int *pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509IntegerDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509MultiByteIntegerEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_INTEGER_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509MultiByteIntegerDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509EnumeratedEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN int *pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509EnumeratedDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509OctetStringEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_DATA_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509OctetStringDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509ChoiceOfTimeEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN LPFILETIME pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509ChoiceOfTimeDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509AttributeEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ATTRIBUTE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509AttributeDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509ContentInfoSequenceOfAnyEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509ContentInfoSequenceOfAnyDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509ContentInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_CONTENT_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509ContentInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509SequenceOfAnyEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_SEQUENCE_OF_ANY pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509SequenceOfAnyDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509MultiByteUINTEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_UINT_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509MultiByteUINTDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509DSSParametersEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_DSS_PARAMETERS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509DSSParametersDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509DSSSignatureEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN BYTE rgbSignature[CERT_DSS_SIGNATURE_LEN],
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509DSSSignatureDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509DHParametersEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_DH_PARAMETERS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509DHParametersDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X942DhParametersEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_X942_DH_PARAMETERS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X942DhParametersDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X942OtherInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_X942_OTHER_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X942OtherInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1RC2CBCParametersEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_RC2_CBC_PARAMETERS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1RC2CBCParametersDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1SMIMECapabilitiesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_SMIME_CAPABILITIES pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1SMIMECapabilitiesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1UtcTimeEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN FILETIME * pFileTime,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1UtcTimeDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1TimeStampRequestInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_TIME_STAMP_REQUEST_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

BOOL WINAPI Asn1TimeStampRequestInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509AttributesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ATTRIBUTES pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509AttributesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  ASN1 X509 Certificate Trust List (CTL) ASN.1 Encode / Decode functions
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CtlUsageEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCTL_USAGE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CtlUsageDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509CtlInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCTL_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CtlInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509CertPairEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_PAIR pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CertPairDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509NameConstraintsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_CONSTRAINTS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509NameConstraintsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509CrlIssuingDistPointEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRL_ISSUING_DIST_POINT pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CrlIssuingDistPointDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509PolicyMappingsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_POLICY_MAPPINGS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509PolicyMappingsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509PolicyConstraintsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_POLICY_CONSTRAINTS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509PolicyConstraintsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509CrossCertDistPointsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCROSS_CERT_DIST_POINTS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CrossCertDistPointsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+=========================================================================
//  Certificate Management Messages over CMS (CMC) Encode/Decode Functions
//==========================================================================
BOOL WINAPI Asn1CmcDataEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_DATA_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1CmcDataDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1CmcResponseEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_RESPONSE_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1CmcResponseDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1CmcStatusEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_STATUS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1CmcStatusDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1CmcAddExtensionsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_ADD_EXTENSIONS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1CmcAddExtensionsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1CmcAddAttributesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_ADD_ATTRIBUTES_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1CmcAddAttributesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+=========================================================================
//  Certificate Template Encode/Decode Functions
//==========================================================================

BOOL WINAPI Asn1X509CertTemplateEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_TEMPLATE_EXT pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CertTemplateDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

#ifndef OSS_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Encode / Decode the "UNICODE" Name Info
//
//  from certstr.cpp
//--------------------------------------------------------------------------
extern BOOL WINAPI UnicodeNameInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
extern BOOL WINAPI UnicodeNameInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  Encode / Decode the "UNICODE" Name Value
//
//  from certstr.cpp
//--------------------------------------------------------------------------
extern BOOL WINAPI UnicodeNameValueEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_VALUE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
extern BOOL WINAPI UnicodeNameValueDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  Encode sorted ctl info
//
//  from newstor.cpp
//--------------------------------------------------------------------------
extern BOOL WINAPI SortedCtlInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCTL_INFO pCtlInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

#endif  // OSS_CRYPT_ASN1

#ifdef OSS_CRYPT_ASN1
#define ASN1_OID_OFFSET         10000 +
#define ASN1_OID_PREFIX         "OssCryptAsn1."
#else
#define ASN1_OID_OFFSET
#define ASN1_OID_PREFIX
#endif  // OSS_CRYPT_ASN1

#ifdef DEBUG_CRYPT_ASN1_MASTER
#define OSS_OID_OFFSET         10000
#define OSS_OID_PREFIX         "OssCryptAsn1."
#endif  // DEBUG_CRYPT_ASN1_MASTER

static const CRYPT_OID_FUNC_ENTRY X509EncodeExFuncTable[] = {
    ASN1_OID_OFFSET X509_CERT, Asn1X509SignedContentEncodeEx,
    ASN1_OID_OFFSET X509_CERT_TO_BE_SIGNED, Asn1X509CertInfoEncodeEx,
    ASN1_OID_OFFSET X509_CERT_CRL_TO_BE_SIGNED, Asn1X509CrlInfoEncodeEx,
    ASN1_OID_OFFSET X509_CERT_REQUEST_TO_BE_SIGNED, Asn1X509CertRequestInfoEncodeEx,
    ASN1_OID_OFFSET X509_EXTENSIONS, Asn1X509ExtensionsEncodeEx,
    ASN1_OID_OFFSET X509_NAME_VALUE, Asn1X509NameValueEncodeEx,
    ASN1_OID_OFFSET X509_NAME, Asn1X509NameInfoEncodeEx,
    ASN1_OID_OFFSET X509_PUBLIC_KEY_INFO, Asn1X509PublicKeyInfoEncodeEx,
    ASN1_OID_OFFSET X509_AUTHORITY_KEY_ID, Asn1X509AuthorityKeyIdEncodeEx,
    ASN1_OID_OFFSET X509_KEY_ATTRIBUTES, Asn1X509KeyAttributesEncodeEx,
    ASN1_OID_OFFSET X509_KEY_USAGE_RESTRICTION, Asn1X509KeyUsageRestrictionEncodeEx,
    ASN1_OID_OFFSET X509_ALTERNATE_NAME, Asn1X509AltNameEncodeEx,
    ASN1_OID_OFFSET X509_BASIC_CONSTRAINTS, Asn1X509BasicConstraintsEncodeEx,
    ASN1_OID_OFFSET X509_KEY_USAGE, Asn1X509BitsWithoutTrailingZeroesEncodeEx,
    ASN1_OID_OFFSET X509_BASIC_CONSTRAINTS2, Asn1X509BasicConstraints2EncodeEx,
    ASN1_OID_OFFSET X509_CERT_POLICIES, Asn1X509CertPoliciesEncodeEx,
    ASN1_OID_OFFSET PKCS_UTC_TIME, Asn1UtcTimeEncodeEx,
    ASN1_OID_OFFSET PKCS_TIME_REQUEST, Asn1TimeStampRequestInfoEncodeEx,
    ASN1_OID_OFFSET RSA_CSP_PUBLICKEYBLOB, Asn1RSAPublicKeyStrucEncodeEx,
#ifndef OSS_CRYPT_ASN1
    ASN1_OID_OFFSET X509_UNICODE_NAME, UnicodeNameInfoEncodeEx,
#endif  // OSS_CRYPT_ASN1

    ASN1_OID_OFFSET X509_KEYGEN_REQUEST_TO_BE_SIGNED, Asn1X509KeygenRequestInfoEncodeEx,
    ASN1_OID_OFFSET PKCS_ATTRIBUTE, Asn1X509AttributeEncodeEx,
    ASN1_OID_OFFSET PKCS_CONTENT_INFO_SEQUENCE_OF_ANY, Asn1X509ContentInfoSequenceOfAnyEncodeEx,
#ifndef OSS_CRYPT_ASN1
    ASN1_OID_OFFSET X509_UNICODE_NAME_VALUE, UnicodeNameValueEncodeEx,
#endif  // OSS_CRYPT_ASN1
    ASN1_OID_OFFSET X509_OCTET_STRING, Asn1X509OctetStringEncodeEx,
    ASN1_OID_OFFSET X509_BITS, Asn1X509BitsEncodeEx,
    ASN1_OID_OFFSET X509_INTEGER, Asn1X509IntegerEncodeEx,
    ASN1_OID_OFFSET X509_MULTI_BYTE_INTEGER, Asn1X509MultiByteIntegerEncodeEx,
    ASN1_OID_OFFSET X509_ENUMERATED, Asn1X509EnumeratedEncodeEx,
    ASN1_OID_OFFSET X509_CHOICE_OF_TIME, Asn1X509ChoiceOfTimeEncodeEx,
    ASN1_OID_OFFSET X509_AUTHORITY_KEY_ID2, Asn1X509AuthorityKeyId2EncodeEx, 
    ASN1_OID_OFFSET X509_AUTHORITY_INFO_ACCESS, Asn1X509AuthorityInfoAccessEncodeEx,
    ASN1_OID_OFFSET PKCS_CONTENT_INFO, Asn1X509ContentInfoEncodeEx,
    ASN1_OID_OFFSET X509_SEQUENCE_OF_ANY, Asn1X509SequenceOfAnyEncodeEx,
    ASN1_OID_OFFSET X509_CRL_DIST_POINTS, Asn1X509CrlDistPointsEncodeEx,

    ASN1_OID_OFFSET X509_ENHANCED_KEY_USAGE, Asn1X509CtlUsageEncodeEx,
    ASN1_OID_OFFSET PKCS_CTL, Asn1X509CtlInfoEncodeEx,

    ASN1_OID_OFFSET X509_MULTI_BYTE_UINT, Asn1X509MultiByteUINTEncodeEx,
    ASN1_OID_OFFSET X509_DSS_PARAMETERS, Asn1X509DSSParametersEncodeEx,
    ASN1_OID_OFFSET X509_DSS_SIGNATURE, Asn1X509DSSSignatureEncodeEx,
    ASN1_OID_OFFSET PKCS_RC2_CBC_PARAMETERS, Asn1RC2CBCParametersEncodeEx,
    ASN1_OID_OFFSET PKCS_SMIME_CAPABILITIES, Asn1SMIMECapabilitiesEncodeEx,

    ASN1_OID_PREFIX X509_PKIX_POLICY_QUALIFIER_USERNOTICE, Asn1X509PKIXUserNoticeEncodeEx,
    ASN1_OID_OFFSET X509_DH_PARAMETERS, Asn1X509DHParametersEncodeEx,
    ASN1_OID_OFFSET PKCS_ATTRIBUTES, Asn1X509AttributesEncodeEx,
#ifndef OSS_CRYPT_ASN1
    ASN1_OID_OFFSET PKCS_SORTED_CTL, SortedCtlInfoEncodeEx,
#endif  // OSS_CRYPT_ASN1

    ASN1_OID_OFFSET X942_DH_PARAMETERS, Asn1X942DhParametersEncodeEx,
    ASN1_OID_OFFSET X509_BITS_WITHOUT_TRAILING_ZEROES, Asn1X509BitsWithoutTrailingZeroesEncodeEx,

    ASN1_OID_OFFSET X942_OTHER_INFO, Asn1X942OtherInfoEncodeEx,
    ASN1_OID_OFFSET X509_CERT_PAIR, Asn1X509CertPairEncodeEx,
    ASN1_OID_OFFSET X509_ISSUING_DIST_POINT, Asn1X509CrlIssuingDistPointEncodeEx,
    ASN1_OID_OFFSET X509_NAME_CONSTRAINTS, Asn1X509NameConstraintsEncodeEx,
    ASN1_OID_OFFSET X509_POLICY_MAPPINGS, Asn1X509PolicyMappingsEncodeEx,
    ASN1_OID_OFFSET X509_POLICY_CONSTRAINTS, Asn1X509PolicyConstraintsEncodeEx,
    ASN1_OID_OFFSET X509_CROSS_CERT_DIST_POINTS, Asn1X509CrossCertDistPointsEncodeEx,

    ASN1_OID_OFFSET CMC_DATA, Asn1CmcDataEncodeEx,
    ASN1_OID_OFFSET CMC_RESPONSE, Asn1CmcResponseEncodeEx,
    ASN1_OID_OFFSET CMC_STATUS, Asn1CmcStatusEncodeEx,
    ASN1_OID_OFFSET CMC_ADD_EXTENSIONS, Asn1CmcAddExtensionsEncodeEx,
    ASN1_OID_OFFSET CMC_ADD_ATTRIBUTES, Asn1CmcAddAttributesEncodeEx,
    ASN1_OID_OFFSET X509_CERTIFICATE_TEMPLATE, Asn1X509CertTemplateEncodeEx,

    ASN1_OID_PREFIX szOID_AUTHORITY_KEY_IDENTIFIER, Asn1X509AuthorityKeyIdEncodeEx,
    ASN1_OID_PREFIX szOID_KEY_ATTRIBUTES, Asn1X509KeyAttributesEncodeEx,
    ASN1_OID_PREFIX szOID_KEY_USAGE_RESTRICTION, Asn1X509KeyUsageRestrictionEncodeEx,
    ASN1_OID_PREFIX szOID_SUBJECT_ALT_NAME, Asn1X509AltNameEncodeEx,
    ASN1_OID_PREFIX szOID_ISSUER_ALT_NAME, Asn1X509AltNameEncodeEx,
    ASN1_OID_PREFIX szOID_BASIC_CONSTRAINTS, Asn1X509BasicConstraintsEncodeEx,
    ASN1_OID_PREFIX szOID_KEY_USAGE, Asn1X509BitsWithoutTrailingZeroesEncodeEx,
    ASN1_OID_PREFIX szOID_BASIC_CONSTRAINTS2, Asn1X509BasicConstraints2EncodeEx,
    ASN1_OID_PREFIX szOID_CERT_POLICIES, Asn1X509CertPoliciesEncodeEx,

    ASN1_OID_PREFIX szOID_PKIX_POLICY_QUALIFIER_USERNOTICE, Asn1X509PKIXUserNoticeEncodeEx,

    ASN1_OID_PREFIX szOID_AUTHORITY_KEY_IDENTIFIER2, Asn1X509AuthorityKeyId2EncodeEx, 
    ASN1_OID_PREFIX szOID_SUBJECT_KEY_IDENTIFIER, Asn1X509OctetStringEncodeEx,
    ASN1_OID_PREFIX szOID_SUBJECT_ALT_NAME2, Asn1X509AltNameEncodeEx,
    ASN1_OID_PREFIX szOID_ISSUER_ALT_NAME2, Asn1X509AltNameEncodeEx,
    ASN1_OID_PREFIX szOID_CRL_REASON_CODE, Asn1X509EnumeratedEncodeEx,
    ASN1_OID_PREFIX szOID_AUTHORITY_INFO_ACCESS, Asn1X509AuthorityInfoAccessEncodeEx,
    ASN1_OID_PREFIX szOID_CRL_DIST_POINTS, Asn1X509CrlDistPointsEncodeEx,

    ASN1_OID_PREFIX szOID_CERT_EXTENSIONS, Asn1X509ExtensionsEncodeEx,
    ASN1_OID_PREFIX szOID_RSA_certExtensions, Asn1X509ExtensionsEncodeEx,
    ASN1_OID_PREFIX szOID_NEXT_UPDATE_LOCATION, Asn1X509AltNameEncodeEx,

    ASN1_OID_PREFIX szOID_ENHANCED_KEY_USAGE, Asn1X509CtlUsageEncodeEx,
    ASN1_OID_PREFIX szOID_CTL, Asn1X509CtlInfoEncodeEx,

    ASN1_OID_PREFIX szOID_RSA_RC2CBC, Asn1RC2CBCParametersEncodeEx,
    ASN1_OID_PREFIX szOID_RSA_SMIMECapabilities, Asn1SMIMECapabilitiesEncodeEx,
    ASN1_OID_PREFIX szOID_RSA_signingTime, Asn1UtcTimeEncodeEx,

    ASN1_OID_PREFIX szOID_ENROLLMENT_NAME_VALUE_PAIR, Asn1NameValueEncodeEx,
	szOID_ENROLLMENT_CSP_PROVIDER, Asn1CSPProviderEncodeEx,

    ASN1_OID_OFFSET szOID_CRL_NUMBER, Asn1X509IntegerEncodeEx,
    ASN1_OID_OFFSET szOID_DELTA_CRL_INDICATOR, Asn1X509IntegerEncodeEx,
    ASN1_OID_OFFSET szOID_ISSUING_DIST_POINT, Asn1X509CrlIssuingDistPointEncodeEx,
    ASN1_OID_PREFIX szOID_FRESHEST_CRL, Asn1X509CrlDistPointsEncodeEx,
    ASN1_OID_OFFSET szOID_NAME_CONSTRAINTS, Asn1X509NameConstraintsEncodeEx,
    ASN1_OID_OFFSET szOID_POLICY_MAPPINGS, Asn1X509PolicyMappingsEncodeEx,
    ASN1_OID_OFFSET szOID_LEGACY_POLICY_MAPPINGS, Asn1X509PolicyMappingsEncodeEx,
    ASN1_OID_OFFSET szOID_POLICY_CONSTRAINTS, Asn1X509PolicyConstraintsEncodeEx,
    ASN1_OID_OFFSET szOID_CROSS_CERT_DIST_POINTS, Asn1X509CrossCertDistPointsEncodeEx,
    ASN1_OID_OFFSET szOID_CERTIFICATE_TEMPLATE, Asn1X509CertTemplateEncodeEx,

};

#define X509_ENCODE_EX_FUNC_COUNT (sizeof(X509EncodeExFuncTable) / \
                                    sizeof(X509EncodeExFuncTable[0]))

static const CRYPT_OID_FUNC_ENTRY X509DecodeExFuncTable[] = {
    ASN1_OID_OFFSET X509_CERT, Asn1X509SignedContentDecodeEx,
    ASN1_OID_OFFSET X509_CERT_TO_BE_SIGNED, Asn1X509CertInfoDecodeEx,
    ASN1_OID_OFFSET X509_CERT_CRL_TO_BE_SIGNED, Asn1X509CrlInfoDecodeEx,
    ASN1_OID_OFFSET X509_CERT_REQUEST_TO_BE_SIGNED, Asn1X509CertRequestInfoDecodeEx,
    ASN1_OID_OFFSET X509_EXTENSIONS, Asn1X509ExtensionsDecodeEx,
    ASN1_OID_OFFSET X509_NAME_VALUE, Asn1X509NameValueDecodeEx,
    ASN1_OID_OFFSET X509_NAME, Asn1X509NameInfoDecodeEx,
    ASN1_OID_OFFSET X509_PUBLIC_KEY_INFO, Asn1X509PublicKeyInfoDecodeEx,
    ASN1_OID_OFFSET X509_AUTHORITY_KEY_ID, Asn1X509AuthorityKeyIdDecodeEx,
    ASN1_OID_OFFSET X509_KEY_ATTRIBUTES, Asn1X509KeyAttributesDecodeEx,
    ASN1_OID_OFFSET X509_KEY_USAGE_RESTRICTION, Asn1X509KeyUsageRestrictionDecodeEx,
    ASN1_OID_OFFSET X509_ALTERNATE_NAME, Asn1X509AltNameDecodeEx,
    ASN1_OID_OFFSET X509_BASIC_CONSTRAINTS, Asn1X509BasicConstraintsDecodeEx,
    ASN1_OID_OFFSET X509_KEY_USAGE, Asn1X509BitsDecodeEx,
    ASN1_OID_OFFSET X509_BASIC_CONSTRAINTS2, Asn1X509BasicConstraints2DecodeEx,
    ASN1_OID_OFFSET X509_CERT_POLICIES, Asn1X509CertPoliciesDecodeEx,
    ASN1_OID_OFFSET PKCS_UTC_TIME, Asn1UtcTimeDecodeEx,
    ASN1_OID_OFFSET PKCS_TIME_REQUEST, Asn1TimeStampRequestInfoDecodeEx,
    ASN1_OID_OFFSET RSA_CSP_PUBLICKEYBLOB, Asn1RSAPublicKeyStrucDecodeEx,
#ifndef OSS_CRYPT_ASN1
    ASN1_OID_OFFSET X509_UNICODE_NAME, UnicodeNameInfoDecodeEx,
#endif  // OSS_CRYPT_ASN1

    ASN1_OID_OFFSET X509_KEYGEN_REQUEST_TO_BE_SIGNED, Asn1X509KeygenRequestInfoDecodeEx,
    ASN1_OID_OFFSET PKCS_ATTRIBUTE, Asn1X509AttributeDecodeEx,
    ASN1_OID_OFFSET PKCS_CONTENT_INFO_SEQUENCE_OF_ANY, Asn1X509ContentInfoSequenceOfAnyDecodeEx,
#ifndef OSS_CRYPT_ASN1
    ASN1_OID_OFFSET X509_UNICODE_NAME_VALUE, UnicodeNameValueDecodeEx,
#endif  // OSS_CRYPT_ASN1
    ASN1_OID_OFFSET X509_OCTET_STRING, Asn1X509OctetStringDecodeEx,
    ASN1_OID_OFFSET X509_BITS, Asn1X509BitsDecodeEx,
    ASN1_OID_OFFSET X509_INTEGER, Asn1X509IntegerDecodeEx,
    ASN1_OID_OFFSET X509_MULTI_BYTE_INTEGER, Asn1X509MultiByteIntegerDecodeEx,
    ASN1_OID_OFFSET X509_ENUMERATED, Asn1X509EnumeratedDecodeEx,
    ASN1_OID_OFFSET X509_CHOICE_OF_TIME, Asn1X509ChoiceOfTimeDecodeEx,
    ASN1_OID_OFFSET X509_AUTHORITY_KEY_ID2, Asn1X509AuthorityKeyId2DecodeEx, 
    ASN1_OID_OFFSET X509_AUTHORITY_INFO_ACCESS, Asn1X509AuthorityInfoAccessDecodeEx,
    ASN1_OID_OFFSET PKCS_CONTENT_INFO, Asn1X509ContentInfoDecodeEx,
    ASN1_OID_OFFSET X509_SEQUENCE_OF_ANY, Asn1X509SequenceOfAnyDecodeEx,
    ASN1_OID_OFFSET X509_CRL_DIST_POINTS, Asn1X509CrlDistPointsDecodeEx,

    ASN1_OID_OFFSET X509_ENHANCED_KEY_USAGE, Asn1X509CtlUsageDecodeEx,
    ASN1_OID_OFFSET PKCS_CTL, Asn1X509CtlInfoDecodeEx,

    ASN1_OID_OFFSET X509_MULTI_BYTE_UINT, Asn1X509MultiByteUINTDecodeEx,
    ASN1_OID_OFFSET X509_DSS_PARAMETERS, Asn1X509DSSParametersDecodeEx,
    ASN1_OID_OFFSET X509_DSS_SIGNATURE, Asn1X509DSSSignatureDecodeEx,
    ASN1_OID_OFFSET PKCS_RC2_CBC_PARAMETERS, Asn1RC2CBCParametersDecodeEx,
    ASN1_OID_OFFSET PKCS_SMIME_CAPABILITIES, Asn1SMIMECapabilitiesDecodeEx,

    ASN1_OID_PREFIX X509_PKIX_POLICY_QUALIFIER_USERNOTICE, Asn1X509PKIXUserNoticeDecodeEx,
    ASN1_OID_OFFSET X509_DH_PARAMETERS, Asn1X509DHParametersDecodeEx,
    ASN1_OID_OFFSET PKCS_ATTRIBUTES, Asn1X509AttributesDecodeEx,
#ifndef OSS_CRYPT_ASN1
    ASN1_OID_OFFSET PKCS_SORTED_CTL, Asn1X509CtlInfoDecodeEx,
#endif  // OSS_CRYPT_ASN1

    ASN1_OID_OFFSET X942_DH_PARAMETERS, Asn1X942DhParametersDecodeEx,
    ASN1_OID_OFFSET X509_BITS_WITHOUT_TRAILING_ZEROES, Asn1X509BitsDecodeEx,

    ASN1_OID_OFFSET X942_OTHER_INFO, Asn1X942OtherInfoDecodeEx,
    ASN1_OID_OFFSET X509_CERT_PAIR, Asn1X509CertPairDecodeEx,
    ASN1_OID_OFFSET X509_ISSUING_DIST_POINT, Asn1X509CrlIssuingDistPointDecodeEx,
    ASN1_OID_OFFSET X509_NAME_CONSTRAINTS, Asn1X509NameConstraintsDecodeEx,
    ASN1_OID_OFFSET X509_POLICY_MAPPINGS, Asn1X509PolicyMappingsDecodeEx,
    ASN1_OID_OFFSET X509_POLICY_CONSTRAINTS, Asn1X509PolicyConstraintsDecodeEx,
    ASN1_OID_OFFSET X509_CROSS_CERT_DIST_POINTS, Asn1X509CrossCertDistPointsDecodeEx,

    ASN1_OID_OFFSET CMC_DATA, Asn1CmcDataDecodeEx,
    ASN1_OID_OFFSET CMC_RESPONSE, Asn1CmcResponseDecodeEx,
    ASN1_OID_OFFSET CMC_STATUS, Asn1CmcStatusDecodeEx,
    ASN1_OID_OFFSET CMC_ADD_EXTENSIONS, Asn1CmcAddExtensionsDecodeEx,
    ASN1_OID_OFFSET CMC_ADD_ATTRIBUTES, Asn1CmcAddAttributesDecodeEx,
    ASN1_OID_OFFSET X509_CERTIFICATE_TEMPLATE, Asn1X509CertTemplateDecodeEx,

    ASN1_OID_PREFIX szOID_AUTHORITY_KEY_IDENTIFIER, Asn1X509AuthorityKeyIdDecodeEx,
    ASN1_OID_PREFIX szOID_KEY_ATTRIBUTES, Asn1X509KeyAttributesDecodeEx,
    ASN1_OID_PREFIX szOID_KEY_USAGE_RESTRICTION, Asn1X509KeyUsageRestrictionDecodeEx,
    ASN1_OID_PREFIX szOID_SUBJECT_ALT_NAME, Asn1X509AltNameDecodeEx,
    ASN1_OID_PREFIX szOID_ISSUER_ALT_NAME, Asn1X509AltNameDecodeEx,
    ASN1_OID_PREFIX szOID_BASIC_CONSTRAINTS, Asn1X509BasicConstraintsDecodeEx,
    ASN1_OID_PREFIX szOID_KEY_USAGE, Asn1X509BitsDecodeEx,
    ASN1_OID_PREFIX szOID_BASIC_CONSTRAINTS2, Asn1X509BasicConstraints2DecodeEx,
    ASN1_OID_PREFIX szOID_CERT_POLICIES, Asn1X509CertPoliciesDecodeEx,
    ASN1_OID_PREFIX szOID_CERT_POLICIES_95, Asn1X509CertPoliciesDecodeEx,
    ASN1_OID_PREFIX szOID_CERT_POLICIES_95_QUALIFIER1, Asn1X509CertPoliciesQualifier1DecodeEx,

    ASN1_OID_PREFIX szOID_PKIX_POLICY_QUALIFIER_USERNOTICE, Asn1X509PKIXUserNoticeDecodeEx,

    ASN1_OID_PREFIX szOID_AUTHORITY_KEY_IDENTIFIER2, Asn1X509AuthorityKeyId2DecodeEx, 
    ASN1_OID_PREFIX szOID_SUBJECT_KEY_IDENTIFIER, Asn1X509OctetStringDecodeEx,
    ASN1_OID_PREFIX szOID_SUBJECT_ALT_NAME2, Asn1X509AltNameDecodeEx,
    ASN1_OID_PREFIX szOID_ISSUER_ALT_NAME2, Asn1X509AltNameDecodeEx,
    ASN1_OID_PREFIX szOID_CRL_REASON_CODE, Asn1X509EnumeratedDecodeEx,
    ASN1_OID_PREFIX szOID_AUTHORITY_INFO_ACCESS, Asn1X509AuthorityInfoAccessDecodeEx,
    ASN1_OID_PREFIX szOID_CRL_DIST_POINTS, Asn1X509CrlDistPointsDecodeEx,

    ASN1_OID_PREFIX szOID_CERT_EXTENSIONS, Asn1X509ExtensionsDecodeEx,
    ASN1_OID_PREFIX szOID_RSA_certExtensions, Asn1X509ExtensionsDecodeEx,
    ASN1_OID_PREFIX szOID_NEXT_UPDATE_LOCATION, Asn1X509AltNameDecodeEx,

    ASN1_OID_PREFIX szOID_ENHANCED_KEY_USAGE, Asn1X509CtlUsageDecodeEx,
    ASN1_OID_PREFIX szOID_CTL, Asn1X509CtlInfoDecodeEx,

    ASN1_OID_PREFIX szOID_RSA_RC2CBC, Asn1RC2CBCParametersDecodeEx,
    ASN1_OID_PREFIX szOID_RSA_SMIMECapabilities, Asn1SMIMECapabilitiesDecodeEx,
    ASN1_OID_PREFIX szOID_RSA_signingTime, Asn1UtcTimeDecodeEx,

    ASN1_OID_PREFIX szOID_ENROLLMENT_NAME_VALUE_PAIR, Asn1NameValueDecodeEx,
    ASN1_OID_PREFIX szOID_ENROLLMENT_CSP_PROVIDER, Asn1CSPProviderDecodeEx,

    ASN1_OID_OFFSET szOID_CRL_NUMBER, Asn1X509IntegerDecodeEx,
    ASN1_OID_OFFSET szOID_DELTA_CRL_INDICATOR, Asn1X509IntegerDecodeEx,
    ASN1_OID_OFFSET szOID_ISSUING_DIST_POINT, Asn1X509CrlIssuingDistPointDecodeEx,
    ASN1_OID_PREFIX szOID_FRESHEST_CRL, Asn1X509CrlDistPointsDecodeEx,
    ASN1_OID_OFFSET szOID_NAME_CONSTRAINTS, Asn1X509NameConstraintsDecodeEx,
    ASN1_OID_OFFSET szOID_POLICY_MAPPINGS, Asn1X509PolicyMappingsDecodeEx,
    ASN1_OID_OFFSET szOID_LEGACY_POLICY_MAPPINGS, Asn1X509PolicyMappingsDecodeEx,
    ASN1_OID_OFFSET szOID_POLICY_CONSTRAINTS, Asn1X509PolicyConstraintsDecodeEx,
    ASN1_OID_OFFSET szOID_CROSS_CERT_DIST_POINTS, Asn1X509CrossCertDistPointsDecodeEx,
    ASN1_OID_OFFSET szOID_CERTIFICATE_TEMPLATE, Asn1X509CertTemplateDecodeEx,
};

#define X509_DECODE_EX_FUNC_COUNT (sizeof(X509DecodeExFuncTable) / \
                                    sizeof(X509DecodeExFuncTable[0]))

#ifdef DEBUG_CRYPT_ASN1_MASTER
static HMODULE hOssCryptDll = NULL;
#endif  // DEBUG_CRYPT_ASN1_MASTER

BOOL
WINAPI
CertASNDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL    fRet;

    if (!I_CryptOIDConvDllMain(hInst, ulReason, lpReserved))
        return FALSE;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        if (NULL == (hX509EncodeFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_ENCODE_OBJECT_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hX509DecodeFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_DECODE_OBJECT_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (NULL == (hX509EncodeExFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_ENCODE_OBJECT_EX_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hX509DecodeExFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_DECODE_OBJECT_EX_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_OBJECT_EX_FUNC,
                X509_ENCODE_EX_FUNC_COUNT,
                X509EncodeExFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError;
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_DECODE_OBJECT_EX_FUNC,
                X509_DECODE_EX_FUNC_COUNT,
                X509DecodeExFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError;

#ifdef OSS_CRYPT_ASN1
        if (0 == (hX509Asn1Module = I_CryptInstallAsn1Module(ossx509, 0, NULL)))
            goto CryptInstallAsn1ModuleError;
#else
        X509_Module_Startup();
        if (0 == (hX509Asn1Module = I_CryptInstallAsn1Module(
                X509_Module, 0, NULL))) {
            X509_Module_Cleanup();
            goto CryptInstallAsn1ModuleError;
        }
#endif  // OSS_CRYPT_ASN1
        break;

    case DLL_PROCESS_DETACH:
#ifdef DEBUG_CRYPT_ASN1_MASTER
        if (hOssCryptDll) {
            FreeLibrary(hOssCryptDll);
            hOssCryptDll = NULL;
        }
#endif  // DEBUG_CRYPT_ASN1_MASTER

        I_CryptUninstallAsn1Module(hX509Asn1Module);
#ifndef OSS_CRYPT_ASN1
        X509_Module_Cleanup();
#endif  // OSS_CRYPT_ASN1
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    I_CryptOIDConvDllMain(hInst, DLL_PROCESS_DETACH, NULL);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CryptInstallAsn1ModuleError)
TRACE_ERROR(CryptInitOIDFunctionSetError)
TRACE_ERROR(CryptInstallOIDFunctionAddressError)
}

#ifdef DEBUG_CRYPT_ASN1_MASTER

#define DEBUG_OSS_CRYPT_ASN1_ENCODE_FLAG        0x1
#define DEBUG_OSS_CRYPT_ASN1_DECODE_FLAG        0x2
#define DEBUG_OSS_CRYPT_ASN1_COMPARE_FLAG       0x4

static BOOL fGotDebugCryptAsn1Flags = FALSE;
static int iDebugCryptAsn1Flags = 0;

int
WINAPI
GetDebugCryptAsn1Flags()
{

    if (!fGotDebugCryptAsn1Flags) {
        char    *pszEnvVar;
        char    *p;
        int     iFlags;

        if (pszEnvVar = getenv("DEBUG_CRYPT_ASN1_FLAGS"))
            iFlags = strtol(pszEnvVar, &p, 16);
        else
            iFlags = DEBUG_OSS_CRYPT_ASN1_COMPARE_FLAG;

        if (iFlags) {
            if (NULL == (hOssCryptDll = LoadLibraryA("osscrypt.dll"))) {
                iFlags = 0;
                if (pszEnvVar)
                    MessageBoxA(
                        NULL,           // hwndOwner
                        "LoadLibrary(osscrypt.dll) failed",
                        "CheckCryptEncodeDecodeAsn1",
                        MB_TOPMOST | MB_OK | MB_ICONWARNING |
                            MB_SERVICE_NOTIFICATION
                        );
            }
        }

        iDebugCryptAsn1Flags = iFlags;
        fGotDebugCryptAsn1Flags = TRUE;
    }
    return iDebugCryptAsn1Flags;
}

//+-------------------------------------------------------------------------
//  Write an encoded DER blob to a file
//--------------------------------------------------------------------------
static BOOL WriteDERToFile(
    LPCSTR  pszFileName,
    PBYTE   pbDER,
    DWORD   cbDER
    )
{
    BOOL fResult;

    // Write the Encoded Blob to the file
    HANDLE hFile;
    hFile = CreateFile(pszFileName,
                GENERIC_WRITE,
                0,                  // fdwShareMode
                NULL,               // lpsa
                CREATE_ALWAYS,
                0,                  // fdwAttrsAndFlags
                0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hFile) {
        fResult = FALSE;
    } else {
        DWORD dwBytesWritten;
        fResult = WriteFile(
                hFile,
                pbDER,
                cbDER,
                &dwBytesWritten,
                NULL            // lpOverlapped
                );
        CloseHandle(hFile);
    }
    return fResult;
}

#endif  // DEBUG_CRYPT_ASN1_MASTER

//+-------------------------------------------------------------------------
// Encode the specified data structure according to the certificate
// encoding type.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptEncodeObjectEx(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
    OUT void *pvEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr = NULL;

#ifdef DEBUG_CRYPT_ASN1_MASTER
    int iOssAsn1Flags;
    LPSTR lpszOssAsn1StructType = NULL;
    char szOssOID[128];
    HCRYPTOIDFUNCADDR hOssAsn1FuncAddr = NULL;
    void *pvOssAsn1FuncAddr = NULL;

    iOssAsn1Flags = GetDebugCryptAsn1Flags() &
        (DEBUG_OSS_CRYPT_ASN1_ENCODE_FLAG |
            DEBUG_OSS_CRYPT_ASN1_COMPARE_FLAG);
    if (iOssAsn1Flags) {
        if (0xFFFF < (DWORD_PTR) lpszStructType) {
            if ((DWORD) strlen(lpszStructType) <
                (sizeof(szOssOID) - strlen(OSS_OID_PREFIX) - 1)) {
                strcpy(szOssOID, OSS_OID_PREFIX);
                strcat(szOssOID, lpszStructType);
                lpszOssAsn1StructType = szOssOID;
            }
        } else
            lpszOssAsn1StructType = (LPSTR) lpszStructType +
                OSS_OID_OFFSET;

        if (lpszOssAsn1StructType) {
            if (!CryptGetOIDFunctionAddress(
                    hX509EncodeExFuncSet,
                    dwCertEncodingType,
                    lpszOssAsn1StructType,
                    0,                      // dwFlags
                    &pvOssAsn1FuncAddr,
                    &hOssAsn1FuncAddr
                    ))
                pvOssAsn1FuncAddr = NULL;
        }
    }

    if (pvOssAsn1FuncAddr &&
            0 == (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_COMPARE_FLAG)) {
        fResult = ((PFN_ENCODE_EX_FUNC) pvOssAsn1FuncAddr)(
            dwCertEncodingType,
            lpszStructType,
            pvStructInfo,
            dwFlags,
            pEncodePara,
            pvEncoded,
            pcbEncoded
            );
    } else
#endif  // DEBUG_CRYPT_ASN1_MASTER

    if (CryptGetOIDFunctionAddress(
            hX509EncodeExFuncSet,
            dwCertEncodingType,
            lpszStructType,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
      __try {
        fResult = ((PFN_ENCODE_EX_FUNC) pvFuncAddr)(
            dwCertEncodingType,
            lpszStructType,
            pvStructInfo,
            dwFlags,
            pEncodePara,
            pvEncoded,
            pcbEncoded
            );
      } __except(EXCEPTION_EXECUTE_HANDLER) {
        fResult = FALSE;
        *pcbEncoded = 0;
        SetLastError(GetExceptionCode());
      }

#ifdef DEBUG_CRYPT_ASN1_MASTER
        if (pvOssAsn1FuncAddr && fResult && pvEncoded) {
            BYTE *pbEncoded;
            BOOL fOssAsn1Result;
            BYTE *pbOssAsn1 = NULL;
            DWORD cbOssAsn1;

            
            if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
                pbEncoded = *((BYTE **)pvEncoded);
            else
                pbEncoded = (BYTE *) pvEncoded;

            fOssAsn1Result = ((PFN_ENCODE_EX_FUNC) pvOssAsn1FuncAddr)(
                dwCertEncodingType,
                lpszStructType,
                pvStructInfo,
                dwFlags | CRYPT_ENCODE_ALLOC_FLAG,
                &PkiEncodePara,
                (void *) &pbOssAsn1,
                &cbOssAsn1
                );

            if (!fOssAsn1Result) {
                int id;

                id = MessageBoxA(
                    NULL,           // hwndOwner
                    "OssCryptAsn1 encode failed. Select Cancel to stop future OssCryptAsn1 encodes",
                    "CheckCryptEncodeDecodeAsn1",
                    MB_TOPMOST | MB_OKCANCEL | MB_ICONQUESTION |
                        MB_SERVICE_NOTIFICATION
                    );
                if (IDCANCEL == id)
                    iDebugCryptAsn1Flags = 0;
            } else if (*pcbEncoded != cbOssAsn1 ||
                    0 != memcmp(pbEncoded, pbOssAsn1, cbOssAsn1)) {
                int id;

                WriteDERToFile("msasn1.der", pbEncoded, *pcbEncoded);
                WriteDERToFile("ossasn1.der", pbOssAsn1, cbOssAsn1);
                
                id = MessageBoxA(
                    NULL,           // hwndOwner
                    "OssCryptAsn1 encode compare failed. Check ossasn1.der and msasn1.der. Select Cancel to stop future OssCryptAsn1 encodes",
                    "CheckCryptEncodeDecodeAsn1",
                    MB_TOPMOST | MB_OKCANCEL | MB_ICONQUESTION |
                        MB_SERVICE_NOTIFICATION
                    );
                if (IDCANCEL == id)
                    iDebugCryptAsn1Flags = 0;
            }

            if (pbOssAsn1)
                PkiFree(pbOssAsn1);
        }
#endif  // DEBUG_CRYPT_ASN1_MASTER
    } else {
        BYTE *pbEncoded;

#ifdef DEBUG_CRYPT_ASN1_MASTER
        if (lpszOssAsn1StructType) {
            if (hOssAsn1FuncAddr)
                CryptFreeOIDFunctionAddress(hOssAsn1FuncAddr, 0);

            if (!CryptGetOIDFunctionAddress(
                    hX509EncodeFuncSet,
                    dwCertEncodingType,
                    lpszOssAsn1StructType,
                    0,                      // dwFlags
                    &pvOssAsn1FuncAddr,
                    &hOssAsn1FuncAddr
                    ))
                pvOssAsn1FuncAddr = NULL;
        }
#endif  // DEBUG_CRYPT_ASN1_MASTER

        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        if (dwFlags & ~CRYPT_ENCODE_ALLOC_FLAG)
            goto InvalidFlags;

#ifdef DEBUG_CRYPT_ASN1_MASTER
        if (pvOssAsn1FuncAddr &&
                0 == (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_COMPARE_FLAG)) {
            pvFuncAddr = pvOssAsn1FuncAddr;
            pvOssAsn1FuncAddr = NULL;
            hFuncAddr = hOssAsn1FuncAddr;
            hOssAsn1FuncAddr = NULL;
        } else
#endif  // DEBUG_CRYPT_ASN1_MASTER
        if (!CryptGetOIDFunctionAddress(
                hX509EncodeFuncSet,
                dwCertEncodingType,
                lpszStructType,
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            goto NoEncodeFunction;
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
            PFN_CRYPT_ALLOC pfnAlloc;

            *pcbEncoded = 0;
          __try {
            fResult = ((PFN_ENCODE_FUNC) pvFuncAddr)(
                dwCertEncodingType,
                lpszStructType,
                pvStructInfo,
                NULL,
                pcbEncoded
                );
          } __except(EXCEPTION_EXECUTE_HANDLER) {
            fResult = FALSE;
            *pcbEncoded = 0;
            SetLastError(GetExceptionCode());
          }
            if (!fResult || 0 == *pcbEncoded)
                goto CommonReturn;

            pfnAlloc = PkiGetEncodeAllocFunction(pEncodePara);
            if (NULL == (pbEncoded = (BYTE *) pfnAlloc(*pcbEncoded)))
                goto OutOfMemory;
        } else
            pbEncoded = (BYTE *) pvEncoded;

      __try {
        fResult = ((PFN_ENCODE_FUNC) pvFuncAddr)(
                dwCertEncodingType,
                lpszStructType,
                pvStructInfo,
                pbEncoded,
                pcbEncoded
                );
      } __except(EXCEPTION_EXECUTE_HANDLER) {
        fResult = FALSE;
        *pcbEncoded = 0;
        SetLastError(GetExceptionCode());
      }

#ifdef DEBUG_CRYPT_ASN1_MASTER
        if (pvOssAsn1FuncAddr && fResult && pbEncoded) {
            BOOL fOssAsn1Result;
            BYTE *pbOssAsn1 = NULL;
            DWORD cbOssAsn1;

            cbOssAsn1 = *pcbEncoded;
            pbOssAsn1 = (BYTE *) PkiNonzeroAlloc(cbOssAsn1);
            if (NULL == pbOssAsn1)
                fOssAsn1Result = FALSE;
            else
                fOssAsn1Result = ((PFN_ENCODE_FUNC) pvOssAsn1FuncAddr)(
                    dwCertEncodingType,
                    lpszStructType,
                    pvStructInfo,
                    pbOssAsn1,
                    &cbOssAsn1
                    );

            if (!fOssAsn1Result) {
                int id;

                id = MessageBoxA(
                    NULL,           // hwndOwner
                    "OssCryptAsn1 encode failed. Select Cancel to stop future OssCryptAsn1 encodes",
                    "CheckCryptEncodeDecodeAsn1",
                    MB_TOPMOST | MB_OKCANCEL | MB_ICONQUESTION |
                        MB_SERVICE_NOTIFICATION
                    );
                if (IDCANCEL == id)
                    iDebugCryptAsn1Flags = 0;
            } else if (*pcbEncoded != cbOssAsn1 ||
                    0 != memcmp(pbEncoded, pbOssAsn1, cbOssAsn1)) {
                int id;

                WriteDERToFile("msasn1.der", pbEncoded, *pcbEncoded);
                WriteDERToFile("ossasn1.der", pbOssAsn1, cbOssAsn1);
                
                id = MessageBoxA(
                    NULL,           // hwndOwner
                    "OssCryptAsn1 encode compare failed. Check ossasn1.der and msasn1.der. Select Cancel to stop future OssCryptAsn1 encodes",
                    "CheckCryptEncodeDecodeAsn1",
                    MB_TOPMOST | MB_OKCANCEL | MB_ICONQUESTION |
                        MB_SERVICE_NOTIFICATION
                    );
                if (IDCANCEL == id)
                    iDebugCryptAsn1Flags = 0;
            }

            PkiFree(pbOssAsn1);
        }
#endif  // DEBUG_CRYPT_ASN1_MASTER

        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
            if (fResult)
                *((BYTE **) pvEncoded) = pbEncoded;
            else {
                PFN_CRYPT_FREE pfnFree;
                pfnFree = PkiGetEncodeFreeFunction(pEncodePara);
                pfnFree(pbEncoded);
            }
        }
    }

CommonReturn:
    if (hFuncAddr)
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
#ifdef DEBUG_CRYPT_ASN1_MASTER
    if (hOssAsn1FuncAddr)
        CryptFreeOIDFunctionAddress(hOssAsn1FuncAddr, 0);
#endif  // DEBUG_CRYPT_ASN1_MASTER

    return fResult;
ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidFlags, E_INVALIDARG)
TRACE_ERROR(NoEncodeFunction)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
}

BOOL
WINAPI
CryptEncodeObject(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    return CryptEncodeObjectEx(
        dwCertEncodingType,
        lpszStructType,
        pvStructInfo,
        0,                          // dwFlags
        NULL,                       // pEncodePara
        pbEncoded,
        pcbEncoded
        );
}


//+-------------------------------------------------------------------------
// Decode the specified data structure according to the certificate
// encoding type.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptDecodeObjectEx(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT DWORD *pcbStructInfo
    )
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr = NULL;

#ifdef DEBUG_CRYPT_ASN1_MASTER
    int iOssAsn1Flags;
    LPSTR lpszOssAsn1StructType = NULL;
    char szOssOID[128];
    HCRYPTOIDFUNCADDR hOssAsn1FuncAddr = NULL;
    void *pvOssAsn1FuncAddr = NULL;

    iOssAsn1Flags = GetDebugCryptAsn1Flags() &
        DEBUG_OSS_CRYPT_ASN1_DECODE_FLAG;
    if (iOssAsn1Flags) {
        if (0xFFFF < (DWORD_PTR) lpszStructType) {
            if ((DWORD) strlen(lpszStructType) <
                (sizeof(szOssOID) - strlen(OSS_OID_PREFIX) - 1)) {
                strcpy(szOssOID, OSS_OID_PREFIX);
                strcat(szOssOID, lpszStructType);
                lpszOssAsn1StructType = szOssOID;
            }
        } else
            lpszOssAsn1StructType = (LPSTR) lpszStructType + OSS_OID_OFFSET;

        if (lpszOssAsn1StructType) {
            if (!CryptGetOIDFunctionAddress(
                    hX509DecodeExFuncSet,
                    dwCertEncodingType,
                    lpszOssAsn1StructType,
                    0,                      // dwFlags
                    &pvOssAsn1FuncAddr,
                    &hOssAsn1FuncAddr
                    ))
                pvOssAsn1FuncAddr = NULL;
        }
    }

    if (pvOssAsn1FuncAddr) {
        fResult = ((PFN_DECODE_EX_FUNC) pvOssAsn1FuncAddr)(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            dwFlags,
            pDecodePara,
            pvStructInfo,
            pcbStructInfo
            );
    } else
#endif  // DEBUG_CRYPT_ASN1_MASTER
    if (CryptGetOIDFunctionAddress(
            hX509DecodeExFuncSet,
            dwCertEncodingType,
            lpszStructType,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
      __try {
        fResult = ((PFN_DECODE_EX_FUNC) pvFuncAddr)(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            dwFlags,
            pDecodePara,
            pvStructInfo,
            pcbStructInfo
            );
      } __except(EXCEPTION_EXECUTE_HANDLER) {
        fResult = FALSE;
        *pcbStructInfo = 0;
        SetLastError(GetExceptionCode());
      }
    } else {
        void *pv;

#ifdef DEBUG_CRYPT_ASN1_MASTER
        if (lpszOssAsn1StructType) {
            if (!CryptGetOIDFunctionAddress(
                    hX509DecodeFuncSet,
                    dwCertEncodingType,
                    lpszOssAsn1StructType,
                    0,                      // dwFlags
                    &pvOssAsn1FuncAddr,
                    &hOssAsn1FuncAddr
                    ))
                pvOssAsn1FuncAddr = NULL;
        }
#endif  // DEBUG_CRYPT_ASN1_MASTER

        if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
            *((void **) pvStructInfo) = NULL;

#ifdef DEBUG_CRYPT_ASN1_MASTER
        if (pvOssAsn1FuncAddr) {
            pvFuncAddr = pvOssAsn1FuncAddr;
            pvOssAsn1FuncAddr = NULL;
            hFuncAddr = hOssAsn1FuncAddr;
            hOssAsn1FuncAddr = NULL;
        } else
#endif  // DEBUG_CRYPT_ASN1_MASTER

        if (!CryptGetOIDFunctionAddress(
                hX509DecodeFuncSet,
                dwCertEncodingType,
                lpszStructType,
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            goto NoDecodeFunction;
        if (dwFlags & CRYPT_DECODE_ALLOC_FLAG) {
            PFN_CRYPT_ALLOC pfnAlloc;

            *pcbStructInfo = 0;
          __try {
            fResult = ((PFN_DECODE_FUNC) pvFuncAddr)(
                dwCertEncodingType,
                lpszStructType,
                pbEncoded,
                cbEncoded,
                dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
                NULL,
                pcbStructInfo
                );
          } __except(EXCEPTION_EXECUTE_HANDLER) {
            fResult = FALSE;
            *pcbStructInfo = 0;
            SetLastError(GetExceptionCode());
          }
            if (!fResult || 0 == *pcbStructInfo)
                goto CommonReturn;

            pfnAlloc = PkiGetDecodeAllocFunction(pDecodePara);
            if (NULL == (pv = pfnAlloc(*pcbStructInfo)))
                goto OutOfMemory;
        } else
            pv = pvStructInfo;

      __try {
        fResult = ((PFN_DECODE_FUNC) pvFuncAddr)(
                dwCertEncodingType,
                lpszStructType,
                pbEncoded,
                cbEncoded,
                dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
                pv,
                pcbStructInfo
                );
      } __except(EXCEPTION_EXECUTE_HANDLER) {
        fResult = FALSE;
        *pcbStructInfo = 0;
        SetLastError(GetExceptionCode());
      }
        if (dwFlags & CRYPT_DECODE_ALLOC_FLAG) {
            if (fResult)
                *((void **) pvStructInfo) = pv;
            else {
                PFN_CRYPT_FREE pfnFree;
                pfnFree = PkiGetDecodeFreeFunction(pDecodePara);
                pfnFree(pv);
            }
        }
    }

CommonReturn:
    if (hFuncAddr)
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
#ifdef DEBUG_CRYPT_ASN1_MASTER
    if (hOssAsn1FuncAddr)
        CryptFreeOIDFunctionAddress(hOssAsn1FuncAddr, 0);
#endif  // DEBUG_CRYPT_ASN1_MASTER
    return fResult;
ErrorReturn:
    *pcbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(NoDecodeFunction)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
}


BOOL
WINAPI
CryptDecodeObject(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT DWORD *pcbStructInfo
    )
{
    return CryptDecodeObjectEx(
        dwCertEncodingType,
        lpszStructType,
        pbEncoded,
        cbEncoded,
        dwFlags,
        NULL,                   // pDecodePara
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure
//
//  Called by the Asn1X509*Encode() functions.
//--------------------------------------------------------------------------
static BOOL Asn1InfoEncodeEx(
        IN int pdunum,
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return PkiAsn1EncodeInfoEx(
        GetEncoder(),
        pdunum,
        pvAsn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded);
}

//+-------------------------------------------------------------------------
//  Decode into an allocated, ASN1 formatted info structure
//
//  Called by the Asn1X509*Decode() functions.
//--------------------------------------------------------------------------
static BOOL Asn1InfoDecodeAndAlloc(
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvAsn1Info
        )
{
    return PkiAsn1DecodeAndAllocInfo(
        GetDecoder(),
        pdunum,
        pbEncoded,
        cbEncoded,
        ppvAsn1Info);
}

//+-------------------------------------------------------------------------
//  Free an allocated, ASN1 formatted info structure
//
//  Called by the Asn1X509*Decode() functions.
//--------------------------------------------------------------------------
static void Asn1InfoFree(
        IN int pdunum,
        IN void *pAsn1Info
        )
{
    if (pAsn1Info) {
        DWORD dwErr = GetLastError();

        // TlsGetValue globbers LastError
        PkiAsn1FreeInfo(GetDecoder(), pdunum, pAsn1Info);

        SetLastError(dwErr);
    }
}

//+-------------------------------------------------------------------------
//  Decode into an ASN1 formatted info structure. Call the callback
//  function to convert into the 'C' data structure. If
//  CRYPT_DECODE_ALLOC_FLAG is set, call the callback twice. First,
//  to get the length of the 'C' data structure. Then after allocating,
//  call again to update the 'C' data structure.
//
//  Called by the Asn1X509*Decode() functions.
//--------------------------------------------------------------------------
static BOOL Asn1InfoDecodeAndAllocEx(
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return PkiAsn1DecodeAndAllocInfoEx(
        GetDecoder(),
        pdunum,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  ASN1 X509 v3 ASN.1 Set / Get functions
//
//  Called by the ASN1 X509 encode/decode functions.
//
//  Assumption: all types are UNBOUNDED.
//
//  The Get functions decrement *plRemainExtra and advance
//  *ppbExtra. When *plRemainExtra becomes negative, the functions continue
//  with the length calculation but stop doing any copies.
//  The functions don't return an error for a negative *plRemainExtra.
//--------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//  Set/Get Encoded Object Identifier string
//--------------------------------------------------------------------------
#ifdef OSS_CRYPT_ASN1
#define Asn1X509SetEncodedObjId(pszObjId, pAsn1) \
            I_CryptSetEncodedOID(pszObjId, (OssEncodedOID *) (pAsn1))

#define Asn1X509GetEncodedObjId(pAsn1, dwFlags, \
                ppszObjId, ppbExtra, plRemainExtra) \
            I_CryptGetEncodedOID((OssEncodedOID *) (pAsn1), dwFlags, \
                ppszObjId, ppbExtra, plRemainExtra)

#else

#define Asn1X509SetEncodedObjId(pszObjId, pAsn1) \
            I_CryptSetEncodedOID(pszObjId, pAsn1)

#define Asn1X509GetEncodedObjId(pAsn1, dwFlags, \
                ppszObjId, ppbExtra, plRemainExtra) \
            I_CryptGetEncodedOID(pAsn1, dwFlags, \
                ppszObjId, ppbExtra, plRemainExtra)

#endif  // OSS_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Set/Get CRYPT_DATA_BLOB (Octet String)
//--------------------------------------------------------------------------
inline void Asn1X509SetOctetString(
        IN PCRYPT_DATA_BLOB pInfo,
        OUT OCTETSTRING *pAsn1
        )
{
    pAsn1->value = pInfo->pbData;
    pAsn1->length = pInfo->cbData;
}
inline void Asn1X509GetOctetString(
        IN OCTETSTRING *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetOctetString(pAsn1->length, pAsn1->value, dwFlags,
        pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CRYPT_INTEGER_BLOB
//--------------------------------------------------------------------------
inline BOOL Asn1X509SetHugeInteger(
        IN PCRYPT_INTEGER_BLOB pInfo,
        OUT HUGEINTEGER *pAsn1
        )
{
    return PkiAsn1SetHugeInteger(pInfo, &pAsn1->length, &pAsn1->value);
}
inline void Asn1X509FreeHugeInteger(
        IN HUGEINTEGER *pAsn1
        )
{
    PkiAsn1FreeHugeInteger(pAsn1->value);
    pAsn1->value = NULL;
    pAsn1->length = 0;
}
inline void Asn1X509GetHugeInteger(
        IN HUGEINTEGER *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_INTEGER_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetHugeInteger(pAsn1->length, pAsn1->value, dwFlags,
        pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CRYPT_UINT_BLOB
//--------------------------------------------------------------------------
inline BOOL Asn1X509SetHugeUINT(
        IN PCRYPT_UINT_BLOB pInfo,
        OUT HUGEINTEGER *pAsn1
        )
{
    return PkiAsn1SetHugeUINT(pInfo, &pAsn1->length, &pAsn1->value);
}

#define Asn1X509FreeHugeUINT     Asn1X509FreeHugeInteger

inline void Asn1X509GetHugeUINT(
        IN HUGEINTEGER *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_UINT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetHugeUINT(pAsn1->length, pAsn1->value, dwFlags,
        pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Get CRYPT_BIT_BLOB
//--------------------------------------------------------------------------
inline void Asn1X509SetBit(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT BITSTRING *pAsn1
        )
{
    PkiAsn1SetBitString(pInfo, &pAsn1->length, &pAsn1->value);
}
inline void Asn1X509GetBit(
        IN BITSTRING *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetBitString(pAsn1->length, pAsn1->value, dwFlags,
        pInfo, ppbExtra, plRemainExtra);
}

inline void Asn1X509SetBitWithoutTrailingZeroes(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT BITSTRING *pAsn1
        )
{
    PkiAsn1SetBitStringWithoutTrailingZeroes(
        pInfo, &pAsn1->length, &pAsn1->value);
}


//+-------------------------------------------------------------------------
//  Set/Get LPSTR (IA5 String)
//--------------------------------------------------------------------------
inline void Asn1X509SetIA5(
        IN LPSTR psz,
        OUT IA5STRING *pAsn1
        )
{
    pAsn1->value = psz;
    pAsn1->length = strlen(psz);
}
inline void Asn1X509GetIA5(
        IN IA5STRING *pAsn1,
        IN DWORD dwFlags,
        OUT LPSTR *ppsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetIA5String(pAsn1->length, pAsn1->value, dwFlags,
        ppsz, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Unicode mapped to IA5 String
//--------------------------------------------------------------------------
BOOL Asn1X509SetUnicodeConvertedToIA5(
        IN LPWSTR pwsz,
        OUT IA5STRING *pAsn1,
        IN DWORD dwIndex,
        OUT DWORD *pdwErrLocation
        )
{
    BOOL fResult;
    fResult = PkiAsn1SetUnicodeConvertedToIA5String(pwsz,
        &pAsn1->length, &pAsn1->value);
    if (!fResult && (DWORD) CRYPT_E_INVALID_IA5_STRING == GetLastError())
        *pdwErrLocation = (dwIndex << 16) | pAsn1->length;
    else
        *pdwErrLocation = 0;
    return fResult;
}
inline void Asn1X509FreeUnicodeConvertedToIA5(IN IA5STRING *pAsn1)
{
    PkiAsn1FreeUnicodeConvertedToIA5String(pAsn1->value);
    pAsn1->value = NULL;
}
inline void Asn1X509GetIA5ConvertedToUnicode(
        IN IA5STRING *pAsn1,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetIA5StringConvertedToUnicode(pAsn1->length, pAsn1->value, dwFlags,
        ppwsz, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Get LPWSTR (BMP String)
//--------------------------------------------------------------------------
inline void Asn1X509SetBMP(
        IN LPWSTR pwsz,
        OUT BMPSTRING *pAsn1
        )
{
    pAsn1->value = pwsz;
    pAsn1->length = wcslen(pwsz);
}
inline void Asn1X509GetBMP(
        IN BMPSTRING *pAsn1,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetBMPString(pAsn1->length, pAsn1->value, dwFlags,
        ppwsz, ppbExtra, plRemainExtra);
}


//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
inline void Asn1X509SetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT NOCOPYANY *pAsn1
        )
{
    PkiAsn1SetAny(pInfo, pAsn1);
}
inline void Asn1X509GetAny(
        IN NOCOPYANY *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetAny(pAsn1, dwFlags, pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Get CRYPT_ALGORITHM_IDENTIFIER
//--------------------------------------------------------------------------
BOOL Asn1X509SetAlgorithm(
        IN PCRYPT_ALGORITHM_IDENTIFIER pInfo,
        OUT AlgorithmIdentifier *pAsn1,
        IN DWORD dwGroupId = 0
        )
{
    memset(pAsn1, 0, sizeof(*pAsn1));
    if (pInfo->pszObjId) {
        if (!Asn1X509SetEncodedObjId(pInfo->pszObjId, &pAsn1->algorithm))
            return FALSE;

        if (pInfo->Parameters.cbData) {
            Asn1X509SetAny(&pInfo->Parameters, &pAsn1->parameters);
            pAsn1->bit_mask |= parameters_present;
        } else {
            if (dwGroupId) {
                // For public key or signature algorithms, check if
                // NO NULL parameters.

                PCCRYPT_OID_INFO pOIDInfo;
                DWORD dwFlags = 0;

                switch (dwGroupId) {
                    case CRYPT_PUBKEY_ALG_OID_GROUP_ID:
                        if (pOIDInfo = CryptFindOIDInfo(
                                CRYPT_OID_INFO_OID_KEY,
                                pInfo->pszObjId,
                                CRYPT_PUBKEY_ALG_OID_GROUP_ID)) {
                            if (1 <= pOIDInfo->ExtraInfo.cbData /
                                    sizeof(DWORD)) {
                                DWORD *pdwExtra = (DWORD *)
                                    pOIDInfo->ExtraInfo.pbData;
                                dwFlags = pdwExtra[0];
                            }
                        }
                        break;
                    case CRYPT_SIGN_ALG_OID_GROUP_ID:
                        if (pOIDInfo = CryptFindOIDInfo(
                                CRYPT_OID_INFO_OID_KEY,
                                pInfo->pszObjId,
                                CRYPT_SIGN_ALG_OID_GROUP_ID)) {
                            if (2 <= pOIDInfo->ExtraInfo.cbData /
                                    sizeof(DWORD)) {
                                DWORD *pdwExtra = (DWORD *)
                                    pOIDInfo->ExtraInfo.pbData;
                                dwFlags = pdwExtra[1];
                            }
                        }
                        break;
                    default:
                        break;
                }

                if (dwFlags & CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG)
                    return TRUE;
            }

            // Per PKCS #1: default to the ASN.1 type NULL.
            Asn1X509SetAny((PCRYPT_OBJID_BLOB) &NullDerBlob, &pAsn1->parameters);
            pAsn1->bit_mask |= parameters_present;
        }
    }
    return TRUE;
}

void Asn1X509GetAlgorithm(
        IN AlgorithmIdentifier *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_ALGORITHM_IDENTIFIER pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    if (*plRemainExtra >= 0)
        memset(pInfo, 0, sizeof(*pInfo));
    Asn1X509GetEncodedObjId(&pAsn1->algorithm, dwFlags, &pInfo->pszObjId,
            ppbExtra, plRemainExtra);
    if (pAsn1->bit_mask & parameters_present)
        Asn1X509GetAny(&pAsn1->parameters, dwFlags, &pInfo->Parameters,
            ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Get CERT_PUBLIC_KEY_INFO
//--------------------------------------------------------------------------
BOOL Asn1X509SetPublicKeyInfo(
        IN PCERT_PUBLIC_KEY_INFO pInfo,
        OUT SubjectPublicKeyInfo *pAsn1
        )
{
    if (!Asn1X509SetAlgorithm(&pInfo->Algorithm, &pAsn1->algorithm,
            CRYPT_PUBKEY_ALG_OID_GROUP_ID))
        return FALSE;
    Asn1X509SetBit(&pInfo->PublicKey, &pAsn1->subjectPublicKey);
    return TRUE;
}

void Asn1X509GetPublicKeyInfo(
        IN SubjectPublicKeyInfo *pAsn1,
        IN DWORD dwFlags,
        OUT PCERT_PUBLIC_KEY_INFO pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    Asn1X509GetAlgorithm(&pAsn1->algorithm, dwFlags, &pInfo->Algorithm,
        ppbExtra, plRemainExtra);
    Asn1X509GetBit(&pAsn1->subjectPublicKey, dwFlags, &pInfo->PublicKey,
        ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Extensions
//--------------------------------------------------------------------------
BOOL Asn1X509SetExtensions(
        IN DWORD cExtension,
        IN PCERT_EXTENSION pExtension,
        OUT Extensions *pAsn1
        )
{
    Extension *pAsn1Ext;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cExtension == 0)
        return TRUE;

    pAsn1Ext = (Extension *) PkiZeroAlloc(cExtension * sizeof(Extension));
    if (pAsn1Ext == NULL)
        return FALSE;
    pAsn1->value = pAsn1Ext;
    pAsn1->count = cExtension;

    for ( ; cExtension > 0; cExtension--, pExtension++, pAsn1Ext++) {
        if (!Asn1X509SetEncodedObjId(pExtension->pszObjId, &pAsn1Ext->extnId))
            return FALSE;
        if (pExtension->fCritical) {
            pAsn1Ext->critical = TRUE;
            pAsn1Ext->bit_mask |= critical_present;
        }
        Asn1X509SetOctetString(&pExtension->Value, &pAsn1Ext->extnValue);
    }
    return TRUE;
}

void Asn1X509FreeExtensions(
        IN Extensions *pAsn1)
{
    if (pAsn1->value) {
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

void Asn1X509GetExtensions(
        IN Extensions *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcExtension,
        OUT PCERT_EXTENSION *ppExtension,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cExt;
    Extension *pAsn1Ext;
    PCERT_EXTENSION pGetExt;

    cExt = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cExt * sizeof(CERT_EXTENSION));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcExtension = cExt;
        pGetExt = (PCERT_EXTENSION) pbExtra;
        *ppExtension = pGetExt;
        pbExtra += lAlignExtra;
    } else
        pGetExt = NULL;

    pAsn1Ext = pAsn1->value;
    for ( ; cExt > 0; cExt--, pAsn1Ext++, pGetExt++) {
        Asn1X509GetEncodedObjId(&pAsn1Ext->extnId, dwFlags, &pGetExt->pszObjId,
                &pbExtra, &lRemainExtra);
        if (lRemainExtra >= 0) {
            pGetExt->fCritical = FALSE;
            if (pAsn1Ext->bit_mask & critical_present)
                pGetExt->fCritical = (BOOLEAN) pAsn1Ext->critical;
        }

        Asn1X509GetOctetString(&pAsn1Ext->extnValue, dwFlags, &pGetExt->Value,
                &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CRL Entries
//--------------------------------------------------------------------------
BOOL Asn1X509SetCrlEntries(
        IN DWORD cEntry,
        IN PCRL_ENTRY pEntry,
        OUT RevokedCertificates *pAsn1
        )
{
    CRLEntry *pAsn1Entry;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cEntry == 0)
        return TRUE;

    pAsn1Entry = (CRLEntry *) PkiZeroAlloc(cEntry * sizeof(CRLEntry));
    if (pAsn1Entry == NULL)
        return FALSE;
    pAsn1->value = pAsn1Entry;
    pAsn1->count = cEntry;

    for ( ; cEntry > 0; cEntry--, pEntry++, pAsn1Entry++) {
        if (!Asn1X509SetHugeInteger(&pEntry->SerialNumber,
                &pAsn1Entry->userCertificate))
            return FALSE;
        if (!PkiAsn1ToChoiceOfTime(&pEntry->RevocationDate,
                &pAsn1Entry->revocationDate.choice,
                &pAsn1Entry->revocationDate.u.generalTime,
                &pAsn1Entry->revocationDate.u.utcTime
                )) {
            SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
            return FALSE;
        }
        if (pEntry->cExtension) {
            if (!Asn1X509SetExtensions(pEntry->cExtension, pEntry->rgExtension,
                    &pAsn1Entry->crlEntryExtensions))
                return FALSE;
            pAsn1Entry->bit_mask |= crlEntryExtensions_present;
        }
    }
    return TRUE;
}

void Asn1X509FreeCrlEntries(
        IN RevokedCertificates *pAsn1)
{
    if (pAsn1->value) {
        CRLEntry *pAsn1Entry = pAsn1->value;
        DWORD cEntry = pAsn1->count;
        for ( ; cEntry > 0; cEntry--, pAsn1Entry++) {
            Asn1X509FreeHugeInteger(&pAsn1Entry->userCertificate);
            Asn1X509FreeExtensions(&pAsn1Entry->crlEntryExtensions);
        }
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

BOOL Asn1X509GetCrlEntries(
        IN RevokedCertificates *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcEntry,
        OUT PCRL_ENTRY *ppEntry,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cEntry;
    CRLEntry *pAsn1Entry;
    PCRL_ENTRY pGetEntry;

    cEntry = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cEntry * sizeof(CRL_ENTRY));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcEntry = cEntry;
        pGetEntry = (PCRL_ENTRY) pbExtra;
        *ppEntry = pGetEntry;
        pbExtra += lAlignExtra;
    } else
        pGetEntry = NULL;

    pAsn1Entry = pAsn1->value;
    for ( ; cEntry > 0; cEntry--, pAsn1Entry++, pGetEntry++) {
        Asn1X509GetHugeInteger(&pAsn1Entry->userCertificate, dwFlags,
            &pGetEntry->SerialNumber, &pbExtra, &lRemainExtra);

        // RevocationDate
        if (lRemainExtra >= 0) {
            if (!PkiAsn1FromChoiceOfTime(pAsn1Entry->revocationDate.choice,
                    &pAsn1Entry->revocationDate.u.generalTime,
                    &pAsn1Entry->revocationDate.u.utcTime,
                    &pGetEntry->RevocationDate)) {
                SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
                return FALSE;
            }
        }

        // Extensions
        if (pAsn1Entry->bit_mask & crlEntryExtensions_present)
            Asn1X509GetExtensions(&pAsn1Entry->crlEntryExtensions, dwFlags,
                &pGetEntry->cExtension, &pGetEntry->rgExtension,
                &pbExtra, &lRemainExtra);
        else if (lRemainExtra >= 0) {
            pGetEntry->cExtension = 0;
            pGetEntry->rgExtension = NULL;
        }
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
    return TRUE;
}

#ifndef ASN1_SUPPORTS_UTF8_TAG

void inline Asn1X509ReverseCopy(
    OUT BYTE *pbOut,
    IN BYTE *pbInOrg,
    IN DWORD cbIn
    )
{
    BYTE *pbIn = pbInOrg + cbIn - 1;

    while (cbIn-- > 0)
        *pbOut++ = *pbIn--;
}

#define MAX_LENGTH_OCTETS   5

//+-------------------------------------------------------------------------
//  Copy out the encoding of the length octets for a specified content length.
//
//  Returns the number of length octets
//--------------------------------------------------------------------------
DWORD Asn1X509GetLengthOctets(
    IN DWORD cbContent,
    OUT BYTE rgbLength[MAX_LENGTH_OCTETS]
    )
{
    DWORD cbLength;

    if (cbContent < 0x80) {
        rgbLength[0] = (BYTE) cbContent;
        cbLength = 0;
    } else {
        if (cbContent > 0xffffff)
            cbLength = 4;
        else if (cbContent > 0xffff)
            cbLength = 3;
        else if (cbContent > 0xff)
            cbLength = 2;
        else
            cbLength = 1;
        rgbLength[0] = (BYTE) cbLength | 0x80;
        Asn1X509ReverseCopy(rgbLength + 1, (BYTE *) &cbContent, cbLength);
    }
    return cbLength + 1;
}

// Prefix includes:
//  - 1 byte for number of unused bytes in the prefix
//  - 1 byte for the tag
//  - up to 5 bytes for the length octets
#define MAX_ENCODED_UTF8_PREFIX     (1 + 1 + MAX_LENGTH_OCTETS)
#define UTF8_ASN_TAG                0x0C

//+-------------------------------------------------------------------------
//  Allocate and Encode UTF8
//
//  The returned pbEncoded points to an ASN.1 encoded UTF8 string.
//  pbEncoded points to the UTF8_ASN_TAG, followed by the length octets and
//  then the UTF8 bytes.
//
//  *(pbEncoded -1) contains the number of unused bytes preceding the encoded
//  UTF8, ie, pbAllocEncoded = pbEncoded - *(pbEncoded -1).
//--------------------------------------------------------------------------
BOOL Asn1X509AllocAndEncodeUTF8(
        IN PCERT_RDN_VALUE_BLOB pValue,
        OUT BYTE **ppbEncoded,
        OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbAllocEncoded = NULL;
    BYTE *pbEncoded;
    DWORD cbEncoded;
    BYTE rgbLength[MAX_LENGTH_OCTETS];
    DWORD cbLength;
    DWORD cbUnusedPrefix;
    int cchUnicode;
    int cchUTF8;

    cchUnicode = pValue->cbData / sizeof(WCHAR);

    // In the largest buffer case there are 3 bytes per Unicode character.
    // The encoded UTF8 is preceded with a prefix consisting of a byte
    // indicating the number of unused bytes in the prefix, a byte for the
    // UTF8 tag and up to 5 bytes for the length octets.
    if (NULL == (pbAllocEncoded = (BYTE *) PkiNonzeroAlloc(
            MAX_ENCODED_UTF8_PREFIX + cchUnicode * 3)))
        goto OutOfMemory;

    if (0 == cchUnicode)
        cchUTF8 = 0;
    else {
        if (0 >= (cchUTF8 = WideCharToUTF8(
                (LPCWSTR) pValue->pbData,
                cchUnicode,
                (LPSTR) (pbAllocEncoded + MAX_ENCODED_UTF8_PREFIX),
                cchUnicode * 3
                )))
            goto WideCharToUTF8Error;
    }

    cbLength = Asn1X509GetLengthOctets(cchUTF8, rgbLength);
    assert(MAX_ENCODED_UTF8_PREFIX > (1 + cbLength));
    cbUnusedPrefix = MAX_ENCODED_UTF8_PREFIX - (1 + cbLength);
    pbEncoded = pbAllocEncoded + cbUnusedPrefix;
    cbEncoded = 1 + cbLength + cchUTF8;
    *(pbEncoded - 1) = (BYTE) cbUnusedPrefix;
    *(pbEncoded) = UTF8_ASN_TAG;
    memcpy(pbEncoded + 1, rgbLength, cbLength);

    fResult = TRUE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;

ErrorReturn:
    PkiFree(pbAllocEncoded);
    pbEncoded = NULL;
    cbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(WideCharToUTF8Error)
}

//+-------------------------------------------------------------------------
//  Free previously encoded UTF8
//
//  *(pbEncoded -1) contains the number of unused bytes preceding the encoded
//  UTF8, ie, pbAllocEncoded = pbEncoded - *(pbEncoded -1).
//--------------------------------------------------------------------------
void Asn1X509FreeEncodedUTF8(
        IN BYTE *pbEncoded
        )
{
    if (pbEncoded) {
        BYTE *pbAllocEncoded;

        assert(MAX_ENCODED_UTF8_PREFIX > *(pbEncoded -1));

        pbAllocEncoded = pbEncoded - *(pbEncoded - 1);
        PkiFree(pbAllocEncoded);
    }
}

//+-------------------------------------------------------------------------
//  Get UTF8
//--------------------------------------------------------------------------
BOOL Asn1X509GetUTF8(
        IN NOCOPYANY *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pdwValueType,
        OUT PCERT_RDN_VALUE_BLOB pValue,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    const BYTE *pbEncoded = (const BYTE *) pAsn1->encoded;
    DWORD cbEncoded = pAsn1->length;
    const BYTE *pbContent;
    DWORD cbContent;
    int cchUnicode;
    LPWSTR pwszUnicode = NULL;
    LONG lAlignExtra;
    LONG lData;


    if (0 == cbEncoded || UTF8_ASN_TAG != *pbEncoded)
        goto InvalidUTF8Tag;

    if (0 >= Asn1UtilExtractContent(
            pbEncoded,
            cbEncoded,
            &cbContent,
            &pbContent
            ))
        goto InvalidUTF8Header;

    if (0 == cbContent)
        cchUnicode = 0;
    else {
        if (pbContent + cbContent > pbEncoded + cbEncoded)
            goto InvalidUTF8Header;

        // In the largest buffer case there is one Unicode character per
        // UTF8 character
        if (NULL == (pwszUnicode = (LPWSTR) PkiNonzeroAlloc(
                cbContent * sizeof(WCHAR))))
            goto OutOfMemory;

        if (0 >= (cchUnicode = UTF8ToWideChar(
                (LPCSTR) pbContent,
                cbContent,              // cchUTF8
                pwszUnicode,
                cbContent               // cchUnicode
                )))
            goto UTF8ToWideCharError;
    }

    // Add + sizeof(WCHAR) for added 0 bytes. Want to ensure that the WCHAR
    // string is always null terminated
    lData = cchUnicode * sizeof(WCHAR);
    lAlignExtra = INFO_LEN_ALIGN(lData + sizeof(WCHAR));
    *plRemainExtra -= lAlignExtra;
    if (*plRemainExtra >= 0) {
        *pdwValueType = CERT_RDN_UTF8_STRING;
        pValue->pbData = *ppbExtra;
        pValue->cbData = (DWORD) lData;
        if (lData > 0)
            memcpy(pValue->pbData, pwszUnicode, lData);
        memset(pValue->pbData + lData, 0, sizeof(WCHAR));
        *ppbExtra += lAlignExtra;
    }

    fResult = TRUE;
CommonReturn:
    PkiFree(pwszUnicode);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidUTF8Tag, CRYPT_E_BAD_ENCODE)
SET_ERROR(InvalidUTF8Header, CRYPT_E_BAD_ENCODE)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(UTF8ToWideCharError)
}

#endif  // not defined ASN1_SUPPORTS_UTF8_TAG


//+-------------------------------------------------------------------------
//  Set/Get AnyString
//--------------------------------------------------------------------------
void Asn1X509SetAnyString(
        IN DWORD dwValueType,
        IN PCERT_RDN_VALUE_BLOB pValue,
        OUT AnyString *pAsn1
        )
{
    pAsn1->u.octetString.value = pValue->pbData;
    pAsn1->u.octetString.length = pValue->cbData;
    switch (dwValueType) {
        case CERT_RDN_OCTET_STRING:
            pAsn1->choice = octetString_chosen;
            break;
        case CERT_RDN_NUMERIC_STRING:
            pAsn1->choice = numericString_chosen;
            break;
        case CERT_RDN_PRINTABLE_STRING:
            pAsn1->choice = printableString_chosen;
            break;
        case CERT_RDN_TELETEX_STRING:
            pAsn1->choice = teletexString_chosen;
            break;
        case CERT_RDN_VIDEOTEX_STRING:
            pAsn1->choice = videotexString_chosen;
            break;
        case CERT_RDN_IA5_STRING:
            pAsn1->choice = ia5String_chosen;
            break;
        case CERT_RDN_GRAPHIC_STRING:
            pAsn1->choice = graphicString_chosen;
            break;
        case CERT_RDN_VISIBLE_STRING:
            pAsn1->choice = visibleString_chosen;
            break;
        case CERT_RDN_GENERAL_STRING:
            pAsn1->choice = generalString_chosen;
            break;
        case CERT_RDN_UNIVERSAL_STRING:
            pAsn1->choice = universalString_chosen;
            pAsn1->u.octetString.length = pValue->cbData / 4;
            break;
        case CERT_RDN_BMP_STRING:
            pAsn1->choice = bmpString_chosen;
            pAsn1->u.octetString.length = pValue->cbData / 2;
            break;
#ifdef ASN1_SUPPORTS_UTF8_TAG
        case CERT_RDN_UTF8_STRING:
            pAsn1->choice = utf8String_chosen;
            pAsn1->u.octetString.length = pValue->cbData / 2;
            break;
#endif // ASN1_SUPPORTS_UTF8_TAG
        default:
            assert(dwValueType >= CERT_RDN_OCTET_STRING &&
                dwValueType <= CERT_RDN_UTF8_STRING);
            pAsn1->choice = 0;
    }
}

void Asn1X509GetAnyString(
        IN AnyString *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pdwValueType,
        OUT PCERT_RDN_VALUE_BLOB pValue,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lAlignExtra;

    DWORD dwValueType;
    BYTE *pbData;
    LONG lData;

    pbData = pAsn1->u.octetString.value;
    lData = pAsn1->u.octetString.length;
    switch (pAsn1->choice) {
        case octetString_chosen:
            dwValueType = CERT_RDN_OCTET_STRING;
            break;
        case numericString_chosen:
            dwValueType = CERT_RDN_NUMERIC_STRING;
            break;
        case printableString_chosen:
            dwValueType = CERT_RDN_PRINTABLE_STRING;
            break;
        case teletexString_chosen:
            dwValueType = CERT_RDN_TELETEX_STRING;
            break;
        case videotexString_chosen:
            dwValueType = CERT_RDN_VIDEOTEX_STRING;
            break;
        case ia5String_chosen:
            dwValueType = CERT_RDN_IA5_STRING;
            break;
        case graphicString_chosen:
            dwValueType = CERT_RDN_GRAPHIC_STRING;
            break;
        case visibleString_chosen:
            dwValueType = CERT_RDN_VISIBLE_STRING;
            break;
        case generalString_chosen:
            dwValueType = CERT_RDN_GENERAL_STRING;
            break;
        case universalString_chosen:
            dwValueType = CERT_RDN_UNIVERSAL_STRING;
            lData = pAsn1->u.universalString.length * 4;
            break;
        case bmpString_chosen:
            dwValueType = CERT_RDN_BMP_STRING;
            lData = pAsn1->u.bmpString.length * 2;
            break;
#ifdef ASN1_SUPPORTS_UTF8_TAG
        case utf8String_chosen:
            dwValueType = CERT_RDN_UTF8_STRING;
            lData = pAsn1->u.utf8String.length * 2;
            break;
#endif // ASN1_SUPPORTS_UTF8_TAG
        default:
            assert(pAsn1->choice >= 1 && pAsn1->choice <= bmpString_chosen);
            dwValueType = 0;
    }

    // Add + sizeof(WCHAR) for added 0 bytes. Want to ensure that a char
    // or WCHAR string is always null terminated
    lAlignExtra = INFO_LEN_ALIGN(lData + sizeof(WCHAR));
    *plRemainExtra -= lAlignExtra;
    if (*plRemainExtra >= 0) {
        *pdwValueType = dwValueType;
        pValue->pbData = *ppbExtra;
        pValue->cbData = (DWORD) lData;
        if (lData > 0)
            memcpy(pValue->pbData, pbData, lData);
        memset(pValue->pbData + lData, 0, sizeof(WCHAR));
        *ppbExtra += lAlignExtra;
    }
}


//+-------------------------------------------------------------------------
//  Allocate and Encode AnyString
//--------------------------------------------------------------------------
BOOL Asn1X509AllocAndEncodeAnyString(
        IN DWORD dwValueType,
        IN PCERT_RDN_VALUE_BLOB pValue,
        OUT BYTE **ppbEncoded,
        OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    AnyString Asn1String;
    ASN1error_e Asn1Err;
    ASN1encoding_t pEnc = GetEncoder();

    Asn1X509SetAnyString(dwValueType, pValue, &Asn1String);

    *ppbEncoded = NULL;
    *pcbEncoded = 0;
    PkiAsn1SetEncodingRule(pEnc, ASN1_BER_RULE_DER);
    if (ASN1_SUCCESS != (Asn1Err = PkiAsn1Encode(
                pEnc,
                &Asn1String,
                AnyString_PDU,
                ppbEncoded,
                pcbEncoded
                )))
        goto Asn1EncodeError;

    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1EncodeError, PkiAsn1ErrToHr(Asn1Err))
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CERT_RDN attribute value
//--------------------------------------------------------------------------
BOOL Asn1X509SetRDNAttributeValue(
        IN DWORD dwValueType,
        IN PCERT_RDN_VALUE_BLOB pValue,
        OUT NOCOPYANY *pAsn1
        )
{
    memset(pAsn1, 0, sizeof(*pAsn1));
    if (dwValueType == CERT_RDN_ANY_TYPE) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    // Determine if value is an encoded representation or is a known string
    // type. Encode accordingly.
    if (dwValueType == CERT_RDN_ENCODED_BLOB) {
        Asn1X509SetAny(pValue, pAsn1);
#ifndef ASN1_SUPPORTS_UTF8_TAG
    } else if (dwValueType == CERT_RDN_UTF8_STRING) {
        CRYPT_OBJID_BLOB ObjIdBlob;

        if (!Asn1X509AllocAndEncodeUTF8(
                pValue,
                &ObjIdBlob.pbData,
                &ObjIdBlob.cbData))
            return FALSE;
        Asn1X509SetAny(&ObjIdBlob, pAsn1);
#endif  // not defined ASN1_SUPPORTS_UTF8_TAG
    } else {
        CRYPT_OBJID_BLOB ObjIdBlob;

        if (!Asn1X509AllocAndEncodeAnyString(
                dwValueType,
                pValue,
                &ObjIdBlob.pbData,
                &ObjIdBlob.cbData))
            return FALSE;
        Asn1X509SetAny(&ObjIdBlob, pAsn1);
    }
    return TRUE;
}

void Asn1X509FreeRDNAttributeValue(
        IN DWORD dwValueType,
        IN OUT NOCOPYANY *pAsn1
        )
{
#ifndef ASN1_SUPPORTS_UTF8_TAG
    if (dwValueType == CERT_RDN_UTF8_STRING) {
        Asn1X509FreeEncodedUTF8((BYTE *) pAsn1->encoded);
        pAsn1->encoded = NULL;
        pAsn1->length = 0;
    } else
#endif  // not defined ASN1_SUPPORTS_UTF8_TAG
    if (dwValueType != CERT_RDN_ENCODED_BLOB) {
        if (pAsn1->encoded) {
            DWORD dwErr = GetLastError();

            // TlsGetValue globbers LastError
            PkiAsn1FreeEncoded(GetEncoder(), pAsn1->encoded);
            pAsn1->encoded = NULL;

            SetLastError(dwErr);
        }
        pAsn1->length = 0;
    }
}

BOOL Asn1X509GetRDNAttributeValue(
        IN NOCOPYANY *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pdwValueType,
        OUT PCERT_RDN_VALUE_BLOB pValue,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    ASN1decoding_t pDec = GetDecoder();
    AnyString *pAsn1String = NULL;

#ifndef ASN1_SUPPORTS_UTF8_TAG
    if (0 < pAsn1->length && UTF8_ASN_TAG == *((BYTE *) pAsn1->encoded))
        return Asn1X509GetUTF8(
            pAsn1,
            dwFlags,
            pdwValueType,
            pValue,
            ppbExtra,
            plRemainExtra
            );
#endif  // not defined ASN1_SUPPORTS_UTF8_TAG


#ifdef OSS_CRYPT_ASN1
    unsigned long ulPrevDecodingFlags;


    // Since its acceptable for the following decode to fail, don't output
    // decode errors.
    ulPrevDecodingFlags = ossGetDecodingFlags((POssGlobal) pDec);
    if (ulPrevDecodingFlags & DEBUG_ERRORS)
        ossSetDecodingFlags((POssGlobal) pDec,
            ulPrevDecodingFlags & ~DEBUG_ERRORS);
    ossSetEncodingRules((POssGlobal) pDec, OSS_BER);
#endif  // OSS_CRYPT_ASN1

    // Check if the value is a string type
    if (ASN1_SUCCESS == PkiAsn1Decode(
            pDec,
            (void **) &pAsn1String,
            AnyString_PDU,
            (BYTE *) pAsn1->encoded,
            pAsn1->length
            )) {
        Asn1X509GetAnyString(pAsn1String, dwFlags, pdwValueType, pValue,
            ppbExtra, plRemainExtra);
    } else {
        // Encoded representation
        if (*plRemainExtra >= 0)
            *pdwValueType = CERT_RDN_ENCODED_BLOB;

        Asn1X509GetAny(pAsn1, dwFlags, pValue, ppbExtra, plRemainExtra);
    }

#ifdef OSS_CRYPT_ASN1
    // Restore previous flags
    if (ulPrevDecodingFlags & DEBUG_ERRORS)
        ossSetDecodingFlags((POssGlobal) pDec, ulPrevDecodingFlags);
#endif  // OSS_CRYPT_ASN1

    PkiAsn1FreeDecoded(
        pDec,
        pAsn1String,
        AnyString_PDU
        );

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CERT_RDN attribute
//--------------------------------------------------------------------------
BOOL Asn1X509SetRDNAttribute(
        IN PCERT_RDN_ATTR pInfo,
        OUT AttributeTypeValue *pAsn1
        )
{
    memset(pAsn1, 0, sizeof(*pAsn1));
    if (pInfo->pszObjId) {
        if (!Asn1X509SetEncodedObjId(pInfo->pszObjId, &pAsn1->type))
            return FALSE;
    }

    return Asn1X509SetRDNAttributeValue(
            pInfo->dwValueType,
            &pInfo->Value,
            &pAsn1->value
            );
}

void Asn1X509FreeRDNAttribute(
        IN PCERT_RDN_ATTR pInfo,
        IN OUT AttributeTypeValue *pAsn1
        )
{
    Asn1X509FreeRDNAttributeValue(
        pInfo->dwValueType,
        &pAsn1->value
        );
}

BOOL Asn1X509GetRDNAttribute(
        IN AttributeTypeValue *pAsn1,
        IN DWORD dwFlags,
        OUT PCERT_RDN_ATTR pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    // Get ObjectIdentifier
    Asn1X509GetEncodedObjId(&pAsn1->type, dwFlags, &pInfo->pszObjId,
            ppbExtra, plRemainExtra);

    // Get value
    return Asn1X509GetRDNAttributeValue(&pAsn1->value, dwFlags,
        &pInfo->dwValueType, &pInfo->Value, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get SeqOfAny
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509SetSeqOfAny(
        IN DWORD cValue,
        IN PCRYPT_DER_BLOB pValue,
#ifdef OSS_CRYPT_ASN1
        OUT unsigned int *pAsn1Count,
#else
        OUT ASN1uint32_t *pAsn1Count,
#endif  // OSS_CRYPT_ASN1
        OUT NOCOPYANY **ppAsn1Value
        )
{
    
    *pAsn1Count = 0;
    *ppAsn1Value = NULL;
    if (cValue > 0) {
        NOCOPYANY *pAsn1Value;

        pAsn1Value = (NOCOPYANY *) PkiZeroAlloc(cValue * sizeof(NOCOPYANY));
        if (pAsn1Value == NULL)
            return FALSE;
        *pAsn1Count = cValue;
        *ppAsn1Value = pAsn1Value;
        for ( ; cValue > 0; cValue--, pValue++, pAsn1Value++)
            Asn1X509SetAny(pValue, pAsn1Value);
    }
    return TRUE;
}

void Asn1X509FreeSeqOfAny(
        IN NOCOPYANY *pAsn1Value
        )
{
    if (pAsn1Value)
        PkiFree(pAsn1Value);
}

void Asn1X509GetSeqOfAny(
        IN unsigned int Asn1Count,
        IN NOCOPYANY *pAsn1Value,
        IN DWORD dwFlags,
        OUT DWORD *pcValue,
        OUT PCRYPT_DER_BLOB *ppValue,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lAlignExtra;
    PCRYPT_ATTR_BLOB pValue;

    lAlignExtra = INFO_LEN_ALIGN(Asn1Count * sizeof(CRYPT_DER_BLOB));
    *plRemainExtra -= lAlignExtra;
    if (*plRemainExtra >= 0) {
        *pcValue = Asn1Count;
        pValue = (PCRYPT_DER_BLOB) *ppbExtra;
        *ppValue = pValue;
        *ppbExtra += lAlignExtra;
    } else
        pValue = NULL;

    for (; Asn1Count > 0; Asn1Count--, pAsn1Value++, pValue++)
        Asn1X509GetAny(pAsn1Value, dwFlags, pValue, ppbExtra, plRemainExtra);
}


//+-------------------------------------------------------------------------
//  Set/Free/Get CRYPT_ATTRIBUTE
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509SetAttribute(
        IN PCRYPT_ATTRIBUTE pInfo,
        OUT Attribute *pAsn1
        )
{
    memset(pAsn1, 0, sizeof(*pAsn1));
    if (!Asn1X509SetEncodedObjId(pInfo->pszObjId, &pAsn1->type))
        return FALSE;

    return Asn1X509SetSeqOfAny(
            pInfo->cValue,
            pInfo->rgValue,
            &pAsn1->values.count,
            &pAsn1->values.value);
}

void Asn1X509FreeAttribute(
        IN OUT Attribute *pAsn1
        )
{
    Asn1X509FreeSeqOfAny(pAsn1->values.value);
}

void Asn1X509GetAttribute(
        IN Attribute *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_ATTRIBUTE pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    Asn1X509GetEncodedObjId(&pAsn1->type, dwFlags,
        &pInfo->pszObjId, ppbExtra, plRemainExtra);
    Asn1X509GetSeqOfAny(pAsn1->values.count, pAsn1->values.value, dwFlags,
        &pInfo->cValue, &pInfo->rgValue, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Attributes
//--------------------------------------------------------------------------
BOOL Asn1X509SetAttributes(
        IN DWORD cAttribute,
        IN PCRYPT_ATTRIBUTE pAttribute,
        OUT Attributes *pAsn1
        )
{
    Attribute *pAsn1Attr;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cAttribute == 0)
        return TRUE;

    pAsn1Attr = (Attribute *) PkiZeroAlloc(cAttribute * sizeof(Attribute));
    if (pAsn1Attr == NULL)
        return FALSE;
    pAsn1->value = pAsn1Attr;
    pAsn1->count = cAttribute;

    for ( ; cAttribute > 0; cAttribute--, pAttribute++, pAsn1Attr++) {
        if (!Asn1X509SetAttribute(pAttribute, pAsn1Attr))
            return FALSE;
    }
    return TRUE;
}

void Asn1X509FreeAttributes(
        IN Attributes *pAsn1
        )
{
    if (pAsn1->value) {
        DWORD cAttr = pAsn1->count;
        Attribute *pAsn1Attr = pAsn1->value;

        for ( ; cAttr > 0; cAttr--, pAsn1Attr++)
            Asn1X509FreeAttribute(pAsn1Attr);

        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

void Asn1X509GetAttributes(
        IN Attributes *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcAttribute,
        OUT PCRYPT_ATTRIBUTE *ppAttribute,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cAttr;
    Attribute *pAsn1Attr;
    PCRYPT_ATTRIBUTE pGetAttr;

    cAttr = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cAttr * sizeof(CRYPT_ATTRIBUTE));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcAttribute = cAttr;
        pGetAttr = (PCRYPT_ATTRIBUTE) pbExtra;
        *ppAttribute = pGetAttr;
        pbExtra += lAlignExtra;
    } else
        pGetAttr = NULL;

    pAsn1Attr = pAsn1->value;
    for ( ; cAttr > 0; cAttr--, pAsn1Attr++, pGetAttr++) {
        Asn1X509GetAttribute(pAsn1Attr, dwFlags, pGetAttr,
                &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CERT_ALT_NAME_ENTRY
//--------------------------------------------------------------------------
BOOL Asn1X509SetAltNameEntry(
        IN PCERT_ALT_NAME_ENTRY pInfo,
        OUT GeneralName *pAsn1,
        IN DWORD dwEntryIndex,
        OUT DWORD *pdwErrLocation
        )
{
    BOOL fResult;

    // Assumption: ASN1 choice == dwAltNameChoice
    // Asn1X509GetAltNameEntry has asserts to verify
    pAsn1->choice = (unsigned short) pInfo->dwAltNameChoice;

    *pdwErrLocation = 0;

    switch (pInfo->dwAltNameChoice) {
    case CERT_ALT_NAME_OTHER_NAME:
        if (!Asn1X509SetEncodedObjId(pInfo->pOtherName->pszObjId,
                &pAsn1->u.otherName.type))
            goto ErrorReturn;
        Asn1X509SetAny(&pInfo->pOtherName->Value, &pAsn1->u.otherName.value);
        break;
    case CERT_ALT_NAME_DIRECTORY_NAME:
        Asn1X509SetAny(&pInfo->DirectoryName, &pAsn1->u.directoryName);
        break;
    case CERT_ALT_NAME_RFC822_NAME:
    case CERT_ALT_NAME_DNS_NAME:
    case CERT_ALT_NAME_URL:
        if (!Asn1X509SetUnicodeConvertedToIA5(pInfo->pwszRfc822Name,
                &pAsn1->u.rfc822Name, dwEntryIndex, pdwErrLocation))
            goto ErrorReturn;
        break;
    case CERT_ALT_NAME_IP_ADDRESS:
        Asn1X509SetOctetString(&pInfo->IPAddress, &pAsn1->u.iPAddress);
        break;
    case CERT_ALT_NAME_REGISTERED_ID:
        if (!Asn1X509SetEncodedObjId(pInfo->pszRegisteredID, &pAsn1->u.registeredID))
            goto ErrorReturn;
        break;
    case CERT_ALT_NAME_X400_ADDRESS:
    case CERT_ALT_NAME_EDI_PARTY_NAME:
    default:
        SetLastError((DWORD) E_INVALIDARG);
        goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

void Asn1X509FreeAltNameEntry(
        IN GeneralName *pAsn1
        )
{
    switch (pAsn1->choice) {
    case CERT_ALT_NAME_RFC822_NAME:
    case CERT_ALT_NAME_DNS_NAME:
    case CERT_ALT_NAME_URL:
        Asn1X509FreeUnicodeConvertedToIA5(&pAsn1->u.rfc822Name);
        break;
    default:
        break;
    }
}

BOOL Asn1X509GetAltNameEntry(
        IN GeneralName *pAsn1,
        IN DWORD dwFlags,
        OUT PCERT_ALT_NAME_ENTRY pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    DWORD dwAltNameChoice;

    assert(otherName_chosen == CERT_ALT_NAME_OTHER_NAME);
    assert(rfc822Name_chosen == CERT_ALT_NAME_RFC822_NAME);
    assert(dNSName_chosen == CERT_ALT_NAME_DNS_NAME);
    assert(x400Address_chosen == CERT_ALT_NAME_X400_ADDRESS);
    assert(directoryName_chosen == CERT_ALT_NAME_DIRECTORY_NAME);
    assert(ediPartyName_chosen == CERT_ALT_NAME_EDI_PARTY_NAME);
    assert(uniformResourceLocator_chosen == CERT_ALT_NAME_URL);
    assert(iPAddress_chosen == CERT_ALT_NAME_IP_ADDRESS);
    assert(registeredID_chosen == CERT_ALT_NAME_REGISTERED_ID);


    dwAltNameChoice = pAsn1->choice;
    if (*plRemainExtra >= 0)
        pInfo->dwAltNameChoice = dwAltNameChoice;
    switch (dwAltNameChoice) {
    case CERT_ALT_NAME_OTHER_NAME:
        {
            LONG lAlignExtra;
            PCERT_OTHER_NAME pOtherName;

            lAlignExtra = INFO_LEN_ALIGN(sizeof(CERT_OTHER_NAME));
            *plRemainExtra -= lAlignExtra;
            if (*plRemainExtra >= 0) {
                pOtherName = (PCERT_OTHER_NAME) *ppbExtra;
                pInfo->pOtherName = pOtherName;
                *ppbExtra += lAlignExtra;
            } else
                pOtherName = NULL;

            Asn1X509GetEncodedObjId(&pAsn1->u.otherName.type, dwFlags,
                &pOtherName->pszObjId, ppbExtra, plRemainExtra);
            Asn1X509GetAny(&pAsn1->u.otherName.value, dwFlags,
                &pOtherName->Value, ppbExtra, plRemainExtra);
        }
        break;
    case CERT_ALT_NAME_DIRECTORY_NAME:
        Asn1X509GetAny(&pAsn1->u.directoryName, dwFlags,
            &pInfo->DirectoryName, ppbExtra, plRemainExtra);
        break;
    case CERT_ALT_NAME_RFC822_NAME:
    case CERT_ALT_NAME_DNS_NAME:
    case CERT_ALT_NAME_URL:
        Asn1X509GetIA5ConvertedToUnicode(&pAsn1->u.rfc822Name, dwFlags,
            &pInfo->pwszRfc822Name, ppbExtra, plRemainExtra);
        break;
    case CERT_ALT_NAME_IP_ADDRESS:
        Asn1X509GetOctetString(&pAsn1->u.iPAddress, dwFlags,
            &pInfo->IPAddress, ppbExtra, plRemainExtra);
        break;
    case CERT_ALT_NAME_REGISTERED_ID:
        Asn1X509GetEncodedObjId(&pAsn1->u.registeredID, dwFlags,
            &pInfo->pszRegisteredID, ppbExtra, plRemainExtra);
        break;
    case CERT_ALT_NAME_X400_ADDRESS:
    case CERT_ALT_NAME_EDI_PARTY_NAME:
        break;
    default:
        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
        return FALSE;
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//  Set/Free/Get CERT_ALT_NAME_INFO
//--------------------------------------------------------------------------
BOOL Asn1X509SetAltNames(
        IN PCERT_ALT_NAME_INFO pInfo,
        OUT AltNames *pAsn1,
        IN DWORD dwIndex,
        OUT DWORD *pdwErrLocation
        )
{
    BOOL fResult;
    DWORD i;
    DWORD cEntry;
    PCERT_ALT_NAME_ENTRY pEntry;
    GeneralName *pAsn1Entry = NULL;

    *pdwErrLocation = 0;

    cEntry = pInfo->cAltEntry;
    pEntry = pInfo->rgAltEntry;
    pAsn1->count = cEntry;
    pAsn1->value = NULL;
    if (cEntry > 0) {
        pAsn1Entry =
            (GeneralName *) PkiZeroAlloc(cEntry * sizeof(GeneralName));
        if (pAsn1Entry == NULL)
            goto ErrorReturn;
        pAsn1->value = pAsn1Entry;
    }

    // Array of AltName entries
    for (i = 0; i < cEntry; i++, pEntry++, pAsn1Entry++) {
        if (!Asn1X509SetAltNameEntry(pEntry, pAsn1Entry,
                (dwIndex << 8) | i, pdwErrLocation))
            goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

void Asn1X509FreeAltNames(
        OUT AltNames *pAsn1
        )
{
    if (pAsn1->value) {
        DWORD cEntry = pAsn1->count;
        GeneralName *pAsn1Entry = pAsn1->value;
        for ( ; cEntry > 0; cEntry--, pAsn1Entry++)
            Asn1X509FreeAltNameEntry(pAsn1Entry);
        PkiFree(pAsn1->value);
    }
}

BOOL Asn1X509GetAltNames(
        IN AltNames *pAsn1,
        IN DWORD dwFlags,
        OUT PCERT_ALT_NAME_INFO pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lAlignExtra;
    DWORD cEntry;
    PCERT_ALT_NAME_ENTRY pEntry;
    GeneralName *pAsn1Entry;

    cEntry = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cEntry * sizeof(CERT_ALT_NAME_ENTRY));
    *plRemainExtra -= lAlignExtra;
    if (*plRemainExtra >= 0) {
        pInfo->cAltEntry = cEntry;
        pEntry = (PCERT_ALT_NAME_ENTRY) *ppbExtra;
        pInfo->rgAltEntry = pEntry;
        *ppbExtra += lAlignExtra;
    } else
        pEntry = NULL;

    // Array of AltName entries
    pAsn1Entry = pAsn1->value;
    for (; cEntry > 0; cEntry--, pEntry++, pAsn1Entry++) {
        if (!Asn1X509GetAltNameEntry(pAsn1Entry, dwFlags,
                    pEntry, ppbExtra, plRemainExtra))
                return FALSE;
    }
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CERT_ACCESS_DESCRIPTION
//--------------------------------------------------------------------------
BOOL Asn1X509SetAccessDescriptions(
        IN DWORD cAccDescr,
        IN PCERT_ACCESS_DESCRIPTION pAccDescr,
        OUT AccessDescription *pAsn1,
        OUT DWORD *pdwErrLocation
        )
{
    BOOL fResult;
    DWORD i;

    *pdwErrLocation = 0;
    for (i = 0; i < cAccDescr; i++, pAccDescr++, pAsn1++) {
        if (!Asn1X509SetEncodedObjId(pAccDescr->pszAccessMethod, &pAsn1->accessMethod))
            goto ErrorReturn;
        if (!Asn1X509SetAltNameEntry(&pAccDescr->AccessLocation,
                &pAsn1->accessLocation,
                i,
                pdwErrLocation))
            goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

void Asn1X509FreeAccessDescriptions(
        IN DWORD cAccDescr,
        IN OUT AccessDescription *pAsn1
        )
{
    for ( ; cAccDescr > 0; cAccDescr--, pAsn1++)
        Asn1X509FreeAltNameEntry(&pAsn1->accessLocation);
}

BOOL Asn1X509GetAccessDescriptions(
        IN DWORD cAccDescr,
        IN AccessDescription *pAsn1,
        IN DWORD dwFlags,
        IN PCERT_ACCESS_DESCRIPTION pAccDescr,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    // Array of AccessDescription entries
    for (; cAccDescr > 0; cAccDescr--, pAccDescr++, pAsn1++) {
        Asn1X509GetEncodedObjId(&pAsn1->accessMethod, dwFlags,
                &pAccDescr->pszAccessMethod, ppbExtra, plRemainExtra);
        if (!Asn1X509GetAltNameEntry(&pAsn1->accessLocation, dwFlags,
                &pAccDescr->AccessLocation, ppbExtra, plRemainExtra))
            return FALSE;
    }
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Encode the Cert Info (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CertInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CertificateToBeSigned Cert;

    memset(&Cert, 0, sizeof(Cert));
    if (pInfo->dwVersion != 0) {
#ifdef OSS_CRYPT_ASN1
        Cert.CertificateToBeSigned_version = pInfo->dwVersion;
#else
        Cert.version = pInfo->dwVersion;
#endif  // OSS_CRYPT_ASN1
        Cert.bit_mask |= CertificateToBeSigned_version_present;
    }

    if (!Asn1X509SetHugeInteger(&pInfo->SerialNumber, &Cert.serialNumber))
        goto ErrorReturn;
    if (!Asn1X509SetAlgorithm(&pInfo->SignatureAlgorithm, &Cert.signature,
            CRYPT_SIGN_ALG_OID_GROUP_ID))
        goto ErrorReturn;
    Asn1X509SetAny(&pInfo->Issuer, &Cert.issuer);
    if (!PkiAsn1ToChoiceOfTime(&pInfo->NotBefore, 
            &Cert.validity.notBefore.choice,
            &Cert.validity.notBefore.u.generalTime,
            &Cert.validity.notBefore.u.utcTime
            ))
        goto EncodeError;
    if (!PkiAsn1ToChoiceOfTime(&pInfo->NotAfter, 
            &Cert.validity.notAfter.choice,
            &Cert.validity.notAfter.u.generalTime,
            &Cert.validity.notAfter.u.utcTime
            ))
        goto EncodeError;
    Asn1X509SetAny(&pInfo->Subject, &Cert.subject);
    if (!Asn1X509SetPublicKeyInfo(&pInfo->SubjectPublicKeyInfo,
            &Cert.subjectPublicKeyInfo))
        goto ErrorReturn;

    if (pInfo->IssuerUniqueId.cbData) {
        Asn1X509SetBit(&pInfo->IssuerUniqueId, &Cert.issuerUniqueIdentifier);
        Cert.bit_mask |= issuerUniqueIdentifier_present;
    }
    if (pInfo->SubjectUniqueId.cbData) {
        Asn1X509SetBit(&pInfo->SubjectUniqueId, &Cert.subjectUniqueIdentifier);
        Cert.bit_mask |= subjectUniqueIdentifier_present;
    }
    if (pInfo->cExtension) {
        if (!Asn1X509SetExtensions(pInfo->cExtension, pInfo->rgExtension,
                &Cert.extensions))
            goto ErrorReturn;
        Cert.bit_mask |= extensions_present;
    }

    fResult = Asn1InfoEncodeEx(
        CertificateToBeSigned_PDU,
        &Cert,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

EncodeError:
    SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeHugeInteger(&Cert.serialNumber);
    Asn1X509FreeExtensions(&Cert.extensions);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode the Cert Info (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CertInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CertificateToBeSigned *pCert = (CertificateToBeSigned *) pvAsn1Info;
    PCERT_INFO pInfo = (PCERT_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_INFO));

        // Update fields not needing extra memory after the CERT_INFO
        if (pCert->bit_mask & CertificateToBeSigned_version_present)
#ifdef OSS_CRYPT_ASN1
            pInfo->dwVersion = pCert->CertificateToBeSigned_version;
#else
            pInfo->dwVersion = pCert->version;
#endif  // OSS_CRYPT_ASN1
        if (!PkiAsn1FromChoiceOfTime(pCert->validity.notBefore.choice,
                &pCert->validity.notBefore.u.generalTime,
                &pCert->validity.notBefore.u.utcTime,
                &pInfo->NotBefore))
            goto DecodeError;
        if (!PkiAsn1FromChoiceOfTime(pCert->validity.notAfter.choice,
                &pCert->validity.notAfter.u.generalTime,
                &pCert->validity.notAfter.u.utcTime,
                &pInfo->NotAfter))
            goto DecodeError;
        pbExtra = (BYTE *) pInfo + sizeof(CERT_INFO);
    }

    Asn1X509GetHugeInteger(&pCert->serialNumber, dwFlags,
            &pInfo->SerialNumber, &pbExtra, &lRemainExtra);
    Asn1X509GetAlgorithm(&pCert->signature, dwFlags,
            &pInfo->SignatureAlgorithm, &pbExtra, &lRemainExtra);
    Asn1X509GetAny(&pCert->issuer, dwFlags,
            &pInfo->Issuer, &pbExtra, &lRemainExtra);
    Asn1X509GetAny(&pCert->subject, dwFlags,
            &pInfo->Subject, &pbExtra, &lRemainExtra);
    Asn1X509GetPublicKeyInfo(&pCert->subjectPublicKeyInfo, dwFlags,
            &pInfo->SubjectPublicKeyInfo, &pbExtra, &lRemainExtra);

    if (pCert->bit_mask & issuerUniqueIdentifier_present)
        Asn1X509GetBit(&pCert->issuerUniqueIdentifier, dwFlags,
            &pInfo->IssuerUniqueId, &pbExtra, &lRemainExtra);
    if (pCert->bit_mask & subjectUniqueIdentifier_present)
        Asn1X509GetBit(&pCert->subjectUniqueIdentifier, dwFlags,
            &pInfo->SubjectUniqueId, &pbExtra, &lRemainExtra);
    if (pCert->bit_mask & extensions_present)
        Asn1X509GetExtensions(&pCert->extensions, dwFlags,
            &pInfo->cExtension, &pInfo->rgExtension, &pbExtra, &lRemainExtra);

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(DecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1X509CertInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    const BYTE *pbToBeSigned;
    DWORD cbToBeSigned;

    if ((dwFlags & CRYPT_DECODE_TO_BE_SIGNED_FLAG) ||
            !Asn1UtilExtractCertificateToBeSignedContent(
                pbEncoded,
                cbEncoded,
                &cbToBeSigned,
                &pbToBeSigned
                )) {
        pbToBeSigned = pbEncoded;
        cbToBeSigned = cbEncoded;
    }

    return Asn1InfoDecodeAndAllocEx(
        CertificateToBeSigned_PDU,
        pbToBeSigned,
        cbToBeSigned,
        dwFlags,
        pDecodePara,
        Asn1X509CertInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Encode the CRL Info (ASN1 X509 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CrlInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRL_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CertificateRevocationListToBeSigned Crl;

    memset(&Crl, 0, sizeof(Crl));

    if (pInfo->dwVersion != 0) {
#ifdef OSS_CRYPT_ASN1
        Crl.CertificateRevocationListToBeSigned_version = pInfo->dwVersion;
#else
        Crl.version = pInfo->dwVersion;
#endif  // OSS_CRYPT_ASN1
        Crl.bit_mask |= CertificateRevocationListToBeSigned_version_present;
    }
    if (!Asn1X509SetAlgorithm(&pInfo->SignatureAlgorithm, &Crl.signature,
            CRYPT_SIGN_ALG_OID_GROUP_ID))
        goto ErrorReturn;
    Asn1X509SetAny(&pInfo->Issuer, &Crl.issuer);
    if (!PkiAsn1ToChoiceOfTime(&pInfo->ThisUpdate, 
            &Crl.thisUpdate.choice,
            &Crl.thisUpdate.u.generalTime,
            &Crl.thisUpdate.u.utcTime
            ))
        goto EncodeError;
    if (pInfo->NextUpdate.dwLowDateTime || pInfo->NextUpdate.dwHighDateTime) {
        Crl.bit_mask |= nextUpdate_present;
        if (!PkiAsn1ToChoiceOfTime(&pInfo->NextUpdate, 
                &Crl.nextUpdate.choice,
                &Crl.nextUpdate.u.generalTime,
                &Crl.nextUpdate.u.utcTime
                ))
            goto EncodeError;
    }
    if (pInfo->cCRLEntry) {
        if (!Asn1X509SetCrlEntries(pInfo->cCRLEntry, pInfo->rgCRLEntry,
                &Crl.revokedCertificates))
            goto ErrorReturn;
        Crl.bit_mask |= revokedCertificates_present;
    }
    if (pInfo->cExtension) {
        if (!Asn1X509SetExtensions(pInfo->cExtension, pInfo->rgExtension,
                &Crl.crlExtensions))
            goto ErrorReturn;
        Crl.bit_mask |= crlExtensions_present;
    }

    fResult = Asn1InfoEncodeEx(
        CertificateRevocationListToBeSigned_PDU,
        &Crl,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

EncodeError:
    SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeCrlEntries(&Crl.revokedCertificates);
    Asn1X509FreeExtensions(&Crl.crlExtensions);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode the CRL Info (ASN1 X509 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CrlInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CertificateRevocationListToBeSigned *pCrl = 
        (CertificateRevocationListToBeSigned *) pvAsn1Info;
    PCRL_INFO pInfo = (PCRL_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRL_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CRL_INFO));

        // Update fields not needing extra memory after the CRL_INFO
        if (pCrl->bit_mask &
                CertificateRevocationListToBeSigned_version_present)
#ifdef OSS_CRYPT_ASN1
            pInfo->dwVersion =
                pCrl->CertificateRevocationListToBeSigned_version;
#else
            pInfo->dwVersion = pCrl->version;
#endif  // OSS_CRYPT_ASN1
        if (!PkiAsn1FromChoiceOfTime(pCrl->thisUpdate.choice,
                &pCrl->thisUpdate.u.generalTime,
                &pCrl->thisUpdate.u.utcTime,
                &pInfo->ThisUpdate))
            goto DecodeError;
        if (pCrl->bit_mask & nextUpdate_present) {
            if (!PkiAsn1FromChoiceOfTime(pCrl->nextUpdate.choice,
                    &pCrl->nextUpdate.u.generalTime,
                    &pCrl->nextUpdate.u.utcTime,
                    &pInfo->NextUpdate))
                goto DecodeError;
        }

        pbExtra = (BYTE *) pInfo + sizeof(CRL_INFO);
    }

    Asn1X509GetAlgorithm(&pCrl->signature, dwFlags,
            &pInfo->SignatureAlgorithm, &pbExtra, &lRemainExtra);
    Asn1X509GetAny(&pCrl->issuer, dwFlags,
            &pInfo->Issuer, &pbExtra, &lRemainExtra);
    if (pCrl->bit_mask & revokedCertificates_present)
        Asn1X509GetCrlEntries(&pCrl->revokedCertificates, dwFlags,
            &pInfo->cCRLEntry, &pInfo->rgCRLEntry, &pbExtra, &lRemainExtra);
    if (pCrl->bit_mask & crlExtensions_present)
        Asn1X509GetExtensions(&pCrl->crlExtensions, dwFlags,
            &pInfo->cExtension, &pInfo->rgExtension, &pbExtra, &lRemainExtra);

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(DecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1X509CrlInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    const BYTE *pbToBeSigned;
    DWORD cbToBeSigned;

    if ((dwFlags & CRYPT_DECODE_TO_BE_SIGNED_FLAG) ||
            !Asn1UtilExtractCertificateToBeSignedContent(
                pbEncoded,
                cbEncoded,
                &cbToBeSigned,
                &pbToBeSigned
                )) {
        pbToBeSigned = pbEncoded;
        cbToBeSigned = cbEncoded;
    }

    return Asn1InfoDecodeAndAllocEx(
        CertificateRevocationListToBeSigned_PDU,
        pbToBeSigned,
        cbToBeSigned,
        dwFlags,
        pDecodePara,
        Asn1X509CrlInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Encode the Cert Request Info (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CertRequestInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_REQUEST_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CertificationRequestInfo CertReq;

    memset(&CertReq, 0, sizeof(CertReq));
    CertReq.version = pInfo->dwVersion;

    Asn1X509SetAny(&pInfo->Subject, &CertReq.subject);
    if (!Asn1X509SetPublicKeyInfo(&pInfo->SubjectPublicKeyInfo,
            &CertReq.subjectPublicKeyInfo))
        goto ErrorReturn;

    if (!Asn1X509SetAttributes(pInfo->cAttribute, pInfo->rgAttribute,
            &CertReq.attributes))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        CertificationRequestInfo_PDU,
        &CertReq,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeAttributes(&CertReq.attributes);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode the Cert Request Info (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CertRequestInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    CertificationRequestInfoDecode *pCertReq = 
        (CertificationRequestInfoDecode *) pvAsn1Info;
    PCERT_REQUEST_INFO pInfo = (PCERT_REQUEST_INFO) pvStructInfo;
    BYTE *pbExtra;
    LONG lRemainExtra = *plRemainExtra;

    lRemainExtra -= sizeof(CERT_REQUEST_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_REQUEST_INFO));

        // Update fields not needing extra memory after the CERT_INFO
        pInfo->dwVersion = pCertReq->version;
        pbExtra = (BYTE *) pInfo + sizeof(CERT_REQUEST_INFO);
    }

    Asn1X509GetAny(&pCertReq->subject, dwFlags,
            &pInfo->Subject, &pbExtra, &lRemainExtra);
    Asn1X509GetPublicKeyInfo(&pCertReq->subjectPublicKeyInfo, dwFlags,
            &pInfo->SubjectPublicKeyInfo,
            &pbExtra, &lRemainExtra);

    if (pCertReq->bit_mask & attributes_present) {
        Asn1X509GetAttributes(&pCertReq->attributes, dwFlags,
            &pInfo->cAttribute, &pInfo->rgAttribute, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509CertRequestInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    const BYTE *pbToBeSigned;
    DWORD cbToBeSigned;

    if ((dwFlags & CRYPT_DECODE_TO_BE_SIGNED_FLAG) ||
            !Asn1UtilExtractCertificateToBeSignedContent(
                pbEncoded,
                cbEncoded,
                &cbToBeSigned,
                &pbToBeSigned
                )) {
        pbToBeSigned = pbEncoded;
        cbToBeSigned = cbEncoded;
    }

    return Asn1InfoDecodeAndAllocEx(
        CertificationRequestInfoDecode_PDU,
        pbToBeSigned,
        cbToBeSigned,
        dwFlags,
        pDecodePara,
        Asn1X509CertRequestInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Encode the Keygen Request Info (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509KeygenRequestInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_KEYGEN_REQUEST_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    KeygenRequestInfo KeygenReq;
    DWORD dwErrLocation;

    memset(&KeygenReq, 0, sizeof(KeygenReq));

    if (!Asn1X509SetPublicKeyInfo(&pInfo->SubjectPublicKeyInfo,
            &KeygenReq.subjectPublicKeyInfo))
        goto ErrorReturn;
    if (!Asn1X509SetUnicodeConvertedToIA5(pInfo->pwszChallengeString,
            &KeygenReq.challenge, 0, &dwErrLocation)) {
        *pcbEncoded = dwErrLocation;
        goto InvalidIA5;
    }

    fResult = Asn1InfoEncodeEx(
        KeygenRequestInfo_PDU,
        &KeygenReq,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
InvalidIA5:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeUnicodeConvertedToIA5(&KeygenReq.challenge);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode the Keygen Request Info (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509KeygenRequestInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    KeygenRequestInfo *pKeygenReq = (KeygenRequestInfo *) pvAsn1Info;
    PCERT_KEYGEN_REQUEST_INFO pInfo = (PCERT_KEYGEN_REQUEST_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_KEYGEN_REQUEST_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_KEYGEN_REQUEST_INFO));

        pbExtra = (BYTE *) pInfo + sizeof(CERT_KEYGEN_REQUEST_INFO);
    }

    Asn1X509GetPublicKeyInfo(&pKeygenReq->subjectPublicKeyInfo, dwFlags,
        &pInfo->SubjectPublicKeyInfo, &pbExtra, &lRemainExtra);
    Asn1X509GetIA5ConvertedToUnicode(&pKeygenReq->challenge, dwFlags,
            &pInfo->pwszChallengeString, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509KeygenRequestInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    const BYTE *pbToBeSigned;
    DWORD cbToBeSigned;

    if ((dwFlags & CRYPT_DECODE_TO_BE_SIGNED_FLAG) ||
            !Asn1UtilExtractCertificateToBeSignedContent(
                pbEncoded,
                cbEncoded,
                &cbToBeSigned,
                &pbToBeSigned
                )) {
        pbToBeSigned = pbEncoded;
        cbToBeSigned = cbEncoded;
    }

    return Asn1InfoDecodeAndAllocEx(
        KeygenRequestInfo_PDU,
        pbToBeSigned,
        cbToBeSigned,
        dwFlags,
        pDecodePara,
        Asn1X509KeygenRequestInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Encode the Signed Content (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509SignedContentEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_SIGNED_CONTENT_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    SignedContent Asn1SignedContent;
    CRYPT_BIT_BLOB SignatureBlob;
    BYTE *pbAllocSignature = NULL;

    memset(&Asn1SignedContent, 0, sizeof(Asn1SignedContent));
    Asn1X509SetAny(&pInfo->ToBeSigned, &Asn1SignedContent.toBeSigned);
    if (!Asn1X509SetAlgorithm(&pInfo->SignatureAlgorithm,
            &Asn1SignedContent.algorithm, CRYPT_SIGN_ALG_OID_GROUP_ID))
        goto ErrorReturn;

    if (dwFlags & CRYPT_ENCODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG) {
        SignatureBlob.pbData = pInfo->Signature.pbData;
    } else {
        if (NULL == (pbAllocSignature = PkiAsn1AllocAndReverseBytes(
                pInfo->Signature.pbData, pInfo->Signature.cbData)))
            goto ErrorReturn;
        SignatureBlob.pbData = pbAllocSignature;
    }
    SignatureBlob.cbData = pInfo->Signature.cbData;
    SignatureBlob.cUnusedBits = 0;
    Asn1X509SetBit(&SignatureBlob, &Asn1SignedContent.signature);

    fResult = Asn1InfoEncodeEx(
        SignedContent_PDU,
        &Asn1SignedContent,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbAllocSignature)
        PkiAsn1Free(pbAllocSignature);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode the Signed Content (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509SignedContentDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    SignedContent *pSignedContent = (SignedContent *) pvAsn1Info;
    PCERT_SIGNED_CONTENT_INFO pInfo = (PCERT_SIGNED_CONTENT_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_SIGNED_CONTENT_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_SIGNED_CONTENT_INFO);

    Asn1X509GetAny(&pSignedContent->toBeSigned, dwFlags,
        &pInfo->ToBeSigned, &pbExtra, &lRemainExtra);
    Asn1X509GetAlgorithm(&pSignedContent->algorithm, dwFlags,
        &pInfo->SignatureAlgorithm, &pbExtra, &lRemainExtra);
    // Since bits will be reversed, always need to make a copy (dwFlags = 0)
    Asn1X509GetBit(&pSignedContent->signature, 0,
        &pInfo->Signature, &pbExtra, &lRemainExtra);
    if (lRemainExtra >= 0) {
        if (0 == (dwFlags & CRYPT_DECODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG))
            PkiAsn1ReverseBytes(pInfo->Signature.pbData,
                pInfo->Signature.cbData);
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509SignedContentDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
            SignedContent_PDU,
            pbEncoded,
            cbEncoded,
            dwFlags,
            pDecodePara,
            Asn1X509SignedContentDecodeExCallback,
            pvStructInfo,
            pcbStructInfo
            );
}

//+-------------------------------------------------------------------------
//  Encode the Name Info (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509NameInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD cRDN, cAttr;
    PCERT_RDN pRDN;
    PCERT_RDN_ATTR pAttr;
    Name Asn1Name;
    RelativeDistinguishedName *pAsn1RDN = NULL;
    AttributeTypeValue *pAsn1Attr = NULL;

    cRDN = pInfo->cRDN;
    pRDN = pInfo->rgRDN;
    Asn1Name.count = cRDN;
    Asn1Name.value = NULL;
    if (cRDN > 0) {
        pAsn1RDN =
            (RelativeDistinguishedName *) PkiZeroAlloc(
                cRDN * sizeof(RelativeDistinguishedName));
        if (pAsn1RDN == NULL)
            goto ErrorReturn;
        Asn1Name.value = pAsn1RDN;
    }

    // Array of RDNs
    for ( ; cRDN > 0; cRDN--, pRDN++, pAsn1RDN++) {
        cAttr = pRDN->cRDNAttr;
        pAttr = pRDN->rgRDNAttr;
        pAsn1RDN->count = cAttr;

        if (cAttr > 0) {
            pAsn1Attr =
                (AttributeTypeValue *) PkiZeroAlloc(cAttr *
                    sizeof(AttributeTypeValue));
            if (pAsn1Attr == NULL)
                goto ErrorReturn;
            pAsn1RDN->value = pAsn1Attr;
        }

        // Array of attribute/values
        for ( ; cAttr > 0; cAttr--, pAttr++, pAsn1Attr++) {
            // We're now ready to encode the attribute/value stuff
            if (!Asn1X509SetRDNAttribute(pAttr, pAsn1Attr))
                goto ErrorReturn;
        }
    }

    fResult = Asn1InfoEncodeEx(
        Name_PDU,
        &Asn1Name,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (Asn1Name.value) {
        cRDN = Asn1Name.count;
        pRDN = pInfo->rgRDN;
        pAsn1RDN = Asn1Name.value;
        for ( ; cRDN > 0; cRDN--, pRDN++, pAsn1RDN++) {
            if (pAsn1RDN->value) {
                cAttr = pAsn1RDN->count;
                pAttr = pRDN->rgRDNAttr;
                pAsn1Attr = pAsn1RDN->value;
                for ( ; cAttr > 0; cAttr--, pAttr++, pAsn1Attr++)
                    Asn1X509FreeRDNAttribute(pAttr, pAsn1Attr);
                PkiFree(pAsn1RDN->value);
            }
        }
        PkiFree(Asn1Name.value);
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode the Name Info (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509NameInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    Name *pAsn1Name =  (Name *) pvAsn1Info;
    PCERT_NAME_INFO pInfo = (PCERT_NAME_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;
    LONG lAlignExtra;

    DWORD cRDN, cAttr;
    PCERT_RDN pRDN;
    PCERT_RDN_ATTR pAttr;
    RelativeDistinguishedName *pAsn1RDN;
    AttributeTypeValue *pAsn1Attr;

    lRemainExtra -= sizeof(CERT_NAME_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_NAME_INFO);

    cRDN = pAsn1Name->count;
    pAsn1RDN = pAsn1Name->value;
    lAlignExtra = INFO_LEN_ALIGN(cRDN * sizeof(CERT_RDN));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pInfo->cRDN = cRDN;
        pRDN = (PCERT_RDN) pbExtra;
        pInfo->rgRDN = pRDN;
        pbExtra += lAlignExtra;
    } else
        pRDN = NULL;

    // Array of RDNs
    for (; cRDN > 0; cRDN--, pRDN++, pAsn1RDN++) {
        cAttr = pAsn1RDN->count;
        pAsn1Attr = pAsn1RDN->value;
        lAlignExtra = INFO_LEN_ALIGN(cAttr * sizeof(CERT_RDN_ATTR));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pRDN->cRDNAttr = cAttr;
            pAttr = (PCERT_RDN_ATTR) pbExtra;
            pRDN->rgRDNAttr = pAttr;
            pbExtra += lAlignExtra;
        } else
            pAttr = NULL;

        // Array of attribute/values
        for (; cAttr > 0; cAttr--, pAttr++, pAsn1Attr++)
            // We're now ready to decode the attribute/value stuff
            if (!Asn1X509GetRDNAttribute(pAsn1Attr, dwFlags,
                    pAttr, &pbExtra, &lRemainExtra))
                return FALSE;
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}


BOOL WINAPI Asn1X509NameInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        Name_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509NameInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  Encode a single Name Value (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509NameValueEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_VALUE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD dwValueType;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;

    dwValueType = pInfo->dwValueType;
    switch (dwValueType) {
    case CERT_RDN_ANY_TYPE:
        SetLastError((DWORD) E_INVALIDARG);
        *pcbEncoded = 0;
        fResult = FALSE;
        break;
#ifndef ASN1_SUPPORTS_UTF8_TAG
    case CERT_RDN_UTF8_STRING:
        {
            CERT_NAME_VALUE EncodedBlobInfo;

            fResult = Asn1X509AllocAndEncodeUTF8(
                &pInfo->Value,
                &EncodedBlobInfo.Value.pbData,
                &EncodedBlobInfo.Value.cbData
                );
            if (fResult) {
                EncodedBlobInfo.dwValueType = CERT_RDN_ENCODED_BLOB;
                fResult = Asn1X509NameValueEncodeEx(
                    dwCertEncodingType,
                    lpszStructType,
                    &EncodedBlobInfo,
                    dwFlags,
                    pEncodePara,
                    pvEncoded,
                    pcbEncoded
                    );
                Asn1X509FreeEncodedUTF8(EncodedBlobInfo.Value.pbData);
            } else
                *pcbEncoded = 0;
        }
        break;
#endif  // not defined ASN1_SUPPORTS_UTF8_TAG
    case CERT_RDN_ENCODED_BLOB:
        {
            DWORD cbEncoded = pInfo->Value.cbData;

            fResult = TRUE;
            if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
                if (cbEncoded) {
                    BYTE *pb;
                    PFN_CRYPT_ALLOC pfnAlloc =
                        PkiGetEncodeAllocFunction(pEncodePara);
                    if (NULL == (pb = (BYTE *) pfnAlloc(cbEncoded))) {
                        fResult = FALSE;
                        cbEncoded = 0;
                    } else {
                        memcpy(pb, pInfo->Value.pbData, cbEncoded);
                        *((BYTE **) pvEncoded) = pb;
                    }
                }
            } else {
                if (NULL == pvEncoded)
                    *pcbEncoded = 0;
                if (*pcbEncoded < cbEncoded) {
                    if (pvEncoded) {
                        SetLastError((DWORD) ERROR_MORE_DATA);
                        fResult = FALSE;
                    }
                } else if (cbEncoded)
                    memcpy((BYTE *) pvEncoded, pInfo->Value.pbData, cbEncoded);
            }
            *pcbEncoded = cbEncoded;
        }
        break;
    default:
        {
            AnyString Asn1AnyString;

            Asn1X509SetAnyString(dwValueType, &pInfo->Value, &Asn1AnyString);
            fResult = Asn1InfoEncodeEx(
                AnyString_PDU,
                &Asn1AnyString,
                dwFlags,
                pEncodePara,
                pvEncoded,
                pcbEncoded
                );
        }
        break;
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode a single Name Value (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509NameValueDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    PCERT_NAME_VALUE pInfo = (PCERT_NAME_VALUE) pvStructInfo;
    NOCOPYANY Asn1Value;
    BYTE *pbExtra;
    LONG lRemainExtra;


    if (pInfo == NULL || (dwFlags & CRYPT_DECODE_ALLOC_FLAG))
        *pcbStructInfo = 0;

    memset(&Asn1Value, 0, sizeof(Asn1Value));
    Asn1Value.encoded = (void *)pbEncoded;
    Asn1Value.length = cbEncoded;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbStructInfo - sizeof(CERT_NAME_VALUE);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_NAME_VALUE);

    if (!Asn1X509GetRDNAttributeValue(&Asn1Value, dwFlags,
            &pInfo->dwValueType, &pInfo->Value, &pbExtra, &lRemainExtra))
        goto GetRDNAttributeValueError;

    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG) {
        PCERT_NAME_VALUE pAllocInfo;
        PFN_CRYPT_ALLOC pfnAlloc = PkiGetDecodeAllocFunction(pDecodePara);

        assert(0 > lRemainExtra);
        lRemainExtra = -lRemainExtra;

        pAllocInfo = (PCERT_NAME_VALUE) pfnAlloc(lRemainExtra);
        *((PCERT_NAME_VALUE *) pvStructInfo) = pAllocInfo;
        if (NULL == pAllocInfo)
            goto OutOfMemory;
        *pcbStructInfo = lRemainExtra;

        pbExtra = (BYTE *) pAllocInfo + sizeof(CERT_NAME_VALUE);
        lRemainExtra -= sizeof(CERT_NAME_VALUE);
        if (!Asn1X509GetRDNAttributeValue(&Asn1Value, dwFlags,
                &pAllocInfo->dwValueType, &pAllocInfo->Value,
                &pbExtra, &lRemainExtra))
            goto GetRDNAttributeValueError;
        assert(lRemainExtra >= 0);
    }

    if (lRemainExtra >= 0)
        *pcbStructInfo = *pcbStructInfo - (DWORD) lRemainExtra;
    else {
        *pcbStructInfo = *pcbStructInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    *pcbStructInfo = 0;
    goto CommonReturn;
TRACE_ERROR(GetRDNAttributeValueError)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Encode X509 certificate extensions (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ExtensionsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_EXTENSIONS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    Extensions Asn1Ext;

    if (!Asn1X509SetExtensions(pInfo->cExtension, pInfo->rgExtension, &Asn1Ext))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        Extensions_PDU,
        &Asn1Ext,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeExtensions(&Asn1Ext);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode X509 certificate extensions (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ExtensionsDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    Extensions *pAsn1Ext = (Extensions *) pvAsn1Info;
    PCERT_EXTENSIONS pInfo = (PCERT_EXTENSIONS) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_EXTENSIONS);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_EXTENSIONS);

    Asn1X509GetExtensions(pAsn1Ext, dwFlags,
        &pInfo->cExtension, &pInfo->rgExtension, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

#define T61_ASN_TAG             0x14

BOOL WINAPI Asn1X509ExtensionsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{

    if (0 < cbEncoded && T61_ASN_TAG == *pbEncoded) {
        // Entrust wraps X509 Extensions within a T61 string
        DWORD cbContent;
        const BYTE *pbContent;

        // Skip past the outer T61 tag and length octets
        if (0 < Asn1UtilExtractContent(
                pbEncoded,
                cbEncoded,
                &cbContent,
                &pbContent
                )) {
            cbEncoded = cbContent;
            pbEncoded = pbContent;
        }
    }

    return Asn1InfoDecodeAndAllocEx(
        Extensions_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509ExtensionsDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Public Key Info Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509PublicKeyInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_PUBLIC_KEY_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    SubjectPublicKeyInfo PublicKey;

    if (!Asn1X509SetPublicKeyInfo(pInfo, &PublicKey))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        SubjectPublicKeyInfo_PDU,
        &PublicKey,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    return fResult;
}


//+-------------------------------------------------------------------------
//  Public Key Info Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509PublicKeyInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    SubjectPublicKeyInfo *pPublicKey = (SubjectPublicKeyInfo *) pvAsn1Info;
    PCERT_PUBLIC_KEY_INFO pInfo = (PCERT_PUBLIC_KEY_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_PUBLIC_KEY_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_PUBLIC_KEY_INFO);

    Asn1X509GetPublicKeyInfo(pPublicKey, dwFlags,
        pInfo, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509PublicKeyInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        SubjectPublicKeyInfo_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509PublicKeyInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


#ifndef RSA1
#define RSA1 ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'1'<<24))
#endif

//+-------------------------------------------------------------------------
//  RSA Public Key Structure Encode (ASN1 X509)
//
//  Converts from the CAPI public key representation to a PKCS #1 RSAPublicKey
//
//  BYTE reversal::
//   - this only needs to be done for little endian processors
//--------------------------------------------------------------------------
BOOL WINAPI Asn1RSAPublicKeyStrucEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PUBLICKEYSTRUC *pPubKeyStruc,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbKeyBlob;
    RSAPUBKEY *pRsaPubKey;
    const BYTE *pbModulus;
    DWORD cbModulus;
    BYTE *pbAllocModulus = NULL;
    RSAPublicKey Asn1PubKey;

    // The CAPI public key representation consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - RSAPUBKEY
    //  - rgbModulus[]
    pbKeyBlob = (BYTE *) pPubKeyStruc;
    pRsaPubKey = (RSAPUBKEY *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
    pbModulus = pbKeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(RSAPUBKEY);
    cbModulus = pRsaPubKey->bitlen / 8;

    assert(cbModulus > 0);
    assert(pPubKeyStruc->bType == PUBLICKEYBLOB);
    assert(pPubKeyStruc->bVersion == CUR_BLOB_VERSION);
    assert(pPubKeyStruc->aiKeyAlg == CALG_RSA_SIGN ||
           pPubKeyStruc->aiKeyAlg == CALG_RSA_KEYX);
    assert(pRsaPubKey->magic == RSA1);
    assert(pRsaPubKey->bitlen % 8 == 0);

    if (pPubKeyStruc->bType != PUBLICKEYBLOB)
        goto InvalidArg;

    // PKCS #1 ASN.1 encode
    //
    // ASN1 isn't reversing HUGE_INTEGERs. Also, after doing the
    // reversal insert a leading 0 byte to force it to always be treated
    // as an unsigned integer
    if (NULL == (pbAllocModulus = (BYTE *) PkiNonzeroAlloc(cbModulus + 1)))
        goto ErrorReturn;
    *pbAllocModulus = 0;
    memcpy(pbAllocModulus + 1, pbModulus, cbModulus);
    PkiAsn1ReverseBytes(pbAllocModulus + 1, cbModulus);
    pbModulus = pbAllocModulus;
    cbModulus++;

    Asn1PubKey.publicExponent = pRsaPubKey->pubexp;
    Asn1PubKey.modulus.length = cbModulus;
    Asn1PubKey.modulus.value = (BYTE *) pbModulus;

    fResult = Asn1InfoEncodeEx(
        RSAPublicKey_PDU,
        &Asn1PubKey,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

InvalidArg:
    SetLastError((DWORD) E_INVALIDARG);
ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbAllocModulus)
        PkiFree(pbAllocModulus);
    return fResult;
}


//+-------------------------------------------------------------------------
//  RSA Public Key Structure Decode (ASN1 X509)
//
//  Converts from a PKCS #1 RSAPublicKey to a CAPI public key representation
//
//  BYTE reversal::
//   - this only needs to be done for little endian processors
//--------------------------------------------------------------------------
BOOL WINAPI Asn1RSAPublicKeyStrucDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    RSAPublicKey *pAsn1PubKey = (RSAPublicKey *) pvAsn1Info;
    PUBLICKEYSTRUC *pPubKeyStruc = (PUBLICKEYSTRUC *) pvStructInfo;
    BYTE *pbAsn1Modulus;
    DWORD cbModulus;

    // Now convert the ASN1 RSA public key into CAPI's representation which
    // consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - RSAPUBKEY
    //  - rgbModulus[]
    cbModulus = pAsn1PubKey->modulus.length;
    pbAsn1Modulus = pAsn1PubKey->modulus.value;
    // Strip off a leading 0 byte. Its there in the decoded ASN
    // integer for an unsigned integer with the leading bit set.
    if (cbModulus > 1 && *pbAsn1Modulus == 0) {
        pbAsn1Modulus++;
        cbModulus--;
    }
    *plRemainExtra -= sizeof(PUBLICKEYSTRUC) + sizeof(RSAPUBKEY) + cbModulus;
    if (0 <= *plRemainExtra) {
        BYTE *pbKeyBlob = (BYTE *) pPubKeyStruc;
        RSAPUBKEY *pRsaPubKey =
            (RSAPUBKEY *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
        BYTE *pbModulus = pbKeyBlob + sizeof(PUBLICKEYSTRUC) +
            sizeof(RSAPUBKEY);

        pPubKeyStruc->bType = PUBLICKEYBLOB;
        pPubKeyStruc->bVersion = CUR_BLOB_VERSION;
        pPubKeyStruc->reserved = 0;
        // Note: KEYX can also be used for doing a signature
        pPubKeyStruc->aiKeyAlg = CALG_RSA_KEYX;
        pRsaPubKey->magic = RSA1;
        pRsaPubKey->bitlen = cbModulus * 8;
        pRsaPubKey->pubexp = pAsn1PubKey->publicExponent;
        if (cbModulus > 0) {
            memcpy(pbModulus, pbAsn1Modulus, cbModulus);
            // ASN1 isn't reversing HUGEINTEGERs
            PkiAsn1ReverseBytes(pbModulus, cbModulus);
        }
    }
    return TRUE;
}

BOOL WINAPI Asn1RSAPublicKeyStrucDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        RSAPublicKey_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1RSAPublicKeyStrucDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Authority Key Id Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AuthorityKeyIdEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_AUTHORITY_KEY_ID_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;

    AuthorityKeyId Asn1AuthorityKeyId;
    memset(&Asn1AuthorityKeyId, 0, sizeof(Asn1AuthorityKeyId));

    if (pInfo->KeyId.cbData) {
        Asn1X509SetOctetString(&pInfo->KeyId,
#ifdef OSS_CRYPT_ASN1
            &Asn1AuthorityKeyId.AuthorityKeyId_keyIdentifier);
#else
            &Asn1AuthorityKeyId.keyIdentifier);
#endif  // OSS_CRYPT_ASN1
        Asn1AuthorityKeyId.bit_mask |= AuthorityKeyId_keyIdentifier_present;
    }
    if (pInfo->CertIssuer.cbData) {
        Asn1X509SetAny(&pInfo->CertIssuer, &Asn1AuthorityKeyId.certIssuer);
        Asn1AuthorityKeyId.bit_mask |= certIssuer_present;
    }
    if (pInfo->CertSerialNumber.cbData) {
        if (!Asn1X509SetHugeInteger(&pInfo->CertSerialNumber,
                &Asn1AuthorityKeyId.certSerialNumber))
            goto ErrorReturn;
        Asn1AuthorityKeyId.bit_mask |= certSerialNumber_present;
    }

    fResult = Asn1InfoEncodeEx(
        AuthorityKeyId_PDU,
        &Asn1AuthorityKeyId,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeHugeInteger(&Asn1AuthorityKeyId.certSerialNumber);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Authority Key Id Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AuthorityKeyIdDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    AuthorityKeyId *pAuthorityKeyId = (AuthorityKeyId *) pvAsn1Info;
    PCERT_AUTHORITY_KEY_ID_INFO pInfo =
        (PCERT_AUTHORITY_KEY_ID_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_AUTHORITY_KEY_ID_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_AUTHORITY_KEY_ID_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_AUTHORITY_KEY_ID_INFO);
    }

    if (pAuthorityKeyId->bit_mask & AuthorityKeyId_keyIdentifier_present)
#ifdef OSS_CRYPT_ASN1
        Asn1X509GetOctetString(&pAuthorityKeyId->AuthorityKeyId_keyIdentifier,
#else
        Asn1X509GetOctetString(&pAuthorityKeyId->keyIdentifier,
#endif  // OSS_CRYPT_ASN1
            dwFlags, &pInfo->KeyId, &pbExtra, &lRemainExtra);
    if (pAuthorityKeyId->bit_mask & certIssuer_present)
        Asn1X509GetAny(&pAuthorityKeyId->certIssuer, dwFlags,
            &pInfo->CertIssuer, &pbExtra, &lRemainExtra);
    if (pAuthorityKeyId->bit_mask & certSerialNumber_present)
        Asn1X509GetHugeInteger(&pAuthorityKeyId->certSerialNumber, dwFlags,
            &pInfo->CertSerialNumber, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509AuthorityKeyIdDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        AuthorityKeyId_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509AuthorityKeyIdDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Authority Key Id2 Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AuthorityKeyId2EncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_AUTHORITY_KEY_ID2_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD dwErrLocation;

    AuthorityKeyId2 Asn1AuthorityKeyId2;
    memset(&Asn1AuthorityKeyId2, 0, sizeof(Asn1AuthorityKeyId2));

    if (pInfo->KeyId.cbData) {
        Asn1X509SetOctetString(&pInfo->KeyId,
#ifdef OSS_CRYPT_ASN1
            &Asn1AuthorityKeyId2.AuthorityKeyId2_keyIdentifier);
#else
            &Asn1AuthorityKeyId2.keyIdentifier);
#endif  // OSS_CRYPT_ASN1
        Asn1AuthorityKeyId2.bit_mask |= AuthorityKeyId2_keyIdentifier_present;
    }
    if (pInfo->AuthorityCertIssuer.cAltEntry) {
        if (!Asn1X509SetAltNames(&pInfo->AuthorityCertIssuer,
                &Asn1AuthorityKeyId2.authorityCertIssuer, 0, &dwErrLocation)) {
            *pcbEncoded = dwErrLocation;
            goto AltNamesError;
        }
        Asn1AuthorityKeyId2.bit_mask |= authorityCertIssuer_present;
    }
    if (pInfo->AuthorityCertSerialNumber.cbData) {
        if (!Asn1X509SetHugeInteger(&pInfo->AuthorityCertSerialNumber,
                &Asn1AuthorityKeyId2.authorityCertSerialNumber))
            goto ErrorReturn;
        Asn1AuthorityKeyId2.bit_mask |= authorityCertSerialNumber_present;
    }

    fResult = Asn1InfoEncodeEx(
        AuthorityKeyId2_PDU,
        &Asn1AuthorityKeyId2,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
AltNamesError:
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeAltNames(&Asn1AuthorityKeyId2.authorityCertIssuer);
    Asn1X509FreeHugeInteger(&Asn1AuthorityKeyId2.authorityCertSerialNumber);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Authority Key Id2 Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AuthorityKeyId2DecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    AuthorityKeyId2 *pAuthorityKeyId2 = (AuthorityKeyId2 *) pvAsn1Info;
    PCERT_AUTHORITY_KEY_ID2_INFO pInfo =
        (PCERT_AUTHORITY_KEY_ID2_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_AUTHORITY_KEY_ID2_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_AUTHORITY_KEY_ID2_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_AUTHORITY_KEY_ID2_INFO);
    }

    if (pAuthorityKeyId2->bit_mask & AuthorityKeyId2_keyIdentifier_present)
#ifdef OSS_CRYPT_ASN1
        Asn1X509GetOctetString(&pAuthorityKeyId2->AuthorityKeyId2_keyIdentifier,
#else
        Asn1X509GetOctetString(&pAuthorityKeyId2->keyIdentifier,
#endif  // OSS_CRYPT_ASN1
            dwFlags, &pInfo->KeyId, &pbExtra, &lRemainExtra);
    if (pAuthorityKeyId2->bit_mask & authorityCertIssuer_present) {
        if (!Asn1X509GetAltNames(&pAuthorityKeyId2->authorityCertIssuer, dwFlags,
                &pInfo->AuthorityCertIssuer, &pbExtra, &lRemainExtra))
            goto ErrorReturn;
    }
    if (pAuthorityKeyId2->bit_mask & authorityCertSerialNumber_present)
        Asn1X509GetHugeInteger(&pAuthorityKeyId2->authorityCertSerialNumber, dwFlags,
            &pInfo->AuthorityCertSerialNumber, &pbExtra, &lRemainExtra);

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

BOOL WINAPI Asn1X509AuthorityKeyId2DecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        AuthorityKeyId2_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509AuthorityKeyId2DecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  Key Attributes Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509KeyAttributesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_KEY_ATTRIBUTES_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    KeyAttributes Asn1KeyAttributes;
    memset(&Asn1KeyAttributes, 0, sizeof(Asn1KeyAttributes));

    if (pInfo->KeyId.cbData) {
        Asn1X509SetOctetString(&pInfo->KeyId,
#ifdef OSS_CRYPT_ASN1
            &Asn1KeyAttributes.KeyAttributes_keyIdentifier);
#else
            &Asn1KeyAttributes.keyIdentifier);
#endif  // OSS_CRYPT_ASN1
        Asn1KeyAttributes.bit_mask |= KeyAttributes_keyIdentifier_present;
    }
    if (pInfo->IntendedKeyUsage.cbData) {
        Asn1X509SetBitWithoutTrailingZeroes(&pInfo->IntendedKeyUsage,
            &Asn1KeyAttributes.intendedKeyUsage);
        Asn1KeyAttributes.bit_mask |= intendedKeyUsage_present;
    }
    if (pInfo->pPrivateKeyUsagePeriod) {
        if (!PkiAsn1ToGeneralizedTime(
                &pInfo->pPrivateKeyUsagePeriod->NotBefore,
                &Asn1KeyAttributes.privateKeyUsagePeriod.notBefore))
            goto EncodeError;
        if (!PkiAsn1ToGeneralizedTime(
                &pInfo->pPrivateKeyUsagePeriod->NotAfter,
                &Asn1KeyAttributes.privateKeyUsagePeriod.notAfter))
            goto EncodeError;
        Asn1KeyAttributes.privateKeyUsagePeriod.bit_mask |=
            notBefore_present | notAfter_present;
        Asn1KeyAttributes.bit_mask |= privateKeyUsagePeriod_present;
    }

    fResult = Asn1InfoEncodeEx(
        KeyAttributes_PDU,
        &Asn1KeyAttributes,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

EncodeError:
    SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

//+-------------------------------------------------------------------------
//  Key Attributes Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509KeyAttributesDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    KeyAttributes *pKeyAttributes = (KeyAttributes *) pvAsn1Info;
    PCERT_KEY_ATTRIBUTES_INFO pInfo = (PCERT_KEY_ATTRIBUTES_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_KEY_ATTRIBUTES_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_KEY_ATTRIBUTES_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_KEY_ATTRIBUTES_INFO);
    }

    if (pKeyAttributes->bit_mask & KeyAttributes_keyIdentifier_present)
#ifdef OSS_CRYPT_ASN1
        Asn1X509GetOctetString(&pKeyAttributes->KeyAttributes_keyIdentifier,
#else
        Asn1X509GetOctetString(&pKeyAttributes->keyIdentifier,
#endif  // OSS_CRYPT_ASN1
            dwFlags, &pInfo->KeyId, &pbExtra, &lRemainExtra);
    if (pKeyAttributes->bit_mask & intendedKeyUsage_present)
        Asn1X509GetBit(&pKeyAttributes->intendedKeyUsage, dwFlags,
            &pInfo->IntendedKeyUsage, &pbExtra, &lRemainExtra);

    if (pKeyAttributes->bit_mask & privateKeyUsagePeriod_present) {
        LONG lAlignExtra;
        PrivateKeyValidity *pAsn1KeyUsage =
            &pKeyAttributes->privateKeyUsagePeriod;

        lAlignExtra = INFO_LEN_ALIGN(sizeof(CERT_PRIVATE_KEY_VALIDITY));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            PCERT_PRIVATE_KEY_VALIDITY pKeyUsage =
                (PCERT_PRIVATE_KEY_VALIDITY) pbExtra;

            // Default all optional fields to zero
            memset(pKeyUsage, 0, sizeof(CERT_PRIVATE_KEY_VALIDITY));
            if (pAsn1KeyUsage->bit_mask & notBefore_present) {
                if (!PkiAsn1FromGeneralizedTime(&pAsn1KeyUsage->notBefore,
                        &pKeyUsage->NotBefore))
                    goto DecodeError;
            }
            if (pAsn1KeyUsage->bit_mask & notAfter_present) {
                if (!PkiAsn1FromGeneralizedTime(&pAsn1KeyUsage->notAfter,
                        &pKeyUsage->NotAfter))
                    goto DecodeError;
            }
            pInfo->pPrivateKeyUsagePeriod = pKeyUsage;
            pbExtra += lAlignExtra;
        }
    }

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(DecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1X509KeyAttributesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        KeyAttributes_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509KeyAttributesDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  AltName Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AltNameEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_ALT_NAME_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    AltNames AltNames;
    DWORD dwErrLocation;

    if (!Asn1X509SetAltNames(pInfo, &AltNames, 0, &dwErrLocation)) {
        *pcbEncoded = dwErrLocation;
        fResult = FALSE;
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        goto CommonReturn;
    }

    fResult = Asn1InfoEncodeEx(
        AltNames_PDU,
        &AltNames,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    Asn1X509FreeAltNames(&AltNames);
    return fResult;
}


//+-------------------------------------------------------------------------
//  AltName Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AltNameDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    AltNames *pAltNames = (AltNames *) pvAsn1Info;
    PCERT_ALT_NAME_INFO pInfo = (PCERT_ALT_NAME_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_ALT_NAME_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_ALT_NAME_INFO);

    if (!Asn1X509GetAltNames(pAltNames, dwFlags,
            pInfo, &pbExtra, &lRemainExtra))
        goto ErrorReturn;

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

BOOL WINAPI Asn1X509AltNameDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        AltNames_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509AltNameDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}



//+-------------------------------------------------------------------------
//  Key Usage Restriction Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509KeyUsageRestrictionEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_KEY_USAGE_RESTRICTION_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD cPolicyId;

    KeyUsageRestriction Asn1KeyUsageRestriction;
    memset(&Asn1KeyUsageRestriction, 0, sizeof(Asn1KeyUsageRestriction));

    cPolicyId = pInfo->cCertPolicyId;
    if (cPolicyId) {
        PCERT_POLICY_ID pPolicyId = pInfo->rgCertPolicyId;
        CertPolicyId *pAsn1PolicyId =
            (CertPolicyId *) PkiZeroAlloc(cPolicyId * sizeof(CertPolicyId));
        if (pAsn1PolicyId == NULL) goto ErrorReturn;
        Asn1KeyUsageRestriction.certPolicySet.count = cPolicyId;
        Asn1KeyUsageRestriction.certPolicySet.value = pAsn1PolicyId;

        for ( ; cPolicyId > 0; cPolicyId--, pPolicyId++, pAsn1PolicyId++) {
            DWORD cElement = pPolicyId->cCertPolicyElementId;
            if (cElement > 0) {
                LPSTR *ppszElement = pPolicyId->rgpszCertPolicyElementId;
                EncodedObjectID *pAsn1Element =
                    (EncodedObjectID *) PkiZeroAlloc(cElement * sizeof(EncodedObjectID));
                if (pAsn1Element == NULL) goto ErrorReturn;
                pAsn1PolicyId->count = cElement;
                pAsn1PolicyId->value = pAsn1Element;
                for ( ; cElement > 0; cElement--, ppszElement++, pAsn1Element++)
                    if (!Asn1X509SetEncodedObjId(*ppszElement, pAsn1Element))
                        goto ErrorReturn;
            }
        }
        Asn1KeyUsageRestriction.bit_mask |= certPolicySet_present;
    }

    if (pInfo->RestrictedKeyUsage.cbData) {
        Asn1X509SetBitWithoutTrailingZeroes(&pInfo->RestrictedKeyUsage,
            &Asn1KeyUsageRestriction.restrictedKeyUsage);
        Asn1KeyUsageRestriction.bit_mask |= restrictedKeyUsage_present;
    }

    fResult = Asn1InfoEncodeEx(
        KeyUsageRestriction_PDU,
        &Asn1KeyUsageRestriction,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (Asn1KeyUsageRestriction.certPolicySet.value) {
        cPolicyId = Asn1KeyUsageRestriction.certPolicySet.count;
        CertPolicyId *pAsn1PolicyId = Asn1KeyUsageRestriction.certPolicySet.value;
        for ( ; cPolicyId > 0; cPolicyId--, pAsn1PolicyId++)
            if (pAsn1PolicyId->value)
                PkiFree(pAsn1PolicyId->value);
        PkiFree(Asn1KeyUsageRestriction.certPolicySet.value);
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Key Usage Restriction Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509KeyUsageRestrictionDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    KeyUsageRestriction *pKeyUsageRestriction =
        (KeyUsageRestriction *) pvAsn1Info;
    PCERT_KEY_USAGE_RESTRICTION_INFO pInfo =
        (PCERT_KEY_USAGE_RESTRICTION_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_KEY_USAGE_RESTRICTION_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_KEY_USAGE_RESTRICTION_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_KEY_USAGE_RESTRICTION_INFO);
    }

    if (pKeyUsageRestriction->bit_mask & certPolicySet_present) {
        LONG lAlignExtra;
        DWORD cPolicyId;
        PCERT_POLICY_ID pPolicyId;
        CertPolicyId *pAsn1PolicyId;

        cPolicyId = pKeyUsageRestriction->certPolicySet.count;
        lAlignExtra = INFO_LEN_ALIGN(cPolicyId * sizeof(CERT_POLICY_ID));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pInfo->cCertPolicyId = cPolicyId;
            pPolicyId = (PCERT_POLICY_ID) pbExtra;
            pInfo->rgCertPolicyId = pPolicyId;
            pbExtra += lAlignExtra;
        } else
            pPolicyId = NULL;

        pAsn1PolicyId = pKeyUsageRestriction->certPolicySet.value;
        for ( ; cPolicyId > 0; cPolicyId--, pPolicyId++, pAsn1PolicyId++) {
            DWORD cElement;
            LPSTR *ppszElement;
            EncodedObjectID *pAsn1Element;

            cElement = pAsn1PolicyId->count;
            lAlignExtra = INFO_LEN_ALIGN(cElement * sizeof(LPSTR *));
            lRemainExtra -= lAlignExtra;
            if (lRemainExtra >= 0) {
                pPolicyId->cCertPolicyElementId = cElement;
                ppszElement = (LPSTR *) pbExtra;
                pPolicyId->rgpszCertPolicyElementId = ppszElement;
                pbExtra += lAlignExtra;
            } else
                ppszElement = NULL;

            pAsn1Element = pAsn1PolicyId->value;
            for ( ; cElement > 0; cElement--, ppszElement++, pAsn1Element++)
                Asn1X509GetEncodedObjId(pAsn1Element, dwFlags,
                    ppszElement, &pbExtra, &lRemainExtra);
        }
    }

    if (pKeyUsageRestriction->bit_mask & restrictedKeyUsage_present)
        Asn1X509GetBit(&pKeyUsageRestriction->restrictedKeyUsage, dwFlags,
            &pInfo->RestrictedKeyUsage, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509KeyUsageRestrictionDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        KeyUsageRestriction_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509KeyUsageRestrictionDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Basic Constraints Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509BasicConstraintsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_BASIC_CONSTRAINTS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD cSubtrees;

    BasicConstraints Asn1BasicConstraints;
    memset(&Asn1BasicConstraints, 0, sizeof(Asn1BasicConstraints));

    Asn1X509SetBitWithoutTrailingZeroes(&pInfo->SubjectType,
        &Asn1BasicConstraints.subjectType);
    if (pInfo->fPathLenConstraint) {
#ifdef OSS_CRYPT_ASN1
        Asn1BasicConstraints.BasicConstraints_pathLenConstraint =
#else
        Asn1BasicConstraints.pathLenConstraint =
#endif  // OSS_CRYPT_ASN1
            pInfo->dwPathLenConstraint;
        Asn1BasicConstraints.bit_mask |=
            BasicConstraints_pathLenConstraint_present;
    }
    cSubtrees = pInfo->cSubtreesConstraint;
    if (cSubtrees) {
        PCERT_NAME_BLOB pSubtrees = pInfo->rgSubtreesConstraint;
        NOCOPYANY *pAsn1Subtrees =
            (NOCOPYANY *) PkiZeroAlloc(
                cSubtrees * sizeof(NOCOPYANY));
        if (pAsn1Subtrees == NULL) goto ErrorReturn;
        Asn1BasicConstraints.subtreesConstraint.count = cSubtrees;
        Asn1BasicConstraints.subtreesConstraint.value = pAsn1Subtrees;

        for ( ; cSubtrees > 0; cSubtrees--, pSubtrees++, pAsn1Subtrees++)
            Asn1X509SetAny(pSubtrees, pAsn1Subtrees);
        Asn1BasicConstraints.bit_mask |= subtreesConstraint_present;
    }

    fResult = Asn1InfoEncodeEx(
        BasicConstraints_PDU,
        &Asn1BasicConstraints,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (Asn1BasicConstraints.subtreesConstraint.value)
        PkiFree(Asn1BasicConstraints.subtreesConstraint.value);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Basic Constraints Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509BasicConstraintsDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BasicConstraints *pBasicConstraints = (BasicConstraints *) pvAsn1Info;
    PCERT_BASIC_CONSTRAINTS_INFO pInfo =
        (PCERT_BASIC_CONSTRAINTS_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_BASIC_CONSTRAINTS_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_BASIC_CONSTRAINTS_INFO));

        // Update fields not needing extra memory after the
        // CERT_BASIC_CONSTRAINTS_INFO
        if (pBasicConstraints->bit_mask &
                BasicConstraints_pathLenConstraint_present) {
            pInfo->fPathLenConstraint = TRUE;
            pInfo->dwPathLenConstraint =
#ifdef OSS_CRYPT_ASN1
                pBasicConstraints->BasicConstraints_pathLenConstraint;
#else
                pBasicConstraints->pathLenConstraint;
#endif  // OSS_CRYPT_ASN1
        }

        pbExtra = (BYTE *) pInfo + sizeof(CERT_BASIC_CONSTRAINTS_INFO);
    }

    Asn1X509GetBit(&pBasicConstraints->subjectType, dwFlags,
        &pInfo->SubjectType, &pbExtra, &lRemainExtra);

    if (pBasicConstraints->bit_mask & subtreesConstraint_present) {
        LONG lAlignExtra;
        DWORD cSubtrees;
        PCERT_NAME_BLOB pSubtrees;
        NOCOPYANY *pAsn1Subtrees;

        cSubtrees = pBasicConstraints->subtreesConstraint.count;
        lAlignExtra = INFO_LEN_ALIGN(cSubtrees * sizeof(CERT_NAME_BLOB));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pInfo->cSubtreesConstraint = cSubtrees;
            pSubtrees = (PCERT_NAME_BLOB) pbExtra;
            pInfo->rgSubtreesConstraint = pSubtrees;
            pbExtra += lAlignExtra;
        } else
            pSubtrees = NULL;

        pAsn1Subtrees = pBasicConstraints->subtreesConstraint.value;
        for ( ; cSubtrees > 0; cSubtrees--, pSubtrees++, pAsn1Subtrees++)
            Asn1X509GetAny(pAsn1Subtrees, dwFlags,
                pSubtrees, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509BasicConstraintsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        BasicConstraints_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509BasicConstraintsDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Basic Constraints #2 Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509BasicConstraints2EncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_BASIC_CONSTRAINTS2_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BasicConstraints2 Asn1Info;
    memset(&Asn1Info, 0, sizeof(Asn1Info));

    if (pInfo->fCA) {
        Asn1Info.cA = TRUE;
        Asn1Info.bit_mask |= cA_present;
    }
    if (pInfo->fPathLenConstraint) {
#ifdef OSS_CRYPT_ASN1
        Asn1Info.BasicConstraints2_pathLenConstraint =
#else
        Asn1Info.pathLenConstraint =
#endif  // OSS_CRYPT_ASN1
            pInfo->dwPathLenConstraint;
        Asn1Info.bit_mask |= BasicConstraints2_pathLenConstraint_present;
    }

    return Asn1InfoEncodeEx(
        BasicConstraints2_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Basic Constraints #2 Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509BasicConstraints2DecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BasicConstraints2 *pAsn1Info = (BasicConstraints2 *) pvAsn1Info;
    PCERT_BASIC_CONSTRAINTS2_INFO pInfo =
        (PCERT_BASIC_CONSTRAINTS2_INFO) pvStructInfo;

    *plRemainExtra -= sizeof(CERT_BASIC_CONSTRAINTS2_INFO);
    if (*plRemainExtra >= 0) {
        memset(pInfo, 0, sizeof(CERT_BASIC_CONSTRAINTS2_INFO));

        if (pAsn1Info->bit_mask & cA_present)
            pInfo->fCA = (BOOLEAN) pAsn1Info->cA;

        if (pAsn1Info->bit_mask &
                BasicConstraints2_pathLenConstraint_present) {
            pInfo->fPathLenConstraint = TRUE;
            pInfo->dwPathLenConstraint =
#ifdef OSS_CRYPT_ASN1
                pAsn1Info->BasicConstraints2_pathLenConstraint;
#else
                pAsn1Info->pathLenConstraint;
#endif  // OSS_CRYPT_ASN1
        }
    }
    return TRUE;
}

BOOL WINAPI Asn1X509BasicConstraints2DecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        BasicConstraints2_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509BasicConstraints2DecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  Bits Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509BitsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_BIT_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BITSTRING Asn1Info;

    Asn1X509SetBit(pInfo, &Asn1Info);
    return Asn1InfoEncodeEx(
        Bits_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Bits Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509BitsDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BITSTRING *pAsn1Info = (BITSTRING *) pvAsn1Info;
    PCRYPT_BIT_BLOB pInfo = (PCRYPT_BIT_BLOB) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRYPT_BIT_BLOB);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_BIT_BLOB);

    Asn1X509GetBit(pAsn1Info, dwFlags, pInfo, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509BitsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        Bits_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509BitsDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Bits Without Trailing Zeroes Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509BitsWithoutTrailingZeroesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_BIT_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BITSTRING Asn1Info;

    Asn1X509SetBitWithoutTrailingZeroes(pInfo, &Asn1Info);
    return Asn1InfoEncodeEx(
        Bits_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}


//+-------------------------------------------------------------------------
//  Certificate Policies Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CertPoliciesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_POLICIES_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD cPolicyInfo;

    CertificatePolicies Asn1Info;
    memset(&Asn1Info, 0, sizeof(Asn1Info));

    cPolicyInfo = pInfo->cPolicyInfo;
    if (cPolicyInfo) {
        PCERT_POLICY_INFO pPolicyInfo = pInfo->rgPolicyInfo;
        PolicyInformation *pAsn1PolicyInfo =
            (PolicyInformation *) PkiZeroAlloc(
                cPolicyInfo * sizeof(PolicyInformation));
        if (pAsn1PolicyInfo == NULL) goto ErrorReturn;
        Asn1Info.count = cPolicyInfo;
        Asn1Info.value = pAsn1PolicyInfo;

        for ( ; cPolicyInfo > 0;
                            cPolicyInfo--, pPolicyInfo++, pAsn1PolicyInfo++) {
            DWORD cQualifier = pPolicyInfo->cPolicyQualifier;
            if (!Asn1X509SetEncodedObjId(pPolicyInfo->pszPolicyIdentifier,
                    &pAsn1PolicyInfo->policyIdentifier))
                    goto ErrorReturn;
            if (cQualifier > 0) {
                PCERT_POLICY_QUALIFIER_INFO pQualifier =
                    pPolicyInfo->rgPolicyQualifier;
                PolicyQualifierInfo *pAsn1Qualifier =
                    (PolicyQualifierInfo *) PkiZeroAlloc(
                        cQualifier * sizeof(PolicyQualifierInfo));
                if (pAsn1Qualifier == NULL) goto ErrorReturn;
                pAsn1PolicyInfo->policyQualifiers.count = cQualifier;
                pAsn1PolicyInfo->policyQualifiers.value = pAsn1Qualifier;
                pAsn1PolicyInfo->bit_mask |= policyQualifiers_present;

                for ( ; cQualifier > 0;
                            cQualifier--, pQualifier++, pAsn1Qualifier++) {
                    if (!Asn1X509SetEncodedObjId(pQualifier->pszPolicyQualifierId,
                            &pAsn1Qualifier->policyQualifierId))
                        goto ErrorReturn;

                    if (pQualifier->Qualifier.cbData) {
                        Asn1X509SetAny(&pQualifier->Qualifier,
                            &pAsn1Qualifier->qualifier);
                        pAsn1Qualifier->bit_mask |= qualifier_present;
                    }
                }
            }
        }
    }

    fResult = Asn1InfoEncodeEx(
        CertificatePolicies_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (Asn1Info.value) {
        cPolicyInfo = Asn1Info.count;
        PolicyInformation *pAsn1PolicyInfo = Asn1Info.value;
        for ( ; cPolicyInfo > 0; cPolicyInfo--, pAsn1PolicyInfo++)
            if (pAsn1PolicyInfo->policyQualifiers.value)
                PkiFree(pAsn1PolicyInfo->policyQualifiers.value);
        PkiFree(Asn1Info.value);
    }
    return fResult;
}


//+-------------------------------------------------------------------------
//  Certificate Policies Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CertPoliciesDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    CertificatePolicies *pAsn1Info = (CertificatePolicies *) pvAsn1Info;
    PCERT_POLICIES_INFO pInfo = (PCERT_POLICIES_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;
    DWORD cPolicyInfo;

    lRemainExtra -= sizeof(CERT_POLICIES_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CERT_POLICIES_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_POLICIES_INFO);
    }

    cPolicyInfo = pAsn1Info->count;
    if (cPolicyInfo) {
        LONG lAlignExtra;
        PCERT_POLICY_INFO pPolicyInfo;
        PolicyInformation *pAsn1PolicyInfo;

        lAlignExtra = INFO_LEN_ALIGN(cPolicyInfo * sizeof(CERT_POLICY_INFO));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pInfo->cPolicyInfo = cPolicyInfo;
            pPolicyInfo = (PCERT_POLICY_INFO) pbExtra;
            pInfo->rgPolicyInfo = pPolicyInfo;
            memset(pPolicyInfo, 0, cPolicyInfo * sizeof(CERT_POLICY_INFO));
            pbExtra += lAlignExtra;
        } else
            pPolicyInfo = NULL;

        pAsn1PolicyInfo = pAsn1Info->value;
        for ( ; cPolicyInfo > 0;
                            cPolicyInfo--, pPolicyInfo++, pAsn1PolicyInfo++) {
            DWORD cQualifier;

            // check to see if there is a policy identifier
            if (pAsn1PolicyInfo->policyIdentifier.length != 0) {
                Asn1X509GetEncodedObjId(&pAsn1PolicyInfo->policyIdentifier, dwFlags,
                &pPolicyInfo->pszPolicyIdentifier, &pbExtra, &lRemainExtra);
            }
            else {
                lAlignExtra = INFO_LEN_ALIGN(strlen("")+1);
                lRemainExtra -= lAlignExtra;
                if (lRemainExtra >= 0) {
                    pPolicyInfo->pszPolicyIdentifier = (LPSTR) pbExtra;
                    strcpy(pPolicyInfo->pszPolicyIdentifier, "");
                    pbExtra += lAlignExtra;
                }
            }
            
            cQualifier = pAsn1PolicyInfo->bit_mask & policyQualifiers_present ?
                pAsn1PolicyInfo->policyQualifiers.count : 0;
            if (cQualifier > 0) {
                PCERT_POLICY_QUALIFIER_INFO pQualifier;
                PolicyQualifierInfo *pAsn1Qualifier;

                lAlignExtra = INFO_LEN_ALIGN(cQualifier *
                    sizeof(CERT_POLICY_QUALIFIER_INFO));
                lRemainExtra -= lAlignExtra;
                if (lRemainExtra >= 0) {
                    pPolicyInfo->cPolicyQualifier = cQualifier;
                    pQualifier = (PCERT_POLICY_QUALIFIER_INFO) pbExtra;
                    pPolicyInfo->rgPolicyQualifier = pQualifier;
                    memset(pQualifier, 0,
                        cQualifier * sizeof(CERT_POLICY_QUALIFIER_INFO));
                    pbExtra += lAlignExtra;
                } else
                    pQualifier = NULL;

                pAsn1Qualifier = pAsn1PolicyInfo->policyQualifiers.value;
                for ( ; cQualifier > 0;
                            cQualifier--, pQualifier++, pAsn1Qualifier++) {
                    Asn1X509GetEncodedObjId(&pAsn1Qualifier->policyQualifierId, dwFlags,
                        &pQualifier->pszPolicyQualifierId,
                        &pbExtra, &lRemainExtra);
                    if (pAsn1Qualifier->bit_mask & qualifier_present)
                        Asn1X509GetAny(&pAsn1Qualifier->qualifier, dwFlags,
                            &pQualifier->Qualifier, &pbExtra, &lRemainExtra);
                }
            }
        }
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509CertPoliciesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    CertificatePolicies *pAsn1Info = NULL;
    CertificatePolicies95 *pAsn1Info95 = NULL;
    PolicyInformation *pPolicyInformation = NULL;
    CertificatePolicies certificatePolicies;
    DWORD i;

    if (!Asn1InfoDecodeAndAlloc(
            CertificatePolicies_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pAsn1Info))
    {
        // try to decode it as the old style
        if (!Asn1InfoDecodeAndAlloc(
                CertificatePolicies95_PDU,
                pbEncoded,
                cbEncoded,
                (void **) &pAsn1Info95))
             goto ErrorReturn;

        // that decode worked, so alloc some memory, fix up some pointers
        // and role through the rest of the routine per usual
        certificatePolicies.count = pAsn1Info95->count;
        if (NULL == (pPolicyInformation = 
                    (PolicyInformation *) PkiNonzeroAlloc(pAsn1Info95->count * sizeof(PolicyInformation))))
            goto ErrorReturn;

        certificatePolicies.value = pPolicyInformation;
        
        for (i=0; i<pAsn1Info95->count; i++)
        {
            pPolicyInformation[i].bit_mask = policyQualifiers_present;
            pPolicyInformation[i].policyIdentifier.length = 0;
            pPolicyInformation[i].policyIdentifier.value = NULL;
            pPolicyInformation[i].policyQualifiers.count = pAsn1Info95->value[i].count;
            pPolicyInformation[i].policyQualifiers.value = pAsn1Info95->value[i].value;
        }
            
        pAsn1Info = &certificatePolicies;
    }

    fResult = PkiAsn1AllocStructInfoEx(
        pAsn1Info,
        dwFlags,
        pDecodePara,
        Asn1X509CertPoliciesDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
CommonReturn:
    if (pAsn1Info95)
    {
        if (pPolicyInformation)
            PkiFree(pPolicyInformation);
        Asn1InfoFree(CertificatePolicies95_PDU, pAsn1Info95);
    }
    else
    {
        Asn1InfoFree(CertificatePolicies_PDU, pAsn1Info);
    }
    
    return fResult;

ErrorReturn:
    *pcbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Policy Information 95 - Qualifier 1 decode
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CertPoliciesQualifier1DecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    VerisignQualifier1 *pAsn1Info = (VerisignQualifier1 *) pvAsn1Info; 
    PCERT_POLICY95_QUALIFIER1 pInfo =
        (PCERT_POLICY95_QUALIFIER1) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;
    LONG lAlignExtra;
    DWORD i;
    
    lRemainExtra -= sizeof(CERT_POLICY95_QUALIFIER1);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CERT_POLICY95_QUALIFIER1));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_POLICY95_QUALIFIER1);
    }

    if (
#ifndef OSS_CRYPT_ASN1
            0 != (pAsn1Info->bit_mask & practicesReference_present) &&
#endif  // OSS_CRYPT_ASN1
            pAsn1Info->practicesReference != NULL)
    {
        lAlignExtra = INFO_LEN_ALIGN((strlen(pAsn1Info->practicesReference)+1) * 2);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pInfo->pszPracticesReference = (LPWSTR) pbExtra;
            MultiByteToWideChar(CP_ACP, 
                                0, 
                                pAsn1Info->practicesReference, 
                                -1, 
                                pInfo->pszPracticesReference,
                                lAlignExtra);
            pbExtra += lAlignExtra;
        }
    }
    else if (lRemainExtra >= 0)
    {
        pInfo->pszPracticesReference = NULL;
    }
    
    if (pAsn1Info->bit_mask & noticeId_present)
    {
        Asn1X509GetEncodedObjId(&pAsn1Info->noticeId, dwFlags,
                        &pInfo->pszNoticeIdentifier,
                        &pbExtra, &lRemainExtra);  
    }
    else if (lRemainExtra >= 0)
    {
        pInfo->pszNoticeIdentifier = NULL;
    }

    if (pAsn1Info->bit_mask & nsiNoticeId_present)
    {
        Asn1X509GetEncodedObjId(&pAsn1Info->nsiNoticeId, dwFlags,
                        &pInfo->pszNSINoticeIdentifier,
                        &pbExtra, &lRemainExtra);  
    }
    else if (lRemainExtra >= 0)
    {
        pInfo->pszNSINoticeIdentifier = NULL;
    }

    if (pAsn1Info->bit_mask & cpsURLs_present)
    {
        lAlignExtra = INFO_LEN_ALIGN(pAsn1Info->cpsURLs.count * sizeof(CPS_URLS));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) { 
            pInfo->rgCPSURLs = (CPS_URLS *) pbExtra;
            memset(pInfo->rgCPSURLs, 0, lAlignExtra);
            pInfo->cCPSURLs = pAsn1Info->cpsURLs.count;   
            pbExtra += lAlignExtra;
        }
        
        for (i=0; i<pAsn1Info->cpsURLs.count; i++)
        {
            lAlignExtra = INFO_LEN_ALIGN((strlen(pAsn1Info->cpsURLs.value[i].url)+1) * 2);
            lRemainExtra -= lAlignExtra;
            if (lRemainExtra >= 0)
            {
                pInfo->rgCPSURLs[i].pszURL = (LPWSTR) pbExtra;
                MultiByteToWideChar(CP_ACP, 
                                    0, 
                                    pAsn1Info->cpsURLs.value[i].url, 
                                    -1, 
                                    pInfo->rgCPSURLs[i].pszURL,
                                    lAlignExtra);
                pbExtra += lAlignExtra;
            }

            if (pAsn1Info->cpsURLs.value[i].bit_mask & digestAlgorithmId_present)
            {
                lAlignExtra = INFO_LEN_ALIGN(sizeof(CRYPT_ALGORITHM_IDENTIFIER));
                lRemainExtra -= lAlignExtra;
                if (lRemainExtra >= 0)
                {
                    pInfo->rgCPSURLs[i].pAlgorithm = (CRYPT_ALGORITHM_IDENTIFIER *) pbExtra;
                    memset(pInfo->rgCPSURLs[i].pAlgorithm, 0, lAlignExtra);
                    pbExtra += lAlignExtra;
                }

                Asn1X509GetAlgorithm(
                        &(pAsn1Info->cpsURLs.value[i].digestAlgorithmId),
                        dwFlags,
                        pInfo->rgCPSURLs[i].pAlgorithm,
                        &pbExtra,
                        &lRemainExtra);
            }
            else if (lRemainExtra >= 0)
            {
                pInfo->rgCPSURLs[i].pAlgorithm = NULL;
            }

            if (pAsn1Info->cpsURLs.value[i].bit_mask & digest_present)
            {
                lAlignExtra = INFO_LEN_ALIGN(sizeof(CRYPT_DATA_BLOB));
                lRemainExtra -= lAlignExtra;
                if (lRemainExtra >= 0)
                {
                    pInfo->rgCPSURLs[i].pDigest = (CRYPT_DATA_BLOB *) pbExtra;
                    memset(pInfo->rgCPSURLs[i].pAlgorithm, 0, lAlignExtra);
                    pbExtra += lAlignExtra;
                }   

                Asn1X509GetOctetString(
                        &(pAsn1Info->cpsURLs.value[i].digest),
                        dwFlags,
                        pInfo->rgCPSURLs[i].pDigest,
                        &pbExtra,
                        &lRemainExtra);
            }
            else if (lRemainExtra >= 0)
            {
                pInfo->rgCPSURLs[i].pDigest = NULL;
            }
        }   
    }
    else if (lRemainExtra >= 0)
    {
        pInfo->rgCPSURLs = NULL;
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509CertPoliciesQualifier1DecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        VerisignQualifier1_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509CertPoliciesQualifier1DecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  Authority Information Access Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AuthorityInfoAccessEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_AUTHORITY_INFO_ACCESS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    AuthorityInfoAccess Asn1Info;
    DWORD cAccDescr;
    AccessDescription *pAsn1AccDescr;
    DWORD dwErrLocation;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;

    memset(&Asn1Info, 0, sizeof(Asn1Info));

    cAccDescr = pInfo->cAccDescr;
    if (cAccDescr > 0) {
        pAsn1AccDescr =
            (AccessDescription *) PkiZeroAlloc(cAccDescr *
                sizeof(AccessDescription));
        if (pAsn1AccDescr == NULL)
            goto ErrorReturn;
        Asn1Info.count = cAccDescr;
        Asn1Info.value = pAsn1AccDescr;

        if (!Asn1X509SetAccessDescriptions(
                cAccDescr,
                pInfo->rgAccDescr,
                pAsn1AccDescr,
                &dwErrLocation))
            goto AccessDescriptionsError;

    } else
        pAsn1AccDescr = NULL;

    fResult = Asn1InfoEncodeEx(
        AuthorityInfoAccess_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

AccessDescriptionsError:
    *pcbEncoded = dwErrLocation;
    fResult = FALSE;
    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pAsn1AccDescr) {
        Asn1X509FreeAccessDescriptions(cAccDescr, pAsn1AccDescr);
        PkiFree(pAsn1AccDescr);
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Authority Information Access Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AuthorityInfoAccessDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    AuthorityInfoAccess *pAsn1 = (AuthorityInfoAccess *) pvAsn1Info;
    PCERT_AUTHORITY_INFO_ACCESS pInfo =
        (PCERT_AUTHORITY_INFO_ACCESS) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;
    LONG lAlignExtra;
    DWORD cAccDescr;
    PCERT_ACCESS_DESCRIPTION pAccDescr;

    cAccDescr = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cAccDescr * sizeof(CERT_ACCESS_DESCRIPTION));

    lRemainExtra -= sizeof(CERT_AUTHORITY_INFO_ACCESS) + lAlignExtra;
    if (lRemainExtra < 0) {
        pbExtra = NULL;
        pAccDescr = NULL;
    } else {
        pbExtra = (BYTE *) pInfo + sizeof(CERT_AUTHORITY_INFO_ACCESS);
        pAccDescr = (PCERT_ACCESS_DESCRIPTION) pbExtra;
        pInfo->cAccDescr = cAccDescr;
        pInfo->rgAccDescr = pAccDescr;
        pbExtra += lAlignExtra;
    }

    if (!Asn1X509GetAccessDescriptions(
            cAccDescr,
            pAsn1->value,
            dwFlags,
            pAccDescr,
            &pbExtra,
            &lRemainExtra
            )) goto ErrorReturn;

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}


BOOL WINAPI Asn1X509AuthorityInfoAccessDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        AuthorityInfoAccess_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509AuthorityInfoAccessDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  CRL Distribution Points Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CrlDistPointsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRL_DIST_POINTS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CRLDistributionPoints Asn1Info;
    DistributionPoint *pAsn1DistPoint;
    PCRL_DIST_POINT pDistPoint;
    DWORD cDistPoint;
    DWORD i;
    DWORD dwErrLocation;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (0 == (cDistPoint = pInfo->cDistPoint))
        goto InvalidArg;

    if (NULL == (pAsn1DistPoint = (DistributionPoint *) PkiZeroAlloc(
            cDistPoint * sizeof(DistributionPoint))))
        goto ErrorReturn;
    Asn1Info.count = cDistPoint;
    Asn1Info.value = pAsn1DistPoint;

    pDistPoint = pInfo->rgDistPoint;
    for (i = 0; i < cDistPoint; i++, pDistPoint++, pAsn1DistPoint++) {
        PCRL_DIST_POINT_NAME pDistPointName =
            &pDistPoint->DistPointName;
        if (CRL_DIST_POINT_NO_NAME !=
                pDistPointName->dwDistPointNameChoice) {
            DistributionPointName *pAsn1DistPointName =
                &pAsn1DistPoint->distributionPoint;

            pAsn1DistPoint->bit_mask |= distributionPoint_present;
            pAsn1DistPointName->choice = (unsigned short)
                pDistPointName->dwDistPointNameChoice;
            
            assert(fullName_chosen == CRL_DIST_POINT_FULL_NAME);
            assert(nameRelativeToCRLIssuer_chosen ==
                CRL_DIST_POINT_ISSUER_RDN_NAME);

            switch (pDistPointName->dwDistPointNameChoice) {
                case CRL_DIST_POINT_FULL_NAME:
                    if (!Asn1X509SetAltNames(
                            &pDistPointName->FullName,
                            &pAsn1DistPointName->u.fullName, i, &dwErrLocation))
                        goto AltNamesError;
                    break;
                case CRL_DIST_POINT_ISSUER_RDN_NAME:
                default:
                    goto InvalidArg;
            }
        }

        if (pDistPoint->ReasonFlags.cbData) {
            pAsn1DistPoint->bit_mask |= reasons_present;
            Asn1X509SetBitWithoutTrailingZeroes(&pDistPoint->ReasonFlags,
                &pAsn1DistPoint->reasons);
        }

        if (pDistPoint->CRLIssuer.cAltEntry) {
            pAsn1DistPoint->bit_mask |= cRLIssuer_present;
            if (!Asn1X509SetAltNames(
                    &pDistPoint->CRLIssuer,
                    &pAsn1DistPoint->cRLIssuer,
                    (CRL_DIST_POINT_ERR_CRL_ISSUER_BIT >> 24) | i,
                    &dwErrLocation))
                goto AltNamesError;
        }
    }

    fResult = Asn1InfoEncodeEx(
        CRLDistributionPoints_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;


AltNamesError:
    *pcbEncoded = dwErrLocation;
    fResult = FALSE;
    goto CommonReturn;

InvalidArg:
    SetLastError((DWORD) E_INVALIDARG);
ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    pAsn1DistPoint = Asn1Info.value;
    if (pAsn1DistPoint) {
        cDistPoint = Asn1Info.count;
        pDistPoint = pInfo->rgDistPoint;
        for ( ; cDistPoint > 0; cDistPoint--, pDistPoint++, pAsn1DistPoint++) {
            DistributionPointName *pAsn1DistPointName =
                &pAsn1DistPoint->distributionPoint;

            switch (pAsn1DistPointName->choice) {
                case CRL_DIST_POINT_FULL_NAME:
                    Asn1X509FreeAltNames(&pAsn1DistPointName->u.fullName);
                    break;
                case CRL_DIST_POINT_ISSUER_RDN_NAME:
                default:
                    break;
            }

            Asn1X509FreeAltNames(&pAsn1DistPoint->cRLIssuer);
        }
        PkiFree(Asn1Info.value);
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  CRL Distribution Points Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CrlDistPointsDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CRLDistributionPoints *pAsn1 = (CRLDistributionPoints *) pvAsn1Info;
    PCRL_DIST_POINTS_INFO pInfo = (PCRL_DIST_POINTS_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;
    LONG lAlignExtra;

    lRemainExtra -= sizeof(CRL_DIST_POINTS_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CRL_DIST_POINTS_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CRL_DIST_POINTS_INFO);
    }

    if (pAsn1->count) {
        DWORD cDistPoint = pAsn1->count;
        DistributionPoint *pAsn1DistPoint = pAsn1->value;
        PCRL_DIST_POINT pDistPoint;

        lAlignExtra = INFO_LEN_ALIGN(cDistPoint * sizeof(CRL_DIST_POINT));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pDistPoint = (PCRL_DIST_POINT) pbExtra;
            memset(pDistPoint, 0, cDistPoint * sizeof(CRL_DIST_POINT));
            pInfo->cDistPoint = cDistPoint;
            pInfo->rgDistPoint = pDistPoint;
            pbExtra += lAlignExtra;
        } else
            pDistPoint = NULL;

        for ( ; cDistPoint > 0; cDistPoint--, pAsn1DistPoint++, pDistPoint++) {
            if (pAsn1DistPoint->bit_mask & distributionPoint_present) {
                DistributionPointName *pAsn1DistPointName =
                    &pAsn1DistPoint->distributionPoint;
                DWORD dwDistPointNameChoice = pAsn1DistPointName->choice;
                PCRL_DIST_POINT_NAME pDistPointName;

                if (lRemainExtra >= 0) {
                    pDistPointName = &pDistPoint->DistPointName;
                    pDistPointName->dwDistPointNameChoice =
                        dwDistPointNameChoice;
                } else
                    pDistPointName = NULL;

                assert(fullName_chosen == CRL_DIST_POINT_FULL_NAME);
                assert(nameRelativeToCRLIssuer_chosen ==
                    CRL_DIST_POINT_ISSUER_RDN_NAME);

                switch (dwDistPointNameChoice) {
                    case CRL_DIST_POINT_FULL_NAME:
                        if (!Asn1X509GetAltNames(&pAsn1DistPointName->u.fullName,
                                dwFlags, &pDistPointName->FullName,
                                &pbExtra, &lRemainExtra))
                            goto ErrorReturn;
                        break;
                    case CRL_DIST_POINT_ISSUER_RDN_NAME:
                        break;
                    default:
                        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
                        goto ErrorReturn;
                }
            }

            if (pAsn1DistPoint->bit_mask & reasons_present)
                Asn1X509GetBit(&pAsn1DistPoint->reasons, dwFlags,
                    &pDistPoint->ReasonFlags, &pbExtra, &lRemainExtra);

            if (pAsn1DistPoint->bit_mask & cRLIssuer_present) {
                if (!Asn1X509GetAltNames(&pAsn1DistPoint->cRLIssuer, dwFlags,
                        &pDistPoint->CRLIssuer, &pbExtra, &lRemainExtra))
                    goto ErrorReturn;
            }
        }
    }

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

BOOL WINAPI Asn1X509CrlDistPointsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CRLDistributionPoints_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509CrlDistPointsDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Integer Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509IntegerEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN int *pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    int Asn1Info = *pInfo;

    return Asn1InfoEncodeEx(
        IntegerType_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Integer Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509IntegerDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    int *pAsn1Info = (int *) pvAsn1Info;
    int *pInfo = (int *) pvStructInfo;

    *plRemainExtra -= sizeof(int);
    if (*plRemainExtra >= 0)
        *pInfo = *pAsn1Info;
    return TRUE;
}

BOOL WINAPI Asn1X509IntegerDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        IntegerType_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509IntegerDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  MultiByte Integer Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509MultiByteIntegerEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_INTEGER_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    HUGEINTEGER Asn1Info;


    if (!Asn1X509SetHugeInteger(pInfo, &Asn1Info)) {
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        *pcbEncoded = 0;
        return FALSE;
    }
    fResult = Asn1InfoEncodeEx(
        HugeIntegerType_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    Asn1X509FreeHugeInteger(&Asn1Info);
    return fResult;
}

//+-------------------------------------------------------------------------
//  MultiByte Integer Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509MultiByteIntegerDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    HUGEINTEGER *pAsn1Info = (HUGEINTEGER *) pvAsn1Info;
    PCRYPT_INTEGER_BLOB pInfo = (PCRYPT_INTEGER_BLOB) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRYPT_INTEGER_BLOB);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_INTEGER_BLOB);

    Asn1X509GetHugeInteger(pAsn1Info, dwFlags, pInfo, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509MultiByteIntegerDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        HugeIntegerType_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509MultiByteIntegerDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  MultiByte UINT Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509MultiByteUINTEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_UINT_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    HUGEINTEGER Asn1Info;

    if (!Asn1X509SetHugeUINT(pInfo, &Asn1Info)) {
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        *pcbEncoded = 0;
        return FALSE;
    }
    fResult = Asn1InfoEncodeEx(
        HugeIntegerType_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    Asn1X509FreeHugeUINT(&Asn1Info);
    return fResult;
}

//+-------------------------------------------------------------------------
//  MultiByte UINT Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509MultiByteUINTDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    HUGEINTEGER *pAsn1Info = (HUGEINTEGER *) pvAsn1Info;
    PCRYPT_UINT_BLOB pInfo = (PCRYPT_UINT_BLOB) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRYPT_UINT_BLOB);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_UINT_BLOB);

    Asn1X509GetHugeUINT(pAsn1Info, dwFlags, pInfo, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509MultiByteUINTDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        HugeIntegerType_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509MultiByteUINTDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  DSS Parameters Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509DSSParametersEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_DSS_PARAMETERS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DSSParameters Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1X509SetHugeUINT(&pInfo->p, &Asn1Info.p))
        goto ErrorReturn;
    if (!Asn1X509SetHugeUINT(&pInfo->q, &Asn1Info.q))
        goto ErrorReturn;
    if (!Asn1X509SetHugeUINT(&pInfo->g, &Asn1Info.g))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        DSSParameters_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeHugeUINT(&Asn1Info.p);
    Asn1X509FreeHugeUINT(&Asn1Info.q);
    Asn1X509FreeHugeUINT(&Asn1Info.g);
    return fResult;
}

//+-------------------------------------------------------------------------
//  DSS Parameters Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509DSSParametersDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    DSSParameters *pAsn1Info = (DSSParameters *) pvAsn1Info;
    PCERT_DSS_PARAMETERS pInfo = (PCERT_DSS_PARAMETERS) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_DSS_PARAMETERS);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_DSS_PARAMETERS);

    Asn1X509GetHugeUINT(&pAsn1Info->p, dwFlags,
        &pInfo->p, &pbExtra, &lRemainExtra);
    Asn1X509GetHugeUINT(&pAsn1Info->q, dwFlags,
        &pInfo->q, &pbExtra, &lRemainExtra);
    Asn1X509GetHugeUINT(&pAsn1Info->g, dwFlags,
        &pInfo->g, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509DSSParametersDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        DSSParameters_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509DSSParametersDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  DSS Signature Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509DSSSignatureEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN BYTE rgbSignature[CERT_DSS_SIGNATURE_LEN],
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BYTE rgbR[1 + CERT_DSS_R_LEN];
    BYTE rgbS[1 + CERT_DSS_S_LEN];
    DSSSignature Asn1Signature;
    DWORD i;

    // Treat the r and s components of the DSS signature as being unsigned.
    // Also need to swap before doing the encode.
    rgbR[0] = 0;
    for (i = 0; i < CERT_DSS_R_LEN; i++)
        rgbR[(1 + CERT_DSS_R_LEN - 1) - i] = rgbSignature[i];
    Asn1Signature.r.length = sizeof(rgbR);
    Asn1Signature.r.value = rgbR;

    rgbS[0] = 0;
    for (i = 0; i < CERT_DSS_S_LEN; i++)
        rgbS[(1 + CERT_DSS_S_LEN - 1) - i] =
            rgbSignature[CERT_DSS_R_LEN + i];
    Asn1Signature.s.length = sizeof(rgbS);
    Asn1Signature.s.value = rgbS;

    return Asn1InfoEncodeEx(
        DSSSignature_PDU,
        &Asn1Signature,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  DSS Signature Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509DSSSignatureDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    DSSSignature *pAsn1Signature = (DSSSignature *) pvAsn1Info;
//  BYTE rgbSignature[CERT_DSS_SIGNATURE_LEN],
    BYTE *rgbSignature = (BYTE *) pvStructInfo;
    DWORD cb;
    BYTE *pb;
    DWORD i;

    *plRemainExtra -= CERT_DSS_SIGNATURE_LEN;
    if (*plRemainExtra >= 0) {
        memset(rgbSignature, 0, CERT_DSS_SIGNATURE_LEN);

        // Strip off a leading 0 byte. Byte reverse while copying
        cb = pAsn1Signature->r.length;
        pb = pAsn1Signature->r.value;
        if (cb > 1 && *pb == 0) {
            pb++;
            cb--;
        }
        if (0 == cb || cb > CERT_DSS_R_LEN)
            goto DecodeError;
        for (i = 0; i < cb; i++)
            rgbSignature[i] = pb[cb - 1 - i];

        // Strip off a leading 0 byte. Byte reverse while copying
        cb = pAsn1Signature->s.length;
        pb = pAsn1Signature->s.value;
        if (cb > 1 && *pb == 0) {
            pb++;
            cb--;
        }
        if (0 == cb || cb > CERT_DSS_S_LEN)
            goto DecodeError;
        for (i = 0; i < cb; i++)
            rgbSignature[CERT_DSS_R_LEN + i] = pb[cb - 1 - i];
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(DecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1X509DSSSignatureDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        DSSSignature_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509DSSSignatureDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  DH Parameters Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509DHParametersEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_DH_PARAMETERS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DHParameters Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1X509SetHugeUINT(&pInfo->p, &Asn1Info.p))
        goto ErrorReturn;
    if (!Asn1X509SetHugeUINT(&pInfo->g, &Asn1Info.g))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        DHParameters_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeHugeUINT(&Asn1Info.p);
    Asn1X509FreeHugeUINT(&Asn1Info.g);
    return fResult;
}

//+-------------------------------------------------------------------------
//  DH Parameters Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509DHParametersDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    DHParameters *pAsn1Info = (DHParameters *) pvAsn1Info;
    PCERT_DH_PARAMETERS pInfo = (PCERT_DH_PARAMETERS) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_DH_PARAMETERS);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_DH_PARAMETERS);

    Asn1X509GetHugeUINT(&pAsn1Info->p, dwFlags,
        &pInfo->p, &pbExtra, &lRemainExtra);
    Asn1X509GetHugeUINT(&pAsn1Info->g, dwFlags,
        &pInfo->g, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

//+-------------------------------------------------------------------------
//  DH Parameters Decode (ASN1) New Style X942
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509DHParametersX942DecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    X942DhParameters *pAsn1Info = (X942DhParameters *) pvAsn1Info;
    PCERT_DH_PARAMETERS pInfo = (PCERT_DH_PARAMETERS) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_DH_PARAMETERS);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_DH_PARAMETERS);

    Asn1X509GetHugeUINT(&pAsn1Info->p, dwFlags,
        &pInfo->p, &pbExtra, &lRemainExtra);
    Asn1X509GetHugeUINT(&pAsn1Info->g, dwFlags,
        &pInfo->g, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509DHParametersDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    DWORD cbStructInfo;

    cbStructInfo = *pcbStructInfo;
    fResult = Asn1InfoDecodeAndAllocEx(
        DHParameters_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509DHParametersDecodeExCallback,
        pvStructInfo,
        &cbStructInfo
        );

    if (!fResult && 0 == cbStructInfo) {
        // Try to decode as new style X942 parameters

        DWORD dwErr = GetLastError();

        cbStructInfo = *pcbStructInfo;
        fResult = Asn1InfoDecodeAndAllocEx(
            X942DhParameters_PDU,
            pbEncoded,
            cbEncoded,
            dwFlags,
            pDecodePara,
            Asn1X509DHParametersX942DecodeExCallback,
            pvStructInfo,
            &cbStructInfo
            );
        if (!fResult && 0 == cbStructInfo)
            SetLastError(dwErr);
    }

    *pcbStructInfo = cbStructInfo;
    return fResult;
}

//+-------------------------------------------------------------------------
//  X942 DH Parameters Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X942DhParametersEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_X942_DH_PARAMETERS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    X942DhParameters Asn1Info;

    if (0 == pInfo->q.cbData) {
        CERT_DH_PARAMETERS Pkcs3Info;

        Pkcs3Info.p = pInfo->p;
        Pkcs3Info.g = pInfo->g;
        return Asn1X509DHParametersEncodeEx(
            dwCertEncodingType,
            lpszStructType,
            &Pkcs3Info,
            dwFlags,
            pEncodePara,
            pvEncoded,
            pcbEncoded
            );
    }

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1X509SetHugeUINT(&pInfo->p, &Asn1Info.p))
        goto ErrorReturn;
    if (!Asn1X509SetHugeUINT(&pInfo->g, &Asn1Info.g))
        goto ErrorReturn;
    if (!Asn1X509SetHugeUINT(&pInfo->q, &Asn1Info.q))
        goto ErrorReturn;

    if (pInfo->j.cbData) {
        if (!Asn1X509SetHugeUINT(&pInfo->j, &Asn1Info.j))
            goto ErrorReturn;
        Asn1Info.bit_mask |= j_present;
    }

    if (pInfo->pValidationParams) {
        PCERT_X942_DH_VALIDATION_PARAMS pValidationParams =
            pInfo->pValidationParams;

        Asn1X509SetBit(&pValidationParams->seed,
            &Asn1Info.validationParams.seed);
        Asn1Info.validationParams.pgenCounter = pValidationParams->pgenCounter;
        Asn1Info.bit_mask |= validationParams_present;
    }

    fResult = Asn1InfoEncodeEx(
        X942DhParameters_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeHugeUINT(&Asn1Info.p);
    Asn1X509FreeHugeUINT(&Asn1Info.g);
    Asn1X509FreeHugeUINT(&Asn1Info.q);
    Asn1X509FreeHugeUINT(&Asn1Info.j);
    return fResult;
}

//+-------------------------------------------------------------------------
//  X942 DH Parameters Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X942DhParametersDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    X942DhParameters *pAsn1Info = (X942DhParameters *) pvAsn1Info;
    PCERT_X942_DH_PARAMETERS pInfo = (PCERT_X942_DH_PARAMETERS) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_X942_DH_PARAMETERS);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_X942_DH_PARAMETERS));

        pbExtra = (BYTE *) pInfo + sizeof(CERT_X942_DH_PARAMETERS);
    }

    Asn1X509GetHugeUINT(&pAsn1Info->p, dwFlags,
        &pInfo->p, &pbExtra, &lRemainExtra);
    Asn1X509GetHugeUINT(&pAsn1Info->g, dwFlags,
        &pInfo->g, &pbExtra, &lRemainExtra);
    Asn1X509GetHugeUINT(&pAsn1Info->q, dwFlags,
        &pInfo->q, &pbExtra, &lRemainExtra);

    if (pAsn1Info->bit_mask & j_present)
        Asn1X509GetHugeUINT(&pAsn1Info->j, dwFlags,
            &pInfo->j, &pbExtra, &lRemainExtra);

    if (pAsn1Info->bit_mask & validationParams_present) {
        PCERT_X942_DH_VALIDATION_PARAMS pValidationParams;

        lRemainExtra -= sizeof(CERT_X942_DH_VALIDATION_PARAMS);

        if (lRemainExtra < 0) {
            pValidationParams = NULL;
        } else {
            pValidationParams = (PCERT_X942_DH_VALIDATION_PARAMS) pbExtra;
            pInfo->pValidationParams = pValidationParams;
            pbExtra += sizeof(CERT_X942_DH_VALIDATION_PARAMS);
            pValidationParams->pgenCounter =
                pAsn1Info->validationParams.pgenCounter;
        }

        Asn1X509GetBit(&pAsn1Info->validationParams.seed, dwFlags,
            &pValidationParams->seed, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

//+-------------------------------------------------------------------------
//  X942 DH Parameters Decode (ASN1) Old Style Pkcs #3
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X942DhParametersPkcs3DecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    DHParameters *pAsn1Info = (DHParameters *) pvAsn1Info;
    PCERT_X942_DH_PARAMETERS pInfo = (PCERT_X942_DH_PARAMETERS) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_X942_DH_PARAMETERS);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_X942_DH_PARAMETERS));

        pbExtra = (BYTE *) pInfo + sizeof(CERT_X942_DH_PARAMETERS);
    }
    Asn1X509GetHugeUINT(&pAsn1Info->p, dwFlags,
        &pInfo->p, &pbExtra, &lRemainExtra);
    Asn1X509GetHugeUINT(&pAsn1Info->g, dwFlags,
        &pInfo->g, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X942DhParametersDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    DWORD cbStructInfo;

    cbStructInfo = *pcbStructInfo;
    fResult = Asn1InfoDecodeAndAllocEx(
        X942DhParameters_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X942DhParametersDecodeExCallback,
        pvStructInfo,
        &cbStructInfo
        );

    if (!fResult && 0 == cbStructInfo) {
        // Try to decode as old style PKCS #3 parameters

        DWORD dwErr = GetLastError();

        cbStructInfo = *pcbStructInfo;
        fResult = Asn1InfoDecodeAndAllocEx(
            DHParameters_PDU,
            pbEncoded,
            cbEncoded,
            dwFlags,
            pDecodePara,
            Asn1X942DhParametersPkcs3DecodeExCallback,
            pvStructInfo,
            &cbStructInfo
            );
        if (!fResult && 0 == cbStructInfo)
            SetLastError(dwErr);
    }

    *pcbStructInfo = cbStructInfo;
    return fResult;
}


//+-------------------------------------------------------------------------
//  X942_OTHER_INFO Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X942OtherInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_X942_OTHER_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    X942DhOtherInfo Asn1Info;
    BYTE rgbAsn1Counter[CRYPT_X942_COUNTER_BYTE_LENGTH];
    BYTE rgbAsn1KeyLength[CRYPT_X942_KEY_LENGTH_BYTE_LENGTH];

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1X509SetEncodedObjId(pInfo->pszContentEncryptionObjId,
            &Asn1Info.keyInfo.algorithm))
        goto ErrorReturn;

    memcpy(rgbAsn1Counter, pInfo->rgbCounter, CRYPT_X942_COUNTER_BYTE_LENGTH);
    PkiAsn1ReverseBytes(rgbAsn1Counter, CRYPT_X942_COUNTER_BYTE_LENGTH);
    Asn1Info.keyInfo.counter.length = CRYPT_X942_COUNTER_BYTE_LENGTH;
    Asn1Info.keyInfo.counter.value = rgbAsn1Counter;

    memcpy(rgbAsn1KeyLength, pInfo->rgbKeyLength,
        CRYPT_X942_KEY_LENGTH_BYTE_LENGTH);
    PkiAsn1ReverseBytes(rgbAsn1KeyLength, CRYPT_X942_KEY_LENGTH_BYTE_LENGTH);
    Asn1Info.keyLength.length = CRYPT_X942_KEY_LENGTH_BYTE_LENGTH;
    Asn1Info.keyLength.value = rgbAsn1KeyLength;

    if (pInfo->PubInfo.cbData) {
        Asn1X509SetOctetString(&pInfo->PubInfo, &Asn1Info.pubInfo);
        Asn1Info.bit_mask |= pubInfo_present;
    }

    fResult = Asn1InfoEncodeEx(
        X942DhOtherInfo_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

//+-------------------------------------------------------------------------
//  X942_OTHER_INFO Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X942OtherInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    X942DhOtherInfo *pAsn1Info = (X942DhOtherInfo *) pvAsn1Info;
    PCRYPT_X942_OTHER_INFO pInfo = (PCRYPT_X942_OTHER_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    if (CRYPT_X942_COUNTER_BYTE_LENGTH != pAsn1Info->keyInfo.counter.length ||
            CRYPT_X942_KEY_LENGTH_BYTE_LENGTH !=
                pAsn1Info->keyLength.length) {
        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
        return FALSE;
    }

    lRemainExtra -= sizeof(CRYPT_X942_OTHER_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CRYPT_X942_OTHER_INFO));

        memcpy(pInfo->rgbCounter, pAsn1Info->keyInfo.counter.value,
            CRYPT_X942_COUNTER_BYTE_LENGTH);
        PkiAsn1ReverseBytes(pInfo->rgbCounter, CRYPT_X942_COUNTER_BYTE_LENGTH);

        memcpy(pInfo->rgbKeyLength, pAsn1Info->keyLength.value,
            CRYPT_X942_KEY_LENGTH_BYTE_LENGTH);
        PkiAsn1ReverseBytes(pInfo->rgbKeyLength,
            CRYPT_X942_KEY_LENGTH_BYTE_LENGTH);

        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_X942_OTHER_INFO);
    }

    Asn1X509GetEncodedObjId(&pAsn1Info->keyInfo.algorithm, dwFlags,
            &pInfo->pszContentEncryptionObjId,
            &pbExtra, &lRemainExtra);

    if (pAsn1Info->bit_mask & pubInfo_present) {
        Asn1X509GetOctetString(&pAsn1Info->pubInfo, dwFlags,
            &pInfo->PubInfo, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X942OtherInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        X942DhOtherInfo_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X942OtherInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  RC2 CBC Parameters Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1RC2CBCParametersEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_RC2_CBC_PARAMETERS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    RC2CBCParameters Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    Asn1Info.version = pInfo->dwVersion;
    if (pInfo->fIV) {
        Asn1Info.bit_mask |= iv_present;
        Asn1Info.iv.length = sizeof(pInfo->rgbIV);
        Asn1Info.iv.value = pInfo->rgbIV;
    }

    return Asn1InfoEncodeEx(
        RC2CBCParameters_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  RC2 CBC Parameters Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1RC2CBCParametersDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    RC2CBCParameters *pAsn1Info = (RC2CBCParameters *) pvAsn1Info;
    PCRYPT_RC2_CBC_PARAMETERS pInfo = (PCRYPT_RC2_CBC_PARAMETERS) pvStructInfo;

    *plRemainExtra -= sizeof(CRYPT_RC2_CBC_PARAMETERS);
    if (*plRemainExtra >= 0) {
        memset(pInfo, 0, sizeof(CRYPT_RC2_CBC_PARAMETERS));
        pInfo->dwVersion = pAsn1Info->version;
        if (pAsn1Info->bit_mask & iv_present) {
            pInfo->fIV = TRUE;
            if (pAsn1Info->iv.length != sizeof(pInfo->rgbIV))
                goto DecodeError;
            memcpy(pInfo->rgbIV, pAsn1Info->iv.value, sizeof(pInfo->rgbIV));
        }
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(DecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1RC2CBCParametersDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        RC2CBCParameters_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1RC2CBCParametersDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  SMIME Capabilities Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1SMIMECapabilitiesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_SMIME_CAPABILITIES pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    SMIMECapabilities Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (0 != pInfo->cCapability) {
        DWORD cCap = pInfo->cCapability;
        PCRYPT_SMIME_CAPABILITY pCap = pInfo->rgCapability;
        SMIMECapability *pAsn1Cap;
        
        if (NULL == (pAsn1Cap = (SMIMECapability *) PkiZeroAlloc(
                cCap * sizeof(SMIMECapability))))
            goto ErrorReturn;

        Asn1Info.count = cCap;
        Asn1Info.value = pAsn1Cap;
        for ( ; cCap > 0; cCap--, pCap++, pAsn1Cap++) {
            if (!Asn1X509SetEncodedObjId(pCap->pszObjId, &pAsn1Cap->capabilityID))
                goto ErrorReturn;
            if (pCap->Parameters.cbData) {
                pAsn1Cap->bit_mask |= smimeParameters_present;
                Asn1X509SetAny(&pCap->Parameters,
                    &pAsn1Cap->smimeParameters);
            }
        }
    }

    fResult = Asn1InfoEncodeEx(
        SMIMECapabilities_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    PkiFree(Asn1Info.value);
    return fResult;
}

//+-------------------------------------------------------------------------
//  SMIME Capabilities Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1SMIMECapabilitiesDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    SMIMECapabilities *pAsn1Info = (SMIMECapabilities *) pvAsn1Info;
    PCRYPT_SMIME_CAPABILITIES pInfo = (PCRYPT_SMIME_CAPABILITIES) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;
    LONG lAlignExtra;
    DWORD cCap;
    SMIMECapability *pAsn1Cap;
    PCRYPT_SMIME_CAPABILITY pCap;

    cCap = pAsn1Info->count;
    lAlignExtra = cCap * sizeof(CRYPT_SMIME_CAPABILITY);

    lRemainExtra -= sizeof(CRYPT_SMIME_CAPABILITIES) + lAlignExtra;
    if (lRemainExtra < 0) {
        pbExtra = NULL;
        pCap = NULL;
    } else {
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_SMIME_CAPABILITIES);
        pCap = (PCRYPT_SMIME_CAPABILITY) pbExtra;
        pInfo->cCapability = cCap;
        pInfo->rgCapability = pCap;
        if (lAlignExtra) {
            memset(pbExtra, 0, lAlignExtra);
            pbExtra += lAlignExtra;
        }
    }

    pAsn1Cap = pAsn1Info->value;
    for ( ; cCap > 0; cCap--, pAsn1Cap++, pCap++) {
        Asn1X509GetEncodedObjId(&pAsn1Cap->capabilityID, dwFlags, &pCap->pszObjId,
            &pbExtra, &lRemainExtra);
        if (pAsn1Cap->bit_mask & smimeParameters_present)
            Asn1X509GetAny(&pAsn1Cap->smimeParameters, dwFlags,
                &pCap->Parameters, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1SMIMECapabilitiesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        SMIMECapabilities_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1SMIMECapabilitiesDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Enumerated Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509EnumeratedEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN int *pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    EnumeratedType Asn1Info = (EnumeratedType) *pInfo;

    return Asn1InfoEncodeEx(
        EnumeratedType_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Enumerated Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509EnumeratedDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    EnumeratedType *pAsn1Info = (EnumeratedType *) pvAsn1Info;
    int *pInfo = (int *) pvStructInfo;

    *plRemainExtra -= sizeof(int);
    if (*plRemainExtra >= 0)
        *pInfo = *pAsn1Info;
    return TRUE;
}

BOOL WINAPI Asn1X509EnumeratedDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        EnumeratedType_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509EnumeratedDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Octet String Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509OctetStringEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_DATA_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    OCTETSTRING Asn1Info;

    Asn1X509SetOctetString(pInfo, &Asn1Info);
    return Asn1InfoEncodeEx(
        OctetStringType_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
// Octet String Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509OctetStringDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    OCTETSTRING *pAsn1Info = (OCTETSTRING *) pvAsn1Info;
    PCRYPT_DATA_BLOB pInfo = (PCRYPT_DATA_BLOB) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRYPT_DATA_BLOB);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_DATA_BLOB);

    Asn1X509GetOctetString(pAsn1Info, dwFlags, pInfo, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509OctetStringDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        OctetStringType_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509OctetStringDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  ChoiceOfTime Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ChoiceOfTimeEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN LPFILETIME pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    ChoiceOfTime Asn1Info;

    if (!PkiAsn1ToChoiceOfTime(pInfo,
            &Asn1Info.choice,
            &Asn1Info.u.generalTime ,
            &Asn1Info.u.utcTime
            )) {
        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        *pcbEncoded = 0;
        return FALSE;
    }
    return Asn1InfoEncodeEx(
        ChoiceOfTime_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  ChoiceOfTime Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ChoiceOfTimeDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    ChoiceOfTime *pAsn1Info = (ChoiceOfTime *) pvAsn1Info;
    LPFILETIME pInfo = (LPFILETIME) pvStructInfo;

    *plRemainExtra -= sizeof(FILETIME);
    if (*plRemainExtra >= 0) {
        if (!PkiAsn1FromChoiceOfTime(pAsn1Info->choice,
                &pAsn1Info->u.generalTime,
                &pAsn1Info->u.utcTime,
                pInfo))
            goto DecodeError;
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(DecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1X509ChoiceOfTimeDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        ChoiceOfTime_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509ChoiceOfTimeDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  Attribute Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AttributeEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ATTRIBUTE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    Attribute Asn1Info;


    if (!Asn1X509SetAttribute(pInfo, &Asn1Info)) {
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        *pcbEncoded = 0;
        return FALSE;
    }
    fResult = Asn1InfoEncodeEx(
        Attribute_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    Asn1X509FreeAttribute(&Asn1Info);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Attribute Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AttributeDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    Attribute *pAsn1Info = (Attribute *) pvAsn1Info;
    PCRYPT_ATTRIBUTE pInfo = (PCRYPT_ATTRIBUTE) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRYPT_ATTRIBUTE);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_ATTRIBUTE);

    Asn1X509GetAttribute(pAsn1Info, dwFlags, pInfo, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509AttributeDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        Attribute_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509AttributeDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  ContentInfo Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ContentInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_CONTENT_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    ContentInfo Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1X509SetEncodedObjId(pInfo->pszObjId, &Asn1Info.contentType)) {
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        *pcbEncoded = 0;
        return FALSE;
    }

    if (pInfo->Content.cbData) {
        Asn1Info.bit_mask |= content_present;
        Asn1X509SetAny(&pInfo->Content, &Asn1Info.content);
    }

    return Asn1InfoEncodeEx(
        ContentInfo_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  ContentInfo Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ContentInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    ContentInfo *pAsn1Info = (ContentInfo *) pvAsn1Info;
    PCRYPT_CONTENT_INFO pInfo = (PCRYPT_CONTENT_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRYPT_CONTENT_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CRYPT_CONTENT_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_CONTENT_INFO);
    }

    Asn1X509GetEncodedObjId(&pAsn1Info->contentType, dwFlags,
        &pInfo->pszObjId, &pbExtra, &lRemainExtra);
    if (pAsn1Info->bit_mask & content_present)
        Asn1X509GetAny(&pAsn1Info->content, dwFlags,
            &pInfo->Content, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509ContentInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        ContentInfo_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509ContentInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  ContentInfoSequenceOfAny Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ContentInfoSequenceOfAnyEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    ContentInfoSeqOfAny Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1X509SetEncodedObjId(pInfo->pszObjId, &Asn1Info.contentType))
        goto ErrorReturn;

    if (pInfo->cValue) {
        Asn1Info.bit_mask |= contentSeqOfAny_present;
        if (!Asn1X509SetSeqOfAny(
                pInfo->cValue,
                pInfo->rgValue,
                &Asn1Info.contentSeqOfAny.count,
                &Asn1Info.contentSeqOfAny.value))
            goto ErrorReturn;
    }

    fResult = Asn1InfoEncodeEx(
        ContentInfoSeqOfAny_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeSeqOfAny(Asn1Info.contentSeqOfAny.value);
    return fResult;
}

//+-------------------------------------------------------------------------
//  ContentInfoSequenceOfAny Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ContentInfoSequenceOfAnyDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    ContentInfoSeqOfAny *pAsn1Info = (ContentInfoSeqOfAny *) pvAsn1Info;
    PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY pInfo =
        (PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY));
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY);
    }

    Asn1X509GetEncodedObjId(&pAsn1Info->contentType, dwFlags,
        &pInfo->pszObjId, &pbExtra, &lRemainExtra);
    if (pAsn1Info->bit_mask & contentSeqOfAny_present)
        Asn1X509GetSeqOfAny(pAsn1Info->contentSeqOfAny.count,
            pAsn1Info->contentSeqOfAny.value, dwFlags,
            &pInfo->cValue, &pInfo->rgValue, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509ContentInfoSequenceOfAnyDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        ContentInfoSeqOfAny_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509ContentInfoSequenceOfAnyDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  SequenceOfAny Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509SequenceOfAnyEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_SEQUENCE_OF_ANY pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    SeqOfAny Asn1Info;

    if (!Asn1X509SetSeqOfAny(
            pInfo->cValue,
            pInfo->rgValue,
            &Asn1Info.count,
            &Asn1Info.value))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        SeqOfAny_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeSeqOfAny(Asn1Info.value);
    return fResult;
}

//+-------------------------------------------------------------------------
//  SequenceOfAny Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509SequenceOfAnyDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    SeqOfAny *pAsn1Info = (SeqOfAny *) pvAsn1Info;
    PCRYPT_SEQUENCE_OF_ANY pInfo = (PCRYPT_SEQUENCE_OF_ANY) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRYPT_SEQUENCE_OF_ANY);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_SEQUENCE_OF_ANY);
    }

    Asn1X509GetSeqOfAny(pAsn1Info->count, pAsn1Info->value, dwFlags,
            &pInfo->cValue, &pInfo->rgValue, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509SequenceOfAnyDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        SeqOfAny_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509SequenceOfAnyDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  UTC TIME Encode/Decode
//--------------------------------------------------------------------------
BOOL WINAPI Asn1UtcTimeEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN FILETIME * pFileTime,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        ) {

    assert(pcbEncoded != NULL);

    BOOL fResult;
    UtcTime utcTime;

    memset(&utcTime, 0, sizeof(UtcTime));

    if( !PkiAsn1ToUTCTime(pFileTime, &utcTime) )
            goto PkiAsn1ToUTCTimeError;

    fResult = Asn1InfoEncodeEx(
                UtcTime_PDU,
                &utcTime,
                dwFlags,
                pEncodePara,
                pvEncoded,
                pcbEncoded
                );

CommonReturn:
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(PkiAsn1ToUTCTimeError, CRYPT_E_BAD_ENCODE);
}


BOOL WINAPI Asn1UtcTimeDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    UtcTime *putcTime = (UtcTime *) pvAsn1Info;
    LPFILETIME pInfo = (LPFILETIME) pvStructInfo;

    *plRemainExtra -= sizeof(FILETIME);
    if (*plRemainExtra >= 0) {
        if(!PkiAsn1FromUTCTime(putcTime, pInfo))
            goto DecodeError;
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(DecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1UtcTimeDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        UtcTime_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1UtcTimeDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

BOOL WINAPI Asn1TimeStampRequestInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_TIME_STAMP_REQUEST_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD   pdu;

    union {
        TimeStampRequest tsr;
        TimeStampRequestOTS tsrocs;
        } timeStampReq;

    memset(&timeStampReq, 0, sizeof(TimeStampRequest));

    if( !Asn1X509SetEncodedObjId(pInfo->pszTimeStampAlgorithm, &timeStampReq.tsr.timeStampAlgorithm) ||
        !Asn1X509SetEncodedObjId(pInfo->pszContentType, &timeStampReq.tsr.content.contentType) )
	goto Asn1X509SetEncodedObjIdError;

    // only write content if it is present
    if(pInfo->Content.cbData != 0)
        timeStampReq.tsr.content.bit_mask |= content_present;

    if(!strcmp(pInfo->pszContentType, szOID_RSA_data)) {
        Asn1X509SetOctetString(&pInfo->Content, &timeStampReq.tsrocs.contentOTS.contentOTS);
        pdu = TimeStampRequestOTS_PDU;
        }
    else {
        Asn1X509SetAny(&pInfo->Content, &timeStampReq.tsr.content.content);
        pdu = TimeStampRequest_PDU;
        }

    if (pInfo->cAttribute > 0) {
        if (!Asn1X509SetAttributes(pInfo->cAttribute, pInfo->rgAttribute,
                &timeStampReq.tsr.attributesTS))
            goto ErrorReturn;
        timeStampReq.tsr.bit_mask |= attributesTS_present;
    }

    fResult = Asn1InfoEncodeEx(
        pdu,
        &timeStampReq,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

CommonReturn:
    Asn1X509FreeAttributes(&timeStampReq.tsr.attributesTS);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(Asn1X509SetEncodedObjIdError);
}


//+-------------------------------------------------------------------------
//  Decode the Time Stamp Request Info (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1TimeStampRequestInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    TimeStampRequest *pTimeStampReq = (TimeStampRequest *) pvAsn1Info;
    PCRYPT_TIME_STAMP_REQUEST_INFO pInfo =
        (PCRYPT_TIME_STAMP_REQUEST_INFO) pvStructInfo;

    OctetStringType *pOctetStringType = NULL;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRYPT_TIME_STAMP_REQUEST_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CRYPT_TIME_STAMP_REQUEST_INFO));

        // Update fields not needing extra memory after the CERT_INFO
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_TIME_STAMP_REQUEST_INFO);
    }

    Asn1X509GetEncodedObjId(   &pTimeStampReq->timeStampAlgorithm,
                        dwFlags,
                       &pInfo->pszTimeStampAlgorithm,
                       &pbExtra,
                       &lRemainExtra
                   );
    Asn1X509GetEncodedObjId(   &pTimeStampReq->content.contentType,
                        dwFlags,
                       &pInfo->pszContentType,
                       &pbExtra,
                       &lRemainExtra
                   );

    if(pTimeStampReq->content.bit_mask == content_present) {
    
        // OctetStrings will be smaller, so when doing byte counting go to
        // ANY which will requre more room for decode...
        if(pInfo && !strcmp(pInfo->pszContentType, szOID_RSA_data)) {

            if (!Asn1InfoDecodeAndAlloc(
                        OctetStringType_PDU,
                        (const unsigned char *) pTimeStampReq->content.content.encoded,
                        pTimeStampReq->content.content.length,
                        (void **) &pOctetStringType))
                    goto Asn1InfoDecodeAndAllocError;

            Asn1X509GetOctetString(pOctetStringType, dwFlags,
                &pInfo->Content, &pbExtra, &lRemainExtra);
        }
        else
            Asn1X509GetAny(&pTimeStampReq->content.content, dwFlags,
                &pInfo->Content, &pbExtra, &lRemainExtra);
    }

    if (pTimeStampReq->bit_mask & attributesTS_present) {
        Asn1X509GetAttributes(&pTimeStampReq->attributesTS, dwFlags,
            &pInfo->cAttribute, &pInfo->rgAttribute, &pbExtra, &lRemainExtra);
    }

    fResult = TRUE;

CommonReturn:
    Asn1InfoFree(OctetStringType_PDU, pOctetStringType);
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(Asn1InfoDecodeAndAllocError);
}

BOOL WINAPI Asn1TimeStampRequestInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        TimeStampRequest_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1TimeStampRequestInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  Set/Free/Get CTL Usage object identifiers
//--------------------------------------------------------------------------
BOOL Asn1X509SetCtlUsage(
        IN PCTL_USAGE pUsage,
        OUT EnhancedKeyUsage *pAsn1
        )
{
    DWORD cId;
    LPSTR *ppszId;
    UsageIdentifier *pAsn1Id;

    pAsn1->count = 0;
    pAsn1->value = NULL;
    cId = pUsage->cUsageIdentifier;
    if (0 == cId)
        return TRUE;

    pAsn1Id = (UsageIdentifier *) PkiNonzeroAlloc(cId * sizeof(UsageIdentifier));
    if (pAsn1Id == NULL)
        return FALSE;

    pAsn1->count = cId;
    pAsn1->value = pAsn1Id;
    ppszId = pUsage->rgpszUsageIdentifier;
    for ( ; cId > 0; cId--, ppszId++, pAsn1Id++) {
        if (!Asn1X509SetEncodedObjId(*ppszId, pAsn1Id))
            return FALSE;
    }

    return TRUE;
}

void Asn1X509FreeCtlUsage(
        IN EnhancedKeyUsage *pAsn1)
{
    if (pAsn1->value) {
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
}

void Asn1X509GetCtlUsage(
        IN EnhancedKeyUsage *pAsn1,
        IN DWORD dwFlags,
        OUT PCTL_USAGE pUsage,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cId;
    UsageIdentifier *pAsn1Id;
    LPSTR *ppszId;

    cId = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cId * sizeof(LPSTR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pUsage->cUsageIdentifier = cId;
        ppszId = (LPSTR *) pbExtra;
        pUsage->rgpszUsageIdentifier = ppszId;
        pbExtra += lAlignExtra;
    } else
        ppszId = NULL;

    pAsn1Id = pAsn1->value;
    for ( ; cId > 0; cId--, pAsn1Id++, ppszId++)
        Asn1X509GetEncodedObjId(pAsn1Id, dwFlags, ppszId, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  CTL Usage (Enhanced Key Usage) Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CtlUsageEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCTL_USAGE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    EnhancedKeyUsage Asn1Info;

    if (!Asn1X509SetCtlUsage(pInfo, &Asn1Info)) {
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        *pcbEncoded = 0;
        fResult = FALSE;
    } else
        fResult = Asn1InfoEncodeEx(
            EnhancedKeyUsage_PDU,
            &Asn1Info,
            dwFlags,
            pEncodePara,
            pvEncoded,
            pcbEncoded
            );
    Asn1X509FreeCtlUsage(&Asn1Info);
    return fResult;
}

//+-------------------------------------------------------------------------
//  CTL Usage (Enhanced Key Usage) Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CtlUsageDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    EnhancedKeyUsage *pAsn1Info = (EnhancedKeyUsage *) pvAsn1Info;
    PCTL_USAGE pInfo = (PCTL_USAGE) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CTL_USAGE);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CTL_USAGE);

    Asn1X509GetCtlUsage(pAsn1Info, dwFlags, pInfo, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509CtlUsageDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        EnhancedKeyUsage_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509CtlUsageDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CTL Entries
//--------------------------------------------------------------------------
BOOL Asn1X509SetCtlEntries(
        IN DWORD cEntry,
        IN PCTL_ENTRY pEntry,
        OUT TrustedSubjects *pAsn1
        )
{
    TrustedSubject *pAsn1Entry;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cEntry == 0)
        return TRUE;

    pAsn1Entry = (TrustedSubject *) PkiZeroAlloc(
        cEntry * sizeof(TrustedSubject));
    if (pAsn1Entry == NULL)
        return FALSE;
    pAsn1->value = pAsn1Entry;
    pAsn1->count = cEntry;

    for ( ; cEntry > 0; cEntry--, pEntry++, pAsn1Entry++) {
        Asn1X509SetOctetString(&pEntry->SubjectIdentifier,
            &pAsn1Entry->subjectIdentifier);
        if (pEntry->cAttribute > 0) {
            pAsn1Entry->bit_mask |= subjectAttributes_present;

            if (!Asn1X509SetAttributes(pEntry->cAttribute, pEntry->rgAttribute,
                    &pAsn1Entry->subjectAttributes))
                return FALSE;
        }
    }
    return TRUE;
}

void Asn1X509FreeCtlEntries(
        IN TrustedSubjects *pAsn1)
{
    if (pAsn1->value) {
        DWORD cEntry = pAsn1->count;
        TrustedSubject *pAsn1Entry = pAsn1->value;
        for ( ; cEntry > 0; cEntry--, pAsn1Entry++)
            Asn1X509FreeAttributes(&pAsn1Entry->subjectAttributes);
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

void Asn1X509GetCtlEntries(
        IN TrustedSubjects *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcEntry,
        OUT PCTL_ENTRY *ppEntry,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cEntry;
    TrustedSubject *pAsn1Entry;
    PCTL_ENTRY pEntry;

    cEntry = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cEntry * sizeof(CTL_ENTRY));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcEntry = cEntry;
        pEntry = (PCTL_ENTRY) pbExtra;
        memset(pEntry, 0, cEntry * sizeof(CTL_ENTRY));
        *ppEntry = pEntry;
        pbExtra += lAlignExtra;
    } else
        pEntry = NULL;

    pAsn1Entry = pAsn1->value;
    for ( ; cEntry > 0; cEntry--, pAsn1Entry++, pEntry++) {
        // SubjectIdentifier
        Asn1X509GetOctetString(&pAsn1Entry->subjectIdentifier, dwFlags,
                &pEntry->SubjectIdentifier, &pbExtra, &lRemainExtra);

        // Attributes
        if (pAsn1Entry->bit_mask & subjectAttributes_present) {
            Asn1X509GetAttributes(&pAsn1Entry->subjectAttributes, dwFlags,
                &pEntry->cAttribute, &pEntry->rgAttribute,
                &pbExtra, &lRemainExtra);
        }
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Encode the CTL Info (ASN1 X509 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CtlInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCTL_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CertificateTrustList Ctl;

    memset(&Ctl, 0, sizeof(Ctl));

    if (pInfo->dwVersion != 0) {
#ifdef OSS_CRYPT_ASN1
        Ctl.CertificateTrustList_version = pInfo->dwVersion;
#else
        Ctl.version = pInfo->dwVersion;
#endif  // OSS_CRYPT_ASN1
        Ctl.bit_mask |= CertificateTrustList_version_present;
    }
    if (!Asn1X509SetCtlUsage(&pInfo->SubjectUsage, &Ctl.subjectUsage))
        goto ErrorReturn;
    if (pInfo->ListIdentifier.cbData) {
        Asn1X509SetOctetString(&pInfo->ListIdentifier, &Ctl.listIdentifier);
        Ctl.bit_mask |= listIdentifier_present;
    }
    if (pInfo->SequenceNumber.cbData) {
        if (!Asn1X509SetHugeInteger(&pInfo->SequenceNumber,
                &Ctl.sequenceNumber))
            goto ErrorReturn;
        Ctl.bit_mask |= sequenceNumber_present;
    }
    if (!PkiAsn1ToChoiceOfTime(&pInfo->ThisUpdate, 
            &Ctl.ctlThisUpdate.choice,
            &Ctl.ctlThisUpdate.u.generalTime,
            &Ctl.ctlThisUpdate.u.utcTime
            ))
        goto EncodeError;
    if (pInfo->NextUpdate.dwLowDateTime || pInfo->NextUpdate.dwHighDateTime) {
        Ctl.bit_mask |= ctlNextUpdate_present;
        if (!PkiAsn1ToChoiceOfTime(&pInfo->NextUpdate, 
                &Ctl.ctlNextUpdate.choice,
                &Ctl.ctlNextUpdate.u.generalTime,
                &Ctl.ctlNextUpdate.u.utcTime
                ))
            goto EncodeError;
    }
    if (!Asn1X509SetAlgorithm(&pInfo->SubjectAlgorithm, &Ctl.subjectAlgorithm))
        goto ErrorReturn;
    if (pInfo->cCTLEntry) {
        if (!Asn1X509SetCtlEntries(pInfo->cCTLEntry, pInfo->rgCTLEntry,
                &Ctl.trustedSubjects))
            goto ErrorReturn;
        Ctl.bit_mask |= trustedSubjects_present;
    }
    if (pInfo->cExtension) {
        if (!Asn1X509SetExtensions(pInfo->cExtension, pInfo->rgExtension,
                &Ctl.ctlExtensions))
            goto ErrorReturn;
        Ctl.bit_mask |= ctlExtensions_present;
    }

    fResult = Asn1InfoEncodeEx(
        CertificateTrustList_PDU,
        &Ctl,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

EncodeError:
    SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeCtlUsage(&Ctl.subjectUsage);
    Asn1X509FreeHugeInteger(&Ctl.sequenceNumber);
    Asn1X509FreeCtlEntries(&Ctl.trustedSubjects);
    Asn1X509FreeExtensions(&Ctl.ctlExtensions);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode the CTL Info (ASN1 X509 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CtlInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CertificateTrustList *pCtl = (CertificateTrustList *) pvAsn1Info;
    PCTL_INFO pInfo = (PCTL_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CTL_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CTL_INFO));

        // Update fields not needing extra memory after the CTL_INFO
        if (pCtl->bit_mask &
                CertificateTrustList_version_present)
#ifdef OSS_CRYPT_ASN1
            pInfo->dwVersion =
                pCtl->CertificateTrustList_version;
#else
            pInfo->dwVersion = pCtl->version;
#endif  // OSS_CRYPT_ASN1
        if (!PkiAsn1FromChoiceOfTime(pCtl->ctlThisUpdate.choice,
                &pCtl->ctlThisUpdate.u.generalTime,
                &pCtl->ctlThisUpdate.u.utcTime,
                &pInfo->ThisUpdate))
            goto DecodeError;
        if (pCtl->bit_mask & ctlNextUpdate_present) {
            if (!PkiAsn1FromChoiceOfTime(pCtl->ctlNextUpdate.choice,
                    &pCtl->ctlNextUpdate.u.generalTime,
                    &pCtl->ctlNextUpdate.u.utcTime,
                    &pInfo->NextUpdate))
                goto DecodeError;
        }

        pbExtra = (BYTE *) pInfo + sizeof(CTL_INFO);
    }

    Asn1X509GetCtlUsage(&pCtl->subjectUsage, dwFlags,
            &pInfo->SubjectUsage, &pbExtra, &lRemainExtra);
    if (pCtl->bit_mask & listIdentifier_present)
        // Always copy to force alignment
        Asn1X509GetOctetString(&pCtl->listIdentifier,
                dwFlags & ~CRYPT_DECODE_NOCOPY_FLAG,
                &pInfo->ListIdentifier, &pbExtra, &lRemainExtra);
    if (pCtl->bit_mask & sequenceNumber_present)
        Asn1X509GetHugeInteger(&pCtl->sequenceNumber, dwFlags,
                &pInfo->SequenceNumber, &pbExtra, &lRemainExtra);
    Asn1X509GetAlgorithm(&pCtl->subjectAlgorithm, dwFlags,
            &pInfo->SubjectAlgorithm, &pbExtra, &lRemainExtra);
    if (pCtl->bit_mask & trustedSubjects_present)
        Asn1X509GetCtlEntries(&pCtl->trustedSubjects, dwFlags,
            &pInfo->cCTLEntry, &pInfo->rgCTLEntry, &pbExtra, &lRemainExtra);
    if (pCtl->bit_mask & ctlExtensions_present)
        Asn1X509GetExtensions(&pCtl->ctlExtensions, dwFlags,
            &pInfo->cExtension, &pInfo->rgExtension, &pbExtra, &lRemainExtra);

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(DecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1X509CtlInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CertificateTrustList_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509CtlInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


BOOL WINAPI Asn1X509PKIXUserNoticeEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_POLICY_QUALIFIER_USER_NOTICE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    UserNotice Asn1Info;

    memset (&Asn1Info, 0, sizeof(Asn1Info));

    if (pInfo->pNoticeReference != NULL)
    {
        Asn1Info.bit_mask |= noticeRef_present;
        Asn1Info.noticeRef.organization = pInfo->pNoticeReference->pszOrganization;
        Asn1Info.noticeRef.noticeNumbers.count = pInfo->pNoticeReference->cNoticeNumbers;
#ifdef OSS_CRYPT_ASN1
        Asn1Info.noticeRef.noticeNumbers.value = pInfo->pNoticeReference->rgNoticeNumbers;
#else
        Asn1Info.noticeRef.noticeNumbers.value = (ASN1int32_t *) pInfo->pNoticeReference->rgNoticeNumbers;
#endif  // OSS_CRYPT_ASN1
    }

    if (pInfo->pszDisplayText)
    {
        Asn1Info.bit_mask |= explicitText_present;
        Asn1Info.explicitText.choice = theBMPString_chosen;
        Asn1Info.explicitText.u.theBMPString.length = wcslen(pInfo->pszDisplayText);
        Asn1Info.explicitText.u.theBMPString.value = (unsigned short *) pInfo->pszDisplayText;
    }
    
    fResult = Asn1InfoEncodeEx(
            UserNotice_PDU,
            &Asn1Info,
            dwFlags,
            pEncodePara,
            pvEncoded,
            pcbEncoded
            );
    
    return fResult;
}

BOOL WINAPI Asn1X509PKIXUserNoticeDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    UserNotice *pAsn1UserNotice = (UserNotice *) pvAsn1Info;
    PCERT_POLICY_QUALIFIER_USER_NOTICE pInfo =
        (PCERT_POLICY_QUALIFIER_USER_NOTICE) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_POLICY_QUALIFIER_USER_NOTICE);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CERT_POLICY_QUALIFIER_USER_NOTICE));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_POLICY_QUALIFIER_USER_NOTICE);
    }

    // check to see if there is a notice reference
    if (pAsn1UserNotice->bit_mask & noticeRef_present)
    {
        lRemainExtra -= sizeof(CERT_POLICY_QUALIFIER_NOTICE_REFERENCE);
        if (lRemainExtra >= 0)
        {
            pInfo->pNoticeReference = (PCERT_POLICY_QUALIFIER_NOTICE_REFERENCE) pbExtra;
            memset(pInfo->pNoticeReference, 0, sizeof(CERT_POLICY_QUALIFIER_NOTICE_REFERENCE));
            pbExtra += sizeof(CERT_POLICY_QUALIFIER_NOTICE_REFERENCE);
        }

        lRemainExtra -= INFO_LEN_ALIGN(strlen(pAsn1UserNotice->noticeRef.organization)+1);
        if (lRemainExtra >= 0)
        {
            pInfo->pNoticeReference->pszOrganization = (LPSTR) pbExtra;
            strcpy(pInfo->pNoticeReference->pszOrganization, pAsn1UserNotice->noticeRef.organization);
            pbExtra += INFO_LEN_ALIGN(strlen(pAsn1UserNotice->noticeRef.organization)+1);
        }

        lRemainExtra -= pAsn1UserNotice->noticeRef.noticeNumbers.count * sizeof(int);
        if (lRemainExtra >= 0)
        {   
            pInfo->pNoticeReference->cNoticeNumbers = pAsn1UserNotice->noticeRef.noticeNumbers.count;
            pInfo->pNoticeReference->rgNoticeNumbers = (int *) pbExtra;
            memcpy(
                pInfo->pNoticeReference->rgNoticeNumbers, 
                pAsn1UserNotice->noticeRef.noticeNumbers.value, 
                pAsn1UserNotice->noticeRef.noticeNumbers.count * sizeof(int));
            pbExtra += pAsn1UserNotice->noticeRef.noticeNumbers.count * sizeof(int);
        }
    }
    else if (lRemainExtra >= 0)
    {
        pInfo->pNoticeReference = NULL;
    }

    // check to see if there is a notice reference
    if (pAsn1UserNotice->bit_mask & explicitText_present)
    {
        // check whether it is a visible or bmp string
        if (pAsn1UserNotice->explicitText.choice & theVisibleString_chosen)
        {
            lRemainExtra -= (strlen(pAsn1UserNotice->explicitText.u.theVisibleString)+1) * sizeof(WCHAR);
            if (lRemainExtra >= 0)
            {
                pInfo->pszDisplayText = (LPWSTR) pbExtra;
                MultiByteToWideChar(
                    CP_ACP, 
                    0, 
                    pAsn1UserNotice->explicitText.u.theVisibleString,
                    -1,
                    pInfo->pszDisplayText,
                    (strlen(pAsn1UserNotice->explicitText.u.theVisibleString)+1) * sizeof(WCHAR));
                pbExtra += (strlen(pAsn1UserNotice->explicitText.u.theVisibleString)+1) * sizeof(WCHAR);
            }
        }
        else if (pAsn1UserNotice->explicitText.choice & theBMPString_chosen)
        {
            lRemainExtra -= (pAsn1UserNotice->explicitText.u.theBMPString.length + 1) * sizeof(WCHAR);
            if (lRemainExtra >= 0)
            {
                pInfo->pszDisplayText = (LPWSTR) pbExtra;
                memcpy(
                    (void *)pInfo->pszDisplayText, 
                    pAsn1UserNotice->explicitText.u.theBMPString.value,
                    pAsn1UserNotice->explicitText.u.theBMPString.length * sizeof(WCHAR));
                pInfo->pszDisplayText[pAsn1UserNotice->explicitText.u.theBMPString.length] = 0;
                pbExtra += (pAsn1UserNotice->explicitText.u.theBMPString.length + 1) * sizeof(WCHAR);
            }
        }
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509PKIXUserNoticeDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        UserNotice_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509PKIXUserNoticeDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  Encode Attributes (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AttributesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ATTRIBUTES pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    Attributes Asn1Info;

    if (!Asn1X509SetAttributes(pInfo->cAttr, pInfo->rgAttr,
            &Asn1Info))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        Attributes_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeAttributes(&Asn1Info);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode Attributes (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AttributesDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    Attributes *pAsn1Info = (Attributes *) pvAsn1Info;
    PCRYPT_ATTRIBUTES pInfo = (PCRYPT_ATTRIBUTES) pvStructInfo;
    BYTE *pbExtra;
    LONG lRemainExtra = *plRemainExtra;

    lRemainExtra -= sizeof(CRYPT_ATTRIBUTES);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_ATTRIBUTES);
    }

    Asn1X509GetAttributes(pAsn1Info, dwFlags,
            &pInfo->cAttr, &pInfo->rgAttr, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509AttributesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        Attributes_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509AttributesDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Decode Enrollment Name Value Pair Authenticated Attributes in RA PKCS7s
//--------------------------------------------------------------------------

BOOL WINAPI Asn1NameValueDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    EnrollmentNameValuePair *pAsn1Info = (EnrollmentNameValuePair *) pvAsn1Info;
    PCRYPT_ENROLLMENT_NAME_VALUE_PAIR pNameValuePair = (PCRYPT_ENROLLMENT_NAME_VALUE_PAIR) pvStructInfo;
    BYTE *pbExtra;
    LONG lRemainExtra = *plRemainExtra;
    LONG lAlignExtra;

    lRemainExtra -= sizeof(CRYPT_ENROLLMENT_NAME_VALUE_PAIR);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        pbExtra = (BYTE *) pNameValuePair + sizeof(CRYPT_ENROLLMENT_NAME_VALUE_PAIR);
    }

    lAlignExtra = INFO_LEN_ALIGN(sizeof(CRYPT_ENROLLMENT_NAME_VALUE_PAIR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pbExtra += lAlignExtra;
    }

    PkiAsn1GetBMPString(
        pAsn1Info->name.length,
        pAsn1Info->name.value,
        0,
        &pNameValuePair->pwszName,
        &pbExtra,
        &lRemainExtra
        );
        
    PkiAsn1GetBMPString(
        pAsn1Info->value.length,
        pAsn1Info->value.value,
        0,
        &pNameValuePair->pwszValue,
        &pbExtra,
        &lRemainExtra
        );

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1NameValueDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        EnrollmentNameValuePair_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1NameValueDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Encode Name Value Pair Authenticated Attributes in RA PKCS7s
//--------------------------------------------------------------------------
BOOL WINAPI Asn1NameValueEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ENROLLMENT_NAME_VALUE_PAIR pNameValue,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    EnrollmentNameValuePair NameValue;

    NameValue.name.length = wcslen(pNameValue->pwszName);
    NameValue.name.value  = pNameValue->pwszName;
    
    NameValue.value.length = wcslen(pNameValue->pwszValue);
    NameValue.value.value  = pNameValue->pwszValue;
    
    fResult = Asn1InfoEncodeEx(
        EnrollmentNameValuePair_PDU,
        &NameValue,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
        
    if (!fResult && (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)) {
        *((void **) pvEncoded) = NULL;
        *pcbEncoded = 0;
    }

    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode CSP Provider Attribute
//--------------------------------------------------------------------------

BOOL WINAPI Asn1CSPProviderDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    CSPProvider *pAsn1Info = (CSPProvider *) pvAsn1Info;
    PCRYPT_CSP_PROVIDER pCSPProvider = (PCRYPT_CSP_PROVIDER) pvStructInfo;
    BYTE *pbExtra;
    LONG lRemainExtra = *plRemainExtra;
    LONG lAlignExtra;

    lRemainExtra -= sizeof(CRYPT_CSP_PROVIDER);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        pbExtra = (BYTE *) pCSPProvider + sizeof(CRYPT_CSP_PROVIDER);
    }

    lAlignExtra = INFO_LEN_ALIGN(sizeof(CRYPT_CSP_PROVIDER));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pbExtra += lAlignExtra;
    }

    pCSPProvider->dwKeySpec = (DWORD) pAsn1Info->keySpec;
    
    PkiAsn1GetBMPString(
        pAsn1Info->cspName.length,
        pAsn1Info->cspName.value,
        0,
        &pCSPProvider->pwszProviderName,
        &pbExtra,
        &lRemainExtra
        );

    Asn1X509GetBit(
            &pAsn1Info->signature,
            dwFlags,
            &pCSPProvider->Signature,
            &pbExtra,
            &lRemainExtra
            );
            
    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1CSPProviderDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CSPProvider_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1CSPProviderDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Encode CSP Provider Attribute
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CSPProviderEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_CSP_PROVIDER pCSPProvider,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CSPProvider CspProvider;

    CspProvider.keySpec = (int) pCSPProvider->dwKeySpec;
    CspProvider.cspName.length = wcslen(pCSPProvider->pwszProviderName);
    CspProvider.cspName.value  = pCSPProvider->pwszProviderName;
    
     Asn1X509SetBit(
        &pCSPProvider->Signature,
        &CspProvider.signature
        );

    fResult = Asn1InfoEncodeEx(
        CSPProvider_PDU,
        &CspProvider,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    if (!fResult && (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)) {
        *((void **) pvEncoded) = NULL;
        *pcbEncoded = 0;
    }

    return fResult;
}


//+-------------------------------------------------------------------------
//  Certificate Pair Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CertPairEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_PAIR pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    CertificatePair Asn1CertificatePair;
    memset(&Asn1CertificatePair, 0, sizeof(Asn1CertificatePair));

    if (pInfo->Forward.cbData) {
        Asn1X509SetAny(&pInfo->Forward, &Asn1CertificatePair.forward);
        Asn1CertificatePair.bit_mask |= forward_present;
    }

    if (pInfo->Reverse.cbData) {
        Asn1X509SetAny(&pInfo->Reverse, &Asn1CertificatePair.reverse);
        Asn1CertificatePair.bit_mask |= reverse_present;
    }

    return Asn1InfoEncodeEx(
        CertificatePair_PDU,
        &Asn1CertificatePair,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Certificate Pair Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CertPairDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    CertificatePair *pCertificatePair = (CertificatePair *) pvAsn1Info;
    PCERT_PAIR pInfo =
        (PCERT_PAIR) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_PAIR);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_PAIR));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_PAIR);
    }

    if (pCertificatePair->bit_mask & forward_present)
        Asn1X509GetAny(&pCertificatePair->forward, dwFlags,
            &pInfo->Forward, &pbExtra, &lRemainExtra);
    if (pCertificatePair->bit_mask & reverse_present)
        Asn1X509GetAny(&pCertificatePair->reverse, dwFlags,
            &pInfo->Reverse, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509CertPairDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CertificatePair_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509CertPairDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Set/Free/Get NameConstraints Subtree
//--------------------------------------------------------------------------
BOOL Asn1X509SetNameConstraintsSubtree(
        IN DWORD cSubtree,
        IN PCERT_GENERAL_SUBTREE pSubtree,
        IN OUT GeneralSubtrees *pAsn1,
        OUT DWORD *pdwErrLocation
        )
{
    BOOL fResult;
    DWORD i;
    GeneralSubtree *pAsn1Subtree;

    *pdwErrLocation = 0;

    assert(0 != cSubtree);
    if (NULL == (pAsn1Subtree = (GeneralSubtree *) PkiZeroAlloc(
            cSubtree * sizeof(GeneralSubtree))))
        goto ErrorReturn;

    pAsn1->count = cSubtree;
    pAsn1->value = pAsn1Subtree;

    for (i = 0; i < cSubtree; i++, pSubtree++, pAsn1Subtree++) {
        if (!Asn1X509SetAltNameEntry(&pSubtree->Base,
                &pAsn1Subtree->base,
                i,
                pdwErrLocation))
            goto ErrorReturn;
        if (0 < pSubtree->dwMinimum) {
            pAsn1Subtree->minimum = pSubtree->dwMinimum;
            pAsn1Subtree->bit_mask |= minimum_present;
        }

        if (pSubtree->fMaximum) {
            pAsn1Subtree->maximum = pSubtree->dwMaximum;
            pAsn1Subtree->bit_mask |= maximum_present;
        }
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

void Asn1X509FreeNameConstraintsSubtree(
        IN OUT GeneralSubtrees *pAsn1
        )
{
    DWORD cSubtree = pAsn1->count;
    GeneralSubtree *pAsn1Subtree = pAsn1->value;

    for ( ; cSubtree > 0; cSubtree--, pAsn1Subtree++)
        Asn1X509FreeAltNameEntry(&pAsn1Subtree->base);

    PkiFree(pAsn1->value);
}

BOOL Asn1X509GetNameConstraintsSubtree(
        IN GeneralSubtrees *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcSubtree,
        IN OUT PCERT_GENERAL_SUBTREE *ppSubtree,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    BYTE *pbExtra = *ppbExtra;
    LONG lRemainExtra = *plRemainExtra;
    LONG lAlignExtra;

    DWORD cSubtree;
    GeneralSubtree *pAsn1Subtree;
    PCERT_GENERAL_SUBTREE pSubtree;

    cSubtree = pAsn1->count;
    if (0 == cSubtree)
        goto SuccessReturn;

    pAsn1Subtree = pAsn1->value;

    lAlignExtra = INFO_LEN_ALIGN(cSubtree * sizeof(CERT_GENERAL_SUBTREE));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra < 0) {
        pSubtree = NULL;
    } else {
        pSubtree = (PCERT_GENERAL_SUBTREE) pbExtra;
        memset(pSubtree, 0, lAlignExtra);
        *pcSubtree = cSubtree;
        *ppSubtree = pSubtree;
        pbExtra += lAlignExtra;
    }

    // Subtree Array entries
    for (; cSubtree > 0; cSubtree--, pSubtree++, pAsn1Subtree++) {
        if (!Asn1X509GetAltNameEntry(&pAsn1Subtree->base, dwFlags,
                &pSubtree->Base, &pbExtra, &lRemainExtra))
            goto ErrorReturn;
        if (lRemainExtra >= 0) {
            if (pAsn1Subtree->bit_mask & minimum_present) 
                pSubtree->dwMinimum = pAsn1Subtree->minimum;
            if (pAsn1Subtree->bit_mask & maximum_present) {
                pSubtree->fMaximum = TRUE;
                pSubtree->dwMaximum = pAsn1Subtree->maximum;
            }
        }
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    *ppbExtra = pbExtra;
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Name Constraints Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509NameConstraintsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_CONSTRAINTS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    NameConstraints Asn1Info;
    DWORD cSubtree;
    DWORD dwErrLocation;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;

    memset(&Asn1Info, 0, sizeof(Asn1Info));

    cSubtree = pInfo->cPermittedSubtree;
    if (0 < cSubtree) {
        if (!Asn1X509SetNameConstraintsSubtree(
                cSubtree,
                pInfo->rgPermittedSubtree,
                &Asn1Info.permittedSubtrees,
                &dwErrLocation))
            goto SubtreeError;
        Asn1Info.bit_mask |= permittedSubtrees_present;
    }

    cSubtree = pInfo->cExcludedSubtree;
    if (0 < cSubtree) {
        if (!Asn1X509SetNameConstraintsSubtree(
                cSubtree,
                pInfo->rgExcludedSubtree,
                &Asn1Info.excludedSubtrees,
                &dwErrLocation)) {
            if (0 != dwErrLocation)
                dwErrLocation |= CERT_EXCLUDED_SUBTREE_BIT;
            goto SubtreeError;
        }
        Asn1Info.bit_mask |= excludedSubtrees_present;
    }

    fResult = Asn1InfoEncodeEx(
        NameConstraints_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    Asn1X509FreeNameConstraintsSubtree(&Asn1Info.permittedSubtrees);
    Asn1X509FreeNameConstraintsSubtree(&Asn1Info.excludedSubtrees);
    return fResult;

SubtreeError:
    *pcbEncoded = dwErrLocation;
    fResult = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Name Constraints Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509NameConstraintsDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    NameConstraints *pAsn1 = (NameConstraints *) pvAsn1Info;
    PCERT_NAME_CONSTRAINTS_INFO pInfo =
        (PCERT_NAME_CONSTRAINTS_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_NAME_CONSTRAINTS_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CERT_NAME_CONSTRAINTS_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_NAME_CONSTRAINTS_INFO);
    }

    if (pAsn1->bit_mask & permittedSubtrees_present) {
        if (!Asn1X509GetNameConstraintsSubtree(
                &pAsn1->permittedSubtrees,
                dwFlags,
                &pInfo->cPermittedSubtree,
                &pInfo->rgPermittedSubtree,
                &pbExtra,
                &lRemainExtra
                )) goto ErrorReturn;
    }

    if (pAsn1->bit_mask & excludedSubtrees_present) {
        if (!Asn1X509GetNameConstraintsSubtree(
                &pAsn1->excludedSubtrees,
                dwFlags,
                &pInfo->cExcludedSubtree,
                &pInfo->rgExcludedSubtree,
                &pbExtra,
                &lRemainExtra
                )) goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}



BOOL WINAPI Asn1X509NameConstraintsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        NameConstraints_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509NameConstraintsDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  CRL Issuing Distribution Point Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CrlIssuingDistPointEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRL_ISSUING_DIST_POINT pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    IssuingDistributionPoint Asn1Info;
    DistributionPointName *pAsn1DistPointName;
    PCRL_DIST_POINT_NAME pDistPointName;
    DWORD dwErrLocation;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;

    memset(&Asn1Info, 0, sizeof(Asn1Info));

    pDistPointName = &pInfo->DistPointName;
    if (CRL_DIST_POINT_NO_NAME !=
            pDistPointName->dwDistPointNameChoice) {
        pAsn1DistPointName = &Asn1Info.issuingDistributionPoint;

        Asn1Info.bit_mask |= issuingDistributionPoint_present;
        pAsn1DistPointName->choice = (unsigned short)
            pDistPointName->dwDistPointNameChoice;
        
        assert(fullName_chosen == CRL_DIST_POINT_FULL_NAME);
        assert(nameRelativeToCRLIssuer_chosen ==
            CRL_DIST_POINT_ISSUER_RDN_NAME);

        switch (pDistPointName->dwDistPointNameChoice) {
            case CRL_DIST_POINT_FULL_NAME:
                if (!Asn1X509SetAltNames(
                        &pDistPointName->FullName,
                        &pAsn1DistPointName->u.fullName, 0, &dwErrLocation))
                    goto AltNamesError;
                break;
            case CRL_DIST_POINT_ISSUER_RDN_NAME:
            default:
                goto InvalidArg;
        }
    }

    if (pInfo->fOnlyContainsUserCerts) {
        Asn1Info.bit_mask |= onlyContainsUserCerts_present;
        Asn1Info.onlyContainsUserCerts = TRUE;
    }
    if (pInfo->fOnlyContainsCACerts) {
        Asn1Info.bit_mask |= onlyContainsCACerts_present;
        Asn1Info.onlyContainsCACerts = TRUE;
    }
    if (pInfo->fIndirectCRL) {
        Asn1Info.bit_mask |= indirectCRL_present;
        Asn1Info.indirectCRL = TRUE;
    }

    if (pInfo->OnlySomeReasonFlags.cbData) {
        Asn1Info.bit_mask |= onlySomeReasons_present;
        Asn1X509SetBitWithoutTrailingZeroes(&pInfo->OnlySomeReasonFlags,
            &Asn1Info.onlySomeReasons);
    }

    fResult = Asn1InfoEncodeEx(
        IssuingDistributionPoint_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    pAsn1DistPointName = &Asn1Info.issuingDistributionPoint;
    switch (pAsn1DistPointName->choice) {
        case CRL_DIST_POINT_FULL_NAME:
            Asn1X509FreeAltNames(&pAsn1DistPointName->u.fullName);
            break;
        case CRL_DIST_POINT_ISSUER_RDN_NAME:
        default:
            break;
    }
    return fResult;

AltNamesError:
    *pcbEncoded = dwErrLocation;
    goto ErrorReturn;

InvalidArg:
    SetLastError((DWORD) E_INVALIDARG);
    *pcbEncoded = 0;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  CRL Issuing Distribution Point Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CrlIssuingDistPointDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    IssuingDistributionPoint *pAsn1 = (IssuingDistributionPoint *) pvAsn1Info;
    PCRL_ISSUING_DIST_POINT pInfo = (PCRL_ISSUING_DIST_POINT) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRL_ISSUING_DIST_POINT);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CRL_ISSUING_DIST_POINT));
        pbExtra = (BYTE *) pInfo + sizeof(CRL_ISSUING_DIST_POINT);

        if (pAsn1->bit_mask & onlyContainsUserCerts_present)
            pInfo->fOnlyContainsUserCerts =
                (BOOL) pAsn1->onlyContainsUserCerts;
        if (pAsn1->bit_mask & onlyContainsCACerts_present)
            pInfo->fOnlyContainsCACerts = (BOOL) pAsn1->onlyContainsCACerts;
        if (pAsn1->bit_mask & indirectCRL_present)
            pInfo->fIndirectCRL = (BOOL) pAsn1->indirectCRL;
    }

    if (pAsn1->bit_mask & issuingDistributionPoint_present) {
        DistributionPointName *pAsn1DistPointName =
            &pAsn1->issuingDistributionPoint;
        DWORD dwDistPointNameChoice = pAsn1DistPointName->choice;
        PCRL_DIST_POINT_NAME pDistPointName;

        if (lRemainExtra >= 0) {
            pDistPointName = &pInfo->DistPointName;
            pDistPointName->dwDistPointNameChoice =
                dwDistPointNameChoice;
        } else
            pDistPointName = NULL;

        assert(fullName_chosen == CRL_DIST_POINT_FULL_NAME);
        assert(nameRelativeToCRLIssuer_chosen ==
            CRL_DIST_POINT_ISSUER_RDN_NAME);

        switch (dwDistPointNameChoice) {
            case CRL_DIST_POINT_FULL_NAME:
                if (!Asn1X509GetAltNames(&pAsn1DistPointName->u.fullName,
                        dwFlags, &pDistPointName->FullName,
                        &pbExtra, &lRemainExtra))
                    goto ErrorReturn;
                break;
            case CRL_DIST_POINT_ISSUER_RDN_NAME:
                break;
            default:
                SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
                goto ErrorReturn;
        }
    }

    if (pAsn1->bit_mask & onlySomeReasons_present)
        Asn1X509GetBit(&pAsn1->onlySomeReasons, dwFlags,
                &pInfo->OnlySomeReasonFlags, &pbExtra, &lRemainExtra);

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

BOOL WINAPI Asn1X509CrlIssuingDistPointDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        IssuingDistributionPoint_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509CrlIssuingDistPointDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Policy Mappings Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509PolicyMappingsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_POLICY_MAPPINGS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    PolicyMappings Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (0 != pInfo->cPolicyMapping) {
        DWORD cMap = pInfo->cPolicyMapping;
        PCERT_POLICY_MAPPING pMap = pInfo->rgPolicyMapping;
        PolicyMapping *pAsn1Map;
        
        if (NULL == (pAsn1Map = (PolicyMapping *) PkiZeroAlloc(
                cMap * sizeof(PolicyMapping))))
            goto ErrorReturn;

        Asn1Info.count = cMap;
        Asn1Info.value = pAsn1Map;
        for ( ; cMap > 0; cMap--, pMap++, pAsn1Map++) {
            if (!Asn1X509SetEncodedObjId(pMap->pszIssuerDomainPolicy,
                    &pAsn1Map->issuerDomainPolicy))
                goto ErrorReturn;
            if (!Asn1X509SetEncodedObjId(pMap->pszSubjectDomainPolicy,
                    &pAsn1Map->subjectDomainPolicy))
                goto ErrorReturn;
        }
    }

    fResult = Asn1InfoEncodeEx(
        PolicyMappings_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    PkiFree(Asn1Info.value);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Policy Mappings Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509PolicyMappingsDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    PolicyMappings *pAsn1Info = (PolicyMappings *) pvAsn1Info;
    PCERT_POLICY_MAPPINGS_INFO pInfo =
        (PCERT_POLICY_MAPPINGS_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;
    LONG lAlignExtra;
    DWORD cMap;
    PolicyMapping *pAsn1Map;
    PCERT_POLICY_MAPPING pMap;

    cMap = pAsn1Info->count;
    lAlignExtra = cMap * sizeof(CERT_POLICY_MAPPING);

    lRemainExtra -= sizeof(CERT_POLICY_MAPPINGS_INFO) + lAlignExtra;
    if (lRemainExtra < 0) {
        pbExtra = NULL;
        pMap = NULL;
    } else {
        pbExtra = (BYTE *) pInfo + sizeof(CERT_POLICY_MAPPINGS_INFO);
        pMap = (PCERT_POLICY_MAPPING) pbExtra;
        pInfo->cPolicyMapping = cMap;
        pInfo->rgPolicyMapping = pMap;
        if (lAlignExtra) {
            memset(pbExtra, 0, lAlignExtra);
            pbExtra += lAlignExtra;
        }
    }

    pAsn1Map = pAsn1Info->value;
    for ( ; cMap > 0; cMap--, pAsn1Map++, pMap++) {
        Asn1X509GetEncodedObjId(&pAsn1Map->issuerDomainPolicy, dwFlags,
            &pMap->pszIssuerDomainPolicy, &pbExtra, &lRemainExtra);
        Asn1X509GetEncodedObjId(&pAsn1Map->subjectDomainPolicy, dwFlags,
            &pMap->pszSubjectDomainPolicy, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509PolicyMappingsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        PolicyMappings_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509PolicyMappingsDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Policy Constraints Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509PolicyConstraintsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_POLICY_CONSTRAINTS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    PolicyConstraints Asn1Info;
    memset(&Asn1Info, 0, sizeof(Asn1Info));

    if (pInfo->fRequireExplicitPolicy) {
        Asn1Info.requireExplicitPolicy =
            pInfo->dwRequireExplicitPolicySkipCerts;
        Asn1Info.bit_mask |= requireExplicitPolicy_present;
    }

    if (pInfo->fInhibitPolicyMapping) {
        Asn1Info.inhibitPolicyMapping =
            pInfo->dwInhibitPolicyMappingSkipCerts;
        Asn1Info.bit_mask |= inhibitPolicyMapping_present;
    }

    return Asn1InfoEncodeEx(
        PolicyConstraints_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Policy Constraints  Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509PolicyConstraintsDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    PolicyConstraints *pAsn1Info = (PolicyConstraints *) pvAsn1Info;
    PCERT_POLICY_CONSTRAINTS_INFO pInfo =
        (PCERT_POLICY_CONSTRAINTS_INFO) pvStructInfo;

    *plRemainExtra -= sizeof(CERT_POLICY_CONSTRAINTS_INFO);
    if (*plRemainExtra >= 0) {
        memset(pInfo, 0, sizeof(CERT_POLICY_CONSTRAINTS_INFO));

        if (pAsn1Info->bit_mask & requireExplicitPolicy_present) {
            pInfo->fRequireExplicitPolicy = TRUE;
            pInfo->dwRequireExplicitPolicySkipCerts =
                pAsn1Info->requireExplicitPolicy;
        }

        if (pAsn1Info->bit_mask & inhibitPolicyMapping_present) {
            pInfo->fInhibitPolicyMapping = TRUE;
            pInfo->dwInhibitPolicyMappingSkipCerts =
                pAsn1Info->inhibitPolicyMapping;
        }
    }
    return TRUE;
}

BOOL WINAPI Asn1X509PolicyConstraintsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        PolicyConstraints_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509PolicyConstraintsDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Cross Cert Distribution Points Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CrossCertDistPointsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCROSS_CERT_DIST_POINTS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CrossCertDistPoints Asn1Info;
    GeneralNames *pAsn1DistPoint;
    PCERT_ALT_NAME_INFO pDistPoint;
    DWORD cDistPoint;
    DWORD i;
    DWORD dwErrLocation;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (pInfo->dwSyncDeltaTime) {
        Asn1Info.syncDeltaTime = pInfo->dwSyncDeltaTime;
        Asn1Info.bit_mask |= syncDeltaTime_present;
    }

    cDistPoint = pInfo->cDistPoint;
    if (0 < cDistPoint) {
        if (NULL == (pAsn1DistPoint = (GeneralNames *) PkiZeroAlloc(
                cDistPoint * sizeof(GeneralNames))))
            goto ErrorReturn;
        Asn1Info.crossCertDistPointNames.count = cDistPoint;
        Asn1Info.crossCertDistPointNames.value = pAsn1DistPoint;

        pDistPoint = pInfo->rgDistPoint;
        for (i = 0; i < cDistPoint; i++, pDistPoint++, pAsn1DistPoint++) {
            if (!Asn1X509SetAltNames(
                    pDistPoint,
                    pAsn1DistPoint,
                    i,
                    &dwErrLocation))
                goto AltNamesError;
        }
    }

    fResult = Asn1InfoEncodeEx(
        CrossCertDistPoints_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    pAsn1DistPoint = Asn1Info.crossCertDistPointNames.value;
    if (pAsn1DistPoint) {
        cDistPoint = Asn1Info.crossCertDistPointNames.count;
        for ( ; cDistPoint > 0; cDistPoint--, pAsn1DistPoint++) {
            Asn1X509FreeAltNames(pAsn1DistPoint);
        }
        PkiFree(Asn1Info.crossCertDistPointNames.value);
    }
    return fResult;

AltNamesError:
    *pcbEncoded = dwErrLocation;
    fResult = FALSE;
    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Cross Cert Distribution Points Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CrossCertDistPointsDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CrossCertDistPoints *pAsn1 = (CrossCertDistPoints *) pvAsn1Info;
    PCROSS_CERT_DIST_POINTS_INFO pInfo =
        (PCROSS_CERT_DIST_POINTS_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;
    LONG lAlignExtra;

    lRemainExtra -= sizeof(CROSS_CERT_DIST_POINTS_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CROSS_CERT_DIST_POINTS_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CROSS_CERT_DIST_POINTS_INFO);

        if (pAsn1->bit_mask & syncDeltaTime_present)
            pInfo->dwSyncDeltaTime = pAsn1->syncDeltaTime;
    }

    if (pAsn1->crossCertDistPointNames.count) {
        DWORD cDistPoint = pAsn1->crossCertDistPointNames.count;
        GeneralNames *pAsn1DistPoint = pAsn1->crossCertDistPointNames.value;
        PCERT_ALT_NAME_INFO pDistPoint;

        lAlignExtra = INFO_LEN_ALIGN(cDistPoint * sizeof(CERT_ALT_NAME_INFO));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pDistPoint = (PCERT_ALT_NAME_INFO) pbExtra;
            memset(pDistPoint, 0, cDistPoint * sizeof(CERT_ALT_NAME_INFO));
            pInfo->cDistPoint = cDistPoint;
            pInfo->rgDistPoint = pDistPoint;
            pbExtra += lAlignExtra;
        } else
            pDistPoint = NULL;

        for ( ; cDistPoint > 0; cDistPoint--, pAsn1DistPoint++, pDistPoint++) {
            if (!Asn1X509GetAltNames(pAsn1DistPoint, dwFlags, pDistPoint,
                    &pbExtra, &lRemainExtra))
                goto ErrorReturn;
        }
    }

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

BOOL WINAPI Asn1X509CrossCertDistPointsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CrossCertDistPoints_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509CrossCertDistPointsDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+=========================================================================
//  Certificate Management Messages over CMS (CMC) Encode/Decode Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Set/Free/Get CMC Tagged Attributes
//--------------------------------------------------------------------------
BOOL Asn1CmcSetTaggedAttributes(
        IN DWORD cTaggedAttr,
        IN PCMC_TAGGED_ATTRIBUTE pTaggedAttr,
        OUT ControlSequence *pAsn1
        )
{
    TaggedAttribute *pAsn1Attr;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cTaggedAttr == 0)
        return TRUE;

    pAsn1Attr = (TaggedAttribute *) PkiZeroAlloc(
        cTaggedAttr * sizeof(TaggedAttribute));
    if (pAsn1Attr == NULL)
        return FALSE;
    pAsn1->value = pAsn1Attr;
    pAsn1->count = cTaggedAttr;

    for ( ; cTaggedAttr > 0; cTaggedAttr--, pTaggedAttr++, pAsn1Attr++) {
        pAsn1Attr->bodyPartID = pTaggedAttr->dwBodyPartID;
        if (!Asn1X509SetEncodedObjId(pTaggedAttr->Attribute.pszObjId,
                &pAsn1Attr->type))
            return FALSE;

        if (!Asn1X509SetSeqOfAny(
                pTaggedAttr->Attribute.cValue,
                pTaggedAttr->Attribute.rgValue,
                &pAsn1Attr->values.count,
                &pAsn1Attr->values.value))
            return FALSE;
    }
    return TRUE;
}

void Asn1CmcFreeTaggedAttributes(
        IN OUT ControlSequence *pAsn1
        )
{
    if (pAsn1->value) {
        TaggedAttribute *pAsn1Attr = pAsn1->value;
        DWORD cTaggedAttr = pAsn1->count;

        for ( ; cTaggedAttr > 0; cTaggedAttr--, pAsn1Attr++) {
            Asn1X509FreeSeqOfAny(pAsn1Attr->values.value);
        }
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

void Asn1CmcGetTaggedAttributes(
        IN ControlSequence *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcTaggedAttr,
        OUT PCMC_TAGGED_ATTRIBUTE *ppTaggedAttr,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cTaggedAttr;
    TaggedAttribute *pAsn1Attr;
    PCMC_TAGGED_ATTRIBUTE pTaggedAttr;

    cTaggedAttr = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cTaggedAttr * sizeof(CMC_TAGGED_ATTRIBUTE));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcTaggedAttr = cTaggedAttr;
        pTaggedAttr = (PCMC_TAGGED_ATTRIBUTE) pbExtra;
        *ppTaggedAttr = pTaggedAttr;
        pbExtra += lAlignExtra;
    } else
        pTaggedAttr = NULL;

    pAsn1Attr = pAsn1->value;
    for ( ; cTaggedAttr > 0; cTaggedAttr--, pAsn1Attr++, pTaggedAttr++) {
        if (lRemainExtra >= 0) {
            pTaggedAttr->dwBodyPartID = pAsn1Attr->bodyPartID;
        }
        Asn1X509GetEncodedObjId(&pAsn1Attr->type, dwFlags,
            &pTaggedAttr->Attribute.pszObjId, &pbExtra, &lRemainExtra);
        Asn1X509GetSeqOfAny(
            pAsn1Attr->values.count, pAsn1Attr->values.value, dwFlags,
            &pTaggedAttr->Attribute.cValue, &pTaggedAttr->Attribute.rgValue,
            &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CMC Tagged Requests
//--------------------------------------------------------------------------
BOOL Asn1CmcSetTaggedRequests(
        IN DWORD cTaggedReq,
        IN PCMC_TAGGED_REQUEST pTaggedReq,
        OUT ReqSequence *pAsn1
        )
{
    TaggedRequest *pAsn1Req;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cTaggedReq == 0)
        return TRUE;

    pAsn1Req = (TaggedRequest *) PkiZeroAlloc(
        cTaggedReq * sizeof(TaggedRequest));
    if (pAsn1Req == NULL)
        return FALSE;
    pAsn1->value = pAsn1Req;
    pAsn1->count = cTaggedReq;

    for ( ; cTaggedReq > 0; cTaggedReq--, pTaggedReq++, pAsn1Req++) {
        PCMC_TAGGED_CERT_REQUEST pTaggedCertReq;
        TaggedCertificationRequest *ptcr;

        if (CMC_TAGGED_CERT_REQUEST_CHOICE !=
                pTaggedReq->dwTaggedRequestChoice) {
            SetLastError((DWORD) E_INVALIDARG);
            return FALSE;
        }
        
        pAsn1Req->choice = tcr_chosen;
        ptcr = &pAsn1Req->u.tcr;
        pTaggedCertReq = pTaggedReq->pTaggedCertRequest;

        ptcr->bodyPartID = pTaggedCertReq->dwBodyPartID;
        Asn1X509SetAny(&pTaggedCertReq->SignedCertRequest,
            &ptcr->certificationRequest);
    }
    return TRUE;
}

void Asn1CmcFreeTaggedRequests(
        IN OUT ReqSequence *pAsn1
        )
{
    if (pAsn1->value) {
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

BOOL Asn1CmcGetTaggedRequests(
        IN ReqSequence *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcTaggedReq,
        OUT PCMC_TAGGED_REQUEST *ppTaggedReq,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cTaggedReq;
    TaggedRequest *pAsn1Req;
    PCMC_TAGGED_REQUEST pTaggedReq;

    cTaggedReq = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cTaggedReq * sizeof(CMC_TAGGED_REQUEST));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcTaggedReq = cTaggedReq;
        pTaggedReq = (PCMC_TAGGED_REQUEST) pbExtra;
        *ppTaggedReq = pTaggedReq;
        pbExtra += lAlignExtra;
    } else
        pTaggedReq = NULL;

    pAsn1Req = pAsn1->value;
    for ( ; cTaggedReq > 0; cTaggedReq--, pAsn1Req++, pTaggedReq++) {
        PCMC_TAGGED_CERT_REQUEST pTaggedCertReq;
        TaggedCertificationRequest *ptcr;

        if (tcr_chosen != pAsn1Req->choice) {
            SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
            goto ErrorReturn;
        }

        ptcr = &pAsn1Req->u.tcr;

        lAlignExtra = INFO_LEN_ALIGN(sizeof(CMC_TAGGED_CERT_REQUEST));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pTaggedReq->dwTaggedRequestChoice =
                CMC_TAGGED_CERT_REQUEST_CHOICE;

            pTaggedCertReq = (PCMC_TAGGED_CERT_REQUEST) pbExtra;
            pbExtra += lAlignExtra;

            pTaggedReq->pTaggedCertRequest = pTaggedCertReq;
            pTaggedCertReq->dwBodyPartID = ptcr->bodyPartID;
        } else
            pTaggedCertReq = NULL;

        Asn1X509GetAny(&ptcr->certificationRequest, dwFlags,
            &pTaggedCertReq->SignedCertRequest, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CMC Tagged ContentInfo
//--------------------------------------------------------------------------
BOOL Asn1CmcSetTaggedContentInfos(
        IN DWORD cTaggedCI,
        IN PCMC_TAGGED_CONTENT_INFO pTaggedCI,
        OUT CmsSequence *pAsn1
        )
{
    TaggedContentInfo *pAsn1CI;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cTaggedCI == 0)
        return TRUE;

    pAsn1CI = (TaggedContentInfo *) PkiZeroAlloc(
        cTaggedCI * sizeof(TaggedContentInfo));
    if (pAsn1CI == NULL)
        return FALSE;
    pAsn1->value = pAsn1CI;
    pAsn1->count = cTaggedCI;

    for ( ; cTaggedCI > 0; cTaggedCI--, pTaggedCI++, pAsn1CI++) {
        pAsn1CI->bodyPartID = pTaggedCI->dwBodyPartID;
        Asn1X509SetAny(&pTaggedCI->EncodedContentInfo, &pAsn1CI->contentInfo);
    }

    return TRUE;
}

void Asn1CmcFreeTaggedContentInfos(
        IN OUT CmsSequence *pAsn1
        )
{
    if (pAsn1->value) {
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

void Asn1CmcGetTaggedContentInfos(
        IN CmsSequence *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcTaggedCI,
        OUT PCMC_TAGGED_CONTENT_INFO *ppTaggedCI,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cTaggedCI;
    TaggedContentInfo *pAsn1CI;
    PCMC_TAGGED_CONTENT_INFO pTaggedCI;

    cTaggedCI = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cTaggedCI * sizeof(CMC_TAGGED_CONTENT_INFO));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcTaggedCI = cTaggedCI;
        pTaggedCI = (PCMC_TAGGED_CONTENT_INFO) pbExtra;
        *ppTaggedCI = pTaggedCI;
        pbExtra += lAlignExtra;
    } else
        pTaggedCI = NULL;

    pAsn1CI = pAsn1->value;
    for ( ; cTaggedCI > 0; cTaggedCI--, pAsn1CI++, pTaggedCI++) {
        if (lRemainExtra >= 0) {
            pTaggedCI->dwBodyPartID = pAsn1CI->bodyPartID;
        }

        Asn1X509GetAny(&pAsn1CI->contentInfo, dwFlags,
            &pTaggedCI->EncodedContentInfo, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CMC Tagged OtherMsg
//--------------------------------------------------------------------------
BOOL Asn1CmcSetTaggedOtherMsgs(
        IN DWORD cTaggedOM,
        IN PCMC_TAGGED_OTHER_MSG pTaggedOM,
        OUT OtherMsgSequence *pAsn1
        )
{
    TaggedOtherMsg *pAsn1OM;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cTaggedOM == 0)
        return TRUE;

    pAsn1OM = (TaggedOtherMsg *) PkiZeroAlloc(
        cTaggedOM * sizeof(TaggedOtherMsg));
    if (pAsn1OM == NULL)
        return FALSE;
    pAsn1->value = pAsn1OM;
    pAsn1->count = cTaggedOM;

    for ( ; cTaggedOM > 0; cTaggedOM--, pTaggedOM++, pAsn1OM++) {
        pAsn1OM->bodyPartID = pTaggedOM->dwBodyPartID;

        if (!Asn1X509SetEncodedObjId(pTaggedOM->pszObjId,
                &pAsn1OM->otherMsgType))
            return FALSE;

        Asn1X509SetAny(&pTaggedOM->Value, &pAsn1OM->otherMsgValue);
    }

    return TRUE;
}

void Asn1CmcFreeTaggedOtherMsgs(
        IN OUT OtherMsgSequence *pAsn1
        )
{
    if (pAsn1->value) {
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

void Asn1CmcGetTaggedOtherMsgs(
        IN OtherMsgSequence *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcTaggedOM,
        OUT PCMC_TAGGED_OTHER_MSG *ppTaggedOM,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cTaggedOM;
    TaggedOtherMsg *pAsn1OM;
    PCMC_TAGGED_OTHER_MSG pTaggedOM;

    cTaggedOM = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cTaggedOM * sizeof(CMC_TAGGED_OTHER_MSG));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcTaggedOM = cTaggedOM;
        pTaggedOM = (PCMC_TAGGED_OTHER_MSG) pbExtra;
        *ppTaggedOM = pTaggedOM;
        pbExtra += lAlignExtra;
    } else
        pTaggedOM = NULL;

    pAsn1OM = pAsn1->value;
    for ( ; cTaggedOM > 0; cTaggedOM--, pAsn1OM++, pTaggedOM++) {
        if (lRemainExtra >= 0) {
            pTaggedOM->dwBodyPartID = pAsn1OM->bodyPartID;
        }

        Asn1X509GetEncodedObjId(&pAsn1OM->otherMsgType, dwFlags,
            &pTaggedOM->pszObjId, &pbExtra, &lRemainExtra);

        Asn1X509GetAny(&pAsn1OM->otherMsgValue, dwFlags,
            &pTaggedOM->Value, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  CMC Data Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcDataEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_DATA_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CmcData Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1CmcSetTaggedAttributes(pInfo->cTaggedAttribute,
            pInfo->rgTaggedAttribute, &Asn1Info.controlSequence))
        goto ErrorReturn;
    if (!Asn1CmcSetTaggedRequests(pInfo->cTaggedRequest,
            pInfo->rgTaggedRequest, &Asn1Info.reqSequence))
        goto ErrorReturn;
    if (!Asn1CmcSetTaggedContentInfos(pInfo->cTaggedContentInfo,
            pInfo->rgTaggedContentInfo, &Asn1Info.cmsSequence))
        goto ErrorReturn;
    if (!Asn1CmcSetTaggedOtherMsgs(pInfo->cTaggedOtherMsg,
            pInfo->rgTaggedOtherMsg, &Asn1Info.otherMsgSequence))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        CmcData_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    Asn1CmcFreeTaggedAttributes(&Asn1Info.controlSequence);
    Asn1CmcFreeTaggedRequests(&Asn1Info.reqSequence);
    Asn1CmcFreeTaggedContentInfos(&Asn1Info.cmsSequence);
    Asn1CmcFreeTaggedOtherMsgs(&Asn1Info.otherMsgSequence);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  CMC Data Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcDataDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CmcData *pAsn1 = (CmcData *) pvAsn1Info;
    PCMC_DATA_INFO pInfo = (PCMC_DATA_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CMC_DATA_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CMC_DATA_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CMC_DATA_INFO);
    }

    Asn1CmcGetTaggedAttributes(&pAsn1->controlSequence,
        dwFlags,
        &pInfo->cTaggedAttribute,
        &pInfo->rgTaggedAttribute,
        &pbExtra,
        &lRemainExtra
        );

    if (!Asn1CmcGetTaggedRequests(&pAsn1->reqSequence,
            dwFlags,
            &pInfo->cTaggedRequest,
            &pInfo->rgTaggedRequest,
            &pbExtra,
            &lRemainExtra
            ))
        goto ErrorReturn;

    Asn1CmcGetTaggedContentInfos(&pAsn1->cmsSequence,
        dwFlags,
        &pInfo->cTaggedContentInfo,
        &pInfo->rgTaggedContentInfo,
        &pbExtra,
        &lRemainExtra
        );

    Asn1CmcGetTaggedOtherMsgs(&pAsn1->otherMsgSequence,
        dwFlags,
        &pInfo->cTaggedOtherMsg,
        &pInfo->rgTaggedOtherMsg,
        &pbExtra,
        &lRemainExtra
        );

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

BOOL WINAPI Asn1CmcDataDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CmcData_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1CmcDataDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  CMC Response Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcResponseEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_RESPONSE_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CmcResponseBody Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1CmcSetTaggedAttributes(pInfo->cTaggedAttribute,
            pInfo->rgTaggedAttribute, &Asn1Info.controlSequence))
        goto ErrorReturn;
    if (!Asn1CmcSetTaggedContentInfos(pInfo->cTaggedContentInfo,
            pInfo->rgTaggedContentInfo, &Asn1Info.cmsSequence))
        goto ErrorReturn;
    if (!Asn1CmcSetTaggedOtherMsgs(pInfo->cTaggedOtherMsg,
            pInfo->rgTaggedOtherMsg, &Asn1Info.otherMsgSequence))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        CmcResponseBody_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
CommonReturn:
    Asn1CmcFreeTaggedAttributes(&Asn1Info.controlSequence);
    Asn1CmcFreeTaggedContentInfos(&Asn1Info.cmsSequence);
    Asn1CmcFreeTaggedOtherMsgs(&Asn1Info.otherMsgSequence);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  CMC Response Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcResponseDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CmcResponseBody *pAsn1 = (CmcResponseBody *) pvAsn1Info;
    PCMC_RESPONSE_INFO pInfo = (PCMC_RESPONSE_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CMC_RESPONSE_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CMC_RESPONSE_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CMC_RESPONSE_INFO);
    }

    Asn1CmcGetTaggedAttributes(&pAsn1->controlSequence,
        dwFlags,
        &pInfo->cTaggedAttribute,
        &pInfo->rgTaggedAttribute,
        &pbExtra,
        &lRemainExtra
        );

    Asn1CmcGetTaggedContentInfos(&pAsn1->cmsSequence,
        dwFlags,
        &pInfo->cTaggedContentInfo,
        &pInfo->rgTaggedContentInfo,
        &pbExtra,
        &lRemainExtra
        );

    Asn1CmcGetTaggedOtherMsgs(&pAsn1->otherMsgSequence,
        dwFlags,
        &pInfo->cTaggedOtherMsg,
        &pInfo->rgTaggedOtherMsg,
        &pbExtra,
        &lRemainExtra
        );

    fResult = TRUE;
    *plRemainExtra = lRemainExtra;
    return fResult;
}

BOOL WINAPI Asn1CmcResponseDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CmcResponseBody_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1CmcResponseDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  CMC Status Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcStatusEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_STATUS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CmcStatusInfo Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    Asn1Info.cmcStatus = pInfo->dwStatus;
    if (pInfo->cBodyList) {
        Asn1Info.bodyList.count = pInfo->cBodyList;
        Asn1Info.bodyList.value = pInfo->rgdwBodyList;
    }

    if (pInfo->pwszStatusString && L'\0' != *pInfo->pwszStatusString) {
        Asn1Info.bit_mask |= statusString_present;
        Asn1Info.statusString.length = wcslen(pInfo->pwszStatusString);
        Asn1Info.statusString.value = pInfo->pwszStatusString;
    }

    if (CMC_OTHER_INFO_NO_CHOICE != pInfo->dwOtherInfoChoice) {
        Asn1Info.bit_mask |= otherInfo_present;

        switch (pInfo->dwOtherInfoChoice) {
            case CMC_OTHER_INFO_FAIL_CHOICE:
                Asn1Info.otherInfo.choice = failInfo_chosen;
                Asn1Info.otherInfo.u.failInfo = pInfo->dwFailInfo;
                break;
            case CMC_OTHER_INFO_PEND_CHOICE:
                Asn1Info.otherInfo.choice = pendInfo_chosen;
                Asn1X509SetOctetString(&pInfo->pPendInfo->PendToken,
                    &Asn1Info.otherInfo.u.pendInfo.pendToken);
                if (!PkiAsn1ToGeneralizedTime(
                        &pInfo->pPendInfo->PendTime,
                        &Asn1Info.otherInfo.u.pendInfo.pendTime))
                    goto GeneralizedTimeError;
                break;
            default:
                goto InvalidOtherInfoChoiceError;
        }
    }


    fResult = Asn1InfoEncodeEx(
        CmcStatusInfo_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidOtherInfoChoiceError, E_INVALIDARG)
SET_ERROR(GeneralizedTimeError, CRYPT_E_BAD_ENCODE)
}

//+-------------------------------------------------------------------------
//  CMC Status Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcStatusDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CmcStatusInfo *pAsn1 = (CmcStatusInfo *) pvAsn1Info;
    PCMC_STATUS_INFO pInfo = (PCMC_STATUS_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    LONG lAlignExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CMC_STATUS_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CMC_STATUS_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CMC_STATUS_INFO);

        pInfo->dwStatus = pAsn1->cmcStatus;
    }

    if (pAsn1->bodyList.count > 0) {
        ASN1uint32_t count = pAsn1->bodyList.count;
        
        lAlignExtra = INFO_LEN_ALIGN(count * sizeof(DWORD));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            BodyPartID *value;
            DWORD *pdwBodyList;

            value = pAsn1->bodyList.value;
            pdwBodyList = (DWORD *) pbExtra;
            pbExtra += lAlignExtra;

            pInfo->cBodyList = count;
            pInfo->rgdwBodyList = pdwBodyList;

            for ( ; count > 0; count--, value++, pdwBodyList++)
                *pdwBodyList = *value;
        }
    }


    if (pAsn1->bit_mask & statusString_present) {
        ASN1uint32_t length = pAsn1->statusString.length;

        lAlignExtra = INFO_LEN_ALIGN((length + 1) * sizeof(WCHAR));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            memcpy(pbExtra, pAsn1->statusString.value, length * sizeof(WCHAR));
            memset(pbExtra + (length * sizeof(WCHAR)), 0, sizeof(WCHAR));

            pInfo->pwszStatusString = (LPWSTR) pbExtra;
            pbExtra += lAlignExtra;
        }
    }

    if (pAsn1->bit_mask & otherInfo_present) {
        switch (pAsn1->otherInfo.choice) {
            case failInfo_chosen:
                if (lRemainExtra >= 0) {
                    pInfo->dwOtherInfoChoice = CMC_OTHER_INFO_FAIL_CHOICE;
                    pInfo->dwFailInfo = pAsn1->otherInfo.u.failInfo;
                }
                break;
            case pendInfo_chosen:
                {
                    PCMC_PEND_INFO pPendInfo;

                    lAlignExtra = INFO_LEN_ALIGN(sizeof(CMC_PEND_INFO));
                    lRemainExtra -= lAlignExtra;
                    if (lRemainExtra >= 0) {
                        pInfo->dwOtherInfoChoice = CMC_OTHER_INFO_PEND_CHOICE;
                        pPendInfo = (PCMC_PEND_INFO) pbExtra;
                        pInfo->pPendInfo = pPendInfo;
                        pbExtra += lAlignExtra;

                        if (!PkiAsn1FromGeneralizedTime(
                                &pAsn1->otherInfo.u.pendInfo.pendTime,
                                &pPendInfo->PendTime))
                            goto GeneralizedTimeDecodeError;
                    } else
                        pPendInfo = NULL;

                    Asn1X509GetOctetString(
                        &pAsn1->otherInfo.u.pendInfo.pendToken, dwFlags,
                        &pPendInfo->PendToken, &pbExtra, &lRemainExtra);
                }
                break;
            default:
                goto InvalidOtherInfoChoiceError;
        }
    }

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidOtherInfoChoiceError, CRYPT_E_BAD_ENCODE)
SET_ERROR(GeneralizedTimeDecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1CmcStatusDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CmcStatusInfo_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1CmcStatusDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  CMC Add Extensions Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcAddExtensionsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_ADD_EXTENSIONS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CmcAddExtensions Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    Asn1Info.pkiDataReference = pInfo->dwCmcDataReference;
    if (pInfo->cCertReference) {
        Asn1Info.certReferences.count = pInfo->cCertReference;
        Asn1Info.certReferences.value = pInfo->rgdwCertReference;
    }

    if (!Asn1X509SetExtensions(pInfo->cExtension, pInfo->rgExtension,
            &Asn1Info.extensions))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        CmcAddExtensions_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    Asn1X509FreeExtensions(&Asn1Info.extensions);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  CMC Add Extensions Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcAddExtensionsDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CmcAddExtensions *pAsn1 = (CmcAddExtensions *) pvAsn1Info;
    PCMC_ADD_EXTENSIONS_INFO pInfo = (PCMC_ADD_EXTENSIONS_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    LONG lAlignExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CMC_ADD_EXTENSIONS_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CMC_ADD_EXTENSIONS_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CMC_ADD_EXTENSIONS_INFO);

        pInfo->dwCmcDataReference = pAsn1->pkiDataReference;
    }

    if (pAsn1->certReferences.count > 0) {
        ASN1uint32_t count = pAsn1->certReferences.count;
        
        lAlignExtra = INFO_LEN_ALIGN(count * sizeof(DWORD));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            BodyPartID *value;
            DWORD *pdwCertReference;

            value = pAsn1->certReferences.value;
            pdwCertReference = (DWORD *) pbExtra;
            pbExtra += lAlignExtra;

            pInfo->cCertReference = count;
            pInfo->rgdwCertReference = pdwCertReference;

            for ( ; count > 0; count--, value++, pdwCertReference++)
                *pdwCertReference = *value;
        }
    }

    Asn1X509GetExtensions(&pAsn1->extensions, dwFlags,
        &pInfo->cExtension, &pInfo->rgExtension, &pbExtra, &lRemainExtra);

    fResult = TRUE;
    *plRemainExtra = lRemainExtra;
    return fResult;
}

BOOL WINAPI Asn1CmcAddExtensionsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CmcAddExtensions_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1CmcAddExtensionsDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  CMC Add Attributes Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcAddAttributesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_ADD_ATTRIBUTES_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CmcAddAttributes Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    Asn1Info.pkiDataReference = pInfo->dwCmcDataReference;
    if (pInfo->cCertReference) {
        Asn1Info.certReferences.count = pInfo->cCertReference;
        Asn1Info.certReferences.value = pInfo->rgdwCertReference;
    }

    if (!Asn1X509SetAttributes(pInfo->cAttribute, pInfo->rgAttribute,
            &Asn1Info.attributes))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        CmcAddAttributes_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    Asn1X509FreeAttributes(&Asn1Info.attributes);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  CMC Add Attributes Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcAddAttributesDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CmcAddAttributes *pAsn1 = (CmcAddAttributes *) pvAsn1Info;
    PCMC_ADD_ATTRIBUTES_INFO pInfo = (PCMC_ADD_ATTRIBUTES_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    LONG lAlignExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CMC_ADD_ATTRIBUTES_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CMC_ADD_ATTRIBUTES_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CMC_ADD_ATTRIBUTES_INFO);

        pInfo->dwCmcDataReference = pAsn1->pkiDataReference;
    }

    if (pAsn1->certReferences.count > 0) {
        ASN1uint32_t count = pAsn1->certReferences.count;
        
        lAlignExtra = INFO_LEN_ALIGN(count * sizeof(DWORD));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            BodyPartID *value;
            DWORD *pdwCertReference;

            value = pAsn1->certReferences.value;
            pdwCertReference = (DWORD *) pbExtra;
            pbExtra += lAlignExtra;

            pInfo->cCertReference = count;
            pInfo->rgdwCertReference = pdwCertReference;

            for ( ; count > 0; count--, value++, pdwCertReference++)
                *pdwCertReference = *value;
        }
    }

    Asn1X509GetAttributes(&pAsn1->attributes, dwFlags,
        &pInfo->cAttribute, &pInfo->rgAttribute, &pbExtra, &lRemainExtra);

    fResult = TRUE;
    *plRemainExtra = lRemainExtra;
    return fResult;
}

BOOL WINAPI Asn1CmcAddAttributesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CmcAddAttributes_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1CmcAddAttributesDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+=========================================================================
//  Certificate Template Encode/Decode Functions
//==========================================================================

BOOL WINAPI Asn1X509CertTemplateEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_TEMPLATE_EXT pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CertificateTemplate Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1X509SetEncodedObjId(pInfo->pszObjId, &Asn1Info.templateID))
        goto ErrorReturn;

    Asn1Info.templateMajorVersion = pInfo->dwMajorVersion;
    if (pInfo->fMinorVersion) {
        Asn1Info.bit_mask |= templateMinorVersion_present;
        Asn1Info.templateMinorVersion = pInfo->dwMinorVersion;
    }

    fResult = Asn1InfoEncodeEx(
        CertificateTemplate_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

BOOL WINAPI Asn1X509CertTemplateDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    CertificateTemplate *pAsn1Info = (CertificateTemplate *) pvAsn1Info;
    PCERT_TEMPLATE_EXT pInfo =
        (PCERT_TEMPLATE_EXT) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_TEMPLATE_EXT);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CERT_TEMPLATE_EXT));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_TEMPLATE_EXT);

        pInfo->dwMajorVersion = pAsn1Info->templateMajorVersion;
        if (pAsn1Info->bit_mask & templateMinorVersion_present) {
            pInfo->fMinorVersion = TRUE;
            pInfo->dwMinorVersion = pAsn1Info->templateMinorVersion;
        }
    }

    Asn1X509GetEncodedObjId(&pAsn1Info->templateID, dwFlags,
        &pInfo->pszObjId, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509CertTemplateDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CertificateTemplate_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509CertTemplateDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\chain\callctx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       callctx.cpp
//
//  Contents:   Certificate Chaining Infrastructure Call Context
//
//  History:    02-Mar-98    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Member:     CChainCallContext::CChainCallContext, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CChainCallContext::CChainCallContext (
                         IN PCCERTCHAINENGINE pChainEngine,
                         IN OPTIONAL LPFILETIME pRequestedTime,
                         IN OPTIONAL PCERT_CHAIN_PARA pChainPara,
                         IN DWORD dwFlags,
                         OUT BOOL& rfResult
                         )
{
    LRU_CACHE_CONFIG Config;

    m_hObjectCreationCache = NULL;
    m_pChainEngine = pChainEngine;
    GetSystemTimeAsFileTime(&m_CurrentTime);
    if (pRequestedTime)
        m_RequestedTime = *pRequestedTime;
    else
        m_RequestedTime = m_CurrentTime;
    m_dwCallFlags = dwFlags;
    m_dwStatus = 0;
    m_dwTouchEngineCount = 0;
    // m_RevEndTime =       // Initialized by RevocationUrlRetrievalTimeout()

    memset(&m_ChainPara, 0, sizeof(m_ChainPara));
    if (NULL != pChainPara)
        memcpy(&m_ChainPara, pChainPara, min(pChainPara->cbSize,
            sizeof(m_ChainPara)));
    m_ChainPara.cbSize = sizeof(m_ChainPara);

    if (0 == m_ChainPara.dwUrlRetrievalTimeout) {
        m_ChainPara.dwUrlRetrievalTimeout =
            pChainEngine->UrlRetrievalTimeout();
        m_fDefaultUrlRetrievalTimeout = 
            pChainEngine->HasDefaultUrlRetrievalTimeout();
    } else
        m_fDefaultUrlRetrievalTimeout = FALSE;


    memset( &Config, 0, sizeof( Config ) );

    Config.dwFlags = LRU_CACHE_NO_SERIALIZE | LRU_CACHE_NO_COPY_IDENTIFIER;
    Config.pfnHash = CertObjectCacheHashMd5Identifier;
    Config.pfnOnRemoval = CallContextOnCreationCacheObjectRemoval;
    Config.cBuckets = DEFAULT_CREATION_CACHE_BUCKETS;

    rfResult = I_CryptCreateLruCache( &Config, &m_hObjectCreationCache );
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainCallContext::~CChainCallContext, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CChainCallContext::~CChainCallContext ()
{
    if ( m_hObjectCreationCache != NULL )
    {
        I_CryptFreeLruCache( m_hObjectCreationCache, 0, NULL );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainCallContext::AddPathObjectToCreationCache, public
//
//  Synopsis:   add a path object to the creation cache
//
//----------------------------------------------------------------------------
BOOL
CChainCallContext::AddPathObjectToCreationCache (
                      IN PCCHAINPATHOBJECT pPathObject
                      )
{
    BOOL            fResult;
    CRYPT_DATA_BLOB DataBlob;
    HLRUENTRY       hEntry;

    DataBlob.cbData = CHAINHASHLEN;
    DataBlob.pbData = pPathObject->CertObject()->CertHash();

    fResult = I_CryptCreateLruEntry(
                     m_hObjectCreationCache,
                     &DataBlob,
                     pPathObject,
                     &hEntry
                     );

    if ( fResult == TRUE )
    {
        I_CryptInsertLruEntry( hEntry, pPathObject );
        I_CryptReleaseLruEntry( hEntry );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainCallContext::FindPathObjectInCreationCache, public
//
//  Synopsis:   find a path object in the creation cache
//
//----------------------------------------------------------------------------
PCCHAINPATHOBJECT
CChainCallContext::FindPathObjectInCreationCache (
                       IN BYTE rgbCertHash[ CHAINHASHLEN ]
                       )
{
    HLRUENTRY       hFound;
    PCCHAINPATHOBJECT    pFound = NULL;
    CRYPT_DATA_BLOB DataBlob;

    DataBlob.cbData = CHAINHASHLEN;
    DataBlob.pbData = rgbCertHash;

    hFound = I_CryptFindLruEntry( m_hObjectCreationCache, &DataBlob );
    if ( hFound != NULL )
    {
        pFound = (PCCHAINPATHOBJECT)I_CryptGetLruEntryData( hFound );

        I_CryptReleaseLruEntry( hFound );
    }

    return( pFound );
}


DWORD CChainCallContext::RevocationUrlRetrievalTimeout()
{
    DWORD dwRevTimeout;

    if (m_dwCallFlags & CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT)
    {
        if (m_dwStatus & CHAINCALLCONTEXT_REV_END_TIME_FLAG)
        {
            dwRevTimeout = I_CryptRemainingMilliseconds(&m_RevEndTime);
            if (0 == dwRevTimeout)
                dwRevTimeout = 1;
        }
        else
        {
            FILETIME ftCurrent;

            if (m_fDefaultUrlRetrievalTimeout)
                dwRevTimeout = DEFAULT_REV_ACCUMULATIVE_URL_RETRIEVAL_TIMEOUT;
            else
                dwRevTimeout = m_ChainPara.dwUrlRetrievalTimeout;

            GetSystemTimeAsFileTime(&ftCurrent);
            I_CryptIncrementFileTimeByMilliseconds(&ftCurrent,
                dwRevTimeout, &m_RevEndTime);
            m_dwStatus |= CHAINCALLCONTEXT_REV_END_TIME_FLAG;
        }
    }
    else
    {
        dwRevTimeout = m_ChainPara.dwUrlRetrievalTimeout;
    }

    return dwRevTimeout;
}


BOOL
CChainCallContext::IsOnline ()
{
    if ( !(m_dwStatus & CHAINCALLCONTEXT_CHECKED_ONLINE_FLAG) )
    {
        if (!(m_pChainEngine->Flags() & CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL) &&
                !(m_dwCallFlags & CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL))
        {
            if ( ChainIsConnected() )
            {
                m_dwStatus |= CHAINCALLCONTEXT_ONLINE_FLAG;
            }
        }
        m_dwStatus |= CHAINCALLCONTEXT_CHECKED_ONLINE_FLAG;
    }

    if (m_dwStatus & CHAINCALLCONTEXT_ONLINE_FLAG)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOL
CChainCallContext::IsTouchedEngine ()
{
    if (m_dwTouchEngineCount == m_pChainEngine->TouchEngineCount())
        return FALSE;
    else
        return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CallContextCreateCallObject
//
//  Synopsis:   create a chain call context object
//
//----------------------------------------------------------------------------
BOOL WINAPI
CallContextCreateCallObject (
    IN PCCERTCHAINENGINE pChainEngine,
    IN OPTIONAL LPFILETIME pRequestedTime,
    IN OPTIONAL PCERT_CHAIN_PARA pChainPara,
    IN DWORD dwFlags,
    OUT PCCHAINCALLCONTEXT* ppCallContext
    )
{
    BOOL               fResult = FALSE;
    PCCHAINCALLCONTEXT pCallContext;

    pCallContext = new CChainCallContext(
            pChainEngine,
            pRequestedTime,
            pChainPara,
            dwFlags,
            fResult
            );
    if ( pCallContext == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    if ( fResult == TRUE )
    {
        *ppCallContext = pCallContext;
    }
    else
    {
        CallContextFreeCallObject( pCallContext );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   CallContextFreeCallObject
//
//  Synopsis:   free the chain call context object
//
//----------------------------------------------------------------------------
VOID WINAPI
CallContextFreeCallObject (
    IN PCCHAINCALLCONTEXT pCallContext
    )
{
    delete pCallContext;
}

//+---------------------------------------------------------------------------
//
//  Function:   CallContextOnCreationCacheObjectRemoval
//
//  Synopsis:   removal notification callback
//
//----------------------------------------------------------------------------
VOID WINAPI
CallContextOnCreationCacheObjectRemoval (
    IN LPVOID pv,
    IN LPVOID pvRemovalContext
    )
{
    delete (PCCHAINPATHOBJECT) pv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\chain\api.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       api.cpp
//
//  Contents:   Certificate Chaining Infrastructure
//
//  History:    28-Jan-98    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <dbgdef.h>

//
// Globals
//

HMODULE                g_hCryptnet = NULL;
CRITICAL_SECTION       g_CryptnetLock;
CDefaultChainEngineMgr DefaultChainEngineMgr;

CRITICAL_SECTION       g_RoamingLogoffNotificationLock;
BOOL                   g_fRoamingLogoffNotificationInitialized = FALSE;


HMODULE                g_hChainInst;

VOID WINAPI
CreateRoamingLogoffNotificationEvent();
VOID WINAPI
InitializeRoamingLogoffNotification();
VOID WINAPI
UninitializeRoamingLogoffNotification();

//+---------------------------------------------------------------------------
//
//  Function:   ChainDllMain
//
//  Synopsis:   Chaining infrastructure initialization
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainDllMain (
     IN HMODULE hModule,
     IN ULONG ulReason,
     IN LPVOID pvReserved
     )
{
    BOOL fResult = TRUE;

    switch ( ulReason )
    {
    case DLL_PROCESS_ATTACH:

        g_hChainInst = hModule;

        fResult = Pki_InitializeCriticalSection( &g_CryptnetLock );
        if (fResult)
        {
            fResult = Pki_InitializeCriticalSection(
                &g_RoamingLogoffNotificationLock );

            if (fResult)
            {
                fResult = DefaultChainEngineMgr.Initialize();
                if (fResult)
                {
                    CreateRoamingLogoffNotificationEvent();
                }
                else
                {
                    DeleteCriticalSection( &g_RoamingLogoffNotificationLock );
                }
            }

            if (!fResult)
            {
                DeleteCriticalSection( &g_CryptnetLock );
            }
        }

        break;
    case DLL_PROCESS_DETACH:

        UninitializeRoamingLogoffNotification();

        DefaultChainEngineMgr.Uninitialize();

        if ( g_hCryptnet != NULL )
        {
            FreeLibrary( g_hCryptnet );
        }

        DeleteCriticalSection( &g_CryptnetLock );
        DeleteCriticalSection( &g_RoamingLogoffNotificationLock );
        break;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   InternalCertCreateCertificateChainEngine
//
//  Synopsis:   create a chain engine handle
//
//----------------------------------------------------------------------------
BOOL WINAPI
InternalCertCreateCertificateChainEngine (
    IN PCERT_CHAIN_ENGINE_CONFIG pConfig,
    IN BOOL fDefaultEngine,
    OUT HCERTCHAINENGINE* phChainEngine
    )
{
    BOOL                     fResult = TRUE;
    PCCERTCHAINENGINE        pChainEngine = NULL;
    CERT_CHAIN_ENGINE_CONFIG Config;

    if ( pConfig->cbSize != sizeof( CERT_CHAIN_ENGINE_CONFIG ) )
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    Config = *pConfig;

    if ( Config.MaximumCachedCertificates == 0 )
    {
        Config.MaximumCachedCertificates = DEFAULT_MAX_INDEX_ENTRIES;
    }

    pChainEngine = new CCertChainEngine( &Config, fDefaultEngine, fResult );
    if ( pChainEngine == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        fResult = FALSE;
    }

    if ( fResult == TRUE )
    {
        *phChainEngine = (HCERTCHAINENGINE)pChainEngine;
    }
    else
    {
        delete pChainEngine;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertCreateCertificateChainEngine
//
//  Synopsis:   create a certificate chain engine
//
//----------------------------------------------------------------------------
BOOL WINAPI
CertCreateCertificateChainEngine (
    IN PCERT_CHAIN_ENGINE_CONFIG pConfig,
    OUT HCERTCHAINENGINE* phChainEngine
    )
{
    return( InternalCertCreateCertificateChainEngine(
                    pConfig,
                    FALSE,
                    phChainEngine
                    ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertFreeCertificateChainEngine
//
//  Synopsis:   free the chain engine handle
//
//----------------------------------------------------------------------------
VOID WINAPI
CertFreeCertificateChainEngine (
    IN HCERTCHAINENGINE hChainEngine
    )
{
    if ( ( hChainEngine == HCCE_CURRENT_USER ) ||
         ( hChainEngine == HCCE_LOCAL_MACHINE ) )
    {
        DefaultChainEngineMgr.FlushDefaultEngine( hChainEngine );
        return;
    }

    ( (PCCERTCHAINENGINE)hChainEngine )->Release();
}

//+---------------------------------------------------------------------------
//
//  Function:   CertResyncCertificateChainEngine
//
//  Synopsis:   resync the chain engine
//
//----------------------------------------------------------------------------
BOOL WINAPI
CertResyncCertificateChainEngine (
    IN HCERTCHAINENGINE hChainEngine
    )
{
    BOOL                fResult;
    PCCERTCHAINENGINE   pChainEngine = (PCCERTCHAINENGINE)hChainEngine;
    PCCHAINCALLCONTEXT  pCallContext = NULL;

    if ( ( hChainEngine == HCCE_LOCAL_MACHINE ) ||
         ( hChainEngine == HCCE_CURRENT_USER ) )
    {
        if ( DefaultChainEngineMgr.GetDefaultEngine(
                                      hChainEngine,
                                      (HCERTCHAINENGINE *)&pChainEngine
                                      ) == FALSE )
        {
            return( FALSE );
        }
    }
    else
    {
        pChainEngine->AddRef();
    }

    fResult = CallContextCreateCallObject(
            pChainEngine,
            NULL,                   // pRequestedTime
            NULL,                   // pChainPara
            CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL,
            &pCallContext
            );

    if (fResult)
    {

        pChainEngine->LockEngine();

        fResult = pChainEngine->Resync( pCallContext, TRUE );

        CertPerfIncrementChainRequestedEngineResyncCount();

        pChainEngine->UnlockEngine();

        CallContextFreeCallObject(pCallContext);
    }

    pChainEngine->Release();

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertGetCertificateChain
//
//  Synopsis:   get the certificate chain for the given end certificate
//
//----------------------------------------------------------------------------
BOOL WINAPI
CertGetCertificateChain (
    IN OPTIONAL HCERTCHAINENGINE hChainEngine,
    IN PCCERT_CONTEXT pCertContext,
    IN OPTIONAL LPFILETIME pTime,
    IN OPTIONAL HCERTSTORE hAdditionalStore,
    IN OPTIONAL PCERT_CHAIN_PARA pChainPara,
    IN DWORD dwFlags,
    IN LPVOID pvReserved,
    OUT PCCERT_CHAIN_CONTEXT* ppChainContext
    )
{
    BOOL              fResult;
    PCCERTCHAINENGINE pChainEngine = (PCCERTCHAINENGINE)hChainEngine;

    InitializeRoamingLogoffNotification();

    if ( ( pChainPara == NULL ) || ( pvReserved != NULL ) )
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    if ( ( hChainEngine == HCCE_LOCAL_MACHINE ) ||
         ( hChainEngine == HCCE_CURRENT_USER ) )
    {
        if ( DefaultChainEngineMgr.GetDefaultEngine(
                                      hChainEngine,
                                      (HCERTCHAINENGINE *)&pChainEngine
                                      ) == FALSE )
        {
            return( FALSE );
        }
    }
    else
    {
        pChainEngine->AddRef();
    }

    fResult = pChainEngine->GetChainContext(
                               pCertContext,
                               pTime,
                               hAdditionalStore,
                               pChainPara,
                               dwFlags,
                               pvReserved,
                               ppChainContext
                               );

    pChainEngine->Release();

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertFreeCertificateChain
//
//  Synopsis:   free a certificate chain context
//
//----------------------------------------------------------------------------
VOID WINAPI
CertFreeCertificateChain (
    IN PCCERT_CHAIN_CONTEXT pChainContext
    )
{
    ChainReleaseInternalChainContext(
         (PINTERNAL_CERT_CHAIN_CONTEXT)pChainContext
         );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertDuplicateCertificateChain
//
//  Synopsis:   duplicate (add a reference to) a certificate chain
//
//----------------------------------------------------------------------------
PCCERT_CHAIN_CONTEXT WINAPI
CertDuplicateCertificateChain (
    IN PCCERT_CHAIN_CONTEXT pChainContext
    )
{
    ChainAddRefInternalChainContext(
         (PINTERNAL_CERT_CHAIN_CONTEXT)pChainContext
         );

    return( pChainContext );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetCryptnetModule
//
//  Synopsis:   get the cryptnet.dll module handle
//
//----------------------------------------------------------------------------
HMODULE WINAPI
ChainGetCryptnetModule ()
{
    HMODULE hModule;

    EnterCriticalSection( &g_CryptnetLock );

    if ( g_hCryptnet == NULL )
    {
        g_hCryptnet = LoadLibraryA( "cryptnet.dll" );
    }

    hModule = g_hCryptnet;

    LeaveCriticalSection( &g_CryptnetLock );

    return( hModule );
}



//+===========================================================================
//  RegisterWaitForSingleObject and UnregisterWaitEx are only supported
//  in kernel32.dll on NT5.
//
//  Internal functions to do dynamic calls
//-===========================================================================

typedef BOOL (WINAPI *PFN_REGISTER_WAIT_FOR_SINGLE_OBJECT)(
    PHANDLE hNewWaitObject,
    HANDLE hObject,
    WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds,
    ULONG dwFlags
    );

typedef BOOL (WINAPI *PFN_UNREGISTER_WAIT_EX)(
    HANDLE WaitHandle,
    HANDLE CompletionEvent      // INVALID_HANDLE_VALUE => create event
                                // to wait for
    );

#define sz_KERNEL32_DLL                 "kernel32.dll"
#define sz_RegisterWaitForSingleObject  "RegisterWaitForSingleObject"
#define sz_UnregisterWaitEx             "UnregisterWaitEx"

BOOL
WINAPI
InternalRegisterWaitForSingleObject(
    PHANDLE hNewWaitObject,
    HANDLE hObject,
    WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds,
    ULONG dwFlags
    )
{
    BOOL fResult;
    HMODULE hKernel32Dll = NULL;
    PFN_REGISTER_WAIT_FOR_SINGLE_OBJECT pfnRegisterWaitForSingleObject;

    if (NULL == (hKernel32Dll = LoadLibraryA(sz_KERNEL32_DLL)))
        goto LoadKernel32DllError;

    if (NULL == (pfnRegisterWaitForSingleObject =
            (PFN_REGISTER_WAIT_FOR_SINGLE_OBJECT) GetProcAddress(
                hKernel32Dll, sz_RegisterWaitForSingleObject)))
        goto GetRegisterWaitForSingleObjectProcAddressError;

    fResult = pfnRegisterWaitForSingleObject(
        hNewWaitObject,
        hObject,
        Callback,
        Context,
        dwMilliseconds,
        dwFlags
        );

CommonReturn:
    if (hKernel32Dll) {
        DWORD dwErr = GetLastError();
        FreeLibrary(hKernel32Dll);
        SetLastError(dwErr);
    }
    return fResult;
ErrorReturn:
    *hNewWaitObject = NULL;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(LoadKernel32DllError)
TRACE_ERROR(GetRegisterWaitForSingleObjectProcAddressError)
}

BOOL
WINAPI
InternalUnregisterWaitEx(
    HANDLE WaitHandle,
    HANDLE CompletionEvent      // INVALID_HANDLE_VALUE => create event
                                // to wait for
    )
{
    BOOL fResult;
    HMODULE hKernel32Dll = NULL;
    PFN_UNREGISTER_WAIT_EX pfnUnregisterWaitEx;

    if (NULL == (hKernel32Dll = LoadLibraryA(sz_KERNEL32_DLL)))
        goto LoadKernel32DllError;
    if (NULL == (pfnUnregisterWaitEx =
            (PFN_UNREGISTER_WAIT_EX) GetProcAddress(
                hKernel32Dll, sz_UnregisterWaitEx)))
        goto GetUnregisterWaitExProcAddressError;

    fResult = pfnUnregisterWaitEx(
        WaitHandle,
        CompletionEvent
        );

CommonReturn:
    if (hKernel32Dll) {
        DWORD dwErr = GetLastError();
        FreeLibrary(hKernel32Dll);
        SetLastError(dwErr);
    }
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(LoadKernel32DllError)
TRACE_ERROR(GetUnregisterWaitExProcAddressError)
}

//+===========================================================================
//  We only get logoff notification in winlogon.exe.
//
//  The work around is to have the winlogon ChainWlxLogoffEvent pulse a
//  named event. All processes where crypt32.dll is loaded will be doing
//  a RegisterWaitForObject for this event.
//
//  Note, there is a very small window where we might not be waiting at the
//  time the event is pulsed.
//-===========================================================================

#define CRYPT32_LOGOFF_EVENT    "Global\\crypt32LogoffEvent"

HANDLE g_hLogoffEvent;
HANDLE g_hLogoffRegWaitFor;

typedef BOOL (WINAPI *PFN_WLX_LOGOFF)(
    PWLX_NOTIFICATION_INFO pNotificationInfo
    );

VOID NTAPI LogoffWaitForCallback(
    PVOID Context,
    BOOLEAN fWaitOrTimedOut        // ???
    )
{
    HMODULE hModule;

    CertFreeCertificateChainEngine( HCCE_CURRENT_USER );

    // Only call if cryptnet has been loaded
    if (NULL != GetModuleHandleA("cryptnet.dll")) {
        hModule = ChainGetCryptnetModule();
        if (hModule) {
            PFN_WLX_LOGOFF pfn;

            pfn = (PFN_WLX_LOGOFF) GetProcAddress(hModule,
                "CryptnetWlxLogoffEvent");
            if (pfn)
                pfn(NULL);
        }
    }
}

// Note, the event must not be created while impersonating. That's why it
// is created at ProcessAttach.
VOID WINAPI
CreateRoamingLogoffNotificationEvent()
{
    SECURITY_ATTRIBUTES sa;
    SECURITY_DESCRIPTOR sd;

    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY siaWorldSidAuthority =
        SECURITY_WORLD_SID_AUTHORITY;

    PSID psidLocalSystem = NULL;
    PSID psidEveryone = NULL;
    PACL pDacl = NULL;
    DWORD dwAclSize;

    if (!FIsWinNT5())
        return;

    // Allow Everyone to have SYNCHRONIZE access to the logoff event.
    // Only allow LocalSystem to have ALL access
    if (!AllocateAndInitializeSid(
            &siaNtAuthority,
            1,
            SECURITY_LOCAL_SYSTEM_RID,
            0, 0, 0, 0, 0, 0, 0,
            &psidLocalSystem
            )) 
        goto AllocateAndInitializeSidError;

    if (!AllocateAndInitializeSid(
            &siaWorldSidAuthority,
            1,
            SECURITY_WORLD_RID,
            0, 0, 0, 0, 0, 0, 0,
            &psidEveryone
            ))
        goto AllocateAndInitializeSidError;
    //
    // compute size of ACL
    //
    dwAclSize = sizeof(ACL) +
        2 * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
        GetLengthSid(psidLocalSystem) +
        GetLengthSid(psidEveryone)
        ;

    //
    // allocate storage for Acl
    //
    if (NULL == (pDacl = (PACL) PkiNonzeroAlloc(dwAclSize)))
        goto OutOfMemory;

    if (!InitializeAcl(pDacl, dwAclSize, ACL_REVISION))
        goto InitializeAclError;

    if (!AddAccessAllowedAce(
            pDacl,
            ACL_REVISION,
            EVENT_ALL_ACCESS,
            psidLocalSystem
            ))
        goto AddAceError;
    if (!AddAccessAllowedAce(
            pDacl,
            ACL_REVISION,
            SYNCHRONIZE,
            psidEveryone
            ))
        goto AddAceError;

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
        goto InitializeSecurityDescriptorError;
    if (!SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE))
        goto SetSecurityDescriptorDaclError;
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle = FALSE;

    g_hLogoffEvent = CreateEventA(
        &sa,
        TRUE,           // fManualReset, must be TRUE to pulse all waitors
        FALSE,          // fInitialState
        CRYPT32_LOGOFF_EVENT
        );
    if (NULL == g_hLogoffEvent) {
        // Try to open with only SYNCHRONIZE access
        g_hLogoffEvent = OpenEventA(
            SYNCHRONIZE,
            FALSE,          // fInherit
            CRYPT32_LOGOFF_EVENT
            );
        if (NULL == g_hLogoffEvent)
            goto CreateEventError;
    }

CommonReturn:
    if (psidLocalSystem)
        FreeSid(psidLocalSystem);
    if (psidEveryone)
        FreeSid(psidEveryone);
    PkiFree(pDacl);

    return;
ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(AllocateAndInitializeSidError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(InitializeAclError)
TRACE_ERROR(AddAceError)
TRACE_ERROR(InitializeSecurityDescriptorError)
TRACE_ERROR(SetSecurityDescriptorDaclError)
TRACE_ERROR(CreateEventError)
}

VOID WINAPI
InitializeRoamingLogoffNotification()
{
    if (!FIsWinNT5())
        return;
    if (g_fRoamingLogoffNotificationInitialized)
        return;

    EnterCriticalSection(&g_RoamingLogoffNotificationLock);

    if (g_fRoamingLogoffNotificationInitialized)
        goto CommonReturn;
    if (NULL == g_hLogoffEvent)
        goto NoLogoffEvent;

    // Note, this can't be called at ProcessAttach
    if (!InternalRegisterWaitForSingleObject(
            &g_hLogoffRegWaitFor,
            g_hLogoffEvent,
            LogoffWaitForCallback,
            NULL,                   // Context
            INFINITE,               // no timeout
            WT_EXECUTEINWAITTHREAD
            ))
        goto RegisterWaitForError;

CommonReturn:
    g_fRoamingLogoffNotificationInitialized = TRUE;
    LeaveCriticalSection(&g_RoamingLogoffNotificationLock);
    return;
ErrorReturn:
    goto CommonReturn;
SET_ERROR(NoLogoffEvent, E_UNEXPECTED)
TRACE_ERROR(RegisterWaitForError)
}

VOID WINAPI
UninitializeRoamingLogoffNotification()
{
    if (g_hLogoffRegWaitFor) {
        InternalUnregisterWaitEx(g_hLogoffRegWaitFor, INVALID_HANDLE_VALUE);
        g_hLogoffRegWaitFor = NULL;
    }

    if (g_hLogoffEvent) {
        CloseHandle(g_hLogoffEvent);
        g_hLogoffEvent = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainWlxLogoffEvent
//
//  Synopsis:   logoff event processing
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainWlxLogoffEvent (PWLX_NOTIFICATION_INFO pNotificationInfo)
{
    if (g_hLogoffRegWaitFor) {
        InternalUnregisterWaitEx(g_hLogoffRegWaitFor, INVALID_HANDLE_VALUE);
        g_hLogoffRegWaitFor = NULL;
    }

    CertFreeCertificateChainEngine( HCCE_CURRENT_USER );

    if (g_hLogoffEvent) {
        // Trigger all non-winlogon processes to do logoff processing
        PulseEvent(g_hLogoffEvent);
    }
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\chain\callctx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       callctx.h
//
//  Contents:   Certificate Chaining Infrastructure Call Context
//
//  History:    02-Mar-98    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__CALLCTX_H__)
#define __CALLCTX_H__

#include <chain.h>

#define DEFAULT_CREATION_CACHE_BUCKETS 13

// The first revocation URL retrieval uses half of this timeout
#define DEFAULT_REV_ACCUMULATIVE_URL_RETRIEVAL_TIMEOUT 20000

//
// The call context object provides a mechanism for packaging and passing
// around per-call data in the certificate chaining infrastructure.
//

class CChainCallContext
{
public:

    //
    // Construction
    //

    CChainCallContext (
          IN PCCERTCHAINENGINE pChainEngine,
          IN OPTIONAL LPFILETIME pRequestedTime,
          IN OPTIONAL PCERT_CHAIN_PARA pChainPara,
          IN DWORD dwFlags,
          OUT BOOL& rfResult
          );

    ~CChainCallContext ();

    inline PCCERTCHAINENGINE ChainEngine();

    inline VOID CurrentTime (
                    OUT LPFILETIME pCurrentTime
                    );
    inline VOID RequestedTime (
                    OUT LPFILETIME pCurrentTime
                    );

    inline PCERT_CHAIN_PARA ChainPara();
    inline BOOL HasDefaultUrlRetrievalTimeout ();

    DWORD RevocationUrlRetrievalTimeout();

    inline DWORD CallFlags();
    inline DWORD EngineFlags();
    inline DWORD CallOrEngineFlags();

    //
    // Cert Object Creation Cache
    //
    // This caches all certificate objects created in the context of this
    // call.
    //

    BOOL AddPathObjectToCreationCache (
            IN PCCHAINPATHOBJECT pPathObject
            );

    PCCHAINPATHOBJECT FindPathObjectInCreationCache (
                     IN BYTE rgbCertHash[ CHAINHASHLEN ]
                     );

    inline VOID FlushObjectsInCreationCache( );

    BOOL IsOnline ();


    //
    // Engine Touching
    //

    inline VOID TouchEngine ();
    BOOL IsTouchedEngine ();
    inline VOID ResetTouchEngine ();


private:

    //
    // Cert Object Creation cache
    //
    // NOTE: LRU is turned off
    //

    HLRUCACHE m_hObjectCreationCache;

    PCCERTCHAINENGINE m_pChainEngine;
    FILETIME m_CurrentTime;
    FILETIME m_RequestedTime;
    CERT_CHAIN_PARA m_ChainPara;
    BOOL m_fDefaultUrlRetrievalTimeout;
    DWORD m_dwCallFlags;

    DWORD m_dwStatus;

    DWORD m_dwTouchEngineCount;

    FILETIME m_RevEndTime;
};

#define CHAINCALLCONTEXT_CHECKED_ONLINE_FLAG    0x00000001
#define CHAINCALLCONTEXT_ONLINE_FLAG            0x00010000

#define CHAINCALLCONTEXT_REV_END_TIME_FLAG      0x00000010


//
// Call Context Utility Functions
//

BOOL WINAPI
CallContextCreateCallObject (
    IN PCCERTCHAINENGINE pChainEngine,
    IN OPTIONAL LPFILETIME pRequestedTime,
    IN OPTIONAL PCERT_CHAIN_PARA pChainPara,
    IN DWORD dwFlags,
    OUT PCCHAINCALLCONTEXT* ppCallContext
    );

VOID WINAPI
CallContextFreeCallObject (
    IN PCCHAINCALLCONTEXT pCallContext
    );

VOID WINAPI
CallContextOnCreationCacheObjectRemoval (
    IN LPVOID pv,
    IN LPVOID pvRemovalContext
    );

//
// Inline methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CChainCallContext::FlushObjectsInCreationCache, public
//
//  Synopsis:   flush the cache of objects
//
//----------------------------------------------------------------------------
inline VOID
CChainCallContext::FlushObjectsInCreationCache( )
{
    I_CryptFlushLruCache( m_hObjectCreationCache, 0, this );
}

inline PCCERTCHAINENGINE
CChainCallContext::ChainEngine ()
{
    return( m_pChainEngine);
}

inline VOID
CChainCallContext::RequestedTime (
                    OUT LPFILETIME pRequestedTime
                    )
{
    *pRequestedTime = m_RequestedTime;
}

inline VOID
CChainCallContext::CurrentTime (
                    OUT LPFILETIME pCurrentTime
                    )
{
    *pCurrentTime = m_CurrentTime;
}

inline PCERT_CHAIN_PARA
CChainCallContext::ChainPara()
{
    return( &m_ChainPara );
}

inline BOOL
CChainCallContext::HasDefaultUrlRetrievalTimeout()
{
    return( m_fDefaultUrlRetrievalTimeout );
}

inline DWORD
CChainCallContext::CallFlags ()
{
    return( m_dwCallFlags );
}

inline DWORD
CChainCallContext::EngineFlags ()
{
    return( m_pChainEngine->Flags() );
}

inline DWORD
CChainCallContext::CallOrEngineFlags ()
{
    return( m_dwCallFlags | m_pChainEngine->Flags() );
}


inline VOID
CChainCallContext::TouchEngine ()
{
    m_dwTouchEngineCount = m_pChainEngine->IncrementTouchEngineCount();
}


inline VOID
CChainCallContext::ResetTouchEngine ()
{
    m_dwTouchEngineCount = m_pChainEngine->TouchEngineCount();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\x509.h ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for X509 v3 certificates */

#ifndef _X509_Module_H_
#define _X509_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef ASN1int32_t NoticeReference_noticeNumbers_Seq;

typedef ASN1intx_t HUGEINTEGER;

typedef ASN1bitstring_t BITSTRING;

typedef ASN1octetstring_t OCTETSTRING;

typedef ASN1open_t NOCOPYANY;

typedef ASN1charstring_t NUMERICSTRING;

typedef ASN1charstring_t PRINTABLESTRING;

typedef ASN1charstring_t TELETEXSTRING;

typedef ASN1charstring_t T61STRING;

typedef ASN1charstring_t VIDEOTEXSTRING;

typedef ASN1charstring_t IA5STRING;

typedef ASN1charstring_t GRAPHICSTRING;

typedef ASN1charstring_t VISIBLESTRING;

typedef ASN1charstring_t ISO646STRING;

typedef ASN1charstring_t GENERALSTRING;

typedef ASN1char32string_t UNIVERSALSTRING;

typedef ASN1char16string_t BMPSTRING;

typedef ASN1wstring_t UTF8STRING;

typedef ASN1encodedOID_t EncodedObjectID;
#define EncodedObjectID_PDU 0
#define SIZE_X509_Module_PDU_0 sizeof(EncodedObjectID)

typedef BITSTRING Bits;
#define Bits_PDU 1
#define SIZE_X509_Module_PDU_1 sizeof(Bits)

typedef ASN1int32_t CertificateVersion;
#define CertificateVersion_v1 0
#define CertificateVersion_v2 1
#define CertificateVersion_v3 2

typedef HUGEINTEGER CertificateSerialNumber;

typedef BITSTRING UniqueIdentifier;

typedef ASN1int32_t CRLVersion;
#define CRLVersion_v1 0
#define CRLVersion_v2 1

typedef ASN1int32_t CertificationRequestInfoVersion;

typedef OCTETSTRING KeyIdentifier;

typedef BITSTRING KeyUsage;

typedef EncodedObjectID CertPolicyElementId;

typedef BITSTRING SubjectType;

typedef BITSTRING ReasonFlags;

typedef ASN1int32_t IntegerType;
#define IntegerType_PDU 2
#define SIZE_X509_Module_PDU_2 sizeof(IntegerType)

typedef HUGEINTEGER HugeIntegerType;
#define HugeIntegerType_PDU 3
#define SIZE_X509_Module_PDU_3 sizeof(HugeIntegerType)

typedef OCTETSTRING OctetStringType;
#define OctetStringType_PDU 4
#define SIZE_X509_Module_PDU_4 sizeof(OctetStringType)

typedef enum EnumeratedType {
    dummyEnumerated0 = 0,
} EnumeratedType;
#define EnumeratedType_PDU 5
#define SIZE_X509_Module_PDU_5 sizeof(EnumeratedType)

typedef ASN1utctime_t UtcTime;
#define UtcTime_PDU 6
#define SIZE_X509_Module_PDU_6 sizeof(UtcTime)

typedef EncodedObjectID ContentType;

typedef EncodedObjectID UsageIdentifier;

typedef ASN1int32_t CTLVersion;
#define CTLVersion_v1 0

typedef OCTETSTRING ListIdentifier;

typedef OCTETSTRING SubjectIdentifier;

typedef ASN1uint32_t BaseDistance;

typedef ASN1uint32_t SkipCerts;

typedef ASN1uint32_t BodyPartID;

typedef ASN1uint32_t TemplateVersion;

typedef struct NoticeReference_noticeNumbers {
    ASN1uint32_t count;
    NoticeReference_noticeNumbers_Seq *value;
} NoticeReference_noticeNumbers;

typedef struct AnyString {
    ASN1choice_t choice;
    union {
#	define octetString_chosen 1
	OCTETSTRING octetString;
#	define utf8String_chosen 2
	UTF8STRING utf8String;
#	define numericString_chosen 3
	NUMERICSTRING numericString;
#	define printableString_chosen 4
	PRINTABLESTRING printableString;
#	define teletexString_chosen 5
	TELETEXSTRING teletexString;
#	define videotexString_chosen 6
	VIDEOTEXSTRING videotexString;
#	define ia5String_chosen 7
	IA5STRING ia5String;
#	define graphicString_chosen 8
	GRAPHICSTRING graphicString;
#	define visibleString_chosen 9
	VISIBLESTRING visibleString;
#	define generalString_chosen 10
	GENERALSTRING generalString;
#	define universalString_chosen 11
	UNIVERSALSTRING universalString;
#	define bmpString_chosen 12
	BMPSTRING bmpString;
    } u;
} AnyString;
#define AnyString_PDU 7
#define SIZE_X509_Module_PDU_7 sizeof(AnyString)

typedef struct AlgorithmIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EncodedObjectID algorithm;
#   define parameters_present 0x80
    NOCOPYANY parameters;
} AlgorithmIdentifier;

typedef struct Name {
    ASN1uint32_t count;
    struct RelativeDistinguishedName *value;
} Name;
#define Name_PDU 8
#define SIZE_X509_Module_PDU_8 sizeof(Name)

typedef struct RelativeDistinguishedName {
    ASN1uint32_t count;
    struct AttributeTypeValue *value;
} RelativeDistinguishedName;

typedef struct AttributeTypeValue {
    EncodedObjectID type;
    NOCOPYANY value;
} AttributeTypeValue;

typedef struct AttributeSetValue {
    ASN1uint32_t count;
    NOCOPYANY *value;
} AttributeSetValue;

typedef struct Attributes {
    ASN1uint32_t count;
    struct Attribute *value;
} Attributes;
#define Attributes_PDU 9
#define SIZE_X509_Module_PDU_9 sizeof(Attributes)

typedef struct RSAPublicKey {
    HUGEINTEGER modulus;
    ASN1uint32_t publicExponent;
} RSAPublicKey;
#define RSAPublicKey_PDU 10
#define SIZE_X509_Module_PDU_10 sizeof(RSAPublicKey)

typedef struct DSSParameters {
    HUGEINTEGER p;
    HUGEINTEGER q;
    HUGEINTEGER g;
} DSSParameters;
#define DSSParameters_PDU 11
#define SIZE_X509_Module_PDU_11 sizeof(DSSParameters)

typedef struct DSSSignature {
    HUGEINTEGER r;
    HUGEINTEGER s;
} DSSSignature;
#define DSSSignature_PDU 12
#define SIZE_X509_Module_PDU_12 sizeof(DSSSignature)

typedef struct DHParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    HUGEINTEGER p;
    HUGEINTEGER g;
#   define privateValueLength_present 0x80
    HUGEINTEGER privateValueLength;
} DHParameters;
#define DHParameters_PDU 13
#define SIZE_X509_Module_PDU_13 sizeof(DHParameters)

typedef struct X942DhValidationParams {
    BITSTRING seed;
    ASN1uint32_t pgenCounter;
} X942DhValidationParams;

typedef struct X942DhKeySpecificInfo {
    EncodedObjectID algorithm;
    OCTETSTRING counter;
} X942DhKeySpecificInfo;

typedef struct RC2CBCParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
#   define iv_present 0x80
    OCTETSTRING iv;
} RC2CBCParameters;
#define RC2CBCParameters_PDU 14
#define SIZE_X509_Module_PDU_14 sizeof(RC2CBCParameters)

typedef struct SMIMECapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EncodedObjectID capabilityID;
#   define smimeParameters_present 0x80
    NOCOPYANY smimeParameters;
} SMIMECapability;

typedef struct SMIMECapabilities {
    ASN1uint32_t count;
    struct SMIMECapability *value;
} SMIMECapabilities;
#define SMIMECapabilities_PDU 15
#define SIZE_X509_Module_PDU_15 sizeof(SMIMECapabilities)

typedef struct SubjectPublicKeyInfo {
    AlgorithmIdentifier algorithm;
    BITSTRING subjectPublicKey;
} SubjectPublicKeyInfo;
#define SubjectPublicKeyInfo_PDU 16
#define SIZE_X509_Module_PDU_16 sizeof(SubjectPublicKeyInfo)

typedef struct ChoiceOfTime {
    ASN1choice_t choice;
    union {
#	define utcTime_chosen 1
	ASN1utctime_t utcTime;
#	define generalTime_chosen 2
	ASN1generalizedtime_t generalTime;
    } u;
} ChoiceOfTime;
#define ChoiceOfTime_PDU 17
#define SIZE_X509_Module_PDU_17 sizeof(ChoiceOfTime)

typedef struct Validity {
    ChoiceOfTime notBefore;
    ChoiceOfTime notAfter;
} Validity;

typedef struct Extensions {
    ASN1uint32_t count;
    struct Extension *value;
} Extensions;
#define Extensions_PDU 18
#define SIZE_X509_Module_PDU_18 sizeof(Extensions)

typedef struct Extension {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EncodedObjectID extnId;
#   define critical_present 0x80
    ASN1bool_t critical;
    OCTETSTRING extnValue;
} Extension;

typedef struct SignedContent {
    NOCOPYANY toBeSigned;
    AlgorithmIdentifier algorithm;
    BITSTRING signature;
} SignedContent;
#define SignedContent_PDU 19
#define SIZE_X509_Module_PDU_19 sizeof(SignedContent)

typedef struct RevokedCertificates {
    ASN1uint32_t count;
    struct CRLEntry *value;
} RevokedCertificates;

typedef struct CRLEntry {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CertificateSerialNumber userCertificate;
    ChoiceOfTime revocationDate;
#   define crlEntryExtensions_present 0x80
    Extensions crlEntryExtensions;
} CRLEntry;

typedef struct CertificationRequestInfo {
    CertificationRequestInfoVersion version;
    NOCOPYANY subject;
    SubjectPublicKeyInfo subjectPublicKeyInfo;
    Attributes attributes;
} CertificationRequestInfo;
#define CertificationRequestInfo_PDU 20
#define SIZE_X509_Module_PDU_20 sizeof(CertificationRequestInfo)

typedef struct CertificationRequestInfoDecode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CertificationRequestInfoVersion version;
    NOCOPYANY subject;
    SubjectPublicKeyInfo subjectPublicKeyInfo;
#   define attributes_present 0x80
    Attributes attributes;
} CertificationRequestInfoDecode;
#define CertificationRequestInfoDecode_PDU 21
#define SIZE_X509_Module_PDU_21 sizeof(CertificationRequestInfoDecode)

typedef struct KeygenRequestInfo {
    SubjectPublicKeyInfo subjectPublicKeyInfo;
    IA5STRING challenge;
} KeygenRequestInfo;
#define KeygenRequestInfo_PDU 22
#define SIZE_X509_Module_PDU_22 sizeof(KeygenRequestInfo)

typedef struct AuthorityKeyId {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define AuthorityKeyId_keyIdentifier_present 0x80
    KeyIdentifier keyIdentifier;
#   define certIssuer_present 0x40
    NOCOPYANY certIssuer;
#   define certSerialNumber_present 0x20
    CertificateSerialNumber certSerialNumber;
} AuthorityKeyId;
#define AuthorityKeyId_PDU 23
#define SIZE_X509_Module_PDU_23 sizeof(AuthorityKeyId)

typedef struct PrivateKeyValidity {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define notBefore_present 0x80
    ASN1generalizedtime_t notBefore;
#   define notAfter_present 0x40
    ASN1generalizedtime_t notAfter;
} PrivateKeyValidity;

typedef struct CertPolicySet {
    ASN1uint32_t count;
    struct CertPolicyId *value;
} CertPolicySet;

typedef struct CertPolicyId {
    ASN1uint32_t count;
    CertPolicyElementId *value;
} CertPolicyId;

typedef struct AltNames {
    ASN1uint32_t count;
    struct GeneralName *value;
} AltNames;
#define AltNames_PDU 24
#define SIZE_X509_Module_PDU_24 sizeof(AltNames)

typedef AltNames GeneralNames;

typedef struct OtherName {
    EncodedObjectID type;
    NOCOPYANY value;
} OtherName;

typedef struct EDIPartyName {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define nameAssigner_present 0x80
    NOCOPYANY nameAssigner;
    NOCOPYANY partyName;
} EDIPartyName;
#define EDIPartyName_PDU 25
#define SIZE_X509_Module_PDU_25 sizeof(EDIPartyName)

typedef struct SubtreesConstraint {
    ASN1uint32_t count;
    NOCOPYANY *value;
} SubtreesConstraint;

typedef struct BasicConstraints2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define cA_present 0x80
    ASN1bool_t cA;
#   define BasicConstraints2_pathLenConstraint_present 0x40
    ASN1int32_t pathLenConstraint;
} BasicConstraints2;
#define BasicConstraints2_PDU 26
#define SIZE_X509_Module_PDU_26 sizeof(BasicConstraints2)

typedef struct CertificatePolicies {
    ASN1uint32_t count;
    struct PolicyInformation *value;
} CertificatePolicies;
#define CertificatePolicies_PDU 27
#define SIZE_X509_Module_PDU_27 sizeof(CertificatePolicies)

typedef struct PolicyQualifiers {
    ASN1uint32_t count;
    struct PolicyQualifierInfo *value;
} PolicyQualifiers;

typedef struct PolicyQualifierInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EncodedObjectID policyQualifierId;
#   define qualifier_present 0x80
    NOCOPYANY qualifier;
} PolicyQualifierInfo;

typedef struct NoticeReference {
    ASN1ztcharstring_t organization;
    NoticeReference_noticeNumbers noticeNumbers;
} NoticeReference;

typedef struct DisplayText {
    ASN1choice_t choice;
    union {
#	define theVisibleString_chosen 1
	ASN1ztcharstring_t theVisibleString;
#	define theBMPString_chosen 2
	ASN1char16string_t theBMPString;
    } u;
} DisplayText;

typedef struct CertificatePolicies95 {
    ASN1uint32_t count;
    struct PolicyQualifiers *value;
} CertificatePolicies95;
#define CertificatePolicies95_PDU 28
#define SIZE_X509_Module_PDU_28 sizeof(CertificatePolicies95)

typedef struct CpsURLs {
    ASN1uint32_t count;
    struct CpsURLs_Seq *value;
} CpsURLs;

typedef struct AuthorityKeyId2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define AuthorityKeyId2_keyIdentifier_present 0x80
    KeyIdentifier keyIdentifier;
#   define authorityCertIssuer_present 0x40
    GeneralNames authorityCertIssuer;
#   define authorityCertSerialNumber_present 0x20
    CertificateSerialNumber authorityCertSerialNumber;
} AuthorityKeyId2;
#define AuthorityKeyId2_PDU 29
#define SIZE_X509_Module_PDU_29 sizeof(AuthorityKeyId2)

typedef struct AuthorityInfoAccess {
    ASN1uint32_t count;
    struct AccessDescription *value;
} AuthorityInfoAccess;
#define AuthorityInfoAccess_PDU 30
#define SIZE_X509_Module_PDU_30 sizeof(AuthorityInfoAccess)

typedef struct CRLDistributionPoints {
    ASN1uint32_t count;
    struct DistributionPoint *value;
} CRLDistributionPoints;
#define CRLDistributionPoints_PDU 31
#define SIZE_X509_Module_PDU_31 sizeof(CRLDistributionPoints)

typedef struct DistributionPointName {
    ASN1choice_t choice;
    union {
#	define fullName_chosen 1
	GeneralNames fullName;
#	define nameRelativeToCRLIssuer_chosen 2
	RelativeDistinguishedName nameRelativeToCRLIssuer;
    } u;
} DistributionPointName;

typedef struct ContentInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ContentType contentType;
#   define content_present 0x80
    NOCOPYANY content;
} ContentInfo;
#define ContentInfo_PDU 32
#define SIZE_X509_Module_PDU_32 sizeof(ContentInfo)

typedef struct SeqOfAny {
    ASN1uint32_t count;
    NOCOPYANY *value;
} SeqOfAny;
#define SeqOfAny_PDU 33
#define SIZE_X509_Module_PDU_33 sizeof(SeqOfAny)

typedef struct TimeStampRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EncodedObjectID timeStampAlgorithm;
#   define attributesTS_present 0x80
    Attributes attributesTS;
    ContentInfo content;
} TimeStampRequest;
#define TimeStampRequest_PDU 34
#define SIZE_X509_Module_PDU_34 sizeof(TimeStampRequest)

typedef struct ContentInfoOTS {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ContentType contentTypeOTS;
#   define contentOTS_present 0x80
    OCTETSTRING contentOTS;
} ContentInfoOTS;
#define ContentInfoOTS_PDU 35
#define SIZE_X509_Module_PDU_35 sizeof(ContentInfoOTS)

typedef struct TimeStampRequestOTS {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EncodedObjectID timeStampAlgorithmOTS;
#   define attributesOTS_present 0x80
    Attributes attributesOTS;
    ContentInfoOTS contentOTS;
} TimeStampRequestOTS;
#define TimeStampRequestOTS_PDU 36
#define SIZE_X509_Module_PDU_36 sizeof(TimeStampRequestOTS)

typedef struct EnhancedKeyUsage {
    ASN1uint32_t count;
    UsageIdentifier *value;
} EnhancedKeyUsage;
#define EnhancedKeyUsage_PDU 37
#define SIZE_X509_Module_PDU_37 sizeof(EnhancedKeyUsage)

typedef EnhancedKeyUsage SubjectUsage;

typedef struct TrustedSubjects {
    ASN1uint32_t count;
    struct TrustedSubject *value;
} TrustedSubjects;

typedef struct TrustedSubject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SubjectIdentifier subjectIdentifier;
#   define subjectAttributes_present 0x80
    Attributes subjectAttributes;
} TrustedSubject;

typedef struct EnrollmentNameValuePair {
    BMPSTRING name;
    BMPSTRING value;
} EnrollmentNameValuePair;
#define EnrollmentNameValuePair_PDU 38
#define SIZE_X509_Module_PDU_38 sizeof(EnrollmentNameValuePair)

typedef struct CSPProvider {
    ASN1int32_t keySpec;
    BMPSTRING cspName;
    BITSTRING signature;
} CSPProvider;
#define CSPProvider_PDU 39
#define SIZE_X509_Module_PDU_39 sizeof(CSPProvider)

typedef struct CertificatePair {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define forward_present 0x80
    NOCOPYANY forward;
#   define reverse_present 0x40
    NOCOPYANY reverse;
} CertificatePair;
#define CertificatePair_PDU 40
#define SIZE_X509_Module_PDU_40 sizeof(CertificatePair)

typedef struct GeneralSubtrees {
    ASN1uint32_t count;
    struct GeneralSubtree *value;
} GeneralSubtrees;

typedef struct IssuingDistributionPoint {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define issuingDistributionPoint_present 0x80
    DistributionPointName issuingDistributionPoint;
#   define onlyContainsUserCerts_present 0x40
    ASN1bool_t onlyContainsUserCerts;
#   define onlyContainsCACerts_present 0x20
    ASN1bool_t onlyContainsCACerts;
#   define onlySomeReasons_present 0x10
    ReasonFlags onlySomeReasons;
#   define indirectCRL_present 0x8
    ASN1bool_t indirectCRL;
} IssuingDistributionPoint;
#define IssuingDistributionPoint_PDU 41
#define SIZE_X509_Module_PDU_41 sizeof(IssuingDistributionPoint)

typedef struct CrossCertDistPointNames {
    ASN1uint32_t count;
    GeneralNames *value;
} CrossCertDistPointNames;

typedef struct PolicyMappings {
    ASN1uint32_t count;
    struct PolicyMapping *value;
} PolicyMappings;
#define PolicyMappings_PDU 42
#define SIZE_X509_Module_PDU_42 sizeof(PolicyMappings)

typedef struct PolicyMapping {
    EncodedObjectID issuerDomainPolicy;
    EncodedObjectID subjectDomainPolicy;
} PolicyMapping;

typedef struct PolicyConstraints {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define requireExplicitPolicy_present 0x80
    SkipCerts requireExplicitPolicy;
#   define inhibitPolicyMapping_present 0x40
    SkipCerts inhibitPolicyMapping;
} PolicyConstraints;
#define PolicyConstraints_PDU 43
#define SIZE_X509_Module_PDU_43 sizeof(PolicyConstraints)

typedef struct ControlSequence {
    ASN1uint32_t count;
    struct TaggedAttribute *value;
} ControlSequence;

typedef struct ReqSequence {
    ASN1uint32_t count;
    struct TaggedRequest *value;
} ReqSequence;

typedef struct CmsSequence {
    ASN1uint32_t count;
    struct TaggedContentInfo *value;
} CmsSequence;

typedef struct OtherMsgSequence {
    ASN1uint32_t count;
    struct TaggedOtherMsg *value;
} OtherMsgSequence;

typedef struct BodyPartIDSequence {
    ASN1uint32_t count;
    BodyPartID *value;
} BodyPartIDSequence;

typedef struct TaggedAttribute {
    BodyPartID bodyPartID;
    EncodedObjectID type;
    AttributeSetValue values;
} TaggedAttribute;

typedef struct TaggedCertificationRequest {
    BodyPartID bodyPartID;
    NOCOPYANY certificationRequest;
} TaggedCertificationRequest;

typedef struct TaggedContentInfo {
    BodyPartID bodyPartID;
    NOCOPYANY contentInfo;
} TaggedContentInfo;

typedef struct TaggedOtherMsg {
    BodyPartID bodyPartID;
    EncodedObjectID otherMsgType;
    NOCOPYANY otherMsgValue;
} TaggedOtherMsg;

typedef struct PendInfo {
    OCTETSTRING pendToken;
    ASN1generalizedtime_t pendTime;
} PendInfo;

typedef struct CmcAddExtensions {
    BodyPartID pkiDataReference;
    BodyPartIDSequence certReferences;
    Extensions extensions;
} CmcAddExtensions;
#define CmcAddExtensions_PDU 44
#define SIZE_X509_Module_PDU_44 sizeof(CmcAddExtensions)

typedef struct CmcAddAttributes {
    BodyPartID pkiDataReference;
    BodyPartIDSequence certReferences;
    Attributes attributes;
} CmcAddAttributes;
#define CmcAddAttributes_PDU 45
#define SIZE_X509_Module_PDU_45 sizeof(CmcAddAttributes)

typedef struct CertificateTemplate {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EncodedObjectID templateID;
    TemplateVersion templateMajorVersion;
#   define templateMinorVersion_present 0x80
    TemplateVersion templateMinorVersion;
} CertificateTemplate;
#define CertificateTemplate_PDU 46
#define SIZE_X509_Module_PDU_46 sizeof(CertificateTemplate)

typedef struct CmcStatusInfo_otherInfo {
    ASN1choice_t choice;
    union {
#	define failInfo_chosen 1
	ASN1uint32_t failInfo;
#	define pendInfo_chosen 2
	PendInfo pendInfo;
    } u;
} CmcStatusInfo_otherInfo;

typedef struct CpsURLs_Seq {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1ztcharstring_t url;
#   define digestAlgorithmId_present 0x80
    AlgorithmIdentifier digestAlgorithmId;
#   define digest_present 0x40
    OCTETSTRING digest;
} CpsURLs_Seq;

typedef struct Attribute {
    EncodedObjectID type;
    AttributeSetValue values;
} Attribute;
#define Attribute_PDU 47
#define SIZE_X509_Module_PDU_47 sizeof(Attribute)

typedef struct X942DhParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    HUGEINTEGER p;
    HUGEINTEGER g;
    HUGEINTEGER q;
#   define j_present 0x80
    HUGEINTEGER j;
#   define validationParams_present 0x40
    X942DhValidationParams validationParams;
} X942DhParameters;
#define X942DhParameters_PDU 48
#define SIZE_X509_Module_PDU_48 sizeof(X942DhParameters)

typedef struct X942DhOtherInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    X942DhKeySpecificInfo keyInfo;
#   define pubInfo_present 0x80
    OCTETSTRING pubInfo;
    OCTETSTRING keyLength;
} X942DhOtherInfo;
#define X942DhOtherInfo_PDU 49
#define SIZE_X509_Module_PDU_49 sizeof(X942DhOtherInfo)

typedef struct CertificateToBeSigned {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define CertificateToBeSigned_version_present 0x80
    CertificateVersion version;
    CertificateSerialNumber serialNumber;
    AlgorithmIdentifier signature;
    NOCOPYANY issuer;
    Validity validity;
    NOCOPYANY subject;
    SubjectPublicKeyInfo subjectPublicKeyInfo;
#   define issuerUniqueIdentifier_present 0x40
    UniqueIdentifier issuerUniqueIdentifier;
#   define subjectUniqueIdentifier_present 0x20
    UniqueIdentifier subjectUniqueIdentifier;
#   define extensions_present 0x10
    Extensions extensions;
} CertificateToBeSigned;
#define CertificateToBeSigned_PDU 50
#define SIZE_X509_Module_PDU_50 sizeof(CertificateToBeSigned)

typedef struct CertificateRevocationListToBeSigned {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define CertificateRevocationListToBeSigned_version_present 0x80
    CRLVersion version;
    AlgorithmIdentifier signature;
    NOCOPYANY issuer;
    ChoiceOfTime thisUpdate;
#   define nextUpdate_present 0x40
    ChoiceOfTime nextUpdate;
#   define revokedCertificates_present 0x20
    RevokedCertificates revokedCertificates;
#   define crlExtensions_present 0x10
    Extensions crlExtensions;
} CertificateRevocationListToBeSigned;
#define CertificateRevocationListToBeSigned_PDU 51
#define SIZE_X509_Module_PDU_51 sizeof(CertificateRevocationListToBeSigned)

typedef struct KeyAttributes {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define KeyAttributes_keyIdentifier_present 0x80
    KeyIdentifier keyIdentifier;
#   define intendedKeyUsage_present 0x40
    KeyUsage intendedKeyUsage;
#   define privateKeyUsagePeriod_present 0x20
    PrivateKeyValidity privateKeyUsagePeriod;
} KeyAttributes;
#define KeyAttributes_PDU 52
#define SIZE_X509_Module_PDU_52 sizeof(KeyAttributes)

typedef struct KeyUsageRestriction {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define certPolicySet_present 0x80
    CertPolicySet certPolicySet;
#   define restrictedKeyUsage_present 0x40
    KeyUsage restrictedKeyUsage;
} KeyUsageRestriction;
#define KeyUsageRestriction_PDU 53
#define SIZE_X509_Module_PDU_53 sizeof(KeyUsageRestriction)

typedef struct GeneralName {
    ASN1choice_t choice;
    union {
#	define otherName_chosen 1
	OtherName otherName;
#	define rfc822Name_chosen 2
	IA5STRING rfc822Name;
#	define dNSName_chosen 3
	IA5STRING dNSName;
#	define x400Address_chosen 4
	SeqOfAny x400Address;
#	define directoryName_chosen 5
	NOCOPYANY directoryName;
#	define ediPartyName_chosen 6
	SeqOfAny ediPartyName;
#	define uniformResourceLocator_chosen 7
	IA5STRING uniformResourceLocator;
#	define iPAddress_chosen 8
	OCTETSTRING iPAddress;
#	define registeredID_chosen 9
	EncodedObjectID registeredID;
    } u;
} GeneralName;

typedef struct BasicConstraints {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SubjectType subjectType;
#   define BasicConstraints_pathLenConstraint_present 0x80
    ASN1int32_t pathLenConstraint;
#   define subtreesConstraint_present 0x40
    SubtreesConstraint subtreesConstraint;
} BasicConstraints;
#define BasicConstraints_PDU 54
#define SIZE_X509_Module_PDU_54 sizeof(BasicConstraints)

typedef struct PolicyInformation {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EncodedObjectID policyIdentifier;
#   define policyQualifiers_present 0x80
    PolicyQualifiers policyQualifiers;
} PolicyInformation;

typedef struct UserNotice {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define noticeRef_present 0x80
    NoticeReference noticeRef;
#   define explicitText_present 0x40
    DisplayText explicitText;
} UserNotice;
#define UserNotice_PDU 55
#define SIZE_X509_Module_PDU_55 sizeof(UserNotice)

typedef struct VerisignQualifier1 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define practicesReference_present 0x80
    ASN1ztcharstring_t practicesReference;
#   define noticeId_present 0x40
    EncodedObjectID noticeId;
#   define nsiNoticeId_present 0x20
    EncodedObjectID nsiNoticeId;
#   define cpsURLs_present 0x10
    CpsURLs cpsURLs;
} VerisignQualifier1;
#define VerisignQualifier1_PDU 56
#define SIZE_X509_Module_PDU_56 sizeof(VerisignQualifier1)

typedef struct AccessDescription {
    EncodedObjectID accessMethod;
    GeneralName accessLocation;
} AccessDescription;

typedef struct DistributionPoint {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define distributionPoint_present 0x80
    DistributionPointName distributionPoint;
#   define reasons_present 0x40
    ReasonFlags reasons;
#   define cRLIssuer_present 0x20
    GeneralNames cRLIssuer;
} DistributionPoint;

typedef struct ContentInfoSeqOfAny {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ContentType contentType;
#   define contentSeqOfAny_present 0x80
    SeqOfAny contentSeqOfAny;
} ContentInfoSeqOfAny;
#define ContentInfoSeqOfAny_PDU 57
#define SIZE_X509_Module_PDU_57 sizeof(ContentInfoSeqOfAny)

typedef struct CertificateTrustList {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define CertificateTrustList_version_present 0x80
    CTLVersion version;
    SubjectUsage subjectUsage;
#   define listIdentifier_present 0x40
    ListIdentifier listIdentifier;
#   define sequenceNumber_present 0x20
    HUGEINTEGER sequenceNumber;
    ChoiceOfTime ctlThisUpdate;
#   define ctlNextUpdate_present 0x10
    ChoiceOfTime ctlNextUpdate;
    AlgorithmIdentifier subjectAlgorithm;
#   define trustedSubjects_present 0x8
    TrustedSubjects trustedSubjects;
#   define ctlExtensions_present 0x4
    Extensions ctlExtensions;
} CertificateTrustList;
#define CertificateTrustList_PDU 58
#define SIZE_X509_Module_PDU_58 sizeof(CertificateTrustList)

typedef struct NameConstraints {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define permittedSubtrees_present 0x80
    GeneralSubtrees permittedSubtrees;
#   define excludedSubtrees_present 0x40
    GeneralSubtrees excludedSubtrees;
} NameConstraints;
#define NameConstraints_PDU 59
#define SIZE_X509_Module_PDU_59 sizeof(NameConstraints)

typedef struct GeneralSubtree {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    GeneralName base;
#   define minimum_present 0x80
    BaseDistance minimum;
#   define maximum_present 0x40
    BaseDistance maximum;
} GeneralSubtree;

typedef struct CrossCertDistPoints {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define syncDeltaTime_present 0x80
    ASN1uint32_t syncDeltaTime;
    CrossCertDistPointNames crossCertDistPointNames;
} CrossCertDistPoints;
#define CrossCertDistPoints_PDU 60
#define SIZE_X509_Module_PDU_60 sizeof(CrossCertDistPoints)

typedef struct CmcData {
    ControlSequence controlSequence;
    ReqSequence reqSequence;
    CmsSequence cmsSequence;
    OtherMsgSequence otherMsgSequence;
} CmcData;
#define CmcData_PDU 61
#define SIZE_X509_Module_PDU_61 sizeof(CmcData)

typedef struct CmcResponseBody {
    ControlSequence controlSequence;
    CmsSequence cmsSequence;
    OtherMsgSequence otherMsgSequence;
} CmcResponseBody;
#define CmcResponseBody_PDU 62
#define SIZE_X509_Module_PDU_62 sizeof(CmcResponseBody)

typedef struct TaggedRequest {
    ASN1choice_t choice;
    union {
#	define tcr_chosen 1
	TaggedCertificationRequest tcr;
    } u;
} TaggedRequest;

typedef struct CmcStatusInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint32_t cmcStatus;
    BodyPartIDSequence bodyList;
#   define statusString_present 0x80
    UTF8STRING statusString;
#   define otherInfo_present 0x40
    CmcStatusInfo_otherInfo otherInfo;
} CmcStatusInfo;
#define CmcStatusInfo_PDU 63
#define SIZE_X509_Module_PDU_63 sizeof(CmcStatusInfo)

extern ASN1bool_t IssuingDistributionPoint_indirectCRL_default;
extern ASN1bool_t IssuingDistributionPoint_onlyContainsCACerts_default;
extern ASN1bool_t IssuingDistributionPoint_onlyContainsUserCerts_default;
extern BaseDistance GeneralSubtree_minimum_default;
extern CTLVersion CertificateTrustList_version_default;
extern ASN1bool_t BasicConstraints2_cA_default;
extern ASN1bool_t Extension_critical_default;
extern CertificateVersion CertificateToBeSigned_version_default;

extern ASN1module_t X509_Module;
extern void ASN1CALL X509_Module_Startup(void);
extern void ASN1CALL X509_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _X509_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\chain\chain.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       chain.h
//
//  Contents:   Certificate Chaining Infrastructure
//
//  History:    13-Jan-98    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__CHAIN_H__)
#define __CHAIN_H__

#include <windows.h>
#include <wincrypt.h>
#include <winchain.h>
#include <lrucache.h>
#include <md5.h>


// All internal chain hashes are MD5 (16 bytes)
#define CHAINHASHLEN    MD5DIGESTLEN

//
// Certificate and Path Object Forward class declarations
//

class CCertObject;
class CCertIssuerList;
class CCertObjectCache;
class CCertChainEngine;
class CChainPathObject;

//
// Certificate and Path Object Class pointer typedefs
//

typedef CCertObject*       PCCERTOBJECT;
typedef CCertIssuerList*   PCCERTISSUERLIST;
typedef CCertObjectCache*  PCCERTOBJECTCACHE;
typedef CCertChainEngine*  PCCERTCHAINENGINE;
typedef CChainPathObject*  PCCHAINPATHOBJECT;

//
// SSCTL Forward class declarations
//

class CSSCtlObject;
class CSSCtlObjectCache;

//
// SSCTL Class pointer typedefs
//

typedef class CSSCtlObject*      PCSSCTLOBJECT;
typedef class CSSCtlObjectCache* PCSSCTLOBJECTCACHE;

//
// Call Context Forward class declarations
//

class CChainCallContext;

//
// Call Context class pointer typedefs
//

typedef CChainCallContext* PCCHAINCALLCONTEXT;

//
// Certificate Object Identifier.  This is a unique identifier for a certificate
// object and is the MD5 hash of the issuer and serial no.
//

typedef BYTE CERT_OBJECT_IDENTIFIER[ CHAINHASHLEN ];

//
// CCertObject types
//

#define CERT_END_OBJECT_TYPE                1
#define CERT_CACHED_END_OBJECT_TYPE         2
#define CERT_CACHED_ISSUER_OBJECT_TYPE      3
#define CERT_EXTERNAL_ISSUER_OBJECT_TYPE    4

//
// Issuer match types
//

#define CERT_EXACT_ISSUER_MATCH_TYPE        1
#define CERT_KEYID_ISSUER_MATCH_TYPE        2
#define CERT_NAME_ISSUER_MATCH_TYPE         3
#define CERT_PUBKEY_ISSUER_MATCH_TYPE       4

//
// Issuer match flags
//

#define CERT_MATCH_TYPE_TO_FLAG(MatchType)  (1 << (MatchType - 1))

#define CERT_EXACT_ISSUER_MATCH_FLAG    \
                CERT_MATCH_TYPE_TO_FLAG(CERT_EXACT_ISSUER_MATCH_TYPE)
#define CERT_KEYID_ISSUER_MATCH_FLAG    \
                CERT_MATCH_TYPE_TO_FLAG(CERT_KEYID_ISSUER_MATCH_TYPE)
#define CERT_NAME_ISSUER_MATCH_FLAG     \
                CERT_MATCH_TYPE_TO_FLAG(CERT_NAME_ISSUER_MATCH_TYPE)
#define CERT_PUBKEY_ISSUER_MATCH_FLAG   \
                CERT_MATCH_TYPE_TO_FLAG(CERT_PUBKEY_ISSUER_MATCH_TYPE)


//
// Issuer status flags
//

#define CERT_ISSUER_PUBKEY_FLAG             0x00000001
#define CERT_ISSUER_VALID_SIGNATURE_FLAG    0x00000002
#define CERT_ISSUER_URL_FLAG                0x00000004
#define CERT_ISSUER_PUBKEY_PARA_FLAG        0x00000008
#define CERT_ISSUER_SELF_SIGNED_FLAG        0x00000010
#define CERT_ISSUER_TRUSTED_ROOT_FLAG       0x00000020
#define CERT_ISSUER_EXACT_MATCH_HASH_FLAG   0x00000100
#define CERT_ISSUER_NAME_MATCH_HASH_FLAG    0x00000200

//
// Misc info flags
//

#define CHAIN_INVALID_BASIC_CONSTRAINTS_INFO_FLAG           0x00000001
#define CHAIN_INVALID_ISSUER_NAME_CONSTRAINTS_INFO_FLAG     0x00000002
#define CHAIN_INVALID_KEY_USAGE_FLAG                        0x00000004


//
// CTL cache entry used for a self signed, untrusted root CCertObject
//

typedef struct _CERT_OBJECT_CTL_CACHE_ENTRY CERT_OBJECT_CTL_CACHE_ENTRY,
    *PCERT_OBJECT_CTL_CACHE_ENTRY;
struct _CERT_OBJECT_CTL_CACHE_ENTRY {
    PCSSCTLOBJECT                   pSSCtlObject;   // AddRef'ed
    PCERT_TRUST_LIST_INFO           pTrustListInfo;
    PCERT_OBJECT_CTL_CACHE_ENTRY    pNext;
};


//
// Chain policies and usage info
//

// Issuance and application policy and usage info
typedef struct _CHAIN_ISS_OR_APP_INFO {
    PCERT_POLICIES_INFO             pPolicy;
    PCERT_POLICY_MAPPINGS_INFO      pMappings;
    PCERT_POLICY_CONSTRAINTS_INFO   pConstraints;
    PCERT_ENHKEY_USAGE              pUsage;                 // If NULL, any
    DWORD                           dwFlags;
} CHAIN_ISS_OR_APP_INFO, *PCHAIN_ISS_OR_APP_INFO;

#define CHAIN_INVALID_POLICY_FLAG       0x00000001
#define CHAIN_ANY_POLICY_FLAG           0x00000002

#define CHAIN_ISS_INDEX                 0
#define CHAIN_APP_INDEX                 1
#define CHAIN_ISS_OR_APP_COUNT          2

typedef struct _CHAIN_POLICIES_INFO {
    CHAIN_ISS_OR_APP_INFO           rgIssOrAppInfo[CHAIN_ISS_OR_APP_COUNT];

    PCERT_ENHKEY_USAGE              pPropertyUsage;         // If NULL, any
} CHAIN_POLICIES_INFO, *PCHAIN_POLICIES_INFO;

//
// Subject name constraint info
//

typedef struct _CHAIN_SUBJECT_NAME_CONSTRAINTS_INFO {
    BOOL                            fInvalid;

    // NULL pointer implies not present in the subject certificate
    PCERT_ALT_NAME_INFO             pAltNameInfo;
    PCERT_NAME_INFO                 pUnicodeNameInfo;

    // If the AltNameInfo doesn't have a RFC822 (email) choice, tries to find
    // email attribute (szOID_RSA_emailAddr) in the above pUnicodeNameInfo.
    // Note, not re-allocated.
    PCERT_RDN_ATTR                  pEmailAttr;

    // Set to TRUE if the pAltNameInfo has a DNS choice.
    BOOL                            fHasDnsAltNameEntry;
} CHAIN_SUBJECT_NAME_CONSTRAINTS_INFO, *PCHAIN_SUBJECT_NAME_CONSTRAINTS_INFO;

//
// CSSCtlObjectCache::EnumObjects callback data structure used to
// create the linked list of CTL cache entries.
//

typedef struct _CERT_OBJECT_CTL_CACHE_ENUM_DATA {
    BOOL                fResult; 
    DWORD               dwLastError;
    PCCERTOBJECT        pCertObject;
} CERT_OBJECT_CTL_CACHE_ENUM_DATA, *PCERT_OBJECT_CTL_CACHE_ENUM_DATA;


//
// CCertObject.  This is the main object used for caching information
// about a certificate
//

class CCertObject
{
public:

    //
    // Construction
    //

    CCertObject (
        IN DWORD dwObjectType,
        IN PCCHAINCALLCONTEXT pCallContext,
        IN PCCERT_CONTEXT pCertContext,
        IN BYTE rgbCertHash[CHAINHASHLEN],
        OUT BOOL& rfResult
        );

    ~CCertObject ();

    //
    // Object type
    //

    inline DWORD ObjectType();

    //
    // Convert a CERT_END_OBJECT_TYPE to a CERT_CACHED_END_OBJECT_TYPE.
    //

    BOOL CacheEndObject(
        IN PCCHAINCALLCONTEXT pCallContext
        );

    //
    // Reference counting
    //

    inline VOID AddRef ();
    inline VOID Release ();

    //
    // Chain engine access
    //

    inline PCCERTCHAINENGINE ChainEngine ();

    //
    // Issuer's match and status flags
    //

    inline DWORD IssuerMatchFlags();
    inline DWORD CachedMatchFlags();
    inline DWORD IssuerStatusFlags();
    inline VOID OrIssuerStatusFlags(IN DWORD dwFlags);
    inline VOID OrCachedMatchFlags(IN DWORD dwFlags);

    //
    // Misc Info status flags
    //

    inline DWORD InfoFlags();

    //
    // For CERT_ISSUER_SELF_SIGNED_FLAG && !CERT_ISSUER_TRUSTED_ROOT_FLAG.
    //
    // List of cached CTLs
    //

    inline PCERT_OBJECT_CTL_CACHE_ENTRY NextCtlCacheEntry(
        IN PCERT_OBJECT_CTL_CACHE_ENTRY pEntry
        );
    inline VOID InsertCtlCacheEntry(
        IN PCERT_OBJECT_CTL_CACHE_ENTRY pEntry
        );

    //
    // Object's certificate context
    //

    inline PCCERT_CONTEXT CertContext ();


    //
    // Policies and enhanced key usage obtained from certificate context's
    // extensions and property
    //

    inline PCHAIN_POLICIES_INFO PoliciesInfo ();

    //
    // Basic constraints obtained from the certificate context's
    // extensions (NULL if this extension is omitted)
    //
    inline PCERT_BASIC_CONSTRAINTS2_INFO BasicConstraintsInfo ();

    //
    // Key usage obtained from the certificate context's
    // extensions (NULL if this extension is omitted)
    //
    inline PCRYPT_BIT_BLOB KeyUsage ();

    //
    // Issuer name constraints obtained from the certificate context's
    // extensions (NULL if this extension is omitted)
    //
    inline PCERT_NAME_CONSTRAINTS_INFO IssuerNameConstraintsInfo ();

    //
    // Subject name constraint info
    //

    PCHAIN_SUBJECT_NAME_CONSTRAINTS_INFO SubjectNameConstraintsInfo ();

    //
    // Issuer access
    //

    inline PCERT_AUTHORITY_KEY_ID_INFO AuthorityKeyIdentifier ();



    //
    // Hash access
    //

    inline LPBYTE CertHash ();

    //
    // Key identifier access
    //

    inline DWORD KeyIdentifierSize ();
    inline LPBYTE KeyIdentifier ();

    //
    // Public key hash access
    //

    inline LPBYTE PublicKeyHash ();

    // Only valid when CERT_ISSUER_PUBKEY_FLAG is set in m_dwIssuerStatusFlags
    inline LPBYTE IssuerPublicKeyHash ();


    //
    // The index entry handles for cached issuer certificates.
    // The primary index entry is the hash index entry. The index entries
    // aren't LRU'ed.
    //

    inline HLRUENTRY HashIndexEntry ();
    inline HLRUENTRY IdentifierIndexEntry ();
    inline HLRUENTRY SubjectNameIndexEntry ();
    inline HLRUENTRY KeyIdIndexEntry ();
    inline HLRUENTRY PublicKeyHashIndexEntry ();


    //
    // The index entry handle for cached end certificates. This is an LRU
    // list.
    //

    inline HLRUENTRY EndHashIndexEntry ();

    //
    // Issuer match hashes. If match hash doesn't exist,
    // returns pMatchHash->cbData = 0
    //
    VOID GetIssuerExactMatchHash(
        OUT PCRYPT_DATA_BLOB pMatchHash
        );
    VOID GetIssuerKeyMatchHash(
        OUT PCRYPT_DATA_BLOB pMatchHash
        );
    VOID GetIssuerNameMatchHash(
        OUT PCRYPT_DATA_BLOB pMatchHash
        );
    

private:
    //
    // Object's type
    //

    DWORD                       m_dwObjectType;

    //
    // Reference count
    //

    LONG                        m_cRefs;

    //
    // Certificate Chain Engine which owns this certificate object (not
    // AddRef'ed)
    //

    PCCERTCHAINENGINE           m_pChainEngine;

    //
    // Issuer's match and status flags
    //
    
    DWORD                       m_dwIssuerMatchFlags;
    DWORD                       m_dwCachedMatchFlags;
    DWORD                       m_dwIssuerStatusFlags;

    //
    // Misc Info flags
    //

    DWORD                       m_dwInfoFlags;

    //
    // For CERT_ISSUER_SELF_SIGNED_FLAG && !CERT_ISSUER_TRUSTED_ROOT_FLAG.
    // Only set for CERT_CACHED_ISSUER_OBJECT_TYPE.
    //
    // List of cached CTLs
    //

    PCERT_OBJECT_CTL_CACHE_ENTRY m_pCtlCacheHead;

    //
    // Certificate context (duplicated)
    //

    PCCERT_CONTEXT              m_pCertContext;

    //
    // Policies and usage info
    //

    CHAIN_POLICIES_INFO         m_PoliciesInfo;

    //
    // Basic constraints info (NULL if this extension is omitted)
    //
    PCERT_BASIC_CONSTRAINTS2_INFO m_pBasicConstraintsInfo;

    //
    // Key usage (NULL if this extension is omitted)
    //
    PCRYPT_BIT_BLOB             m_pKeyUsage;

    //
    // Name constraints obtained from the certificate context's
    // extensions (NULL if this extension is omitted)
    //
    PCERT_NAME_CONSTRAINTS_INFO m_pIssuerNameConstraintsInfo;

    //
    // Subject name constraint info (deferred get of)
    //

    BOOL                                m_fAvailableSubjectNameConstraintsInfo;
    CHAIN_SUBJECT_NAME_CONSTRAINTS_INFO m_SubjectNameConstraintsInfo;

    //
    // Authority Key Identifier.  This contains the issuer and serial number
    // and/or key identifier of the issuing certificate for this certificate
    // object if the m_dwIssuerMatchFlags includes
    // CERT_EXACT_ISSUER_MATCH_FLAG and/or CERT_KEYID_ISSUER_MATCH_FLAG
    //

    PCERT_AUTHORITY_KEY_ID_INFO m_pAuthKeyIdentifier;


    //
    // Certificate Object Identifier (MD5 hash of issuer and serial number)
    //

    CERT_OBJECT_IDENTIFIER      m_ObjectIdentifier;

    //
    // MD5 Hash of the certificate
    //

    BYTE                        m_rgbCertHash[ CHAINHASHLEN ];

    //
    // Key Identifier of the certificate
    //

    DWORD                       m_cbKeyIdentifier;
    LPBYTE                      m_pbKeyIdentifier;

    //
    // MD5 Hash of the subject and issuer public keys
    //

    BYTE                        m_rgbPublicKeyHash[ CHAINHASHLEN ];

    // Only valid when CERT_ISSUER_PUBKEY_FLAG is set in m_dwIssuerStatusFlags
    BYTE                        m_rgbIssuerPublicKeyHash[ CHAINHASHLEN ];

    // Only valid when CERT_ISSUER_EXACT_MATCH_HASH_FLAG is set in
    // m_dwIssuerStatusFlags
    BYTE                        m_rgbIssuerExactMatchHash[ CHAINHASHLEN ];
    // Only valid when CERT_ISSUER_NAME_MATCH_HASH_FLAG is set in
    // m_dwIssuerStatusFlags
    BYTE                        m_rgbIssuerNameMatchHash[ CHAINHASHLEN ];

    //
    // Certificate Object Cache Index entries applicable to
    // CERT_CACHED_ISSUER_OBJECT_TYPE.
    //

    HLRUENTRY                   m_hHashEntry;
    HLRUENTRY                   m_hIdentifierEntry;
    HLRUENTRY                   m_hSubjectNameEntry;
    HLRUENTRY                   m_hKeyIdEntry;
    HLRUENTRY                   m_hPublicKeyHashEntry;

    //
    // Certificate Object Cache Index entries applicable to
    // CERT_CACHED_END_OBJECT_TYPE.
    //

    HLRUENTRY                   m_hEndHashEntry;
};

//
//  Chain quality values (ascending order)
//

#define CERT_QUALITY_SIMPLE_CHAIN                   0x00000001
#define CERT_QUALITY_CHECK_REVOCATION               0x00000010
#define CERT_QUALITY_ONLINE_REVOCATION              0x00000020
#define CERT_QUALITY_PREFERRED_ISSUER               0x00000040

#define CERT_QUALITY_HAS_APPLICATION_USAGE          0x00000080

#define CERT_QUALITY_HAS_ISSUANCE_CHAIN_POLICY      0x00000100
#define CERT_QUALITY_POLICY_CONSTRAINTS_VALID       0x00000200
#define CERT_QUALITY_BASIC_CONSTRAINTS_VALID        0x00000400
#define CERT_QUALITY_HAS_NAME_CONSTRAINTS           0x00000800
#define CERT_QUALITY_NAME_CONSTRAINTS_VALID         0x00001000
#define CERT_QUALITY_NAME_CONSTRAINTS_MET           0x00002000


#define CERT_QUALITY_NOT_REVOKED                    0x00100000
#define CERT_QUALITY_TIME_VALID                     0x00200000
#define CERT_QUALITY_MEETS_USAGE_CRITERIA           0x00400000
#define CERT_QUALITY_NOT_CYCLIC                     0x00800000
#define CERT_QUALITY_HAS_TIME_VALID_TRUSTED_ROOT    0x01000000
#define CERT_QUALITY_HAS_TRUSTED_ROOT               0x02000000
#define CERT_QUALITY_COMPLETE_CHAIN                 0x04000000
#define CERT_QUALITY_SIGNATURE_VALID                0x08000000



#define CERT_TRUST_CERTIFICATE_ONLY_INFO_STATUS ( CERT_TRUST_IS_SELF_SIGNED |\
                                                  CERT_TRUST_HAS_EXACT_MATCH_ISSUER |\
                                                  CERT_TRUST_HAS_NAME_MATCH_ISSUER |\
                                                  CERT_TRUST_HAS_KEY_MATCH_ISSUER )


#define CERT_CHAIN_REVOCATION_CHECK_ALL ( CERT_CHAIN_REVOCATION_CHECK_END_CERT | \
                                          CERT_CHAIN_REVOCATION_CHECK_CHAIN | \
                                          CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT | \
                                          CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY )

#define CERT_TRUST_ANY_NAME_CONSTRAINT_ERROR_STATUS ( \
                    CERT_TRUST_INVALID_NAME_CONSTRAINTS             | \
                    CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT    | \
                    CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT      | \
                    CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT    | \
                    CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT )


//
// Internal chain context. Wraps the exposed CERT_CHAIN_CONTEXT.
//

typedef struct _INTERNAL_CERT_CHAIN_CONTEXT INTERNAL_CERT_CHAIN_CONTEXT,
                                                *PINTERNAL_CERT_CHAIN_CONTEXT;
struct _INTERNAL_CERT_CHAIN_CONTEXT {
    CERT_CHAIN_CONTEXT              ChainContext;
    LONG                            cRefs;
    DWORD                           dwQuality;
    PINTERNAL_CERT_CHAIN_CONTEXT    pNext;
};

//
// Restricted issuance, application and property usage as we move from the
// top down to the end certificate
//

// Note, NULL PCERT_ENHKEY_USAGE implies any
typedef struct _CHAIN_RESTRICTED_USAGE_INFO {
    PCERT_ENHKEY_USAGE              pIssuanceRestrictedUsage;
    PCERT_ENHKEY_USAGE              pIssuanceMappedUsage;
    LPDWORD                         rgdwIssuanceMappedIndex;
    BOOL                            fRequireIssuancePolicy;

    PCERT_ENHKEY_USAGE              pApplicationRestrictedUsage;
    PCERT_ENHKEY_USAGE              pApplicationMappedUsage;
    LPDWORD                         rgdwApplicationMappedIndex;

    PCERT_ENHKEY_USAGE              pPropertyRestrictedUsage;
} CHAIN_RESTRICTED_USAGE_INFO, *PCHAIN_RESTRICTED_USAGE_INFO;

//
// Forward reference to the issuer element
//

typedef struct _CERT_ISSUER_ELEMENT CERT_ISSUER_ELEMENT, *PCERT_ISSUER_ELEMENT;

//
// CChainPathObject.  This is the main object used for building the
// chain graph.
//
// Note, since this object isn't persisted across calls, NO REF COUNTING is
// done.
//
class CChainPathObject
{
public:
    //
    // Construction
    //

    CChainPathObject (
        IN PCCHAINCALLCONTEXT pCallContext,
        IN BOOL fCyclic,
        IN LPVOID pvObject,             // fCyclic : pPathObject ? pCertObject
        IN OPTIONAL HCERTSTORE hAdditionalStore,
        OUT BOOL& rfResult,
        OUT BOOL& rfAddedToCreationCache
        );

    ~CChainPathObject ();


    //
    // Certificate Object (AddRef'ed)
    //

    inline PCCERTOBJECT CertObject ();

    //
    // Pass 1 quality
    //

    inline DWORD Pass1Quality ();
    inline VOID SetPass1Quality (IN DWORD dwQuality);

    //
    // Returns TRUE if we have completed the initialization and addition
    // of issuers to this object. FALSE would normally indicate a cyclic
    // issuer.
    //

    inline BOOL IsCompleted ();

    //
    // AdditionalStatus flag and down path object
    //

    inline BOOL HasAdditionalStatus ();
    inline PCCHAINPATHOBJECT DownPathObject ();

    //
    // Find and add issuers
    //
    
    BOOL FindAndAddIssuers (
        IN PCCHAINCALLCONTEXT pCallContext,
        IN OPTIONAL HCERTSTORE hAdditionalStore,
        IN OPTIONAL HCERTSTORE hIssuerUrlStore
        );
    BOOL FindAndAddIssuersByMatchType(
        IN DWORD dwMatchType,
        IN PCCHAINCALLCONTEXT pCallContext,
        IN OPTIONAL HCERTSTORE hAdditionalStore,
        IN OPTIONAL HCERTSTORE hIssuerUrlStore
        );
    BOOL FindAndAddIssuersFromCacheByMatchType(
        IN DWORD dwMatchType,
        IN PCCHAINCALLCONTEXT pCallContext,
        IN OPTIONAL HCERTSTORE hAdditionalStore
        );
    BOOL FindAndAddIssuersFromStoreByMatchType(
        IN DWORD dwMatchType,
        IN PCCHAINCALLCONTEXT pCallContext,
        IN BOOL fExternalStore,
        IN OPTIONAL HCERTSTORE hAdditionalStore,
        IN OPTIONAL HCERTSTORE hIssuerUrlStore
        );

    BOOL FindAndAddCtlIssuersFromCache (
        IN PCCHAINCALLCONTEXT pCallContext,
        IN OPTIONAL HCERTSTORE hAdditionalStore
        );
    BOOL FindAndAddCtlIssuersFromAdditionalStore (
        IN PCCHAINCALLCONTEXT pCallContext,
        IN HCERTSTORE hAdditionalStore
        );

    //
    // Builds the top down chain graph for the next top object
    //

    PCCHAINPATHOBJECT NextPath (
        IN PCCHAINCALLCONTEXT pCallContext,
        IN OPTIONAL PCCHAINPATHOBJECT pPrevTopPathObject
        );

    VOID CalculateAdditionalStatus (
        IN PCCHAINCALLCONTEXT pCallContext,
        IN HCERTSTORE hAllStore
        );
    VOID CalculatePolicyConstraintsStatus ();
    VOID CalculateBasicConstraintsStatus ();
    VOID CalculateKeyUsageStatus ();
    VOID CalculateNameConstraintsStatus (
        IN PCERT_USAGE_MATCH pUsageToUse
        );
    VOID CalculateRevocationStatus (
        IN PCCHAINCALLCONTEXT pCallContext,
        IN HCERTSTORE hCrlStore,
        IN LPFILETIME pTime
        );

    PINTERNAL_CERT_CHAIN_CONTEXT CreateChainContextFromPath (
        IN PCCHAINCALLCONTEXT pCallContext,
        IN PCCHAINPATHOBJECT pTopPathObject
        );

    BOOL UpdateChainContextUsageForPathObject (
        IN PCCHAINCALLCONTEXT pCallContext,
        IN OUT PCERT_SIMPLE_CHAIN pChain,
        IN OUT PCERT_CHAIN_ELEMENT pElement,
        IN OUT PCHAIN_RESTRICTED_USAGE_INFO pRestrictedUsageInfo
        );

    BOOL UpdateChainContextFromPathObject (
        IN PCCHAINCALLCONTEXT pCallContext,
        IN OUT PCERT_SIMPLE_CHAIN pChain,
        IN OUT PCERT_CHAIN_ELEMENT pElement
        );

    //
    // AuthRoot Auto Update CTL Methods
    //
    BOOL GetAuthRootAutoUpdateUrlStore(
        IN PCCHAINCALLCONTEXT pCallContext,
        OUT HCERTSTORE *phIssuerUrlStore
        );

private:
    //
    // Certificate Object (AddRef'ed)
    //

    PCCERTOBJECT            m_pCertObject;

    //
    // Trust Status.  This does not represent the full trust status
    // for the object.  Some of the bits are calculated on demand and placed
    // into the ending chain context.  The following are the trust status
    // bits which can appear here
    //
    // CERT_TRUST_IS_SELF_SIGNED
    // CERT_TRUST_HAS_EXACT_MATCH_ISSUER
    // CERT_TRUST_HAS_NAME_MATCH_ISSUER
    // CERT_TRUST_HAS_KEY_MATCH_ISSUER
    //
    // CERT_TRUST_IS_NOT_SIGNATURE_VALID (if the certificate is self-signed)
    // CERT_TRUST_IS_UNTRUSTED_ROOT (if the certificate is self-signed)
    // CERT_TRUST_HAS_PREFERRED_ISSUER (if the certificate is self-signed)
    //
    // CERT_TRUST_IS_CYCLIC (for cyclic cert)
    //

    CERT_TRUST_STATUS       m_TrustStatus;

    // Pass1 Quality is limited to the following:
    //  CERT_QUALITY_NOT_CYCLIC
    //  CERT_QUALITY_HAS_TIME_VALID_TRUSTED_ROOT
    //  CERT_QUALITY_HAS_TRUSTED_ROOT
    //  CERT_QUALITY_SIGNATURE_VALID
    //  CERT_QUALITY_COMPLETE_CHAIN

    DWORD                   m_dwPass1Quality;

    //
    //  The chain context's chain and element indices
    //

    DWORD                   m_dwChainIndex;
    DWORD                   m_dwElementIndex;

    //
    // Down and up path pointers for a chain context
    //

    PCERT_ISSUER_ELEMENT    m_pDownIssuerElement;
    PCCHAINPATHOBJECT       m_pDownPathObject;
    PCERT_ISSUER_ELEMENT    m_pUpIssuerElement;

    //
    // Additional status and revocation info (only applicable to self signed
    // certificates or top certificates without any issuers)
    //

    BOOL                    m_fHasAdditionalStatus;
    CERT_TRUST_STATUS       m_AdditionalStatus;
    BOOL                    m_fHasRevocationInfo;
    CERT_REVOCATION_INFO    m_RevocationInfo;
    CERT_REVOCATION_CRL_INFO m_RevocationCrlInfo;


    //
    // Issuer Chain Path Objects.  The list of issuers of this
    // certificate object along with information about those issuers
    // relevant to this subject.
    //

    PCCERTISSUERLIST        m_pIssuerList;

    //
    // Supplemental error information is localization formatted and appended.
    // Each error line should be terminated with a L'\n'.
    //
    LPWSTR                  m_pwszExtendedErrorInfo;

    //
    // Following flag is set when we have completed the initialization and
    // addition of all issuers to this object.
    //
    BOOL                    m_fCompleted;
};


//
// CCertIssuerList.  List of issuer certificate objects along with related
// issuer information.  This is used by the certificate object to cache
// its possible set of issuers
//

// Currently in a self signed certificate object, the issuer elements will
// have CTL issuer data set and pIssuer may be NULL if unable to find 
// the CTL signer

typedef struct _CTL_ISSUER_DATA {
    PCSSCTLOBJECT         pSSCtlObject;     // AddRef'ed
    PCERT_TRUST_LIST_INFO pTrustListInfo;
} CTL_ISSUER_DATA, *PCTL_ISSUER_DATA;

struct _CERT_ISSUER_ELEMENT {
    DWORD                        dwPass1Quality;
    CERT_TRUST_STATUS            SubjectStatus;
    BOOL                         fCtlIssuer;
    PCCHAINPATHOBJECT            pIssuer;

    // For a cyclic issuer, the above pIssuer is saved into the following
    // before it is updated with the cyclic issuer path object
    PCCHAINPATHOBJECT            pCyclicSaveIssuer;

    PCTL_ISSUER_DATA             pCtlIssuerData;
    struct _CERT_ISSUER_ELEMENT* pPrevElement;
    struct _CERT_ISSUER_ELEMENT* pNextElement;
    BOOL                         fHasRevocationInfo;
    CERT_REVOCATION_INFO         RevocationInfo;
    CERT_REVOCATION_CRL_INFO     RevocationCrlInfo;
};

class CCertIssuerList
{
public:

    //
    // Construction
    //

    CCertIssuerList (
         IN PCCHAINPATHOBJECT pSubject
         );

    ~CCertIssuerList ();

    //
    // Issuer management
    //

    inline BOOL IsEmpty ();

    BOOL AddIssuer(
            IN PCCHAINCALLCONTEXT pCallContext,
            IN OPTIONAL HCERTSTORE hAdditionalStore,
            IN PCCERTOBJECT pIssuer
            );

    BOOL AddCtlIssuer(
            IN PCCHAINCALLCONTEXT pCallContext,
            IN OPTIONAL HCERTSTORE hAdditionalStore,
            IN PCSSCTLOBJECT pSSCtlObject,
            IN PCERT_TRUST_LIST_INFO pTrustListInfo
            );

    //
    // Element management
    //

    BOOL CreateElement(
            IN PCCHAINCALLCONTEXT pCallContext,
            IN BOOL fCtlIssuer,
            IN OPTIONAL PCCHAINPATHOBJECT pIssuer,
            IN OPTIONAL HCERTSTORE hAdditionalStore,
            IN OPTIONAL PCSSCTLOBJECT pSSCtlObject,
            IN OPTIONAL PCERT_TRUST_LIST_INFO pTrustListInfo,
            OUT PCERT_ISSUER_ELEMENT* ppElement
            );


    VOID DeleteElement (
               IN PCERT_ISSUER_ELEMENT pElement
               );

    inline VOID AddElement (
                   IN PCERT_ISSUER_ELEMENT pElement
                   );

    inline VOID RemoveElement (
                      IN PCERT_ISSUER_ELEMENT pElement
                      );

    BOOL CheckForDuplicateElement (
              IN BYTE rgbHash [ CHAINHASHLEN ],
              IN BOOL fCtlIssuer
              );

    //
    // Enumerate the issuers
    //

    inline PCERT_ISSUER_ELEMENT NextElement (
                                    IN PCERT_ISSUER_ELEMENT pElement
                                    );

private:

    //
    // Subject chain path object
    //

    PCCHAINPATHOBJECT     m_pSubject;

    //
    // Issuer List
    //

    PCERT_ISSUER_ELEMENT  m_pHead;

};


//
// CCertObjectCache.
//
// Cache of issuer certificate object references indexed by the following keys:
//      Certificate Hash
//      Certificate Object Identifier
//      Subject Name
//      Key Identifier
//      Public Key Hash
//
// Cache of end certificate object references indexed by the following keys:
//      End Certificate Hash
//
// Only the end certificate is LRU maintained.
//

#define DEFAULT_CERT_OBJECT_CACHE_BUCKETS 127
#define DEFAULT_MAX_INDEX_ENTRIES         256

class CCertObjectCache
{
public:

    //
    // Construction
    //

    CCertObjectCache (
         IN DWORD MaxIndexEntries,
         OUT BOOL& rfResult
         );

    ~CCertObjectCache ();

    //
    // Certificate Object Management
    //

    // Increments engine's touch count
    VOID AddIssuerObject (
            IN PCCHAINCALLCONTEXT pCallContext,
            IN PCCERTOBJECT pCertObject
            );

    VOID AddEndObject (
            IN PCCHAINCALLCONTEXT pCallContext,
            IN PCCERTOBJECT pCertObject
            );

    //
    // Access the indexes
    //

    inline HLRUCACHE HashIndex ();

    inline HLRUCACHE IdentifierIndex ();

    inline HLRUCACHE SubjectNameIndex ();

    inline HLRUCACHE KeyIdIndex ();

    inline HLRUCACHE PublicKeyHashIndex ();

    inline HLRUCACHE EndHashIndex ();

    //
    // Certificate Object Searching
    //

    PCCERTOBJECT FindIssuerObject (
                     IN HLRUCACHE hIndex,
                     IN PCRYPT_DATA_BLOB pIdentifier
                     );

    PCCERTOBJECT FindIssuerObjectByHash (
                     IN BYTE rgbCertHash[ CHAINHASHLEN ]
                     );

    PCCERTOBJECT FindEndObjectByHash (
                     IN BYTE rgbCertHash[ CHAINHASHLEN ]
                     );

    //
    // Certificate Object Enumeration
    //

    PCCERTOBJECT NextMatchingIssuerObject (
                     IN HLRUENTRY hObjectEntry,
                     IN PCCERTOBJECT pCertObject
                     );

    //
    // Cache flushing
    //

    inline VOID FlushObjects (IN PCCHAINCALLCONTEXT pCallContext);

private:

    //
    // Certificate Hash Index
    //

    HLRUCACHE m_hHashIndex;

    //
    // Certificate Object Identifier Index
    //

    HLRUCACHE m_hIdentifierIndex;

    //
    // Subject Name Index
    //

    HLRUCACHE m_hSubjectNameIndex;

    //
    // Key Identifier Index
    //

    HLRUCACHE m_hKeyIdIndex;

    //
    // Public Key Hash Index
    //

    HLRUCACHE m_hPublicKeyHashIndex;

    //
    // End Certificate Hash Index
    //

    HLRUCACHE m_hEndHashIndex;

    //
    // Private methods
    //
};



typedef struct _XCERT_DP_ENTRY XCERT_DP_ENTRY, *PXCERT_DP_ENTRY;
typedef struct _XCERT_DP_LINK XCERT_DP_LINK, *PXCERT_DP_LINK;

//
// Cross Certificate Distribution Point Entry
//

struct _XCERT_DP_ENTRY {
    // Seconds between syncs
    DWORD               dwSyncDeltaTime;

    // List of NULL terminated Urls. A successfully retrieved Url
    // pointer is moved to the beginning of the list.
    DWORD               cUrl;
    LPWSTR              *rgpwszUrl;

    // Time of last sync
    FILETIME            LastSyncTime;

    // If dwOfflineCnt == 0, NextSyncTime = LastSyncTime + dwSyncDeltaTime.
    // Otherwise, NextSyncTime = CurrentTime +
    //                rgdwChainOfflineUrlDeltaSeconds[dwOfflineCnt - 1]
    FILETIME            NextSyncTime;

    // Following is incremented when unable to do an online Url retrieval.
    // A successful Url retrieval resets.
    DWORD               dwOfflineCnt;

    // Following is incremented for each new scan through the DP entries
    DWORD               dwResyncIndex;

    // Following is set when this entry has already been checked
    BOOL                fChecked;
    
    PXCERT_DP_LINK      pChildCrossCertDPLink;
    LONG                lRefCnt;
    HCERTSTORE          hUrlStore;
    PXCERT_DP_ENTRY     pNext;
    PXCERT_DP_ENTRY     pPrev;
};


//
// Cross Certificate Distribution Point Link
//

struct _XCERT_DP_LINK {
    PXCERT_DP_ENTRY     pCrossCertDPEntry;
    PXCERT_DP_LINK      pNext;
    PXCERT_DP_LINK      pPrev;
};


//
// AuthRoot Auto Update Info
//

#define AUTH_ROOT_KEY_MATCH_IDX         0
#define AUTH_ROOT_NAME_MATCH_IDX        1
#define AUTH_ROOT_MATCH_CNT             2

#define AUTH_ROOT_MATCH_CACHE_BUCKETS   61

typedef struct _AUTH_ROOT_AUTO_UPDATE_INFO {
    // Seconds between syncs
    DWORD               dwSyncDeltaTime;

    // Registry Flags value
    DWORD               dwFlags;

    // URL to the directory containing the AuthRoots
    LPWSTR              pwszRootDirUrl;

    // URL to the CAB containing the CTL containing the complete list of roots
    // in the AuthRoot store
    LPWSTR              pwszCabUrl;

    // URL to the SequenceNumber file corresponding to the latest list of
    // roots in the AuthRoot store
    LPWSTR              pwszSeqUrl;

    // Time of last sync
    FILETIME            LastSyncTime;

    // NextSyncTime = LastSyncTime + dwSyncDeltaTime.
    FILETIME            NextSyncTime;

    // If nonNull, a validated AuthRoot CTL.
    PCCTL_CONTEXT       pCtl;

    // Cache of CTL entries via their key and name match hashes. The
    // Cache entry value is the PCTL_ENTRY pointer.
    HLRUCACHE           rghMatchCache[AUTH_ROOT_MATCH_CNT];

} AUTH_ROOT_AUTO_UPDATE_INFO, *PAUTH_ROOT_AUTO_UPDATE_INFO;

// 7 days
#define AUTH_ROOT_AUTO_UPDATE_SYNC_DELTA_TIME   (60 * 60 * 24 * 7)

#define AUTH_ROOT_AUTO_UPDATE_ROOT_DIR_URL      L"http://www.download.windowsupdate.com/msdownload/update/v3/static/trustedr/en"


//
// CCertChainEngine.  The chaining engine satisfies requests for chain contexts
// given some set of parameters.  In order to make the building of these
// contexts efficient, the chain engine caches trust and chain information
// for certificates
//

class CCertChainEngine
{
public:

    //
    // Construction
    //

    CCertChainEngine (
         IN PCERT_CHAIN_ENGINE_CONFIG pConfig,
         IN BOOL fDefaultEngine,
         OUT BOOL& rfResult
         );

    ~CCertChainEngine ();

    //
    // Chain Engine Locking
    //

    inline VOID LockEngine ();
    inline VOID UnlockEngine ();

    //
    // Chain Engine reference counting
    //

    inline VOID AddRef ();
    inline VOID Release ();

    //
    // Cache access
    //

    inline PCCERTOBJECTCACHE CertObjectCache ();
    inline PCSSCTLOBJECTCACHE SSCtlObjectCache ();

    //
    // Store access
    //

    inline HCERTSTORE RootStore ();
    inline HCERTSTORE RealRootStore ();
    inline HCERTSTORE TrustStore ();
    inline HCERTSTORE OtherStore ();
    inline HCERTSTORE CAStore ();

    //
    // Open the HKLM or HKCU "trust" store. Caller must close.
    //

    inline HCERTSTORE OpenTrustStore ();

    //
    // Engine's Url retrieval timeout
    //

    inline DWORD UrlRetrievalTimeout ();
    inline BOOL HasDefaultUrlRetrievalTimeout ();

    //
    // Engine's Flags
    //

    inline DWORD Flags ();

    //
    // Engine Touching
    //

    inline DWORD TouchEngineCount ();
    inline DWORD IncrementTouchEngineCount ();

    //
    // Chain Context Retrieval
    //

    BOOL GetChainContext (
            IN PCCERT_CONTEXT pCertContext,
            IN LPFILETIME pTime,
            IN HCERTSTORE hAdditionalStore,
            IN OPTIONAL PCERT_CHAIN_PARA pChainPara,
            IN DWORD dwFlags,
            IN LPVOID pvReserved,
            OUT PCCERT_CHAIN_CONTEXT* ppChainContext
            );

    BOOL CreateChainContextFromPathGraph (
            IN PCCHAINCALLCONTEXT pCallContext,
            IN PCCERT_CONTEXT pCertContext,
            IN HCERTSTORE hAdditionalStore,
            OUT PCCERT_CHAIN_CONTEXT* ppChainContext
            );

    // Leaves Engine's lock to do URL fetching
    BOOL GetIssuerUrlStore(
        IN PCCHAINCALLCONTEXT pCallContext,
        IN PCCERT_CONTEXT pSubjectCertContext,
        IN DWORD dwRetrievalFlags,
        OUT HCERTSTORE *phIssuerUrlStore
        );

    // Engine isn't locked on entry. Only called if online.
    HCERTSTORE GetNewerIssuerUrlStore(
        IN PCCHAINCALLCONTEXT pCallContext,
        IN PCCERT_CONTEXT pSubjectCertContext,
        IN PCCERT_CONTEXT pIssuerCertContext
        );


    //
    // Resync the engine
    //

    BOOL Resync (IN PCCHAINCALLCONTEXT pCallContext, BOOL fForce);


    //
    // Cross Certificate Methods implemented in xcert.cpp
    //

    void
    InsertCrossCertDistPointEntry(
        IN OUT PXCERT_DP_ENTRY pEntry
        );
    void
    RemoveCrossCertDistPointEntry(
        IN OUT PXCERT_DP_ENTRY pEntry
        );

    void
    RepositionOnlineCrossCertDistPointEntry(
        IN OUT PXCERT_DP_ENTRY pEntry,
        IN LPFILETIME pLastSyncTime
        );
    void
    RepositionOfflineCrossCertDistPointEntry(
        IN OUT PXCERT_DP_ENTRY pEntry,
        IN LPFILETIME pCurrentTime
        );
    void
    RepositionNewSyncDeltaTimeCrossCertDistPointEntry(
        IN OUT PXCERT_DP_ENTRY pEntry,
        IN DWORD dwSyncDeltaTime
        );

    PXCERT_DP_ENTRY
    CreateCrossCertDistPointEntry(
        IN DWORD dwSyncDeltaTime,
        IN DWORD cUrl,
        IN LPWSTR *rgpwszUrl
        );
    void
    AddRefCrossCertDistPointEntry(
        IN OUT PXCERT_DP_ENTRY pEntry
        );
    BOOL
    ReleaseCrossCertDistPointEntry(
        IN OUT PXCERT_DP_ENTRY pEntry
        );

    BOOL
    GetCrossCertDistPointsForStore(
        IN HCERTSTORE hStore,
        IN OUT PXCERT_DP_LINK *ppLinkHead
        );

    void
    RemoveCrossCertDistPointOrphanEntry(
        IN PXCERT_DP_ENTRY pOrphanEntry
        );
    void
    FreeCrossCertDistPoints(
        IN OUT PXCERT_DP_LINK *ppLinkHead
        );

    BOOL
    RetrieveCrossCertUrl(
        IN PCCHAINCALLCONTEXT pCallContext,
        IN OUT PXCERT_DP_ENTRY pEntry,
        IN DWORD dwRetrievalFlags,
        IN OUT BOOL *pfTimeValid
        );
    BOOL
    UpdateCrossCerts(
        IN PCCHAINCALLCONTEXT pCallContext
        );



    //
    // AuthRoot Auto Update CTL Methods
    //

    inline PAUTH_ROOT_AUTO_UPDATE_INFO AuthRootAutoUpdateInfo();

    BOOL
    RetrieveAuthRootAutoUpdateObjectByUrlW(
        IN PCCHAINCALLCONTEXT pCallContext,
        IN DWORD dwSuccessEventID,
        IN DWORD dwFailEventID,
        IN LPCWSTR pwszUrl,
        IN LPCSTR pszObjectOid,
        IN DWORD dwRetrievalFlags,
        IN DWORD dwTimeout,         // 0 => use default
        OUT LPVOID* ppvObject,
        IN OPTIONAL PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
        );

    BOOL
    GetAuthRootAutoUpdateCtl(
        IN PCCHAINCALLCONTEXT pCallContext,
        OUT PCCTL_CONTEXT *ppCtl
        );

    VOID
    FindAuthRootAutoUpdateMatchingCtlEntries(
        IN CRYPT_DATA_BLOB rgMatchHash[AUTH_ROOT_MATCH_CNT],
        IN OUT PCCTL_CONTEXT *ppCtl,
        OUT DWORD *pcCtlEntry,
        OUT PCTL_ENTRY **prgpCtlEntry
        );

    BOOL
    GetAuthRootAutoUpdateCert(
        IN PCCHAINCALLCONTEXT pCallContext,
        IN PCTL_ENTRY pCtlEntry,
        IN OUT HCERTSTORE hStore
        );

private:

    //
    // Reference count
    //

    LONG                     m_cRefs;

    //
    // Engine Lock
    //

    CRITICAL_SECTION         m_Lock;

    //
    // Root store ( Certs )
    //

    HCERTSTORE               m_hRealRootStore;
    HCERTSTORE               m_hRootStore;

    //
    // Trust Store Collection ( CTLs )
    //

    HCERTSTORE               m_hTrustStore;

    //
    // Other store collection ( Certs and CRLs )
    //

    HCERTSTORE               m_hOtherStore;
    HCERTSTORE               m_hCAStore;

    //
    // Engine Store ( Collection of Root, Trust and Other )
    //

    HCERTSTORE               m_hEngineStore;

    //
    // Engine Store Change Notification Event
    //

    HANDLE                   m_hEngineStoreChangeEvent;

    //
    // Engine flags
    //

    DWORD                    m_dwFlags;

    //
    // Retrieval timeout
    //

    DWORD                    m_dwUrlRetrievalTimeout;
    BOOL                     m_fDefaultUrlRetrievalTimeout;

    //
    // Certificate Object Cache
    //

    PCCERTOBJECTCACHE        m_pCertObjectCache;

    //
    // Self Signed Certificate Trust List Object Cache
    //

    PCSSCTLOBJECTCACHE       m_pSSCtlObjectCache;


    //
    // Engine Touching
    //

    DWORD                    m_dwTouchEngineCount;

    //
    // Cross Certificate
    //

    // List of all distribution point entries. Ordered according to
    // the entrys' NextSyncTime.
    PXCERT_DP_ENTRY          m_pCrossCertDPEntry;

    // List of engine's distribution point links
    PXCERT_DP_LINK           m_pCrossCertDPLink;

    // Collection of cross cert stores
    HCERTSTORE               m_hCrossCertStore;

    // Following index is advanced for each new scan to find cross cert
    // distribution points to resync
    DWORD                    m_dwCrossCertDPResyncIndex;

    //
    // AuthRoot Auto Update Info. Created first time we have a partial chain
    // or a untrusted root and auto update has been enabled.
    //
    PAUTH_ROOT_AUTO_UPDATE_INFO m_pAuthRootAutoUpdateInfo;
};


//+===========================================================================
//  CCertObject inline methods
//============================================================================

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::ObjectType, public
//
//  Synopsis:   return the object type
//
//----------------------------------------------------------------------------
inline DWORD
CCertObject::ObjectType ()
{
    return( m_dwObjectType );
}
 
//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::AddRef, public
//
//  Synopsis:   add a reference to the certificate object
//
//----------------------------------------------------------------------------
inline VOID
CCertObject::AddRef ()
{
    InterlockedIncrement( &m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::Release, public
//
//  Synopsis:   remove a reference from the certificate object
//
//----------------------------------------------------------------------------
inline VOID
CCertObject::Release ()
{
    if ( InterlockedDecrement( &m_cRefs ) == 0 )
    {
        delete this;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::ChainEngine, public
//
//  Synopsis:   return the chain engine object
//
//----------------------------------------------------------------------------
inline PCCERTCHAINENGINE
CCertObject::ChainEngine ()
{
    return( m_pChainEngine );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::IssuerMatchFlags, public
//
//  Synopsis:   return the issuer match flags
//
//----------------------------------------------------------------------------
inline DWORD
CCertObject::IssuerMatchFlags ()
{
    return( m_dwIssuerMatchFlags );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::CachedMatchFlags, public
//
//  Synopsis:   return the cached match flags
//
//----------------------------------------------------------------------------
inline DWORD
CCertObject::CachedMatchFlags ()
{
    return( m_dwCachedMatchFlags );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::IssuerStatusFlags, public
//
//  Synopsis:   return the issuer status flags
//
//----------------------------------------------------------------------------
inline DWORD
CCertObject::IssuerStatusFlags ()
{
    return( m_dwIssuerStatusFlags );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::OrIssuerStatusFlags, public
//
//  Synopsis:   'or' bits into the issuer status flags.
//
//----------------------------------------------------------------------------
inline VOID
CCertObject::OrIssuerStatusFlags(
        IN DWORD dwFlags
        )
{
    m_dwIssuerStatusFlags |= dwFlags;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::OrCachedMatchFlags, public
//
//  Synopsis:   'or' bits into the cached match flags
//
//
//----------------------------------------------------------------------------
inline VOID
CCertObject::OrCachedMatchFlags(
        IN DWORD dwFlags
        )
{
    m_dwCachedMatchFlags |= dwFlags;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::InfoFlags, public
//
//  Synopsis:   return the misc info flags
//
//----------------------------------------------------------------------------
inline DWORD
CCertObject::InfoFlags ()
{
    return( m_dwInfoFlags );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::NextCtlCacheEntry, public
//
//  Synopsis:   return the next entry, if pEntry == NULL the first entry
//              is returned
//
//----------------------------------------------------------------------------
inline PCERT_OBJECT_CTL_CACHE_ENTRY
CCertObject::NextCtlCacheEntry(
    IN PCERT_OBJECT_CTL_CACHE_ENTRY pEntry
    )
{
    if (NULL == pEntry)
        return m_pCtlCacheHead;
    else
        return pEntry->pNext;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::InsertCtlCacheEntry, public
//
//  Synopsis:   insert an entry into the Ctl cache
//
//----------------------------------------------------------------------------
inline VOID
CCertObject::InsertCtlCacheEntry(
    IN PCERT_OBJECT_CTL_CACHE_ENTRY pEntry
    )
{
    pEntry->pNext = m_pCtlCacheHead;
    m_pCtlCacheHead = pEntry;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::CertContext, public
//
//  Synopsis:   return the certificate context
//
//----------------------------------------------------------------------------
inline PCCERT_CONTEXT
CCertObject::CertContext ()
{
    return( m_pCertContext );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::PoliciesInfo, public
//
//  Synopsis:   return pointer to the policies and usage info
//
//----------------------------------------------------------------------------
inline PCHAIN_POLICIES_INFO
CCertObject::PoliciesInfo ()
{
    return( &m_PoliciesInfo );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::BasicConstraintsInfo, public
//
//  Synopsis:   return the basic constraints info pointer
//
//----------------------------------------------------------------------------
inline PCERT_BASIC_CONSTRAINTS2_INFO
CCertObject::BasicConstraintsInfo ()
{
    return( m_pBasicConstraintsInfo );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::KeyUsage, public
//
//  Synopsis:   return the key usage pointer
//
//----------------------------------------------------------------------------
inline PCRYPT_BIT_BLOB
CCertObject::KeyUsage ()
{
    return( m_pKeyUsage );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::IssuerNameConstraintsInfo, public
//
//  Synopsis:   return the issuer name constraints info pointer
//
//----------------------------------------------------------------------------
inline PCERT_NAME_CONSTRAINTS_INFO
CCertObject::IssuerNameConstraintsInfo ()
{
    return( m_pIssuerNameConstraintsInfo );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::AuthorityKeyIdentifier, public
//
//  Synopsis:   return the issuer authority key identifier information
//
//----------------------------------------------------------------------------
inline PCERT_AUTHORITY_KEY_ID_INFO
CCertObject::AuthorityKeyIdentifier ()
{
    return( m_pAuthKeyIdentifier );
}


//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::CertHash, public
//
//  Synopsis:   return the certificate hash
//
//----------------------------------------------------------------------------
inline LPBYTE
CCertObject::CertHash ()
{
    return( m_rgbCertHash );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::KeyIdentifierSize, public
//
//  Synopsis:   return the key identifier blob size
//
//----------------------------------------------------------------------------
inline DWORD
CCertObject::KeyIdentifierSize ()
{
    return( m_cbKeyIdentifier );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::KeyIdentifier, public
//
//  Synopsis:   return the key identifier
//
//----------------------------------------------------------------------------
inline LPBYTE
CCertObject::KeyIdentifier ()
{
    return( m_pbKeyIdentifier );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::PublicKeyHash, public
//
//  Synopsis:   return the cert's public key hash
//
//----------------------------------------------------------------------------
inline LPBYTE
CCertObject::PublicKeyHash ()
{
    return( m_rgbPublicKeyHash );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::IssuerPublicKeyHash, public
//
//  Synopsis:   return the public key hash of the cert's issuer
//
//----------------------------------------------------------------------------
inline LPBYTE
CCertObject::IssuerPublicKeyHash ()
{
    return( m_rgbIssuerPublicKeyHash );
}


//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::HashIndexEntry, public
//
//  Synopsis:   return the hash index entry
//
//----------------------------------------------------------------------------
inline HLRUENTRY
CCertObject::HashIndexEntry ()
{
    return( m_hHashEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::IdentifierIndexEntry, public
//
//  Synopsis:   return the identifier index entry
//
//----------------------------------------------------------------------------
inline HLRUENTRY
CCertObject::IdentifierIndexEntry ()
{
    return( m_hIdentifierEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::SubjectNameIndexEntry, public
//
//  Synopsis:   return the subject name index entry
//
//----------------------------------------------------------------------------
inline HLRUENTRY
CCertObject::SubjectNameIndexEntry ()
{
    return( m_hSubjectNameEntry );
}


//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::KeyIdIndexEntry, public
//
//  Synopsis:   return the key identifier index entry
//
//----------------------------------------------------------------------------
inline HLRUENTRY
CCertObject::KeyIdIndexEntry ()
{
    return( m_hKeyIdEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::PublicKeyHashIndexEntry, public
//
//  Synopsis:   return the public key hash index entry
//
//----------------------------------------------------------------------------
inline HLRUENTRY
CCertObject::PublicKeyHashIndexEntry ()
{
    return( m_hPublicKeyHashEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::EndHashIndexEntry, public
//
//  Synopsis:   return the hash index entry
//
//----------------------------------------------------------------------------
inline HLRUENTRY
CCertObject::EndHashIndexEntry ()
{
    return( m_hEndHashEntry );
}


//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::CertObject, public
//
//  Synopsis:   returns the cert object
//
//----------------------------------------------------------------------------
inline PCCERTOBJECT
CChainPathObject::CertObject ()
{
    return( m_pCertObject );
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::Pass1Quality, public
//
//  Synopsis:   return the quality value determined during the first pass
//
//----------------------------------------------------------------------------
inline DWORD
CChainPathObject::Pass1Quality ()
{
    return( m_dwPass1Quality );
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::SetPass1Quality, public
//
//  Synopsis:   set the first pass quality value
//
//----------------------------------------------------------------------------
inline VOID
CChainPathObject::SetPass1Quality (IN DWORD dwQuality)
{
    m_dwPass1Quality  = dwQuality;
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::IsCompleted, public
//
//  Synopsis:   returns TRUE if we have completed object initialization and
//              the addition of all issuers. FALSE normally indicates a
//              cyclic issuer.
//
//----------------------------------------------------------------------------
inline BOOL
CChainPathObject::IsCompleted ()
{
    return m_fCompleted;
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::HasAdditionalStatus, public
//
//  Synopsis:   returns HasAdditionalStatus flag value 
//
//----------------------------------------------------------------------------
inline BOOL
CChainPathObject::HasAdditionalStatus ()
{
    return( m_fHasAdditionalStatus );
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::DownPathObject, public
//
//  Synopsis:   returns this object's down path object
//
//----------------------------------------------------------------------------
inline PCCHAINPATHOBJECT
CChainPathObject::DownPathObject ()
{
    return( m_pDownPathObject );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::IsEmpty, public
//
//  Synopsis:   is the issuer list empty
//
//----------------------------------------------------------------------------
inline BOOL
CCertIssuerList::IsEmpty ()
{
    return( m_pHead == NULL );
}


//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::AddElement, public
//
//  Synopsis:   add an element to the list
//
//----------------------------------------------------------------------------
inline VOID
CCertIssuerList::AddElement (IN PCERT_ISSUER_ELEMENT pElement)
{
    pElement->pNextElement = m_pHead;
    pElement->pPrevElement = NULL;

    if ( m_pHead != NULL )
    {
        m_pHead->pPrevElement = pElement;
    }

    m_pHead = pElement;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::RemoveElement, public
//
//  Synopsis:   remove an element from the list
//
//----------------------------------------------------------------------------
inline VOID
CCertIssuerList::RemoveElement (IN PCERT_ISSUER_ELEMENT pElement)
{
    if ( pElement->pPrevElement != NULL )
    {
        pElement->pPrevElement->pNextElement = pElement->pNextElement;
    }

    if ( pElement->pNextElement != NULL )
    {
        pElement->pNextElement->pPrevElement = pElement->pPrevElement;
    }

    if ( pElement == m_pHead )
    {
        m_pHead = pElement->pNextElement;
    }

#if DBG
    pElement->pPrevElement = NULL;
    pElement->pNextElement = NULL;
#endif
}


//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::NextElement, public
//
//  Synopsis:   return the next element, if pElement == NULL the first element
//              is returned
//
//----------------------------------------------------------------------------
inline PCERT_ISSUER_ELEMENT
CCertIssuerList::NextElement (IN PCERT_ISSUER_ELEMENT pElement)
{
    if ( pElement == NULL )
    {
        return( m_pHead );
    }

    return( pElement->pNextElement );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::HashIndex, public
//
//  Synopsis:   return the hash index
//
//----------------------------------------------------------------------------
inline HLRUCACHE
CCertObjectCache::HashIndex ()
{
    return( m_hHashIndex );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::IdentifierIndex, public
//
//  Synopsis:   return the identifier index
//
//----------------------------------------------------------------------------
inline HLRUCACHE
CCertObjectCache::IdentifierIndex ()
{
    return( m_hIdentifierIndex );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::SubjectNameIndex, public
//
//  Synopsis:   return the subject name index
//
//----------------------------------------------------------------------------
inline HLRUCACHE
CCertObjectCache::SubjectNameIndex ()
{
    return( m_hSubjectNameIndex );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::KeyIdIndex, public
//
//  Synopsis:   return the key identifier index
//
//----------------------------------------------------------------------------
inline HLRUCACHE
CCertObjectCache::KeyIdIndex ()
{
    return( m_hKeyIdIndex );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::PublicKeyHashIndex, public
//
//  Synopsis:   return the hash index
//
//----------------------------------------------------------------------------
inline HLRUCACHE
CCertObjectCache::PublicKeyHashIndex ()
{
    return( m_hPublicKeyHashIndex );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::EndHashIndex, public
//
//  Synopsis:   return the end hash index
//
//----------------------------------------------------------------------------
inline HLRUCACHE
CCertObjectCache::EndHashIndex ()
{
    return( m_hEndHashIndex );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::FlushObjects, public
//
//  Synopsis:   flush the cache of issuer and end objects
//
//----------------------------------------------------------------------------
inline VOID
CCertObjectCache::FlushObjects (IN PCCHAINCALLCONTEXT pCallContext)
{
    I_CryptFlushLruCache( m_hHashIndex, 0, pCallContext );
    I_CryptFlushLruCache( m_hEndHashIndex, 0, pCallContext );

}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::LockEngine, public
//
//  Synopsis:   acquire the engine lock
//
//----------------------------------------------------------------------------
inline VOID
CCertChainEngine::LockEngine ()
{
    EnterCriticalSection( &m_Lock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::UnlockEngine, public
//
//  Synopsis:   release the engine lock
//
//----------------------------------------------------------------------------
inline VOID
CCertChainEngine::UnlockEngine ()
{
    LeaveCriticalSection( &m_Lock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::AddRef, public
//
//  Synopsis:   increment the reference count
//
//----------------------------------------------------------------------------
inline VOID
CCertChainEngine::AddRef ()
{
    InterlockedIncrement( &m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::Release, public
//
//  Synopsis:   decrement the reference count
//
//----------------------------------------------------------------------------
inline VOID
CCertChainEngine::Release ()
{
    if ( InterlockedDecrement( &m_cRefs ) == 0 )
    {
        delete this;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::CertObjectCache, public
//
//  Synopsis:   return the certificate object cache
//
//----------------------------------------------------------------------------
inline PCCERTOBJECTCACHE
CCertChainEngine::CertObjectCache ()
{
    return( m_pCertObjectCache );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::SSCtlObjectCache, public
//
//  Synopsis:   return the self signed certificate trust list object cache
//
//----------------------------------------------------------------------------
inline PCSSCTLOBJECTCACHE
CCertChainEngine::SSCtlObjectCache ()
{
    return( m_pSSCtlObjectCache );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::RootStore, public
//
//  Synopsis:   return the configured root store
//
//----------------------------------------------------------------------------
inline HCERTSTORE
CCertChainEngine::RootStore ()
{
    return( m_hRootStore );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::RealRootStore, public
//
//  Synopsis:   return the real root store
//
//----------------------------------------------------------------------------
inline HCERTSTORE
CCertChainEngine::RealRootStore ()
{
    return( m_hRealRootStore );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::TrustStore, public
//
//  Synopsis:   return the configured trust store
//
//----------------------------------------------------------------------------
inline HCERTSTORE
CCertChainEngine::TrustStore ()
{
    return( m_hTrustStore );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::OtherStore, public
//
//  Synopsis:   return the configured other store
//
//----------------------------------------------------------------------------
inline HCERTSTORE
CCertChainEngine::OtherStore ()
{
    return( m_hOtherStore );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::CAStore, public
//
//  Synopsis:   return the opened CA store, NOTE: this could be NULL!
//
//----------------------------------------------------------------------------
inline HCERTSTORE
CCertChainEngine::CAStore ()
{
    return( m_hCAStore );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::OpenTrustStore, public
//
//  Synopsis:   open's the engine's HKLM or HKCU "trust" store.
//              Caller must close.
//
//----------------------------------------------------------------------------
inline HCERTSTORE
CCertChainEngine::OpenTrustStore ()
{
    DWORD dwStoreFlags;

    if ( m_dwFlags & CERT_CHAIN_USE_LOCAL_MACHINE_STORE )
    {
        dwStoreFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
    }
    else
    {
        dwStoreFlags = CERT_SYSTEM_STORE_CURRENT_USER;
    }

    return CertOpenStore(
                     CERT_STORE_PROV_SYSTEM_W,
                     X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                     NULL,
                     dwStoreFlags |
                         CERT_STORE_SHARE_CONTEXT_FLAG |
                         CERT_STORE_SHARE_STORE_FLAG |
                         CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                     L"trust"
                     );
    
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::UrlRetrievalTimeout, public
//
//  Synopsis:   return the engine's UrlRetrievalTimeout
//
//----------------------------------------------------------------------------
inline DWORD
CCertChainEngine::UrlRetrievalTimeout ()
{
    return( m_dwUrlRetrievalTimeout );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::HasDefaultUrlRetrievalTimeout, public
//
//  Synopsis:   returns TRUE if the engine is using the default timeout
//
//----------------------------------------------------------------------------
inline BOOL
CCertChainEngine::HasDefaultUrlRetrievalTimeout ()
{
    return( m_fDefaultUrlRetrievalTimeout );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::Flags, public
//
//  Synopsis:   return the engine's flags
//
//----------------------------------------------------------------------------
inline DWORD
CCertChainEngine::Flags ()
{
    return( m_dwFlags );
}


//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::TouchEngineCount, public
//
//  Synopsis:   return the engine's touch count
//
//----------------------------------------------------------------------------
inline DWORD
CCertChainEngine::TouchEngineCount ()
{
    return( m_dwTouchEngineCount );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::IncrementTouchEngineCount, public
//
//  Synopsis:   increment and return the engine's touch count
//
//----------------------------------------------------------------------------
inline DWORD
CCertChainEngine::IncrementTouchEngineCount ()
{
    return( ++m_dwTouchEngineCount );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::AuthRootAutoUpdateInfo, public
//
//  Synopsis:   returns pointer to the engine's AuthRoot Auto Update Info
//
//----------------------------------------------------------------------------
inline PAUTH_ROOT_AUTO_UPDATE_INFO
CCertChainEngine::AuthRootAutoUpdateInfo()
{
    return m_pAuthRootAutoUpdateInfo;
}


//+===========================================================================
//  CCertObject helper functions
//============================================================================

BOOL WINAPI
ChainCreateCertObject (
    IN DWORD dwObjectType,
    IN PCCHAINCALLCONTEXT pCallContext,
    IN PCCERT_CONTEXT pCertContext,
    IN OPTIONAL LPBYTE pbCertHash,
    OUT PCCERTOBJECT *ppCertObject
    );

BOOL WINAPI
ChainFillCertObjectCtlCacheEnumFn(
     IN LPVOID pvParameter,
     IN PCSSCTLOBJECT pSSCtlObject
     );
VOID WINAPI
ChainFreeCertObjectCtlCache(
     IN PCERT_OBJECT_CTL_CACHE_ENTRY pCtlCacheHead
     );

LPVOID WINAPI
ChainAllocAndDecodeObject(
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    );

VOID WINAPI
ChainGetIssuerMatchInfo (
     IN PCCERT_CONTEXT pCertContext,
     OUT DWORD *pdwIssuerMatchFlags,
     OUT PCERT_AUTHORITY_KEY_ID_INFO* ppAuthKeyIdentifier
     );

BOOL WINAPI
ChainConvertAuthKeyIdentifierFromV2ToV1 (
     IN PCERT_AUTHORITY_KEY_ID2_INFO pAuthKeyIdentifier2,
     OUT PCERT_AUTHORITY_KEY_ID_INFO* ppAuthKeyIdentifier
     );
VOID WINAPI
ChainFreeAuthorityKeyIdentifier (
     IN PCERT_AUTHORITY_KEY_ID_INFO pAuthKeyIdInfo
     );

VOID WINAPI
ChainProcessSpecialOrDuplicateOIDsInUsage (
    IN OUT PCERT_ENHKEY_USAGE *ppUsage,
    IN OUT DWORD *pdwFlags
    );

VOID WINAPI
ChainConvertPoliciesToUsage (
    IN PCERT_POLICIES_INFO pPolicy,
    IN OUT DWORD *pdwFlags,
    OUT PCERT_ENHKEY_USAGE *ppUsage
    );

VOID WINAPI
ChainRemoveDuplicatePolicyMappings (
    IN OUT PCERT_POLICY_MAPPINGS_INFO pInfo
    );

VOID WINAPI
ChainGetPoliciesInfo (
    IN PCCERT_CONTEXT pCertContext,
    IN OUT PCHAIN_POLICIES_INFO pPoliciesInfo
    );
VOID WINAPI
ChainFreePoliciesInfo (
    IN OUT PCHAIN_POLICIES_INFO pPoliciesInfo
    );

BOOL WINAPI
ChainGetBasicConstraintsInfo (
    IN PCCERT_CONTEXT pCertContext,
    OUT PCERT_BASIC_CONSTRAINTS2_INFO *ppInfo
    );

VOID WINAPI
ChainFreeBasicConstraintsInfo (
    IN OUT PCERT_BASIC_CONSTRAINTS2_INFO pInfo
    );

BOOL WINAPI
ChainGetKeyUsage (
    IN PCCERT_CONTEXT pCertContext,
    OUT PCRYPT_BIT_BLOB *ppKeyUsage
    );

VOID WINAPI
ChainFreeKeyUsage (
    IN OUT PCRYPT_BIT_BLOB pKeyUsage
    );

VOID WINAPI
ChainGetSelfSignedStatus (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN PCCERTOBJECT pCertObject,
    IN OUT DWORD *pdwIssuerStatusFlags
    );
VOID WINAPI
ChainGetRootStoreStatus (
    IN HCERTSTORE hRoot,
    IN HCERTSTORE hRealRoot,
    IN BYTE rgbCertHash[ CHAINHASHLEN ],
    IN OUT DWORD *pdwIssuerStatusFlags
    );

//+===========================================================================
//  CCertObjectCache helper functions
//============================================================================

BOOL WINAPI
ChainCreateCertificateObjectCache (
     IN DWORD MaxIndexEntries,
     OUT PCCERTOBJECTCACHE* ppCertObjectCache
     );

VOID WINAPI
ChainFreeCertificateObjectCache (
     IN PCCERTOBJECTCACHE pCertObjectCache
     );


//
// Issuer Certificate Object Cache Primary Index Entry Removal Notification
//
// This should remove the relevant entries
// from the other indexes and release the reference on the certificate object
// maintained by the primary index.
//

VOID WINAPI
CertObjectCacheOnRemovalFromPrimaryIndex (
    IN LPVOID pv,
    IN LPVOID pvRemovalContext
    );

//
// End Certificate Object Cache Entry Removal Notification
//

VOID WINAPI
CertObjectCacheOnRemovalFromEndHashIndex (
    IN LPVOID pv,
    IN LPVOID pvRemovalContext
    );

//
// Certificate Object Cache Identifier Hashing Functions
//

DWORD WINAPI
CertObjectCacheHashMd5Identifier (
    IN PCRYPT_DATA_BLOB pIdentifier
    );

DWORD WINAPI
CertObjectCacheHashNameIdentifier (
    IN PCRYPT_DATA_BLOB pIdentifier
    );

VOID WINAPI
ChainCreateCertificateObjectIdentifier (
     IN PCERT_NAME_BLOB pIssuer,
     IN PCRYPT_INTEGER_BLOB pSerialNumber,
     OUT CERT_OBJECT_IDENTIFIER ObjectIdentifier
     );

//+===========================================================================
//  CChainPathObject helper functions
//============================================================================
BOOL WINAPI
ChainCreatePathObject (
     IN PCCHAINCALLCONTEXT pCallContext,
     IN PCCERTOBJECT pCertObject,
     IN OPTIONAL HCERTSTORE hAdditionalStore,
     OUT PCCHAINPATHOBJECT *ppPathObject
     );
BOOL WINAPI
ChainCreateCyclicPathObject (
     IN PCCHAINCALLCONTEXT pCallContext,
     IN PCCHAINPATHOBJECT pPathObject,
     OUT PCCHAINPATHOBJECT *ppCyclicPathObject
     );

LPSTR WINAPI
ChainAllocAndCopyOID (
     IN LPSTR pszSrcOID
     );
VOID WINAPI
ChainFreeOID (
     IN OUT LPSTR pszOID
     );

BOOL WINAPI
ChainAllocAndCopyUsage (
     IN PCERT_ENHKEY_USAGE pSrcUsage,
     OUT PCERT_ENHKEY_USAGE *ppDstUsage
     );
VOID WINAPI
ChainFreeUsage (
     IN OUT PCERT_ENHKEY_USAGE pUsage
     );

BOOL WINAPI
ChainIsOIDInUsage (
    IN LPSTR pszOID,
    IN PCERT_ENHKEY_USAGE pUsage
    );

VOID WINAPI
ChainIntersectUsages (
    IN PCERT_ENHKEY_USAGE pCertUsage,
    IN OUT PCERT_ENHKEY_USAGE pRestrictedUsage
    );

VOID WINAPI
ChainFreeAndClearRestrictedUsageInfo(
    IN OUT PCHAIN_RESTRICTED_USAGE_INFO pInfo
    );

BOOL WINAPI
ChainCalculateRestrictedUsage (
    IN PCERT_ENHKEY_USAGE pCertUsage,
    IN OPTIONAL PCERT_POLICY_MAPPINGS_INFO pMappings,
    IN OUT PCERT_ENHKEY_USAGE *ppRestrictedUsage,
    IN OUT PCERT_ENHKEY_USAGE *ppMappedUsage,
    IN OUT LPDWORD *ppdwMappedIndex
    );

VOID WINAPI
ChainGetUsageStatus (
     IN PCERT_ENHKEY_USAGE pRequestedUsage,
     IN PCERT_ENHKEY_USAGE pAvailableUsage,
     IN DWORD dwMatchType,
     IN OUT PCERT_TRUST_STATUS pStatus
     );

VOID WINAPI
ChainOrInStatusBits (
     IN PCERT_TRUST_STATUS pDestStatus,
     IN PCERT_TRUST_STATUS pSourceStatus
     );

BOOL WINAPI
ChainGetMatchInfoStatus (
    IN PCCERTOBJECT pIssuerObject,
    IN PCCERTOBJECT pSubjectObject,
    IN OUT DWORD *pdwInfoStatus
    );
DWORD WINAPI
ChainGetMatchInfoStatusForNoIssuer (
    IN DWORD dwIssuerMatchFlags
    );

BOOL WINAPI
ChainIsValidPubKeyMatchForIssuer (
    IN PCCERTOBJECT pIssuer,
    IN PCCERTOBJECT pSubject
    );

// Leaves Engine's lock to do signature verification
BOOL WINAPI
ChainGetSubjectStatus (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN PCCHAINPATHOBJECT pIssuerPathObject,
    IN PCCHAINPATHOBJECT pSubjectPathObject,
    IN OUT PCERT_TRUST_STATUS pStatus
    );

VOID WINAPI
ChainUpdateSummaryStatusByTrustStatus(
     IN OUT PCERT_TRUST_STATUS pSummaryStatus,
     IN PCERT_TRUST_STATUS pTrustStatus
     );

//+===========================================================================
//  Format and append extended error information helper functions
//============================================================================

BOOL WINAPI
ChainAllocAndEncodeObject(
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    );

VOID WINAPI
ChainAppendExtendedErrorInfo(
    IN OUT LPWSTR *ppwszExtErrorInfo,
    IN LPWSTR pwszAppend,
    IN DWORD cchAppend                  // Includes NULL terminator
    );

VOID WINAPI
ChainFormatAndAppendExtendedErrorInfo(
    IN OUT LPWSTR *ppwszExtErrorInfo,
    IN UINT nFormatID,
    ...
    );

//+===========================================================================
//  Name Constraint helper functions
//============================================================================
VOID WINAPI
ChainRemoveLeadingAndTrailingWhiteSpace(
    IN LPWSTR pwszIn,
    OUT LPWSTR *ppwszOut,
    OUT DWORD *pcchOut
    );

BOOL WINAPI
ChainIsRightStringInString(
    IN LPCWSTR pwszRight,
    IN DWORD cchRight,
    IN LPCWSTR pwszString,
    IN DWORD cchString
    );

BOOL WINAPI
ChainFixupNameConstraintsUPN(
    IN OUT PCRYPT_OBJID_BLOB pUPN
    );
BOOL WINAPI
ChainAllocDecodeAndFixupNameConstraintsDirectoryName(
    IN PCERT_NAME_BLOB pDirName,
    OUT PCERT_NAME_INFO *ppNameInfo
    );
BOOL WINAPI
ChainFixupNameConstraintsAltNameEntry(
    IN BOOL fSubjectConstraint,
    IN OUT PCERT_ALT_NAME_ENTRY pEntry
    );
VOID WINAPI
ChainFreeNameConstraintsAltNameEntryFixup(
    IN BOOL fSubjectConstraint,
    IN OUT PCERT_ALT_NAME_ENTRY pEntry
    );

LPWSTR WINAPI
ChainFormatNameConstraintsAltNameEntryFixup(
    IN PCERT_ALT_NAME_ENTRY pEntry
    );

VOID WINAPI
ChainFormatAndAppendNameConstraintsAltNameEntryFixup(
    IN OUT LPWSTR *ppwszExtErrorInfo,
    IN PCERT_ALT_NAME_ENTRY pEntry,
    IN UINT nFormatID,
    IN OPTIONAL DWORD dwSubtreeIndex = 0    // 0 => no subtree parameter
    );

BOOL WINAPI
ChainGetIssuerNameConstraintsInfo (
    IN PCCERT_CONTEXT pCertContext,
    IN OUT PCERT_NAME_CONSTRAINTS_INFO *ppInfo
    );
VOID WINAPI
ChainFreeIssuerNameConstraintsInfo (
    IN OUT PCERT_NAME_CONSTRAINTS_INFO pInfo
    );

VOID WINAPI
ChainGetSubjectNameConstraintsInfo (
    IN PCCERT_CONTEXT pCertContext,
    IN OUT PCHAIN_SUBJECT_NAME_CONSTRAINTS_INFO pSubjectInfo
    );
VOID WINAPI
ChainFreeSubjectNameConstraintsInfo (
    IN OUT PCHAIN_SUBJECT_NAME_CONSTRAINTS_INFO pSubjectInfo
    );

BOOL WINAPI
ChainCompareNameConstraintsDirectoryName(
    IN PCERT_NAME_INFO pSubjectInfo,
    IN PCERT_NAME_INFO pSubtreeInfo
    );
BOOL WINAPI
ChainCompareNameConstraintsIPAddress(
    IN PCRYPT_DATA_BLOB pSubjectIPAddress,
    IN PCRYPT_DATA_BLOB pSubtreeIPAddress
    );
BOOL WINAPI
ChainCompareNameConstraintsUPN(
    IN PCRYPT_OBJID_BLOB pSubjectValue,
    IN PCRYPT_OBJID_BLOB pSubtreeValue
    );
DWORD WINAPI
ChainCalculateNameConstraintsSubtreeErrorStatusForAltNameEntry(
    IN PCERT_ALT_NAME_ENTRY pSubjectEntry,
    IN BOOL fExcludedSubtree,
    IN DWORD cSubtree,
    IN PCERT_GENERAL_SUBTREE pSubtree,
    IN OUT LPWSTR *ppwszExtErrorInfo
    );
DWORD WINAPI
ChainCalculateNameConstraintsErrorStatusForAltNameEntry(
    IN PCERT_ALT_NAME_ENTRY pSubjectEntry,
    IN PCERT_NAME_CONSTRAINTS_INFO pNameConstraintsInfo,
    IN OUT LPWSTR *ppwszExtErrorInfo
    );

//+===========================================================================
//  CCertIssuerList helper functions
//============================================================================
BOOL WINAPI
ChainCreateIssuerList (
     IN PCCHAINPATHOBJECT pSubject,
     OUT PCCERTISSUERLIST* ppIssuerList
     );
VOID WINAPI
ChainFreeIssuerList (
     IN PCCERTISSUERLIST pIssuerList
     );

VOID WINAPI
ChainFreeCtlIssuerData (
     IN PCTL_ISSUER_DATA pCtlIssuerData
     );

//+===========================================================================
//  INTERNAL_CERT_CHAIN_CONTEXT helper functions
//============================================================================
VOID WINAPI
ChainAddRefInternalChainContext (
     IN PINTERNAL_CERT_CHAIN_CONTEXT pChainContext
     );
VOID WINAPI
ChainReleaseInternalChainContext (
     IN PINTERNAL_CERT_CHAIN_CONTEXT pChainContext
     );
VOID WINAPI
ChainFreeInternalChainContext (
     IN PINTERNAL_CERT_CHAIN_CONTEXT pContext
     );

VOID
ChainUpdateEndEntityCertContext(
    IN OUT PINTERNAL_CERT_CHAIN_CONTEXT pChainContext,
    IN OUT PCCERT_CONTEXT pEndCertContext
    );

//+===========================================================================
//  CERT_REVOCATION_INFO helper functions
//============================================================================

VOID WINAPI
ChainUpdateRevocationInfo (
     IN PCERT_REVOCATION_STATUS pRevStatus,
     IN OUT PCERT_REVOCATION_INFO pRevocationInfo,
     IN OUT PCERT_TRUST_STATUS pTrustStatus
     );

//+===========================================================================
//  CCertChainEngine helper functions
//============================================================================

BOOL WINAPI
ChainCreateWorldStore (
     IN HCERTSTORE hRoot,
     IN HCERTSTORE hCA,
     IN DWORD cAdditionalStore,
     IN HCERTSTORE* rghAdditionalStore,
     IN DWORD dwStoreFlags,
     OUT HCERTSTORE* phWorld
     );
BOOL WINAPI
ChainCreateEngineStore (
     IN HCERTSTORE hRootStore,
     IN HCERTSTORE hTrustStore,
     IN HCERTSTORE hOtherStore,
     IN BOOL fDefaultEngine,
     IN DWORD dwFlags,
     OUT HCERTSTORE* phEngineStore,
     OUT HANDLE* phEngineStoreChangeEvent
     );

BOOL WINAPI
ChainIsProperRestrictedRoot (
     IN HCERTSTORE hRealRoot,
     IN HCERTSTORE hRestrictedRoot
     );

BOOL WINAPI
ChainCreateCollectionIncludingCtlCertificates (
     IN HCERTSTORE hStore,
     OUT HCERTSTORE* phCollection
     );

BOOL WINAPI
ChainCopyToCAStore (
     PCCERTCHAINENGINE pChainEngine,
     HCERTSTORE hStore
     );


//+===========================================================================
//  URL helper functions
//============================================================================

//
// Cryptnet Thunk Helper API
//

typedef BOOL (WINAPI *PFN_GETOBJECTURL) (
                          IN LPCSTR pszUrlOid,
                          IN LPVOID pvPara,
                          IN DWORD dwFlags,
                          OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
                          IN OUT DWORD* pcbUrlArray,
                          OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
                          IN OUT OPTIONAL DWORD* pcbUrlInfo,
                          IN OPTIONAL LPVOID pvReserved
                          );

BOOL WINAPI
ChainGetObjectUrl (
     IN LPCSTR pszUrlOid,
     IN LPVOID pvPara,
     IN DWORD dwFlags,
     OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
     IN OUT DWORD* pcbUrlArray,
     OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
     IN OUT OPTIONAL DWORD* pcbUrlInfo,
     IN OPTIONAL LPVOID pvReserved
     );

typedef BOOL (WINAPI *PFN_RETRIEVEOBJECTBYURLW) (
                          IN LPCWSTR pszUrl,
                          IN LPCSTR pszObjectOid,
                          IN DWORD dwRetrievalFlags,
                          IN DWORD dwTimeout,
                          OUT LPVOID* ppvObject,
                          IN HCRYPTASYNC hAsyncRetrieve,
                          IN PCRYPT_CREDENTIALS pCredentials,
                          IN LPVOID pvVerify,
                          IN OPTIONAL PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                          );

BOOL WINAPI
ChainRetrieveObjectByUrlW (
     IN LPCWSTR pszUrl,
     IN LPCSTR pszObjectOid,
     IN DWORD dwRetrievalFlags,
     IN DWORD dwTimeout,
     OUT LPVOID* ppvObject,
     IN HCRYPTASYNC hAsyncRetrieve,
     IN PCRYPT_CREDENTIALS pCredentials,
     IN LPVOID pvVerify,
     IN OPTIONAL PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
     );

BOOL WINAPI
ChainIsConnected();

BOOL
WINAPI
ChainGetHostNameFromUrl (
    IN LPWSTR pwszUrl,
    IN DWORD cchHostName,
    OUT LPWSTR pwszHostName
    );

HMODULE WINAPI
ChainGetCryptnetModule ();

//
// URL helper
//

BOOL WINAPI
ChainIsFileOrLdapUrl (
     IN LPCWSTR pwszUrl
     );


//
// Given the number of unsuccessful attempts to retrieve the Url, returns
// the number of seconds to wait before the next attempt.
//
DWORD
WINAPI
ChainGetOfflineUrlDeltaSeconds (
    IN DWORD dwOfflineCnt
    );


//+===========================================================================
//  AuthRoot Auto Update helper functions (chain.cpp)
//============================================================================

PAUTH_ROOT_AUTO_UPDATE_INFO WINAPI
CreateAuthRootAutoUpdateInfo();

VOID WINAPI
FreeAuthRootAutoUpdateInfo(
    IN OUT PAUTH_ROOT_AUTO_UPDATE_INFO pInfo
    );

BOOL WINAPI
CreateAuthRootAutoUpdateMatchCaches(
    IN PCCTL_CONTEXT pCtl,
    IN OUT HLRUCACHE  rghMatchCache[AUTH_ROOT_MATCH_CNT]
    );

VOID WINAPI
FreeAuthRootAutoUpdateMatchCaches(
    IN OUT HLRUCACHE  rghMatchCache[AUTH_ROOT_MATCH_CNT]
    );

#define SHA1_HASH_LEN               20
#define SHA1_HASH_NAME_LEN          (2 * SHA1_HASH_LEN)

LPWSTR WINAPI
FormatAuthRootAutoUpdateCertUrl(
    IN BYTE rgbSha1Hash[SHA1_HASH_LEN],
    IN PAUTH_ROOT_AUTO_UPDATE_INFO pInfo
    );

BOOL WINAPI
ChainGetAuthRootAutoUpdateStatus (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN PCCERTOBJECT pCertObject,
    IN OUT DWORD *pdwIssuerStatusFlags
    );

//+===========================================================================
//  AuthRoot Auto Update helper functions (extract.cpp)
//============================================================================

PCCTL_CONTEXT WINAPI
ExtractAuthRootAutoUpdateCtlFromCab (
    IN PCRYPT_BLOB_ARRAY pcbaCab
    );



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\chain\chain.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       chain.cpp
//
//  Contents:   Certificate Chaining Infrastructure
//
//  History:    15-Jan-98    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <dbgdef.h>

//+===========================================================================
//  CCertObject methods
//============================================================================

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::CCertObject, public
//
//  Synopsis:   Constructor
//
//              Leaves the engine's critical section to create an object of
//              dwObjectType = CERT_END_OBJECT_TYPE. For a self-signed root
//              may also leave the critical section to retrieve and validate
//              the AuthRoot Auto Update CTL and add such a root to the
//              AuthRoot store.
//
//  Assumption: Chain engine is locked once in the calling thread.
//
//----------------------------------------------------------------------------
CCertObject::CCertObject (
    IN DWORD dwObjectType,
    IN PCCHAINCALLCONTEXT pCallContext,
    IN PCCERT_CONTEXT pCertContext,
    IN BYTE rgbCertHash[CHAINHASHLEN],
    OUT BOOL& rfResult
    )
{
    BOOL fLocked = TRUE;
    CRYPT_DATA_BLOB   DataBlob;
    DWORD cbData;

    if (CERT_END_OBJECT_TYPE == dwObjectType) {
        pCallContext->ChainEngine()->UnlockEngine();
        fLocked = FALSE;
    }

    m_dwObjectType = dwObjectType;
    m_cRefs = 1;

    // NOTE: The chain engine is NOT addref'd
    m_pChainEngine = pCallContext->ChainEngine();

    m_dwIssuerMatchFlags = 0;
    m_dwCachedMatchFlags = 0;
    m_dwIssuerStatusFlags = 0;
    m_dwInfoFlags = 0;
    m_pCtlCacheHead = NULL;
    m_pCertContext = CertDuplicateCertificateContext( pCertContext );
    memset(&m_PoliciesInfo, 0, sizeof(m_PoliciesInfo));
    m_pBasicConstraintsInfo = NULL;
    m_pKeyUsage = NULL;
    m_pIssuerNameConstraintsInfo = NULL;
    m_fAvailableSubjectNameConstraintsInfo = FALSE;
    memset(&m_SubjectNameConstraintsInfo, 0,
        sizeof(m_SubjectNameConstraintsInfo));
    m_pAuthKeyIdentifier = NULL;
    // m_ObjectIdentifier;
    memcpy(m_rgbCertHash, rgbCertHash, CHAINHASHLEN);
    m_cbKeyIdentifier = 0;
    m_pbKeyIdentifier = NULL;
    // m_rgbPublicKeyHash[ CHAINHASHLEN ];
    // m_rgbIssuerPublicKeyHash[ CHAINHASHLEN ];
    // m_rgbIssuerExactMatchHash[ CHAINHASHLEN ];
    // m_rgbIssuerNameMatchHash[ CHAINHASHLEN ];


    m_hHashEntry = NULL;
    m_hIdentifierEntry = NULL;
    m_hSubjectNameEntry = NULL;
    m_hKeyIdEntry = NULL;
    m_hPublicKeyHashEntry = NULL;

    m_hEndHashEntry = NULL;

    if (!CertGetCertificateContextProperty(
               pCertContext,
               CERT_KEY_IDENTIFIER_PROP_ID,
               NULL,
               &m_cbKeyIdentifier
               ))
        goto GetKeyIdentifierPropertyError;
    m_pbKeyIdentifier = new BYTE [ m_cbKeyIdentifier ];
    if (NULL == m_pbKeyIdentifier)
        goto OutOfMemory;
    if (!CertGetCertificateContextProperty(
               pCertContext,
               CERT_KEY_IDENTIFIER_PROP_ID,
               m_pbKeyIdentifier,
               &m_cbKeyIdentifier
               ))
        goto GetKeyIdentifierPropertyError;

    cbData = CHAINHASHLEN;
    if (!CertGetCertificateContextProperty(
              pCertContext,
              CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID,
              m_rgbPublicKeyHash,
              &cbData
              ) || CHAINHASHLEN != cbData)
        goto GetSubjectPublicKeyHashPropertyError;

    cbData = CHAINHASHLEN;
    if (CertGetCertificateContextProperty(
            pCertContext,
            CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID,
            m_rgbIssuerPublicKeyHash,
            &cbData
            ) && CHAINHASHLEN == cbData)
        m_dwIssuerStatusFlags |= CERT_ISSUER_PUBKEY_FLAG;

    ChainGetPoliciesInfo(pCertContext, &m_PoliciesInfo);

    if (!ChainGetBasicConstraintsInfo(pCertContext, &m_pBasicConstraintsInfo))
        m_dwInfoFlags |= CHAIN_INVALID_BASIC_CONSTRAINTS_INFO_FLAG;

    if (!ChainGetKeyUsage(pCertContext, &m_pKeyUsage))
        m_dwInfoFlags |= CHAIN_INVALID_KEY_USAGE_FLAG;

    if (!ChainGetIssuerNameConstraintsInfo(pCertContext,
            &m_pIssuerNameConstraintsInfo))
        m_dwInfoFlags |= CHAIN_INVALID_ISSUER_NAME_CONSTRAINTS_INFO_FLAG;

    if (CERT_CACHED_ISSUER_OBJECT_TYPE == dwObjectType) {
        DataBlob.cbData = CHAINHASHLEN;
        DataBlob.pbData = m_rgbCertHash;
        if (!I_CryptCreateLruEntry(
                          m_pChainEngine->CertObjectCache()->HashIndex(),
                          &DataBlob,
                          this,
                          &m_hHashEntry
                          ))
            goto CreateHashLruEntryError;

        // Need to double check this, only needed for issuer caching ???
        ChainCreateCertificateObjectIdentifier(
             &pCertContext->pCertInfo->Issuer,
             &pCertContext->pCertInfo->SerialNumber,
             m_ObjectIdentifier
             );

        DataBlob.cbData = sizeof( CERT_OBJECT_IDENTIFIER );
        DataBlob.pbData = m_ObjectIdentifier;
        if (!I_CryptCreateLruEntry(
                          m_pChainEngine->CertObjectCache()->IdentifierIndex(),
                          &DataBlob,
                          this,
                          &m_hIdentifierEntry
                          ))
            goto CreateIdentifierLruEntryError;

        DataBlob.cbData = pCertContext->pCertInfo->Subject.cbData;
        DataBlob.pbData = pCertContext->pCertInfo->Subject.pbData;
        if (!I_CryptCreateLruEntry(
                          m_pChainEngine->CertObjectCache()->SubjectNameIndex(),
                          &DataBlob,
                          this,
                          &m_hSubjectNameEntry
                          ))
            goto CreateSubjectNameLruEntryError;

        DataBlob.cbData = m_cbKeyIdentifier;
        DataBlob.pbData = m_pbKeyIdentifier;
        if (!I_CryptCreateLruEntry(
                          m_pChainEngine->CertObjectCache()->KeyIdIndex(),
                          &DataBlob,
                          this,
                          &m_hKeyIdEntry
                          ))
            goto CreateKeyIdLruEntryError;

        DataBlob.cbData = CHAINHASHLEN;
        DataBlob.pbData = m_rgbPublicKeyHash;
        if (!I_CryptCreateLruEntry(
                          m_pChainEngine->CertObjectCache()->PublicKeyHashIndex(),
                          &DataBlob,
                          this,
                          &m_hPublicKeyHashEntry
                          ))
            goto CreatePublicKeyHashLruEntryError;
    }


    ChainGetIssuerMatchInfo(
            pCertContext,
            &m_dwIssuerMatchFlags,
            &m_pAuthKeyIdentifier
            );

    ChainGetSelfSignedStatus(pCallContext, this, &m_dwIssuerStatusFlags);

    if (m_dwIssuerStatusFlags & CERT_ISSUER_SELF_SIGNED_FLAG) {
        //
        // NOTE: This means that only self-signed roots are supported
        //

        if (!fLocked) {
            pCallContext->ChainEngine()->LockEngine();
            fLocked = TRUE;
        }

        ChainGetRootStoreStatus(
             m_pChainEngine->RootStore(),
             m_pChainEngine->RealRootStore(),
             rgbCertHash,
             &m_dwIssuerStatusFlags
             );

        if (!(m_dwIssuerStatusFlags & CERT_ISSUER_TRUSTED_ROOT_FLAG)) {
            if (!ChainGetAuthRootAutoUpdateStatus(
                    pCallContext,
                    this,
                    &m_dwIssuerStatusFlags
                    ))
                goto AuthRootAutoUpdateError;
        }

        if (!(m_dwIssuerStatusFlags & CERT_ISSUER_TRUSTED_ROOT_FLAG)) {
            // Get all cached CTLs we are a member of

            CERT_OBJECT_CTL_CACHE_ENUM_DATA EnumData;

            memset(&EnumData, 0, sizeof(EnumData));
            EnumData.fResult = TRUE;
            EnumData.pCertObject = this;

            m_pChainEngine->SSCtlObjectCache()->EnumObjects(
                ChainFillCertObjectCtlCacheEnumFn,
                &EnumData
                );

            if (!EnumData.fResult) {
                SetLastError(EnumData.dwLastError);
                goto FillCertObjectCtlCacheError;
            }
        }
    }

    rfResult = TRUE;

CommonReturn:
    if (!fLocked)
        pCallContext->ChainEngine()->LockEngine();
    return;

ErrorReturn:
    rfResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetKeyIdentifierPropertyError)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
TRACE_ERROR(GetSubjectPublicKeyHashPropertyError)
TRACE_ERROR(CreateHashLruEntryError)
TRACE_ERROR(CreateIdentifierLruEntryError)
TRACE_ERROR(CreateSubjectNameLruEntryError)
TRACE_ERROR(CreateKeyIdLruEntryError)
TRACE_ERROR(CreatePublicKeyHashLruEntryError)
TRACE_ERROR(AuthRootAutoUpdateError)
TRACE_ERROR(FillCertObjectCtlCacheError)
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::~CCertObject, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CCertObject::~CCertObject ()
{
    if ( m_hKeyIdEntry != NULL )
    {
        I_CryptReleaseLruEntry( m_hKeyIdEntry );
    }

    if ( m_hSubjectNameEntry != NULL )
    {
        I_CryptReleaseLruEntry( m_hSubjectNameEntry );
    }

    if ( m_hIdentifierEntry != NULL )
    {
        I_CryptReleaseLruEntry( m_hIdentifierEntry );
    }

    if ( m_hPublicKeyHashEntry != NULL )
    {
        I_CryptReleaseLruEntry( m_hPublicKeyHashEntry );
    }

    if ( m_hHashEntry != NULL )
    {
        I_CryptReleaseLruEntry( m_hHashEntry );
    }

    if ( m_hEndHashEntry != NULL )
    {
        I_CryptReleaseLruEntry( m_hEndHashEntry );
    }

    ChainFreeCertObjectCtlCache(m_pCtlCacheHead);

    delete m_pbKeyIdentifier;
    ChainFreeAuthorityKeyIdentifier( m_pAuthKeyIdentifier );
    ChainFreePoliciesInfo( &m_PoliciesInfo );
    ChainFreeBasicConstraintsInfo( m_pBasicConstraintsInfo );
    ChainFreeKeyUsage( m_pKeyUsage );
    ChainFreeIssuerNameConstraintsInfo( m_pIssuerNameConstraintsInfo );
    ChainFreeSubjectNameConstraintsInfo( &m_SubjectNameConstraintsInfo );
    CertFreeCertificateContext( m_pCertContext );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::CacheEndObject, public
//
//  Synopsis:   Convert a CERT_END_OBJECT_TYPE to a CERT_CACHED_END_OBJECT_TYPE.
//
//----------------------------------------------------------------------------
BOOL 
CCertObject::CacheEndObject(
    IN PCCHAINCALLCONTEXT pCallContext
    )
{
    BOOL fResult;
    CRYPT_DATA_BLOB   DataBlob;

    assert(CERT_END_OBJECT_TYPE == m_dwObjectType);

    DataBlob.cbData = CHAINHASHLEN;
    DataBlob.pbData = m_rgbCertHash;
    fResult = I_CryptCreateLruEntry(
                      m_pChainEngine->CertObjectCache()->EndHashIndex(),
                      &DataBlob,
                      this,
                      &m_hEndHashEntry
                      );

    if (fResult)
        m_dwObjectType = CERT_CACHED_END_OBJECT_TYPE;

    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::SubjectNameConstraintsInfo, public
//
//  Synopsis:   return the subject name constraints info
//
//              allocation and getting of info is deferred until the
//              first name constraint check is done.
//
//  Assumption: chain engine isn't locked upon entry.
//
//----------------------------------------------------------------------------
PCHAIN_SUBJECT_NAME_CONSTRAINTS_INFO
CCertObject::SubjectNameConstraintsInfo ()
{
    if (!m_fAvailableSubjectNameConstraintsInfo) {
        CHAIN_SUBJECT_NAME_CONSTRAINTS_INFO Info;

        memset(&Info, 0, sizeof(Info));

        ChainGetSubjectNameConstraintsInfo(m_pCertContext, &Info);

        // Must do the update while holding the engine's critical section
        m_pChainEngine->LockEngine();

        if (m_fAvailableSubjectNameConstraintsInfo)
            // Another thread already did the update
            ChainFreeSubjectNameConstraintsInfo(&Info);
        else {
            memcpy(&m_SubjectNameConstraintsInfo, &Info,
                sizeof(m_SubjectNameConstraintsInfo));


            // Must be set last!!!
            m_fAvailableSubjectNameConstraintsInfo = TRUE;
        }
    
        m_pChainEngine->UnlockEngine();
        
    }

    return &m_SubjectNameConstraintsInfo;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::GetIssuerExactMatchHash, public
//
//  Synopsis:   if the cert has an Authority Key Info extension with
//              the optional issuer and serial number, returns the count and
//              pointer to the MD5 hash of the issuer name and serial number.
//              Otherwise, pMatchHash->cbData is set to 0.
//
//              MD5 hash calculation is deferred until the first call.
//
//  Assumption: Chain engine is locked once in the calling thread.
//
//----------------------------------------------------------------------------
VOID
CCertObject::GetIssuerExactMatchHash(
    OUT PCRYPT_DATA_BLOB pMatchHash
    )
{
    if (!(m_dwIssuerStatusFlags & CERT_ISSUER_EXACT_MATCH_HASH_FLAG)) {
        PCERT_AUTHORITY_KEY_ID_INFO pAKI = m_pAuthKeyIdentifier;

        if (pAKI && 0 != pAKI->CertIssuer.cbData &&
                0 != pAKI->CertSerialNumber.cbData) {
            ChainCreateCertificateObjectIdentifier(
                &pAKI->CertIssuer,
                &pAKI->CertSerialNumber,
                m_rgbIssuerExactMatchHash
                );
            m_dwIssuerStatusFlags |= CERT_ISSUER_EXACT_MATCH_HASH_FLAG;
        } else {
            pMatchHash->cbData = 0;
            pMatchHash->pbData = NULL;
            return;
        }
    }
    // else
    //  We have already calculated the MD5 hash

    pMatchHash->cbData = CHAINHASHLEN;
    pMatchHash->pbData = m_rgbIssuerExactMatchHash;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::GetIssuerKeyMatchHash, public
//
//  Synopsis:   if the cert has an Authority Key Info extension with
//              the optional key id, returns the key id.
//              Otherwise, pMatchHash->cbData is set to 0.
//
//----------------------------------------------------------------------------
VOID
CCertObject::GetIssuerKeyMatchHash(
    OUT PCRYPT_DATA_BLOB pMatchHash
    )
{
    PCERT_AUTHORITY_KEY_ID_INFO pAKI = m_pAuthKeyIdentifier;

    if (pAKI)
        *pMatchHash = pAKI->KeyId;
    else {
        pMatchHash->cbData = 0;
        pMatchHash->pbData = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::GetIssuerNameMatchHash, public
//
//  Synopsis:   if the cert has an issuer name, returns the count and
//              pointer to the MD5 hash of the issuer name.
//              Otherwise, pMatchHash->cbData is set to 0.
//
//              MD5 hash calculation is deferred until the first call.
//
//  Assumption: Chain engine is locked once in the calling thread.
//
//----------------------------------------------------------------------------
VOID
CCertObject::GetIssuerNameMatchHash(
    OUT PCRYPT_DATA_BLOB pMatchHash
    )
{
    if (!(m_dwIssuerStatusFlags & CERT_ISSUER_NAME_MATCH_HASH_FLAG)) {
        PCERT_INFO pCertInfo = m_pCertContext->pCertInfo;

        if (0 != pCertInfo->Issuer.cbData) {
            MD5_CTX md5ctx;

            MD5Init( &md5ctx );
            MD5Update( &md5ctx, pCertInfo->Issuer.pbData,
                pCertInfo->Issuer.cbData );
            MD5Final( &md5ctx );

            assert(CHAINHASHLEN == MD5DIGESTLEN);
            memcpy(m_rgbIssuerNameMatchHash, md5ctx.digest, CHAINHASHLEN);

            m_dwIssuerStatusFlags |= CERT_ISSUER_NAME_MATCH_HASH_FLAG;
        } else {
            pMatchHash->cbData = 0;
            pMatchHash->pbData = NULL;
            return;
        }
    }

    pMatchHash->cbData = CHAINHASHLEN;
    pMatchHash->pbData = m_rgbIssuerNameMatchHash;
}


//+===========================================================================
//  CChainPathObject methods
//============================================================================

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::CChainPathObject, public
//
//  Synopsis:   Constructor
//
//  Once successfully added to the call context cache, rfAddedToCreationCache
//  is set. This object will be deleted when CChainCallContext gets destroyed.
//
//  Since this object is per call, no AddRef'ing is required.
//
//----------------------------------------------------------------------------
CChainPathObject::CChainPathObject (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN BOOL fCyclic,
    IN LPVOID pvObject,             // fCyclic : pPathObject ? pCertObject
    IN OPTIONAL HCERTSTORE hAdditionalStore,
    OUT BOOL& rfResult,
    OUT BOOL& rfAddedToCreationCache
    )
{
    PCCERTOBJECT pCertObject;
    PCCHAINPATHOBJECT pPathObject;
    DWORD dwIssuerStatusFlags;

    rfAddedToCreationCache = FALSE;

    if (fCyclic) {
        pPathObject = (PCCHAINPATHOBJECT) pvObject;
        pCertObject = pPathObject->CertObject();
    } else {
        pPathObject = NULL;
        pCertObject = (PCCERTOBJECT) pvObject;
    }

    m_pCertObject = pCertObject;
    pCertObject->AddRef();
    memset( &m_TrustStatus, 0, sizeof( m_TrustStatus ) );
    m_dwPass1Quality = 0;
    m_dwChainIndex = 0;
    m_dwElementIndex = 0;
    m_pDownIssuerElement = NULL;
    m_pDownPathObject = NULL;
    m_pUpIssuerElement = NULL;
    m_fHasAdditionalStatus = FALSE;
    memset( &m_AdditionalStatus, 0, sizeof( m_AdditionalStatus ) );
    m_fHasRevocationInfo = FALSE;
    memset( &m_RevocationInfo, 0, sizeof( m_RevocationInfo ) );
    memset( &m_RevocationCrlInfo, 0, sizeof( m_RevocationCrlInfo ) );
    m_pIssuerList = NULL;
    m_pwszExtendedErrorInfo = NULL;
    m_fCompleted = FALSE;

    if (!ChainCreateIssuerList( this, &m_pIssuerList ))
        goto CreateIssuerListError;

    if (!pCallContext->AddPathObjectToCreationCache( this ))
        goto AddPathObjectToCreationCacheError;
    rfAddedToCreationCache = TRUE;

    if (fCyclic) {
        m_TrustStatus = pPathObject->m_TrustStatus;
        m_TrustStatus.dwInfoStatus |= ChainGetMatchInfoStatusForNoIssuer(
            pCertObject->IssuerMatchFlags());
        m_TrustStatus.dwErrorStatus |= CERT_TRUST_IS_CYCLIC;
        goto SuccessReturn;
    }

    dwIssuerStatusFlags = pCertObject->IssuerStatusFlags();
    if (dwIssuerStatusFlags & CERT_ISSUER_SELF_SIGNED_FLAG) {
        m_TrustStatus.dwInfoStatus |= CERT_TRUST_IS_SELF_SIGNED;
        ChainGetMatchInfoStatus(pCertObject, pCertObject,
            &m_TrustStatus.dwInfoStatus);
        m_dwPass1Quality |= CERT_QUALITY_COMPLETE_CHAIN |
            CERT_QUALITY_NOT_CYCLIC;

        if (dwIssuerStatusFlags & CERT_ISSUER_VALID_SIGNATURE_FLAG) {
            m_dwPass1Quality |= CERT_QUALITY_SIGNATURE_VALID;
        } else {
            m_TrustStatus.dwErrorStatus |= CERT_TRUST_IS_NOT_SIGNATURE_VALID;
            m_TrustStatus.dwInfoStatus &= ~CERT_TRUST_HAS_PREFERRED_ISSUER;
        }

        if (dwIssuerStatusFlags & CERT_ISSUER_TRUSTED_ROOT_FLAG) {
            m_dwPass1Quality |= CERT_QUALITY_HAS_TRUSTED_ROOT;

            // Check if we have a time valid root. This is an extra
            // check necessary to determine if we will need to do
            // AuthRoot Auto Update.

            FILETIME RequestedTime;
            PCERT_INFO pCertInfo = pCertObject->CertContext()->pCertInfo;

            pCallContext->RequestedTime(&RequestedTime);
            if ((0 == (pCallContext->CallFlags() &
                                CERT_CHAIN_TIMESTAMP_TIME)) &&
                    0 == CertVerifyTimeValidity(&RequestedTime, pCertInfo)) {
                m_dwPass1Quality |= CERT_QUALITY_HAS_TIME_VALID_TRUSTED_ROOT;
            } else {
                // Use current time for timestamping or try again using the
                // current time. This is necessary for cross certificate
                // chains.

                FILETIME CurrentTime;

                pCallContext->CurrentTime(&CurrentTime);
                if (0 == CertVerifyTimeValidity(&CurrentTime, pCertInfo)) {
                    m_dwPass1Quality |=
                        CERT_QUALITY_HAS_TIME_VALID_TRUSTED_ROOT;
                }
            }
        } else {
            m_TrustStatus.dwErrorStatus |= CERT_TRUST_IS_UNTRUSTED_ROOT;

            if (!FindAndAddCtlIssuersFromCache(pCallContext, hAdditionalStore))
                goto FindAndCtlIssuersFromCacheError;

            if (hAdditionalStore) {
                if (!FindAndAddCtlIssuersFromAdditionalStore(
                        pCallContext,
                        hAdditionalStore
                        ))
                    goto FindAndCtlIssuersFromAdditionalStoreError;
            }

            if (!(dwIssuerStatusFlags & CERT_ISSUER_VALID_SIGNATURE_FLAG))
                m_dwPass1Quality &= ~CERT_QUALITY_SIGNATURE_VALID;
        }
    } else {
        if (!FindAndAddIssuers (
                pCallContext,
                hAdditionalStore,
                NULL                // hIssuerUrlStore
                ))
            goto FindAndAddIssuersError;

        dwIssuerStatusFlags = pCertObject->IssuerStatusFlags();
        if (m_pIssuerList->IsEmpty()
                        ||
                (!(dwIssuerStatusFlags & CERT_ISSUER_URL_FLAG)
                                &&
                    (!(dwIssuerStatusFlags &
                            CERT_ISSUER_VALID_SIGNATURE_FLAG) ||
                        !(m_dwPass1Quality & CERT_QUALITY_SIGNATURE_VALID)))) {
            DWORD i;

            // Try the following 2 URL cases:
            //  0 - AIA cache
            //  1 - AIA wire
            // Continue through the cases until finding a "good" issuer.
            for (i = 0; i <= 1; i++) {
                HCERTSTORE hIssuerUrlStore = NULL;
                DWORD dwRetrievalFlags;

                if (0 == i)
                    dwRetrievalFlags = CRYPT_CACHE_ONLY_RETRIEVAL;
                else {
                    if (!pCallContext->IsOnline())
                        break;
                    dwRetrievalFlags = CRYPT_WIRE_ONLY_RETRIEVAL;
                }

                // The following leaves the engine's critical section to do
                // URL fetching.  If the engine was touched by another
                // thread, it fails with LastError set to
                // ERROR_CAN_NOT_COMPLETE.
                if (!pCallContext->ChainEngine()->GetIssuerUrlStore(
                        pCallContext,
                        pCertObject->CertContext(),
                        dwRetrievalFlags,
                        &hIssuerUrlStore
                        ))
                    goto GetIssuerUrlStoreError;

                if (hIssuerUrlStore) {
                    BOOL fResult;

                    fResult = FindAndAddIssuers (
                        pCallContext,
                        hAdditionalStore,
                        hIssuerUrlStore
                        );
                    CertCloseStore(hIssuerUrlStore, 0);

                    if (!fResult)
                        goto FindAndAddIssuersFromUrlStoreError;

                    dwIssuerStatusFlags = pCertObject->IssuerStatusFlags();
                    if (!m_pIssuerList->IsEmpty() &&
                            (dwIssuerStatusFlags &
                                CERT_ISSUER_VALID_SIGNATURE_FLAG)) {
                        assert(dwIssuerStatusFlags & CERT_ISSUER_PUBKEY_FLAG);

                        // Try to find all issuers having the same public key.
                        if (!FindAndAddIssuersByMatchType(
                                CERT_PUBKEY_ISSUER_MATCH_TYPE,
                                pCallContext,
                                hAdditionalStore,
                                NULL                    // hIssuerUrlStore
                                ))
                            goto FindIssuersByPubKeyError;

                        if (m_dwPass1Quality & CERT_QUALITY_SIGNATURE_VALID)
                            break;
                    }

                }
            }

            pCertObject->OrIssuerStatusFlags(CERT_ISSUER_URL_FLAG);
        }

        // Check if we have a time valid, signature valid, trusted root
        if ((CERT_QUALITY_HAS_TIME_VALID_TRUSTED_ROOT |
                CERT_QUALITY_SIGNATURE_VALID) !=
                    (m_dwPass1Quality &
                        (CERT_QUALITY_HAS_TIME_VALID_TRUSTED_ROOT |
                            CERT_QUALITY_SIGNATURE_VALID))
                            &&
                pCallContext->IsOnline()) {
            HCERTSTORE hIssuerUrlStore = NULL;

            // The following leaves the engine's critical section to do
            // URL fetching.  If the engine was touched by another
            // thread, it fails with LastError set to
            // ERROR_CAN_NOT_COMPLETE.

            // Note, we only hit the wire to fetch AuthRoots stored
            // on Microsoft's web server

            if (!GetAuthRootAutoUpdateUrlStore(
                    pCallContext,
                    &hIssuerUrlStore
                    ))
                goto GetAuthRootAutoUpdateUrlStoreError;

            if (hIssuerUrlStore) {
                BOOL fResult;

                fResult = FindAndAddIssuers (
                    pCallContext,
                    hAdditionalStore,
                    hIssuerUrlStore
                    );
                CertCloseStore(hIssuerUrlStore, 0);

                if (!fResult)
                    goto FindAndAddIssuersFromUrlStoreError;
            }
        }

        if (m_pIssuerList->IsEmpty()) {
            m_TrustStatus.dwInfoStatus |= ChainGetMatchInfoStatusForNoIssuer(
                pCertObject->IssuerMatchFlags());

            assert(0 == (m_dwPass1Quality &
                (CERT_QUALITY_HAS_TRUSTED_ROOT |
                    CERT_QUALITY_COMPLETE_CHAIN)));

            // Unable to verify our signature, default to being valid.
            // Also, we can't be cyclic.
            m_dwPass1Quality |= CERT_QUALITY_SIGNATURE_VALID |
                CERT_QUALITY_NOT_CYCLIC;
        }
    }

SuccessReturn:
    rfResult = TRUE;
CommonReturn:
    m_fCompleted = TRUE;
    return;
ErrorReturn:
    rfResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CreateIssuerListError)
TRACE_ERROR(AddPathObjectToCreationCacheError)
TRACE_ERROR(FindAndCtlIssuersFromCacheError)
TRACE_ERROR(FindAndCtlIssuersFromAdditionalStoreError)
TRACE_ERROR(FindAndAddIssuersError)
TRACE_ERROR(GetIssuerUrlStoreError)
TRACE_ERROR(GetAuthRootAutoUpdateUrlStoreError)
TRACE_ERROR(FindAndAddIssuersFromUrlStoreError)
TRACE_ERROR(FindIssuersByPubKeyError)
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::~CChainPathObject, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CChainPathObject::~CChainPathObject ()
{
    if (m_pCertObject)
        m_pCertObject->Release();

    if (m_fHasRevocationInfo) {
        if (m_RevocationCrlInfo.pBaseCrlContext)
            CertFreeCRLContext(m_RevocationCrlInfo.pBaseCrlContext);
        if (m_RevocationCrlInfo.pDeltaCrlContext)
            CertFreeCRLContext(m_RevocationCrlInfo.pDeltaCrlContext);
    }

    if (m_pIssuerList)
        ChainFreeIssuerList( m_pIssuerList );
    if (m_pwszExtendedErrorInfo)
        PkiFree(m_pwszExtendedErrorInfo);
}


//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::FindAndAddIssuers, public
//
//  Synopsis:   find and add issuers for all matching types
//
//----------------------------------------------------------------------------
BOOL
CChainPathObject::FindAndAddIssuers (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN OPTIONAL HCERTSTORE hAdditionalStore,
    IN OPTIONAL HCERTSTORE hIssuerUrlStore
    )
{
    BOOL fResult;
    PCCERTOBJECT pCertObject = m_pCertObject;
    DWORD dwIssuerMatchFlags;
    DWORD i;

    static const rgdwMatchType[] = {
        CERT_EXACT_ISSUER_MATCH_TYPE,
        CERT_KEYID_ISSUER_MATCH_TYPE,
        CERT_NAME_ISSUER_MATCH_TYPE
    };
#define FIND_MATCH_TYPE_CNT (sizeof(rgdwMatchType) / sizeof(rgdwMatchType[0]))

    if (pCertObject->IssuerStatusFlags() & CERT_ISSUER_PUBKEY_FLAG) {
        // We know the issuer's public key. First, attempt to find all issuers
        // having that public key.
        if (!FindAndAddIssuersByMatchType(
                CERT_PUBKEY_ISSUER_MATCH_TYPE,
                pCallContext,
                hAdditionalStore,
                hIssuerUrlStore
                ))
            goto FindIssuersByPubKeyError;

        if (!m_pIssuerList->IsEmpty() &&
                (pCertObject->IssuerStatusFlags() &
                    CERT_ISSUER_VALID_SIGNATURE_FLAG))
            goto SuccessReturn;
    }

    dwIssuerMatchFlags = pCertObject->IssuerMatchFlags();

    for (i = 0; i < FIND_MATCH_TYPE_CNT; i++) {
        if (dwIssuerMatchFlags & CERT_MATCH_TYPE_TO_FLAG(rgdwMatchType[i])) {
            DWORD dwIssuerStatusFlags;

            if (!FindAndAddIssuersByMatchType(
                    rgdwMatchType[i],
                    pCallContext,
                    hAdditionalStore,
                    hIssuerUrlStore
                    ))
                goto FindIssuersByMatchTypeError;

            dwIssuerStatusFlags = pCertObject->IssuerStatusFlags();
            if (!m_pIssuerList->IsEmpty() &&
                    (dwIssuerStatusFlags & CERT_ISSUER_VALID_SIGNATURE_FLAG)) {
                assert(dwIssuerStatusFlags & CERT_ISSUER_PUBKEY_FLAG);

                // We can now find all issuers having the same public key.
                if (!FindAndAddIssuersByMatchType(
                        CERT_PUBKEY_ISSUER_MATCH_TYPE,
                        pCallContext,
                        hAdditionalStore,
                        hIssuerUrlStore
                        ))
                    goto FindIssuersByPubKeyError;

                break;
            }
        }
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
    
TRACE_ERROR(FindIssuersByPubKeyError)
TRACE_ERROR(FindIssuersByMatchTypeError)
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::FindAndAddIssuersByMatchType, public
//
//  Synopsis:   find and add issuers for the specified match type
//
//----------------------------------------------------------------------------
BOOL
CChainPathObject::FindAndAddIssuersByMatchType(
    IN DWORD dwMatchType,
    IN PCCHAINCALLCONTEXT pCallContext,
    IN OPTIONAL HCERTSTORE hAdditionalStore,
    IN OPTIONAL HCERTSTORE hIssuerUrlStore
    )
{
    BOOL fResult;
    PCCERTOBJECT pCertObject = m_pCertObject;

    if (NULL == hIssuerUrlStore) {
        DWORD dwIssuerStatusFlags;
        DWORD dwCachedMatchFlags;

        // Note, we need to get the cached match flags before finding
        // in the cache. Due to recursive, doing a find further up the
        // chain may result in another issuer being inserted at the beginning
        // of the cache bucket list. Pretty remote, but possible.
        dwCachedMatchFlags = pCertObject->CachedMatchFlags();

        if (!FindAndAddIssuersFromCacheByMatchType(
                dwMatchType,
                pCallContext,
                hAdditionalStore
                ))
            goto FindIssuersFromCacheError;

        dwIssuerStatusFlags = pCertObject->IssuerStatusFlags();
        if (CERT_PUBKEY_ISSUER_MATCH_TYPE != dwMatchType &&
                !m_pIssuerList->IsEmpty() &&
                    (dwIssuerStatusFlags & CERT_ISSUER_VALID_SIGNATURE_FLAG)) {
            assert(dwIssuerStatusFlags & CERT_ISSUER_PUBKEY_FLAG);

            // We will be called again using the PUBKEY match
            goto SuccessReturn;
        }

        if (!(dwCachedMatchFlags & CERT_MATCH_TYPE_TO_FLAG(dwMatchType))) {
            if (!FindAndAddIssuersFromStoreByMatchType(
                    dwMatchType,
                    pCallContext,
                    FALSE,                  // fExternalStore
                    hAdditionalStore,
                    NULL                    // hIssuerUrlStore
                    ))
                goto FindIssuersFromEngineStoreError;

            dwIssuerStatusFlags = pCertObject->IssuerStatusFlags();
            if (CERT_PUBKEY_ISSUER_MATCH_TYPE != dwMatchType &&
                    !m_pIssuerList->IsEmpty() &&
                        (dwIssuerStatusFlags &
                            CERT_ISSUER_VALID_SIGNATURE_FLAG)) {
                assert(dwIssuerStatusFlags & CERT_ISSUER_PUBKEY_FLAG);

                // We will be called again using the PUBKEY match
                goto SuccessReturn;
            }
        }
    }


    if (NULL != hAdditionalStore || NULL != hIssuerUrlStore) {
        if (!FindAndAddIssuersFromStoreByMatchType(
                dwMatchType,
                pCallContext,
                TRUE,                   // fExternalStore
                hAdditionalStore,
                hIssuerUrlStore
                ))
            goto FindIssuersFromAdditionalOrUrlStoreError;
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(FindIssuersFromCacheError)
TRACE_ERROR(FindIssuersFromEngineStoreError)
TRACE_ERROR(FindIssuersFromAdditionalOrUrlStoreError)
}


//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::FindAndAddIssuersFromCacheByMatchType, public
//
//  Synopsis:   find and add cached issuers for the specified match type
//
//----------------------------------------------------------------------------
BOOL
CChainPathObject::FindAndAddIssuersFromCacheByMatchType(
    IN DWORD dwMatchType,
    IN PCCHAINCALLCONTEXT pCallContext,
    IN OPTIONAL HCERTSTORE hAdditionalStore
    )
{
    BOOL fResult;
    PCCERTOBJECT pCertObject = m_pCertObject;
    PCCERTCHAINENGINE pChainEngine = pCertObject->ChainEngine();
    PCCERTOBJECTCACHE pCertObjectCache = pChainEngine->CertObjectCache();
    PCCERTOBJECT pIssuer = NULL;

    HLRUCACHE hCache;
    HLRUENTRY hEntry;
    PCRYPT_DATA_BLOB pIdentifier;
    CRYPT_DATA_BLOB DataBlob;

    PCERT_AUTHORITY_KEY_ID_INFO pAuthKeyIdentifier;

    switch (dwMatchType) {
        case CERT_EXACT_ISSUER_MATCH_TYPE:
            hCache = pCertObjectCache->IdentifierIndex();
            pCertObject->GetIssuerExactMatchHash(&DataBlob);
            pIdentifier = &DataBlob;
            break;
        case CERT_KEYID_ISSUER_MATCH_TYPE:
            hCache = pCertObjectCache->KeyIdIndex();
            pAuthKeyIdentifier = pCertObject->AuthorityKeyIdentifier();
            pIdentifier = &pAuthKeyIdentifier->KeyId;
            break;
        case CERT_NAME_ISSUER_MATCH_TYPE:
            hCache = pCertObjectCache->SubjectNameIndex();
            pIdentifier = &pCertObject->CertContext()->pCertInfo->Issuer;
            break;
        case CERT_PUBKEY_ISSUER_MATCH_TYPE:
            hCache = pCertObjectCache->PublicKeyHashIndex();
            DataBlob.cbData = CHAINHASHLEN;
            DataBlob.pbData = pCertObject->IssuerPublicKeyHash();
            pIdentifier = &DataBlob;
            break;
        default:
            goto InvalidMatchType;
    }

    pIssuer = pCertObjectCache->FindIssuerObject(hCache, pIdentifier);
    while (pIssuer) {
        DWORD dwIssuerStatusFlags;

        if (!m_pIssuerList->AddIssuer(
                pCallContext,
                hAdditionalStore,
                pIssuer
                ))
            goto AddIssuerError;

        dwIssuerStatusFlags = pCertObject->IssuerStatusFlags();
        if (CERT_PUBKEY_ISSUER_MATCH_TYPE != dwMatchType &&
                (dwIssuerStatusFlags & CERT_ISSUER_VALID_SIGNATURE_FLAG)) {
            assert(dwIssuerStatusFlags & CERT_ISSUER_PUBKEY_FLAG);

            // We will be called again using the PUBKEY match
            goto SuccessReturn;
        }

        switch (dwMatchType) {
            case CERT_EXACT_ISSUER_MATCH_TYPE:
                hEntry = pIssuer->IdentifierIndexEntry();
                break;
            case CERT_KEYID_ISSUER_MATCH_TYPE:
                hEntry = pIssuer->KeyIdIndexEntry();
                break;
            case CERT_NAME_ISSUER_MATCH_TYPE:
                hEntry = pIssuer->SubjectNameIndexEntry();
                break;
            case CERT_PUBKEY_ISSUER_MATCH_TYPE:
                hEntry = pIssuer->PublicKeyHashIndexEntry();
                break;
            default:
                goto InvalidMatchType;
        }

        pIssuer = pCertObjectCache->NextMatchingIssuerObject(hEntry, pIssuer);
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    if (pIssuer) {
        DWORD dwErr = GetLastError();

        pIssuer->Release();

        SetLastError(dwErr);
    }
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidMatchType, E_UNEXPECTED)
TRACE_ERROR(AddIssuerError)
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::FindAndAddIssuersFromStoreByMatchType, public
//
//  Synopsis:   find and add issuers from either the engine's or an
//              external store for the specified match type
//
//----------------------------------------------------------------------------
BOOL
CChainPathObject::FindAndAddIssuersFromStoreByMatchType(
    IN DWORD dwMatchType,
    IN PCCHAINCALLCONTEXT pCallContext,
    IN BOOL fExternalStore,
    IN OPTIONAL HCERTSTORE hAdditionalStore,
    IN OPTIONAL HCERTSTORE hIssuerUrlStore
    )
{
    BOOL fResult;
    PCCERTOBJECT pCertObject = m_pCertObject;
    PCCERTCHAINENGINE pChainEngine = pCertObject->ChainEngine();

    HCERTSTORE hAdditionalStoreToUse = NULL;
    HCERTSTORE hStore = NULL;
    PCCERT_CONTEXT pCertContext = NULL;
    DWORD dwFindType;
    const void *pvFindPara;
    CRYPT_DATA_BLOB DataBlob;
    CERT_INFO CertInfo;
    PCERT_AUTHORITY_KEY_ID_INFO pAuthKeyIdentifier;

    if (fExternalStore) {
        if (hIssuerUrlStore) {
            hStore = CertDuplicateStore(hIssuerUrlStore);
            if (hAdditionalStore) {
                hAdditionalStoreToUse = CertOpenStore(
                      CERT_STORE_PROV_COLLECTION,
                      X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                      NULL,
                      CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                      NULL
                      );
                if (NULL == hAdditionalStoreToUse)
                    goto OpenCollectionStoreError;

                if (!CertAddStoreToCollection(hAdditionalStoreToUse,
                        hIssuerUrlStore, 0, 0))
                    goto AddToCollectionStoreError;
                if (!CertAddStoreToCollection(hAdditionalStoreToUse,
                        hAdditionalStore, 0, 0))
                    goto AddToCollectionStoreError;
            } else
                hAdditionalStoreToUse = CertDuplicateStore(hIssuerUrlStore);

        } else {
            assert(hAdditionalStore);
            hStore = CertDuplicateStore(hAdditionalStore);
            hAdditionalStoreToUse = CertDuplicateStore(hAdditionalStore);
        }
    } else {
        hStore = CertDuplicateStore(pChainEngine->OtherStore());
        if (hAdditionalStore)
            hAdditionalStoreToUse = CertDuplicateStore(hAdditionalStore);
    }

    switch (dwMatchType) {
        case CERT_EXACT_ISSUER_MATCH_TYPE:
            dwFindType = CERT_FIND_SUBJECT_CERT;
            pAuthKeyIdentifier = pCertObject->AuthorityKeyIdentifier();
            CertInfo.Issuer = pAuthKeyIdentifier->CertIssuer;
            CertInfo.SerialNumber = pAuthKeyIdentifier->CertSerialNumber;
            pvFindPara = (const void *) &CertInfo;
            break;
        case CERT_KEYID_ISSUER_MATCH_TYPE:
            dwFindType = CERT_FIND_KEY_IDENTIFIER;
            pAuthKeyIdentifier = pCertObject->AuthorityKeyIdentifier();
            pvFindPara = (const void *) &pAuthKeyIdentifier->KeyId;
            break;
        case CERT_NAME_ISSUER_MATCH_TYPE:
            dwFindType = CERT_FIND_SUBJECT_NAME;
            pvFindPara =
                (const void *) &pCertObject->CertContext()->pCertInfo->Issuer;
            break;
        case CERT_PUBKEY_ISSUER_MATCH_TYPE:
            dwFindType = CERT_FIND_PUBKEY_MD5_HASH;
            DataBlob.cbData = CHAINHASHLEN;
            DataBlob.pbData = pCertObject->IssuerPublicKeyHash();
            pvFindPara = (const void *) &DataBlob;
            break;
        default:
            goto InvalidMatchType;
    }

    while (pCertContext = CertFindCertificateInStore(
            hStore,
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            0,                              // dwFindFlags
            dwFindType,
            pvFindPara,
            pCertContext
            )) {
        DWORD dwIssuerStatusFlags;
        PCCERTOBJECT pIssuer = NULL;

        if (!ChainCreateCertObject (
                fExternalStore ? CERT_EXTERNAL_ISSUER_OBJECT_TYPE :
                                 CERT_CACHED_ISSUER_OBJECT_TYPE,
                pCallContext,
                pCertContext,
                NULL,           // rgbCertHash
                &pIssuer
                ))
            goto CreateIssuerObjectError;

        fResult = m_pIssuerList->AddIssuer(
                pCallContext,
                hAdditionalStoreToUse,
                pIssuer
                );
        pIssuer->Release();
        if (!fResult)
            goto AddIssuerError;

        dwIssuerStatusFlags = pCertObject->IssuerStatusFlags();
        if (CERT_PUBKEY_ISSUER_MATCH_TYPE != dwMatchType &&
                (dwIssuerStatusFlags & CERT_ISSUER_VALID_SIGNATURE_FLAG)) {
            assert(dwIssuerStatusFlags & CERT_ISSUER_PUBKEY_FLAG);

            // We will be called again using the PUBKEY match
            goto SuccessReturn;
        }
    }

    if (CRYPT_E_NOT_FOUND != GetLastError())
        goto FindCertificateInStoreError;

    if (!fExternalStore)
        // All matching issuers from the engine's store should be in
        // the cache now.
        pCertObject->OrCachedMatchFlags(CERT_MATCH_TYPE_TO_FLAG(dwMatchType));

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    if (pCertContext)
        CertFreeCertificateContext(pCertContext);

    if (hAdditionalStoreToUse)
        CertCloseStore(hAdditionalStoreToUse, 0);
    if (hStore)
        CertCloseStore(hStore, 0);

    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
    
TRACE_ERROR(OpenCollectionStoreError)
TRACE_ERROR(AddToCollectionStoreError)
SET_ERROR(InvalidMatchType, E_UNEXPECTED)
TRACE_ERROR(CreateIssuerObjectError)
TRACE_ERROR(AddIssuerError)
TRACE_ERROR(FindCertificateInStoreError)
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::FindAndAddCtlIssuersFromCache, public
//
//  Synopsis:   find and add matching CTL issuers from the cache
//
//----------------------------------------------------------------------------
BOOL
CChainPathObject::FindAndAddCtlIssuersFromCache (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN OPTIONAL HCERTSTORE hAdditionalStore
    )
{
    PCERT_OBJECT_CTL_CACHE_ENTRY pEntry;

    assert(m_pCertObject->IssuerStatusFlags() &
        CERT_ISSUER_SELF_SIGNED_FLAG);
    assert(!(m_pCertObject->IssuerStatusFlags() &
        CERT_ISSUER_TRUSTED_ROOT_FLAG));

    pEntry = NULL;
    while (pEntry = m_pCertObject->NextCtlCacheEntry(pEntry)) {
        PCERT_TRUST_LIST_INFO pTrustListInfo = NULL;

        if (!SSCtlAllocAndCopyTrustListInfo(
                pEntry->pTrustListInfo,
                &pTrustListInfo
                ))
            return FALSE;

        if (!m_pIssuerList->AddCtlIssuer(
                pCallContext,
                hAdditionalStore,
                pEntry->pSSCtlObject,
                pTrustListInfo
                ))
        {
            SSCtlFreeTrustListInfo(pTrustListInfo);
            return FALSE;
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::FindAndAddCtlIssuersFromAdditionalStore, public
//
//  Synopsis:   find and add matching Ctl issuers from an additional store
//
//----------------------------------------------------------------------------
BOOL
CChainPathObject::FindAndAddCtlIssuersFromAdditionalStore (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN HCERTSTORE hAdditionalStore
    )
{
    BOOL fResult;
    PCCTL_CONTEXT pCtlContext = NULL;
    PCSSCTLOBJECT pSSCtlObject = NULL;

    assert(hAdditionalStore);

    while (pCtlContext = CertEnumCTLsInStore(hAdditionalStore, pCtlContext))
    {
        PCERT_TRUST_LIST_INFO pTrustListInfo = NULL;

        pSSCtlObject = NULL;

        if (!SSCtlCreateCtlObject(
                m_pCertObject->ChainEngine(),
                pCtlContext,
                TRUE,                       // fAdditionalStore
                &pSSCtlObject
                ))
            // Should look at the different errors
            continue;
        if (!pSSCtlObject->GetTrustListInfo(
                m_pCertObject->CertContext(),
                &pTrustListInfo
                )) {
            DWORD dwErr = GetLastError();
            if (CRYPT_E_NOT_FOUND != dwErr)
                goto GetTrustListInfoError;
            else {
                pSSCtlObject->Release();
                continue;
            }
        }

        if (!m_pIssuerList->AddCtlIssuer(
                pCallContext,
                hAdditionalStore,
                pSSCtlObject,
                pTrustListInfo
                )) {
            SSCtlFreeTrustListInfo(pTrustListInfo);
            goto AddCtlIssuerError;
        }

        pSSCtlObject->Release();
    }

    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    if (pCtlContext)
        CertFreeCTLContext(pCtlContext);
    if (pSSCtlObject)
        pSSCtlObject->Release();

    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetTrustListInfoError)
TRACE_ERROR(AddCtlIssuerError)
}


//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::NextPath, public
//
//  Synopsis:   Get the next top path object for this end path object.
//
//----------------------------------------------------------------------------
PCCHAINPATHOBJECT
CChainPathObject::NextPath (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN OPTIONAL PCCHAINPATHOBJECT pPrevTopPathObject
    )
{
    PCCHAINPATHOBJECT pTopPathObject;
    PCERT_ISSUER_ELEMENT pSubjectIssuerElement;
    PCCHAINPATHOBJECT pSubjectPathObject;
    DWORD dwFlags = pCallContext->CallFlags();

    if (NULL == pPrevTopPathObject) {
        pSubjectIssuerElement = NULL;
        pSubjectPathObject = NULL;
    } else {
        // Find the next issuer for the issuer's subject certificate.
        // We iterate downward toward the end certificate
        while (TRUE) {
            pSubjectIssuerElement = pPrevTopPathObject->m_pDownIssuerElement;
            pSubjectPathObject = pPrevTopPathObject->m_pDownPathObject;

            // Set to NULL so it can be reused. Used to determine if
            // cyclic.
            pPrevTopPathObject->m_pDownPathObject = NULL;
            pPrevTopPathObject->m_fHasAdditionalStatus = FALSE;


            if (NULL == pSubjectPathObject) {
                // We have reached the end certificate without having a
                // next path
                SetLastError((DWORD) CRYPT_E_NOT_FOUND);
                goto NoPath;
            }

            assert(pSubjectIssuerElement);
            if (pSubjectIssuerElement->pCyclicSaveIssuer) {
                // Restore the issuer replaced by the cyclic issuer
                pSubjectIssuerElement->pIssuer =
                    pSubjectIssuerElement->pCyclicSaveIssuer;
                pSubjectIssuerElement->pCyclicSaveIssuer = NULL;
            }

            // Move on to the next issuer for the subject. Skip low
            // quality issuers
            while (pSubjectIssuerElement =
                    pSubjectPathObject->m_pIssuerList->NextElement(
                                                    pSubjectIssuerElement)) {
                if ((dwFlags & CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING) ||
                        pSubjectIssuerElement->dwPass1Quality >=
                            pSubjectPathObject->m_dwPass1Quality)
                    break;
            }

            if (pSubjectIssuerElement)
                // The subject has another issuer
                break;

            // Note, a untrusted self signed root without CTLs is equal and
            // possibly higher quality than having untrusted CTLs
            if ((pSubjectPathObject->m_TrustStatus.dwInfoStatus &
                    CERT_TRUST_IS_SELF_SIGNED) && 
                    (dwFlags & CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING) &&
                    !(pSubjectPathObject->m_dwPass1Quality &
                        CERT_QUALITY_HAS_TRUSTED_ROOT)) {
                pTopPathObject = pSubjectPathObject;
                pTopPathObject->m_pUpIssuerElement = NULL;
                goto SelfSignedRootInsteadOfCtlPathReturn;
            }

            // Find the next issuer for my subject
            pPrevTopPathObject = pSubjectPathObject;
        }
    }

    // Iterate upward until the TopPathObject's issuer list is empty or
    // we have detected a cyclic PathObject
    while (TRUE) {
        if (NULL == pSubjectIssuerElement) {
            // End (bottom) certificate
            pTopPathObject = this;
            pTopPathObject->m_dwChainIndex = 0;
            pTopPathObject->m_dwElementIndex = 0;
        } else {
            pTopPathObject = pSubjectIssuerElement->pIssuer;
            // Determine if cyclic.
            if (pTopPathObject->m_pDownPathObject ||
                    pTopPathObject == this) {
                // The returned Cyclic path won't have any issuers
                if (!ChainCreateCyclicPathObject(
                        pCallContext,
                        pTopPathObject,
                        &pTopPathObject
                        ))
                    goto CreateCyclicPathObjectError;
                pSubjectIssuerElement->pCyclicSaveIssuer = 
                    pSubjectIssuerElement->pIssuer;
                pSubjectIssuerElement->pIssuer = pTopPathObject;
            }

            if (pSubjectPathObject->m_TrustStatus.dwInfoStatus &
                    CERT_TRUST_IS_SELF_SIGNED) {
                pTopPathObject->m_dwChainIndex =
                    pSubjectPathObject->m_dwChainIndex + 1;
                pTopPathObject->m_dwElementIndex = 0;
            } else {
                pTopPathObject->m_dwChainIndex =
                    pSubjectPathObject->m_dwChainIndex;
                pTopPathObject->m_dwElementIndex =
                    pSubjectPathObject->m_dwElementIndex + 1;
            }

            pSubjectPathObject->m_pUpIssuerElement = pSubjectIssuerElement;

        }

        pTopPathObject->m_pDownIssuerElement = pSubjectIssuerElement;
        pTopPathObject->m_pDownPathObject = pSubjectPathObject;

        pSubjectPathObject = pTopPathObject;

        // Find the first issuer having sufficient quality
        pSubjectIssuerElement = NULL;
        while (pSubjectIssuerElement =
                pSubjectPathObject->m_pIssuerList->NextElement(
                                                pSubjectIssuerElement)) {
            if ((dwFlags & CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING) ||
                    pSubjectIssuerElement->dwPass1Quality >=
                        pSubjectPathObject->m_dwPass1Quality) {
                // For a CTL, check that we have an issuer
                if (NULL != pSubjectIssuerElement->pIssuer)
                    break;
                else {
                    assert(pSubjectIssuerElement->fCtlIssuer);
                }
            }
        }

        if (NULL == pSubjectIssuerElement) {
            pTopPathObject->m_pUpIssuerElement = NULL;
            break;
        }

    }

SelfSignedRootInsteadOfCtlPathReturn:
CommonReturn:
    return pTopPathObject;

NoPath:
ErrorReturn:
    pTopPathObject = NULL;
    goto CommonReturn;
TRACE_ERROR(CreateCyclicPathObjectError)
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::CalculateAdditionalStatus, public
//
//  Synopsis:   calculate additional status bits based on time, usage,
//              revocation, ...
//
//----------------------------------------------------------------------------
VOID
CChainPathObject::CalculateAdditionalStatus (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN HCERTSTORE hAllStore
    )
{
    PCERT_INFO pCertInfo = m_pCertObject->CertContext()->pCertInfo;
    FILETIME RequestedTime;
    FILETIME CurrentTime;

    assert(!m_fHasAdditionalStatus);
    memset(&m_AdditionalStatus, 0, sizeof(m_AdditionalStatus));
    if (m_pwszExtendedErrorInfo) {
        PkiFree(m_pwszExtendedErrorInfo);
        m_pwszExtendedErrorInfo = NULL;
    }

    pCallContext->RequestedTime(&RequestedTime);
    pCallContext->CurrentTime(&CurrentTime);

    if (0 == m_dwChainIndex) {
        // First simple chain

        if (0 == m_dwElementIndex) {
            // End cert
            if (pCallContext->CallFlags() & CERT_CHAIN_TIMESTAMP_TIME) {
                // For time stamping, the end certificate needs to be valid
                // for both the time stamped and current times.
                if (0 != CertVerifyTimeValidity(&RequestedTime, pCertInfo) ||
                        0 != CertVerifyTimeValidity(&CurrentTime, pCertInfo))
                    m_AdditionalStatus.dwErrorStatus |=
                        CERT_TRUST_IS_NOT_TIME_VALID;
            } else {
                // End certificate needs to be valid for the requested time
                if (0 != CertVerifyTimeValidity(&RequestedTime, pCertInfo))
                    m_AdditionalStatus.dwErrorStatus |=
                        CERT_TRUST_IS_NOT_TIME_VALID;
            }
        } else {
            // CA or root
            if (pCallContext->CallFlags() & CERT_CHAIN_TIMESTAMP_TIME) {
                // For time stamping, the CA or root needs to be valid using
                // current time
                if (0 != CertVerifyTimeValidity(&CurrentTime, pCertInfo))
                    m_AdditionalStatus.dwErrorStatus |=
                        CERT_TRUST_IS_NOT_TIME_VALID;
            } else {
                // The CA or root needs to be valid using either the requested
                // or current time. Allowing current time is necessary for
                // cross certificate chains.
                if (!(0 == CertVerifyTimeValidity(&RequestedTime, pCertInfo) ||
                        0 == CertVerifyTimeValidity(&CurrentTime, pCertInfo)))
                    m_AdditionalStatus.dwErrorStatus |=
                        CERT_TRUST_IS_NOT_TIME_VALID;
            }
        }
    } else {
        // CTL signer chains. Must be valid using current time.
        if (0 != CertVerifyTimeValidity(&CurrentTime, pCertInfo))
            m_AdditionalStatus.dwErrorStatus |= CERT_TRUST_IS_NOT_TIME_VALID;
    }
        
    if (m_pDownIssuerElement) {
        PCERT_USAGE_MATCH pUsageToUse;
        CERT_USAGE_MATCH CtlUsage;
        LPSTR pszUsage = szOID_KP_CTL_USAGE_SIGNING;

        // Update subject's issuer status
        assert (m_pDownIssuerElement->pIssuer = this);


        if (0 != m_pDownPathObject->m_dwChainIndex) {
            // CTL path object
            memset(&CtlUsage, 0, sizeof(CtlUsage));

            CtlUsage.dwType = USAGE_MATCH_TYPE_AND;
            CtlUsage.Usage.cUsageIdentifier = 1;
            CtlUsage.Usage.rgpszUsageIdentifier = &pszUsage;

            pUsageToUse = &CtlUsage;
        } else
            pUsageToUse = &pCallContext->ChainPara()->RequestedUsage;

        if (m_pDownIssuerElement->fCtlIssuer) {
            FILETIME CurrentTime;

            memset(&m_pDownIssuerElement->SubjectStatus, 0,
                sizeof(m_pDownIssuerElement->SubjectStatus));
            pCallContext->CurrentTime(&CurrentTime);
            m_pDownIssuerElement->pCtlIssuerData->pSSCtlObject->
                CalculateStatus(
                    &CurrentTime,
                    pUsageToUse,
                    &m_pDownIssuerElement->SubjectStatus
                    );
        } else {
            CalculatePolicyConstraintsStatus();
            CalculateBasicConstraintsStatus();
            CalculateKeyUsageStatus();
            CalculateNameConstraintsStatus(pUsageToUse);
        }
    }

    if (pCallContext->CallFlags() & CERT_CHAIN_REVOCATION_CHECK_ALL) {
        // For CTL signer chains, always use current time
        CalculateRevocationStatus(
            pCallContext,
            hAllStore,
            0 == m_dwChainIndex ? &RequestedTime : &CurrentTime
            );
    }

    m_fHasAdditionalStatus = TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::CalculatePolicyConstraintsStatus, public
//
//  Synopsis:   calculate policy constraints additional status for this
//              issuer
//
//----------------------------------------------------------------------------
VOID
CChainPathObject::CalculatePolicyConstraintsStatus ()
{
    PCHAIN_POLICIES_INFO pPoliciesInfo;
    DWORD i;

    assert (0 != m_dwElementIndex);

    pPoliciesInfo = m_pCertObject->PoliciesInfo();
    for (i = 0; i < CHAIN_ISS_OR_APP_COUNT; i++ ) {
        PCERT_POLICY_CONSTRAINTS_INFO pConstraints =
            pPoliciesInfo->rgIssOrAppInfo[i].pConstraints;

        DWORD dwRequireSkipCerts;
        DWORD dwInhibitSkipCerts;
        PCCHAINPATHOBJECT pPathObject;

        if (NULL == pConstraints)
            continue;

        dwRequireSkipCerts = pConstraints->dwRequireExplicitPolicySkipCerts;
        dwInhibitSkipCerts = pConstraints->dwInhibitPolicyMappingSkipCerts;
        for (pPathObject = m_pDownPathObject;
                NULL != pPathObject &&
                    pPathObject->m_dwChainIndex == m_dwChainIndex;
                                pPathObject = pPathObject->m_pDownPathObject) {
                PCHAIN_POLICIES_INFO pSubjectPoliciesInfo;

            pSubjectPoliciesInfo = pPathObject->m_pCertObject->PoliciesInfo();

            if (pConstraints->fRequireExplicitPolicy) {
                if (0 < dwRequireSkipCerts)
                    dwRequireSkipCerts--;
                else {
                    if (NULL == pSubjectPoliciesInfo->rgIssOrAppInfo[i].pPolicy)
                    {
                        m_AdditionalStatus.dwErrorStatus |=
                            CERT_TRUST_INVALID_POLICY_CONSTRAINTS;
                        goto RequireExplicitPolicyError;
                    }
                }
            }

            if (pConstraints->fInhibitPolicyMapping) {
                if (0 < dwInhibitSkipCerts)
                    dwInhibitSkipCerts--;
                else {
                    if (pSubjectPoliciesInfo->rgIssOrAppInfo[i].pMappings)
                    {
                        m_AdditionalStatus.dwErrorStatus |=
                            CERT_TRUST_INVALID_POLICY_CONSTRAINTS;
                        goto InhibitPolicyMappingError;
                    }
                }
            }
        }
    }

CommonReturn:
    return;

ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(RequireExplicitPolicyError)
TRACE_ERROR(InhibitPolicyMappingError)
}


//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::CalculateBasicConstraintsStatus, public
//
//  Synopsis:   calculate basic constraints additional status for this
//              issuer
//
//----------------------------------------------------------------------------
VOID
CChainPathObject::CalculateBasicConstraintsStatus ()
{
    PCERT_BASIC_CONSTRAINTS2_INFO pInfo;

    assert (0 != m_dwElementIndex);

    if (m_pCertObject->InfoFlags() &
            CHAIN_INVALID_BASIC_CONSTRAINTS_INFO_FLAG) {
        m_AdditionalStatus.dwErrorStatus |= CERT_TRUST_INVALID_EXTENSION |
            CERT_TRUST_INVALID_BASIC_CONSTRAINTS;
    }

    pInfo = m_pCertObject->BasicConstraintsInfo();
    if (NULL == pInfo)
        return;

    if (!pInfo->fCA || (pInfo->fPathLenConstraint &&
            m_dwElementIndex > pInfo->dwPathLenConstraint + 1)) {
        m_AdditionalStatus.dwErrorStatus |=
            CERT_TRUST_INVALID_BASIC_CONSTRAINTS;
        goto BasicConstraintsError;
    }

CommonReturn:
    return;

ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(BasicConstraintsError)
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::CalculateKeyUsageStatus, public
//
//  Synopsis:   calculate key usage additional status for this
//              issuer
//
//----------------------------------------------------------------------------
VOID
CChainPathObject::CalculateKeyUsageStatus ()
{
    PCRYPT_BIT_BLOB pKeyUsage;

    assert (0 != m_dwElementIndex);

    if (m_pCertObject->InfoFlags() & CHAIN_INVALID_KEY_USAGE_FLAG) {
        m_AdditionalStatus.dwErrorStatus |= CERT_TRUST_INVALID_EXTENSION |
            CERT_TRUST_IS_NOT_VALID_FOR_USAGE;
    }

    pKeyUsage = m_pCertObject->KeyUsage();
    if (NULL == pKeyUsage)
        return;

    if (1 > pKeyUsage->cbData ||
            0 == (pKeyUsage->pbData[0] & CERT_KEY_CERT_SIGN_KEY_USAGE)) {
        m_AdditionalStatus.dwErrorStatus |= CERT_TRUST_IS_NOT_VALID_FOR_USAGE;
        goto KeyUsageError;
    }

CommonReturn:
    return;

ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(KeyUsageError)
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::CalculateNameConstraintsStatus, public
//
//  Synopsis:   calculate name constraints additional status for this
//              issuer
//
//----------------------------------------------------------------------------
VOID
CChainPathObject::CalculateNameConstraintsStatus (
    IN PCERT_USAGE_MATCH pUsageToUse
    )
{
    PCERT_NAME_CONSTRAINTS_INFO pIssuerInfo;
    PCHAIN_SUBJECT_NAME_CONSTRAINTS_INFO pSubjectInfo;
    PCERT_BASIC_CONSTRAINTS2_INFO pSubjectBasicInfo;
    PCCHAINPATHOBJECT pSubjectObject;
    DWORD dwErrorStatus = 0;

    assert (0 != m_dwElementIndex);

    if (m_pCertObject->InfoFlags() &
            CHAIN_INVALID_ISSUER_NAME_CONSTRAINTS_INFO_FLAG) {
        m_AdditionalStatus.dwErrorStatus |= CERT_TRUST_INVALID_EXTENSION |
            CERT_TRUST_INVALID_NAME_CONSTRAINTS;

        ChainFormatAndAppendExtendedErrorInfo(
            &m_pwszExtendedErrorInfo,
            IDS_INVALID_ISSUER_NAME_CONSTRAINT_EXT
            );
    }
    
    pIssuerInfo = m_pCertObject->IssuerNameConstraintsInfo();
    if (NULL == pIssuerInfo)
        // No NameConstraint check
        return;

    // We only verify the name constraints on the end cert
    for (pSubjectObject = m_pDownPathObject;
            NULL != pSubjectObject && 0 != pSubjectObject->m_dwElementIndex;
                        pSubjectObject = pSubjectObject->m_pDownPathObject)
        ;

    assert(pSubjectObject);
    assert(pSubjectObject->m_dwChainIndex == m_dwChainIndex);
    if (NULL == pSubjectObject)
        return;

    pSubjectBasicInfo = pSubjectObject->m_pCertObject->BasicConstraintsInfo();
    if (pSubjectBasicInfo && pSubjectBasicInfo->fCA)
        // End cert is a CA.
        return;

    pSubjectInfo = pSubjectObject->m_pCertObject->SubjectNameConstraintsInfo();

    if (pSubjectInfo->fInvalid) {
        dwErrorStatus |= CERT_TRUST_INVALID_EXTENSION |
            CERT_TRUST_INVALID_NAME_CONSTRAINTS;

        ChainFormatAndAppendExtendedErrorInfo(
            &m_pwszExtendedErrorInfo,
            IDS_INVALID_SUBJECT_NAME_CONSTRAINT_INFO
            );

        goto InvalidNameConstraints;
    }

    if (pSubjectInfo->pAltNameInfo) {
        // Loop through all the AltName entries. There needs to be a
        // name constraint for each entry.
        DWORD cEntry;
        PCERT_ALT_NAME_ENTRY pEntry;
            
        cEntry = pSubjectInfo->pAltNameInfo->cAltEntry;
        pEntry = pSubjectInfo->pAltNameInfo->rgAltEntry;
        for ( ; 0 < cEntry; cEntry--, pEntry++) {
            BOOL fSupported;

            // Check if a NameConstraint for this entry choice is supported
            fSupported = FALSE;
            switch (pEntry->dwAltNameChoice) {
                case CERT_ALT_NAME_OTHER_NAME:
                    // Only support the UPN OID
                    if (0 == strcmp(pEntry->pOtherName->pszObjId,
                            szOID_NT_PRINCIPAL_NAME))
                        fSupported = TRUE;
                    break;
                case CERT_ALT_NAME_RFC822_NAME:
                case CERT_ALT_NAME_DNS_NAME:
                case CERT_ALT_NAME_URL:
                case CERT_ALT_NAME_DIRECTORY_NAME:
                    fSupported = TRUE;
                    break;
                case CERT_ALT_NAME_IP_ADDRESS:
                    // Only support 4 or 16 byte IP addresses
                    if (4 == pEntry->IPAddress.cbData ||
                            16 == pEntry->IPAddress.cbData)
                        fSupported = TRUE;
                    break;
                case CERT_ALT_NAME_X400_ADDRESS:
                case CERT_ALT_NAME_EDI_PARTY_NAME:
                case CERT_ALT_NAME_REGISTERED_ID:
                default:
                    // Not supported
                    break;
            }

            if (!fSupported) {
                dwErrorStatus |= CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT;

                ChainFormatAndAppendNameConstraintsAltNameEntryFixup(
                    &m_pwszExtendedErrorInfo,
                    pEntry,
                    IDS_NOT_SUPPORTED_ENTRY_NAME_CONSTRAINT
                    );
            } else
                dwErrorStatus |=
                    ChainCalculateNameConstraintsErrorStatusForAltNameEntry(
                        pEntry, pIssuerInfo, &m_pwszExtendedErrorInfo);
        }
    }

    if (pSubjectInfo->pUnicodeNameInfo) {
        // Check as a DIRECTORY_NAME AltNameEntry choice. The DIRECTORY_NAME
        // fixup expects the DirectoryName.pbData to be the decoded and
        // fixup'ed UnicodeNameInfo.

        CERT_ALT_NAME_ENTRY Entry;

        Entry.dwAltNameChoice = CERT_ALT_NAME_DIRECTORY_NAME;
        Entry.DirectoryName.pbData = (BYTE *) pSubjectInfo->pUnicodeNameInfo;
        dwErrorStatus |=
            ChainCalculateNameConstraintsErrorStatusForAltNameEntry(
               &Entry, pIssuerInfo, &m_pwszExtendedErrorInfo);
    }

    if (pSubjectInfo->pEmailAttr) {
        // The SubjectAltName doesn't have an email choice. However, there is an
        // email attribute in the Subject UnicodeNameInfo.
        //
        // Check as a CERT_ALT_NAME_RFC822_NAME AltNameEntry choice. The
        // RFC822 fixup uses the DirectoryName.pbData and DirectoryName.cbData
        // to contain the pointer to and length of the unicode string.

        CERT_ALT_NAME_ENTRY Entry;
        Entry.dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
        Entry.DirectoryName = pSubjectInfo->pEmailAttr->Value;
        dwErrorStatus |=
            ChainCalculateNameConstraintsErrorStatusForAltNameEntry(
               &Entry, pIssuerInfo, &m_pwszExtendedErrorInfo);
    }


    if (!pSubjectInfo->fHasDnsAltNameEntry &&
            NULL != pSubjectInfo->pUnicodeNameInfo &&
            ChainIsOIDInUsage(szOID_PKIX_KP_SERVER_AUTH, &pUsageToUse->Usage)) {
        // The SubjectAltName doesn't have a DNS choice and we are building
        // a ServerAuth chain.

        // Need to check all the CN components in the UnicodeNameInfo.

        DWORD cRDN;
        PCERT_RDN pRDN;

        cRDN = pSubjectInfo->pUnicodeNameInfo->cRDN;
        pRDN = pSubjectInfo->pUnicodeNameInfo->rgRDN;
        for ( ; cRDN > 0; cRDN--, pRDN++) {
            DWORD cAttr = pRDN->cRDNAttr;
            PCERT_RDN_ATTR pAttr = pRDN->rgRDNAttr;
            for ( ; cAttr > 0; cAttr--, pAttr++) {
                if (!IS_CERT_RDN_CHAR_STRING(pAttr->dwValueType))
                    continue;
                if (0 == strcmp(pAttr->pszObjId, szOID_COMMON_NAME)) {
                    //
                    // Check as a CERT_ALT_NAME_DNS_NAME AltNameEntry choice.
                    // The DNS fixup uses the DirectoryName.pbData and
                    // DirectoryName.cbData to contain the pointer to and
                    // length of the unicode string.

                    CERT_ALT_NAME_ENTRY Entry;
                    Entry.dwAltNameChoice = CERT_ALT_NAME_DNS_NAME;
                    Entry.DirectoryName = pAttr->Value;
                    dwErrorStatus |=
                        ChainCalculateNameConstraintsErrorStatusForAltNameEntry(
                           &Entry, pIssuerInfo, &m_pwszExtendedErrorInfo);
                }
            }
        }
    }

CommonReturn:
    if (0 == dwErrorStatus)
        m_AdditionalStatus.dwInfoStatus |= CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS;
    else
        m_AdditionalStatus.dwErrorStatus |= dwErrorStatus;
    return;

ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(InvalidNameConstraints)
}


//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::CalculateRevocationStatus, public
//
//  Synopsis:   calculate additional status bits based on revocation
//
//----------------------------------------------------------------------------
VOID
CChainPathObject::CalculateRevocationStatus (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN HCERTSTORE hCrlStore,
    IN LPFILETIME pTime
    )
{
    CERT_REVOCATION_PARA   RevPara;
    CERT_REVOCATION_STATUS RevStatus;
    DWORD                  dwRevFlags;
    DWORD                  dwFlags = pCallContext->CallFlags();
    PCERT_CHAIN_PARA       pChainPara  = pCallContext->ChainPara();
    FILETIME               CurrentTime;

    assert(dwFlags & CERT_CHAIN_REVOCATION_CHECK_ALL);

    memset( &RevPara, 0, sizeof( RevPara ) );
    RevPara.cbSize = sizeof( RevPara );
    RevPara.hCrlStore = hCrlStore;
    RevPara.pftTimeToUse = pTime;
    RevPara.dwUrlRetrievalTimeout =
        pCallContext->RevocationUrlRetrievalTimeout();
    RevPara.fCheckFreshnessTime = pChainPara->fCheckRevocationFreshnessTime;
    RevPara.dwFreshnessTime = pChainPara->dwRevocationFreshnessTime;
    pCallContext->CurrentTime(&CurrentTime);
    RevPara.pftCurrentTime = &CurrentTime;

    memset( &RevStatus, 0, sizeof( RevStatus ) );
    RevStatus.cbSize = sizeof( RevStatus );

    dwRevFlags = 0;
    if (dwFlags & CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY)
        dwRevFlags |= CERT_VERIFY_CACHE_ONLY_BASED_REVOCATION;
    if (dwFlags & CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT)
        dwRevFlags |= CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG;

    if (!m_fHasRevocationInfo) {
        BOOL fHasRevocationInfo = FALSE;

        if (m_TrustStatus.dwInfoStatus & CERT_TRUST_IS_SELF_SIGNED) {
            BOOL fDoRevocation = FALSE;

            if (dwFlags & CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT) {
                ;
            } else if (dwFlags & CERT_CHAIN_REVOCATION_CHECK_END_CERT) {
                if (0 == m_dwChainIndex && 0 == m_dwElementIndex)
                    fDoRevocation = TRUE;
            } else {
                assert(dwFlags & CERT_CHAIN_REVOCATION_CHECK_CHAIN);
                fDoRevocation = TRUE;
            }

            if (fDoRevocation) {
                PCCERT_CONTEXT pSubjectCert = m_pCertObject->CertContext();
                RevPara.pIssuerCert = m_pCertObject->CertContext();
                RevPara.pCrlInfo = &m_RevocationCrlInfo;
                m_RevocationCrlInfo.cbSize = sizeof(m_RevocationCrlInfo);

                RevStatus.dwError = (DWORD) CRYPT_E_REVOCATION_OFFLINE;
                CertVerifyRevocation(
                    X509_ASN_ENCODING,
                    CERT_CONTEXT_REVOCATION_TYPE,
                    1,
                    (LPVOID *) &pSubjectCert,
                    dwRevFlags,
                    &RevPara,
                    &RevStatus
                    );
                fHasRevocationInfo = TRUE;
            }
        } else if (NULL == m_pUpIssuerElement) {
            if (dwFlags & CERT_CHAIN_REVOCATION_CHECK_END_CERT) {
                if (0 == m_dwChainIndex && 0 == m_dwElementIndex)
                    fHasRevocationInfo = TRUE;
            } else {
                fHasRevocationInfo = TRUE;
            }

            if (fHasRevocationInfo) {
                RevStatus.dwError = (DWORD) CRYPT_E_REVOCATION_OFFLINE;
            }
        }


        if (fHasRevocationInfo) {
            ChainUpdateRevocationInfo(&RevStatus, &m_RevocationInfo,
                &m_TrustStatus);
            m_fHasRevocationInfo = TRUE;

            memset( &RevStatus, 0, sizeof( RevStatus ) );
            RevStatus.cbSize = sizeof( RevStatus );
        }
    }

    if (m_pDownIssuerElement && !m_pDownIssuerElement->fCtlIssuer &&
            !m_pDownIssuerElement->fHasRevocationInfo) {
        BOOL fDoRevocation = FALSE;

        if (dwFlags & CERT_CHAIN_REVOCATION_CHECK_END_CERT) {
            if (0 == m_dwChainIndex && 1 == m_dwElementIndex)
                fDoRevocation = TRUE;
        } else {
            fDoRevocation = TRUE;
        }

        if (fDoRevocation) {
            PCCERT_CONTEXT pSubjectCert =
                m_pDownPathObject->m_pCertObject->CertContext();
            RevPara.pIssuerCert = m_pCertObject->CertContext();
            RevPara.pCrlInfo = &m_pDownIssuerElement->RevocationCrlInfo;
            m_pDownIssuerElement->RevocationCrlInfo.cbSize =
                sizeof(m_pDownIssuerElement->RevocationCrlInfo);

            RevStatus.dwError = (DWORD) CRYPT_E_REVOCATION_OFFLINE;
            CertVerifyRevocation(
                X509_ASN_ENCODING,
                CERT_CONTEXT_REVOCATION_TYPE,
                1,
                (LPVOID *) &pSubjectCert,
                dwRevFlags,
                &RevPara,
                &RevStatus
                );

            ChainUpdateRevocationInfo(&RevStatus,
                &m_pDownIssuerElement->RevocationInfo,
                &m_pDownIssuerElement->SubjectStatus);
            m_pDownIssuerElement->fHasRevocationInfo = TRUE;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::CreateChainContextFromPath, public
//
//  Synopsis:   Create the chain context for chain path ending in the
//              specified top path object. Also calculates the chain's
//              quality value.
//
//----------------------------------------------------------------------------
PINTERNAL_CERT_CHAIN_CONTEXT
CChainPathObject::CreateChainContextFromPath (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN PCCHAINPATHOBJECT pTopPathObject
    )
{
    // Single PkiZeroAlloc for all of the following:
    PINTERNAL_CERT_CHAIN_CONTEXT pContext = NULL;
    PCERT_SIMPLE_CHAIN *ppChain;
    PCERT_SIMPLE_CHAIN pChain;
    PCERT_CHAIN_ELEMENT *ppElement;
    PCERT_CHAIN_ELEMENT pElement;
    DWORD cChain;
    DWORD cTotalElement;
    DWORD cbTotal;
    PCCHAINPATHOBJECT pPathObject;
    DWORD dwQuality;
    DWORD dwChainErrorStatus;
    DWORD dwChainInfoStatus;
    PCERT_ENHKEY_USAGE pAppUsage;

    BOOL fHasContextRevocationFreshnessTime;

    // Restricted usage info that gets propogated downward
    CHAIN_RESTRICTED_USAGE_INFO RestrictedUsageInfo;

    memset(&RestrictedUsageInfo, 0, sizeof(RestrictedUsageInfo));

    cChain = pTopPathObject->m_dwChainIndex + 1;

    if (1 == cChain) {
        cTotalElement = pTopPathObject->m_dwElementIndex + 1;
    } else {
        cTotalElement = 0;
        for (pPathObject = pTopPathObject; NULL != pPathObject;
                                pPathObject = pPathObject->m_pDownPathObject)
            cTotalElement++;
    }

    cbTotal = sizeof(INTERNAL_CERT_CHAIN_CONTEXT) +
        sizeof(PCERT_SIMPLE_CHAIN) * cChain +
        sizeof(CERT_SIMPLE_CHAIN) * cChain +
        sizeof(PCERT_CHAIN_ELEMENT) * cTotalElement +
        sizeof(CERT_CHAIN_ELEMENT) * cTotalElement;
    

    pContext = (PINTERNAL_CERT_CHAIN_CONTEXT) PkiZeroAlloc(cbTotal);
    if (NULL == pContext)
        goto OutOfMemory;
    ppChain = (PCERT_SIMPLE_CHAIN *) &pContext[1];
    pChain = (PCERT_SIMPLE_CHAIN) &ppChain[cChain];
    ppElement = (PCERT_CHAIN_ELEMENT *) &pChain[cChain];
    pElement = (PCERT_CHAIN_ELEMENT) &ppElement[cTotalElement];

    pContext->cRefs = 1;
    pContext->ChainContext.cbSize = sizeof(CERT_CHAIN_CONTEXT);
    pContext->ChainContext.cChain = cChain;
    pContext->ChainContext.rgpChain = ppChain;

    if (1 < cChain )
        pContext->ChainContext.TrustStatus.dwInfoStatus |=
            CERT_TRUST_IS_COMPLEX_CHAIN;

    // Default to having preferred issuers
    pContext->ChainContext.TrustStatus.dwInfoStatus |=
        CERT_TRUST_HAS_PREFERRED_ISSUER;

    // Default to having revocation freshness time
    fHasContextRevocationFreshnessTime = TRUE;

    // Work our way from the top downward
    pPathObject = pTopPathObject;
    ppChain += cChain - 1;
    pChain += cChain - 1;
    ppElement += cTotalElement - 1;
    pElement += cTotalElement - 1;

    if (!(pTopPathObject->m_TrustStatus.dwInfoStatus &
            CERT_TRUST_IS_SELF_SIGNED))
        pChain->TrustStatus.dwErrorStatus |= CERT_TRUST_IS_PARTIAL_CHAIN;

    for ( ; 0 < cChain; cChain--, ppChain--, pChain--) {
        BOOL fHasChainRevocationFreshnessTime;
        DWORD cElement;

        *ppChain = pChain;
        pChain->cbSize = sizeof(CERT_SIMPLE_CHAIN);

        // Default to having preferred issuers
        pChain->TrustStatus.dwInfoStatus |= CERT_TRUST_HAS_PREFERRED_ISSUER;

        // Default to having revocation freshness time
        fHasChainRevocationFreshnessTime = TRUE;


        cElement = pPathObject->m_dwElementIndex + 1;
        pChain->cElement = cElement;
        pChain->rgpElement = ppElement - (cElement - 1);
        for ( ; 0 < cElement; cElement--, cTotalElement--,
                              ppElement--, pElement--,
                              pPathObject = pPathObject->m_pDownPathObject) {
            assert(pPathObject);
            *ppElement = pElement;
            pElement->cbSize = sizeof(CERT_CHAIN_ELEMENT);

            if (!pPathObject->UpdateChainContextUsageForPathObject (
                    pCallContext,
                    pChain,
                    pElement,
                    &RestrictedUsageInfo
                    ))
                goto UpdateChainContextUsageForPathObjectError;


            // This must be last. It updates the chain's TrustStatus
            // from the element's TrustStatus.
            if (!pPathObject->UpdateChainContextFromPathObject (
                    pCallContext,
                    pChain,
                    pElement
                    ))
                goto UpdateChainContextFromPathObjectError;

            // Remember the largest revocation freshness time for the
            // simple chain and the chain context.
            if (pElement->pRevocationInfo && fHasChainRevocationFreshnessTime) {
                PCERT_REVOCATION_INFO pRevInfo = pElement->pRevocationInfo;

                if (pRevInfo->fHasFreshnessTime) {
                    if (pRevInfo->dwFreshnessTime >
                            pChain->dwRevocationFreshnessTime)
                        pChain->dwRevocationFreshnessTime =
                            pRevInfo->dwFreshnessTime;
                    pChain->fHasRevocationFreshnessTime = TRUE;

                    if (fHasContextRevocationFreshnessTime) {
                        if (pRevInfo->dwFreshnessTime >
                                pContext->ChainContext.dwRevocationFreshnessTime)
                            pContext->ChainContext.dwRevocationFreshnessTime =
                                pRevInfo->dwFreshnessTime;
                        pContext->ChainContext.fHasRevocationFreshnessTime =
                            TRUE;
                    }
                } else if (CRYPT_E_NO_REVOCATION_CHECK !=
                        pRevInfo->dwRevocationResult) {
                    fHasChainRevocationFreshnessTime = FALSE;
                    pChain->fHasRevocationFreshnessTime = FALSE;

                    fHasContextRevocationFreshnessTime = FALSE;
                    pContext->ChainContext.fHasRevocationFreshnessTime = FALSE;
                }
                
            }

            CertPerfIncrementChainElementCount();

        }

        ChainUpdateSummaryStatusByTrustStatus(
            &pContext->ChainContext.TrustStatus,
            &pChain->TrustStatus);

        ChainFreeAndClearRestrictedUsageInfo(&RestrictedUsageInfo);
    }

    assert(0 == cTotalElement);

    // Calculate chain quality value
    dwQuality = 0;
    dwChainErrorStatus = pContext->ChainContext.TrustStatus.dwErrorStatus;
    dwChainInfoStatus = pContext->ChainContext.TrustStatus.dwInfoStatus;

    if (!(dwChainErrorStatus & CERT_TRUST_IS_NOT_TIME_VALID) &&
         !(dwChainErrorStatus & CERT_TRUST_CTL_IS_NOT_TIME_VALID))
        dwQuality |= CERT_QUALITY_TIME_VALID;

    if (!(dwChainErrorStatus & CERT_TRUST_IS_NOT_VALID_FOR_USAGE) &&
         !(dwChainErrorStatus & CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE))
        dwQuality |= CERT_QUALITY_MEETS_USAGE_CRITERIA;

    pAppUsage =
        pContext->ChainContext.rgpChain[0]->rgpElement[0]->pApplicationUsage;
    if (NULL == pAppUsage || 0 != pAppUsage->cUsageIdentifier)
        dwQuality |= CERT_QUALITY_HAS_APPLICATION_USAGE;

    if (!(dwChainErrorStatus & CERT_TRUST_IS_UNTRUSTED_ROOT))
        dwQuality |= CERT_QUALITY_HAS_TRUSTED_ROOT;

    if (!(dwChainErrorStatus & CERT_TRUST_IS_NOT_SIGNATURE_VALID) &&
         !(dwChainErrorStatus & CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID))
        dwQuality |= CERT_QUALITY_SIGNATURE_VALID;

    if (!(dwChainErrorStatus & CERT_TRUST_IS_PARTIAL_CHAIN))
        dwQuality |= CERT_QUALITY_COMPLETE_CHAIN;

    if (!(dwChainErrorStatus & CERT_TRUST_IS_REVOKED))
        dwQuality |= CERT_QUALITY_NOT_REVOKED;

    if (!(dwChainErrorStatus & CERT_TRUST_IS_OFFLINE_REVOCATION) &&
            !(dwChainErrorStatus & CERT_TRUST_IS_REVOKED))
        dwQuality |= CERT_QUALITY_ONLINE_REVOCATION;

    if (!(dwChainErrorStatus & CERT_TRUST_REVOCATION_STATUS_UNKNOWN) &&
            !(dwChainErrorStatus & CERT_TRUST_IS_REVOKED))
        dwQuality |= CERT_QUALITY_CHECK_REVOCATION;

    if (!(dwChainInfoStatus & CERT_TRUST_IS_COMPLEX_CHAIN))
        dwQuality |= CERT_QUALITY_SIMPLE_CHAIN;

    if (dwChainInfoStatus & CERT_TRUST_HAS_PREFERRED_ISSUER)
        dwQuality |= CERT_QUALITY_PREFERRED_ISSUER;

    if (dwChainInfoStatus & CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY)
        dwQuality |= CERT_QUALITY_HAS_ISSUANCE_CHAIN_POLICY;
    if (!(dwChainErrorStatus &
            (CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY |
                CERT_TRUST_INVALID_POLICY_CONSTRAINTS)))
        dwQuality |= CERT_QUALITY_POLICY_CONSTRAINTS_VALID;
    if (!(dwChainErrorStatus & CERT_TRUST_INVALID_BASIC_CONSTRAINTS))
        dwQuality |= CERT_QUALITY_BASIC_CONSTRAINTS_VALID;

    if (dwChainInfoStatus & CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS)
        dwQuality |= CERT_QUALITY_HAS_NAME_CONSTRAINTS;
    if (!(dwChainErrorStatus & (CERT_TRUST_INVALID_NAME_CONSTRAINTS |
            CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT |
            CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT)))
        dwQuality |= CERT_QUALITY_NAME_CONSTRAINTS_VALID;
    if (!(dwChainErrorStatus & (CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT |
            CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT)))
        dwQuality |= CERT_QUALITY_NAME_CONSTRAINTS_MET;


    pContext->dwQuality = dwQuality;

    CertPerfIncrementChainCount();

CommonReturn:
    return pContext;

ErrorReturn:
    if (pContext) {
        ChainReleaseInternalChainContext(pContext);
        pContext = NULL;
    }

    ChainFreeAndClearRestrictedUsageInfo(&RestrictedUsageInfo);
    goto CommonReturn;

SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
TRACE_ERROR(UpdateChainContextUsageForPathObjectError)
TRACE_ERROR(UpdateChainContextFromPathObjectError)
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::UpdateChainContextUsageForPathObject, public
//
//  Synopsis:   update the chain context usage information for this
//              path object.
//
//----------------------------------------------------------------------------
BOOL
CChainPathObject::UpdateChainContextUsageForPathObject (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN OUT PCERT_SIMPLE_CHAIN pChain,
    IN OUT PCERT_CHAIN_ELEMENT pElement,
    IN OUT PCHAIN_RESTRICTED_USAGE_INFO pRestrictedUsageInfo
    )
{
    BOOL fResult;
    PCHAIN_POLICIES_INFO pPoliciesInfo = m_pCertObject->PoliciesInfo();
    CERT_USAGE_MATCH CtlUsage;
    PCERT_USAGE_MATCH pUsageToUse;
    LPSTR pszUsage = szOID_KP_CTL_USAGE_SIGNING;
    PCERT_ENHKEY_USAGE pIssUsage;
    PCERT_ENHKEY_USAGE pAppUsage;
    PCERT_ENHKEY_USAGE pPropUsage;
    DWORD dwIssFlags;
    DWORD dwAppFlags;

    static const CERT_ENHKEY_USAGE NoUsage = { 0, NULL };

    // Update the usage to use for the second and subsequent chains
    if (0 != m_dwChainIndex) {
        // CTL path object
        memset(&CtlUsage, 0, sizeof(CtlUsage));


        CtlUsage.dwType = USAGE_MATCH_TYPE_AND;
        CtlUsage.Usage.cUsageIdentifier = 1;
        CtlUsage.Usage.rgpszUsageIdentifier = &pszUsage;

        pUsageToUse = &CtlUsage;
    } else {
        pUsageToUse = &pCallContext->ChainPara()->RequestedUsage;
    }

    dwIssFlags = pPoliciesInfo->rgIssOrAppInfo[CHAIN_ISS_INDEX].dwFlags;
    dwAppFlags = pPoliciesInfo->rgIssOrAppInfo[CHAIN_APP_INDEX].dwFlags;

    // Update TrustStatus to reflect any policy decoding errors
    if ((dwIssFlags & CHAIN_INVALID_POLICY_FLAG) ||
            (dwAppFlags & CHAIN_INVALID_POLICY_FLAG))
        pElement->TrustStatus.dwErrorStatus |= CERT_TRUST_INVALID_EXTENSION |
            CERT_TRUST_INVALID_POLICY_CONSTRAINTS;

    // Issuance :: restricted and mapped usage

    pIssUsage = pPoliciesInfo->rgIssOrAppInfo[CHAIN_ISS_INDEX].pUsage;
    if (NULL == pIssUsage) {
        // NULL => Any Usage

        // Only allow any usage for self signed roots or certs having
        // the CertPolicies extension. Otherwise, treat as having no usage.
        if (!(m_TrustStatus.dwInfoStatus & CERT_TRUST_IS_SELF_SIGNED) &&
                NULL == pPoliciesInfo->rgIssOrAppInfo[CHAIN_ISS_INDEX].pPolicy)
            pIssUsage = (PCERT_ENHKEY_USAGE) &NoUsage;
    }

    if (!ChainCalculateRestrictedUsage (
            pIssUsage,
            pPoliciesInfo->rgIssOrAppInfo[CHAIN_ISS_INDEX].pMappings,
            &pRestrictedUsageInfo->pIssuanceRestrictedUsage,
            &pRestrictedUsageInfo->pIssuanceMappedUsage,
            &pRestrictedUsageInfo->rgdwIssuanceMappedIndex
            ))
        goto CalculateIssuanceRestrictedUsageError;

    if (!ChainAllocAndCopyUsage(
            pRestrictedUsageInfo->pIssuanceRestrictedUsage,
            &pElement->pIssuanceUsage
            ))
        goto AllocAndCopyUsageError;

    if (0 != m_dwElementIndex) {
        PCERT_POLICY_CONSTRAINTS_INFO pConstraints =
            pPoliciesInfo->rgIssOrAppInfo[CHAIN_ISS_INDEX].pConstraints;

        if (pConstraints && pConstraints->fRequireExplicitPolicy &&
                m_dwElementIndex >
                    pConstraints->dwRequireExplicitPolicySkipCerts)
            pRestrictedUsageInfo->fRequireIssuancePolicy = TRUE;
        
    } else {
        // For the end cert, update the require issuance chain policy
        // TrustStatus.  Also, check the requested issuance policy.

        if (pRestrictedUsageInfo->fRequireIssuancePolicy) {
            if (pRestrictedUsageInfo->pIssuanceRestrictedUsage &&
                    0 == pRestrictedUsageInfo->pIssuanceRestrictedUsage->cUsageIdentifier) {
                // Must have either ANY_POLICY or some policy OIDs
                pChain->TrustStatus.dwErrorStatus |=
                    CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY;
            } else if (pPoliciesInfo->rgIssOrAppInfo[CHAIN_ISS_INDEX].pPolicy) {
                pChain->TrustStatus.dwInfoStatus |=
                    CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY;
            }
        }

        pIssUsage = pElement->pIssuanceUsage;
        if (pIssUsage) {
            PCERT_USAGE_MATCH pRequestedIssuancePolicy =
                &pCallContext->ChainPara()->RequestedIssuancePolicy;

            ChainGetUsageStatus(
                &pRequestedIssuancePolicy->Usage,
                pIssUsage,
                pRequestedIssuancePolicy->dwType,
                &pElement->TrustStatus
                );
        }
    }


    if (USAGE_MATCH_TYPE_OR == pUsageToUse->dwType &&
            1 < pUsageToUse->Usage.cUsageIdentifier) {
        // For "OR" match type request, we can't use restricted property usage
        pPropUsage = pPoliciesInfo->pPropertyUsage;

        // For "OR" match type request, we only use restricted application
        // usage upon seeing policy mappings.
        if (pRestrictedUsageInfo->pApplicationMappedUsage ||
                pPoliciesInfo->rgIssOrAppInfo[CHAIN_APP_INDEX].pMappings) {
            if (!ChainCalculateRestrictedUsage (
                    pPoliciesInfo->rgIssOrAppInfo[CHAIN_APP_INDEX].pUsage,
                    pPoliciesInfo->rgIssOrAppInfo[CHAIN_APP_INDEX].pMappings,
                    &pRestrictedUsageInfo->pApplicationRestrictedUsage,
                    &pRestrictedUsageInfo->pApplicationMappedUsage,
                    &pRestrictedUsageInfo->rgdwApplicationMappedIndex
                    ))
                goto CalculateApplicationRestrictedUsageError;
            pAppUsage = pRestrictedUsageInfo->pApplicationRestrictedUsage;
        } else
            pAppUsage = pPoliciesInfo->rgIssOrAppInfo[CHAIN_APP_INDEX].pUsage;
    } else {
        // Restricted property and application usage

        PCERT_ENHKEY_USAGE pPropMappedUsage = NULL;
        LPDWORD pdwPropMappedIndex = NULL;

        fResult = ChainCalculateRestrictedUsage (
            pPoliciesInfo->pPropertyUsage,
            NULL,                               // pMappings
            &pRestrictedUsageInfo->pPropertyRestrictedUsage,
            &pPropMappedUsage,
            &pdwPropMappedIndex
            );
        assert(NULL == pPropMappedUsage && NULL == pdwPropMappedIndex);
        if (!fResult)
            goto CalculatePropertyRestrictedUsageError;
        pPropUsage = pRestrictedUsageInfo->pPropertyRestrictedUsage;

        if (!ChainCalculateRestrictedUsage (
                pPoliciesInfo->rgIssOrAppInfo[CHAIN_APP_INDEX].pUsage,
                pPoliciesInfo->rgIssOrAppInfo[CHAIN_APP_INDEX].pMappings,
                &pRestrictedUsageInfo->pApplicationRestrictedUsage,
                &pRestrictedUsageInfo->pApplicationMappedUsage,
                &pRestrictedUsageInfo->rgdwApplicationMappedIndex
                ))
            goto CalculateApplicationRestrictedUsageError;
        pAppUsage = pRestrictedUsageInfo->pApplicationRestrictedUsage;
    }


    // The element's application usage includes the intersection with
    // the property usage
    if (NULL == pAppUsage) {
        if (!ChainAllocAndCopyUsage(
                pPropUsage,
                &pElement->pApplicationUsage
                ))
            goto AllocAndCopyUsageError;
    } else {
        if (!ChainAllocAndCopyUsage(
                pAppUsage,
                &pElement->pApplicationUsage
                ))
            goto AllocAndCopyUsageError;
        if (pPropUsage)
            // Remove OIDs not also in the property usage
            ChainIntersectUsages(pPropUsage, pElement->pApplicationUsage);
    }

    // Check the requested usage
    pAppUsage = pElement->pApplicationUsage;
    if (pAppUsage)
        ChainGetUsageStatus(
            &pUsageToUse->Usage,
            pAppUsage,
            pUsageToUse->dwType,
            &pElement->TrustStatus
            );

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CalculateIssuanceRestrictedUsageError)
TRACE_ERROR(AllocAndCopyUsageError)
TRACE_ERROR(CalculateApplicationRestrictedUsageError)
TRACE_ERROR(CalculatePropertyRestrictedUsageError)
}


//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::UpdateChainContextFromPathObject, public
//
//  Synopsis:   update the chain context using information from this
//              path object.
//
//----------------------------------------------------------------------------
BOOL
CChainPathObject::UpdateChainContextFromPathObject (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN OUT PCERT_SIMPLE_CHAIN pChain,
    IN OUT PCERT_CHAIN_ELEMENT pElement
    )
{
    BOOL fResult;
    PCERT_REVOCATION_INFO pRevocationInfo = NULL;
    PCERT_REVOCATION_CRL_INFO pRevocationCrlInfo = NULL;

    ChainOrInStatusBits(&pElement->TrustStatus, &m_TrustStatus);
    assert(m_fHasAdditionalStatus);
    ChainOrInStatusBits(&pElement->TrustStatus, &m_AdditionalStatus);

    if (m_pUpIssuerElement) {
        if (m_pUpIssuerElement->fCtlIssuer) {
            ChainOrInStatusBits(&pChain->TrustStatus,
                &m_pUpIssuerElement->SubjectStatus);

            assert(pElement->TrustStatus.dwErrorStatus &
                CERT_TRUST_IS_UNTRUSTED_ROOT);

            pElement->TrustStatus.dwErrorStatus &=
                ~CERT_TRUST_IS_UNTRUSTED_ROOT;

            if (!SSCtlAllocAndCopyTrustListInfo(
                    m_pUpIssuerElement->pCtlIssuerData->pTrustListInfo,
                    &pChain->pTrustListInfo
                    ))
                goto AllocAndCopyTrustListInfoError;
        } else {
            ChainOrInStatusBits(&pElement->TrustStatus,
                &m_pUpIssuerElement->SubjectStatus);
        }
    }

    pRevocationInfo = NULL;
    if (m_fHasRevocationInfo) {
        pRevocationInfo = &m_RevocationInfo;
        pRevocationCrlInfo = &m_RevocationCrlInfo;
    } else if (m_pUpIssuerElement && m_pUpIssuerElement->fHasRevocationInfo) {
        pRevocationInfo = &m_pUpIssuerElement->RevocationInfo;
        pRevocationCrlInfo = &m_pUpIssuerElement->RevocationCrlInfo;
    }

    if (pRevocationInfo) {
        pElement->pRevocationInfo = new CERT_REVOCATION_INFO;
        if (NULL == pElement->pRevocationInfo)
            goto OutOfMemory;

        memset(pElement->pRevocationInfo, 0, sizeof(CERT_REVOCATION_INFO));
        pElement->pRevocationInfo->cbSize = sizeof(CERT_REVOCATION_INFO);
        pElement->pRevocationInfo->dwRevocationResult = 
            pRevocationInfo->dwRevocationResult;
        pElement->pRevocationInfo->fHasFreshnessTime = 
            pRevocationInfo->fHasFreshnessTime;
        pElement->pRevocationInfo->dwFreshnessTime = 
            pRevocationInfo->dwFreshnessTime;

        if (NULL != pRevocationCrlInfo->pBaseCrlContext) {
            PCERT_REVOCATION_CRL_INFO pCrlInfo;

            pCrlInfo = new CERT_REVOCATION_CRL_INFO;
            if (NULL == pCrlInfo)
                goto OutOfMemory;

            pElement->pRevocationInfo->pCrlInfo = pCrlInfo;
            memcpy(pCrlInfo, pRevocationCrlInfo, sizeof(*pCrlInfo));
            assert(pCrlInfo->cbSize = sizeof(*pCrlInfo));

            pCrlInfo->pBaseCrlContext = CertDuplicateCRLContext(
                pRevocationCrlInfo->pBaseCrlContext);
            if (NULL != pRevocationCrlInfo->pDeltaCrlContext)
                pCrlInfo->pDeltaCrlContext = CertDuplicateCRLContext(
                    pRevocationCrlInfo->pDeltaCrlContext);
        }
    }

    if (m_pwszExtendedErrorInfo) {
        DWORD cbExtendedErrorInfo;
        LPWSTR pwszExtendedErrorInfo;

        cbExtendedErrorInfo =
            (wcslen(m_pwszExtendedErrorInfo) + 1) * sizeof(WCHAR);
        if (NULL == (pwszExtendedErrorInfo = (LPWSTR) PkiNonzeroAlloc(
                cbExtendedErrorInfo)))
            goto OutOfMemory;
        memcpy(pwszExtendedErrorInfo, m_pwszExtendedErrorInfo,
            cbExtendedErrorInfo);
        pElement->pwszExtendedErrorInfo = pwszExtendedErrorInfo;
    }

    pElement->pCertContext = CertDuplicateCertificateContext(
        m_pCertObject->CertContext());

    ChainUpdateSummaryStatusByTrustStatus(&pChain->TrustStatus,
        &pElement->TrustStatus);

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(AllocAndCopyTrustListInfoError)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
}


//+===========================================================================
//  CCertIssuerList methods
//============================================================================

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::CCertIssuerList, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CCertIssuerList::CCertIssuerList (IN PCCHAINPATHOBJECT pSubject)
{
    m_pSubject = pSubject;
    m_pHead = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::~CCertIssuerList, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CCertIssuerList::~CCertIssuerList ()
{
    PCERT_ISSUER_ELEMENT pElement;

    while ( ( pElement = NextElement( NULL ) ) != NULL  )
    {
        RemoveElement( pElement );
        DeleteElement( pElement );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::AddIssuer, public
//
//  Synopsis:   add an issuer to the list
//
//----------------------------------------------------------------------------
BOOL
CCertIssuerList::AddIssuer(
    IN PCCHAINCALLCONTEXT pCallContext,
    IN OPTIONAL HCERTSTORE hAdditionalStore,
    IN PCCERTOBJECT pIssuer
    )
{
    BOOL fResult;
    PCCHAINPATHOBJECT pIssuerPathObject = NULL;
    PCERT_ISSUER_ELEMENT pElement = NULL;

    if (CheckForDuplicateElement(pIssuer->CertHash(), FALSE))
        return TRUE;
    
    // Don't add ourself as an issuer.
       if (0 == memcmp(m_pSubject->CertObject()->CertHash(),
             pIssuer->CertHash(), CHAINHASHLEN))
             return TRUE;

    // Mainly for certs generated by tstore2.exe that mostly contain
    // the same public key, need to add an additional filter to
    // discard certs that only match via the public key, ie no
    // AKI, name or basic constraints match.
    if (!ChainIsValidPubKeyMatchForIssuer(pIssuer, m_pSubject->CertObject()))
        return TRUE;

    if (!ChainCreatePathObject(
            pCallContext,
            pIssuer,
            hAdditionalStore,
            &pIssuerPathObject
            ))
        return FALSE;

    fResult = CreateElement(
               pCallContext,
               FALSE,               // fCtlIssuer
               pIssuerPathObject,
               hAdditionalStore,
               NULL,                // pSSCtlObject
               NULL,                // pTrustListInfo
               &pElement
               );

    if (!fResult)
    {
        return( FALSE );
    }

    AddElement( pElement );

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::AddCtlIssuer, public
//
//  Synopsis:   add an issuer to the list
//
//----------------------------------------------------------------------------
BOOL
CCertIssuerList::AddCtlIssuer(
    IN PCCHAINCALLCONTEXT pCallContext,
    IN OPTIONAL HCERTSTORE hAdditionalStore,
    IN PCSSCTLOBJECT pSSCtlObject,
    IN PCERT_TRUST_LIST_INFO pTrustListInfo
    )
{
    PCERT_ISSUER_ELEMENT pElement = NULL;

    if (CheckForDuplicateElement(pSSCtlObject->CtlHash(), TRUE))
        return TRUE;

    if (!CreateElement(
               pCallContext,
               TRUE,                // fCtlIssuer
               NULL,                // pIssuerPathObject
               hAdditionalStore,
               pSSCtlObject,
               pTrustListInfo,
               &pElement
               ))
        return FALSE;


    AddElement( pElement );

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::CreateElement, public
//
//  Synopsis:   create an element
//
//----------------------------------------------------------------------------
BOOL
CCertIssuerList::CreateElement(
    IN PCCHAINCALLCONTEXT pCallContext,
    IN BOOL fCtlIssuer,
    IN OPTIONAL PCCHAINPATHOBJECT pIssuer,
    IN OPTIONAL HCERTSTORE hAdditionalStore,
    IN OPTIONAL PCSSCTLOBJECT pSSCtlObject,
    IN OPTIONAL PCERT_TRUST_LIST_INFO pTrustListInfo,   // allocated by caller
    OUT PCERT_ISSUER_ELEMENT* ppElement
    )
{
    BOOL fResult;
    BOOL fCtlSignatureValid = FALSE;
    PCERT_ISSUER_ELEMENT pElement;

    pElement = new CERT_ISSUER_ELEMENT;
    if (NULL == pElement)
        goto OutOfMemory;

    memset( pElement, 0, sizeof( CERT_ISSUER_ELEMENT ) );

    pElement->fCtlIssuer = fCtlIssuer;

    if (!fCtlIssuer) {
        pElement->pIssuer = pIssuer;

        // The following may leave the engine's critical section to verify the
        // signature. If the engine was touched by another thread, it fails with
        // LastError set to ERROR_CAN_NOT_COMPLETE.
        if (!ChainGetSubjectStatus(
                 pCallContext,
                 pIssuer,
                 m_pSubject,
                 &pElement->SubjectStatus
                 ))
            goto GetSubjectStatusError;
    } else {
        pElement->pCtlIssuerData = new CTL_ISSUER_DATA;
        if (NULL == pElement->pCtlIssuerData)
            goto OutOfMemory;

        memset( pElement->pCtlIssuerData, 0, sizeof( CTL_ISSUER_DATA ) );

        pSSCtlObject->AddRef();
        pElement->pCtlIssuerData->pSSCtlObject = pSSCtlObject;
        pElement->pCtlIssuerData->pTrustListInfo = pTrustListInfo;

        // The following may leave the engine's critical section to verify a
        // signature or do URL retrieval. If the engine was touched by
        // another thread, it fails with LastError set to
        // ERROR_CAN_NOT_COMPLETE.
        if (!pSSCtlObject->GetSigner(
                m_pSubject,
                pCallContext,
                hAdditionalStore,
                &pElement->pIssuer,
                &fCtlSignatureValid
                )) {
            if (GetLastError() != CRYPT_E_NOT_FOUND)
                goto GetSignerError;
        }
    }

    if (pElement->pIssuer) {
        // If the Issuer hasn't completed yet, then, we are cyclic.
        if (!pElement->pIssuer->IsCompleted())
            pElement->dwPass1Quality = 0;
        else {
            pElement->dwPass1Quality = pElement->pIssuer->Pass1Quality();

            if (!fCtlIssuer) {
                if (pElement->SubjectStatus.dwErrorStatus &
                        CERT_TRUST_IS_NOT_SIGNATURE_VALID) {
                    pElement->dwPass1Quality &= ~CERT_QUALITY_SIGNATURE_VALID;
                }
            } else if (!fCtlSignatureValid) {
                pElement->dwPass1Quality &= ~CERT_QUALITY_SIGNATURE_VALID;
            }
        }
    } else {
        assert(fCtlIssuer);
        pElement->dwPass1Quality = 0;
    }

    // Remember highest quality issuer
    if (pElement->dwPass1Quality > m_pSubject->Pass1Quality())
        m_pSubject->SetPass1Quality(pElement->dwPass1Quality);
   
    fResult = TRUE;

CommonReturn:
    *ppElement = pElement;
    return fResult;

ErrorReturn:
    if (pElement) {
        DeleteElement(pElement);
        pElement = NULL;
    }

    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
TRACE_ERROR(GetSubjectStatusError)
TRACE_ERROR(GetSignerError)
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::DeleteElement, public
//
//  Synopsis:   delete an element
//
//----------------------------------------------------------------------------
VOID
CCertIssuerList::DeleteElement (IN PCERT_ISSUER_ELEMENT pElement)
{
    if ( pElement->pCtlIssuerData )
    {
        ChainFreeCtlIssuerData( pElement->pCtlIssuerData );
    }

    if (pElement->fHasRevocationInfo) {
        if (pElement->RevocationCrlInfo.pBaseCrlContext)
            CertFreeCRLContext(pElement->RevocationCrlInfo.pBaseCrlContext);
        if (pElement->RevocationCrlInfo.pDeltaCrlContext)
            CertFreeCRLContext(pElement->RevocationCrlInfo.pDeltaCrlContext);
    }

    delete pElement;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::CheckForDuplicateElement, public
//
//  Synopsis:   check for a duplicate element
//
//----------------------------------------------------------------------------
BOOL
CCertIssuerList::CheckForDuplicateElement (
                      IN BYTE rgbHash[ CHAINHASHLEN ],
                      IN BOOL fCtlIssuer
                      )
{
    PCERT_ISSUER_ELEMENT pElement = NULL;

    while ( ( pElement = NextElement( pElement ) ) != NULL )
    {
        if ( pElement->fCtlIssuer == fCtlIssuer )
        {
            if ( fCtlIssuer == FALSE )
            {
                if ( memcmp(
                        rgbHash,
                        pElement->pIssuer->CertObject()->CertHash(),
                        CHAINHASHLEN
                        ) == 0 )
                {
                    return( TRUE );
                }
            }
            else
            {
                if ( memcmp(
                        rgbHash,
                        pElement->pCtlIssuerData->pSSCtlObject->CtlHash(),
                        CHAINHASHLEN
                        ) == 0 )
                {
                    return( TRUE );
                }
            }
        }
    }

    return( FALSE );
}

//+===========================================================================
//  CCertObjectCache methods
//============================================================================

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::CCertObjectCache, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CCertObjectCache::CCertObjectCache (
                       IN DWORD MaxIndexEntries,
                       OUT BOOL& rfResult
                       )
{
    LRU_CACHE_CONFIG Config;

    memset( &Config, 0, sizeof( Config ) );

    Config.dwFlags = LRU_CACHE_NO_SERIALIZE | LRU_CACHE_NO_COPY_IDENTIFIER;
    Config.cBuckets = DEFAULT_CERT_OBJECT_CACHE_BUCKETS;

    m_hHashIndex = NULL;
    m_hIdentifierIndex = NULL;
    m_hKeyIdIndex = NULL;
    m_hSubjectNameIndex = NULL;
    m_hPublicKeyHashIndex = NULL;
    m_hEndHashIndex = NULL;

    Config.pfnHash = CertObjectCacheHashNameIdentifier;

    rfResult = I_CryptCreateLruCache( &Config, &m_hSubjectNameIndex );

    Config.pfnHash = CertObjectCacheHashMd5Identifier;

    if ( rfResult == TRUE )
    {
        rfResult = I_CryptCreateLruCache( &Config, &m_hIdentifierIndex );
    }

    if ( rfResult == TRUE )
    {
        rfResult = I_CryptCreateLruCache( &Config, &m_hKeyIdIndex );
    }

    if ( rfResult == TRUE )
    {
        rfResult = I_CryptCreateLruCache( &Config, &m_hPublicKeyHashIndex );
    }

    Config.pfnOnRemoval = CertObjectCacheOnRemovalFromPrimaryIndex;

    if ( rfResult == TRUE )
    {
        rfResult = I_CryptCreateLruCache( &Config, &m_hHashIndex );
    }

    Config.MaxEntries = MaxIndexEntries;
    Config.pfnOnRemoval = CertObjectCacheOnRemovalFromEndHashIndex;

    if ( rfResult == TRUE )
    {
        rfResult = I_CryptCreateLruCache( &Config, &m_hEndHashIndex );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::~CCertObjectCache, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CCertObjectCache::~CCertObjectCache ()
{
    I_CryptFreeLruCache(
           m_hHashIndex,
           0,
           NULL
           );

    I_CryptFreeLruCache(
           m_hSubjectNameIndex,
           LRU_SUPPRESS_REMOVAL_NOTIFICATION,
           NULL
           );

    I_CryptFreeLruCache(
           m_hIdentifierIndex,
           LRU_SUPPRESS_REMOVAL_NOTIFICATION,
           NULL
           );

    I_CryptFreeLruCache(
           m_hKeyIdIndex,
           LRU_SUPPRESS_REMOVAL_NOTIFICATION,
           NULL
           );

    I_CryptFreeLruCache(
           m_hPublicKeyHashIndex,
           LRU_SUPPRESS_REMOVAL_NOTIFICATION,
           NULL
           );

    I_CryptFreeLruCache(
           m_hEndHashIndex,
           0,
           NULL
           );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::AddIssuerObject, public
//
//  Synopsis:   add an issuer object to the cache

//              Increments engine's touch count
//
//----------------------------------------------------------------------------
VOID
CCertObjectCache::AddIssuerObject (
                     IN PCCHAINCALLCONTEXT pCallContext,
                     IN PCCERTOBJECT pCertObject
                     )
{
    assert(CERT_CACHED_ISSUER_OBJECT_TYPE == pCertObject->ObjectType());
    pCertObject->AddRef();

    I_CryptInsertLruEntry( pCertObject->HashIndexEntry(), pCallContext );
    I_CryptInsertLruEntry( pCertObject->IdentifierIndexEntry(), pCallContext );
    I_CryptInsertLruEntry( pCertObject->SubjectNameIndexEntry(), pCallContext );
    I_CryptInsertLruEntry( pCertObject->KeyIdIndexEntry(), pCallContext );
    I_CryptInsertLruEntry( pCertObject->PublicKeyHashIndexEntry(),
        pCallContext );

    pCallContext->TouchEngine();

    CertPerfIncrementChainCertCacheCount();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::AddEndObject, public
//
//  Synopsis:   add an end object to the cache
//
//----------------------------------------------------------------------------
VOID
CCertObjectCache::AddEndObject (
                     IN PCCHAINCALLCONTEXT pCallContext,
                     IN PCCERTOBJECT pCertObject
                     )
{
    PCCERTOBJECT pDuplicate;


    if (CERT_END_OBJECT_TYPE != pCertObject->ObjectType())
        return;

    pDuplicate = FindEndObjectByHash(pCertObject->CertHash());
    if (pDuplicate) {
        pDuplicate->Release();
        return;
    }

    if (pCertObject->CacheEndObject(pCallContext)) {
        pCertObject->AddRef();

        I_CryptInsertLruEntry( pCertObject->EndHashIndexEntry(), pCallContext );

        CertPerfIncrementChainCertCacheCount();

        CertPerfIncrementChainCacheEndCertCount();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::FindIssuerObject, public
//
//  Synopsis:   find object
//
//  Note, also called by FindEndObjectByHash
//
//----------------------------------------------------------------------------
PCCERTOBJECT
CCertObjectCache::FindIssuerObject (
                      IN HLRUCACHE hIndex,
                      IN PCRYPT_DATA_BLOB pIdentifier
                      )
{
    HLRUENTRY    hFound;
    PCCERTOBJECT pFound = NULL;

    hFound = I_CryptFindLruEntry( hIndex, pIdentifier );
    if ( hFound != NULL )
    {
        pFound = (PCCERTOBJECT)I_CryptGetLruEntryData( hFound );
        pFound->AddRef();

        I_CryptReleaseLruEntry( hFound );
    }

    return( pFound );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::FindIssuerObjectByHash, public
//
//  Synopsis:   find object by hash
//
//----------------------------------------------------------------------------
PCCERTOBJECT
CCertObjectCache::FindIssuerObjectByHash (
                      IN BYTE rgbCertHash[ CHAINHASHLEN ]
                      )
{
    CRYPT_DATA_BLOB   DataBlob;

    DataBlob.cbData = CHAINHASHLEN;
    DataBlob.pbData = rgbCertHash;
    return( FindIssuerObject( m_hHashIndex, &DataBlob ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::FindEndObjectByHash, public
//
//  Synopsis:   find object by hash
//
//----------------------------------------------------------------------------
PCCERTOBJECT
CCertObjectCache::FindEndObjectByHash (
                      IN BYTE rgbCertHash[ CHAINHASHLEN ]
                      )
{
    CRYPT_DATA_BLOB   DataBlob;

    DataBlob.cbData = CHAINHASHLEN;
    DataBlob.pbData = rgbCertHash;
    return( FindIssuerObject( m_hEndHashIndex, &DataBlob ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::NextMatchingIssuerObject, public
//
//  Synopsis:   next matching issuer object
//
//----------------------------------------------------------------------------
PCCERTOBJECT
CCertObjectCache::NextMatchingIssuerObject (
                      IN HLRUENTRY hObjectEntry,
                      IN PCCERTOBJECT pCertObject
                      )
{
    HLRUENTRY    hFound;
    PCCERTOBJECT pFound = NULL;

    I_CryptAddRefLruEntry( hObjectEntry );

    hFound = I_CryptEnumMatchingLruEntries( hObjectEntry );
    if ( hFound != NULL )
    {
        pFound = (PCCERTOBJECT)I_CryptGetLruEntryData( hFound );
        pFound->AddRef();

        I_CryptReleaseLruEntry( hFound );
    }

    pCertObject->Release();

    return( pFound );
}

//+===========================================================================
//  CCertChainEngine methods
//============================================================================

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::CCertChainEngine, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CCertChainEngine::CCertChainEngine (
                       IN PCERT_CHAIN_ENGINE_CONFIG pConfig,
                       IN BOOL fDefaultEngine,
                       OUT BOOL& rfResult
                       )
{
    HCERTSTORE hWorld = NULL;
    DWORD      dwStoreFlags = CERT_SYSTEM_STORE_CURRENT_USER;

    assert( pConfig->cbSize == sizeof( CERT_CHAIN_ENGINE_CONFIG ) );

    rfResult = TRUE;

    m_cRefs = 1;
    m_hRootStore = NULL;
    m_hRealRootStore = NULL;
    m_hTrustStore = NULL;
    m_hOtherStore = NULL;
    m_hCAStore = NULL;
    m_hEngineStore = NULL;
    m_hEngineStoreChangeEvent = NULL;
    m_pCertObjectCache = NULL;
    m_pSSCtlObjectCache = NULL;
    m_dwFlags = pConfig->dwFlags;
    if (0 == pConfig->dwUrlRetrievalTimeout)
    {
        m_dwUrlRetrievalTimeout = DEFAULT_ENGINE_URL_RETRIEVAL_TIMEOUT;
        m_fDefaultUrlRetrievalTimeout = TRUE;
    }
    else
    {
        m_dwUrlRetrievalTimeout = pConfig->dwUrlRetrievalTimeout;
        m_fDefaultUrlRetrievalTimeout = FALSE;
    }
    m_dwTouchEngineCount = 0;

    m_pCrossCertDPEntry = NULL;
    m_pCrossCertDPLink = NULL;
    m_hCrossCertStore = NULL;
    m_dwCrossCertDPResyncIndex = 0;
    m_pAuthRootAutoUpdateInfo = NULL;

    if ( !Pki_InitializeCriticalSection( &m_Lock ))
    {
        rfResult = FALSE;
        return;
    }

    if ( pConfig->dwFlags & CERT_CHAIN_USE_LOCAL_MACHINE_STORE )
    {
        dwStoreFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
    }

    if ( pConfig->dwFlags & CERT_CHAIN_ENABLE_SHARE_STORE )
    {
        dwStoreFlags |= CERT_STORE_SHARE_STORE_FLAG;
    }

    dwStoreFlags |= CERT_STORE_SHARE_CONTEXT_FLAG;

    m_hRealRootStore = CertOpenStore(
                           CERT_STORE_PROV_SYSTEM_W,
                           X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                           NULL,
                           dwStoreFlags |
                               CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                           L"root"
                           );

    if ( m_hRealRootStore == NULL )
    {
        rfResult = FALSE;
        return;
    }

    m_hCAStore = CertOpenStore(
                     CERT_STORE_PROV_SYSTEM_W,
                     X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                     NULL,
                     dwStoreFlags |
                         CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                     L"ca"
                     );

    if ( pConfig->hRestrictedRoot != NULL )
    {
        if ( ChainIsProperRestrictedRoot(
                  m_hRealRootStore,
                  pConfig->hRestrictedRoot
                  ) == TRUE )
        {
            m_hRootStore = CertDuplicateStore( pConfig->hRestrictedRoot );

            // Having restricted roots implicitly disables the auto
            // updating of roots
            m_dwFlags |= CERT_CHAIN_DISABLE_AUTH_ROOT_AUTO_UPDATE;
        }
    }
    else
    {
        m_hRootStore = CertDuplicateStore( m_hRealRootStore );
    }

    if ( m_hRootStore == NULL )
    {
        rfResult = FALSE;
        return;
    }

    if ( ( pConfig->hRestrictedTrust == NULL ) ||
         ( pConfig->hRestrictedOther == NULL ) )
    {
        rfResult = ChainCreateWorldStore(
                        m_hRootStore,
                        m_hCAStore,
                        pConfig->cAdditionalStore,
                        pConfig->rghAdditionalStore,
                        dwStoreFlags,
                        &hWorld
                        );

        if ( rfResult == FALSE )
        {
            return;
        }
    }

    if ( pConfig->hRestrictedTrust != NULL )
    {
        m_hTrustStore = CertDuplicateStore( pConfig->hRestrictedTrust );
    }
    else
    {
        m_hTrustStore = CertDuplicateStore( hWorld );
    }

    m_hOtherStore = CertOpenStore(
                        CERT_STORE_PROV_COLLECTION,
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        NULL,
                        CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                        NULL
                        );

    if ( m_hOtherStore != NULL )
    {
        if ( pConfig->hRestrictedOther != NULL )
        {
            rfResult = CertAddStoreToCollection(
                           m_hOtherStore,
                           pConfig->hRestrictedOther,
                           0,
                           0
                           );

            if ( rfResult == TRUE )
            {
                rfResult = CertAddStoreToCollection(
                               m_hOtherStore,
                               m_hRootStore,
                               0,
                               0
                               );
            }
        }
        else
        {
            rfResult = CertAddStoreToCollection(
                           m_hOtherStore,
                           hWorld,
                           0,
                           0
                           );

            if ( ( rfResult == TRUE ) && ( pConfig->hRestrictedTrust != NULL ) )
            {
                rfResult = CertAddStoreToCollection(
                               m_hOtherStore,
                               pConfig->hRestrictedTrust,
                               0,
                               0
                               );
            }
        }
    }
    else
    {
        rfResult = FALSE;
    }

    if ( hWorld != NULL )
    {
        CertCloseStore( hWorld, 0 );
    }

    if ( rfResult == TRUE )
    {
        rfResult = ChainCreateEngineStore(
                        m_hRootStore,
                        m_hTrustStore,
                        m_hOtherStore,
                        fDefaultEngine,
                        pConfig->dwFlags,
                        &m_hEngineStore,
                        &m_hEngineStoreChangeEvent
                        );
    }

    if ( rfResult == TRUE )
    {
        rfResult = ChainCreateCertificateObjectCache(
                        pConfig->MaximumCachedCertificates,
                        &m_pCertObjectCache
                        );
    }

    if ( rfResult == TRUE )
    {
        rfResult = SSCtlCreateObjectCache( &m_pSSCtlObjectCache );
    }

    if ( rfResult == TRUE )
    {
        rfResult = m_pSSCtlObjectCache->PopulateCache( this );
    }

    assert( m_hRootStore != NULL );


    // Beginning of cross certificate stuff

    if ( rfResult == FALSE )
    {
        return;
    }

    m_hCrossCertStore = CertOpenStore(
        CERT_STORE_PROV_COLLECTION,
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        NULL,
        CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
        NULL
        );

    if ( m_hCrossCertStore == NULL )
    {
        rfResult = FALSE;
        return;
    }

    rfResult = GetCrossCertDistPointsForStore(
         m_hEngineStore,
         &m_pCrossCertDPLink
         );
    if ( rfResult == FALSE )
    {
        return;
    }

    rfResult = CertAddStoreToCollection(
         m_hOtherStore,
         m_hCrossCertStore,
         0,
         0
         );

    // End of cross certificate stuff

    CertPerfIncrementChainEngineCurrentCount();
    CertPerfIncrementChainEngineTotalCount();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::~CCertChainEngine, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CCertChainEngine::~CCertChainEngine ()
{
    CertPerfDecrementChainEngineCurrentCount();

    // Beginning of cross certificate stuff

    FreeCrossCertDistPoints(
        &m_pCrossCertDPLink
        );

    assert( NULL == m_pCrossCertDPLink );
    assert( NULL == m_pCrossCertDPEntry );

    if ( m_hCrossCertStore != NULL )
    {
        CertCloseStore( m_hCrossCertStore, 0 );
    }

    // End of cross certificate stuff

    FreeAuthRootAutoUpdateInfo(m_pAuthRootAutoUpdateInfo);


    ChainFreeCertificateObjectCache( m_pCertObjectCache );
    SSCtlFreeObjectCache( m_pSSCtlObjectCache );

    if ( m_hRootStore != NULL )
    {
        CertCloseStore( m_hRootStore, 0 );
    }

    if ( m_hRealRootStore != NULL )
    {
        CertCloseStore( m_hRealRootStore, 0 );
    }

    if ( m_hTrustStore != NULL )
    {
        CertCloseStore( m_hTrustStore, 0 );
    }

    if ( m_hOtherStore != NULL )
    {
        CertCloseStore( m_hOtherStore, 0 );
    }

    if ( m_hCAStore != NULL )
    {
        CertCloseStore( m_hCAStore, 0 );
    }

    if ( m_hEngineStore != NULL )
    {
        if ( m_hEngineStoreChangeEvent != NULL )
        {
            CertControlStore(
                m_hEngineStore,
                0,                              // dwFlags
                CERT_STORE_CTRL_CANCEL_NOTIFY,
                &m_hEngineStoreChangeEvent
                );
        }

        CertCloseStore( m_hEngineStore, 0 );
    }

    if ( m_hEngineStoreChangeEvent != NULL )
    {
        CloseHandle( m_hEngineStoreChangeEvent );
    }

    DeleteCriticalSection( &m_Lock );
}


// "CrossCA"
const BYTE rgbEncodedCrossCAUnicodeString[] = {
    0x1E, 0x0E,
        0x00, 0x43, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x73,
        0x00, 0x73, 0x00, 0x43, 0x00, 0x41
};

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::GetChainContext, public
//
//  Synopsis:   get a certificate chain context
//
//              NOTE: This method acquires the engine lock
//
//----------------------------------------------------------------------------
BOOL
CCertChainEngine::GetChainContext (
                     IN PCCERT_CONTEXT pCertContext,
                     IN LPFILETIME pTime,
                     IN OPTIONAL HCERTSTORE hAdditionalStore,
                     IN OPTIONAL PCERT_CHAIN_PARA pChainPara,
                     IN DWORD dwFlags,
                     IN LPVOID pvReserved,
                     OUT PCCERT_CHAIN_CONTEXT* ppChainContext
                     )
{
    BOOL fResult;
    DWORD dwLastError = 0;
    PCCHAINCALLCONTEXT pCallContext = NULL;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;

    if (!CallContextCreateCallObject(
            this,
            pTime,
            pChainPara,
            dwFlags,
            &pCallContext
            ))
        goto CallContextCreateCallObjectError;

    if (!CreateChainContextFromPathGraph(
            pCallContext,
            pCertContext,
            hAdditionalStore,
            &pChainContext
            ))
        goto CreateChainContextFromPathGraphError;

    if ((pChainContext->TrustStatus.dwErrorStatus & CERT_TRUST_IS_REVOKED) &&
            pCallContext->IsOnline()) {
        // For a revoked CA, try to retrieve a newer CA cert via the subject's
        // AIA extension.
        //
        // Note, will only try for the first revoked CA cert in the first
        // simple chain.

        HCERTSTORE hNewerIssuerUrlStore = NULL;
        PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[0];
        DWORD cEle = pChain->cElement;
        PCERT_CHAIN_ELEMENT *ppEle = pChain->rgpElement;
        DWORD i;

        for (i = 1; i < cEle; i++) {
            PCERT_CHAIN_ELEMENT pIssuerEle = ppEle[i];

            if (pIssuerEle->TrustStatus.dwErrorStatus & CERT_TRUST_IS_REVOKED) {
                // First Revoked CA

                PCCERT_CONTEXT pIssuerCert = pIssuerEle->pCertContext;
                PCERT_EXTENSION pExt;

                // Ignore CrossCA's. If the CA cert has a Certificate
                // Template Name extension we will check if its set to
                // "CrossCA". Note, this is only a hint. Its not a
                // requirement to have this extension for a cross cert.
                pExt = CertFindExtension(
                    szOID_ENROLL_CERTTYPE_EXTENSION,
                    pIssuerCert->pCertInfo->cExtension,
                    pIssuerCert->pCertInfo->rgExtension
                    );
                if (pExt && pExt->Value.cbData ==
                                sizeof(rgbEncodedCrossCAUnicodeString) &&
                        0 == memcmp(pExt->Value.pbData,
                            rgbEncodedCrossCAUnicodeString,
                            sizeof(rgbEncodedCrossCAUnicodeString)))
                    break;
            
                hNewerIssuerUrlStore = GetNewerIssuerUrlStore(
                    pCallContext,
                    ppEle[i - 1]->pCertContext,      // Subject
                    pIssuerCert
                    );

                break;
            }
        }

        if (hNewerIssuerUrlStore) {
            // Rebuild the chain using the newer AIA retrieved Issuer cert

            HCERTSTORE hNewerAdditionalStore = NULL;

            if (hAdditionalStore) {
                hNewerAdditionalStore = CertOpenStore(
                    CERT_STORE_PROV_COLLECTION,
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    NULL,
                    CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                    NULL
                    );
                if (hNewerAdditionalStore) {
                    if (!CertAddStoreToCollection(hNewerAdditionalStore,
                            hNewerIssuerUrlStore, 0, 0) ||
                        !CertAddStoreToCollection(hNewerAdditionalStore,
                            hAdditionalStore, 0, 0)) {

                        CertCloseStore(hNewerAdditionalStore, 0);
                        hNewerAdditionalStore = NULL;
                    }
                }
            } else 
                hNewerAdditionalStore =
                    CertDuplicateStore(hNewerIssuerUrlStore);

            if (hNewerAdditionalStore) {
                PCCERT_CHAIN_CONTEXT pNewerChainContext = NULL;

                LockEngine();

                pCallContext->FlushObjectsInCreationCache( );

                UnlockEngine();

                if (CreateChainContextFromPathGraph(
                        pCallContext,
                        pCertContext,
                        hNewerAdditionalStore,
                        &pNewerChainContext
                        )) {
                    assert(pNewerChainContext);
                    CertFreeCertificateChain(pChainContext);
                    pChainContext = pNewerChainContext;
                }

                CertCloseStore(hNewerAdditionalStore, 0);
            }

            CertCloseStore(hNewerIssuerUrlStore, 0);
        }
    }


    fResult = TRUE;

CommonReturn:
    if (pCallContext) {
        LockEngine();

        CallContextFreeCallObject(pCallContext);

        UnlockEngine();
    }

    if (0 != dwLastError)
        SetLastError(dwLastError);

    *ppChainContext = pChainContext;
    return fResult;

ErrorReturn:
    dwLastError = GetLastError();

    assert(NULL == pChainContext);
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CallContextCreateCallObjectError)
TRACE_ERROR(CreateChainContextFromPathGraphError)
}


//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::CreateChainContextFromPathGraph, public
//
//  Synopsis:   builds a chain path graph and returns quality ordered
//              chain contexts
//
//              NOTE: This method acquires the engine lock
//
//----------------------------------------------------------------------------
BOOL
CCertChainEngine::CreateChainContextFromPathGraph (
                     IN PCCHAINCALLCONTEXT pCallContext,
                     IN PCCERT_CONTEXT pCertContext,
                     IN OPTIONAL HCERTSTORE hAdditionalStore,
                     OUT PCCERT_CHAIN_CONTEXT* ppChainContext
                     )
{
    BOOL fResult;
    DWORD dwLastError = 0;
    BOOL fLocked = FALSE;
    BYTE rgbCertHash[CHAINHASHLEN];
    DWORD cbCertHash;
    PCCERTOBJECT pEndCertObject = NULL;
    PCCHAINPATHOBJECT pEndPathObject = NULL;
    PCCHAINPATHOBJECT pTopPathObject = NULL;
    HCERTSTORE hAdditionalStoreToUse = NULL;
    HCERTSTORE hAllStore = NULL;
    PINTERNAL_CERT_CHAIN_CONTEXT pNewChainContext = NULL;   // don't release
    PINTERNAL_CERT_CHAIN_CONTEXT pChainContext = NULL;
    DWORD cChainContext = 0;
    DWORD dwFlags = pCallContext->CallFlags();

    cbCertHash = CHAINHASHLEN;
    if (!CertGetCertificateContextProperty(
            pCertContext,
            CERT_MD5_HASH_PROP_ID,
            rgbCertHash,
            &cbCertHash
            ) || CHAINHASHLEN != cbCertHash)
        goto GetCertHashError;

    if (hAdditionalStore) {
        if (!ChainCreateCollectionIncludingCtlCertificates(
                hAdditionalStore,
                &hAdditionalStoreToUse
                ))
            goto CreateAdditionalStoreCollectionError;

        hAllStore = CertOpenStore(
            CERT_STORE_PROV_COLLECTION,
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            NULL,
            CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
            NULL
            );
        if (NULL == hAllStore)
            goto OpenAllCollectionError;
        if (!CertAddStoreToCollection(hAllStore, OtherStore(), 0, 0 ))
            goto AddToAllCollectionError;
        if (!CertAddStoreToCollection(hAllStore, hAdditionalStoreToUse, 0, 0 ))
            goto AddToAllCollectionError;
    } else 
        hAllStore = CertDuplicateStore(OtherStore());

    LockEngine();
    fLocked = TRUE;

    // We're in this loop to handle the case where we leave the engine's
    // critical section and another thread has entered the engine's
    // critical section and done a resync or added a cached issuer cert object.
    while (TRUE) {
        if (!Resync(pCallContext, FALSE))
            goto ResyncError;

        pCallContext->ResetTouchEngine();

        assert(NULL == pEndCertObject);
        pEndCertObject = m_pCertObjectCache->FindIssuerObjectByHash(
            rgbCertHash);

        fResult = TRUE;
        if (NULL == pEndCertObject) {
            pEndCertObject = m_pCertObjectCache->FindEndObjectByHash(
                rgbCertHash);

            if (NULL == pEndCertObject) {
                fResult = ChainCreateCertObject(
                        CERT_END_OBJECT_TYPE,
                        pCallContext,
                        pCertContext,
                        rgbCertHash,
                        &pEndCertObject
                        );
            } else {
                CertPerfIncrementChainEndCertInCacheCount();
            }
        }

        if (pCallContext->IsTouchedEngine()) {
            // The chain engine was touched at some point when we left
            // the engine's lock to create the end cert object
            if (pEndCertObject) {
                pEndCertObject->Release();
                pEndCertObject = NULL;
            }

            continue;
        }

        if (!fResult)
            goto CreateCertObjectError;
        assert(pEndCertObject);

        // This will create the entire path graph
        fResult = ChainCreatePathObject(
                       pCallContext,
                       pEndCertObject,
                       hAdditionalStoreToUse,
                       &pEndPathObject
                       );

        if (pCallContext->IsTouchedEngine()) {
            // The chain engine was touched at some point when we left
            // the engine's lock to verify a signature or do URL fetching.

            pEndCertObject->Release();
            pEndCertObject = NULL;
            pEndPathObject = NULL;
            pCallContext->FlushObjectsInCreationCache( );
        } else
            break;
    }

    if (!fResult)
        goto CreatePathObjectError;

    if (pCallContext->CallOrEngineFlags() & CERT_CHAIN_CACHE_END_CERT)
        m_pCertObjectCache->AddEndObject(pCallContext, pEndCertObject);


    // Create the ChainContext without holding the engine lock
    UnlockEngine();
    fLocked = FALSE;

    // Loop through all the certificate paths:
    //  - Calculate additional status
    //  - Create chain context and its quality value
    //  - Determine highest quality chain
    //  - Optionally, maintain a linked list of the lower quality chains

    while (pTopPathObject = pEndPathObject->NextPath(
            pCallContext,
            pTopPathObject
            )) {
        PCCHAINPATHOBJECT pPathObject;

        // Loop downward to calculate additional status
        for (pPathObject = pTopPathObject;
                pPathObject && !pPathObject->HasAdditionalStatus();
                            pPathObject = pPathObject->DownPathObject()) {
            pPathObject->CalculateAdditionalStatus(
                pCallContext,
                hAllStore
                );
        }

        // Also calculates the chain's quality value
        pNewChainContext = pEndPathObject->CreateChainContextFromPath(
            pCallContext,
            pTopPathObject
            );
        if (NULL == pNewChainContext)
            goto CreateChainContextFromPathError;

        // Fixup end cert
        ChainUpdateEndEntityCertContext(pNewChainContext, pCertContext);

        // Add logic to call either the chain engine's or the caller's
        // callback function here to provide additional chain context
        // quality

        if (NULL == pChainContext) {
            pChainContext = pNewChainContext;
            cChainContext = 1;
        } else {
            BOOL fNewHigherQuality = FALSE;

            if (pNewChainContext->dwQuality > pChainContext->dwQuality)
                fNewHigherQuality = TRUE;
            else if (pNewChainContext->dwQuality == pChainContext->dwQuality) {
                BOOL fDupPublicKey = FALSE;

                PCERT_SIMPLE_CHAIN pChain =
                    pChainContext->ChainContext.rgpChain[0];
                PCERT_SIMPLE_CHAIN pNewChain =
                    pNewChainContext->ChainContext.rgpChain[0];
                DWORD cElement = pChain->cElement;
                DWORD cNewElement = pNewChain->cElement;

                if (cElement != cNewElement) {
                    // Check if the longer chain has any duplicate public
                    // keys. This could happen if we have 2 sets of cross
                    // certificates

                    PCERT_SIMPLE_CHAIN pLongChain;
                    DWORD cLongElement;
                    DWORD i;

                    if (cElement > cNewElement) {
                        pLongChain = pChain;
                        cLongElement = cElement;
                    } else {
                        pLongChain = pNewChain;
                        cLongElement = cNewElement;
                    }

                    // Start with the CA and compare all keys up to and
                    // including the root
                    for (i = 1; i + 1 < cLongElement; i++) {
                        DWORD j;
                        DWORD cbHash;
                        BYTE rgbHash0[ CHAINHASHLEN ];

                        cbHash = CHAINHASHLEN;
                        if (!CertGetCertificateContextProperty(
                                pLongChain->rgpElement[i]->pCertContext,
                                CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID,
                                rgbHash0,
                                &cbHash
                                ) || CHAINHASHLEN != cbHash)
                            break;

                        for (j = i + 1; j < cLongElement; j++) {
                            BYTE rgbHash1[ CHAINHASHLEN ];

                            cbHash = CHAINHASHLEN;
                            if (!CertGetCertificateContextProperty(
                                    pLongChain->rgpElement[j]->pCertContext,
                                    CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID,
                                    rgbHash1,
                                    &cbHash
                                    ) || CHAINHASHLEN != cbHash)
                                break;

                            if (0 == memcmp(rgbHash0, rgbHash1, CHAINHASHLEN)) {
                                fDupPublicKey = TRUE;
                                break;
                            }
                        }

                        if (fDupPublicKey)
                            break;
                    }
                }

                if (fDupPublicKey) {
                    if (cElement > cNewElement)
                        fNewHigherQuality = TRUE;
                } else {
                    DWORD i;
                    DWORD cMinElement;

                    // Chains having certs with later NotAfter/NotBefore dates
                    // starting with the first CA cert are considered higher
                    // quality when dwQuality is the same. Will only compare
                    // the first simple chain.
                    cMinElement = min(cElement, cNewElement);

                    for (i = 1; i < cMinElement; i++) {
                        LONG lCmp;

                        PCERT_INFO pCertInfo =
                            pChain->rgpElement[i]->pCertContext->pCertInfo;
                        PCERT_INFO pNewCertInfo =
                            pNewChain->rgpElement[i]->pCertContext->pCertInfo;
                        
                        lCmp = CompareFileTime(&pNewCertInfo->NotAfter,
                            &pCertInfo->NotAfter);
                        if (0 < lCmp) {
                            fNewHigherQuality = TRUE;
                            break;
                        } else if (0 > lCmp) {
                            break;
                        } else {
                            // Same NotAfter. Check NotBefore.
                            lCmp = CompareFileTime(&pNewCertInfo->NotBefore,
                                &pCertInfo->NotBefore);
                            if (0 < lCmp) {
                                fNewHigherQuality = TRUE;
                                break;
                            } else if (0 > lCmp)
                                break;
                            // else
                            //  Same
                        }
                    }
                }
            }
            // else
            //  fNewHigherQuality = FALSE;

            if (fNewHigherQuality) {
                if (dwFlags & CERT_CHAIN_RETURN_LOWER_QUALITY_CONTEXTS) {
                    pNewChainContext->pNext = pChainContext;
                    pChainContext = pNewChainContext;
                    cChainContext++;
                } else {
                    ChainReleaseInternalChainContext(pChainContext);
                    pChainContext = pNewChainContext;
                }
            } else {
                if (dwFlags & CERT_CHAIN_RETURN_LOWER_QUALITY_CONTEXTS) {
                    PINTERNAL_CERT_CHAIN_CONTEXT p;

                    // Insert according to quality
                    for (p = pChainContext;
                             p->pNext && p->pNext->dwQuality >=
                                 pNewChainContext->dwQuality;
                                                                p = p->pNext) {
                        ;
                    }

                    pNewChainContext->pNext = p->pNext;
                    p->pNext = pNewChainContext;

                    cChainContext++;
                } else {
                    ChainReleaseInternalChainContext(pNewChainContext);
                }
            }
        }
    }

    if (GetLastError() != CRYPT_E_NOT_FOUND)
        goto NextPathError;

    assert(pChainContext && cChainContext);


    if (cChainContext > 1) {
        PINTERNAL_CERT_CHAIN_CONTEXT p;
        PCCERT_CHAIN_CONTEXT *ppLower;

        // Create array of lower quality chain contexts
        ppLower = new PCCERT_CHAIN_CONTEXT [ cChainContext - 1];
        if (NULL == ppLower)
            goto OutOfMemory;

        pChainContext->ChainContext.cLowerQualityChainContext =
            cChainContext - 1;
        pChainContext->ChainContext.rgpLowerQualityChainContext = ppLower;

        for (p = pChainContext->pNext; p; p = p->pNext, ppLower++) {
            assert(cChainContext > 1);
            cChainContext--;

            *ppLower = (PCCERT_CHAIN_CONTEXT) p;
        }

    }

    assert(1 == cChainContext);

    fResult = TRUE;

CommonReturn:
    if (!fLocked)
        LockEngine();

    if (pEndCertObject)
        pEndCertObject->Release();

    if (hAllStore)
        CertCloseStore(hAllStore, 0);
    if (hAdditionalStoreToUse)
        CertCloseStore(hAdditionalStoreToUse, 0);


    *ppChainContext = (PCCERT_CHAIN_CONTEXT) pChainContext;

    UnlockEngine();

    if (0 != dwLastError)
        SetLastError(dwLastError);
    return fResult;

ErrorReturn:
    dwLastError = GetLastError();

    if (pChainContext) {
        PINTERNAL_CERT_CHAIN_CONTEXT p;

        while (p = pChainContext->pNext) {
            pChainContext->pNext = p->pNext;
            ChainReleaseInternalChainContext(p);
        }

        ChainReleaseInternalChainContext(pChainContext);
        pChainContext = NULL;
    }

    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetCertHashError)
TRACE_ERROR(CreateAdditionalStoreCollectionError)
TRACE_ERROR(OpenAllCollectionError)
TRACE_ERROR(AddToAllCollectionError)
TRACE_ERROR(ResyncError)
TRACE_ERROR(CreateCertObjectError)
TRACE_ERROR(CreatePathObjectError)
TRACE_ERROR(CreateChainContextFromPathError)
TRACE_ERROR(NextPathError)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::GetIssuerUrlStore, public
//
//  Synopsis:   if the certificate has an Authority Info Access extension,
//              return a store containing the issuing certificates
//
//              Leaves the engine's critical section to do the URL
//              fetching. If the engine was touched by another thread,
//              it fails with LastError set to ERROR_CAN_NOT_COMPLETE.
//
//  Assumption: Chain engine is locked once in the calling thread.
//
//----------------------------------------------------------------------------
BOOL
CCertChainEngine::GetIssuerUrlStore(
    IN PCCHAINCALLCONTEXT pCallContext,
    IN PCCERT_CONTEXT pSubjectCertContext,
    IN DWORD dwRetrievalFlags,
    OUT HCERTSTORE *phIssuerUrlStore
    )
{
    BOOL             fTouchedResult = TRUE;
    BOOL             fResult;
    DWORD            cbUrlArray;
    PCRYPT_URL_ARRAY pUrlArray = NULL;
    DWORD            cCount;
    DWORD            dwCacheResultFlag;

    *phIssuerUrlStore = NULL;

    dwRetrievalFlags |= CRYPT_RETRIEVE_MULTIPLE_OBJECTS |
                            CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL |
                            CRYPT_OFFLINE_CHECK_RETRIEVAL;

    fResult = ChainGetObjectUrl(
                   URL_OID_CERTIFICATE_ISSUER,
                   (LPVOID) pSubjectCertContext,
                   CRYPT_GET_URL_FROM_EXTENSION,
                   NULL,
                   &cbUrlArray,
                   NULL,
                   NULL,
                   NULL
                   );

    if ( fResult == TRUE )
    {
        pUrlArray = (PCRYPT_URL_ARRAY)new BYTE [ cbUrlArray ];
        if ( pUrlArray == NULL )
        {
            SetLastError( (DWORD) E_OUTOFMEMORY );
            return( FALSE );
        }

        fResult = ChainGetObjectUrl(
                       URL_OID_CERTIFICATE_ISSUER,
                       (LPVOID) pSubjectCertContext,
                       CRYPT_GET_URL_FROM_EXTENSION,
                       pUrlArray,
                       &cbUrlArray,
                       NULL,
                       NULL,
                       NULL
                       );
    }

    if ( fResult == TRUE )
    {
        BOOL fLocked = FALSE;

        //
        // We are about to go on the wire to retrieve the issuer certificate.
        // At this time we will release the chain engine lock so others can
        // go about there business while we wait for the protocols to do the
        // fetching.
        //

        UnlockEngine();

        for ( cCount = 0; cCount < pUrlArray->cUrl; cCount++ )
        {
            if ( !( dwRetrievalFlags & CRYPT_CACHE_ONLY_RETRIEVAL ) &&
                  ( ChainIsFileOrLdapUrl( pUrlArray->rgwszUrl[ cCount ] ) == TRUE ) )
            {
                dwCacheResultFlag = CRYPT_DONT_CACHE_RESULT;
            }
            else
            {
                dwCacheResultFlag = 0;
            }

            fResult = ChainRetrieveObjectByUrlW(
                           pUrlArray->rgwszUrl[ cCount ],
                           CONTEXT_OID_CERTIFICATE,
                           dwRetrievalFlags | dwCacheResultFlag,
                           pCallContext->ChainPara()->dwUrlRetrievalTimeout,
                           (LPVOID *)phIssuerUrlStore,
                           NULL,
                           NULL,
                           NULL,
                           NULL
                           );

            if ( fResult == TRUE )
            {
                CertPerfIncrementChainUrlIssuerCount();
                if (dwRetrievalFlags & CRYPT_CACHE_ONLY_RETRIEVAL)
                    CertPerfIncrementChainCacheOnlyUrlIssuerCount();

                //
                // Retake the engine lock. Also check if the engine was
                // touched during our absence.
                //

                LockEngine();
                if (pCallContext->IsTouchedEngine()) {
                    fTouchedResult = FALSE;
                    SetLastError( (DWORD) ERROR_CAN_NOT_COMPLETE );
                }

                fLocked = TRUE;

                ChainCopyToCAStore( this, *phIssuerUrlStore );

                if (!fTouchedResult) {
                    CertCloseStore(*phIssuerUrlStore, 0);
                    *phIssuerUrlStore = NULL;
                }

                break;
            }
        }

        //
        // Retake the engine lock if necessary
        //

        if ( fLocked == FALSE )
        {
            LockEngine();
            if (pCallContext->IsTouchedEngine()) {
                fTouchedResult = FALSE;
                SetLastError( (DWORD) ERROR_CAN_NOT_COMPLETE );
            }
        }
    }

    delete (LPBYTE)pUrlArray;

    // NOTE: Need to somehow log that we tried to retrieve the issuer but
    //       it was inaccessible

    return( fTouchedResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::GetNewerIssuerUrlStore, public
//
//  Synopsis:   if the subject certificate has an Authority Info Access
//              extension, attempts an online URL retrieval of the
//              issuer certificate(s). If any of the URL retrieved
//              certs are different from the input Issuer cert,
//              returns a store containing the issuing certificates.
//              Otherwise, returns NULL store.
//
//  Assumption: Chain engine isn't locked in the calling thread. Also,
//              only called if online.
//
//----------------------------------------------------------------------------
HCERTSTORE
CCertChainEngine::GetNewerIssuerUrlStore(
        IN PCCHAINCALLCONTEXT pCallContext,
        IN PCCERT_CONTEXT pSubjectCertContext,
        IN PCCERT_CONTEXT pIssuerCertContext
        )
{
    HCERTSTORE hNewIssuerUrlStore = NULL;

    LockEngine();

    while (TRUE) {
        pCallContext->ResetTouchEngine();

        GetIssuerUrlStore(
            pCallContext,
            pSubjectCertContext,
            CRYPT_WIRE_ONLY_RETRIEVAL,
            &hNewIssuerUrlStore
            );
        if (!pCallContext->IsTouchedEngine())
            break;

        assert(NULL == hNewIssuerUrlStore);
    }

    UnlockEngine();

    if (hNewIssuerUrlStore) {
        // Discard if it doesn't contain more than just the input
        // pIssuerCertContext

        PCCERT_CONTEXT pCert;

        pCert = NULL;
        while (pCert = CertEnumCertificatesInStore(hNewIssuerUrlStore, pCert)) {
            if (!CertCompareCertificate(
                    pCert->dwCertEncodingType,
                    pCert->pCertInfo,
                    pIssuerCertContext->pCertInfo
                    )) {
                CertFreeCertificateContext(pCert);
                return hNewIssuerUrlStore;
            }
        }

        CertCloseStore(hNewIssuerUrlStore, 0);
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::Resync, public
//
//  Synopsis:   resync the store if necessary
//
//              Leaves the engine's critical section to do the URL
//              fetching. If the engine was touched by another thread,
//              it fails with LastError set to ERROR_CAN_NOT_COMPLETE.
//
//              A resync increments the engine's touch count.
//
//  Assumption: Chain engine is locked once in the calling thread.
//
//----------------------------------------------------------------------------
BOOL
CCertChainEngine::Resync (IN PCCHAINCALLCONTEXT pCallContext, BOOL fForce)
{
    BOOL fResync = FALSE;
    BOOL fResult = TRUE;

    if ( fForce == FALSE )
    {
        if ( WaitForSingleObject(
                 m_hEngineStoreChangeEvent,
                 0
                 ) == WAIT_OBJECT_0 )
        {
            fResync = TRUE;
        }
    }
    else
    {
        fResync = TRUE;
    }


    if ( fResync )
    {
        CertControlStore(
            m_hEngineStore,
            CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG,
            CERT_STORE_CTRL_RESYNC,
            &m_hEngineStoreChangeEvent
            );

        m_pCertObjectCache->FlushObjects( pCallContext );

        fResult = m_pSSCtlObjectCache->Resync( this );

        assert( fResult == TRUE );

        assert( m_hCrossCertStore );

        // Remove CrossCert collection from engine's list. Don't want to
        // also search it for cross cert distribution points
        CertRemoveStoreFromCollection(
            m_hOtherStore,
            m_hCrossCertStore
            );

        fResult = GetCrossCertDistPointsForStore(
             m_hEngineStore,
             &m_pCrossCertDPLink
             );

        CertAddStoreToCollection(
            m_hOtherStore,
            m_hCrossCertStore,
            0,
            0
            );

        pCallContext->TouchEngine();

        CertPerfIncrementChainEngineResyncCount();
    }

    if ( fResult )
    {
        while (TRUE ) {
            pCallContext->ResetTouchEngine();

            // The following 2 updates leave the engine's critical
            // section to do the URL fetching. If the engine was touched by
            // another thread, it fails with LastError set to
            // ERROR_CAN_NOT_COMPLETE and IsTouchedEngine() is TRUE.

            UpdateCrossCerts(pCallContext);
            if (pCallContext->IsTouchedEngine())
                continue;

            m_pSSCtlObjectCache->UpdateCache(this, pCallContext);
            if (!pCallContext->IsTouchedEngine())
                break;
        }
    }

    return( TRUE );
}


//+===========================================================================
//  CCertObject helper functions
//============================================================================

//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateCertObject
//
//  Synopsis:   create a cert object, note since it is a ref-counted
//              object, freeing occurs by doing a pCertObject->Release
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCreateCertObject (
    IN DWORD dwObjectType,
    IN PCCHAINCALLCONTEXT pCallContext,
    IN PCCERT_CONTEXT pCertContext,
    IN OPTIONAL LPBYTE pbCertHash,
    OUT PCCERTOBJECT *ppCertObject
    )
{
    BOOL fResult = TRUE;
    PCCERTOBJECT pCertObject;
    BYTE rgbHash[CHAINHASHLEN];

    if (NULL == pbCertHash) {
        DWORD cbHash = CHAINHASHLEN;

        if (!CertGetCertificateContextProperty(
                pCertContext,
                CERT_MD5_HASH_PROP_ID,
                rgbHash,
                &cbHash
                ) || CHAINHASHLEN != cbHash) {
            *ppCertObject = NULL;
            return FALSE;
        }
        pbCertHash = rgbHash;
    }

    if (CERT_CACHED_ISSUER_OBJECT_TYPE == dwObjectType) {
        pCertObject =
            pCallContext->ChainEngine()->CertObjectCache()->FindIssuerObjectByHash(
                pbCertHash);

        if (NULL != pCertObject) {
            *ppCertObject = pCertObject;
            return TRUE;
        }
    } else {
        PCCHAINPATHOBJECT pPathObject;

        pPathObject = pCallContext->FindPathObjectInCreationCache(
            pbCertHash);
        if (NULL != pPathObject) {
            pCertObject = pPathObject->CertObject();
            pCertObject->AddRef();
            *ppCertObject = pCertObject;

            return TRUE;
        }
    }


    pCertObject = new CCertObject(
                        dwObjectType,
                        pCallContext,
                        pCertContext,
                        pbCertHash,
                        fResult
                        );

    if (NULL != pCertObject) {
        if (!fResult) {
            pCertObject->Release();
            pCertObject = NULL;
        } else if (CERT_CACHED_ISSUER_OBJECT_TYPE == dwObjectType) {
            // Following add increments the engine's touch count
            pCallContext->ChainEngine()->CertObjectCache()->AddIssuerObject(
                pCallContext,
                pCertObject
                );
        }
    } else {
        fResult = FALSE;

    }

    *ppCertObject = pCertObject;
    return fResult;
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainFillCertObjectCtlCacheEnumFn
//
//  Synopsis:   CSSCtlObjectCache::EnumObjects callback used to create
//              the linked list of CTL cache entries.
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainFillCertObjectCtlCacheEnumFn(
     IN LPVOID pvParameter,
     IN PCSSCTLOBJECT pSSCtlObject
     )
{
    PCERT_OBJECT_CTL_CACHE_ENUM_DATA pEnumData =
        (PCERT_OBJECT_CTL_CACHE_ENUM_DATA) pvParameter;
    PCERT_TRUST_LIST_INFO pTrustListInfo = NULL;
    PCERT_OBJECT_CTL_CACHE_ENTRY pEntry = NULL;

    if (!pEnumData->fResult)
        return FALSE;

    if (!pSSCtlObject->GetTrustListInfo(
            pEnumData->pCertObject->CertContext(),
            &pTrustListInfo
            )) {
        DWORD dwErr = GetLastError();
        if (CRYPT_E_NOT_FOUND == dwErr)
            return TRUE;
        else {
            pEnumData->fResult = FALSE;
            pEnumData->dwLastError = dwErr;
            return FALSE;
        }
    }

    pEntry = new CERT_OBJECT_CTL_CACHE_ENTRY;
    if (NULL == pEntry) {
        SSCtlFreeTrustListInfo(pTrustListInfo);

        pEnumData->fResult = FALSE;
        pEnumData->dwLastError = (DWORD) E_OUTOFMEMORY;
        return FALSE;
    }

    pSSCtlObject->AddRef();
    pEntry->pSSCtlObject = pSSCtlObject;
    pEntry->pTrustListInfo = pTrustListInfo;
    pEnumData->pCertObject->InsertCtlCacheEntry(pEntry);
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeCertObjectCtlCache
//
//  Synopsis:   free the linked list of CTL cache entries.
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeCertObjectCtlCache(
     IN PCERT_OBJECT_CTL_CACHE_ENTRY pCtlCacheHead
     )
{
    PCERT_OBJECT_CTL_CACHE_ENTRY pCtlCache;

    while (pCtlCache = pCtlCacheHead) {
        pCtlCacheHead = pCtlCacheHead->pNext;

        if (pCtlCache->pTrustListInfo)
            SSCtlFreeTrustListInfo(pCtlCache->pTrustListInfo);

        if (pCtlCache->pSSCtlObject)
            pCtlCache->pSSCtlObject->Release();

        delete pCtlCache;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainAllocAndDecodeObject
//
//  Synopsis:   allocate and decodes the ASN.1 encoded data structure.
//
//              NULL is returned for a decoding or allocation error.
//              PkiFree must be called to free the allocated data structure.
//
//----------------------------------------------------------------------------
LPVOID WINAPI
ChainAllocAndDecodeObject(
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    )
{
    DWORD cbStructInfo;
    void *pvStructInfo;

    if (!CryptDecodeObjectEx(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_SHARE_OID_STRING_FLAG |
                CRYPT_DECODE_NOCOPY_FLAG |
                CRYPT_DECODE_ALLOC_FLAG,
            &PkiDecodePara,
            (void *) &pvStructInfo,
            &cbStructInfo
            ))
        goto DecodeError;

CommonReturn:
    return pvStructInfo;
ErrorReturn:
    pvStructInfo = NULL;
    goto CommonReturn;
TRACE_ERROR(DecodeError)
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainGetIssuerMatchInfo
//
//  Synopsis:   return match bits specifying the types of issuer matching
//              that can be done for this certificate and if available return
//              the decoded authority key identifier extension
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainGetIssuerMatchInfo (
     IN PCCERT_CONTEXT pCertContext,
     OUT DWORD *pdwIssuerMatchFlags,
     OUT PCERT_AUTHORITY_KEY_ID_INFO* ppAuthKeyIdentifier
     )
{
    PCERT_EXTENSION              pExt;
    LPVOID                       pv = NULL;
    BOOL                         fV1AuthKeyIdInfo = TRUE;
    PCERT_AUTHORITY_KEY_ID_INFO  pAuthKeyIdentifier = NULL;
    DWORD                        dwIssuerMatchFlags = 0;

    pExt = CertFindExtension(
               szOID_AUTHORITY_KEY_IDENTIFIER,
               pCertContext->pCertInfo->cExtension,
               pCertContext->pCertInfo->rgExtension
               );

    if ( pExt == NULL )
    {
        fV1AuthKeyIdInfo = FALSE;

        pExt = CertFindExtension(
                   szOID_AUTHORITY_KEY_IDENTIFIER2,
                   pCertContext->pCertInfo->cExtension,
                   pCertContext->pCertInfo->rgExtension
                   );
    }

    if ( pExt != NULL )
    {

        pv = ChainAllocAndDecodeObject(
            pExt->pszObjId,
            pExt->Value.pbData,
            pExt->Value.cbData
            );
    }

    if ( pv )
    {
        if ( fV1AuthKeyIdInfo == FALSE )
        {
            // NOTENOTE: Yes, this is a bit backwards but, right now but the
            //           V1 structure is a bit easier to deal with and we
            //           only support the V1 version of the V2 structure
            //           anyway
            ChainConvertAuthKeyIdentifierFromV2ToV1(
                (PCERT_AUTHORITY_KEY_ID2_INFO)pv,
                &pAuthKeyIdentifier
                );

        }
        else
        {
            pAuthKeyIdentifier = (PCERT_AUTHORITY_KEY_ID_INFO)pv;
            pv = NULL;
        }

        if ( pAuthKeyIdentifier != NULL )
        {
            if ( ( pAuthKeyIdentifier->CertIssuer.cbData != 0 ) &&
                 ( pAuthKeyIdentifier->CertSerialNumber.cbData != 0 ) )
            {
                dwIssuerMatchFlags |= CERT_EXACT_ISSUER_MATCH_FLAG;
            }

            if ( pAuthKeyIdentifier->KeyId.cbData != 0 )
            {
                dwIssuerMatchFlags |= CERT_KEYID_ISSUER_MATCH_FLAG;
            }

            if (0 == dwIssuerMatchFlags) {
                delete (LPBYTE) pAuthKeyIdentifier;
                pAuthKeyIdentifier = NULL;
            }

        }
    }

    dwIssuerMatchFlags |= CERT_NAME_ISSUER_MATCH_FLAG;

    if (pv)
        PkiFree(pv);

    *pdwIssuerMatchFlags = dwIssuerMatchFlags;
    *ppAuthKeyIdentifier = pAuthKeyIdentifier;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainConvertAuthKeyIdentifierFromV2ToV1
//
//  Synopsis:   convert authority key identifier from V2 to V1
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainConvertAuthKeyIdentifierFromV2ToV1 (
     IN PCERT_AUTHORITY_KEY_ID2_INFO pAuthKeyIdentifier2,
     OUT PCERT_AUTHORITY_KEY_ID_INFO* ppAuthKeyIdentifier
     )
{
    DWORD                       cb;
    PCERT_AUTHORITY_KEY_ID_INFO pAuthKeyIdentifier;
    BOOL                        fExactMatchAvailable = FALSE;

    if ( ( pAuthKeyIdentifier2->AuthorityCertIssuer.cAltEntry == 1 ) &&
         ( pAuthKeyIdentifier2->AuthorityCertIssuer.rgAltEntry[0].dwAltNameChoice ==
           CERT_ALT_NAME_DIRECTORY_NAME ) )
    {
        fExactMatchAvailable = TRUE;
    }

    cb = sizeof( CERT_AUTHORITY_KEY_ID_INFO );
    cb += pAuthKeyIdentifier2->KeyId.cbData;

    if ( fExactMatchAvailable == TRUE )
    {
        cb += pAuthKeyIdentifier2->AuthorityCertIssuer.rgAltEntry[0].DirectoryName.cbData;
        cb += pAuthKeyIdentifier2->AuthorityCertSerialNumber.cbData;
    }

    pAuthKeyIdentifier = (PCERT_AUTHORITY_KEY_ID_INFO)PkiZeroAlloc(cb);
    if ( pAuthKeyIdentifier == NULL )
    {
        return( FALSE );
    }

    pAuthKeyIdentifier->KeyId.cbData = pAuthKeyIdentifier2->KeyId.cbData;
    pAuthKeyIdentifier->KeyId.pbData = (LPBYTE)pAuthKeyIdentifier + sizeof( CERT_AUTHORITY_KEY_ID_INFO );

    memcpy(
       pAuthKeyIdentifier->KeyId.pbData,
       pAuthKeyIdentifier2->KeyId.pbData,
       pAuthKeyIdentifier->KeyId.cbData
       );

    if ( fExactMatchAvailable == TRUE )
    {
        pAuthKeyIdentifier->CertIssuer.cbData = pAuthKeyIdentifier2->AuthorityCertIssuer.rgAltEntry[0].DirectoryName.cbData;
        pAuthKeyIdentifier->CertIssuer.pbData = pAuthKeyIdentifier->KeyId.pbData + pAuthKeyIdentifier->KeyId.cbData;

        memcpy(
           pAuthKeyIdentifier->CertIssuer.pbData,
           pAuthKeyIdentifier2->AuthorityCertIssuer.rgAltEntry[0].DirectoryName.pbData,
           pAuthKeyIdentifier->CertIssuer.cbData
           );

        pAuthKeyIdentifier->CertSerialNumber.cbData = pAuthKeyIdentifier2->AuthorityCertSerialNumber.cbData;
        pAuthKeyIdentifier->CertSerialNumber.pbData = pAuthKeyIdentifier->CertIssuer.pbData + pAuthKeyIdentifier->CertIssuer.cbData;

        memcpy(
           pAuthKeyIdentifier->CertSerialNumber.pbData,
           pAuthKeyIdentifier2->AuthorityCertSerialNumber.pbData,
           pAuthKeyIdentifier->CertSerialNumber.cbData
           );
    }

    *ppAuthKeyIdentifier = pAuthKeyIdentifier;

    return( TRUE );
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeAuthorityKeyIdentifier
//
//  Synopsis:   free the authority key identifier
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeAuthorityKeyIdentifier (
     IN PCERT_AUTHORITY_KEY_ID_INFO pAuthKeyIdInfo
     )
{
    PkiFree(pAuthKeyIdInfo);
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainProcessSpecialOrDuplicateOIDsInUsage
//
//  Synopsis:   process and removes special or duplicate OIDs from the usage
//
//              For szOID_ANY_CERT_POLICY, frees the usage
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainProcessSpecialOrDuplicateOIDsInUsage (
    IN OUT PCERT_ENHKEY_USAGE *ppUsage,
    IN OUT DWORD *pdwFlags
    )
{
    PCERT_ENHKEY_USAGE pUsage = *ppUsage;
    DWORD dwFlags = *pdwFlags;
    LPSTR *ppszOID;
    DWORD cOID;
    DWORD i;

    cOID = pUsage->cUsageIdentifier;
    ppszOID = pUsage->rgpszUsageIdentifier;

    i = 0;
    while (i < cOID) {
        BOOL fSpecialOrDuplicate = TRUE;
        LPSTR pszOID = ppszOID[i];

        if (0 == strcmp(pszOID, szOID_ANY_CERT_POLICY))
            dwFlags |= CHAIN_ANY_POLICY_FLAG;
        else {
            // Check for duplicate OID

            DWORD j;

            fSpecialOrDuplicate = FALSE;
            for (j = 0; j < i; j++) {
                if (0 == strcmp(ppszOID[j], ppszOID[i])) {
                    fSpecialOrDuplicate = TRUE;
                    break;
                }
            }
        }

        if (fSpecialOrDuplicate) {
            // Remove the special or duplicate OID string and move the remaining
            // strings up one.
            DWORD j;

            for (j = i; j + 1 < cOID; j++)
                ppszOID[j] = ppszOID[j + 1];

            cOID--;
            pUsage->cUsageIdentifier = cOID;
        } else
            i++;
    }

    if (dwFlags & CHAIN_ANY_POLICY_FLAG) {
        PkiFree(pUsage);
        *ppUsage = NULL;
    }
        
    *pdwFlags = dwFlags;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainConvertPoliciesToUsage
//
//  Synopsis:   extract the usage OIDs from the cert policies
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainConvertPoliciesToUsage (
    IN PCERT_POLICIES_INFO pPolicy,
    IN OUT DWORD *pdwFlags,
    OUT PCERT_ENHKEY_USAGE *ppUsage
    )
{
    PCERT_ENHKEY_USAGE pUsage;
    LPSTR *ppszOID;
    DWORD cOID;
    DWORD i;

    cOID = pPolicy->cPolicyInfo;

    pUsage = (PCERT_ENHKEY_USAGE) PkiNonzeroAlloc(
        sizeof(CERT_ENHKEY_USAGE) + sizeof(LPSTR) * cOID);

    if (NULL == pUsage) {
        *pdwFlags |= CHAIN_INVALID_POLICY_FLAG;
        *ppUsage = NULL;
        return;
    }

    ppszOID = (LPSTR *) &pUsage[1];

    pUsage->cUsageIdentifier = cOID;
    pUsage->rgpszUsageIdentifier = ppszOID;

    for (i = 0; i < cOID; i++)
        ppszOID[i] = pPolicy->rgPolicyInfo[i].pszPolicyIdentifier;

    *ppUsage = pUsage;

    ChainProcessSpecialOrDuplicateOIDsInUsage(ppUsage, pdwFlags);
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainRemoveDuplicatePolicyMappings
//
//  Synopsis:   remove any duplicate mappings
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainRemoveDuplicatePolicyMappings (
    IN OUT PCERT_POLICY_MAPPINGS_INFO pInfo
    )
{
    DWORD cMap = pInfo->cPolicyMapping;
    PCERT_POLICY_MAPPING pMap = pInfo->rgPolicyMapping;
    DWORD i;

    i = 0;
    while (i < cMap) {
        DWORD j;

        for (j = 0; j < i; j++) {
            if (0 == strcmp(pMap[i].pszSubjectDomainPolicy,
                    pMap[j].pszSubjectDomainPolicy))
                break;
        }

        if (j < i) {
            // Duplicate
            //
            // Remove the duplicate mapping and move the remaining
            // mappings up one.
            for (j = i; j + 1 < cMap; j++)
                pMap[j] = pMap[j + 1];

            cMap--;
            pInfo->cPolicyMapping = cMap;
        } else
            i++;
    }

}


//+---------------------------------------------------------------------------
//
//  Function:   ChainGetPoliciesInfo
//
//  Synopsis:   allocate and return the policies and usage info
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainGetPoliciesInfo (
    IN PCCERT_CONTEXT pCertContext,
    IN OUT PCHAIN_POLICIES_INFO pPoliciesInfo
    )
{
    DWORD cExt = pCertContext->pCertInfo->cExtension;
    PCERT_EXTENSION rgExt = pCertContext->pCertInfo->rgExtension;
    DWORD i;
    DWORD cbData;

    for (i = 0; i < CHAIN_ISS_OR_APP_COUNT; i++ ) {
        PCHAIN_ISS_OR_APP_INFO pInfo = &pPoliciesInfo->rgIssOrAppInfo[i];
        PCERT_EXTENSION pExt;

        pExt = CertFindExtension(
            CHAIN_ISS_INDEX == i ?
                szOID_CERT_POLICIES : szOID_APPLICATION_CERT_POLICIES,
            cExt, rgExt);
        if (pExt) {
            pInfo->pPolicy =
                (PCERT_POLICIES_INFO) ChainAllocAndDecodeObject(
                    X509_CERT_POLICIES,
                    pExt->Value.pbData,
                    pExt->Value.cbData
                    );

            if (NULL == pInfo->pPolicy)
                pInfo->dwFlags |= CHAIN_INVALID_POLICY_FLAG;
            else
                ChainConvertPoliciesToUsage(pInfo->pPolicy,
                    &pInfo->dwFlags, &pInfo->pUsage);
        } else if (CHAIN_APP_INDEX == i) {
            pExt = CertFindExtension(szOID_ENHANCED_KEY_USAGE,
                cExt, rgExt);
            if (pExt) {
                pInfo->pUsage =
                    (PCERT_ENHKEY_USAGE) ChainAllocAndDecodeObject(
                        X509_ENHANCED_KEY_USAGE,
                        pExt->Value.pbData,
                        pExt->Value.cbData
                        );

                if (NULL == pInfo->pUsage)
                    pInfo->dwFlags |= CHAIN_INVALID_POLICY_FLAG;
                else
                    ChainProcessSpecialOrDuplicateOIDsInUsage(
                        &pInfo->pUsage, &pInfo->dwFlags);
            }
        }

        pExt = CertFindExtension(
            CHAIN_ISS_INDEX == i ?
                szOID_POLICY_MAPPINGS : szOID_APPLICATION_POLICY_MAPPINGS,
            cExt, rgExt);
        if (pExt) {
            pInfo->pMappings =
                (PCERT_POLICY_MAPPINGS_INFO) ChainAllocAndDecodeObject(
                    X509_POLICY_MAPPINGS,
                    pExt->Value.pbData,
                    pExt->Value.cbData
                    );

            if (NULL == pInfo->pMappings)
                pInfo->dwFlags |= CHAIN_INVALID_POLICY_FLAG;
            else
                ChainRemoveDuplicatePolicyMappings(pInfo->pMappings);
        }

        pExt = CertFindExtension(
            CHAIN_ISS_INDEX == i ?
                szOID_POLICY_CONSTRAINTS : szOID_APPLICATION_POLICY_CONSTRAINTS,
            cExt, rgExt);
        if (pExt) {
            pInfo->pConstraints =
                (PCERT_POLICY_CONSTRAINTS_INFO) ChainAllocAndDecodeObject(
                    X509_POLICY_CONSTRAINTS,
                    pExt->Value.pbData,
                    pExt->Value.cbData
                    );

            if (NULL == pInfo->pConstraints)
                pInfo->dwFlags |= CHAIN_INVALID_POLICY_FLAG;
        }
    }

    cbData = 0;
    if (CertGetCertificateContextProperty(
            pCertContext,
            CERT_ENHKEY_USAGE_PROP_ID,
            NULL,   // pbData
            &cbData
            ) && 0 != cbData) {
        BYTE *pbData;

        pbData = (BYTE *) PkiNonzeroAlloc(cbData);
        if (pbData) {
            if (CertGetCertificateContextProperty(
                    pCertContext,
                    CERT_ENHKEY_USAGE_PROP_ID,
                    pbData,
                    &cbData
                    ))
                pPoliciesInfo->pPropertyUsage =
                    (PCERT_ENHKEY_USAGE) ChainAllocAndDecodeObject(
                        X509_ENHANCED_KEY_USAGE,
                        pbData,
                        cbData
                        );

            PkiFree(pbData);
        }

        if (NULL == pPoliciesInfo->pPropertyUsage)
            pPoliciesInfo->rgIssOrAppInfo[CHAIN_APP_INDEX].dwFlags |=
                CHAIN_INVALID_POLICY_FLAG;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreePoliciesInfo
//
//  Synopsis:   free the policies and usage info
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreePoliciesInfo (
    IN OUT PCHAIN_POLICIES_INFO pPoliciesInfo
    )
{
    DWORD i;

    for (i = 0; i < CHAIN_ISS_OR_APP_COUNT; i++ ) {
        PCHAIN_ISS_OR_APP_INFO pInfo = &pPoliciesInfo->rgIssOrAppInfo[i];

        PkiFree(pInfo->pPolicy);
        PkiFree(pInfo->pUsage);
        PkiFree(pInfo->pMappings);
        PkiFree(pInfo->pConstraints);
    }

    PkiFree(pPoliciesInfo->pPropertyUsage);
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetBasicConstraintsInfo
//
//  Synopsis:   alloc and return the basic constraints info.
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainGetBasicConstraintsInfo (
    IN PCCERT_CONTEXT pCertContext,
    IN OUT PCERT_BASIC_CONSTRAINTS2_INFO *ppInfo
    )
{
    BOOL fResult;
    PCERT_EXTENSION pExt;
    PCERT_BASIC_CONSTRAINTS2_INFO pInfo = NULL;
    PCERT_BASIC_CONSTRAINTS_INFO pLegacyInfo = NULL;

    pExt = CertFindExtension(
        szOID_BASIC_CONSTRAINTS2,
        pCertContext->pCertInfo->cExtension,
        pCertContext->pCertInfo->rgExtension
        );

    if (pExt) {
        pInfo = (PCERT_BASIC_CONSTRAINTS2_INFO) ChainAllocAndDecodeObject(
            X509_BASIC_CONSTRAINTS2, 
            pExt->Value.pbData,
            pExt->Value.cbData
            );
        if (NULL == pInfo)
            goto DecodeError;
    } else {
        // Try to find the legacy extension

        pExt = CertFindExtension(
            szOID_BASIC_CONSTRAINTS,
            pCertContext->pCertInfo->cExtension,
            pCertContext->pCertInfo->rgExtension
            );

        if (pExt) {
            pLegacyInfo =
                (PCERT_BASIC_CONSTRAINTS_INFO) ChainAllocAndDecodeObject(
                    X509_BASIC_CONSTRAINTS, 
                    pExt->Value.pbData,
                    pExt->Value.cbData
                    );
            if (NULL == pLegacyInfo)
                goto DecodeError;

            // Convert to new format
            pInfo = (PCERT_BASIC_CONSTRAINTS2_INFO) PkiZeroAlloc(
                sizeof(CERT_BASIC_CONSTRAINTS2_INFO));
            if (NULL == pInfo)
                goto OutOfMemory;

            if (pLegacyInfo->SubjectType.cbData > 0 &&
                    (pLegacyInfo->SubjectType.pbData[0] &
                        CERT_CA_SUBJECT_FLAG)) {
                pInfo->fCA = TRUE;
                pInfo->fPathLenConstraint = pLegacyInfo->fPathLenConstraint;
                pInfo->dwPathLenConstraint = pLegacyInfo->dwPathLenConstraint;
            }
        }
    }

    fResult = TRUE;
CommonReturn:
    if (pLegacyInfo)
        PkiFree(pLegacyInfo);
    *ppInfo = pInfo;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(DecodeError)
TRACE_ERROR(OutOfMemory)
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeBasicConstraintsInfo
//
//  Synopsis:   free the basic constraints info
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeBasicConstraintsInfo (
    IN OUT PCERT_BASIC_CONSTRAINTS2_INFO pInfo
    )
{
    PkiFree(pInfo);
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetKeyUsage
//
//  Synopsis:   alloc and return the key usage.
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainGetKeyUsage (
    IN PCCERT_CONTEXT pCertContext,
    IN OUT PCRYPT_BIT_BLOB *ppKeyUsage
    )
{
    BOOL fResult;
    PCERT_EXTENSION pExt;
    PCRYPT_BIT_BLOB pKeyUsage = NULL;

    pExt = CertFindExtension(
        szOID_KEY_USAGE,
        pCertContext->pCertInfo->cExtension,
        pCertContext->pCertInfo->rgExtension
        );

    if (pExt) {
        pKeyUsage = (PCRYPT_BIT_BLOB) ChainAllocAndDecodeObject(
            X509_KEY_USAGE, 
            pExt->Value.pbData,
            pExt->Value.cbData
            );
        if (NULL == pKeyUsage)
            goto DecodeError;
    }

    fResult = TRUE;
CommonReturn:
    *ppKeyUsage = pKeyUsage;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(DecodeError)
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeKeyUsage
//
//  Synopsis:   free the key usage
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeKeyUsage (
    IN OUT PCRYPT_BIT_BLOB pKeyUsage
    )
{
    PkiFree(pKeyUsage);
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetSelfSignedStatus
//
//  Synopsis:   return status bits specifying if the certificate is self signed
//              and if so, if it is signature valid
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainGetSelfSignedStatus (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN PCCERTOBJECT pCertObject,
    IN OUT DWORD *pdwIssuerStatusFlags
    )
{
    DWORD dwInfoStatus = 0;

    // If the certificate has an AKI, then, ignore name matching

       if (ChainGetMatchInfoStatus(pCertObject, pCertObject, &dwInfoStatus) &&
        (CERT_TRUST_HAS_NAME_MATCH_ISSUER != dwInfoStatus)) {
        *pdwIssuerStatusFlags |= CERT_ISSUER_SELF_SIGNED_FLAG;

        if (CryptVerifyCertificateSignatureEx(
                NULL,                   // hCryptProv
                X509_ASN_ENCODING,
                CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT,
                (void *) pCertObject->CertContext(),
                CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT,
                (void *) pCertObject->CertContext(),
                0,                      // dwFlags
                NULL                    // pvReserved
                ))
            *pdwIssuerStatusFlags |= CERT_ISSUER_VALID_SIGNATURE_FLAG;

        CertPerfIncrementChainVerifyCertSignatureCount();
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetRootStoreStatus
//
//  Synopsis:   determine if the certificate with the given hash is in the
//              root store
//
//  Assumption: Chain engine is locked once in the calling thread.
//----------------------------------------------------------------------------
VOID WINAPI
ChainGetRootStoreStatus (
    IN HCERTSTORE hRoot,
    IN HCERTSTORE hRealRoot,
    IN BYTE rgbCertHash[ CHAINHASHLEN ],
    IN OUT DWORD *pdwIssuerStatusFlags
    )
{
    CRYPT_HASH_BLOB HashBlob;
    PCCERT_CONTEXT pCertContext;

    HashBlob.cbData = CHAINHASHLEN;
    HashBlob.pbData = rgbCertHash;
    pCertContext = CertFindCertificateInStore(
                       hRoot,
                       X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                       0,
                       CERT_FIND_MD5_HASH,
                       (LPVOID) &HashBlob,
                       NULL
                       );

    if ( pCertContext )
    {
        CertFreeCertificateContext( pCertContext );

        if ( hRoot == hRealRoot )
        {
            *pdwIssuerStatusFlags |= CERT_ISSUER_TRUSTED_ROOT_FLAG;
            return;
        }

        pCertContext = CertFindCertificateInStore(
                           hRealRoot,
                           X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                           0,
                           CERT_FIND_MD5_HASH,
                           (LPVOID) &HashBlob,
                           NULL
                           );

        if ( pCertContext )
        {
            CertFreeCertificateContext( pCertContext );
            *pdwIssuerStatusFlags |= CERT_ISSUER_TRUSTED_ROOT_FLAG;
        }
    }
}


//+===========================================================================
//  CCertObjectCache helper functions
//============================================================================


//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateCertificateObjectCache
//
//  Synopsis:   create certificate object cache object
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCreateCertificateObjectCache (
     IN DWORD MaxIndexEntries,
     OUT PCCERTOBJECTCACHE* ppCertObjectCache
     )
{
    BOOL              fResult = FALSE;
    PCCERTOBJECTCACHE pCertObjectCache = NULL;

    pCertObjectCache = new CCertObjectCache( MaxIndexEntries, fResult );
    if ( pCertObjectCache != NULL )
    {
        if ( fResult == TRUE )
        {
            *ppCertObjectCache = pCertObjectCache;
        }
        else
        {
            delete pCertObjectCache;
        }
    }
    else
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeCertificateObjectCache
//
//  Synopsis:   free the certificate object cache object
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeCertificateObjectCache (
     IN PCCERTOBJECTCACHE pCertObjectCache
     )
{
    delete pCertObjectCache;
}

//+---------------------------------------------------------------------------
//
//  Function:   CertObjectCacheOnRemovalFromPrimaryIndex
//
//  Synopsis:   removes the cert object from all other indexes and also
//              removes the reference on the cert object.
//
//----------------------------------------------------------------------------
VOID WINAPI
CertObjectCacheOnRemovalFromPrimaryIndex (
    IN LPVOID pv,
    IN OPTIONAL LPVOID pvRemovalContext
    )
{
    PCCERTOBJECT pCertObject = (PCCERTOBJECT) pv;

    I_CryptRemoveLruEntry(
           pCertObject->IdentifierIndexEntry(),
           LRU_SUPPRESS_REMOVAL_NOTIFICATION,
           NULL
           );

    I_CryptRemoveLruEntry(
           pCertObject->SubjectNameIndexEntry(),
           LRU_SUPPRESS_REMOVAL_NOTIFICATION,
           NULL
           );

    I_CryptRemoveLruEntry(
           pCertObject->KeyIdIndexEntry(),
           LRU_SUPPRESS_REMOVAL_NOTIFICATION,
           NULL
           );

    I_CryptRemoveLruEntry(
           pCertObject->PublicKeyHashIndexEntry(),
           LRU_SUPPRESS_REMOVAL_NOTIFICATION,
           NULL
           );

    pCertObject->Release();

    CertPerfDecrementChainCertCacheCount();
}


//+---------------------------------------------------------------------------
//
//  Function:   CertObjectCacheOnRemovalFromEndHashIndex
//
//  Synopsis:   removes the reference on the end cert object.
//
//----------------------------------------------------------------------------
VOID WINAPI
CertObjectCacheOnRemovalFromEndHashIndex (
    IN LPVOID pv,
    IN LPVOID pvRemovalContext
    )
{
    PCCERTOBJECT pCertObject = (PCCERTOBJECT) pv;

    pCertObject->Release();

    CertPerfDecrementChainCertCacheCount();
}


//+---------------------------------------------------------------------------
//
//  Function:   CertObjectCacheHashMd5Identifier
//
//  Synopsis:   DWORD hash an MD5 identifier.  This is done by taking the
//              first four bytes of the MD5 hash since there is enough
//              randomness already
//
//----------------------------------------------------------------------------
DWORD WINAPI
CertObjectCacheHashMd5Identifier (
    IN PCRYPT_DATA_BLOB pIdentifier
    )
{
    if ( sizeof(DWORD) > pIdentifier->cbData )
    {
        return 0;
    }
    else
    {
        return( *( (DWORD UNALIGNED *)pIdentifier->pbData ) );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CertObjectCacheHashNameIdentifier
//
//  Synopsis:   DWORD hash a subject or issuer name.
//
//----------------------------------------------------------------------------
DWORD WINAPI
CertObjectCacheHashNameIdentifier (
    IN PCRYPT_DATA_BLOB pIdentifier
    )
{
    DWORD  dwHash = 0;
    DWORD  cb = pIdentifier->cbData;
    LPBYTE pb = pIdentifier->pbData;

    while ( cb-- )
    {
        if ( dwHash & 0x80000000 )
        {
            dwHash = ( dwHash << 1 ) | 1;
        }
        else
        {
            dwHash = dwHash << 1;
        }

        dwHash += *pb++;
    }

    return( dwHash );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateCertificateObjectIdentifier
//
//  Synopsis:   create an object identifier given the issuer name and serial
//              number.  This is done using an MD5 hash over the content
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainCreateCertificateObjectIdentifier (
     IN PCERT_NAME_BLOB pIssuer,
     IN PCRYPT_INTEGER_BLOB pSerialNumber,
     OUT CERT_OBJECT_IDENTIFIER ObjectIdentifier
     )
{
    MD5_CTX md5ctx;

    MD5Init( &md5ctx );

    MD5Update( &md5ctx, pIssuer->pbData, pIssuer->cbData );
    MD5Update( &md5ctx, pSerialNumber->pbData, pSerialNumber->cbData );

    MD5Final( &md5ctx );

    assert(CHAINHASHLEN == MD5DIGESTLEN);

    memcpy( ObjectIdentifier, md5ctx.digest, CHAINHASHLEN );
}


//+===========================================================================
//  CChainPathObject helper functions
//============================================================================

//+---------------------------------------------------------------------------
//
//  Function:   ChainCreatePathObject
//
//  Synopsis:   create a path object, note since it is a ref-counted
//              object, freeing occurs by doing a pCertObject->Release
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCreatePathObject (
     IN PCCHAINCALLCONTEXT pCallContext,
     IN PCCERTOBJECT pCertObject,
     IN OPTIONAL HCERTSTORE hAdditionalStore,
     OUT PCCHAINPATHOBJECT *ppPathObject
     )
{
    BOOL fResult = TRUE;
    BOOL fAddedToCreationCache = TRUE;
    PCCHAINPATHOBJECT pPathObject = NULL;

    pPathObject = pCallContext->FindPathObjectInCreationCache(
        pCertObject->CertHash() );
    if ( pPathObject != NULL )
    {
        *ppPathObject = pPathObject;
        return( TRUE );
    }

    pPathObject = new CChainPathObject(
                           pCallContext,
                           FALSE,                   // fCyclic
                           (LPVOID) pCertObject,
                           hAdditionalStore,
                           fResult,
                           fAddedToCreationCache
                           );

    if ( pPathObject != NULL )
    {
        if (!fResult) {
            if (!fAddedToCreationCache)
            {
                delete pPathObject;
            }
            pPathObject = NULL;
        }
    }
    else
    {
        fResult = FALSE;
    }

    *ppPathObject = pPathObject;
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateCyclicPathObject
//
//  Synopsis:   create a path object, note since it is a ref-counted
//              object, freeing occurs by doing a pCertObject->Release
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCreateCyclicPathObject (
     IN PCCHAINCALLCONTEXT pCallContext,
     IN PCCHAINPATHOBJECT pPathObject,
     OUT PCCHAINPATHOBJECT *ppCyclicPathObject
     )
{
    BOOL fResult = TRUE;
    BOOL fAddedToCreationCache = TRUE;
    PCCHAINPATHOBJECT pCyclicPathObject = NULL;

    pCyclicPathObject = new CChainPathObject(
                           pCallContext,
                           TRUE,                    // fCyclic
                           (LPVOID) pPathObject,
                           NULL,                    // hAdditionalStore
                           fResult,
                           fAddedToCreationCache
                           );

    if ( pCyclicPathObject != NULL )
    {
        if (!fResult) {
            if (!fAddedToCreationCache) {
                delete pCyclicPathObject;
            }
            pCyclicPathObject = NULL;
        }
    }
    else
    {
        fResult = FALSE;
    }

    *ppCyclicPathObject = pCyclicPathObject;
    return( fResult );
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainAllocAndCopyOID
//
//  Synopsis:   allocate and copy OID
//
//----------------------------------------------------------------------------
LPSTR WINAPI
ChainAllocAndCopyOID (
     IN LPSTR pszSrcOID
     )
{
    DWORD cchOID;
    LPSTR pszDstOID;

    cchOID = strlen(pszSrcOID) + 1;
    pszDstOID = (LPSTR) PkiNonzeroAlloc(cchOID);
    if (NULL == pszDstOID)
        return NULL;

    memcpy(pszDstOID, pszSrcOID, cchOID);
    return pszDstOID;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeOID
//
//  Synopsis:   free allocated OID
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeOID (
     IN OUT LPSTR pszOID
     )
{
    PkiFree(pszOID);
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainAllocAndCopyUsage
//
//  Synopsis:   allocates and copies usage OIDs.
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainAllocAndCopyUsage (
     IN PCERT_ENHKEY_USAGE pSrcUsage,
     OUT PCERT_ENHKEY_USAGE *ppDstUsage
     )
{
    BOOL fResult;
    PCERT_ENHKEY_USAGE pDstUsage = NULL;
    DWORD cOID;
    LPSTR *ppszDstOID;
    DWORD i;

    if (NULL == pSrcUsage)
        goto SuccessReturn;

    cOID = pSrcUsage->cUsageIdentifier;

    pDstUsage = (PCERT_ENHKEY_USAGE) PkiZeroAlloc(
        sizeof(CERT_ENHKEY_USAGE) + sizeof(LPSTR) * cOID);
    if (NULL == pDstUsage)
        goto OutOfMemory;

    ppszDstOID = (LPSTR *) &pDstUsage[1];

    pDstUsage->cUsageIdentifier = cOID;
    pDstUsage->rgpszUsageIdentifier = ppszDstOID;

    for (i = 0; i < cOID; i++) {
        ppszDstOID[i] =
            ChainAllocAndCopyOID(pSrcUsage->rgpszUsageIdentifier[i]);
        if (NULL == ppszDstOID[i])
            goto OutOfMemory;
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    *ppDstUsage = pDstUsage;
    return fResult;

ErrorReturn:
    if (pDstUsage) {
        ChainFreeUsage(pDstUsage);
        pDstUsage = NULL;
    }
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeUsage
//
//  Synopsis:   frees usage OIDs allocated by ChainAllocAndCopyUsage
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeUsage (
     IN OUT PCERT_ENHKEY_USAGE pUsage
     )
{
    if (pUsage) {
        DWORD cOID = pUsage->cUsageIdentifier;
        LPSTR *ppszOID = pUsage->rgpszUsageIdentifier;
        DWORD i;

        for (i = 0; i < cOID; i++)
            ChainFreeOID(ppszOID[i]);

        PkiFree(pUsage);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainIsOIDInUsage
//
//  Synopsis:   returns TRUE if the OID is in the usage
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainIsOIDInUsage (
    IN LPSTR pszOID,
    IN PCERT_ENHKEY_USAGE pUsage
    )
{
    DWORD cOID;
    DWORD i;

    assert(pUsage);

    cOID = pUsage->cUsageIdentifier;
    for (i = 0; i < cOID; i++){
        if (0 == strcmp(pszOID, pUsage->rgpszUsageIdentifier[i]))
            return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainIntersectUsages
//
//  Synopsis:   returns the intersection of the two usages
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainIntersectUsages (
    IN PCERT_ENHKEY_USAGE pCertUsage,
    IN OUT PCERT_ENHKEY_USAGE pRestrictedUsage
    )
{
    LPSTR *ppszOID;
    DWORD cOID;
    DWORD i;
    
    cOID = pRestrictedUsage->cUsageIdentifier;
    ppszOID = pRestrictedUsage->rgpszUsageIdentifier;
    i = 0;
    while (i < cOID) {
        if (ChainIsOIDInUsage(ppszOID[i], pCertUsage))
            i++;
        else {
            // Remove the OID string and move the remaining
            // strings up one.
            DWORD j;

            ChainFreeOID(ppszOID[i]);

            for (j = i; j + 1 < cOID; j++)
                ppszOID[j] = ppszOID[j + 1];

            cOID--;
            pRestrictedUsage->cUsageIdentifier = cOID;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeAndClearRestrictedUsageInfo
//
//  Synopsis:   frees allocated restricted usage info
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeAndClearRestrictedUsageInfo(
    IN OUT PCHAIN_RESTRICTED_USAGE_INFO pInfo
    )
{
    ChainFreeUsage(pInfo->pIssuanceRestrictedUsage);
    ChainFreeUsage(pInfo->pIssuanceMappedUsage);
    PkiFree(pInfo->rgdwIssuanceMappedIndex);
    // fRequireIssuancePolicy

    ChainFreeUsage(pInfo->pApplicationRestrictedUsage);
    ChainFreeUsage(pInfo->pApplicationMappedUsage);
    PkiFree(pInfo->rgdwApplicationMappedIndex);

    ChainFreeUsage(pInfo->pPropertyRestrictedUsage);

    memset(pInfo, 0, sizeof(*pInfo));
}
    
//+---------------------------------------------------------------------------
//
//  Function:   ChainCalculateRestrictedUsage
//
//  Synopsis:   update the restricted and mapped usage using the cert's
//              usage and optional policy mappings
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCalculateRestrictedUsage (
    IN PCERT_ENHKEY_USAGE pCertUsage,
    IN OPTIONAL PCERT_POLICY_MAPPINGS_INFO pMappings,
    IN OUT PCERT_ENHKEY_USAGE *ppRestrictedUsage,
    IN OUT PCERT_ENHKEY_USAGE *ppMappedUsage,
    IN OUT LPDWORD *ppdwMappedIndex
    )
{
    BOOL fResult;
    PCERT_ENHKEY_USAGE pNewMappedUsage = NULL;
    LPDWORD pdwNewMappedIndex = NULL;

    if (pCertUsage) {
        if (NULL == *ppRestrictedUsage) {
            // Top most, first certificate with a usage restriction

            assert(NULL == *ppMappedUsage);
            assert(NULL == *ppdwMappedIndex);

            if (!ChainAllocAndCopyUsage(pCertUsage, ppRestrictedUsage))
                goto AllocAndCopyUsageError;
        } else {
            PCERT_ENHKEY_USAGE pRestrictedUsage = *ppRestrictedUsage;
            PCERT_ENHKEY_USAGE pMappedUsage = *ppMappedUsage;
            
            if (NULL == pMappedUsage) {
                // Take the intersection of the restricted and cert's
                // usage

                ChainIntersectUsages(pCertUsage, pRestrictedUsage);

            } else {
                // Take the intersection of the mapped and cert's
                // usage. If removed from the mapped usage,
                // we might also need to remove from the restricted usage.

                LPDWORD pdwMappedIndex = *ppdwMappedIndex;
                LPSTR *ppszOID;
                DWORD cOID;
                DWORD i;

                assert(pdwMappedIndex);

                cOID = pMappedUsage->cUsageIdentifier;
                ppszOID = pMappedUsage->rgpszUsageIdentifier;
                i = 0;
                while (i < cOID) {
                    if (ChainIsOIDInUsage(ppszOID[i], pCertUsage))
                        i++;
                    else {
                        // If no other mappings to the restricted OID, then,
                        // remove the restricted OID.

                        DWORD j;
                        BOOL fRemoveRestricted;

                        if ((0 == i ||
                                pdwMappedIndex[i - 1] != pdwMappedIndex[i])
                                            &&
                            (i + 1 == cOID ||
                                pdwMappedIndex[i] != pdwMappedIndex[i + 1])) {
                            // Remove the restricted OID we are mapped to.

                            LPSTR *ppszRestrictedOID =
                                pRestrictedUsage->rgpszUsageIdentifier;
                            DWORD cRestrictedOID = 
                                pRestrictedUsage->cUsageIdentifier;

                            fRemoveRestricted = TRUE;

                            j = pdwMappedIndex[i];
                            assert(j < cRestrictedOID);

                            if (j < cRestrictedOID)
                                ChainFreeOID(ppszRestrictedOID[j]);

                            for ( ; j + 1 < cRestrictedOID; j++)
                                ppszRestrictedOID[j] = ppszRestrictedOID[j + 1];

                            cRestrictedOID--;
                            pRestrictedUsage->cUsageIdentifier =
                                cRestrictedOID;
                        } else
                            fRemoveRestricted = FALSE;

                        // Remove the OID string and mapped index. Move the
                        // remaining strings and indices up one.
                        ChainFreeOID(ppszOID[i]);

                        for (j = i; j + 1 < cOID; j++) {
                            ppszOID[j] = ppszOID[j + 1];
                            pdwMappedIndex[j] = pdwMappedIndex[j + 1];
                            if (fRemoveRestricted) {
                                assert(0 < pdwMappedIndex[j]);
                                pdwMappedIndex[j] -= 1;
                                
                            }
                        }

                        cOID--;
                        pMappedUsage->cUsageIdentifier = cOID;
                    }
                }
            }
        }
    }
    // else
    //  No restrictions added by certificate


    if (pMappings) {
        PCERT_ENHKEY_USAGE pRestrictedUsage = *ppRestrictedUsage;
        PCERT_ENHKEY_USAGE pMappedUsage = *ppMappedUsage;

        if (NULL == pRestrictedUsage ||
                0 == pRestrictedUsage->cUsageIdentifier) {
            // Nothing to be mapped.
            assert(NULL == pMappedUsage ||
                0 == pMappedUsage->cUsageIdentifier);
        } else {
            LPDWORD pdwMappedIndex;
            PCERT_ENHKEY_USAGE pSrcUsage;
            LPSTR *ppszSrcOID;
            DWORD cSrcOID;
            DWORD iSrc;

            DWORD cMap;
            PCERT_POLICY_MAPPING pMap;

            DWORD cNewOID;
            LPSTR *ppszNewOID;

            if (pMappedUsage) {
                // Subsequent mapping
                assert(0 < pMappedUsage->cUsageIdentifier);
                pSrcUsage = pMappedUsage;
                pdwMappedIndex = *ppdwMappedIndex;
                assert(pdwMappedIndex);
            } else {
                // First mapping
                pSrcUsage = pRestrictedUsage;
                pdwMappedIndex = NULL;
            }

            cSrcOID = pSrcUsage->cUsageIdentifier;
            ppszSrcOID = pSrcUsage->rgpszUsageIdentifier;

            cMap = pMappings->cPolicyMapping;
            pMap = pMappings->rgPolicyMapping;

            // Note, all duplicates have been remove from usage and
            // mappings
            cNewOID = cSrcOID + cMap;

            pNewMappedUsage = (PCERT_ENHKEY_USAGE) PkiZeroAlloc(
                sizeof(CERT_ENHKEY_USAGE) + sizeof(LPSTR) * cNewOID);
            if (NULL == pNewMappedUsage)
                goto OutOfMemory;

            ppszNewOID = (LPSTR *) &pNewMappedUsage[1];
            pNewMappedUsage->cUsageIdentifier = cNewOID;
            pNewMappedUsage->rgpszUsageIdentifier = ppszNewOID;

            pdwNewMappedIndex = (LPDWORD) PkiZeroAlloc(
                sizeof(DWORD) * cNewOID);
            if (NULL == pdwNewMappedIndex)
                goto OutOfMemory;

            cNewOID = 0;
            for (iSrc = 0; iSrc < cSrcOID; iSrc++) {
                DWORD iMap;
                BOOL fMapped = FALSE;

                for (iMap = 0; iMap < cMap; iMap++) {
                    if (0 == strcmp(ppszSrcOID[iSrc],
                            pMap[iMap].pszIssuerDomainPolicy)) {
                        assert(cNewOID < pNewMappedUsage->cUsageIdentifier);

                        ppszNewOID[cNewOID] = ChainAllocAndCopyOID(
                            pMap[iMap].pszSubjectDomainPolicy);
                        if (NULL == ppszNewOID[cNewOID])
                            goto OutOfMemory;

                        if (pdwMappedIndex)
                            pdwNewMappedIndex[cNewOID] = pdwMappedIndex[iSrc];
                        else
                            pdwNewMappedIndex[cNewOID] = iSrc;
                        cNewOID++;
                        fMapped = TRUE;
                    }
                }

                if (!fMapped) {
                    assert(cNewOID < pNewMappedUsage->cUsageIdentifier);

                    ppszNewOID[cNewOID] =
                        ChainAllocAndCopyOID(ppszSrcOID[iSrc]);
                    if (NULL == ppszNewOID[cNewOID])
                        goto OutOfMemory;
                    if (pdwMappedIndex)
                        pdwNewMappedIndex[cNewOID] = pdwMappedIndex[iSrc];
                    else
                        pdwNewMappedIndex[cNewOID] = iSrc;

                    cNewOID++;

                }
            }

            assert(cNewOID >= cSrcOID);
            pNewMappedUsage->cUsageIdentifier = cNewOID;

            if (pMappedUsage) {
                ChainFreeUsage(pMappedUsage);
                PkiFree(pdwMappedIndex);
            }

            *ppMappedUsage = pNewMappedUsage;
            *ppdwMappedIndex = pdwNewMappedIndex;

        }
    }

    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    ChainFreeUsage(pNewMappedUsage);
    PkiFree(pdwNewMappedIndex);
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(AllocAndCopyUsageError)
TRACE_ERROR(OutOfMemory)
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainGetUsageStatus
//
//  Synopsis:   get the usage status
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainGetUsageStatus (
     IN PCERT_ENHKEY_USAGE pRequestedUsage,
     IN PCERT_ENHKEY_USAGE pAvailableUsage,
     IN DWORD dwMatchType,
     IN OUT PCERT_TRUST_STATUS pStatus
     )
{
    DWORD cRequested;
    DWORD cAvailable;
    DWORD cFound;
    BOOL  fFound;

    if ( pAvailableUsage == NULL )
    {
        return;
    }

    if ( ( pRequestedUsage->cUsageIdentifier >
           pAvailableUsage->cUsageIdentifier ) &&
         ( dwMatchType == USAGE_MATCH_TYPE_AND ) )
    {
        pStatus->dwErrorStatus |= CERT_TRUST_IS_NOT_VALID_FOR_USAGE;
        return;
    }

    for ( cRequested = 0, cFound = 0;
          cRequested < pRequestedUsage->cUsageIdentifier;
          cRequested++ )
    {
        for ( cAvailable = 0, fFound = FALSE;
              ( cAvailable < pAvailableUsage->cUsageIdentifier ) &&
              ( fFound == FALSE );
              cAvailable++ )
        {
            // NOTE: Optimize compares of OIDs.  Perhaps with a different
            //       encoding
            if ( strcmp(
                    pRequestedUsage->rgpszUsageIdentifier[ cRequested ],
                    pAvailableUsage->rgpszUsageIdentifier[ cAvailable ]
                    ) == 0 )
            {
                fFound = TRUE;
            }
        }

        if ( fFound == TRUE )
        {
            cFound += 1;
        }
    }

    if ( ( dwMatchType == USAGE_MATCH_TYPE_AND ) &&
         ( cFound != pRequestedUsage->cUsageIdentifier ) )
    {
        pStatus->dwErrorStatus |= CERT_TRUST_IS_NOT_VALID_FOR_USAGE;
    }
    else if ( ( dwMatchType == USAGE_MATCH_TYPE_OR ) &&
              ( cFound == 0 ) )
    {
        pStatus->dwErrorStatus |= CERT_TRUST_IS_NOT_VALID_FOR_USAGE;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainOrInStatusBits
//
//  Synopsis:   bit or in the status bits from the source into the destination
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainOrInStatusBits (
     IN PCERT_TRUST_STATUS pDestStatus,
     IN PCERT_TRUST_STATUS pSourceStatus
     )
{
    pDestStatus->dwErrorStatus |= pSourceStatus->dwErrorStatus;
    pDestStatus->dwInfoStatus |= pSourceStatus->dwInfoStatus;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetMatchInfoStatus
//
//  Synopsis:   return the info status used to match the issuer
//
//              For a match returns TRUE, where dwInfoStatus can be
//              one of the following:
//               - CERT_TRUST_HAS_EXACT_MATCH_ISSUER |
//                      CERT_TRUST_HAS_PREFERRED_ISSUER
//               - CERT_TRUST_HAS_KEY_MATCH_ISSUER |
//                      CERT_TRUST_HAS_PREFERRED_ISSUER
//               - CERT_TRUST_HAS_KEY_MATCH_ISSUER (nonmatching AKI exact match)
//               - CERT_TRUST_HAS_NAME_MATCH_ISSUER |
//                      CERT_TRUST_HAS_PREFERRED_ISSUER
//               - CERT_TRUST_HAS_NAME_MATCH_ISSUER (nonmatching AKI)
//
//              For no match returns FALSE with dwInfoStatus set to the
//              following:
//               - CERT_TRUST_HAS_KEY_MATCH_ISSUER
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainGetMatchInfoStatus (
    IN PCCERTOBJECT pIssuerObject,
    IN PCCERTOBJECT pSubjectObject,
    IN OUT DWORD *pdwInfoStatus
    )
{
    BOOL fResult = FALSE;
    DWORD dwInfoStatus = 0;
    DWORD dwPreferredStatus = CERT_TRUST_HAS_PREFERRED_ISSUER;

    PCERT_INFO pSubjectInfo = pSubjectObject->CertContext()->pCertInfo;
    PCERT_AUTHORITY_KEY_ID_INFO pAKI = pSubjectObject->AuthorityKeyIdentifier();
    PCERT_INFO pIssuerInfo = pIssuerObject->CertContext()->pCertInfo;

    if (pAKI) {
        if ( ( pAKI->CertIssuer.cbData != 0 ) &&
             ( pAKI->CertSerialNumber.cbData != 0 ) )
        {
            DWORD cbAuthIssuerName;
            LPBYTE pbAuthIssuerName;
            DWORD cbAuthSerialNumber;
            LPBYTE pbAuthSerialNumber;

            cbAuthIssuerName = pAKI->CertIssuer.cbData;
            pbAuthIssuerName = pAKI->CertIssuer.pbData;
            cbAuthSerialNumber = pAKI->CertSerialNumber.cbData;
            pbAuthSerialNumber = pAKI->CertSerialNumber.pbData;

            if ( ( cbAuthIssuerName == pIssuerInfo->Issuer.cbData ) &&
                 ( memcmp(
                      pbAuthIssuerName,
                      pIssuerInfo->Issuer.pbData,
                      cbAuthIssuerName
                      ) == 0 ) &&
                 ( cbAuthSerialNumber == pIssuerInfo->SerialNumber.cbData ) &&
                 ( memcmp(
                      pbAuthSerialNumber,
                      pIssuerInfo->SerialNumber.pbData,
                      cbAuthSerialNumber
                      ) == 0 ) )
            {
                dwInfoStatus = CERT_TRUST_HAS_EXACT_MATCH_ISSUER |
                    CERT_TRUST_HAS_PREFERRED_ISSUER;
                goto SuccessReturn;
            } else {
                // Doesn't have preferred match
                dwPreferredStatus = 0;
            }
        }

        if ( pAKI->KeyId.cbData != 0 )
        {
            DWORD cbAuthKeyIdentifier;
            LPBYTE pbAuthKeyIdentifier;
            DWORD cbIssuerKeyIdentifier;
            LPBYTE pbIssuerKeyIdentifier;

            cbAuthKeyIdentifier = pAKI->KeyId.cbData;
            pbAuthKeyIdentifier = pAKI->KeyId.pbData;
            cbIssuerKeyIdentifier = pIssuerObject->KeyIdentifierSize();
            pbIssuerKeyIdentifier = pIssuerObject->KeyIdentifier();

            if ( ( cbAuthKeyIdentifier == cbIssuerKeyIdentifier ) &&
                 ( memcmp(
                      pbAuthKeyIdentifier,
                      pbIssuerKeyIdentifier,
                      cbAuthKeyIdentifier
                      ) == 0 ) )
            {
                dwInfoStatus = dwPreferredStatus |
                    CERT_TRUST_HAS_KEY_MATCH_ISSUER;
                goto SuccessReturn;
            } else {
                // Doesn't have preferred match
                dwPreferredStatus = 0;
            }
        }
    }

    if ( ( pSubjectInfo->Issuer.cbData == pIssuerInfo->Subject.cbData ) &&
         ( pSubjectInfo->Issuer.cbData != 0) &&
         ( memcmp(
              pSubjectInfo->Issuer.pbData,
              pIssuerInfo->Subject.pbData,
              pIssuerInfo->Subject.cbData
              ) == 0 ) )
    {
        dwInfoStatus = dwPreferredStatus | CERT_TRUST_HAS_NAME_MATCH_ISSUER;
        goto SuccessReturn;
    }


    // Default to nonPreferred public key match
    dwInfoStatus = CERT_TRUST_HAS_KEY_MATCH_ISSUER;
    goto ErrorReturn;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    *pdwInfoStatus |= dwInfoStatus;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetMatchInfoStatusForNoIssuer
//
//  Synopsis:   return the info status when unable to find our issuer
//
//----------------------------------------------------------------------------
DWORD WINAPI
ChainGetMatchInfoStatusForNoIssuer (
    IN DWORD dwIssuerMatchFlags
    )
{
    if (dwIssuerMatchFlags & CERT_EXACT_ISSUER_MATCH_FLAG)
        return CERT_TRUST_HAS_EXACT_MATCH_ISSUER;
    else if (dwIssuerMatchFlags & CERT_KEYID_ISSUER_MATCH_TYPE)
        return CERT_TRUST_HAS_KEY_MATCH_ISSUER;
    else
        return CERT_TRUST_HAS_NAME_MATCH_ISSUER;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainIsValidPubKeyMatchForIssuer
//
//  Synopsis:   returns TRUE if the issuer matches more than just the
//              public key match criteria
//
//              This logic is mainly here to handle tstore2.exe and regress.bat
//              which has end, CA and root certificates using the same
//              public key.
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainIsValidPubKeyMatchForIssuer (
    IN PCCERTOBJECT pIssuer,
    IN PCCERTOBJECT pSubject
    )
{
    BOOL fResult = TRUE;
    BOOL fCheckMatchInfo;
    PCERT_BASIC_CONSTRAINTS2_INFO pIssuerBasicConstraints;

    fCheckMatchInfo = FALSE;

    // Check if the issuer has a basic constraints extension. If it does
    // and it isn't a CA, then, we will need to do an additional issuer match.

    pIssuerBasicConstraints = pIssuer->BasicConstraintsInfo();
    if (pIssuerBasicConstraints && !pIssuerBasicConstraints->fCA)
        fCheckMatchInfo = TRUE;
    else {
        // Check if the issuer has the same public key as the subject. If it
        // does, then, will need to do an additional issuer match.

        BYTE *pbIssuerPublicKeyHash;
        BYTE *pbSubjectPublicKeyHash;

        pbIssuerPublicKeyHash = pIssuer->PublicKeyHash();
        pbSubjectPublicKeyHash = pSubject->PublicKeyHash();
        if (0 == memcmp(pbIssuerPublicKeyHash, pbSubjectPublicKeyHash,
                CHAINHASHLEN))
            fCheckMatchInfo = TRUE;
    }

    if (fCheckMatchInfo) {
        // Check that the issuer matches the subject's AKI or subject's
        // issuer name.

        DWORD dwInfoStatus = 0;

        // Following returns FALSE if only has the public key match
        fResult = ChainGetMatchInfoStatus(pIssuer, pSubject, &dwInfoStatus);
    }

    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetSubjectStatus
//
//  Synopsis:   get the subject status bits by checking the time nesting and
//              signature validity
//
//              For CERT_END_OBJECT_TYPE or CERT_EXTERNAL_ISSUER_OBJECT_TYPE
//              CCertObject types, leaves the engine's critical section to
//              verify the signature. If the engine was touched by another
//              thread, it fails with LastError set to ERROR_CAN_NOT_COMPLETE.
//
//  Assumption: Chain engine is locked once in the calling thread.
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainGetSubjectStatus (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN PCCHAINPATHOBJECT pIssuerPathObject,
    IN PCCHAINPATHOBJECT pSubjectPathObject,
    IN OUT PCERT_TRUST_STATUS pStatus
    )
{
    BOOL fResult;

    PCCERTOBJECT pIssuerObject = pIssuerPathObject->CertObject();
    PCCERTOBJECT pSubjectObject = pSubjectPathObject->CertObject();
    PCCERT_CONTEXT pIssuerContext = pIssuerObject->CertContext();
    PCCERT_CONTEXT pSubjectContext = pSubjectObject->CertContext();

    DWORD dwIssuerStatusFlags;

    ChainGetMatchInfoStatus(
        pIssuerObject,
        pSubjectObject,
        &pStatus->dwInfoStatus
        );

    dwIssuerStatusFlags = pSubjectObject->IssuerStatusFlags();
    if (!(dwIssuerStatusFlags & CERT_ISSUER_VALID_SIGNATURE_FLAG)) {
        DWORD dwObjectType;

        dwObjectType = pSubjectObject->ObjectType();
        if (CERT_END_OBJECT_TYPE == dwObjectType ||
                CERT_EXTERNAL_ISSUER_OBJECT_TYPE == dwObjectType)
            pCallContext->ChainEngine()->UnlockEngine();

        fResult = CryptVerifyCertificateSignatureEx(
                NULL,                   // hCryptProv
                X509_ASN_ENCODING,
                CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT,
                (void *) pSubjectContext,
                CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT,
                (void *) pIssuerContext,
                0,                      // dwFlags
                NULL                    // pvReserved
                );

        if (CERT_END_OBJECT_TYPE == dwObjectType ||
                CERT_EXTERNAL_ISSUER_OBJECT_TYPE == dwObjectType) {
            pCallContext->ChainEngine()->LockEngine();
            if (pCallContext->IsTouchedEngine())
                goto TouchedDuringSignatureVerification;
        }

        if (!fResult) {
            pStatus->dwErrorStatus |= CERT_TRUST_IS_NOT_SIGNATURE_VALID;
            pStatus->dwInfoStatus &= ~CERT_TRUST_HAS_PREFERRED_ISSUER;
        } else {
            if (dwIssuerStatusFlags & CERT_ISSUER_PUBKEY_FLAG) {
                // Verify the issuer's public key hash
                if (0 != memcmp(pSubjectObject->IssuerPublicKeyHash(),
                        pIssuerObject->PublicKeyHash(), CHAINHASHLEN))
                    dwIssuerStatusFlags &= ~CERT_ISSUER_PUBKEY_FLAG;
            }

            if (!(dwIssuerStatusFlags & CERT_ISSUER_PUBKEY_FLAG)) {
                CRYPT_DATA_BLOB DataBlob;

                memcpy(pSubjectObject->IssuerPublicKeyHash(),
                    pIssuerObject->PublicKeyHash(), CHAINHASHLEN);
                DataBlob.pbData = pSubjectObject->IssuerPublicKeyHash(),
                DataBlob.cbData = CHAINHASHLEN;
                CertSetCertificateContextProperty(
                    pSubjectContext,
                    CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID,
                    CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG,
                    &DataBlob
                    );
            }

            pSubjectObject->OrIssuerStatusFlags(
                CERT_ISSUER_PUBKEY_FLAG |
                    CERT_ISSUER_VALID_SIGNATURE_FLAG
                );
        }

        CertPerfIncrementChainVerifyCertSignatureCount();
    } else {

        // also need to check public key parameters

        assert(dwIssuerStatusFlags & CERT_ISSUER_PUBKEY_FLAG);
        if (0 != memcmp(pSubjectObject->IssuerPublicKeyHash(),
                    pIssuerObject->PublicKeyHash(), CHAINHASHLEN)) {
            pStatus->dwErrorStatus |= CERT_TRUST_IS_NOT_SIGNATURE_VALID;
            pStatus->dwInfoStatus &= ~CERT_TRUST_HAS_PREFERRED_ISSUER;
        }

        CertPerfIncrementChainCompareIssuerPublicKeyCount();
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(TouchedDuringSignatureVerification, ERROR_CAN_NOT_COMPLETE)
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainUpdateSummaryStatusByTrustStatus
//
//  Synopsis:   update the summary status bits given new trust status bits
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainUpdateSummaryStatusByTrustStatus(
     IN OUT PCERT_TRUST_STATUS pSummaryStatus,
     IN PCERT_TRUST_STATUS pTrustStatus
     )
{
    pSummaryStatus->dwErrorStatus |= pTrustStatus->dwErrorStatus;
    pSummaryStatus->dwInfoStatus |=
        pTrustStatus->dwInfoStatus &
            ~(CERT_TRUST_CERTIFICATE_ONLY_INFO_STATUS |
                CERT_TRUST_HAS_PREFERRED_ISSUER);
    if (!(pTrustStatus->dwInfoStatus & CERT_TRUST_HAS_PREFERRED_ISSUER))
        pSummaryStatus->dwInfoStatus &= ~CERT_TRUST_HAS_PREFERRED_ISSUER;

    if (pSummaryStatus->dwErrorStatus &
            CERT_TRUST_ANY_NAME_CONSTRAINT_ERROR_STATUS)
        pSummaryStatus->dwInfoStatus &= ~CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS;
}


//+===========================================================================
//  Format and append extended error information helper functions
//============================================================================

//+---------------------------------------------------------------------------
//
//  Function:   ChainAllocAndEncodeObject
//
//  Synopsis:   allocate and ASN.1 encodes the data structure.
//
//              PkiFree must be called to free the encoded bytes
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainAllocAndEncodeObject(
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    return CryptEncodeObjectEx(
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        lpszStructType,
        pvStructInfo,
        CRYPT_ENCODE_ALLOC_FLAG,
        &PkiEncodePara,
        (void *) ppbEncoded,
        pcbEncoded
        );
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainAppendExtendedErrorInfo
//
//  Synopsis:   PkiReallocate and append an already localization formatted
//              line of extended error information
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainAppendExtendedErrorInfo(
    IN OUT LPWSTR *ppwszExtErrorInfo,
    IN LPWSTR pwszAppend,
    IN DWORD cchAppend                  // Includes NULL terminator
    )
{
    LPWSTR pwszExtErrorInfo = *ppwszExtErrorInfo;
    DWORD cchExtErrorInfo;

    if (pwszExtErrorInfo)
        cchExtErrorInfo = wcslen(pwszExtErrorInfo);
    else
        cchExtErrorInfo = 0;

    assert(0 < cchAppend);

    if (pwszExtErrorInfo = (LPWSTR) PkiRealloc(pwszExtErrorInfo,
            (cchExtErrorInfo + cchAppend) * sizeof(WCHAR))) {
        memcpy(&pwszExtErrorInfo[cchExtErrorInfo], pwszAppend,
            cchAppend * sizeof(WCHAR));
        *ppwszExtErrorInfo = pwszExtErrorInfo;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainFormatAndAppendExtendedErrorInfo
//
//  Synopsis:   localization format a line of extended error information
//              and append via the above ChainAppendExtendedErrorInfo
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFormatAndAppendExtendedErrorInfo(
    IN OUT LPWSTR *ppwszExtErrorInfo,
    IN UINT nFormatID,
    ...
    )
{
    DWORD cchMsg = 0;
    LPWSTR pwszMsg = NULL;
    WCHAR wszFormat[256];
    wszFormat[0] = '\0';
    va_list argList;

    // get format string from resources
    if(0 == LoadStringU(g_hChainInst, nFormatID, wszFormat,
            sizeof(wszFormat)/sizeof(wszFormat[0])))
        return;

    __try {

        // format message into requested buffer
        va_start(argList, nFormatID);
        cchMsg = FormatMessageU(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
            wszFormat,
            0,                  // dwMessageId
            0,                  // dwLanguageId
            (LPWSTR) &pwszMsg,
            0,                  // minimum size to allocate
            &argList);

        va_end(argList);

        // Must at least have the L'\n' terminator
        if (1 < cchMsg && pwszMsg)
            ChainAppendExtendedErrorInfo(
                ppwszExtErrorInfo,
                pwszMsg,
                cchMsg + 1
                );

    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }

    if (pwszMsg)
        LocalFree(pwszMsg);
}

//+===========================================================================
//  Name Constraint helper functions
//============================================================================

//+---------------------------------------------------------------------------
//
//  Function:   ChainIsWhiteSpace
//
//  Synopsis:   returns TRUE for a white space character
//
//----------------------------------------------------------------------------
static inline BOOL ChainIsWhiteSpace(WCHAR wc)
{
    return wc == L' ' || (wc >= 0x09 && wc <= 0x0d);
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainRemoveLeadingAndTrailingWhiteSpace
//
//  Synopsis:   advances the pointer past any leading white space. Removes
//              any trailing white space by inserting the L'\0' and updating
//              the character count.
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainRemoveLeadingAndTrailingWhiteSpace(
    IN LPWSTR pwszIn,
    OUT LPWSTR *ppwszOut,
    OUT DWORD *pcchOut
    )
{
    LPWSTR pwszOut;
    DWORD cchOut;
    WCHAR wc;

    // Remove leading white space
    for (pwszOut = pwszIn ; L'\0' != (wc = *pwszOut); pwszOut++) {
        if (!ChainIsWhiteSpace(wc))
            break;
    }

    for (cchOut = wcslen(pwszOut); 0 < cchOut; cchOut--) {
        if (!ChainIsWhiteSpace(pwszOut[cchOut - 1]))
            break;
    }

    pwszOut[cchOut] = L'\0';
    *ppwszOut = pwszOut;
    *pcchOut = cchOut;
}

#define NO_LOCALE MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT)

//+---------------------------------------------------------------------------
//
//  Function:   ChainIsRightStringInString
//
//  Synopsis:   returns TRUE for a case insensitive match of the
//              "Right" string with the right most characters of the
//              string.
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainIsRightStringInString(
    IN LPCWSTR pwszRight,
    IN DWORD cchRight,
    IN LPCWSTR pwszString,
    IN DWORD cchString
    )
{
    if (0 == cchRight)
        return TRUE;
    if (cchRight > cchString)
        return FALSE;

    if (CSTR_EQUAL == CompareStringU(
            NO_LOCALE,
            NORM_IGNORECASE,
            pwszRight,
            cchRight,
            pwszString + (cchString - cchRight),
            cchRight
            ))
        return TRUE;
    else
        return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFixupNameConstraintsUPN
//
//  Synopsis:   fixup the CERT_ALT_NAME_OTHER_NAME AltName entry choice
//              for szOID_NT_PRINCIPAL_NAME by allocating and converting
//              to a PCERT_NAME_VALUE containing the unicode string
//              with leading and trailing white space removed.
//
//              The pOtherName->Value.pbData is updated to point to the
//              PCERT_NAME_VALUE instead of the original ASN.1 encoded
//              bytes.
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainFixupNameConstraintsUPN(
    IN OUT PCRYPT_OBJID_BLOB pUPN
    )
{
    BOOL fResult;
    PCERT_NAME_VALUE pNameValue;
    LPWSTR pwsz;
    DWORD cch;

    pNameValue = (PCERT_NAME_VALUE) ChainAllocAndDecodeObject(
        X509_UNICODE_ANY_STRING, 
        pUPN->pbData,
        pUPN->cbData
        );
    if (NULL == pNameValue)
        goto DecodeError;

    if (!IS_CERT_RDN_CHAR_STRING(pNameValue->dwValueType)) {
        PkiFree(pNameValue);
        goto InvalidUPNStringType;
    }

    ChainRemoveLeadingAndTrailingWhiteSpace(
        (LPWSTR) pNameValue->Value.pbData,
        &pwsz,
        &cch
        );

    pNameValue->Value.pbData = (BYTE *) pwsz;
    pNameValue->Value.cbData = cch * sizeof(WCHAR);

    pUPN->pbData = (BYTE *) pNameValue;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    pUPN->pbData = NULL;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(DecodeError)
SET_ERROR(InvalidUPNStringType, CRYPT_E_BAD_ENCODE)
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainAllocDecodeAndFixupNameConstraintsDirectoryName
//
//  Synopsis:   fixup the CERT_ALT_NAME_DIRECTORY_NAME AltName entry choice
//              or the encoded certificate Subject name by allocating and
//              converting to a unicode PCERT_NAME_INFO where
//              leading and trailing white space has been removed from
//              all the attributes.
//
//              The DirectoryName.pbData is updated to point to the
//              PCERT_NAME_INFO instead of the original ASN.1 encoded
//              bytes.
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainAllocDecodeAndFixupNameConstraintsDirectoryName(
    IN PCERT_NAME_BLOB pDirName,
    OUT PCERT_NAME_INFO *ppNameInfo
    )
{
    BOOL fResult;
    PCERT_NAME_INFO pNameInfo = NULL;
    DWORD cRDN;
    PCERT_RDN pRDN;

    if (0 == pDirName->cbData)
        goto SuccessReturn;

    pNameInfo = (PCERT_NAME_INFO) ChainAllocAndDecodeObject(
        X509_UNICODE_NAME, 
        pDirName->pbData,
        pDirName->cbData
        );
    if (NULL == pNameInfo)
        goto DecodeError;

    if (0 == pNameInfo->cRDN) {
        PkiFree(pNameInfo);
        pNameInfo = NULL;
        goto SuccessReturn;
    }

    // Iterate through all the attributes and remove leading and trailing
    // white space.
    cRDN = pNameInfo->cRDN;
    pRDN = pNameInfo->rgRDN;
    for ( ; cRDN > 0; cRDN--, pRDN++) {
        DWORD cAttr = pRDN->cRDNAttr;
        PCERT_RDN_ATTR pAttr = pRDN->rgRDNAttr;
        for ( ; cAttr > 0; cAttr--, pAttr++) {
            LPWSTR pwsz;
            DWORD cch;

            if (!IS_CERT_RDN_CHAR_STRING(pAttr->dwValueType))
                continue;

            ChainRemoveLeadingAndTrailingWhiteSpace(
                (LPWSTR) pAttr->Value.pbData,
                &pwsz,
                &cch
                );

            pAttr->Value.pbData = (BYTE *) pwsz;
            pAttr->Value.cbData = cch * sizeof(WCHAR);
        }
    }

SuccessReturn:
    fResult = TRUE;

CommonReturn:
    *ppNameInfo = pNameInfo;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(DecodeError)
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFixupNameConstraintsAltNameEntry
//
//  Synopsis:   fixup the AltName entry choices as follows:
//                  CERT_ALT_NAME_OTHER_NAME
//                      For szOID_NT_PRINCIPAL_NAME, pOtherName->Value.pbData
//                      is updated to point to the allocated
//                      PCERT_NAME_VALUE containing the decoded unicode string.
//
//                  CERT_ALT_NAME_RFC822_NAME
//                  CERT_ALT_NAME_DNS_NAME
//                  CERT_ALT_NAME_URL
//                      Uses DirectoryName.pbData and DirectoryName.cbData
//                      to contain the pointer to and length of the unicode
//                      string.
//
//                      For the subject URL, the DirectoryName.pbData's
//                      unicode string is the allocated host name.
//
//                  CERT_ALT_NAME_DIRECTORY_NAME:
//                      DirectoryName.pbData is updated to point to the
//                      allocated and decoded unicode PCERT_NAME_INFO.
//
//              For the above choices, leading and trailing white space
//              has been removed. cbData is number of bytes and not number
//              of characters, ie, cbData = cch * sizeof(WCHAR)
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainFixupNameConstraintsAltNameEntry(
    IN BOOL fSubjectConstraint,
    IN OUT PCERT_ALT_NAME_ENTRY pEntry
    )
{
    BOOL fResult = TRUE;

    LPWSTR pwsz = NULL;
    DWORD cch = 0;

    switch (pEntry->dwAltNameChoice) {
        case CERT_ALT_NAME_OTHER_NAME:
            if (0 == strcmp(pEntry->pOtherName->pszObjId,
                    szOID_NT_PRINCIPAL_NAME))
                fResult = ChainFixupNameConstraintsUPN(
                    &pEntry->pOtherName->Value);
            break;
        case CERT_ALT_NAME_RFC822_NAME:
        case CERT_ALT_NAME_DNS_NAME:
            ChainRemoveLeadingAndTrailingWhiteSpace(
                pEntry->pwszRfc822Name,
                &pwsz,
                &cch
                );
            // Use the directory name's BLOB choice to contain both
            // the pointer to and length of the string
            pEntry->DirectoryName.pbData  = (BYTE *) pwsz;
            pEntry->DirectoryName.cbData  = cch * sizeof(WCHAR);
            break;
        case CERT_ALT_NAME_URL:
            if (fSubjectConstraint) {
                WCHAR rgwszHostName[MAX_PATH + 1];
                LPWSTR pwszHostName;

                rgwszHostName[0] = L'\0';
                fResult = ChainGetHostNameFromUrl(
                    pEntry->pwszURL, MAX_PATH, rgwszHostName);
                if (fResult) {
                    ChainRemoveLeadingAndTrailingWhiteSpace(
                        rgwszHostName,
                        &pwszHostName,
                        &cch
                        );
                    pwsz = (LPWSTR) PkiNonzeroAlloc((cch + 1) * sizeof(WCHAR));
                    if (NULL == pwsz)
                        fResult = FALSE;
                    else
                        memcpy(pwsz, pwszHostName, (cch + 1) * sizeof(WCHAR));
                }

                if (!fResult) {
                    pwsz = NULL;
                    cch = 0;
                }
            } else {
                ChainRemoveLeadingAndTrailingWhiteSpace(
                    pEntry->pwszURL,
                    &pwsz,
                    &cch
                    );
            }

            // Use the directory name's BLOB choice to contain both
            // the pointer to and length of the string
            pEntry->DirectoryName.pbData  = (BYTE *) pwsz;
            pEntry->DirectoryName.cbData  = cch * sizeof(WCHAR);
            break;
        case CERT_ALT_NAME_DIRECTORY_NAME:
            {
                PCERT_NAME_INFO pNameInfo = NULL;
                fResult = ChainAllocDecodeAndFixupNameConstraintsDirectoryName(
                    &pEntry->DirectoryName, &pNameInfo);

                // Update the directory name's BLOB to contain the pointer
                // to the decoded name info
                pEntry->DirectoryName.pbData = (BYTE *) pNameInfo;
            }
            break;
        case CERT_ALT_NAME_X400_ADDRESS:
        case CERT_ALT_NAME_EDI_PARTY_NAME:
        case CERT_ALT_NAME_IP_ADDRESS:
        case CERT_ALT_NAME_REGISTERED_ID:
        default:
            break;
    }

    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeNameConstraintsAltNameEntryFixup
//
//  Synopsis:   free memory allocated by the above
//              ChainFixupNameConstraintsAltNameEntry
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeNameConstraintsAltNameEntryFixup(
    IN BOOL fSubjectConstraint,
    IN OUT PCERT_ALT_NAME_ENTRY pEntry
    )
{
    switch (pEntry->dwAltNameChoice) {
        case CERT_ALT_NAME_OTHER_NAME:
            if (0 == strcmp(pEntry->pOtherName->pszObjId,
                    szOID_NT_PRINCIPAL_NAME))
                // pbData :: PCERT_NAME_VALUE
                PkiFree(pEntry->pOtherName->Value.pbData);
            break;
        case CERT_ALT_NAME_RFC822_NAME:
        case CERT_ALT_NAME_DNS_NAME:
            break;
        case CERT_ALT_NAME_URL:
            if (fSubjectConstraint)
                // pbData :: LPWSTR
                PkiFree(pEntry->DirectoryName.pbData);
            break;
        case CERT_ALT_NAME_DIRECTORY_NAME:
            // pbData :: PCERT_NAME_INFO
            PkiFree(pEntry->DirectoryName.pbData);
            break;
        case CERT_ALT_NAME_X400_ADDRESS:
        case CERT_ALT_NAME_EDI_PARTY_NAME:
        case CERT_ALT_NAME_IP_ADDRESS:
        case CERT_ALT_NAME_REGISTERED_ID:
        default:
            break;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFormatNameConstraintsAltNameEntryFixup
//
//  Synopsis:   localization format and allocate a previously fixed up
//              AltName entry.
//
//              The returned string must be freed via PkiFree().
//
//----------------------------------------------------------------------------
LPWSTR WINAPI
ChainFormatNameConstraintsAltNameEntryFixup(
    IN PCERT_ALT_NAME_ENTRY pEntry
    )
{
    DWORD dwExceptionCode;
    LPWSTR pwszFormat = NULL;
    DWORD cbFormat = 0;
    CERT_ALT_NAME_ENTRY AltEntry;
    const CERT_ALT_NAME_INFO AltNameInfo = { 1, &AltEntry };
    CERT_OTHER_NAME OtherName;

    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    BYTE *pbEncoded2 = NULL;
    DWORD cbEncoded2;

    __try {

        AltEntry = *pEntry;

        // Restore fixed up entries so we can re-encode
        switch (AltEntry.dwAltNameChoice) {
            case CERT_ALT_NAME_OTHER_NAME:
                if (0 == strcmp(pEntry->pOtherName->pszObjId,
                        szOID_NT_PRINCIPAL_NAME)) {
                    // Restore from the following fixup:
                    //  pEntry->pOtherName->Value.pbData :: PCERT_NAME_VALUE
                    if (NULL == pEntry->pOtherName->Value.pbData)
                        goto InvalidUPN;
                    if (!ChainAllocAndEncodeObject(
                            X509_UNICODE_ANY_STRING, 
                            (PCERT_NAME_VALUE) pEntry->pOtherName->Value.pbData,
                            &pbEncoded2,
                            &cbEncoded2
                            ))
                        goto EncodedUPNError;
                    OtherName.pszObjId = pEntry->pOtherName->pszObjId;
                    OtherName.Value.pbData = pbEncoded2;
                    OtherName.Value.cbData = cbEncoded2;

                    AltEntry.pOtherName = &OtherName;
                }
                break;
            case CERT_ALT_NAME_RFC822_NAME:
            case CERT_ALT_NAME_DNS_NAME:
            case CERT_ALT_NAME_URL:
                // Restore from the following fixup:
                //  pEntry->DirectoryName.pbData  = (BYTE *) pwsz;
                //  pEntry->DirectoryName.cbData  = cch * sizeof(WCHAR);
                if (NULL == pEntry->DirectoryName.pbData ||
                        0 == pEntry->DirectoryName.cbData)
                    AltEntry.pwszRfc822Name = L"???";
                else
                    AltEntry.pwszRfc822Name =
                        (LPWSTR) pEntry->DirectoryName.pbData;
                break;
            case CERT_ALT_NAME_DIRECTORY_NAME:
                // Restore from the following fixup:
                //  pEntry->DirectoryName.pbData :: PCERT_NAME_INFO
                if (NULL == pEntry->DirectoryName.pbData)
                    goto InvalidDirName;
                if (!ChainAllocAndEncodeObject(
                        X509_UNICODE_NAME,
                        (PCERT_NAME_INFO) pEntry->DirectoryName.pbData,
                        &pbEncoded2,
                        &cbEncoded2
                        ))
                    goto EncodeDirNameError;

                AltEntry.DirectoryName.pbData = pbEncoded2;
                AltEntry.DirectoryName.cbData = cbEncoded2;
                break;
            case CERT_ALT_NAME_X400_ADDRESS:
            case CERT_ALT_NAME_EDI_PARTY_NAME:
            case CERT_ALT_NAME_IP_ADDRESS:
            case CERT_ALT_NAME_REGISTERED_ID:
            default:
                break;
        }

        if (!ChainAllocAndEncodeObject(
                X509_ALTERNATE_NAME,
                &AltNameInfo,
                &pbEncoded,
                &cbEncoded
                ))
            goto EncodeAltNameError;

        if (!CryptFormatObject(
                X509_ASN_ENCODING,
                0,                          // dwFormatType
                0,                          // dwFormatStrType
                NULL,                       // pFormatStruct
                X509_ALTERNATE_NAME,
                pbEncoded,
                cbEncoded,
                NULL,                       // pwszFormat
                &cbFormat
                ))
            goto FormatAltNameError;

        if (NULL == (pwszFormat = (LPWSTR) PkiZeroAlloc(
                cbFormat + sizeof(WCHAR))))
            goto OutOfMemory;

        if (!CryptFormatObject(
                X509_ASN_ENCODING,
                0,                          // dwFormatType
                0,                          // dwFormatStrType
                NULL,                       // pFormatStruct
                X509_ALTERNATE_NAME,
                pbEncoded,
                cbEncoded,
                pwszFormat,
                &cbFormat
                ))
            goto FormatAltNameError;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwExceptionCode = GetExceptionCode();
        goto ExceptionError;
    }

CommonReturn:
    PkiFree(pbEncoded);
    PkiFree(pbEncoded2);

    return pwszFormat;

ErrorReturn:
    if (pwszFormat) {
        PkiFree(pwszFormat);
        pwszFormat = NULL;
    }
    goto CommonReturn;

SET_ERROR(InvalidUPN, ERROR_INVALID_DATA)
TRACE_ERROR(EncodedUPNError)
TRACE_ERROR(InvalidDirName)
TRACE_ERROR(EncodeDirNameError)
TRACE_ERROR(EncodeAltNameError)
TRACE_ERROR(FormatAltNameError)
TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainFormatAndAppendNameConstraintsAltNameEntryFixup
//
//  Synopsis:   localization format a previously fixed up
//              AltName entry and append to the extended error information.
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFormatAndAppendNameConstraintsAltNameEntryFixup(
    IN OUT LPWSTR *ppwszExtErrorInfo,
    IN PCERT_ALT_NAME_ENTRY pEntry,
    IN UINT nFormatID,
    IN OPTIONAL DWORD dwSubtreeIndex        // 0 => no subtree parameter
    )
{
    LPWSTR pwszAllocFormatEntry = NULL;
    LPWSTR pwszFormatEntry;

    pwszAllocFormatEntry = ChainFormatNameConstraintsAltNameEntryFixup(pEntry);
    if (pwszAllocFormatEntry)
        pwszFormatEntry = pwszAllocFormatEntry;
    else
        pwszFormatEntry = L"???";

    if (0 == dwSubtreeIndex)
        ChainFormatAndAppendExtendedErrorInfo(
            ppwszExtErrorInfo,
            nFormatID,
            pwszFormatEntry
            );
    else
        ChainFormatAndAppendExtendedErrorInfo(
            ppwszExtErrorInfo,
            nFormatID,
            dwSubtreeIndex,
            pwszFormatEntry
            );

    PkiFree(pwszAllocFormatEntry);
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetIssuerNameConstraintsInfo
//
//  Synopsis:   alloc and return the issuer name constraints info.
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainGetIssuerNameConstraintsInfo (
    IN PCCERT_CONTEXT pCertContext,
    IN OUT PCERT_NAME_CONSTRAINTS_INFO *ppInfo
    )
{
    BOOL fResult;
    PCERT_EXTENSION pExt;
    PCERT_NAME_CONSTRAINTS_INFO pInfo = NULL;
    PCERT_GENERAL_SUBTREE pSubtree;
    DWORD cSubtree;

    pExt = CertFindExtension(
        szOID_NAME_CONSTRAINTS,
        pCertContext->pCertInfo->cExtension,
        pCertContext->pCertInfo->rgExtension
        );
    if (NULL == pExt)
        goto SuccessReturn;

    pInfo = (PCERT_NAME_CONSTRAINTS_INFO) ChainAllocAndDecodeObject(
        X509_NAME_CONSTRAINTS, 
        pExt->Value.pbData,
        pExt->Value.cbData
        );
    if (NULL == pInfo)
        goto DecodeError;


    // Fixup all the AltName entries

    // Note, even for an error we need to fixup all the entries.
    // ChainFreeIssuerNameConstraintsInfo iterates through all the entries.
    fResult = TRUE;

    cSubtree = pInfo->cPermittedSubtree;
    pSubtree = pInfo->rgPermittedSubtree;
    for ( ; 0 < cSubtree; cSubtree--, pSubtree++) {
        if (!ChainFixupNameConstraintsAltNameEntry(FALSE, &pSubtree->Base))
            fResult = FALSE;
    }

    cSubtree = pInfo->cExcludedSubtree;
    pSubtree = pInfo->rgExcludedSubtree;
    for ( ; 0 < cSubtree; cSubtree--, pSubtree++) {
        if (!ChainFixupNameConstraintsAltNameEntry(FALSE, &pSubtree->Base))
            fResult = FALSE;
    }

    if (!fResult)
        goto FixupAltNameEntryError;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    *ppInfo = pInfo;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(DecodeError)
TRACE_ERROR(FixupAltNameEntryError)
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeIssuerNameConstraintsInfo
//
//  Synopsis:   free the issuer name constraints info
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeIssuerNameConstraintsInfo (
    IN OUT PCERT_NAME_CONSTRAINTS_INFO pInfo
    )
{
    PCERT_GENERAL_SUBTREE pSubtree;
    DWORD cSubtree;

    if (NULL == pInfo)
        return;

    cSubtree = pInfo->cPermittedSubtree;
    pSubtree = pInfo->rgPermittedSubtree;
    for ( ; 0 < cSubtree; cSubtree--, pSubtree++)
        ChainFreeNameConstraintsAltNameEntryFixup(FALSE, &pSubtree->Base);

    cSubtree = pInfo->cExcludedSubtree;
    pSubtree = pInfo->rgExcludedSubtree;
    for ( ; 0 < cSubtree; cSubtree--, pSubtree++)
        ChainFreeNameConstraintsAltNameEntryFixup(FALSE, &pSubtree->Base);

    PkiFree(pInfo);
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainGetSubjectNameConstraintsInfo
//
//  Synopsis:   alloc and return the subject name constraints info.
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainGetSubjectNameConstraintsInfo (
    IN PCCERT_CONTEXT pCertContext,
    IN OUT PCHAIN_SUBJECT_NAME_CONSTRAINTS_INFO pSubjectInfo
    )
{
    PCERT_EXTENSION pExt;
    BOOL fHasEmailAltNameEntry = FALSE;

    pExt = CertFindExtension(
        szOID_SUBJECT_ALT_NAME2,
        pCertContext->pCertInfo->cExtension,
        pCertContext->pCertInfo->rgExtension
        );

    if (NULL == pExt) {
        pExt = CertFindExtension(
            szOID_SUBJECT_ALT_NAME,
            pCertContext->pCertInfo->cExtension,
            pCertContext->pCertInfo->rgExtension
            );
    }

    if (pExt) {
        PCERT_ALT_NAME_INFO pAltNameInfo;

        pAltNameInfo = (PCERT_ALT_NAME_INFO) ChainAllocAndDecodeObject(
            X509_ALTERNATE_NAME, 
            pExt->Value.pbData,
            pExt->Value.cbData
            );
        if (NULL == pAltNameInfo)
            pSubjectInfo->fInvalid = TRUE;
        else {
            DWORD cEntry;
            PCERT_ALT_NAME_ENTRY pEntry;
            
            pSubjectInfo->pAltNameInfo = pAltNameInfo;

            // Fixup all the AltName entries

            // Note, even for an error we need to fixup all the entries.
            // ChainFreeSubjectNameConstraintsInfo iterates through all
            // the entries.

            cEntry = pAltNameInfo->cAltEntry;
            pEntry = pAltNameInfo->rgAltEntry;
            for ( ; 0 < cEntry; cEntry--, pEntry++) {
                if (CERT_ALT_NAME_RFC822_NAME == pEntry->dwAltNameChoice)
                    fHasEmailAltNameEntry = TRUE;
                else if (CERT_ALT_NAME_DNS_NAME == pEntry->dwAltNameChoice)
                    pSubjectInfo->fHasDnsAltNameEntry = TRUE;

                if (!ChainFixupNameConstraintsAltNameEntry(TRUE, pEntry))
                    pSubjectInfo->fInvalid = TRUE;
            }
        }
    }

    if (!ChainAllocDecodeAndFixupNameConstraintsDirectoryName(
            &pCertContext->pCertInfo->Subject,
            &pSubjectInfo->pUnicodeNameInfo 
            ))
        pSubjectInfo->fInvalid = TRUE;

    if (!fHasEmailAltNameEntry && pSubjectInfo->pUnicodeNameInfo) {
        DWORD cRDN;
        PCERT_RDN pRDN;

        cRDN = pSubjectInfo->pUnicodeNameInfo->cRDN;
        pRDN = pSubjectInfo->pUnicodeNameInfo->rgRDN;
        for ( ; cRDN > 0; cRDN--, pRDN++) {
            DWORD cAttr = pRDN->cRDNAttr;
            PCERT_RDN_ATTR pAttr = pRDN->rgRDNAttr;
            for ( ; cAttr > 0; cAttr--, pAttr++) {
                if (!IS_CERT_RDN_CHAR_STRING(pAttr->dwValueType))
                    continue;

                if (0 == strcmp(pAttr->pszObjId, szOID_RSA_emailAddr)) {
                    pSubjectInfo->pEmailAttr = pAttr;
                    break;
                }

            }
            if (cAttr > 0)
                break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeSubjectNameConstraintsInfo
//
//  Synopsis:   free the subject name constraints info
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeSubjectNameConstraintsInfo (
    IN OUT PCHAIN_SUBJECT_NAME_CONSTRAINTS_INFO pSubjectInfo
    )
{
    PCERT_ALT_NAME_INFO pAltNameInfo;

    pAltNameInfo = pSubjectInfo->pAltNameInfo;
    if (pAltNameInfo) {
        DWORD cEntry;
        PCERT_ALT_NAME_ENTRY pEntry;
            
        cEntry = pAltNameInfo->cAltEntry;
        pEntry = pAltNameInfo->rgAltEntry;
        for ( ; 0 < cEntry; cEntry--, pEntry++)
            ChainFreeNameConstraintsAltNameEntryFixup(TRUE, pEntry);

        PkiFree(pAltNameInfo);
    }

    PkiFree(pSubjectInfo->pUnicodeNameInfo);
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCompareNameConstraintsDirectoryName
//
//  Synopsis:   returns TRUE if all the subtree RDN attributes match
//              the RDN attributes at the beginning of the subject
//              directory name. A case insensitive match
//              is performed on each RDN attribute that is a string type.
//              A binary compare is performed on nonstring attribute types.
//
//              The OIDs of the RDN attributes must match.
//
//              Note, a NULL subtree or a subtree with no RDNs matches
//              any subject directory name. Also, an empty subtree
//              RDN attribute matches any subject attribute. 
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCompareNameConstraintsDirectoryName(
    IN PCERT_NAME_INFO pSubjectInfo,
    IN PCERT_NAME_INFO pSubtreeInfo
    )
{
    DWORD cSubjectRDN;
    PCERT_RDN pSubjectRDN;
    DWORD cSubtreeRDN;
    PCERT_RDN pSubtreeRDN;

    if (NULL == pSubtreeInfo || 0 == pSubtreeInfo->cRDN)
        // Match any subject
        return TRUE;
    if (NULL == pSubjectInfo)
        return FALSE;

    cSubjectRDN = pSubjectInfo->cRDN;
    cSubtreeRDN = pSubtreeInfo->cRDN;
    if (cSubtreeRDN > cSubjectRDN)
        return FALSE;

    pSubjectRDN = pSubjectInfo->rgRDN;
    pSubtreeRDN = pSubtreeInfo->rgRDN;
    for ( ; cSubtreeRDN > 0; cSubtreeRDN--, pSubtreeRDN++, pSubjectRDN++) {
        DWORD cSubjectAttr = pSubjectRDN->cRDNAttr;
        PCERT_RDN_ATTR pSubjectAttr = pSubjectRDN->rgRDNAttr;
        DWORD cSubtreeAttr = pSubtreeRDN->cRDNAttr;
        PCERT_RDN_ATTR pSubtreeAttr = pSubtreeRDN->rgRDNAttr;

        if (1 < cSubtreeRDN) {
            if (cSubtreeAttr != cSubjectAttr)
                return FALSE;
        } else {
            if (cSubtreeAttr > cSubjectAttr)
                return FALSE;
        }

        for ( ; cSubtreeAttr > 0; cSubtreeAttr--, pSubtreeAttr++, pSubjectAttr++) {
            if (0 != strcmp(pSubtreeAttr->pszObjId, pSubjectAttr->pszObjId))
                return FALSE;

            if (IS_CERT_RDN_CHAR_STRING(pSubtreeAttr->dwValueType) !=
                    IS_CERT_RDN_CHAR_STRING(pSubjectAttr->dwValueType))
                return FALSE;

            if (IS_CERT_RDN_CHAR_STRING(pSubtreeAttr->dwValueType)) {
                DWORD cchSubtree = pSubtreeAttr->Value.cbData / sizeof(WCHAR);

                if (0 == cchSubtree) {
                    // Match any attribute
                    ;
                } else if (cchSubtree !=
                        pSubjectAttr->Value.cbData / sizeof(WCHAR)) {
                    // For X.509, must match entire attribute
                    return FALSE;
                } else if (!ChainIsRightStringInString(
                        (LPCWSTR) pSubtreeAttr->Value.pbData,
                        cchSubtree,
                        (LPCWSTR) pSubjectAttr->Value.pbData,
                        cchSubtree
                        )) {
                    return FALSE;
                }
            } else {
                if (pSubtreeAttr->Value.cbData != pSubjectAttr->Value.cbData)
                    return FALSE;
                if (0 != memcmp(pSubtreeAttr->Value.pbData,
                        pSubjectAttr->Value.pbData,
                        pSubtreeAttr->Value.cbData
                        ))
                    return FALSE;
            }
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCompareNameConstraintsIPAddress
//
//  Synopsis:   returns TRUE if the subject IP address is within the IP
//              range specified by subtree IP address and mask.
//
//              The subtree IP contains the octet bytes for both the
//              IP address and its mask.
//
//              For IPv4, there are 4 address bytes followed by 4 mask bytes.
//              See RFC 2459 for more details.
//
//              Here's my interpretation:
//
//              For a match: SubtreeIPAddr == (SubjectIPAddr & SubtreeIPMask)
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCompareNameConstraintsIPAddress(
    IN PCRYPT_DATA_BLOB pSubjectIPAddress,
    IN PCRYPT_DATA_BLOB pSubtreeIPAddress
    )
{
    BYTE *pbSubject = pSubjectIPAddress->pbData;
    DWORD cbSubject = pSubjectIPAddress->cbData;
    BYTE *pbSubtree = pSubtreeIPAddress->pbData;
    DWORD cbSubtree = pSubtreeIPAddress->cbData;
    BYTE *pbSubtreeMask = pbSubtree + cbSubject;

    DWORD i;

    if (0 == cbSubtree)
        // Match any IP address
        return TRUE;

    // Only compare if the number of subtree bytes is twice the length of
    // the subject. Second half contains the mask.
    if (cbSubtree != 2 * cbSubject)
        return FALSE;

    for (i = 0; i < cbSubject; i++) {
        if (pbSubtree[i] != (pbSubject[i] & pbSubtreeMask[i]))
            return FALSE;
    }

    return TRUE;

}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCompareNameConstraintsUPN
//
//  Synopsis:   returns TRUE if the subtree UPN string matches the right most
//              characters of the subject's UPN doing a case insensitive
//              match.
//
//              Note, the Value.pbData points to the decoded PCERT_NAME_VALUE.
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCompareNameConstraintsUPN(
    IN PCRYPT_OBJID_BLOB pSubjectValue,
    IN PCRYPT_OBJID_BLOB pSubtreeValue
    )
{
    // The UPN's Value.pbData is used to point to the decoded
    // PCERT_NAME_VALUE

    BOOL fCompare;
    PCERT_NAME_VALUE pSubjectNameValue;
    PCERT_NAME_VALUE pSubtreeNameValue;

    pSubjectNameValue =
        (PCERT_NAME_VALUE) pSubjectValue->pbData;
    pSubtreeNameValue =
        (PCERT_NAME_VALUE) pSubtreeValue->pbData;

    if (pSubjectNameValue && pSubtreeNameValue)
        fCompare = ChainIsRightStringInString(
            (LPCWSTR) pSubtreeNameValue->Value.pbData,
            pSubtreeNameValue->Value.cbData / sizeof(WCHAR),
            (LPCWSTR) pSubjectNameValue->Value.pbData,
            pSubjectNameValue->Value.cbData / sizeof(WCHAR)
            );
    else
        fCompare = FALSE;

    return fCompare;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCalculateNameConstraintsSubtreeErrorStatusForAltNameEntry
//
//  Synopsis:   calculates the name constraints error status by seeing if
//              the subject AltName entry matches any subtree AltName entry.
//
//----------------------------------------------------------------------------
DWORD WINAPI
ChainCalculateNameConstraintsSubtreeErrorStatusForAltNameEntry(
    IN PCERT_ALT_NAME_ENTRY pSubjectEntry,
    IN BOOL fExcludedSubtree,
    IN DWORD cSubtree,
    IN PCERT_GENERAL_SUBTREE pSubtree,
    IN OUT LPWSTR *ppwszExtErrorInfo
    )
{
    DWORD dwErrorStatus = 0;
    BOOL fHasSubtreeEntry = FALSE;
    DWORD dwAltNameChoice = pSubjectEntry->dwAltNameChoice;
    DWORD i;

    for (i = 0; i < cSubtree; i++, pSubtree++) {
        PCERT_ALT_NAME_ENTRY pSubtreeEntry;
        BOOL fCompare;

        if (0 != pSubtree->dwMinimum || pSubtree->fMaximum) {
            dwErrorStatus |= CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT;

            ChainFormatAndAppendExtendedErrorInfo(
                ppwszExtErrorInfo,
                fExcludedSubtree ?
                    IDS_NOT_SUPPORTED_EXCLUDED_NAME_CONSTRAINT :
                    IDS_NOT_SUPPORTED_PERMITTED_NAME_CONSTRAINT,
                i + 1
                );
            continue;
        }

        pSubtreeEntry = &pSubtree->Base;
        if (dwAltNameChoice != pSubtreeEntry->dwAltNameChoice)
            continue;

        fCompare = FALSE;
        switch (dwAltNameChoice) {
            case CERT_ALT_NAME_OTHER_NAME:
                // Only support the UPN OID
                if (0 != strcmp(pSubtreeEntry->pOtherName->pszObjId,
                            szOID_NT_PRINCIPAL_NAME)) {
                    dwErrorStatus |=
                        CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT;

                    ChainFormatAndAppendExtendedErrorInfo(
                        ppwszExtErrorInfo,
                        fExcludedSubtree ?
                            IDS_NOT_SUPPORTED_EXCLUDED_NAME_CONSTRAINT :
                            IDS_NOT_SUPPORTED_PERMITTED_NAME_CONSTRAINT,
                        i + 1
                        );
                } else {
                    assert(0 == strcmp(pSubjectEntry->pOtherName->pszObjId,
                        szOID_NT_PRINCIPAL_NAME));
                    fHasSubtreeEntry = TRUE;
                    fCompare = ChainCompareNameConstraintsUPN(
                        &pSubjectEntry->pOtherName->Value,
                        &pSubtreeEntry->pOtherName->Value
                        );
                }
                break;
            case CERT_ALT_NAME_RFC822_NAME:
            case CERT_ALT_NAME_DNS_NAME:
            case CERT_ALT_NAME_URL:
                fHasSubtreeEntry = TRUE;
                // The directory name's BLOB choice is used to contain both
                // the pointer to and length of the string
                fCompare = ChainIsRightStringInString(
                    (LPCWSTR) pSubtreeEntry->DirectoryName.pbData,
                    pSubtreeEntry->DirectoryName.cbData / sizeof(WCHAR),
                    (LPCWSTR) pSubjectEntry->DirectoryName.pbData,
                    pSubjectEntry->DirectoryName.cbData / sizeof(WCHAR)
                    );
                break;
            case CERT_ALT_NAME_DIRECTORY_NAME:
                fHasSubtreeEntry = TRUE;
                fCompare = ChainCompareNameConstraintsDirectoryName(
                    (PCERT_NAME_INFO) pSubjectEntry->DirectoryName.pbData,
                    (PCERT_NAME_INFO) pSubtreeEntry->DirectoryName.pbData
                    );
                break;
            case CERT_ALT_NAME_IP_ADDRESS:
                fHasSubtreeEntry = TRUE;
                fCompare = ChainCompareNameConstraintsIPAddress(
                    &pSubjectEntry->IPAddress, &pSubtreeEntry->IPAddress);
                break;
            case CERT_ALT_NAME_X400_ADDRESS:
            case CERT_ALT_NAME_EDI_PARTY_NAME:
            case CERT_ALT_NAME_REGISTERED_ID:
            default:
                assert(0);
                break;
        }

        if (fCompare) {
            if (fExcludedSubtree) {
                dwErrorStatus |= CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT;

                ChainFormatAndAppendNameConstraintsAltNameEntryFixup(
                    ppwszExtErrorInfo,
                    pSubjectEntry,
                    IDS_EXCLUDED_ENTRY_NAME_CONSTRAINT,
                    i + 1
                    );
            }
            return dwErrorStatus;
        }
    }

    if (!fExcludedSubtree) {
        if (fHasSubtreeEntry) {
            dwErrorStatus |= CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT;

            ChainFormatAndAppendNameConstraintsAltNameEntryFixup(
                ppwszExtErrorInfo,
                pSubjectEntry,
                IDS_NOT_PERMITTED_ENTRY_NAME_CONSTRAINT
                );
        } else {
            dwErrorStatus |= CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT;

            ChainFormatAndAppendNameConstraintsAltNameEntryFixup(
                ppwszExtErrorInfo,
                pSubjectEntry,
                IDS_NOT_DEFINED_ENTRY_NAME_CONSTRAINT
                );
        }
    }

    return dwErrorStatus;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCalculateNameConstraintsErrorStatusForAltNameEntry
//
//  Synopsis:   calculates the name constraints error status by seeing if
//              the subject AltName entry matches either an excluded
//              or permitted subtree AltName entry.
//
//----------------------------------------------------------------------------
DWORD WINAPI
ChainCalculateNameConstraintsErrorStatusForAltNameEntry(
    IN PCERT_ALT_NAME_ENTRY pSubjectEntry,
    IN PCERT_NAME_CONSTRAINTS_INFO pNameConstraintsInfo,
    IN OUT LPWSTR *ppwszExtErrorInfo
    )
{
    DWORD dwErrorStatus;

    dwErrorStatus =
        ChainCalculateNameConstraintsSubtreeErrorStatusForAltNameEntry(
            pSubjectEntry,
            TRUE,                                   // fExcludedSubtree
            pNameConstraintsInfo->cExcludedSubtree,
            pNameConstraintsInfo->rgExcludedSubtree,
            ppwszExtErrorInfo
            );

    if (!(dwErrorStatus & CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT))
        dwErrorStatus =
            ChainCalculateNameConstraintsSubtreeErrorStatusForAltNameEntry(
                pSubjectEntry,
                FALSE,                                  // fExcludedSubtree
                pNameConstraintsInfo->cPermittedSubtree,
                pNameConstraintsInfo->rgPermittedSubtree,
                ppwszExtErrorInfo
                );

    return dwErrorStatus;
}



//+===========================================================================
//  CCertIssuerList helper functions
//============================================================================

//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateIssuerList
//
//  Synopsis:   create the issuer list object for the given subject
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCreateIssuerList (
     IN PCCHAINPATHOBJECT pSubject,
     OUT PCCERTISSUERLIST* ppIssuerList
     )
{
    PCCERTISSUERLIST pIssuerList;

    pIssuerList = new CCertIssuerList( pSubject );
    if ( pIssuerList == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    *ppIssuerList = pIssuerList;
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeIssuerList
//
//  Synopsis:   free the issuer list object
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeIssuerList (
     IN PCCERTISSUERLIST pIssuerList
     )
{
    delete pIssuerList;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeCtlIssuerData
//
//  Synopsis:   free CTL issuer data
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeCtlIssuerData (
     IN PCTL_ISSUER_DATA pCtlIssuerData
     )
{
    if ( pCtlIssuerData->pTrustListInfo != NULL )
    {
        SSCtlFreeTrustListInfo( pCtlIssuerData->pTrustListInfo );
    }

    if ( pCtlIssuerData->pSSCtlObject != NULL )
    {
        pCtlIssuerData->pSSCtlObject->Release();
    }

    delete pCtlIssuerData;
}

//+===========================================================================
//  INTERNAL_CERT_CHAIN_CONTEXT helper functions
//============================================================================

//+---------------------------------------------------------------------------
//
//  Function:   ChainAddRefInternalChainContext
//
//  Synopsis:   addref the internal chain context
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainAddRefInternalChainContext (
     IN PINTERNAL_CERT_CHAIN_CONTEXT pChainContext
     )
{
    InterlockedIncrement( &pChainContext->cRefs );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainReleaseInternalChainContext
//
//  Synopsis:   release the internal chain context
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainReleaseInternalChainContext (
     IN PINTERNAL_CERT_CHAIN_CONTEXT pChainContext
     )
{
    if ( InterlockedDecrement( &pChainContext->cRefs ) == 0 )
    {
        ChainFreeInternalChainContext( pChainContext );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeInternalChainContext
//
//  Synopsis:   free the internal chain context
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeInternalChainContext (
     IN PINTERNAL_CERT_CHAIN_CONTEXT pContext
     )
{

    PCERT_SIMPLE_CHAIN *ppChain;
    DWORD cChain;

    PINTERNAL_CERT_CHAIN_CONTEXT *ppLowerContext;

    if (NULL == pContext)
        return;

    cChain = pContext->ChainContext.cChain;
    ppChain = pContext->ChainContext.rgpChain;
    for ( ; 0 < cChain; cChain--, ppChain++) {
        PCERT_SIMPLE_CHAIN pChain;
        DWORD cElement;
        PCERT_CHAIN_ELEMENT *ppElement;

        pChain = *ppChain;
        if (NULL == pChain)
            continue;

        if (pChain->pTrustListInfo)
            SSCtlFreeTrustListInfo(pChain->pTrustListInfo);

        cElement = pChain->cElement;
        ppElement = pChain->rgpElement;
        for ( ; 0 < cElement; cElement--, ppElement++) {
            PCERT_CHAIN_ELEMENT pElement;

            pElement = *ppElement;
            if (NULL == pElement)
                continue;

            if (pElement->pRevocationInfo) {
                PCERT_REVOCATION_CRL_INFO pCrlInfo =
                    pElement->pRevocationInfo->pCrlInfo;

                if (pCrlInfo) {
                    if (pCrlInfo->pBaseCrlContext)
                        CertFreeCRLContext(pCrlInfo->pBaseCrlContext);
                    if (pCrlInfo->pDeltaCrlContext)
                        CertFreeCRLContext(pCrlInfo->pDeltaCrlContext);

                    delete pCrlInfo;
                }

                delete pElement->pRevocationInfo;
            }

            if (pElement->pCertContext)
                CertFreeCertificateContext(pElement->pCertContext);

            ChainFreeUsage(pElement->pIssuanceUsage);
            ChainFreeUsage(pElement->pApplicationUsage);

            if (pElement->pwszExtendedErrorInfo)
                PkiFree((LPWSTR) pElement->pwszExtendedErrorInfo);
        }

        
    }

    ppLowerContext = (PINTERNAL_CERT_CHAIN_CONTEXT*)
                            pContext->ChainContext.rgpLowerQualityChainContext;
    if (ppLowerContext) {
        DWORD cLowerContext;
        DWORD i;

        cLowerContext = pContext->ChainContext.cLowerQualityChainContext;
        for (i = 0; i < cLowerContext; i++)
            ChainReleaseInternalChainContext(ppLowerContext[i]);

        delete ppLowerContext;
    }

    PkiFree(pContext);
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainUpdateEndEntityCertContext
//
//  Synopsis:   update the end entity cert context in the chain context
//
//----------------------------------------------------------------------------
VOID
ChainUpdateEndEntityCertContext(
    IN OUT PINTERNAL_CERT_CHAIN_CONTEXT pChainContext,
    IN OUT PCCERT_CONTEXT pEndCertContext
    )
{
    PCCERT_CONTEXT pCertContext =
        pChainContext->ChainContext.rgpChain[0]->rgpElement[0]->pCertContext;
    if (pCertContext == pEndCertContext)
        return;
    pChainContext->ChainContext.rgpChain[0]->rgpElement[0]->pCertContext =
        pEndCertContext;

    {
        DWORD cbData;
        DWORD cbEndData;

        // If the chain context's end context has the public key parameter
        // property and the end context passed in to CertGetCertificateChain
        // doesn't, then copy the public key parameter property.
        if (CertGetCertificateContextProperty(
                pCertContext,
                CERT_PUBKEY_ALG_PARA_PROP_ID,
                NULL,                       // pvData
                &cbData) && 0 < cbData &&
            !CertGetCertificateContextProperty(
                pEndCertContext,
                CERT_PUBKEY_ALG_PARA_PROP_ID,
                NULL,                       // pvData
                &cbEndData))
        {
            BYTE *pbData;

            __try {
                pbData = (BYTE *) _alloca(cbData);
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                pbData = NULL;
            }
            if (pbData)
            {
                if (CertGetCertificateContextProperty(
                        pCertContext,
                        CERT_PUBKEY_ALG_PARA_PROP_ID,
                        pbData,
                        &cbData))
                {
                    CRYPT_DATA_BLOB Para;
                    Para.pbData = pbData;
                    Para.cbData = cbData;
                    CertSetCertificateContextProperty(
                        pEndCertContext,
                        CERT_PUBKEY_ALG_PARA_PROP_ID,
                        CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG,
                        &Para
                        );
                }
            }
        }
    }

    CertDuplicateCertificateContext(pEndCertContext);
    CertFreeCertificateContext(pCertContext);
}


//+===========================================================================
//  CERT_REVOCATION_INFO helper functions
//============================================================================

//+---------------------------------------------------------------------------
//
//  Function:   ChainUpdateRevocationInfo
//
//  Synopsis:   update the revocation information on the element
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainUpdateRevocationInfo (
     IN PCERT_REVOCATION_STATUS pRevStatus,
     IN OUT PCERT_REVOCATION_INFO pRevocationInfo,
     IN OUT PCERT_TRUST_STATUS pTrustStatus
     )
{
    CertPerfIncrementChainRevocationCount();

    if (ERROR_SUCCESS == pRevStatus->dwError) {
        ;
    } else if (CRYPT_E_REVOKED == pRevStatus->dwError) {
        pTrustStatus->dwErrorStatus |= CERT_TRUST_IS_REVOKED;
        CertPerfIncrementChainRevokedCount();
    } else {
        pTrustStatus->dwErrorStatus |= CERT_TRUST_REVOCATION_STATUS_UNKNOWN;
        if (CRYPT_E_NO_REVOCATION_CHECK == pRevStatus->dwError) {
            CertPerfIncrementChainNoRevocationCheckCount();
        } else {
            pTrustStatus->dwErrorStatus |= CERT_TRUST_IS_OFFLINE_REVOCATION;
            CertPerfIncrementChainRevocationOfflineCount();
        }
    }

    pRevocationInfo->cbSize = sizeof(CERT_REVOCATION_INFO);
    pRevocationInfo->dwRevocationResult = pRevStatus->dwError;
    pRevocationInfo->fHasFreshnessTime = pRevStatus->fHasFreshnessTime;
    pRevocationInfo->dwFreshnessTime = pRevStatus->dwFreshnessTime;
}


//+===========================================================================
//  CCertChainEngine helper functions
//============================================================================

//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateWorldStore
//
//  Synopsis:   create the world store
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCreateWorldStore (
     IN HCERTSTORE hRoot,
     IN HCERTSTORE hCA,
     IN DWORD cAdditionalStore,
     IN HCERTSTORE* rghAdditionalStore,
     IN DWORD dwStoreFlags,
     OUT HCERTSTORE* phWorld
     )
{
    BOOL       fResult;
    HCERTSTORE hWorld;
    HCERTSTORE hStore;
    DWORD      cCount;

    hWorld = CertOpenStore(
                 CERT_STORE_PROV_COLLECTION,
                 X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                 NULL,
                 CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                 NULL
                 );

    if ( hWorld == NULL )
    {
        return( FALSE );
    }

    fResult = CertAddStoreToCollection( hWorld, hRoot, 0, 0 );

    for ( cCount = 0;
          ( cCount < cAdditionalStore ) && ( fResult == TRUE );
          cCount++ )
    {
        fResult = CertAddStoreToCollection(
                      hWorld,
                      rghAdditionalStore[ cCount ],
                      0,
                      0
                      );
    }

    dwStoreFlags |=
        CERT_STORE_MAXIMUM_ALLOWED_FLAG | CERT_STORE_SHARE_CONTEXT_FLAG;

    if ( fResult == TRUE )
    {
        hStore = CertOpenStore(
                     CERT_STORE_PROV_SYSTEM_W,
                     X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                     NULL,
                     dwStoreFlags,
                     L"trust"
                     );

        if ( hStore != NULL )
        {
            fResult = CertAddStoreToCollection( hWorld, hStore, 0, 0 );
            CertCloseStore( hStore, 0 );
        }
        else
        {
            fResult = FALSE;
        }
    }

    if ( fResult == TRUE )
    {
        if ( hCA != NULL )
        {
            fResult = CertAddStoreToCollection( hWorld, hCA, 0, 0 );
        }
        else
        {
            fResult = FALSE;
        }
    }

    if ( fResult == TRUE )
    {
        hStore = CertOpenStore(
                     CERT_STORE_PROV_SYSTEM_W,
                     X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                     NULL,
                     dwStoreFlags,
                     L"my"
                     );

        if ( hStore != NULL )
        {
            fResult = CertAddStoreToCollection( hWorld, hStore, 0, 0 );
            CertCloseStore( hStore, 0 );
        }
        else
        {
            fResult = FALSE;
        }
    }

    if ( fResult == TRUE )
    {
        *phWorld = hWorld;
    }
    else
    {
        CertCloseStore( hWorld, 0 );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateEngineStore
//
//  Synopsis:   create the engine store and the change event handle
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCreateEngineStore (
     IN HCERTSTORE hRootStore,
     IN HCERTSTORE hTrustStore,
     IN HCERTSTORE hOtherStore,
     IN BOOL fDefaultEngine,
     IN DWORD dwFlags,
     OUT HCERTSTORE* phEngineStore,
     OUT HANDLE* phEngineStoreChangeEvent
     )
{
    BOOL       fResult = TRUE;
    HCERTSTORE hEngineStore;
    HANDLE     hEvent;

    hEngineStore = CertOpenStore(
                       CERT_STORE_PROV_COLLECTION,
                       X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                       NULL,
                       CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                       NULL
                       );

    hEvent = CreateEventA( NULL, FALSE, FALSE, NULL );

    if ( ( hEngineStore == NULL ) || ( hEvent == NULL ) )
    {
        fResult = FALSE;
    }

    if ( fResult == TRUE )
    {
        fResult = CertAddStoreToCollection( hEngineStore, hRootStore, 0, 0 );
    }

    if ( fResult == TRUE )
    {
        fResult = CertAddStoreToCollection( hEngineStore, hTrustStore, 0, 0 );
    }

    if ( fResult == TRUE )
    {
        fResult = CertAddStoreToCollection( hEngineStore, hOtherStore, 0, 0 );
    }

    if ( ( fResult == TRUE ) &&
         ( dwFlags & CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE ) )
    {
        // Someday support a let me know about errors flag
        CertControlStore(
            hEngineStore,
            CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG,
            CERT_STORE_CTRL_NOTIFY_CHANGE,
            &hEvent
            );
    }

    if ( fResult == TRUE )
    {
        *phEngineStore = hEngineStore;
        *phEngineStoreChangeEvent = hEvent;
    }
    else
    {
        if ( hEngineStore != NULL )
        {
            CertCloseStore( hEngineStore, 0 );
        }

        if ( hEvent != NULL )
        {
            CloseHandle( hEvent );
        }
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainIsProperRestrictedRoot
//
//  Synopsis:   check to see if this restricted root store is a proper subset
//              of the real root store
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainIsProperRestrictedRoot (
     IN HCERTSTORE hRealRoot,
     IN HCERTSTORE hRestrictedRoot
     )
{
    PCCERT_CONTEXT  pCertContext = NULL;
    PCCERT_CONTEXT  pFound = NULL;
    DWORD           cbData = CHAINHASHLEN;
    BYTE            CertificateHash[ CHAINHASHLEN ];
    CRYPT_HASH_BLOB HashBlob;

    HashBlob.cbData = cbData;
    HashBlob.pbData = CertificateHash;

    while ( ( pCertContext = CertEnumCertificatesInStore(
                                 hRestrictedRoot,
                                 pCertContext
                                 ) ) != NULL )
    {
        if ( CertGetCertificateContextProperty(
                 pCertContext,
                 CERT_MD5_HASH_PROP_ID,
                 CertificateHash,
                 &cbData
                 ) == TRUE )
        {
            pFound = CertFindCertificateInStore(
                         hRealRoot,
                         X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                         0,
                         CERT_FIND_MD5_HASH,
                         &HashBlob,
                         NULL
                         );

            if ( pFound == NULL )
            {
                CertFreeCertificateContext( pCertContext );
                return( FALSE );
            }
            else
            {
                CertFreeCertificateContext( pFound );
            }
        }
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateCollectionIncludingCtlCertificates
//
//  Synopsis:   create a collection which includes the source store hStore and
//              any CTL certificates from it
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCreateCollectionIncludingCtlCertificates (
     IN HCERTSTORE hStore,
     OUT HCERTSTORE* phCollection
     )
{
    BOOL          fResult = FALSE;
    HCERTSTORE    hCollection;
    PCCTL_CONTEXT pCtlContext = NULL;
    HCERTSTORE    hCtlStore;

    hCollection = CertOpenStore(
                      CERT_STORE_PROV_COLLECTION,
                      X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                      NULL,
                      CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                      NULL
                      );

    if ( hCollection == NULL )
    {
        return( FALSE );
    }

    fResult = CertAddStoreToCollection( hCollection, hStore, 0, 0 );

    while ( ( fResult == TRUE ) &&
            ( ( pCtlContext = CertEnumCTLsInStore(
                                  hStore,
                                  pCtlContext
                                  ) ) != NULL ) )
    {
        hCtlStore = CertOpenStore(
                        CERT_STORE_PROV_MSG,
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        NULL,
                        0,
                        pCtlContext->hCryptMsg
                        );

        if ( hCtlStore != NULL )
        {
            fResult = CertAddStoreToCollection(
                          hCollection,
                          hCtlStore,
                          0,
                          0
                          );

            CertCloseStore( hCtlStore, 0 );
        }
    }

    if ( fResult == TRUE )
    {
        *phCollection = hCollection;
    }
    else
    {
        CertCloseStore( hCollection, 0 );
    }

    return( fResult );
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainCopyToCAStore
//
//  Synopsis:   copies the hStore to the m_hCAStore of the engine
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCopyToCAStore (
     PCCERTCHAINENGINE pChainEngine,
     HCERTSTORE hStore
     )
{
    PCCERT_CONTEXT pCertContext = NULL;

    if ( pChainEngine->CAStore() == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return( FALSE );
    }

    while ( ( pCertContext = CertEnumCertificatesInStore(
                                 hStore,
                                 pCertContext
                                 ) ) != NULL )
    {
        // Don't add self signed certificates to the CA store
        if (!CertCompareCertificateName(
                pCertContext->dwCertEncodingType,
                &pCertContext->pCertInfo->Subject,
                &pCertContext->pCertInfo->Issuer
                ))
        {
            CertAddCertificateContextToStore(
                pChainEngine->CAStore(),
                pCertContext,
                CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES,
                NULL
                );
        }
    }

    return( TRUE );
}

//+===========================================================================
//  URL helper functions
//============================================================================

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetObjectUrl
//
//  Synopsis:   thunk to CryptGetObjectUrl in cryptnet.dll
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainGetObjectUrl (
     IN LPCSTR pszUrlOid,
     IN LPVOID pvPara,
     IN DWORD dwFlags,
     OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
     IN OUT DWORD* pcbUrlArray,
     OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
     IN OUT OPTIONAL DWORD* pcbUrlInfo,
     IN OPTIONAL LPVOID pvReserved
     )
{
    BOOL             fResult = FALSE;
    HMODULE          hModule;
    PFN_GETOBJECTURL pfn = NULL;

    hModule = ChainGetCryptnetModule();

    if ( hModule != NULL )
    {
        pfn = (PFN_GETOBJECTURL)GetProcAddress( hModule, "CryptGetObjectUrl" );
    }

    if ( pfn != NULL )
    {
        fResult = ( *pfn )(
                      pszUrlOid,
                      pvPara,
                      dwFlags,
                      pUrlArray,
                      pcbUrlArray,
                      pUrlInfo,
                      pcbUrlInfo,
                      pvReserved
                      );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainRetrieveObjectByUrlW
//
//  Synopsis:   thunk to CryptRetrieveObjectByUrlW in cryptnet.dll
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainRetrieveObjectByUrlW (
     IN LPCWSTR pszUrl,
     IN LPCSTR pszObjectOid,
     IN DWORD dwRetrievalFlags,
     IN DWORD dwTimeout,
     OUT LPVOID* ppvObject,
     IN HCRYPTASYNC hAsyncRetrieve,
     IN PCRYPT_CREDENTIALS pCredentials,
     IN LPVOID pvVerify,
     IN OPTIONAL PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
     )
{
    BOOL                     fResult = FALSE;
    HMODULE                  hModule;
    PFN_RETRIEVEOBJECTBYURLW pfn = NULL;

    hModule = ChainGetCryptnetModule();

    if ( hModule != NULL )
    {
        pfn = (PFN_RETRIEVEOBJECTBYURLW)GetProcAddress(
                                          hModule,
                                          "CryptRetrieveObjectByUrlW"
                                          );
    }

    if ( pfn != NULL )
    {
        fResult = ( *pfn )(
                      pszUrl,
                      pszObjectOid,
                      dwRetrievalFlags,
                      dwTimeout,
                      ppvObject,
                      hAsyncRetrieve,
                      pCredentials,
                      pvVerify,
                      pAuxInfo
                      );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainIsConnected
//
//  Synopsis:   thunk to I_CryptNetIsConnected in cryptnet.dll
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainIsConnected()
{
    BOOL                     fResult = FALSE;
    HMODULE                  hModule;
    PFN_I_CRYPTNET_IS_CONNECTED pfn = NULL;

    hModule = ChainGetCryptnetModule();

    if ( hModule != NULL )
    {
        pfn = (PFN_I_CRYPTNET_IS_CONNECTED)GetProcAddress(
                                          hModule,
                                          "I_CryptNetIsConnected"
                                          );
    }

    if ( pfn != NULL )
    {
        fResult = ( *pfn )();
    }

    return( fResult );
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainGetHostNameFromUrl
//
//  Synopsis:   thunk to I_CryptNetGetHostNameFromUrl in cryptnet.dll
//
//----------------------------------------------------------------------------
BOOL
WINAPI
ChainGetHostNameFromUrl (
        IN LPWSTR pwszUrl,
        IN DWORD cchHostName,
        OUT LPWSTR pwszHostName
        )
{
    BOOL                     fResult = FALSE;
    HMODULE                  hModule;
    PFN_I_CRYPTNET_GET_HOST_NAME_FROM_URL pfn = NULL;

    hModule = ChainGetCryptnetModule();

    if ( hModule != NULL )
    {
        pfn = (PFN_I_CRYPTNET_GET_HOST_NAME_FROM_URL)GetProcAddress(
                                          hModule,
                                          "I_CryptNetGetHostNameFromUrl"
                                          );
    }

    if ( pfn != NULL )
    {
        fResult = ( *pfn )(
            pwszUrl,
            cchHostName,
            pwszHostName
            );
    }

    return( fResult );
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainIsFileOrLdapUrl
//
//  Synopsis:   check if the URL given is a file or ldap one
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainIsFileOrLdapUrl (
     IN LPCWSTR pwszUrl
     )
{
    LPWSTR pwsz;

    pwsz = wcschr( pwszUrl, L':' );
    if ( pwsz != NULL )
    {
        if ( ( _wcsnicmp( pwszUrl, L"file", 4 ) == 0 ) ||
             ( _wcsnicmp( pwszUrl, L"ldap", 4 ) == 0 ) )
        {
            return( TRUE );
        }
        else
        {
            return( FALSE );
        }
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetOfflineUrlDeltaSeconds
//
//  Synopsis:   given the number of unsuccessful attempts to retrieve the
//              Url, returns the number of seconds to wait before the
//              next attempt.
//
//----------------------------------------------------------------------------

const DWORD rgdwChainOfflineUrlDeltaSeconds[] = {
    15,                 // 15 seconds
    15,                 // 15 seconds
    60,                 // 1 minute
    60 * 5,             // 5 minutes
    60 * 10,            // 10 minutes
    60 * 30,            // 30 minutes
};

#define CHAIN_OFFLINE_URL_DELTA_SECONDS_CNT \
    (sizeof(rgdwChainOfflineUrlDeltaSeconds) / \
        sizeof(rgdwChainOfflineUrlDeltaSeconds[0]))

DWORD
WINAPI
ChainGetOfflineUrlDeltaSeconds (
    IN DWORD dwOfflineCnt
    )
{
    if (0 == dwOfflineCnt)
        return 0;

    if (CHAIN_OFFLINE_URL_DELTA_SECONDS_CNT < dwOfflineCnt)
        dwOfflineCnt = CHAIN_OFFLINE_URL_DELTA_SECONDS_CNT;

    return rgdwChainOfflineUrlDeltaSeconds[dwOfflineCnt - 1];
}

//+===========================================================================
//  AuthRoot Auto Update methods and helper functions
//============================================================================

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::GetAuthRootAutoUpdateUrlStore, public
//
//  Synopsis:   attempts to get a time valid AuthRoot Auto Update CTL.
//              Checks if there is CTL entry matching the subject
//              certificate's AKI exact match, key identifier or name
//              match. For a match URL retrieves the certificate and
//              returns a store containing the retrieved certificates
//
//              Leaves the engine's critical section to do the URL
//              fetching. If the engine was touched by another thread,
//              it fails with LastError set to ERROR_CAN_NOT_COMPLETE.
//
//  Assumption: Chain engine is locked once in the calling thread.
//
//              Only returns FALSE, if the engine was touched when
//              leaving the critical section.
//
//              The caller has already checked that we are online.
//
//----------------------------------------------------------------------------


// CN=Root Agency
const BYTE rgbRootAgencyIssuerName[] = {
    0x30, 0x16,                         // SEQUENCE
    0x31, 0x14,                         //  SET
    0x30, 0x12,                         //   SEQUENCE
    0x06, 0x03, 0x55, 0x04, 0x03,       //    OID
                                        //    PRINTABLE STRING
    0x13, 0x0b, 0x52, 0x6f, 0x6f, 0x74, 0x20,
    0x41, 0x67, 0x65, 0x6e, 0x63, 0x79
};

// CN=Root SGC Authority
const BYTE rgbRootSGCAuthorityIssuerName[] = {
    0x30, 0x1d,                         // SEQUENCE
    0x31, 0x1b,                         //  SET
    0x30, 0x19,                         //   SEQUENCE
    0x06, 0x03, 0x55, 0x04, 0x03,       //    OID
                                        //    PRINTABLE STRING
    0x13, 0x12, 0x52, 0x6f, 0x6f, 0x74, 0x20,
                0x53, 0x47, 0x43, 0x20, 0x41,
                0x75, 0x74, 0x68, 0x6f, 0x72,
                0x69, 0x74, 0x79
};

const CRYPT_DATA_BLOB rgSkipPartialIssuer[] = {
    sizeof(rgbRootAgencyIssuerName), (BYTE *) rgbRootAgencyIssuerName,
    sizeof(rgbRootSGCAuthorityIssuerName), (BYTE *) rgbRootSGCAuthorityIssuerName
};
#define SKIP_PARTIAL_ISSUER_CNT     (sizeof(rgSkipPartialIssuer)/ \
                                        sizeof(rgSkipPartialIssuer[0]))



BOOL
CChainPathObject::GetAuthRootAutoUpdateUrlStore(
    IN PCCHAINCALLCONTEXT pCallContext,
    OUT HCERTSTORE *phIssuerUrlStore
    )
{
    BOOL fTouchedResult = TRUE;
    PCCERTCHAINENGINE pChainEngine = pCallContext->ChainEngine();
    PCERT_INFO pCertInfo = m_pCertObject->CertContext()->pCertInfo;
    PCCTL_CONTEXT pCtl = NULL;
    HCERTSTORE hIssuerUrlStore = NULL;

    CRYPT_DATA_BLOB rgAuthRootMatchHash[AUTH_ROOT_MATCH_CNT];
    DWORD cEntry = 0;
    PCTL_ENTRY *rgpEntry = NULL;
    PCCERT_CONTEXT pCert;
    DWORD cCert;
    DWORD i;

    *phIssuerUrlStore = NULL;

    // Loop and skip known issuers such as, "Root Agency". Don't want all
    // clients in the world hiting the wire when building these chains
    for (i = 0; i < SKIP_PARTIAL_ISSUER_CNT; i++) {
        if (pCertInfo->Issuer.cbData == rgSkipPartialIssuer[i].cbData &&
            0 == memcmp(pCertInfo->Issuer.pbData, 
                    rgSkipPartialIssuer[i].pbData,
                    rgSkipPartialIssuer[i].cbData))
            return TRUE;
    }
    
    fTouchedResult = pChainEngine->GetAuthRootAutoUpdateCtl(
        pCallContext,
        &pCtl
        );

    if (!fTouchedResult || NULL == pCtl) {

#if 0
// This logs too many test failures

        if (fTouchedResult) {
            PAUTH_ROOT_AUTO_UPDATE_INFO pInfo =
                pChainEngine->AuthRootAutoUpdateInfo();

            if (NULL == pInfo || !(pInfo->dwFlags &
                    CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_PARTIAL_CHAIN_LOGGING_FLAG))
                IPR_LogCertInformation(
                    MSG_PARTIAL_CHAIN_INFORMATIONAL,
                    m_pCertObject->CertContext(),
                    TRUE        // fFormatIssuerName
                    );
        }
#endif

        return fTouchedResult;
    }

    // We have a valid AuthRoot Auto Update CTL.
    // See if we can find any matching AuthRoots

    memset(rgAuthRootMatchHash, 0, sizeof(rgAuthRootMatchHash));

    m_pCertObject->GetIssuerKeyMatchHash(
        &rgAuthRootMatchHash[AUTH_ROOT_KEY_MATCH_IDX]);
    m_pCertObject->GetIssuerNameMatchHash(
        &rgAuthRootMatchHash[AUTH_ROOT_NAME_MATCH_IDX]);

    pChainEngine->FindAuthRootAutoUpdateMatchingCtlEntries(
        rgAuthRootMatchHash,
        &pCtl,
        &cEntry,
        &rgpEntry
        );

    if (0 == cEntry) {

#if 0
// This logs too many test failures

        PAUTH_ROOT_AUTO_UPDATE_INFO pInfo =
            pChainEngine->AuthRootAutoUpdateInfo();

        if (NULL == pInfo || !(pInfo->dwFlags &
                CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_PARTIAL_CHAIN_LOGGING_FLAG))
            IPR_LogCertInformation(
                MSG_PARTIAL_CHAIN_INFORMATIONAL,
                m_pCertObject->CertContext(),
                TRUE        // fFormatIssuerName
                );
#endif

        goto NoAutoUpdateCtlEntry;
    }

    hIssuerUrlStore = CertOpenStore(
        CERT_STORE_PROV_MEMORY,
        0,                          // dwEncodingType
        NULL,                       // hCryptProv
        0,                          // dwFlags
        NULL                        // pvPara
        );
    if (NULL == hIssuerUrlStore)
        goto OpenMemoryStoreError;

    for (i = 0; i < cEntry; i++) {
        PCTL_ENTRY pEntry = rgpEntry[i];

        // If already in our store, no need to hit the wire and retrieve.
        if (pCert = CertFindCertificateInStore(
                pChainEngine->OtherStore(),
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                0,
                CERT_FIND_SHA1_HASH,
                (LPVOID) &pEntry->SubjectIdentifier,
                NULL
                )) {
            CertFreeCertificateContext(pCert);
            continue;
        }

        fTouchedResult = pChainEngine->GetAuthRootAutoUpdateCert(
            pCallContext,
            pEntry,
            hIssuerUrlStore
            );

        if (!fTouchedResult)
            goto TouchedDuringUrlRetrievalOfAuthRoots;
    }

    pCert = NULL;
    cCert = 0;
    while (pCert = CertEnumCertificatesInStore(hIssuerUrlStore, pCert))
        cCert++;

    if (0 == cCert)
        goto NoAuthRootAutoUpdateCerts;

    if (1 < cCert) {
        // If more than one root in the list, explicitly add them all here. 
        // While building the chain using the returned AuthRoots we might
        // leave the critical section and restart. After restarting may
        // have a trusted root and won't redo this URL retrieval.

        pChainEngine->UnlockEngine();

        pCert = NULL;
        while (pCert = CertEnumCertificatesInStore(hIssuerUrlStore, pCert))
            IPR_AddCertInAuthRootAutoUpdateCtl(pCert, pCtl);

        pChainEngine->LockEngine();
        if (pCallContext->IsTouchedEngine()) {
            fTouchedResult = FALSE;
            goto TouchedDuringAddOfAuthRoots;
        }
    }

    *phIssuerUrlStore = hIssuerUrlStore;
    
CommonReturn:
    if (rgpEntry)
        PkiFree(rgpEntry);
    if (pCtl)
        CertFreeCTLContext(pCtl);

    return fTouchedResult;
ErrorReturn:
    if (hIssuerUrlStore)
        CertCloseStore(hIssuerUrlStore, 0);
    goto CommonReturn;

TRACE_ERROR(NoAutoUpdateCtlEntry)
TRACE_ERROR(OpenMemoryStoreError)
TRACE_ERROR(TouchedDuringUrlRetrievalOfAuthRoots)
TRACE_ERROR(NoAuthRootAutoUpdateCerts)
TRACE_ERROR(TouchedDuringAddOfAuthRoots)
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::RetrieveAuthRootAutoUpdateObjectByUrlW, public
//
//  Synopsis:   URL retrieves an AuthRoot Auto Update object. For wire
//              retrieval, logs the event.
//
//              Leaves the engine's critical section to do the URL
//              fetching. If the engine was touched by another thread,
//              it fails with LastError set to ERROR_CAN_NOT_COMPLETE.
//
//  Assumption: Chain engine is locked once in the calling thread.
//
//              If the object was successfully retrieved,
//              *ppvObject != NULL. Otherwise, *ppvObject = NULL.
//
//              Only returns FALSE, if the engine was touched when
//              leaving the critical section. *ppvObject may be != NULL
//              when touched.
//
//----------------------------------------------------------------------------
BOOL
CCertChainEngine::RetrieveAuthRootAutoUpdateObjectByUrlW(
    IN PCCHAINCALLCONTEXT pCallContext,
    IN DWORD dwSuccessEventID,
    IN DWORD dwFailEventID,
    IN LPCWSTR pwszUrl,
    IN LPCSTR pszObjectOid,
    IN DWORD dwRetrievalFlags,
    IN DWORD dwTimeout,         // 0 => use default
    OUT LPVOID* ppvObject,
    IN OPTIONAL PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
    )
{
    BOOL fTouchedResult = TRUE;
    BOOL fResult;

    *ppvObject = NULL;
    if (0 == dwTimeout)
        dwTimeout = pCallContext->ChainPara()->dwUrlRetrievalTimeout;

    //
    // We are about to go on the wire to retrieve the object.
    // At this time we will release the chain engine lock so others can
    // go about there business while we wait for the protocols to do the
    // fetching.
    //

    UnlockEngine();

    // Note, the windows update server doesn't require authentication.
    // wininet sometimes calls us within a critical section. NO_AUTH
    // normally will fix this deadlock.
    //
    // On 09-May-01 the above was fixed by wininet.
    // Removed setting CRYPT_NO_AUTH_RETRIEVAL.
    //
    // Authentication may be required by a proxy.
    fResult = ChainRetrieveObjectByUrlW(
        pwszUrl,
        pszObjectOid,
        dwRetrievalFlags,
        dwTimeout,
        ppvObject,
        NULL,                               // hAsyncRetrieve
        NULL,                               // pCredentials
        NULL,                               // pvVerify
        pAuxInfo
        );

    if (dwRetrievalFlags & CRYPT_WIRE_ONLY_RETRIEVAL) {
        // Only log wire retrievals

        if (fResult) {
            LPCWSTR rgpwszStrings[1] = { pwszUrl };

            IPR_LogCrypt32Event(
                EVENTLOG_INFORMATION_TYPE,
                dwSuccessEventID,
                1,          // wNumStrings
                rgpwszStrings
                );
        } else
            IPR_LogCrypt32Error(
                dwFailEventID,
                pwszUrl,
                GetLastError()
                );
    }

    LockEngine();

    if (pCallContext->IsTouchedEngine()) {
        fTouchedResult = FALSE;
        goto TouchedDuringAuthRootObjectUrlRetrieval;
    }

    if (fResult)
        assert(*ppvObject);
    else
        assert(NULL == *ppvObject);

CommonReturn:
    return fTouchedResult;
ErrorReturn:
    goto CommonReturn;

SET_ERROR(TouchedDuringAuthRootObjectUrlRetrieval, ERROR_CAN_NOT_COMPLETE)
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::GetAuthRootAutoUpdateCtl, public
//
//  Synopsis:   if auto update hasn't been disabled,
//              returns the AuthRoot Auto Update CTL. Hits the wire
//              if necessary to get a "fresh" CTL.
//
//              Note, 2 URL fetches. One for the SequenceNumber file. The
//              other for the CTL cab file. The SequenceNumber file
//              is small and bounded in size. If it matches the SequenceNumber
//              in an already retrieved CTL, then, no need to hit the
//              wire to retrive the larger CTL file. This optimization will
//              reduce the number of bytes needing to be fetched across the
//              wire. The CTL won't be updated that often.
//
//              Leaves the engine's critical section to do the URL
//              fetching. If the engine was touched by another thread,
//              it fails with LastError set to ERROR_CAN_NOT_COMPLETE.
//
//  Assumption: Chain engine is locked once in the calling thread.
//
//              If auto update has been disabled, returns TRUE and
//              *ppCtl = NULL.
//
//              Only returns FALSE, if the engine was touched when
//              leaving the critical section.
//
//              The returned pCtl is AddRef'ed.
//
//----------------------------------------------------------------------------
BOOL
CCertChainEngine::GetAuthRootAutoUpdateCtl(
    IN PCCHAINCALLCONTEXT pCallContext,
    OUT PCCTL_CONTEXT *ppCtl
    )
{
    BOOL fTouchedResult = TRUE;
    FILETIME CurrentTime;
    PAUTH_ROOT_AUTO_UPDATE_INFO pInfo;
    PCRYPT_BLOB_ARRAY pcbaSeq = NULL;
    PCRYPT_BLOB_ARRAY pcbaCab = NULL;
    PCCTL_CONTEXT pNewCtl = NULL;
    CRYPT_RETRIEVE_AUX_INFO RetrieveAuxInfo;
    DWORD i;

    *ppCtl = NULL;

    if ((pCallContext->CallOrEngineFlags() &
                CERT_CHAIN_DISABLE_AUTH_ROOT_AUTO_UPDATE) ||
            IPR_IsAuthRootAutoUpdateDisabled())
        return TRUE;

    if (NULL == (pInfo = m_pAuthRootAutoUpdateInfo)) {
        if (NULL == (pInfo = CreateAuthRootAutoUpdateInfo()))
            return TRUE;
        m_pAuthRootAutoUpdateInfo = pInfo;
    }

    pCallContext->CurrentTime(&CurrentTime);

    memset(&RetrieveAuxInfo, 0, sizeof(RetrieveAuxInfo));
    RetrieveAuxInfo.cbSize = sizeof(RetrieveAuxInfo);

    // First try the cache. If unable to retrieve the seq file or
    // find a time valid CTL cab in the cache, hit the wire.
    for (i = 0; i <= 1; i++) {
        BOOL fResult;
        DWORD dwRetrievalFlags;
        DWORD dwCtlTimeout = 0;
        PCRYPT_INTEGER_BLOB pSequenceNumber;
        FILETIME NewLastSyncTime;
        FILETIME CtlLastSyncTime;
        PCTL_INFO pNewCtlInfo;

        if (pInfo->pCtl &&
                0 < CompareFileTime(&pInfo->NextSyncTime, &CurrentTime))
            // We already have a time valid CTL
            break;

        if (0 == i)
            dwRetrievalFlags = CRYPT_CACHE_ONLY_RETRIEVAL;
        else {
            if (!pCallContext->IsOnline())
                break;
            dwRetrievalFlags = CRYPT_WIRE_ONLY_RETRIEVAL;
        }

        // First try to fetch the CTL's sequence number file
        RetrieveAuxInfo.pLastSyncTime = &NewLastSyncTime;
        fTouchedResult = RetrieveAuthRootAutoUpdateObjectByUrlW(
            pCallContext,
            MSG_ROOT_SEQUENCE_NUMBER_AUTO_UPDATE_URL_RETRIEVAL_INFORMATIONAL,
            MSG_ROOT_SEQUENCE_NUMBER_AUTO_UPDATE_URL_RETRIEVAL_ERROR,
            pInfo->pwszSeqUrl,
            NULL,                   // pszObjectOid,
            dwRetrievalFlags |
                CRYPT_OFFLINE_CHECK_RETRIEVAL |
                CRYPT_STICKY_CACHE_RETRIEVAL,
            0,                      // dwTimeout (use default)
            (LPVOID*) &pcbaSeq,
            &RetrieveAuxInfo
            );
        if (!fTouchedResult)
            goto TouchedDuringAuthRootSeqUrlRetrieval;

        pSequenceNumber = NULL;
        if (NULL == pcbaSeq) {
            // SequenceNumber retrieval failed

            if (0 != i)
                // For wire retrieval failure, don't try to fetch the CTL
                continue;
        } else if (0 > CompareFileTime(&NewLastSyncTime,
                &pInfo->LastSyncTime)) {
            // An older sync time
            CryptMemFree(pcbaSeq);
            pcbaSeq = NULL;
        } else {
            // Extract the Sequence Number from the retrieved blob.
            // Convert the ascii hex characters to binary. Overwrite
            // the ascii hex with the converted bytes.
            // Convert binary to little endian.
            DWORD cchSeq;
            BOOL fUpperNibble = TRUE;
            DWORD cb = 0;
            DWORD j;

            pSequenceNumber = pcbaSeq->rgBlob;
            if (0 == pcbaSeq->cBlob)
                cchSeq = 0;
            else
                cchSeq = pSequenceNumber->cbData;

            for (j = 0; j < cchSeq; j++) {
                char ch = (char) pSequenceNumber->pbData[j];
                BYTE b;

                // only convert ascii hex characters 0..9, a..f, A..F
                // silently ignore all others
                if (ch >= '0' && ch <= '9')
                    b = (BYTE) (ch - '0');
                else if (ch >= 'a' && ch <= 'f')
                    b = (BYTE) (10 + ch - 'a');
                else if (ch >= 'A' && ch <= 'F')
                    b = (BYTE) (10 + ch - 'A');
                else
                    continue;
        
                if (fUpperNibble) {
                    pSequenceNumber->pbData[cb] = b << 4;
                    fUpperNibble = FALSE;
                } else {
                    pSequenceNumber->pbData[cb] |= b;
                    cb++;
                    fUpperNibble = TRUE;
                }
            }

            if (0 == cb) {
                // Empty sequence number.
                CryptMemFree(pcbaSeq);
                pcbaSeq = NULL;
            } else {
                pSequenceNumber->cbData = cb;

                PkiAsn1ReverseBytes(pSequenceNumber->pbData,
                    pSequenceNumber->cbData);

                // Check if we already have a CTL corresponding to this
                // fetched SequenceNumber
                if (pInfo->pCtl) {
                    PCTL_INFO pCtlInfo = pInfo->pCtl->pCtlInfo;

                    if (pCtlInfo->SequenceNumber.cbData ==
                            pSequenceNumber->cbData &&
                        0 == memcmp(pCtlInfo->SequenceNumber.pbData,
                                pSequenceNumber->pbData,
                                pSequenceNumber->cbData)) {
                        // Same CTL
                        pInfo->LastSyncTime = NewLastSyncTime;
                        I_CryptIncrementFileTimeBySeconds(
                            &pInfo->LastSyncTime,
                            pInfo->dwSyncDeltaTime,
                            &pInfo->NextSyncTime
                            );

                        CryptMemFree(pcbaSeq);
                        pcbaSeq = NULL;
                        continue;
                    }
                }

                // The SequenceNumber consists of the FILETIME followed by
                // an optional byte containing a hint for the CTL URL
                // retrieval timeout (in seconds). If we are using the
                // default retrieval timeout, use the hint if it exceeds
                // the default timeout.
                if (sizeof(FILETIME) < cb &&
                        pCallContext->HasDefaultUrlRetrievalTimeout()) {
                    dwCtlTimeout =
                        ((DWORD) pSequenceNumber->pbData[sizeof(FILETIME)]) *
                            1000;
                    if (dwCtlTimeout <
                            pCallContext->ChainPara()->dwUrlRetrievalTimeout)
                        dwCtlTimeout =
                            pCallContext->ChainPara()->dwUrlRetrievalTimeout;
                }
            }
        }

        // After retrieving the sequence number file, now
        // try to fetch the cab containing the CTL
        RetrieveAuxInfo.pLastSyncTime = &CtlLastSyncTime;
        fTouchedResult = RetrieveAuthRootAutoUpdateObjectByUrlW(
            pCallContext,
            MSG_ROOT_LIST_AUTO_UPDATE_URL_RETRIEVAL_INFORMATIONAL,
            MSG_ROOT_LIST_AUTO_UPDATE_URL_RETRIEVAL_ERROR,
            pInfo->pwszCabUrl,
            NULL,                   // pszObjectOid,
            dwRetrievalFlags |
                CRYPT_OFFLINE_CHECK_RETRIEVAL |
                CRYPT_STICKY_CACHE_RETRIEVAL,
            dwCtlTimeout,
            (LPVOID*) &pcbaCab,
            &RetrieveAuxInfo
            );
        if (!fTouchedResult)
            goto TouchedDuringAuthRootCabUrlRetrieval;

        if (NULL == pcbaCab) {
            // Cab Retrieval failed
            if (pcbaSeq) {
                CryptMemFree(pcbaSeq);
                pcbaSeq = NULL;
            }
            continue;
        }

        // Leave the engine to extract the CTL from the cab
        UnlockEngine();

        pNewCtl = ExtractAuthRootAutoUpdateCtlFromCab(pcbaCab);
        if (NULL == pNewCtl)
            IPR_LogCrypt32Error(
                MSG_ROOT_LIST_AUTO_UPDATE_EXTRACT_ERROR,
                pInfo->pwszCabUrl,
                GetLastError()
                );

        CryptMemFree(pcbaCab);
        pcbaCab = NULL;

        LockEngine();

        if (pCallContext->IsTouchedEngine()) {
            fTouchedResult = FALSE;
            goto TouchedDuringExtractAuthRootCtl;
        }

        if (NULL == pNewCtl) {
            // Ctl Extraction failed
            if (pcbaSeq) {
                CryptMemFree(pcbaSeq);
                pcbaSeq = NULL;
            }
            continue;
        }

        // If the SequenceNumber is the same as the one in the retrieved
        // Ctl, then, use the lastest sync of the 2 URL fetches. Otherwise,
        // use the Ctl sync time
        pNewCtlInfo = pNewCtl->pCtlInfo;
        if (NULL == pcbaSeq ||
                pNewCtlInfo->SequenceNumber.cbData != pSequenceNumber->cbData ||
                0 != memcmp(pNewCtlInfo->SequenceNumber.pbData,
                    pSequenceNumber->pbData, pSequenceNumber->cbData)
                            ||
                0 < CompareFileTime(&CtlLastSyncTime, &NewLastSyncTime))
            NewLastSyncTime = CtlLastSyncTime;

        // We are done with the SequenceNumber info
        if (pcbaSeq) {
            CryptMemFree(pcbaSeq);
            pcbaSeq = NULL;
        }

        if (0 >= CompareFileTime(&NewLastSyncTime, &pInfo->LastSyncTime)) {
            // Not a newer sync
            CertFreeCTLContext(pNewCtl);
            pNewCtl = NULL;
            continue;
        }
            
        if (pInfo->pCtl &&
                pInfo->pCtl->cbCtlEncoded == pNewCtl->cbCtlEncoded &&
                0 == memcmp(pInfo->pCtl->pbCtlEncoded,
                    pNewCtl->pbCtlEncoded, pNewCtl->cbCtlEncoded)) {
            // Same CTL
            pInfo->LastSyncTime = NewLastSyncTime;
            I_CryptIncrementFileTimeBySeconds(
                &pInfo->LastSyncTime,
                pInfo->dwSyncDeltaTime,
                &pInfo->NextSyncTime
            );

            CertFreeCTLContext(pNewCtl);
            pNewCtl = NULL;
            continue;
        }

        // Leave the engine to verify the CTL
        UnlockEngine();
        fResult = IRL_VerifyAuthRootAutoUpdateCtl(pNewCtl);
        if (!fResult)
            IPR_LogCrypt32Error(
                MSG_ROOT_LIST_AUTO_UPDATE_EXTRACT_ERROR,
                pInfo->pwszCabUrl,
                GetLastError()
                );
        LockEngine();

        if (fResult &&
                0 < CompareFileTime(&NewLastSyncTime, &pInfo->LastSyncTime)) {
            // Valid CTL that is newer

            pInfo->LastSyncTime = NewLastSyncTime;
            I_CryptIncrementFileTimeBySeconds(
                &pInfo->LastSyncTime,
                pInfo->dwSyncDeltaTime,
                &pInfo->NextSyncTime
            );

            FreeAuthRootAutoUpdateMatchCaches(pInfo->rghMatchCache);
            if (pInfo->pCtl)
                CertFreeCTLContext(pInfo->pCtl);
            pInfo->pCtl = pNewCtl;
            pNewCtl = NULL;
        }

        if (pCallContext->IsTouchedEngine()) {
            fTouchedResult = FALSE;
            goto TouchedDuringVerifyAuthRootCtl;
        }
    }

    if (pInfo->pCtl)
        *ppCtl = CertDuplicateCTLContext(pInfo->pCtl);

CommonReturn:
    if (pcbaSeq)
        CryptMemFree(pcbaSeq);
    if (pcbaCab)
        CryptMemFree(pcbaCab);
    if (pNewCtl)
        CertFreeCTLContext(pNewCtl);
    return fTouchedResult;
ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(TouchedDuringAuthRootSeqUrlRetrieval)
TRACE_ERROR(TouchedDuringAuthRootCabUrlRetrieval)
SET_ERROR(TouchedDuringExtractAuthRootCtl, ERROR_CAN_NOT_COMPLETE)
SET_ERROR(TouchedDuringVerifyAuthRootCtl, ERROR_CAN_NOT_COMPLETE)
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::FindAuthRootAutoUpdateMatchingCtlEntries, public
//
//  Synopsis:   If the CTL hash match cache doesn't exist its created.
//              Iterates through the key and name hash cache entries.
//              Returns matching entries. Removes duplicates.
//              
//  Assumption: Chain engine is locked once in the calling thread.
//
//              The returned prgpCtlEntry must be PkiFree()'ed.
//
//              Note, if the engine's pCtl is different then the passed in
//              pCtl, the passed in pCtl is free'ed and updated with the
//              engine's.
//
//----------------------------------------------------------------------------
VOID
CCertChainEngine::FindAuthRootAutoUpdateMatchingCtlEntries(
    IN CRYPT_DATA_BLOB rgMatchHash[AUTH_ROOT_MATCH_CNT],
    IN OUT PCCTL_CONTEXT *ppCtl,
    OUT DWORD *pcCtlEntry,
    OUT PCTL_ENTRY **prgpCtlEntry
    )
{
    PAUTH_ROOT_AUTO_UPDATE_INFO pInfo;
    PCCTL_CONTEXT pCtl;
    DWORD cCtlEntry = 0;
    PCTL_ENTRY *rgpCtlEntry = NULL;
    DWORD i;

    pInfo = m_pAuthRootAutoUpdateInfo;
    if (NULL == pInfo || NULL == pInfo->pCtl)
        goto InvalidCtl;

    pCtl = *ppCtl;
    if (pCtl != pInfo->pCtl) {
        assert(pCtl);
        CertFreeCTLContext(pCtl);
        *ppCtl = pCtl = pInfo->pCtl;
        CertDuplicateCTLContext(pCtl);
    }

    if (!CreateAuthRootAutoUpdateMatchCaches(
            pCtl,
            pInfo->rghMatchCache
            ))
        goto CreateMatchCachesError;

    assert(pInfo->rghMatchCache[0]);
    assert(pInfo->rghMatchCache[AUTH_ROOT_MATCH_CNT - 1]);

    // Loop through the exact, key and name match hashes and try to find an
    // entry in the corresponding CTL match cache
    for (i = 0; i < AUTH_ROOT_MATCH_CNT; i++) {
        HLRUENTRY hEntry;

        if (0 == rgMatchHash[i].cbData)
            continue;

        hEntry = I_CryptFindLruEntry(pInfo->rghMatchCache[i], &rgMatchHash[i]);
        while (NULL != hEntry) {
            PCTL_ENTRY pCtlEntry;
            PCTL_ENTRY *rgpNewCtlEntry;
            DWORD j;

            pCtlEntry = (PCTL_ENTRY) I_CryptGetLruEntryData(hEntry);
            hEntry = I_CryptEnumMatchingLruEntries(hEntry);

            assert(pCtlEntry);
            if (NULL == pCtlEntry)
                continue;

            // Check if we already have this Ctl Entry
            for (j = 0; j < cCtlEntry; j++) {
                if (pCtlEntry == rgpCtlEntry[j])
                    break;
            }

            if (j < cCtlEntry)
                continue;
            
            if (NULL == (rgpNewCtlEntry = (PCTL_ENTRY *) PkiRealloc(
                    rgpCtlEntry, (cCtlEntry + 1) * sizeof(PCTL_ENTRY))))
                continue;

            rgpCtlEntry = rgpNewCtlEntry;
            rgpCtlEntry[cCtlEntry++] = pCtlEntry;
        }
    }

CommonReturn:
    *pcCtlEntry = cCtlEntry;
    *prgpCtlEntry = rgpCtlEntry;
    return;
ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(InvalidCtl)
TRACE_ERROR(CreateMatchCachesError)
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::GetAuthRootAutoUpdateCert, public
//
//  Synopsis:   URL retrieval of the AuthRoot from the Microsoft web
//              server.
//
//              Leaves the engine's critical section to do the URL
//              fetching. If the engine was touched by another thread,
//              it fails with LastError set to ERROR_CAN_NOT_COMPLETE.
//
//  Assumption: Chain engine is locked once in the calling thread.
//
//              Only returns FALSE, if the engine was touched when
//              leaving the critical section.
//
//----------------------------------------------------------------------------
BOOL
CCertChainEngine::GetAuthRootAutoUpdateCert(
    IN PCCHAINCALLCONTEXT pCallContext,
    IN PCTL_ENTRY pCtlEntry,
    IN OUT HCERTSTORE hStore
    )
{
    BOOL fTouchedResult = TRUE;
    LPWSTR pwszCertUrl = NULL;
    HCERTSTORE hUrlStore = NULL;

    assert(m_pAuthRootAutoUpdateInfo);

    if (SHA1_HASH_LEN != pCtlEntry->SubjectIdentifier.cbData)
        goto InvalidCtlEntryError;

    if (NULL == (pwszCertUrl = FormatAuthRootAutoUpdateCertUrl(
            pCtlEntry->SubjectIdentifier.pbData,
            m_pAuthRootAutoUpdateInfo
            )))
        goto FormatCertUrlError;

    fTouchedResult = RetrieveAuthRootAutoUpdateObjectByUrlW(
        pCallContext,
        MSG_ROOT_CERT_AUTO_UPDATE_URL_RETRIEVAL_INFORMATIONAL,
        MSG_ROOT_CERT_AUTO_UPDATE_URL_RETRIEVAL_ERROR,
        pwszCertUrl,
        CONTEXT_OID_CERTIFICATE,
        CRYPT_RETRIEVE_MULTIPLE_OBJECTS |
            CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL |
            CRYPT_OFFLINE_CHECK_RETRIEVAL |
            CRYPT_WIRE_ONLY_RETRIEVAL |
            CRYPT_DONT_CACHE_RESULT,
        0,              // dwTimeout (use default)
        (LPVOID *) &hUrlStore,
        NULL                                // pAuxInfo
        );
    if (!fTouchedResult)
        goto TouchedDuringAuthRootCertUrlRetrieval;

    if (hUrlStore)
        I_CertUpdateStore(hStore, hUrlStore, 0, NULL);

CommonReturn:
    PkiFree(pwszCertUrl);
    if (hUrlStore)
        CertCloseStore(hUrlStore, 0);
    return fTouchedResult;
ErrorReturn:
    goto CommonReturn;
SET_ERROR(InvalidCtlEntryError, ERROR_INVALID_DATA)
TRACE_ERROR(FormatCertUrlError)
TRACE_ERROR(TouchedDuringAuthRootCertUrlRetrieval)
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateAuthRootAutoUpdateInfo
//
//  Synopsis:   creates and initializes the AuthRoot Auto Update info
//
//----------------------------------------------------------------------------
PAUTH_ROOT_AUTO_UPDATE_INFO WINAPI
CreateAuthRootAutoUpdateInfo()
{
    HKEY hKey = NULL;
    PAUTH_ROOT_AUTO_UPDATE_INFO pInfo = NULL;
    DWORD cchDir;
    DWORD cchUrl;

    if (NULL == (pInfo = (PAUTH_ROOT_AUTO_UPDATE_INFO) PkiZeroAlloc(
            sizeof(AUTH_ROOT_AUTO_UPDATE_INFO))))
        goto OutOfMemory;

    if (ERROR_SUCCESS != RegOpenKeyExU(
            HKEY_LOCAL_MACHINE,
            CERT_AUTH_ROOT_AUTO_UPDATE_LOCAL_MACHINE_REGPATH,
            0,                      // dwReserved
            KEY_READ,
            &hKey
            ))
        hKey = NULL;

    if (hKey) {
        // Attempt to get values from registry

        ILS_ReadDWORDValueFromRegistry(
            hKey,
            CERT_AUTH_ROOT_AUTO_UPDATE_SYNC_DELTA_TIME_VALUE_NAME,
            &pInfo->dwSyncDeltaTime
            );

        ILS_ReadDWORDValueFromRegistry(
            hKey,
            CERT_AUTH_ROOT_AUTO_UPDATE_FLAGS_VALUE_NAME,
            &pInfo->dwFlags
            );

        pInfo->pwszRootDirUrl = ILS_ReadSZValueFromRegistry(
            hKey,
            CERT_AUTH_ROOT_AUTO_UPDATE_ROOT_DIR_URL_VALUE_NAME
            );
        if (pInfo->pwszRootDirUrl && L'\0' == *pInfo->pwszRootDirUrl) {
            PkiFree(pInfo->pwszRootDirUrl);
            pInfo->pwszRootDirUrl = NULL;
        }
    }

    // If not defined in registry, use our defaults

    if (0 == pInfo->dwSyncDeltaTime)
        pInfo->dwSyncDeltaTime = AUTH_ROOT_AUTO_UPDATE_SYNC_DELTA_TIME;

    if (NULL == pInfo->pwszRootDirUrl) {
        if (NULL == (pInfo->pwszRootDirUrl = ILS_AllocAndCopyString(
                AUTH_ROOT_AUTO_UPDATE_ROOT_DIR_URL)))
            goto OutOfMemory;
    }

    // Construct the CTL and Seq Urls
    cchDir = wcslen(pInfo->pwszRootDirUrl);

    cchUrl = cchDir + 1 + wcslen(CERT_AUTH_ROOT_CAB_FILENAME) + 1;
    if (NULL == (pInfo->pwszCabUrl = (LPWSTR) PkiNonzeroAlloc(
            sizeof(WCHAR) * cchUrl)))
        goto OutOfMemory;
    wcscpy(pInfo->pwszCabUrl, pInfo->pwszRootDirUrl);
    pInfo->pwszCabUrl[cchDir] = L'/';
    wcscpy(pInfo->pwszCabUrl + cchDir + 1, CERT_AUTH_ROOT_CAB_FILENAME);

    cchUrl = cchDir + 1 + wcslen(CERT_AUTH_ROOT_SEQ_FILENAME) + 1;
    if (NULL == (pInfo->pwszSeqUrl = (LPWSTR) PkiNonzeroAlloc(
            sizeof(WCHAR) * cchUrl)))
        goto OutOfMemory;
    wcscpy(pInfo->pwszSeqUrl, pInfo->pwszRootDirUrl);
    pInfo->pwszSeqUrl[cchDir] = L'/';
    wcscpy(pInfo->pwszSeqUrl + cchDir + 1, CERT_AUTH_ROOT_SEQ_FILENAME);

CommonReturn:
    ILS_CloseRegistryKey(hKey);
    return pInfo;

ErrorReturn:
    FreeAuthRootAutoUpdateInfo(pInfo);
    pInfo = NULL;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
}

//+---------------------------------------------------------------------------
//
//  Function:   FreeAuthRootAutoUpdateInfo
//
//  Synopsis:   frees the AuthRoot Auto Update info
//
//----------------------------------------------------------------------------
VOID WINAPI
FreeAuthRootAutoUpdateInfo(
    IN OUT PAUTH_ROOT_AUTO_UPDATE_INFO pInfo
    )
{
    if (NULL == pInfo)
        return;

    PkiFree(pInfo->pwszRootDirUrl);
    PkiFree(pInfo->pwszCabUrl);
    PkiFree(pInfo->pwszSeqUrl);

    FreeAuthRootAutoUpdateMatchCaches(pInfo->rghMatchCache);

    if (pInfo->pCtl)
        CertFreeCTLContext(pInfo->pCtl);

    PkiFree(pInfo);
}

const LPCSTR rgpszAuthRootMatchOID[AUTH_ROOT_MATCH_CNT] = {
    szOID_CERT_KEY_IDENTIFIER_PROP_ID,
    szOID_CERT_SUBJECT_NAME_MD5_HASH_PROP_ID
};

//+---------------------------------------------------------------------------
//
//  Function:   CreateAuthRootAutoUpdateMatchCaches
//
//  Synopsis:   if not already created, iterates through the CTL entries
//              and creates key and name match caches entries from
//              the associated entry hash attribute values.
//
//----------------------------------------------------------------------------
BOOL WINAPI
CreateAuthRootAutoUpdateMatchCaches(
    IN PCCTL_CONTEXT pCtl,
    IN OUT HLRUCACHE  rghMatchCache[AUTH_ROOT_MATCH_CNT]
    )
{
    BOOL fResult;
    LRU_CACHE_CONFIG Config;
    DWORD i;
    DWORD cEntry;
    PCTL_ENTRY pEntry;

    if (NULL != rghMatchCache[0])
        // Already created.
        return TRUE;

    memset( &Config, 0, sizeof( Config ) );
    Config.dwFlags = LRU_CACHE_NO_SERIALIZE | LRU_CACHE_NO_COPY_IDENTIFIER;
    Config.pfnHash = CertObjectCacheHashMd5Identifier;
    Config.cBuckets = AUTH_ROOT_MATCH_CACHE_BUCKETS;

    for (i = 0; i < AUTH_ROOT_MATCH_CNT; i++) {
        if (!I_CryptCreateLruCache(&Config, &rghMatchCache[i]))
            goto CreateLruCacheError;
    }

    // Loop through the CTL entries and add the exact, key and name match
    // hash cache entries
    cEntry = pCtl->pCtlInfo->cCTLEntry;
    pEntry = pCtl->pCtlInfo->rgCTLEntry;
    for ( ; cEntry > 0; cEntry--, pEntry++) {
        DWORD cAttr;
        PCRYPT_ATTRIBUTE pAttr;

        cAttr = pEntry->cAttribute;
        pAttr = pEntry->rgAttribute;

        // Skip a remove entry
        if (CertFindAttribute(
                szOID_REMOVE_CERTIFICATE,
                cAttr,
                pAttr
                ))
            continue;

        for ( ; cAttr > 0; cAttr--, pAttr++) {
            for (i = 0; i < AUTH_ROOT_MATCH_CNT; i++) {
                if (0 == strcmp(rgpszAuthRootMatchOID[i], pAttr->pszObjId))
                    break;
            }

            if (i < AUTH_ROOT_MATCH_CNT) {
                PCRYPT_ATTR_BLOB pValue;
                DWORD cbHash;
                const BYTE *pbHash;
                CRYPT_DATA_BLOB DataBlob;
                HLRUENTRY hEntry = NULL;

                // Check that we have a single valued attribute encoded as an
                // OCTET STRING
                if (1 != pAttr->cValue)
                    continue;

                pValue = pAttr->rgValue;
                if (2 > pValue->cbData ||
                        ASN1UTIL_TAG_OCTETSTRING != pValue->pbData[0])
                    continue;

                // Extract the hash bytes from the encoded OCTET STRING
                if (0 >= Asn1UtilExtractContent(
                        pValue->pbData,
                        pValue->cbData,
                        &cbHash,
                        &pbHash
                        ) || CMSG_INDEFINITE_LENGTH == cbHash || 0 == cbHash)
                    continue;

                DataBlob.cbData = cbHash;
                DataBlob.pbData = (BYTE *) pbHash;
                if (!I_CryptCreateLruEntry(
                        rghMatchCache[i],
                        &DataBlob,
                        pEntry,
                        &hEntry
                        ))
                    goto CreateLruEntryError;
                I_CryptInsertLruEntry(hEntry, NULL);
                I_CryptReleaseLruEntry(hEntry);
            }
        }
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    FreeAuthRootAutoUpdateMatchCaches(rghMatchCache);
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CreateLruCacheError)
TRACE_ERROR(CreateLruEntryError)
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeAuthRootAutoUpdateMatchCaches
//
//  Synopsis:   frees the AuthRoot Auto Match Caches
//
//----------------------------------------------------------------------------
VOID WINAPI
FreeAuthRootAutoUpdateMatchCaches(
    IN OUT HLRUCACHE  rghMatchCache[AUTH_ROOT_MATCH_CNT]
    )
{
    DWORD i;

    for (i = 0; i < AUTH_ROOT_MATCH_CNT; i++) {
        if (NULL != rghMatchCache[i]) {
            I_CryptFreeLruCache(
                rghMatchCache[i],
                LRU_SUPPRESS_REMOVAL_NOTIFICATION,
                NULL
                );
            rghMatchCache[i] = NULL;
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   FormatAuthRootAutoUpdateCertUrl
//
//  Synopsis:   allocates and formats the URL to retrieve the auth root cert
//
//              returns "RootDir" "/" "AsciiHexHash" ".cer"
//              for example,
//  "http://www.xyz.com/roots/216B2A29E62A00CE820146D8244141B92511B279.cer"
//
//----------------------------------------------------------------------------
LPWSTR WINAPI
FormatAuthRootAutoUpdateCertUrl(
    IN BYTE rgbSha1Hash[SHA1_HASH_LEN],
    IN PAUTH_ROOT_AUTO_UPDATE_INFO pInfo
    )
{
    LPWSTR pwszUrl;
    DWORD cchDir;
    DWORD cchUrl;

    assert(pInfo->pwszRootDirUrl);

    cchDir = wcslen(pInfo->pwszRootDirUrl);

    cchUrl = cchDir + 1 + SHA1_HASH_NAME_LEN +
        wcslen(CERT_AUTH_ROOT_CERT_EXT) + 1;

    if (NULL == (pwszUrl = (LPWSTR) PkiNonzeroAlloc(sizeof(WCHAR) * cchUrl)))
        return NULL;

    wcscpy(pwszUrl, pInfo->pwszRootDirUrl);
    pwszUrl[cchDir] = L'/';
    ILS_BytesToWStr(SHA1_HASH_LEN, rgbSha1Hash, pwszUrl + cchDir + 1);
    wcscpy(pwszUrl + cchDir + 1 + SHA1_HASH_NAME_LEN, CERT_AUTH_ROOT_CERT_EXT);
    return pwszUrl;
}

// Known invalid roots
BYTE AuthRootInvalidList[][SHA1_HASH_LEN] = {
    // verisign "timestamp" - '97
    { 0xD4, 0x73, 0x5D, 0x8A, 0x9A, 0xE5, 0xBC, 0x4B, 0x0A, 0x0D,
      0xC2, 0x70, 0xD6, 0xA6, 0x25, 0x38, 0xA5, 0x87, 0xD3, 0x2F },

    // Root Agency (test root)
    { 0xFE, 0xE4, 0x49, 0xEE, 0x0E, 0x39, 0x65, 0xA5, 0x24, 0x6F,
      0x00, 0x0E, 0x87, 0xFD, 0xE2, 0xA0, 0x65, 0xFD, 0x89, 0xD4 },
};

#define AUTH_ROOT_INVALID_LIST_CNT  (sizeof(AuthRootInvalidList) / \
                                        sizeof(AuthRootInvalidList[0]))

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetAuthRootAutoUpdateStatus
//
//  Synopsis:   return status bits specifying if the root is 
//              trusted via the AuthRoot Auto Update CTL.
//
//              Leaves the engine's critical section to URL retrieve and
//              validate the CTL. Also leaves critical section to
//              add the cert to the AuthRoot store via crypt32 service.
//              If the engine was touched by another thread,
//              it fails with LastError set to ERROR_CAN_NOT_COMPLETE.
//
//  Assumption: Chain engine is locked once in the calling thread.
//
//              Only returns FALSE, if the engine was touched when
//              leaving the critical section.
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainGetAuthRootAutoUpdateStatus (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN PCCERTOBJECT pCertObject,
    IN OUT DWORD *pdwIssuerStatusFlags
    )
{
    BOOL fTouchedResult = TRUE;
    BOOL fResult;
    PCCERTCHAINENGINE pChainEngine = pCallContext->ChainEngine();
    PCCERT_CONTEXT pCert = pCertObject->CertContext();
    PCCTL_CONTEXT pCtl = NULL;
    PCTL_ENTRY pCtlEntry;
    PCERT_BASIC_CONSTRAINTS2_INFO pBasicConstraintsInfo;

    DWORD i;
    DWORD cbData;
    BYTE rgbSha1Hash[SHA1_HASH_LEN];

    // Check if the root has an end entity basic constraint. These can't
    // be used for roots.
    pBasicConstraintsInfo = pCertObject->BasicConstraintsInfo();
    if (pBasicConstraintsInfo && !pBasicConstraintsInfo->fCA)
        return TRUE;

    // Check if a known invalid root, such as, expired timestamp
    // root or the "Root Agency" test root. Don't want all clients in the
    // world hiting the wire for these guys.
    cbData = SHA1_HASH_LEN;
    if (!CertGetCertificateContextProperty(
              pCert,
              CERT_SHA1_HASH_PROP_ID,
              rgbSha1Hash,
              &cbData
              ) || SHA1_HASH_LEN != cbData)
        goto GetSha1HashPropertyError;

    for (i = 0; i < AUTH_ROOT_INVALID_LIST_CNT; i++) {
        if (0 == memcmp(AuthRootInvalidList[i], rgbSha1Hash, SHA1_HASH_LEN))
            return TRUE;
    }

    // Check if this certificate has an associated private key. Such
    // certificates are generated by EFS.
    cbData = 0;
    if (CertGetCertificateContextProperty(
              pCert,
              CERT_KEY_PROV_INFO_PROP_ID,
              NULL,                     // pbData
              &cbData) && 0 < cbData)
        return TRUE;


    fTouchedResult = pChainEngine->GetAuthRootAutoUpdateCtl(
        pCallContext,
        &pCtl
        );

    if (!fTouchedResult || NULL == pCtl) {

#if 0
// This logs too many test failures

        if (fTouchedResult) {
            PAUTH_ROOT_AUTO_UPDATE_INFO pInfo =
                pChainEngine->AuthRootAutoUpdateInfo();

            if (NULL == pInfo || !(pInfo->dwFlags &
                    CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_UNTRUSTED_ROOT_LOGGING_FLAG))
                IPR_LogCertInformation(
                    MSG_UNTRUSTED_ROOT_INFORMATIONAL,
                    pCert,
                    FALSE       // fFormatIssuerName
                    );
        }
#endif

        return fTouchedResult;
    }

    if (NULL == (pCtlEntry = CertFindSubjectInCTL(
            pCert->dwCertEncodingType,
            CTL_CERT_SUBJECT_TYPE,
            (void *) pCert,
            pCtl,
            0                           // dwFlags
            ))) {

#if 0
// This logs too many test failures

        PAUTH_ROOT_AUTO_UPDATE_INFO pInfo =
            pChainEngine->AuthRootAutoUpdateInfo();

        if (NULL == pInfo || !(pInfo->dwFlags &
                CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_UNTRUSTED_ROOT_LOGGING_FLAG))
            IPR_LogCertInformation(
                MSG_UNTRUSTED_ROOT_INFORMATIONAL,
                pCert,
                FALSE       // fFormatIssuerName
                );
#endif

        goto CommonReturn;
    }

    // Check if a remove entry
    if (CertFindAttribute(
            szOID_REMOVE_CERTIFICATE,
            pCtlEntry->cAttribute,
            pCtlEntry->rgAttribute
            ))
        goto CommonReturn;

    pChainEngine->UnlockEngine();
    fResult = IPR_AddCertInAuthRootAutoUpdateCtl(pCert, pCtl);
    pChainEngine->LockEngine();
    if (pCallContext->IsTouchedEngine()) {
        fTouchedResult = FALSE;
        goto TouchedDuringAddAuthRootInCtl;
    }

    if (fResult && CertSetCertificateContextPropertiesFromCTLEntry(
            pCert,
            pCtlEntry,
            CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG
            ))
        *pdwIssuerStatusFlags |= CERT_ISSUER_TRUSTED_ROOT_FLAG;

CommonReturn:
    if (pCtl)
        CertFreeCTLContext(pCtl);

    return fTouchedResult;
ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(GetSha1HashPropertyError)
SET_ERROR(TouchedDuringAddAuthRootInCtl, ERROR_CAN_NOT_COMPLETE)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\x509.c ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for X509 v3 certificates */

#pragma warning(push,3)

#include <windows.h>
#include "x509.h"

#pragma warning (pop)

// unreferenced inline function has been removed
#pragma warning (disable: 4514)

// unreferenced formal parameter
#pragma warning (disable: 4100)

// assignment within conditional expression
#pragma warning (disable: 4706)

ASN1module_t X509_Module = NULL;

static int ASN1CALL ASN1Enc_EncodedObjectID(ASN1encoding_t enc, ASN1uint32_t tag, EncodedObjectID *val);
static int ASN1CALL ASN1Enc_Bits(ASN1encoding_t enc, ASN1uint32_t tag, Bits *val);
static int ASN1CALL ASN1Enc_IntegerType(ASN1encoding_t enc, ASN1uint32_t tag, IntegerType *val);
static int ASN1CALL ASN1Enc_HugeIntegerType(ASN1encoding_t enc, ASN1uint32_t tag, HugeIntegerType *val);
static int ASN1CALL ASN1Enc_OctetStringType(ASN1encoding_t enc, ASN1uint32_t tag, OctetStringType *val);
static int ASN1CALL ASN1Enc_EnumeratedType(ASN1encoding_t enc, ASN1uint32_t tag, EnumeratedType *val);
static int ASN1CALL ASN1Enc_UtcTime(ASN1encoding_t enc, ASN1uint32_t tag, UtcTime *val);
static int ASN1CALL ASN1Enc_NoticeReference_noticeNumbers(ASN1encoding_t enc, ASN1uint32_t tag, NoticeReference_noticeNumbers *val);
static int ASN1CALL ASN1Enc_AnyString(ASN1encoding_t enc, ASN1uint32_t tag, AnyString *val);
static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_Name(ASN1encoding_t enc, ASN1uint32_t tag, Name *val);
static int ASN1CALL ASN1Enc_RelativeDistinguishedName(ASN1encoding_t enc, ASN1uint32_t tag, RelativeDistinguishedName *val);
static int ASN1CALL ASN1Enc_AttributeTypeValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeTypeValue *val);
static int ASN1CALL ASN1Enc_AttributeSetValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValue *val);
static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Enc_RSAPublicKey(ASN1encoding_t enc, ASN1uint32_t tag, RSAPublicKey *val);
static int ASN1CALL ASN1Enc_DSSParameters(ASN1encoding_t enc, ASN1uint32_t tag, DSSParameters *val);
static int ASN1CALL ASN1Enc_DSSSignature(ASN1encoding_t enc, ASN1uint32_t tag, DSSSignature *val);
static int ASN1CALL ASN1Enc_DHParameters(ASN1encoding_t enc, ASN1uint32_t tag, DHParameters *val);
static int ASN1CALL ASN1Enc_X942DhValidationParams(ASN1encoding_t enc, ASN1uint32_t tag, X942DhValidationParams *val);
static int ASN1CALL ASN1Enc_X942DhKeySpecificInfo(ASN1encoding_t enc, ASN1uint32_t tag, X942DhKeySpecificInfo *val);
static int ASN1CALL ASN1Enc_RC2CBCParameters(ASN1encoding_t enc, ASN1uint32_t tag, RC2CBCParameters *val);
static int ASN1CALL ASN1Enc_SMIMECapability(ASN1encoding_t enc, ASN1uint32_t tag, SMIMECapability *val);
static int ASN1CALL ASN1Enc_SMIMECapabilities(ASN1encoding_t enc, ASN1uint32_t tag, SMIMECapabilities *val);
static int ASN1CALL ASN1Enc_SubjectPublicKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, SubjectPublicKeyInfo *val);
static int ASN1CALL ASN1Enc_ChoiceOfTime(ASN1encoding_t enc, ASN1uint32_t tag, ChoiceOfTime *val);
static int ASN1CALL ASN1Enc_Validity(ASN1encoding_t enc, ASN1uint32_t tag, Validity *val);
static int ASN1CALL ASN1Enc_Extensions(ASN1encoding_t enc, ASN1uint32_t tag, Extensions *val);
static int ASN1CALL ASN1Enc_Extension(ASN1encoding_t enc, ASN1uint32_t tag, Extension *val);
static int ASN1CALL ASN1Enc_SignedContent(ASN1encoding_t enc, ASN1uint32_t tag, SignedContent *val);
static int ASN1CALL ASN1Enc_RevokedCertificates(ASN1encoding_t enc, ASN1uint32_t tag, RevokedCertificates *val);
static int ASN1CALL ASN1Enc_CRLEntry(ASN1encoding_t enc, ASN1uint32_t tag, CRLEntry *val);
static int ASN1CALL ASN1Enc_CertificationRequestInfo(ASN1encoding_t enc, ASN1uint32_t tag, CertificationRequestInfo *val);
static int ASN1CALL ASN1Enc_CertificationRequestInfoDecode(ASN1encoding_t enc, ASN1uint32_t tag, CertificationRequestInfoDecode *val);
static int ASN1CALL ASN1Enc_KeygenRequestInfo(ASN1encoding_t enc, ASN1uint32_t tag, KeygenRequestInfo *val);
static int ASN1CALL ASN1Enc_AuthorityKeyId(ASN1encoding_t enc, ASN1uint32_t tag, AuthorityKeyId *val);
static int ASN1CALL ASN1Enc_PrivateKeyValidity(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyValidity *val);
static int ASN1CALL ASN1Enc_CertPolicySet(ASN1encoding_t enc, ASN1uint32_t tag, CertPolicySet *val);
static int ASN1CALL ASN1Enc_CertPolicyId(ASN1encoding_t enc, ASN1uint32_t tag, CertPolicyId *val);
static int ASN1CALL ASN1Enc_AltNames(ASN1encoding_t enc, ASN1uint32_t tag, AltNames *val);
static int ASN1CALL ASN1Enc_GeneralNames(ASN1encoding_t enc, ASN1uint32_t tag, GeneralNames *val);
static int ASN1CALL ASN1Enc_OtherName(ASN1encoding_t enc, ASN1uint32_t tag, OtherName *val);
static int ASN1CALL ASN1Enc_EDIPartyName(ASN1encoding_t enc, ASN1uint32_t tag, EDIPartyName *val);
static int ASN1CALL ASN1Enc_SubtreesConstraint(ASN1encoding_t enc, ASN1uint32_t tag, SubtreesConstraint *val);
static int ASN1CALL ASN1Enc_BasicConstraints2(ASN1encoding_t enc, ASN1uint32_t tag, BasicConstraints2 *val);
static int ASN1CALL ASN1Enc_CertificatePolicies(ASN1encoding_t enc, ASN1uint32_t tag, CertificatePolicies *val);
static int ASN1CALL ASN1Enc_PolicyQualifiers(ASN1encoding_t enc, ASN1uint32_t tag, PolicyQualifiers *val);
static int ASN1CALL ASN1Enc_PolicyQualifierInfo(ASN1encoding_t enc, ASN1uint32_t tag, PolicyQualifierInfo *val);
static int ASN1CALL ASN1Enc_NoticeReference(ASN1encoding_t enc, ASN1uint32_t tag, NoticeReference *val);
static int ASN1CALL ASN1Enc_DisplayText(ASN1encoding_t enc, ASN1uint32_t tag, DisplayText *val);
static int ASN1CALL ASN1Enc_CertificatePolicies95(ASN1encoding_t enc, ASN1uint32_t tag, CertificatePolicies95 *val);
static int ASN1CALL ASN1Enc_CpsURLs(ASN1encoding_t enc, ASN1uint32_t tag, CpsURLs *val);
static int ASN1CALL ASN1Enc_AuthorityKeyId2(ASN1encoding_t enc, ASN1uint32_t tag, AuthorityKeyId2 *val);
static int ASN1CALL ASN1Enc_AuthorityInfoAccess(ASN1encoding_t enc, ASN1uint32_t tag, AuthorityInfoAccess *val);
static int ASN1CALL ASN1Enc_CRLDistributionPoints(ASN1encoding_t enc, ASN1uint32_t tag, CRLDistributionPoints *val);
static int ASN1CALL ASN1Enc_DistributionPointName(ASN1encoding_t enc, ASN1uint32_t tag, DistributionPointName *val);
static int ASN1CALL ASN1Enc_ContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfo *val);
static int ASN1CALL ASN1Enc_SeqOfAny(ASN1encoding_t enc, ASN1uint32_t tag, SeqOfAny *val);
static int ASN1CALL ASN1Enc_TimeStampRequest(ASN1encoding_t enc, ASN1uint32_t tag, TimeStampRequest *val);
static int ASN1CALL ASN1Enc_ContentInfoOTS(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfoOTS *val);
static int ASN1CALL ASN1Enc_TimeStampRequestOTS(ASN1encoding_t enc, ASN1uint32_t tag, TimeStampRequestOTS *val);
static int ASN1CALL ASN1Enc_EnhancedKeyUsage(ASN1encoding_t enc, ASN1uint32_t tag, EnhancedKeyUsage *val);
static int ASN1CALL ASN1Enc_SubjectUsage(ASN1encoding_t enc, ASN1uint32_t tag, SubjectUsage *val);
static int ASN1CALL ASN1Enc_TrustedSubjects(ASN1encoding_t enc, ASN1uint32_t tag, TrustedSubjects *val);
static int ASN1CALL ASN1Enc_TrustedSubject(ASN1encoding_t enc, ASN1uint32_t tag, TrustedSubject *val);
static int ASN1CALL ASN1Enc_EnrollmentNameValuePair(ASN1encoding_t enc, ASN1uint32_t tag, EnrollmentNameValuePair *val);
static int ASN1CALL ASN1Enc_CSPProvider(ASN1encoding_t enc, ASN1uint32_t tag, CSPProvider *val);
static int ASN1CALL ASN1Enc_CertificatePair(ASN1encoding_t enc, ASN1uint32_t tag, CertificatePair *val);
static int ASN1CALL ASN1Enc_GeneralSubtrees(ASN1encoding_t enc, ASN1uint32_t tag, GeneralSubtrees *val);
static int ASN1CALL ASN1Enc_IssuingDistributionPoint(ASN1encoding_t enc, ASN1uint32_t tag, IssuingDistributionPoint *val);
static int ASN1CALL ASN1Enc_CrossCertDistPointNames(ASN1encoding_t enc, ASN1uint32_t tag, CrossCertDistPointNames *val);
static int ASN1CALL ASN1Enc_PolicyMappings(ASN1encoding_t enc, ASN1uint32_t tag, PolicyMappings *val);
static int ASN1CALL ASN1Enc_PolicyMapping(ASN1encoding_t enc, ASN1uint32_t tag, PolicyMapping *val);
static int ASN1CALL ASN1Enc_PolicyConstraints(ASN1encoding_t enc, ASN1uint32_t tag, PolicyConstraints *val);
static int ASN1CALL ASN1Enc_ControlSequence(ASN1encoding_t enc, ASN1uint32_t tag, ControlSequence *val);
static int ASN1CALL ASN1Enc_ReqSequence(ASN1encoding_t enc, ASN1uint32_t tag, ReqSequence *val);
static int ASN1CALL ASN1Enc_CmsSequence(ASN1encoding_t enc, ASN1uint32_t tag, CmsSequence *val);
static int ASN1CALL ASN1Enc_OtherMsgSequence(ASN1encoding_t enc, ASN1uint32_t tag, OtherMsgSequence *val);
static int ASN1CALL ASN1Enc_BodyPartIDSequence(ASN1encoding_t enc, ASN1uint32_t tag, BodyPartIDSequence *val);
static int ASN1CALL ASN1Enc_TaggedAttribute(ASN1encoding_t enc, ASN1uint32_t tag, TaggedAttribute *val);
static int ASN1CALL ASN1Enc_TaggedCertificationRequest(ASN1encoding_t enc, ASN1uint32_t tag, TaggedCertificationRequest *val);
static int ASN1CALL ASN1Enc_TaggedContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, TaggedContentInfo *val);
static int ASN1CALL ASN1Enc_TaggedOtherMsg(ASN1encoding_t enc, ASN1uint32_t tag, TaggedOtherMsg *val);
static int ASN1CALL ASN1Enc_PendInfo(ASN1encoding_t enc, ASN1uint32_t tag, PendInfo *val);
static int ASN1CALL ASN1Enc_CmcAddExtensions(ASN1encoding_t enc, ASN1uint32_t tag, CmcAddExtensions *val);
static int ASN1CALL ASN1Enc_CmcAddAttributes(ASN1encoding_t enc, ASN1uint32_t tag, CmcAddAttributes *val);
static int ASN1CALL ASN1Enc_CertificateTemplate(ASN1encoding_t enc, ASN1uint32_t tag, CertificateTemplate *val);
static int ASN1CALL ASN1Enc_CmcStatusInfo_otherInfo(ASN1encoding_t enc, ASN1uint32_t tag, CmcStatusInfo_otherInfo *val);
static int ASN1CALL ASN1Enc_CpsURLs_Seq(ASN1encoding_t enc, ASN1uint32_t tag, CpsURLs_Seq *val);
static int ASN1CALL ASN1Enc_Attribute(ASN1encoding_t enc, ASN1uint32_t tag, Attribute *val);
static int ASN1CALL ASN1Enc_X942DhParameters(ASN1encoding_t enc, ASN1uint32_t tag, X942DhParameters *val);
static int ASN1CALL ASN1Enc_X942DhOtherInfo(ASN1encoding_t enc, ASN1uint32_t tag, X942DhOtherInfo *val);
static int ASN1CALL ASN1Enc_CertificateToBeSigned(ASN1encoding_t enc, ASN1uint32_t tag, CertificateToBeSigned *val);
static int ASN1CALL ASN1Enc_CertificateRevocationListToBeSigned(ASN1encoding_t enc, ASN1uint32_t tag, CertificateRevocationListToBeSigned *val);
static int ASN1CALL ASN1Enc_KeyAttributes(ASN1encoding_t enc, ASN1uint32_t tag, KeyAttributes *val);
static int ASN1CALL ASN1Enc_KeyUsageRestriction(ASN1encoding_t enc, ASN1uint32_t tag, KeyUsageRestriction *val);
static int ASN1CALL ASN1Enc_GeneralName(ASN1encoding_t enc, ASN1uint32_t tag, GeneralName *val);
static int ASN1CALL ASN1Enc_BasicConstraints(ASN1encoding_t enc, ASN1uint32_t tag, BasicConstraints *val);
static int ASN1CALL ASN1Enc_PolicyInformation(ASN1encoding_t enc, ASN1uint32_t tag, PolicyInformation *val);
static int ASN1CALL ASN1Enc_UserNotice(ASN1encoding_t enc, ASN1uint32_t tag, UserNotice *val);
static int ASN1CALL ASN1Enc_VerisignQualifier1(ASN1encoding_t enc, ASN1uint32_t tag, VerisignQualifier1 *val);
static int ASN1CALL ASN1Enc_AccessDescription(ASN1encoding_t enc, ASN1uint32_t tag, AccessDescription *val);
static int ASN1CALL ASN1Enc_DistributionPoint(ASN1encoding_t enc, ASN1uint32_t tag, DistributionPoint *val);
static int ASN1CALL ASN1Enc_ContentInfoSeqOfAny(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfoSeqOfAny *val);
static int ASN1CALL ASN1Enc_CertificateTrustList(ASN1encoding_t enc, ASN1uint32_t tag, CertificateTrustList *val);
static int ASN1CALL ASN1Enc_NameConstraints(ASN1encoding_t enc, ASN1uint32_t tag, NameConstraints *val);
static int ASN1CALL ASN1Enc_GeneralSubtree(ASN1encoding_t enc, ASN1uint32_t tag, GeneralSubtree *val);
static int ASN1CALL ASN1Enc_CrossCertDistPoints(ASN1encoding_t enc, ASN1uint32_t tag, CrossCertDistPoints *val);
static int ASN1CALL ASN1Enc_CmcData(ASN1encoding_t enc, ASN1uint32_t tag, CmcData *val);
static int ASN1CALL ASN1Enc_CmcResponseBody(ASN1encoding_t enc, ASN1uint32_t tag, CmcResponseBody *val);
static int ASN1CALL ASN1Enc_TaggedRequest(ASN1encoding_t enc, ASN1uint32_t tag, TaggedRequest *val);
static int ASN1CALL ASN1Enc_CmcStatusInfo(ASN1encoding_t enc, ASN1uint32_t tag, CmcStatusInfo *val);
static int ASN1CALL ASN1Dec_EncodedObjectID(ASN1decoding_t dec, ASN1uint32_t tag, EncodedObjectID *val);
static int ASN1CALL ASN1Dec_Bits(ASN1decoding_t dec, ASN1uint32_t tag, Bits *val);
static int ASN1CALL ASN1Dec_IntegerType(ASN1decoding_t dec, ASN1uint32_t tag, IntegerType *val);
static int ASN1CALL ASN1Dec_HugeIntegerType(ASN1decoding_t dec, ASN1uint32_t tag, HugeIntegerType *val);
static int ASN1CALL ASN1Dec_OctetStringType(ASN1decoding_t dec, ASN1uint32_t tag, OctetStringType *val);
static int ASN1CALL ASN1Dec_EnumeratedType(ASN1decoding_t dec, ASN1uint32_t tag, EnumeratedType *val);
static int ASN1CALL ASN1Dec_UtcTime(ASN1decoding_t dec, ASN1uint32_t tag, UtcTime *val);
static int ASN1CALL ASN1Dec_NoticeReference_noticeNumbers(ASN1decoding_t dec, ASN1uint32_t tag, NoticeReference_noticeNumbers *val);
static int ASN1CALL ASN1Dec_AnyString(ASN1decoding_t dec, ASN1uint32_t tag, AnyString *val);
static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_Name(ASN1decoding_t dec, ASN1uint32_t tag, Name *val);
static int ASN1CALL ASN1Dec_RelativeDistinguishedName(ASN1decoding_t dec, ASN1uint32_t tag, RelativeDistinguishedName *val);
static int ASN1CALL ASN1Dec_AttributeTypeValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeTypeValue *val);
static int ASN1CALL ASN1Dec_AttributeSetValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValue *val);
static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Dec_RSAPublicKey(ASN1decoding_t dec, ASN1uint32_t tag, RSAPublicKey *val);
static int ASN1CALL ASN1Dec_DSSParameters(ASN1decoding_t dec, ASN1uint32_t tag, DSSParameters *val);
static int ASN1CALL ASN1Dec_DSSSignature(ASN1decoding_t dec, ASN1uint32_t tag, DSSSignature *val);
static int ASN1CALL ASN1Dec_DHParameters(ASN1decoding_t dec, ASN1uint32_t tag, DHParameters *val);
static int ASN1CALL ASN1Dec_X942DhValidationParams(ASN1decoding_t dec, ASN1uint32_t tag, X942DhValidationParams *val);
static int ASN1CALL ASN1Dec_X942DhKeySpecificInfo(ASN1decoding_t dec, ASN1uint32_t tag, X942DhKeySpecificInfo *val);
static int ASN1CALL ASN1Dec_RC2CBCParameters(ASN1decoding_t dec, ASN1uint32_t tag, RC2CBCParameters *val);
static int ASN1CALL ASN1Dec_SMIMECapability(ASN1decoding_t dec, ASN1uint32_t tag, SMIMECapability *val);
static int ASN1CALL ASN1Dec_SMIMECapabilities(ASN1decoding_t dec, ASN1uint32_t tag, SMIMECapabilities *val);
static int ASN1CALL ASN1Dec_SubjectPublicKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, SubjectPublicKeyInfo *val);
static int ASN1CALL ASN1Dec_ChoiceOfTime(ASN1decoding_t dec, ASN1uint32_t tag, ChoiceOfTime *val);
static int ASN1CALL ASN1Dec_Validity(ASN1decoding_t dec, ASN1uint32_t tag, Validity *val);
static int ASN1CALL ASN1Dec_Extensions(ASN1decoding_t dec, ASN1uint32_t tag, Extensions *val);
static int ASN1CALL ASN1Dec_Extension(ASN1decoding_t dec, ASN1uint32_t tag, Extension *val);
static int ASN1CALL ASN1Dec_SignedContent(ASN1decoding_t dec, ASN1uint32_t tag, SignedContent *val);
static int ASN1CALL ASN1Dec_RevokedCertificates(ASN1decoding_t dec, ASN1uint32_t tag, RevokedCertificates *val);
static int ASN1CALL ASN1Dec_CRLEntry(ASN1decoding_t dec, ASN1uint32_t tag, CRLEntry *val);
static int ASN1CALL ASN1Dec_CertificationRequestInfo(ASN1decoding_t dec, ASN1uint32_t tag, CertificationRequestInfo *val);
static int ASN1CALL ASN1Dec_CertificationRequestInfoDecode(ASN1decoding_t dec, ASN1uint32_t tag, CertificationRequestInfoDecode *val);
static int ASN1CALL ASN1Dec_KeygenRequestInfo(ASN1decoding_t dec, ASN1uint32_t tag, KeygenRequestInfo *val);
static int ASN1CALL ASN1Dec_AuthorityKeyId(ASN1decoding_t dec, ASN1uint32_t tag, AuthorityKeyId *val);
static int ASN1CALL ASN1Dec_PrivateKeyValidity(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyValidity *val);
static int ASN1CALL ASN1Dec_CertPolicySet(ASN1decoding_t dec, ASN1uint32_t tag, CertPolicySet *val);
static int ASN1CALL ASN1Dec_CertPolicyId(ASN1decoding_t dec, ASN1uint32_t tag, CertPolicyId *val);
static int ASN1CALL ASN1Dec_AltNames(ASN1decoding_t dec, ASN1uint32_t tag, AltNames *val);
static int ASN1CALL ASN1Dec_GeneralNames(ASN1decoding_t dec, ASN1uint32_t tag, GeneralNames *val);
static int ASN1CALL ASN1Dec_OtherName(ASN1decoding_t dec, ASN1uint32_t tag, OtherName *val);
static int ASN1CALL ASN1Dec_EDIPartyName(ASN1decoding_t dec, ASN1uint32_t tag, EDIPartyName *val);
static int ASN1CALL ASN1Dec_SubtreesConstraint(ASN1decoding_t dec, ASN1uint32_t tag, SubtreesConstraint *val);
static int ASN1CALL ASN1Dec_BasicConstraints2(ASN1decoding_t dec, ASN1uint32_t tag, BasicConstraints2 *val);
static int ASN1CALL ASN1Dec_CertificatePolicies(ASN1decoding_t dec, ASN1uint32_t tag, CertificatePolicies *val);
static int ASN1CALL ASN1Dec_PolicyQualifiers(ASN1decoding_t dec, ASN1uint32_t tag, PolicyQualifiers *val);
static int ASN1CALL ASN1Dec_PolicyQualifierInfo(ASN1decoding_t dec, ASN1uint32_t tag, PolicyQualifierInfo *val);
static int ASN1CALL ASN1Dec_NoticeReference(ASN1decoding_t dec, ASN1uint32_t tag, NoticeReference *val);
static int ASN1CALL ASN1Dec_DisplayText(ASN1decoding_t dec, ASN1uint32_t tag, DisplayText *val);
static int ASN1CALL ASN1Dec_CertificatePolicies95(ASN1decoding_t dec, ASN1uint32_t tag, CertificatePolicies95 *val);
static int ASN1CALL ASN1Dec_CpsURLs(ASN1decoding_t dec, ASN1uint32_t tag, CpsURLs *val);
static int ASN1CALL ASN1Dec_AuthorityKeyId2(ASN1decoding_t dec, ASN1uint32_t tag, AuthorityKeyId2 *val);
static int ASN1CALL ASN1Dec_AuthorityInfoAccess(ASN1decoding_t dec, ASN1uint32_t tag, AuthorityInfoAccess *val);
static int ASN1CALL ASN1Dec_CRLDistributionPoints(ASN1decoding_t dec, ASN1uint32_t tag, CRLDistributionPoints *val);
static int ASN1CALL ASN1Dec_DistributionPointName(ASN1decoding_t dec, ASN1uint32_t tag, DistributionPointName *val);
static int ASN1CALL ASN1Dec_ContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfo *val);
static int ASN1CALL ASN1Dec_SeqOfAny(ASN1decoding_t dec, ASN1uint32_t tag, SeqOfAny *val);
static int ASN1CALL ASN1Dec_TimeStampRequest(ASN1decoding_t dec, ASN1uint32_t tag, TimeStampRequest *val);
static int ASN1CALL ASN1Dec_ContentInfoOTS(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfoOTS *val);
static int ASN1CALL ASN1Dec_TimeStampRequestOTS(ASN1decoding_t dec, ASN1uint32_t tag, TimeStampRequestOTS *val);
static int ASN1CALL ASN1Dec_EnhancedKeyUsage(ASN1decoding_t dec, ASN1uint32_t tag, EnhancedKeyUsage *val);
static int ASN1CALL ASN1Dec_SubjectUsage(ASN1decoding_t dec, ASN1uint32_t tag, SubjectUsage *val);
static int ASN1CALL ASN1Dec_TrustedSubjects(ASN1decoding_t dec, ASN1uint32_t tag, TrustedSubjects *val);
static int ASN1CALL ASN1Dec_TrustedSubject(ASN1decoding_t dec, ASN1uint32_t tag, TrustedSubject *val);
static int ASN1CALL ASN1Dec_EnrollmentNameValuePair(ASN1decoding_t dec, ASN1uint32_t tag, EnrollmentNameValuePair *val);
static int ASN1CALL ASN1Dec_CSPProvider(ASN1decoding_t dec, ASN1uint32_t tag, CSPProvider *val);
static int ASN1CALL ASN1Dec_CertificatePair(ASN1decoding_t dec, ASN1uint32_t tag, CertificatePair *val);
static int ASN1CALL ASN1Dec_GeneralSubtrees(ASN1decoding_t dec, ASN1uint32_t tag, GeneralSubtrees *val);
static int ASN1CALL ASN1Dec_IssuingDistributionPoint(ASN1decoding_t dec, ASN1uint32_t tag, IssuingDistributionPoint *val);
static int ASN1CALL ASN1Dec_CrossCertDistPointNames(ASN1decoding_t dec, ASN1uint32_t tag, CrossCertDistPointNames *val);
static int ASN1CALL ASN1Dec_PolicyMappings(ASN1decoding_t dec, ASN1uint32_t tag, PolicyMappings *val);
static int ASN1CALL ASN1Dec_PolicyMapping(ASN1decoding_t dec, ASN1uint32_t tag, PolicyMapping *val);
static int ASN1CALL ASN1Dec_PolicyConstraints(ASN1decoding_t dec, ASN1uint32_t tag, PolicyConstraints *val);
static int ASN1CALL ASN1Dec_ControlSequence(ASN1decoding_t dec, ASN1uint32_t tag, ControlSequence *val);
static int ASN1CALL ASN1Dec_ReqSequence(ASN1decoding_t dec, ASN1uint32_t tag, ReqSequence *val);
static int ASN1CALL ASN1Dec_CmsSequence(ASN1decoding_t dec, ASN1uint32_t tag, CmsSequence *val);
static int ASN1CALL ASN1Dec_OtherMsgSequence(ASN1decoding_t dec, ASN1uint32_t tag, OtherMsgSequence *val);
static int ASN1CALL ASN1Dec_BodyPartIDSequence(ASN1decoding_t dec, ASN1uint32_t tag, BodyPartIDSequence *val);
static int ASN1CALL ASN1Dec_TaggedAttribute(ASN1decoding_t dec, ASN1uint32_t tag, TaggedAttribute *val);
static int ASN1CALL ASN1Dec_TaggedCertificationRequest(ASN1decoding_t dec, ASN1uint32_t tag, TaggedCertificationRequest *val);
static int ASN1CALL ASN1Dec_TaggedContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, TaggedContentInfo *val);
static int ASN1CALL ASN1Dec_TaggedOtherMsg(ASN1decoding_t dec, ASN1uint32_t tag, TaggedOtherMsg *val);
static int ASN1CALL ASN1Dec_PendInfo(ASN1decoding_t dec, ASN1uint32_t tag, PendInfo *val);
static int ASN1CALL ASN1Dec_CmcAddExtensions(ASN1decoding_t dec, ASN1uint32_t tag, CmcAddExtensions *val);
static int ASN1CALL ASN1Dec_CmcAddAttributes(ASN1decoding_t dec, ASN1uint32_t tag, CmcAddAttributes *val);
static int ASN1CALL ASN1Dec_CertificateTemplate(ASN1decoding_t dec, ASN1uint32_t tag, CertificateTemplate *val);
static int ASN1CALL ASN1Dec_CmcStatusInfo_otherInfo(ASN1decoding_t dec, ASN1uint32_t tag, CmcStatusInfo_otherInfo *val);
static int ASN1CALL ASN1Dec_CpsURLs_Seq(ASN1decoding_t dec, ASN1uint32_t tag, CpsURLs_Seq *val);
static int ASN1CALL ASN1Dec_Attribute(ASN1decoding_t dec, ASN1uint32_t tag, Attribute *val);
static int ASN1CALL ASN1Dec_X942DhParameters(ASN1decoding_t dec, ASN1uint32_t tag, X942DhParameters *val);
static int ASN1CALL ASN1Dec_X942DhOtherInfo(ASN1decoding_t dec, ASN1uint32_t tag, X942DhOtherInfo *val);
static int ASN1CALL ASN1Dec_CertificateToBeSigned(ASN1decoding_t dec, ASN1uint32_t tag, CertificateToBeSigned *val);
static int ASN1CALL ASN1Dec_CertificateRevocationListToBeSigned(ASN1decoding_t dec, ASN1uint32_t tag, CertificateRevocationListToBeSigned *val);
static int ASN1CALL ASN1Dec_KeyAttributes(ASN1decoding_t dec, ASN1uint32_t tag, KeyAttributes *val);
static int ASN1CALL ASN1Dec_KeyUsageRestriction(ASN1decoding_t dec, ASN1uint32_t tag, KeyUsageRestriction *val);
static int ASN1CALL ASN1Dec_GeneralName(ASN1decoding_t dec, ASN1uint32_t tag, GeneralName *val);
static int ASN1CALL ASN1Dec_BasicConstraints(ASN1decoding_t dec, ASN1uint32_t tag, BasicConstraints *val);
static int ASN1CALL ASN1Dec_PolicyInformation(ASN1decoding_t dec, ASN1uint32_t tag, PolicyInformation *val);
static int ASN1CALL ASN1Dec_UserNotice(ASN1decoding_t dec, ASN1uint32_t tag, UserNotice *val);
static int ASN1CALL ASN1Dec_VerisignQualifier1(ASN1decoding_t dec, ASN1uint32_t tag, VerisignQualifier1 *val);
static int ASN1CALL ASN1Dec_AccessDescription(ASN1decoding_t dec, ASN1uint32_t tag, AccessDescription *val);
static int ASN1CALL ASN1Dec_DistributionPoint(ASN1decoding_t dec, ASN1uint32_t tag, DistributionPoint *val);
static int ASN1CALL ASN1Dec_ContentInfoSeqOfAny(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfoSeqOfAny *val);
static int ASN1CALL ASN1Dec_CertificateTrustList(ASN1decoding_t dec, ASN1uint32_t tag, CertificateTrustList *val);
static int ASN1CALL ASN1Dec_NameConstraints(ASN1decoding_t dec, ASN1uint32_t tag, NameConstraints *val);
static int ASN1CALL ASN1Dec_GeneralSubtree(ASN1decoding_t dec, ASN1uint32_t tag, GeneralSubtree *val);
static int ASN1CALL ASN1Dec_CrossCertDistPoints(ASN1decoding_t dec, ASN1uint32_t tag, CrossCertDistPoints *val);
static int ASN1CALL ASN1Dec_CmcData(ASN1decoding_t dec, ASN1uint32_t tag, CmcData *val);
static int ASN1CALL ASN1Dec_CmcResponseBody(ASN1decoding_t dec, ASN1uint32_t tag, CmcResponseBody *val);
static int ASN1CALL ASN1Dec_TaggedRequest(ASN1decoding_t dec, ASN1uint32_t tag, TaggedRequest *val);
static int ASN1CALL ASN1Dec_CmcStatusInfo(ASN1decoding_t dec, ASN1uint32_t tag, CmcStatusInfo *val);
static void ASN1CALL ASN1Free_EncodedObjectID(EncodedObjectID *val);
static void ASN1CALL ASN1Free_Bits(Bits *val);
static void ASN1CALL ASN1Free_HugeIntegerType(HugeIntegerType *val);
static void ASN1CALL ASN1Free_OctetStringType(OctetStringType *val);
static void ASN1CALL ASN1Free_UtcTime(UtcTime *val);
static void ASN1CALL ASN1Free_NoticeReference_noticeNumbers(NoticeReference_noticeNumbers *val);
static void ASN1CALL ASN1Free_AnyString(AnyString *val);
static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_Name(Name *val);
static void ASN1CALL ASN1Free_RelativeDistinguishedName(RelativeDistinguishedName *val);
static void ASN1CALL ASN1Free_AttributeTypeValue(AttributeTypeValue *val);
static void ASN1CALL ASN1Free_AttributeSetValue(AttributeSetValue *val);
static void ASN1CALL ASN1Free_Attributes(Attributes *val);
static void ASN1CALL ASN1Free_RSAPublicKey(RSAPublicKey *val);
static void ASN1CALL ASN1Free_DSSParameters(DSSParameters *val);
static void ASN1CALL ASN1Free_DSSSignature(DSSSignature *val);
static void ASN1CALL ASN1Free_DHParameters(DHParameters *val);
static void ASN1CALL ASN1Free_X942DhValidationParams(X942DhValidationParams *val);
static void ASN1CALL ASN1Free_X942DhKeySpecificInfo(X942DhKeySpecificInfo *val);
static void ASN1CALL ASN1Free_RC2CBCParameters(RC2CBCParameters *val);
static void ASN1CALL ASN1Free_SMIMECapability(SMIMECapability *val);
static void ASN1CALL ASN1Free_SMIMECapabilities(SMIMECapabilities *val);
static void ASN1CALL ASN1Free_SubjectPublicKeyInfo(SubjectPublicKeyInfo *val);
static void ASN1CALL ASN1Free_ChoiceOfTime(ChoiceOfTime *val);
static void ASN1CALL ASN1Free_Validity(Validity *val);
static void ASN1CALL ASN1Free_Extensions(Extensions *val);
static void ASN1CALL ASN1Free_Extension(Extension *val);
static void ASN1CALL ASN1Free_SignedContent(SignedContent *val);
static void ASN1CALL ASN1Free_RevokedCertificates(RevokedCertificates *val);
static void ASN1CALL ASN1Free_CRLEntry(CRLEntry *val);
static void ASN1CALL ASN1Free_CertificationRequestInfo(CertificationRequestInfo *val);
static void ASN1CALL ASN1Free_CertificationRequestInfoDecode(CertificationRequestInfoDecode *val);
static void ASN1CALL ASN1Free_KeygenRequestInfo(KeygenRequestInfo *val);
static void ASN1CALL ASN1Free_AuthorityKeyId(AuthorityKeyId *val);
static void ASN1CALL ASN1Free_PrivateKeyValidity(PrivateKeyValidity *val);
static void ASN1CALL ASN1Free_CertPolicySet(CertPolicySet *val);
static void ASN1CALL ASN1Free_CertPolicyId(CertPolicyId *val);
static void ASN1CALL ASN1Free_AltNames(AltNames *val);
static void ASN1CALL ASN1Free_GeneralNames(GeneralNames *val);
static void ASN1CALL ASN1Free_OtherName(OtherName *val);
static void ASN1CALL ASN1Free_EDIPartyName(EDIPartyName *val);
static void ASN1CALL ASN1Free_SubtreesConstraint(SubtreesConstraint *val);
static void ASN1CALL ASN1Free_CertificatePolicies(CertificatePolicies *val);
static void ASN1CALL ASN1Free_PolicyQualifiers(PolicyQualifiers *val);
static void ASN1CALL ASN1Free_PolicyQualifierInfo(PolicyQualifierInfo *val);
static void ASN1CALL ASN1Free_NoticeReference(NoticeReference *val);
static void ASN1CALL ASN1Free_DisplayText(DisplayText *val);
static void ASN1CALL ASN1Free_CertificatePolicies95(CertificatePolicies95 *val);
static void ASN1CALL ASN1Free_CpsURLs(CpsURLs *val);
static void ASN1CALL ASN1Free_AuthorityKeyId2(AuthorityKeyId2 *val);
static void ASN1CALL ASN1Free_AuthorityInfoAccess(AuthorityInfoAccess *val);
static void ASN1CALL ASN1Free_CRLDistributionPoints(CRLDistributionPoints *val);
static void ASN1CALL ASN1Free_DistributionPointName(DistributionPointName *val);
static void ASN1CALL ASN1Free_ContentInfo(ContentInfo *val);
static void ASN1CALL ASN1Free_SeqOfAny(SeqOfAny *val);
static void ASN1CALL ASN1Free_TimeStampRequest(TimeStampRequest *val);
static void ASN1CALL ASN1Free_ContentInfoOTS(ContentInfoOTS *val);
static void ASN1CALL ASN1Free_TimeStampRequestOTS(TimeStampRequestOTS *val);
static void ASN1CALL ASN1Free_EnhancedKeyUsage(EnhancedKeyUsage *val);
static void ASN1CALL ASN1Free_SubjectUsage(SubjectUsage *val);
static void ASN1CALL ASN1Free_TrustedSubjects(TrustedSubjects *val);
static void ASN1CALL ASN1Free_TrustedSubject(TrustedSubject *val);
static void ASN1CALL ASN1Free_EnrollmentNameValuePair(EnrollmentNameValuePair *val);
static void ASN1CALL ASN1Free_CSPProvider(CSPProvider *val);
static void ASN1CALL ASN1Free_CertificatePair(CertificatePair *val);
static void ASN1CALL ASN1Free_GeneralSubtrees(GeneralSubtrees *val);
static void ASN1CALL ASN1Free_IssuingDistributionPoint(IssuingDistributionPoint *val);
static void ASN1CALL ASN1Free_CrossCertDistPointNames(CrossCertDistPointNames *val);
static void ASN1CALL ASN1Free_PolicyMappings(PolicyMappings *val);
static void ASN1CALL ASN1Free_PolicyMapping(PolicyMapping *val);
static void ASN1CALL ASN1Free_ControlSequence(ControlSequence *val);
static void ASN1CALL ASN1Free_ReqSequence(ReqSequence *val);
static void ASN1CALL ASN1Free_CmsSequence(CmsSequence *val);
static void ASN1CALL ASN1Free_OtherMsgSequence(OtherMsgSequence *val);
static void ASN1CALL ASN1Free_BodyPartIDSequence(BodyPartIDSequence *val);
static void ASN1CALL ASN1Free_TaggedAttribute(TaggedAttribute *val);
static void ASN1CALL ASN1Free_TaggedCertificationRequest(TaggedCertificationRequest *val);
static void ASN1CALL ASN1Free_TaggedContentInfo(TaggedContentInfo *val);
static void ASN1CALL ASN1Free_TaggedOtherMsg(TaggedOtherMsg *val);
static void ASN1CALL ASN1Free_PendInfo(PendInfo *val);
static void ASN1CALL ASN1Free_CmcAddExtensions(CmcAddExtensions *val);
static void ASN1CALL ASN1Free_CmcAddAttributes(CmcAddAttributes *val);
static void ASN1CALL ASN1Free_CertificateTemplate(CertificateTemplate *val);
static void ASN1CALL ASN1Free_CmcStatusInfo_otherInfo(CmcStatusInfo_otherInfo *val);
static void ASN1CALL ASN1Free_CpsURLs_Seq(CpsURLs_Seq *val);
static void ASN1CALL ASN1Free_Attribute(Attribute *val);
static void ASN1CALL ASN1Free_X942DhParameters(X942DhParameters *val);
static void ASN1CALL ASN1Free_X942DhOtherInfo(X942DhOtherInfo *val);
static void ASN1CALL ASN1Free_CertificateToBeSigned(CertificateToBeSigned *val);
static void ASN1CALL ASN1Free_CertificateRevocationListToBeSigned(CertificateRevocationListToBeSigned *val);
static void ASN1CALL ASN1Free_KeyAttributes(KeyAttributes *val);
static void ASN1CALL ASN1Free_KeyUsageRestriction(KeyUsageRestriction *val);
static void ASN1CALL ASN1Free_GeneralName(GeneralName *val);
static void ASN1CALL ASN1Free_BasicConstraints(BasicConstraints *val);
static void ASN1CALL ASN1Free_PolicyInformation(PolicyInformation *val);
static void ASN1CALL ASN1Free_UserNotice(UserNotice *val);
static void ASN1CALL ASN1Free_VerisignQualifier1(VerisignQualifier1 *val);
static void ASN1CALL ASN1Free_AccessDescription(AccessDescription *val);
static void ASN1CALL ASN1Free_DistributionPoint(DistributionPoint *val);
static void ASN1CALL ASN1Free_ContentInfoSeqOfAny(ContentInfoSeqOfAny *val);
static void ASN1CALL ASN1Free_CertificateTrustList(CertificateTrustList *val);
static void ASN1CALL ASN1Free_NameConstraints(NameConstraints *val);
static void ASN1CALL ASN1Free_GeneralSubtree(GeneralSubtree *val);
static void ASN1CALL ASN1Free_CrossCertDistPoints(CrossCertDistPoints *val);
static void ASN1CALL ASN1Free_CmcData(CmcData *val);
static void ASN1CALL ASN1Free_CmcResponseBody(CmcResponseBody *val);
static void ASN1CALL ASN1Free_TaggedRequest(TaggedRequest *val);
static void ASN1CALL ASN1Free_CmcStatusInfo(CmcStatusInfo *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[64] = {
    (ASN1EncFun_t) ASN1Enc_EncodedObjectID,
    (ASN1EncFun_t) ASN1Enc_Bits,
    (ASN1EncFun_t) ASN1Enc_IntegerType,
    (ASN1EncFun_t) ASN1Enc_HugeIntegerType,
    (ASN1EncFun_t) ASN1Enc_OctetStringType,
    (ASN1EncFun_t) ASN1Enc_EnumeratedType,
    (ASN1EncFun_t) ASN1Enc_UtcTime,
    (ASN1EncFun_t) ASN1Enc_AnyString,
    (ASN1EncFun_t) ASN1Enc_Name,
    (ASN1EncFun_t) ASN1Enc_Attributes,
    (ASN1EncFun_t) ASN1Enc_RSAPublicKey,
    (ASN1EncFun_t) ASN1Enc_DSSParameters,
    (ASN1EncFun_t) ASN1Enc_DSSSignature,
    (ASN1EncFun_t) ASN1Enc_DHParameters,
    (ASN1EncFun_t) ASN1Enc_RC2CBCParameters,
    (ASN1EncFun_t) ASN1Enc_SMIMECapabilities,
    (ASN1EncFun_t) ASN1Enc_SubjectPublicKeyInfo,
    (ASN1EncFun_t) ASN1Enc_ChoiceOfTime,
    (ASN1EncFun_t) ASN1Enc_Extensions,
    (ASN1EncFun_t) ASN1Enc_SignedContent,
    (ASN1EncFun_t) ASN1Enc_CertificationRequestInfo,
    (ASN1EncFun_t) ASN1Enc_CertificationRequestInfoDecode,
    (ASN1EncFun_t) ASN1Enc_KeygenRequestInfo,
    (ASN1EncFun_t) ASN1Enc_AuthorityKeyId,
    (ASN1EncFun_t) ASN1Enc_AltNames,
    (ASN1EncFun_t) ASN1Enc_EDIPartyName,
    (ASN1EncFun_t) ASN1Enc_BasicConstraints2,
    (ASN1EncFun_t) ASN1Enc_CertificatePolicies,
    (ASN1EncFun_t) ASN1Enc_CertificatePolicies95,
    (ASN1EncFun_t) ASN1Enc_AuthorityKeyId2,
    (ASN1EncFun_t) ASN1Enc_AuthorityInfoAccess,
    (ASN1EncFun_t) ASN1Enc_CRLDistributionPoints,
    (ASN1EncFun_t) ASN1Enc_ContentInfo,
    (ASN1EncFun_t) ASN1Enc_SeqOfAny,
    (ASN1EncFun_t) ASN1Enc_TimeStampRequest,
    (ASN1EncFun_t) ASN1Enc_ContentInfoOTS,
    (ASN1EncFun_t) ASN1Enc_TimeStampRequestOTS,
    (ASN1EncFun_t) ASN1Enc_EnhancedKeyUsage,
    (ASN1EncFun_t) ASN1Enc_EnrollmentNameValuePair,
    (ASN1EncFun_t) ASN1Enc_CSPProvider,
    (ASN1EncFun_t) ASN1Enc_CertificatePair,
    (ASN1EncFun_t) ASN1Enc_IssuingDistributionPoint,
    (ASN1EncFun_t) ASN1Enc_PolicyMappings,
    (ASN1EncFun_t) ASN1Enc_PolicyConstraints,
    (ASN1EncFun_t) ASN1Enc_CmcAddExtensions,
    (ASN1EncFun_t) ASN1Enc_CmcAddAttributes,
    (ASN1EncFun_t) ASN1Enc_CertificateTemplate,
    (ASN1EncFun_t) ASN1Enc_Attribute,
    (ASN1EncFun_t) ASN1Enc_X942DhParameters,
    (ASN1EncFun_t) ASN1Enc_X942DhOtherInfo,
    (ASN1EncFun_t) ASN1Enc_CertificateToBeSigned,
    (ASN1EncFun_t) ASN1Enc_CertificateRevocationListToBeSigned,
    (ASN1EncFun_t) ASN1Enc_KeyAttributes,
    (ASN1EncFun_t) ASN1Enc_KeyUsageRestriction,
    (ASN1EncFun_t) ASN1Enc_BasicConstraints,
    (ASN1EncFun_t) ASN1Enc_UserNotice,
    (ASN1EncFun_t) ASN1Enc_VerisignQualifier1,
    (ASN1EncFun_t) ASN1Enc_ContentInfoSeqOfAny,
    (ASN1EncFun_t) ASN1Enc_CertificateTrustList,
    (ASN1EncFun_t) ASN1Enc_NameConstraints,
    (ASN1EncFun_t) ASN1Enc_CrossCertDistPoints,
    (ASN1EncFun_t) ASN1Enc_CmcData,
    (ASN1EncFun_t) ASN1Enc_CmcResponseBody,
    (ASN1EncFun_t) ASN1Enc_CmcStatusInfo,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[64] = {
    (ASN1DecFun_t) ASN1Dec_EncodedObjectID,
    (ASN1DecFun_t) ASN1Dec_Bits,
    (ASN1DecFun_t) ASN1Dec_IntegerType,
    (ASN1DecFun_t) ASN1Dec_HugeIntegerType,
    (ASN1DecFun_t) ASN1Dec_OctetStringType,
    (ASN1DecFun_t) ASN1Dec_EnumeratedType,
    (ASN1DecFun_t) ASN1Dec_UtcTime,
    (ASN1DecFun_t) ASN1Dec_AnyString,
    (ASN1DecFun_t) ASN1Dec_Name,
    (ASN1DecFun_t) ASN1Dec_Attributes,
    (ASN1DecFun_t) ASN1Dec_RSAPublicKey,
    (ASN1DecFun_t) ASN1Dec_DSSParameters,
    (ASN1DecFun_t) ASN1Dec_DSSSignature,
    (ASN1DecFun_t) ASN1Dec_DHParameters,
    (ASN1DecFun_t) ASN1Dec_RC2CBCParameters,
    (ASN1DecFun_t) ASN1Dec_SMIMECapabilities,
    (ASN1DecFun_t) ASN1Dec_SubjectPublicKeyInfo,
    (ASN1DecFun_t) ASN1Dec_ChoiceOfTime,
    (ASN1DecFun_t) ASN1Dec_Extensions,
    (ASN1DecFun_t) ASN1Dec_SignedContent,
    (ASN1DecFun_t) ASN1Dec_CertificationRequestInfo,
    (ASN1DecFun_t) ASN1Dec_CertificationRequestInfoDecode,
    (ASN1DecFun_t) ASN1Dec_KeygenRequestInfo,
    (ASN1DecFun_t) ASN1Dec_AuthorityKeyId,
    (ASN1DecFun_t) ASN1Dec_AltNames,
    (ASN1DecFun_t) ASN1Dec_EDIPartyName,
    (ASN1DecFun_t) ASN1Dec_BasicConstraints2,
    (ASN1DecFun_t) ASN1Dec_CertificatePolicies,
    (ASN1DecFun_t) ASN1Dec_CertificatePolicies95,
    (ASN1DecFun_t) ASN1Dec_AuthorityKeyId2,
    (ASN1DecFun_t) ASN1Dec_AuthorityInfoAccess,
    (ASN1DecFun_t) ASN1Dec_CRLDistributionPoints,
    (ASN1DecFun_t) ASN1Dec_ContentInfo,
    (ASN1DecFun_t) ASN1Dec_SeqOfAny,
    (ASN1DecFun_t) ASN1Dec_TimeStampRequest,
    (ASN1DecFun_t) ASN1Dec_ContentInfoOTS,
    (ASN1DecFun_t) ASN1Dec_TimeStampRequestOTS,
    (ASN1DecFun_t) ASN1Dec_EnhancedKeyUsage,
    (ASN1DecFun_t) ASN1Dec_EnrollmentNameValuePair,
    (ASN1DecFun_t) ASN1Dec_CSPProvider,
    (ASN1DecFun_t) ASN1Dec_CertificatePair,
    (ASN1DecFun_t) ASN1Dec_IssuingDistributionPoint,
    (ASN1DecFun_t) ASN1Dec_PolicyMappings,
    (ASN1DecFun_t) ASN1Dec_PolicyConstraints,
    (ASN1DecFun_t) ASN1Dec_CmcAddExtensions,
    (ASN1DecFun_t) ASN1Dec_CmcAddAttributes,
    (ASN1DecFun_t) ASN1Dec_CertificateTemplate,
    (ASN1DecFun_t) ASN1Dec_Attribute,
    (ASN1DecFun_t) ASN1Dec_X942DhParameters,
    (ASN1DecFun_t) ASN1Dec_X942DhOtherInfo,
    (ASN1DecFun_t) ASN1Dec_CertificateToBeSigned,
    (ASN1DecFun_t) ASN1Dec_CertificateRevocationListToBeSigned,
    (ASN1DecFun_t) ASN1Dec_KeyAttributes,
    (ASN1DecFun_t) ASN1Dec_KeyUsageRestriction,
    (ASN1DecFun_t) ASN1Dec_BasicConstraints,
    (ASN1DecFun_t) ASN1Dec_UserNotice,
    (ASN1DecFun_t) ASN1Dec_VerisignQualifier1,
    (ASN1DecFun_t) ASN1Dec_ContentInfoSeqOfAny,
    (ASN1DecFun_t) ASN1Dec_CertificateTrustList,
    (ASN1DecFun_t) ASN1Dec_NameConstraints,
    (ASN1DecFun_t) ASN1Dec_CrossCertDistPoints,
    (ASN1DecFun_t) ASN1Dec_CmcData,
    (ASN1DecFun_t) ASN1Dec_CmcResponseBody,
    (ASN1DecFun_t) ASN1Dec_CmcStatusInfo,
};
static const ASN1FreeFun_t freefntab[64] = {
    (ASN1FreeFun_t) ASN1Free_EncodedObjectID,
    (ASN1FreeFun_t) ASN1Free_Bits,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_HugeIntegerType,
    (ASN1FreeFun_t) ASN1Free_OctetStringType,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_UtcTime,
    (ASN1FreeFun_t) ASN1Free_AnyString,
    (ASN1FreeFun_t) ASN1Free_Name,
    (ASN1FreeFun_t) ASN1Free_Attributes,
    (ASN1FreeFun_t) ASN1Free_RSAPublicKey,
    (ASN1FreeFun_t) ASN1Free_DSSParameters,
    (ASN1FreeFun_t) ASN1Free_DSSSignature,
    (ASN1FreeFun_t) ASN1Free_DHParameters,
    (ASN1FreeFun_t) ASN1Free_RC2CBCParameters,
    (ASN1FreeFun_t) ASN1Free_SMIMECapabilities,
    (ASN1FreeFun_t) ASN1Free_SubjectPublicKeyInfo,
    (ASN1FreeFun_t) ASN1Free_ChoiceOfTime,
    (ASN1FreeFun_t) ASN1Free_Extensions,
    (ASN1FreeFun_t) ASN1Free_SignedContent,
    (ASN1FreeFun_t) ASN1Free_CertificationRequestInfo,
    (ASN1FreeFun_t) ASN1Free_CertificationRequestInfoDecode,
    (ASN1FreeFun_t) ASN1Free_KeygenRequestInfo,
    (ASN1FreeFun_t) ASN1Free_AuthorityKeyId,
    (ASN1FreeFun_t) ASN1Free_AltNames,
    (ASN1FreeFun_t) ASN1Free_EDIPartyName,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_CertificatePolicies,
    (ASN1FreeFun_t) ASN1Free_CertificatePolicies95,
    (ASN1FreeFun_t) ASN1Free_AuthorityKeyId2,
    (ASN1FreeFun_t) ASN1Free_AuthorityInfoAccess,
    (ASN1FreeFun_t) ASN1Free_CRLDistributionPoints,
    (ASN1FreeFun_t) ASN1Free_ContentInfo,
    (ASN1FreeFun_t) ASN1Free_SeqOfAny,
    (ASN1FreeFun_t) ASN1Free_TimeStampRequest,
    (ASN1FreeFun_t) ASN1Free_ContentInfoOTS,
    (ASN1FreeFun_t) ASN1Free_TimeStampRequestOTS,
    (ASN1FreeFun_t) ASN1Free_EnhancedKeyUsage,
    (ASN1FreeFun_t) ASN1Free_EnrollmentNameValuePair,
    (ASN1FreeFun_t) ASN1Free_CSPProvider,
    (ASN1FreeFun_t) ASN1Free_CertificatePair,
    (ASN1FreeFun_t) ASN1Free_IssuingDistributionPoint,
    (ASN1FreeFun_t) ASN1Free_PolicyMappings,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_CmcAddExtensions,
    (ASN1FreeFun_t) ASN1Free_CmcAddAttributes,
    (ASN1FreeFun_t) ASN1Free_CertificateTemplate,
    (ASN1FreeFun_t) ASN1Free_Attribute,
    (ASN1FreeFun_t) ASN1Free_X942DhParameters,
    (ASN1FreeFun_t) ASN1Free_X942DhOtherInfo,
    (ASN1FreeFun_t) ASN1Free_CertificateToBeSigned,
    (ASN1FreeFun_t) ASN1Free_CertificateRevocationListToBeSigned,
    (ASN1FreeFun_t) ASN1Free_KeyAttributes,
    (ASN1FreeFun_t) ASN1Free_KeyUsageRestriction,
    (ASN1FreeFun_t) ASN1Free_BasicConstraints,
    (ASN1FreeFun_t) ASN1Free_UserNotice,
    (ASN1FreeFun_t) ASN1Free_VerisignQualifier1,
    (ASN1FreeFun_t) ASN1Free_ContentInfoSeqOfAny,
    (ASN1FreeFun_t) ASN1Free_CertificateTrustList,
    (ASN1FreeFun_t) ASN1Free_NameConstraints,
    (ASN1FreeFun_t) ASN1Free_CrossCertDistPoints,
    (ASN1FreeFun_t) ASN1Free_CmcData,
    (ASN1FreeFun_t) ASN1Free_CmcResponseBody,
    (ASN1FreeFun_t) ASN1Free_CmcStatusInfo,
};
static const ULONG sizetab[64] = {
    SIZE_X509_Module_PDU_0,
    SIZE_X509_Module_PDU_1,
    SIZE_X509_Module_PDU_2,
    SIZE_X509_Module_PDU_3,
    SIZE_X509_Module_PDU_4,
    SIZE_X509_Module_PDU_5,
    SIZE_X509_Module_PDU_6,
    SIZE_X509_Module_PDU_7,
    SIZE_X509_Module_PDU_8,
    SIZE_X509_Module_PDU_9,
    SIZE_X509_Module_PDU_10,
    SIZE_X509_Module_PDU_11,
    SIZE_X509_Module_PDU_12,
    SIZE_X509_Module_PDU_13,
    SIZE_X509_Module_PDU_14,
    SIZE_X509_Module_PDU_15,
    SIZE_X509_Module_PDU_16,
    SIZE_X509_Module_PDU_17,
    SIZE_X509_Module_PDU_18,
    SIZE_X509_Module_PDU_19,
    SIZE_X509_Module_PDU_20,
    SIZE_X509_Module_PDU_21,
    SIZE_X509_Module_PDU_22,
    SIZE_X509_Module_PDU_23,
    SIZE_X509_Module_PDU_24,
    SIZE_X509_Module_PDU_25,
    SIZE_X509_Module_PDU_26,
    SIZE_X509_Module_PDU_27,
    SIZE_X509_Module_PDU_28,
    SIZE_X509_Module_PDU_29,
    SIZE_X509_Module_PDU_30,
    SIZE_X509_Module_PDU_31,
    SIZE_X509_Module_PDU_32,
    SIZE_X509_Module_PDU_33,
    SIZE_X509_Module_PDU_34,
    SIZE_X509_Module_PDU_35,
    SIZE_X509_Module_PDU_36,
    SIZE_X509_Module_PDU_37,
    SIZE_X509_Module_PDU_38,
    SIZE_X509_Module_PDU_39,
    SIZE_X509_Module_PDU_40,
    SIZE_X509_Module_PDU_41,
    SIZE_X509_Module_PDU_42,
    SIZE_X509_Module_PDU_43,
    SIZE_X509_Module_PDU_44,
    SIZE_X509_Module_PDU_45,
    SIZE_X509_Module_PDU_46,
    SIZE_X509_Module_PDU_47,
    SIZE_X509_Module_PDU_48,
    SIZE_X509_Module_PDU_49,
    SIZE_X509_Module_PDU_50,
    SIZE_X509_Module_PDU_51,
    SIZE_X509_Module_PDU_52,
    SIZE_X509_Module_PDU_53,
    SIZE_X509_Module_PDU_54,
    SIZE_X509_Module_PDU_55,
    SIZE_X509_Module_PDU_56,
    SIZE_X509_Module_PDU_57,
    SIZE_X509_Module_PDU_58,
    SIZE_X509_Module_PDU_59,
    SIZE_X509_Module_PDU_60,
    SIZE_X509_Module_PDU_61,
    SIZE_X509_Module_PDU_62,
    SIZE_X509_Module_PDU_63,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */
ASN1bool_t IssuingDistributionPoint_indirectCRL_default = 0;
ASN1bool_t IssuingDistributionPoint_onlyContainsCACerts_default = 0;
ASN1bool_t IssuingDistributionPoint_onlyContainsUserCerts_default = 0;
BaseDistance GeneralSubtree_minimum_default = 0;
CTLVersion CertificateTrustList_version_default = 0;
ASN1bool_t BasicConstraints2_cA_default = 0;
ASN1bool_t Extension_critical_default = 0;
CertificateVersion CertificateToBeSigned_version_default = 0;

void ASN1CALL X509_Module_Startup(void)
{
    X509_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 64, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x39303578);
}

void ASN1CALL X509_Module_Cleanup(void)
{
    ASN1_CloseModule(X509_Module);
    X509_Module = NULL;
}

static int ASN1CALL ASN1Enc_EncodedObjectID(ASN1encoding_t enc, ASN1uint32_t tag, EncodedObjectID *val)
{
    if (!ASN1BEREncEoid(enc, tag ? tag : 0x6, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncodedObjectID(ASN1decoding_t dec, ASN1uint32_t tag, EncodedObjectID *val)
{
    if (!ASN1BERDecEoid(dec, tag ? tag : 0x6, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncodedObjectID(EncodedObjectID *val)
{
    if (val) {
	ASN1BEREoid_free(val);
    }
}

static int ASN1CALL ASN1Enc_Bits(ASN1encoding_t enc, ASN1uint32_t tag, Bits *val)
{
    if (!ASN1DEREncBitString(enc, tag ? tag : 0x3, (val)->length, (val)->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Bits(ASN1decoding_t dec, ASN1uint32_t tag, Bits *val)
{
    if (!ASN1BERDecBitString2(dec, tag ? tag : 0x3, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Bits(Bits *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_IntegerType(ASN1encoding_t enc, ASN1uint32_t tag, IntegerType *val)
{
    if (!ASN1BEREncS32(enc, tag ? tag : 0x2, *val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IntegerType(ASN1decoding_t dec, ASN1uint32_t tag, IntegerType *val)
{
    if (!ASN1BERDecS32Val(dec, tag ? tag : 0x2, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_HugeIntegerType(ASN1encoding_t enc, ASN1uint32_t tag, HugeIntegerType *val)
{
    if (!ASN1BEREncSX(enc, tag ? tag : 0x2, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_HugeIntegerType(ASN1decoding_t dec, ASN1uint32_t tag, HugeIntegerType *val)
{
    if (!ASN1BERDecSXVal(dec, tag ? tag : 0x2, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_HugeIntegerType(HugeIntegerType *val)
{
    if (val) {
	ASN1intx_free(val);
    }
}

static int ASN1CALL ASN1Enc_OctetStringType(ASN1encoding_t enc, ASN1uint32_t tag, OctetStringType *val)
{
    if (!ASN1DEREncOctetString(enc, tag ? tag : 0x4, (val)->length, (val)->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OctetStringType(ASN1decoding_t dec, ASN1uint32_t tag, OctetStringType *val)
{
    if (!ASN1BERDecOctetString2(dec, tag ? tag : 0x4, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OctetStringType(OctetStringType *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_EnumeratedType(ASN1encoding_t enc, ASN1uint32_t tag, EnumeratedType *val)
{
    if (!ASN1BEREncU32(enc, tag ? tag : 0xa, *val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnumeratedType(ASN1decoding_t dec, ASN1uint32_t tag, EnumeratedType *val)
{
    if (!ASN1BERDecU32Val(dec, tag ? tag : 0xa, (ASN1uint32_t *) val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_UtcTime(ASN1encoding_t enc, ASN1uint32_t tag, UtcTime *val)
{
    if (!ASN1DEREncUTCTime(enc, tag ? tag : 0x17, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UtcTime(ASN1decoding_t dec, ASN1uint32_t tag, UtcTime *val)
{
    if (!ASN1BERDecUTCTime(dec, tag ? tag : 0x17, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UtcTime(UtcTime *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_NoticeReference_noticeNumbers(ASN1encoding_t enc, ASN1uint32_t tag, NoticeReference_noticeNumbers *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncS32(enc, 0x2, ((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NoticeReference_noticeNumbers(ASN1decoding_t dec, ASN1uint32_t tag, NoticeReference_noticeNumbers *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (NoticeReference_noticeNumbers_Seq *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecS32Val(dd, 0x2, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NoticeReference_noticeNumbers(NoticeReference_noticeNumbers *val)
{
    if (val) {
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AnyString(ASN1encoding_t enc, ASN1uint32_t tag, AnyString *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->u.octetString).length, ((val)->u.octetString).value))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncUTF8String(enc, 0xc, ((val)->u.utf8String).length, ((val)->u.utf8String).value))
	    return 0;
	break;
    case 3:
	if (!ASN1DEREncCharString(enc, 0x12, ((val)->u.numericString).length, ((val)->u.numericString).value))
	    return 0;
	break;
    case 4:
	if (!ASN1DEREncCharString(enc, 0x13, ((val)->u.printableString).length, ((val)->u.printableString).value))
	    return 0;
	break;
    case 5:
	if (!ASN1DEREncMultibyteString(enc, 0x14, &(val)->u.teletexString))
	    return 0;
	break;
    case 6:
	if (!ASN1DEREncMultibyteString(enc, 0x15, &(val)->u.videotexString))
	    return 0;
	break;
    case 7:
	if (!ASN1DEREncCharString(enc, 0x16, ((val)->u.ia5String).length, ((val)->u.ia5String).value))
	    return 0;
	break;
    case 8:
	if (!ASN1DEREncCharString(enc, 0x19, ((val)->u.graphicString).length, ((val)->u.graphicString).value))
	    return 0;
	break;
    case 9:
	if (!ASN1DEREncCharString(enc, 0x1a, ((val)->u.visibleString).length, ((val)->u.visibleString).value))
	    return 0;
	break;
    case 10:
	if (!ASN1DEREncCharString(enc, 0x1b, ((val)->u.generalString).length, ((val)->u.generalString).value))
	    return 0;
	break;
    case 11:
	if (!ASN1DEREncChar32String(enc, 0x1c, ((val)->u.universalString).length, ((val)->u.universalString).value))
	    return 0;
	break;
    case 12:
	if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->u.bmpString).length, ((val)->u.bmpString).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AnyString(ASN1decoding_t dec, ASN1uint32_t tag, AnyString *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x4:
	(val)->choice = 1;
	if (!ASN1BERDecOctetString2(dec, 0x4, &(val)->u.octetString))
	    return 0;
	break;
    case 0xc:
	(val)->choice = 2;
	if (!ASN1BERDecUTF8String(dec, 0xc, &(val)->u.utf8String))
	    return 0;
	break;
    case 0x12:
	(val)->choice = 3;
	if (!ASN1BERDecCharString(dec, 0x12, &(val)->u.numericString))
	    return 0;
	break;
    case 0x13:
	(val)->choice = 4;
	if (!ASN1BERDecCharString(dec, 0x13, &(val)->u.printableString))
	    return 0;
	break;
    case 0x14:
	(val)->choice = 5;
	if (!ASN1BERDecMultibyteString(dec, 0x14, &(val)->u.teletexString))
	    return 0;
	break;
    case 0x15:
	(val)->choice = 6;
	if (!ASN1BERDecMultibyteString(dec, 0x15, &(val)->u.videotexString))
	    return 0;
	break;
    case 0x16:
	(val)->choice = 7;
	if (!ASN1BERDecCharString(dec, 0x16, &(val)->u.ia5String))
	    return 0;
	break;
    case 0x19:
	(val)->choice = 8;
	if (!ASN1BERDecCharString(dec, 0x19, &(val)->u.graphicString))
	    return 0;
	break;
    case 0x1a:
	(val)->choice = 9;
	if (!ASN1BERDecCharString(dec, 0x1a, &(val)->u.visibleString))
	    return 0;
	break;
    case 0x1b:
	(val)->choice = 10;
	if (!ASN1BERDecCharString(dec, 0x1b, &(val)->u.generalString))
	    return 0;
	break;
    case 0x1c:
	(val)->choice = 11;
	if (!ASN1BERDecChar32String(dec, 0x1c, &(val)->u.universalString))
	    return 0;
	break;
    case 0x1e:
	(val)->choice = 12;
	if (!ASN1BERDecChar16String(dec, 0x1e, &(val)->u.bmpString))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AnyString(AnyString *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    break;
	case 2:
	    ASN1utf8string_free(&(val)->u.utf8String);
	    break;
	case 3:
	    ASN1charstring_free(&(val)->u.numericString);
	    break;
	case 4:
	    ASN1charstring_free(&(val)->u.printableString);
	    break;
	case 5:
	    ASN1charstring_free(&(val)->u.teletexString);
	    break;
	case 6:
	    ASN1charstring_free(&(val)->u.videotexString);
	    break;
	case 7:
	    ASN1charstring_free(&(val)->u.ia5String);
	    break;
	case 8:
	    ASN1charstring_free(&(val)->u.graphicString);
	    break;
	case 9:
	    ASN1charstring_free(&(val)->u.visibleString);
	    break;
	case 10:
	    ASN1charstring_free(&(val)->u.generalString);
	    break;
	case 11:
	    ASN1char32string_free(&(val)->u.universalString);
	    break;
	case 12:
	    ASN1char16string_free(&(val)->u.bmpString);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->algorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->algorithm))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->algorithm);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_Name(ASN1encoding_t enc, ASN1uint32_t tag, Name *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_RelativeDistinguishedName(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Name(ASN1decoding_t dec, ASN1uint32_t tag, Name *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (RelativeDistinguishedName *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_RelativeDistinguishedName(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Name(Name *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_RelativeDistinguishedName(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_RelativeDistinguishedName(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_RelativeDistinguishedName(ASN1encoding_t enc, ASN1uint32_t tag, RelativeDistinguishedName *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_AttributeTypeValue(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RelativeDistinguishedName(ASN1decoding_t dec, ASN1uint32_t tag, RelativeDistinguishedName *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (AttributeTypeValue *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_AttributeTypeValue(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RelativeDistinguishedName(RelativeDistinguishedName *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_AttributeTypeValue(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_AttributeTypeValue(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AttributeTypeValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeTypeValue *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->type))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributeTypeValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeTypeValue *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->type))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->value))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributeTypeValue(AttributeTypeValue *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_AttributeSetValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValue *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributeSetValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValue *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (NOCOPYANY *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributeSetValue(AttributeSetValue *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_Attribute(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (Attribute *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_Attribute(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Attributes(Attributes *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_Attribute(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_Attribute(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_RSAPublicKey(ASN1encoding_t enc, ASN1uint32_t tag, RSAPublicKey *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->modulus))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->publicExponent))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RSAPublicKey(ASN1decoding_t dec, ASN1uint32_t tag, RSAPublicKey *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->modulus))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->publicExponent))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RSAPublicKey(RSAPublicKey *val)
{
    if (val) {
	ASN1intx_free(&(val)->modulus);
    }
}

static int ASN1CALL ASN1Enc_DSSParameters(ASN1encoding_t enc, ASN1uint32_t tag, DSSParameters *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->p))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->q))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->g))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DSSParameters(ASN1decoding_t dec, ASN1uint32_t tag, DSSParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->p))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->q))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->g))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DSSParameters(DSSParameters *val)
{
    if (val) {
	ASN1intx_free(&(val)->p);
	ASN1intx_free(&(val)->q);
	ASN1intx_free(&(val)->g);
    }
}

static int ASN1CALL ASN1Enc_DSSSignature(ASN1encoding_t enc, ASN1uint32_t tag, DSSSignature *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->r))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->s))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DSSSignature(ASN1decoding_t dec, ASN1uint32_t tag, DSSSignature *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->r))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->s))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DSSSignature(DSSSignature *val)
{
    if (val) {
	ASN1intx_free(&(val)->r);
	ASN1intx_free(&(val)->s);
    }
}

static int ASN1CALL ASN1Enc_DHParameters(ASN1encoding_t enc, ASN1uint32_t tag, DHParameters *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->p))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->g))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncSX(enc, 0x2, &(val)->privateValueLength))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DHParameters(ASN1decoding_t dec, ASN1uint32_t tag, DHParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->p))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->g))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecSXVal(dd, 0x2, &(val)->privateValueLength))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DHParameters(DHParameters *val)
{
    if (val) {
	ASN1intx_free(&(val)->p);
	ASN1intx_free(&(val)->g);
	if ((val)->o[0] & 0x80) {
	    ASN1intx_free(&(val)->privateValueLength);
	}
    }
}

static int ASN1CALL ASN1Enc_X942DhValidationParams(ASN1encoding_t enc, ASN1uint32_t tag, X942DhValidationParams *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->seed).length, ((val)->seed).value))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->pgenCounter))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_X942DhValidationParams(ASN1decoding_t dec, ASN1uint32_t tag, X942DhValidationParams *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecBitString2(dd, 0x3, &(val)->seed))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->pgenCounter))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_X942DhValidationParams(X942DhValidationParams *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_X942DhKeySpecificInfo(ASN1encoding_t enc, ASN1uint32_t tag, X942DhKeySpecificInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->algorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->counter).length, ((val)->counter).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_X942DhKeySpecificInfo(ASN1decoding_t dec, ASN1uint32_t tag, X942DhKeySpecificInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->algorithm))
	return 0;
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->counter))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_X942DhKeySpecificInfo(X942DhKeySpecificInfo *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->algorithm);
    }
}

static int ASN1CALL ASN1Enc_RC2CBCParameters(ASN1encoding_t enc, ASN1uint32_t tag, RC2CBCParameters *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->iv).length, ((val)->iv).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RC2CBCParameters(ASN1decoding_t dec, ASN1uint32_t tag, RC2CBCParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x4) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->iv))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RC2CBCParameters(RC2CBCParameters *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_SMIMECapability(ASN1encoding_t enc, ASN1uint32_t tag, SMIMECapability *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->capabilityID))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->smimeParameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SMIMECapability(ASN1decoding_t dec, ASN1uint32_t tag, SMIMECapability *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->capabilityID))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->smimeParameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SMIMECapability(SMIMECapability *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->capabilityID);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_SMIMECapabilities(ASN1encoding_t enc, ASN1uint32_t tag, SMIMECapabilities *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_SMIMECapability(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SMIMECapabilities(ASN1decoding_t dec, ASN1uint32_t tag, SMIMECapabilities *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (SMIMECapability *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_SMIMECapability(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SMIMECapabilities(SMIMECapabilities *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_SMIMECapability(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_SMIMECapability(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SubjectPublicKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, SubjectPublicKeyInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->algorithm))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->subjectPublicKey).length, ((val)->subjectPublicKey).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SubjectPublicKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, SubjectPublicKeyInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->algorithm))
	return 0;
    if (!ASN1BERDecBitString2(dd, 0x3, &(val)->subjectPublicKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SubjectPublicKeyInfo(SubjectPublicKeyInfo *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(&(val)->algorithm);
    }
}

static int ASN1CALL ASN1Enc_ChoiceOfTime(ASN1encoding_t enc, ASN1uint32_t tag, ChoiceOfTime *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1DEREncUTCTime(enc, 0x17, &(val)->u.utcTime))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->u.generalTime))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ChoiceOfTime(ASN1decoding_t dec, ASN1uint32_t tag, ChoiceOfTime *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x17:
	(val)->choice = 1;
	if (!ASN1BERDecUTCTime(dec, 0x17, &(val)->u.utcTime))
	    return 0;
	break;
    case 0x18:
	(val)->choice = 2;
	if (!ASN1BERDecGeneralizedTime(dec, 0x18, &(val)->u.generalTime))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ChoiceOfTime(ChoiceOfTime *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    break;
	case 2:
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_Validity(ASN1encoding_t enc, ASN1uint32_t tag, Validity *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_ChoiceOfTime(enc, 0, &(val)->notBefore))
	return 0;
    if (!ASN1Enc_ChoiceOfTime(enc, 0, &(val)->notAfter))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Validity(ASN1decoding_t dec, ASN1uint32_t tag, Validity *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_ChoiceOfTime(dd, 0, &(val)->notBefore))
	return 0;
    if (!ASN1Dec_ChoiceOfTime(dd, 0, &(val)->notAfter))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Validity(Validity *val)
{
    if (val) {
	ASN1Free_ChoiceOfTime(&(val)->notBefore);
	ASN1Free_ChoiceOfTime(&(val)->notAfter);
    }
}

static int ASN1CALL ASN1Enc_Extensions(ASN1encoding_t enc, ASN1uint32_t tag, Extensions *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_Extension(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Extensions(ASN1decoding_t dec, ASN1uint32_t tag, Extensions *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (Extension *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_Extension(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Extensions(Extensions *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_Extension(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_Extension(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_Extension(ASN1encoding_t enc, ASN1uint32_t tag, Extension *val)
{
    ASN1uint32_t nLenOff;
    ASN1octet_t o[1];
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    CopyMemory(o, (val)->o, 1);
    if (!(val)->critical)
	o[0] &= ~0x80;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->extnId))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1BEREncBool(enc, 0x1, (val)->critical))
	    return 0;
    }
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->extnValue).length, ((val)->extnValue).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Extension(ASN1decoding_t dec, ASN1uint32_t tag, Extension *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->extnId))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x1) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecBool(dd, 0x1, &(val)->critical))
	    return 0;
    }
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->extnValue))
	return 0;
    if (!((val)->o[0] & 0x80))
	(val)->critical = 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Extension(Extension *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->extnId);
    }
}

static int ASN1CALL ASN1Enc_SignedContent(ASN1encoding_t enc, ASN1uint32_t tag, SignedContent *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->toBeSigned))
	return 0;
    if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->algorithm))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->signature).length, ((val)->signature).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignedContent(ASN1decoding_t dec, ASN1uint32_t tag, SignedContent *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->toBeSigned))
	return 0;
    if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->algorithm))
	return 0;
    if (!ASN1BERDecBitString2(dd, 0x3, &(val)->signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignedContent(SignedContent *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(&(val)->algorithm);
    }
}

static int ASN1CALL ASN1Enc_RevokedCertificates(ASN1encoding_t enc, ASN1uint32_t tag, RevokedCertificates *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_CRLEntry(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RevokedCertificates(ASN1decoding_t dec, ASN1uint32_t tag, RevokedCertificates *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (CRLEntry *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_CRLEntry(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RevokedCertificates(RevokedCertificates *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_CRLEntry(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_CRLEntry(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_CRLEntry(ASN1encoding_t enc, ASN1uint32_t tag, CRLEntry *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->userCertificate))
	return 0;
    if (!ASN1Enc_ChoiceOfTime(enc, 0, &(val)->revocationDate))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Extensions(enc, 0, &(val)->crlEntryExtensions))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CRLEntry(ASN1decoding_t dec, ASN1uint32_t tag, CRLEntry *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->userCertificate))
	return 0;
    if (!ASN1Dec_ChoiceOfTime(dd, 0, &(val)->revocationDate))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Extensions(dd, 0, &(val)->crlEntryExtensions))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CRLEntry(CRLEntry *val)
{
    if (val) {
	ASN1intx_free(&(val)->userCertificate);
	ASN1Free_ChoiceOfTime(&(val)->revocationDate);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Extensions(&(val)->crlEntryExtensions);
	}
    }
}

static int ASN1CALL ASN1Enc_CertificationRequestInfo(ASN1encoding_t enc, ASN1uint32_t tag, CertificationRequestInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->subject))
	return 0;
    if (!ASN1Enc_SubjectPublicKeyInfo(enc, 0, &(val)->subjectPublicKeyInfo))
	return 0;
    if (!ASN1Enc_Attributes(enc, 0x80000000, &(val)->attributes))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificationRequestInfo(ASN1decoding_t dec, ASN1uint32_t tag, CertificationRequestInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->subject))
	return 0;
    if (!ASN1Dec_SubjectPublicKeyInfo(dd, 0, &(val)->subjectPublicKeyInfo))
	return 0;
    if (!ASN1Dec_Attributes(dd, 0x80000000, &(val)->attributes))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificationRequestInfo(CertificationRequestInfo *val)
{
    if (val) {
	ASN1Free_SubjectPublicKeyInfo(&(val)->subjectPublicKeyInfo);
	ASN1Free_Attributes(&(val)->attributes);
    }
}

static int ASN1CALL ASN1Enc_CertificationRequestInfoDecode(ASN1encoding_t enc, ASN1uint32_t tag, CertificationRequestInfoDecode *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->subject))
	return 0;
    if (!ASN1Enc_SubjectPublicKeyInfo(enc, 0, &(val)->subjectPublicKeyInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Attributes(enc, 0x80000000, &(val)->attributes))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificationRequestInfoDecode(ASN1decoding_t dec, ASN1uint32_t tag, CertificationRequestInfoDecode *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->subject))
	return 0;
    if (!ASN1Dec_SubjectPublicKeyInfo(dd, 0, &(val)->subjectPublicKeyInfo))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Attributes(dd, 0x80000000, &(val)->attributes))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificationRequestInfoDecode(CertificationRequestInfoDecode *val)
{
    if (val) {
	ASN1Free_SubjectPublicKeyInfo(&(val)->subjectPublicKeyInfo);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Attributes(&(val)->attributes);
	}
    }
}

static int ASN1CALL ASN1Enc_KeygenRequestInfo(ASN1encoding_t enc, ASN1uint32_t tag, KeygenRequestInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_SubjectPublicKeyInfo(enc, 0, &(val)->subjectPublicKeyInfo))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x16, ((val)->challenge).length, ((val)->challenge).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KeygenRequestInfo(ASN1decoding_t dec, ASN1uint32_t tag, KeygenRequestInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_SubjectPublicKeyInfo(dd, 0, &(val)->subjectPublicKeyInfo))
	return 0;
    if (!ASN1BERDecCharString(dd, 0x16, &(val)->challenge))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KeygenRequestInfo(KeygenRequestInfo *val)
{
    if (val) {
	ASN1Free_SubjectPublicKeyInfo(&(val)->subjectPublicKeyInfo);
	ASN1charstring_free(&(val)->challenge);
    }
}

static int ASN1CALL ASN1Enc_AuthorityKeyId(ASN1encoding_t enc, ASN1uint32_t tag, AuthorityKeyId *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->keyIdentifier).length, ((val)->keyIdentifier).value))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncOpenType(enc, &(val)->certIssuer))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncSX(enc, 0x80000002, &(val)->certSerialNumber))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AuthorityKeyId(ASN1decoding_t dec, ASN1uint32_t tag, AuthorityKeyId *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOctetString2(dd, 0x80000000, &(val)->keyIdentifier))
	    return 0;
    }
    if (ASN1BERDecPeekTag(dd, &t)) {
	if (t == 0x80000001) {
	    (val)->o[0] |= 0x40;
	    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
		return 0;
	    if (!ASN1BERDecOpenType2(dd0, &(val)->certIssuer))
		return 0;
	    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
		return 0;
	}
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecSXVal(dd, 0x80000002, &(val)->certSerialNumber))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AuthorityKeyId(AuthorityKeyId *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	    ASN1intx_free(&(val)->certSerialNumber);
	}
    }
}

static int ASN1CALL ASN1Enc_PrivateKeyValidity(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyValidity *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncGeneralizedTime(enc, 0x80000000, &(val)->notBefore))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1DEREncGeneralizedTime(enc, 0x80000001, &(val)->notAfter))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateKeyValidity(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyValidity *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecGeneralizedTime(dd, 0x80000000, &(val)->notBefore))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecGeneralizedTime(dd, 0x80000001, &(val)->notAfter))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivateKeyValidity(PrivateKeyValidity *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_CertPolicySet(ASN1encoding_t enc, ASN1uint32_t tag, CertPolicySet *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_CertPolicyId(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertPolicySet(ASN1decoding_t dec, ASN1uint32_t tag, CertPolicySet *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (CertPolicyId *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_CertPolicyId(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertPolicySet(CertPolicySet *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_CertPolicyId(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_CertPolicyId(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_CertPolicyId(ASN1encoding_t enc, ASN1uint32_t tag, CertPolicyId *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncEoid(enc, 0x6, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertPolicyId(ASN1decoding_t dec, ASN1uint32_t tag, CertPolicyId *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (CertPolicyElementId *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecEoid(dd, 0x6, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertPolicyId(CertPolicyId *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1BEREoid_free(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1BEREoid_free(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AltNames(ASN1encoding_t enc, ASN1uint32_t tag, AltNames *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_GeneralName(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AltNames(ASN1decoding_t dec, ASN1uint32_t tag, AltNames *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (GeneralName *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_GeneralName(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AltNames(AltNames *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_GeneralName(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_GeneralName(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_GeneralNames(ASN1encoding_t enc, ASN1uint32_t tag, GeneralNames *val)
{
    if (!ASN1Enc_AltNames(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GeneralNames(ASN1decoding_t dec, ASN1uint32_t tag, GeneralNames *val)
{
    if (!ASN1Dec_AltNames(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GeneralNames(GeneralNames *val)
{
    if (val) {
	ASN1Free_AltNames(val);
    }
}

static int ASN1CALL ASN1Enc_OtherName(ASN1encoding_t enc, ASN1uint32_t tag, OtherName *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->type))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OtherName(ASN1decoding_t dec, ASN1uint32_t tag, OtherName *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->type))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOpenType2(dd0, &(val)->value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OtherName(OtherName *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_EDIPartyName(ASN1encoding_t enc, ASN1uint32_t tag, EDIPartyName *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1BEREncOpenType(enc, &(val)->nameAssigner))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->partyName))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EDIPartyName(ASN1decoding_t dec, ASN1uint32_t tag, EDIPartyName *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (ASN1BERDecPeekTag(dd, &t)) {
	if (t == 0x80000000) {
	    (val)->o[0] |= 0x80;
	    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
		return 0;
	    if (!ASN1BERDecOpenType2(dd0, &(val)->nameAssigner))
		return 0;
	    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
		return 0;
	}
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOpenType2(dd0, &(val)->partyName))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EDIPartyName(EDIPartyName *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_SubtreesConstraint(ASN1encoding_t enc, ASN1uint32_t tag, SubtreesConstraint *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncOpenType(enc, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SubtreesConstraint(ASN1decoding_t dec, ASN1uint32_t tag, SubtreesConstraint *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (NOCOPYANY *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SubtreesConstraint(SubtreesConstraint *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_BasicConstraints2(ASN1encoding_t enc, ASN1uint32_t tag, BasicConstraints2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1octet_t o[1];
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    CopyMemory(o, (val)->o, 1);
    if (!(val)->cA)
	o[0] &= ~0x80;
    if (o[0] & 0x80) {
	if (!ASN1BEREncBool(enc, 0x1, (val)->cA))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1BEREncS32(enc, 0x2, (val)->pathLenConstraint))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BasicConstraints2(ASN1decoding_t dec, ASN1uint32_t tag, BasicConstraints2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x1) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecBool(dd, 0x1, &(val)->cA))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecS32Val(dd, 0x2, &(val)->pathLenConstraint))
	    return 0;
    }
    if (!((val)->o[0] & 0x80))
	(val)->cA = 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CertificatePolicies(ASN1encoding_t enc, ASN1uint32_t tag, CertificatePolicies *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_PolicyInformation(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificatePolicies(ASN1decoding_t dec, ASN1uint32_t tag, CertificatePolicies *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (PolicyInformation *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_PolicyInformation(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificatePolicies(CertificatePolicies *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_PolicyInformation(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_PolicyInformation(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_PolicyQualifiers(ASN1encoding_t enc, ASN1uint32_t tag, PolicyQualifiers *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_PolicyQualifierInfo(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PolicyQualifiers(ASN1decoding_t dec, ASN1uint32_t tag, PolicyQualifiers *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (PolicyQualifierInfo *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_PolicyQualifierInfo(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PolicyQualifiers(PolicyQualifiers *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_PolicyQualifierInfo(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_PolicyQualifierInfo(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_PolicyQualifierInfo(ASN1encoding_t enc, ASN1uint32_t tag, PolicyQualifierInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->policyQualifierId))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->qualifier))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PolicyQualifierInfo(ASN1decoding_t dec, ASN1uint32_t tag, PolicyQualifierInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->policyQualifierId))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->qualifier))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PolicyQualifierInfo(PolicyQualifierInfo *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->policyQualifierId);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_NoticeReference(ASN1encoding_t enc, ASN1uint32_t tag, NoticeReference *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    t = lstrlenA((val)->organization);
    if (!ASN1DEREncCharString(enc, 0x16, t, (val)->organization))
	return 0;
    if (!ASN1Enc_NoticeReference_noticeNumbers(enc, 0, &(val)->noticeNumbers))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NoticeReference(ASN1decoding_t dec, ASN1uint32_t tag, NoticeReference *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecZeroCharString(dd, 0x16, &(val)->organization))
	return 0;
    if (!ASN1Dec_NoticeReference_noticeNumbers(dd, 0, &(val)->noticeNumbers))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NoticeReference(NoticeReference *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->organization);
	ASN1Free_NoticeReference_noticeNumbers(&(val)->noticeNumbers);
    }
}

static int ASN1CALL ASN1Enc_DisplayText(ASN1encoding_t enc, ASN1uint32_t tag, DisplayText *val)
{
    ASN1uint32_t t;
    switch ((val)->choice) {
    case 1:
	t = lstrlenA((val)->u.theVisibleString);
	if (!ASN1DEREncCharString(enc, 0x1a, t, (val)->u.theVisibleString))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->u.theBMPString).length, ((val)->u.theBMPString).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DisplayText(ASN1decoding_t dec, ASN1uint32_t tag, DisplayText *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x1a:
	(val)->choice = 1;
	if (!ASN1BERDecZeroCharString(dec, 0x1a, &(val)->u.theVisibleString))
	    return 0;
	break;
    case 0x1e:
	(val)->choice = 2;
	if (!ASN1BERDecChar16String(dec, 0x1e, &(val)->u.theBMPString))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DisplayText(DisplayText *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1ztcharstring_free((val)->u.theVisibleString);
	    break;
	case 2:
	    ASN1char16string_free(&(val)->u.theBMPString);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CertificatePolicies95(ASN1encoding_t enc, ASN1uint32_t tag, CertificatePolicies95 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_PolicyQualifiers(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificatePolicies95(ASN1decoding_t dec, ASN1uint32_t tag, CertificatePolicies95 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (PolicyQualifiers *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_PolicyQualifiers(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificatePolicies95(CertificatePolicies95 *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_PolicyQualifiers(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_PolicyQualifiers(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_CpsURLs(ASN1encoding_t enc, ASN1uint32_t tag, CpsURLs *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_CpsURLs_Seq(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CpsURLs(ASN1decoding_t dec, ASN1uint32_t tag, CpsURLs *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (CpsURLs_Seq *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_CpsURLs_Seq(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CpsURLs(CpsURLs *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_CpsURLs_Seq(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_CpsURLs_Seq(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AuthorityKeyId2(ASN1encoding_t enc, ASN1uint32_t tag, AuthorityKeyId2 *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->keyIdentifier).length, ((val)->keyIdentifier).value))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_GeneralNames(enc, 0x80000001, &(val)->authorityCertIssuer))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncSX(enc, 0x80000002, &(val)->authorityCertSerialNumber))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AuthorityKeyId2(ASN1decoding_t dec, ASN1uint32_t tag, AuthorityKeyId2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOctetString2(dd, 0x80000000, &(val)->keyIdentifier))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_GeneralNames(dd, 0x80000001, &(val)->authorityCertIssuer))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecSXVal(dd, 0x80000002, &(val)->authorityCertSerialNumber))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AuthorityKeyId2(AuthorityKeyId2 *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_GeneralNames(&(val)->authorityCertIssuer);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1intx_free(&(val)->authorityCertSerialNumber);
	}
    }
}

static int ASN1CALL ASN1Enc_AuthorityInfoAccess(ASN1encoding_t enc, ASN1uint32_t tag, AuthorityInfoAccess *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_AccessDescription(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AuthorityInfoAccess(ASN1decoding_t dec, ASN1uint32_t tag, AuthorityInfoAccess *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (AccessDescription *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_AccessDescription(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AuthorityInfoAccess(AuthorityInfoAccess *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_AccessDescription(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_AccessDescription(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_CRLDistributionPoints(ASN1encoding_t enc, ASN1uint32_t tag, CRLDistributionPoints *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_DistributionPoint(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CRLDistributionPoints(ASN1decoding_t dec, ASN1uint32_t tag, CRLDistributionPoints *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (DistributionPoint *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_DistributionPoint(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CRLDistributionPoints(CRLDistributionPoints *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_DistributionPoint(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_DistributionPoint(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_DistributionPointName(ASN1encoding_t enc, ASN1uint32_t tag, DistributionPointName *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_GeneralNames(enc, 0x80000000, &(val)->u.fullName))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_RelativeDistinguishedName(enc, 0x80000001, &(val)->u.nameRelativeToCRLIssuer))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DistributionPointName(ASN1decoding_t dec, ASN1uint32_t tag, DistributionPointName *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1Dec_GeneralNames(dec, 0x80000000, &(val)->u.fullName))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1Dec_RelativeDistinguishedName(dec, 0x80000001, &(val)->u.nameRelativeToCRLIssuer))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DistributionPointName(DistributionPointName *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_GeneralNames(&(val)->u.fullName);
	    break;
	case 2:
	    ASN1Free_RelativeDistinguishedName(&(val)->u.nameRelativeToCRLIssuer);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfo *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->contentType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1BEREncOpenType(enc, &(val)->content))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->contentType))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	if (t == 0x80000000) {
	    (val)->o[0] |= 0x80;
	    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
		return 0;
	    if (!ASN1BERDecOpenType2(dd0, &(val)->content))
		return 0;
	    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
		return 0;
	}
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentInfo(ContentInfo *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->contentType);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_SeqOfAny(ASN1encoding_t enc, ASN1uint32_t tag, SeqOfAny *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncOpenType(enc, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SeqOfAny(ASN1decoding_t dec, ASN1uint32_t tag, SeqOfAny *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (NOCOPYANY *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SeqOfAny(SeqOfAny *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_TimeStampRequest(ASN1encoding_t enc, ASN1uint32_t tag, TimeStampRequest *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->timeStampAlgorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Attributes(enc, 0, &(val)->attributesTS))
	    return 0;
    }
    if (!ASN1Enc_ContentInfo(enc, 0, &(val)->content))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TimeStampRequest(ASN1decoding_t dec, ASN1uint32_t tag, TimeStampRequest *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->timeStampAlgorithm))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x11) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Attributes(dd, 0, &(val)->attributesTS))
	    return 0;
    }
    if (!ASN1Dec_ContentInfo(dd, 0, &(val)->content))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TimeStampRequest(TimeStampRequest *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->timeStampAlgorithm);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Attributes(&(val)->attributesTS);
	}
	ASN1Free_ContentInfo(&(val)->content);
    }
}

static int ASN1CALL ASN1Enc_ContentInfoOTS(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfoOTS *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->contentTypeOTS))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->contentOTS).length, ((val)->contentOTS).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentInfoOTS(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfoOTS *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->contentTypeOTS))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString2(dd0, 0x4, &(val)->contentOTS))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentInfoOTS(ContentInfoOTS *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->contentTypeOTS);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_TimeStampRequestOTS(ASN1encoding_t enc, ASN1uint32_t tag, TimeStampRequestOTS *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->timeStampAlgorithmOTS))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Attributes(enc, 0, &(val)->attributesOTS))
	    return 0;
    }
    if (!ASN1Enc_ContentInfoOTS(enc, 0, &(val)->contentOTS))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TimeStampRequestOTS(ASN1decoding_t dec, ASN1uint32_t tag, TimeStampRequestOTS *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->timeStampAlgorithmOTS))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x11) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Attributes(dd, 0, &(val)->attributesOTS))
	    return 0;
    }
    if (!ASN1Dec_ContentInfoOTS(dd, 0, &(val)->contentOTS))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TimeStampRequestOTS(TimeStampRequestOTS *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->timeStampAlgorithmOTS);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Attributes(&(val)->attributesOTS);
	}
	ASN1Free_ContentInfoOTS(&(val)->contentOTS);
    }
}

static int ASN1CALL ASN1Enc_EnhancedKeyUsage(ASN1encoding_t enc, ASN1uint32_t tag, EnhancedKeyUsage *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncEoid(enc, 0x6, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancedKeyUsage(ASN1decoding_t dec, ASN1uint32_t tag, EnhancedKeyUsage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (UsageIdentifier *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecEoid(dd, 0x6, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnhancedKeyUsage(EnhancedKeyUsage *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1BEREoid_free(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1BEREoid_free(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SubjectUsage(ASN1encoding_t enc, ASN1uint32_t tag, SubjectUsage *val)
{
    if (!ASN1Enc_EnhancedKeyUsage(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SubjectUsage(ASN1decoding_t dec, ASN1uint32_t tag, SubjectUsage *val)
{
    if (!ASN1Dec_EnhancedKeyUsage(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SubjectUsage(SubjectUsage *val)
{
    if (val) {
	ASN1Free_EnhancedKeyUsage(val);
    }
}

static int ASN1CALL ASN1Enc_TrustedSubjects(ASN1encoding_t enc, ASN1uint32_t tag, TrustedSubjects *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_TrustedSubject(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TrustedSubjects(ASN1decoding_t dec, ASN1uint32_t tag, TrustedSubjects *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (TrustedSubject *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_TrustedSubject(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TrustedSubjects(TrustedSubjects *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_TrustedSubject(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_TrustedSubject(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_TrustedSubject(ASN1encoding_t enc, ASN1uint32_t tag, TrustedSubject *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->subjectIdentifier).length, ((val)->subjectIdentifier).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Attributes(enc, 0, &(val)->subjectAttributes))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TrustedSubject(ASN1decoding_t dec, ASN1uint32_t tag, TrustedSubject *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->subjectIdentifier))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x11) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Attributes(dd, 0, &(val)->subjectAttributes))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TrustedSubject(TrustedSubject *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Attributes(&(val)->subjectAttributes);
	}
    }
}

static int ASN1CALL ASN1Enc_EnrollmentNameValuePair(ASN1encoding_t enc, ASN1uint32_t tag, EnrollmentNameValuePair *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->name).length, ((val)->name).value))
	return 0;
    if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->value).length, ((val)->value).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnrollmentNameValuePair(ASN1decoding_t dec, ASN1uint32_t tag, EnrollmentNameValuePair *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecChar16String(dd, 0x1e, &(val)->name))
	return 0;
    if (!ASN1BERDecChar16String(dd, 0x1e, &(val)->value))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnrollmentNameValuePair(EnrollmentNameValuePair *val)
{
    if (val) {
	ASN1char16string_free(&(val)->name);
	ASN1char16string_free(&(val)->value);
    }
}

static int ASN1CALL ASN1Enc_CSPProvider(ASN1encoding_t enc, ASN1uint32_t tag, CSPProvider *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->keySpec))
	return 0;
    if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->cspName).length, ((val)->cspName).value))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->signature).length, ((val)->signature).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CSPProvider(ASN1decoding_t dec, ASN1uint32_t tag, CSPProvider *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->keySpec))
	return 0;
    if (!ASN1BERDecChar16String(dd, 0x1e, &(val)->cspName))
	return 0;
    if (!ASN1BERDecBitString2(dd, 0x3, &(val)->signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CSPProvider(CSPProvider *val)
{
    if (val) {
	ASN1char16string_free(&(val)->cspName);
    }
}

static int ASN1CALL ASN1Enc_CertificatePair(ASN1encoding_t enc, ASN1uint32_t tag, CertificatePair *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1BEREncOpenType(enc, &(val)->forward))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncOpenType(enc, &(val)->reverse))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificatePair(ASN1decoding_t dec, ASN1uint32_t tag, CertificatePair *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (ASN1BERDecPeekTag(dd, &t)) {
	if (t == 0x80000000) {
	    (val)->o[0] |= 0x80;
	    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
		return 0;
	    if (!ASN1BERDecOpenType2(dd0, &(val)->forward))
		return 0;
	    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
		return 0;
	}
    }
    if (ASN1BERDecPeekTag(dd, &t)) {
	if (t == 0x80000001) {
	    (val)->o[0] |= 0x40;
	    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
		return 0;
	    if (!ASN1BERDecOpenType2(dd0, &(val)->reverse))
		return 0;
	    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
		return 0;
	}
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificatePair(CertificatePair *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_GeneralSubtrees(ASN1encoding_t enc, ASN1uint32_t tag, GeneralSubtrees *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_GeneralSubtree(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GeneralSubtrees(ASN1decoding_t dec, ASN1uint32_t tag, GeneralSubtrees *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (GeneralSubtree *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_GeneralSubtree(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GeneralSubtrees(GeneralSubtrees *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_GeneralSubtree(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_GeneralSubtree(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_IssuingDistributionPoint(ASN1encoding_t enc, ASN1uint32_t tag, IssuingDistributionPoint *val)
{
    ASN1uint32_t nLenOff;
    ASN1octet_t o[1];
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    CopyMemory(o, (val)->o, 1);
    if (!(val)->onlyContainsUserCerts)
	o[0] &= ~0x40;
    if (!(val)->onlyContainsCACerts)
	o[0] &= ~0x20;
    if (!(val)->indirectCRL)
	o[0] &= ~0x8;
    if (o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_DistributionPointName(enc, 0, &(val)->issuingDistributionPoint))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1BEREncBool(enc, 0x80000001, (val)->onlyContainsUserCerts))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1BEREncBool(enc, 0x80000002, (val)->onlyContainsCACerts))
	    return 0;
    }
    if (o[0] & 0x10) {
	if (!ASN1DEREncBitString(enc, 0x80000003, ((val)->onlySomeReasons).length, ((val)->onlySomeReasons).value))
	    return 0;
    }
    if (o[0] & 0x8) {
	if (!ASN1BEREncBool(enc, 0x80000004, (val)->indirectCRL))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IssuingDistributionPoint(ASN1decoding_t dec, ASN1uint32_t tag, IssuingDistributionPoint *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_DistributionPointName(dd0, 0, &(val)->issuingDistributionPoint))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecBool(dd, 0x80000001, &(val)->onlyContainsUserCerts))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecBool(dd, 0x80000002, &(val)->onlyContainsCACerts))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecBitString2(dd, 0x80000003, &(val)->onlySomeReasons))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecBool(dd, 0x80000004, &(val)->indirectCRL))
	    return 0;
    }
    if (!((val)->o[0] & 0x40))
	(val)->onlyContainsUserCerts = 0;
    if (!((val)->o[0] & 0x20))
	(val)->onlyContainsCACerts = 0;
    if (!((val)->o[0] & 0x8))
	(val)->indirectCRL = 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_IssuingDistributionPoint(IssuingDistributionPoint *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_DistributionPointName(&(val)->issuingDistributionPoint);
	}
	if ((val)->o[0] & 0x10) {
	}
    }
}

static int ASN1CALL ASN1Enc_CrossCertDistPointNames(ASN1encoding_t enc, ASN1uint32_t tag, CrossCertDistPointNames *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_GeneralNames(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CrossCertDistPointNames(ASN1decoding_t dec, ASN1uint32_t tag, CrossCertDistPointNames *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (GeneralNames *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_GeneralNames(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CrossCertDistPointNames(CrossCertDistPointNames *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_GeneralNames(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_GeneralNames(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_PolicyMappings(ASN1encoding_t enc, ASN1uint32_t tag, PolicyMappings *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_PolicyMapping(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PolicyMappings(ASN1decoding_t dec, ASN1uint32_t tag, PolicyMappings *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (PolicyMapping *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_PolicyMapping(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PolicyMappings(PolicyMappings *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_PolicyMapping(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_PolicyMapping(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_PolicyMapping(ASN1encoding_t enc, ASN1uint32_t tag, PolicyMapping *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->issuerDomainPolicy))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->subjectDomainPolicy))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PolicyMapping(ASN1decoding_t dec, ASN1uint32_t tag, PolicyMapping *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->issuerDomainPolicy))
	return 0;
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->subjectDomainPolicy))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PolicyMapping(PolicyMapping *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->issuerDomainPolicy);
	ASN1BEREoid_free(&(val)->subjectDomainPolicy);
    }
}

static int ASN1CALL ASN1Enc_PolicyConstraints(ASN1encoding_t enc, ASN1uint32_t tag, PolicyConstraints *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncU32(enc, 0x80000000, (val)->requireExplicitPolicy))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncU32(enc, 0x80000001, (val)->inhibitPolicyMapping))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PolicyConstraints(ASN1decoding_t dec, ASN1uint32_t tag, PolicyConstraints *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecU32Val(dd, 0x80000000, (ASN1uint32_t *) &(val)->requireExplicitPolicy))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecU32Val(dd, 0x80000001, (ASN1uint32_t *) &(val)->inhibitPolicyMapping))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ControlSequence(ASN1encoding_t enc, ASN1uint32_t tag, ControlSequence *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_TaggedAttribute(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ControlSequence(ASN1decoding_t dec, ASN1uint32_t tag, ControlSequence *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (TaggedAttribute *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_TaggedAttribute(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ControlSequence(ControlSequence *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_TaggedAttribute(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_TaggedAttribute(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_ReqSequence(ASN1encoding_t enc, ASN1uint32_t tag, ReqSequence *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_TaggedRequest(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ReqSequence(ASN1decoding_t dec, ASN1uint32_t tag, ReqSequence *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (TaggedRequest *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_TaggedRequest(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ReqSequence(ReqSequence *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_TaggedRequest(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_TaggedRequest(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_CmsSequence(ASN1encoding_t enc, ASN1uint32_t tag, CmsSequence *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_TaggedContentInfo(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmsSequence(ASN1decoding_t dec, ASN1uint32_t tag, CmsSequence *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (TaggedContentInfo *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_TaggedContentInfo(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmsSequence(CmsSequence *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_TaggedContentInfo(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_TaggedContentInfo(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_OtherMsgSequence(ASN1encoding_t enc, ASN1uint32_t tag, OtherMsgSequence *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_TaggedOtherMsg(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OtherMsgSequence(ASN1decoding_t dec, ASN1uint32_t tag, OtherMsgSequence *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (TaggedOtherMsg *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_TaggedOtherMsg(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OtherMsgSequence(OtherMsgSequence *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_TaggedOtherMsg(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_TaggedOtherMsg(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_BodyPartIDSequence(ASN1encoding_t enc, ASN1uint32_t tag, BodyPartIDSequence *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncU32(enc, 0x2, ((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BodyPartIDSequence(ASN1decoding_t dec, ASN1uint32_t tag, BodyPartIDSequence *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (BodyPartID *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BodyPartIDSequence(BodyPartIDSequence *val)
{
    if (val) {
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_TaggedAttribute(ASN1encoding_t enc, ASN1uint32_t tag, TaggedAttribute *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->bodyPartID))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->type))
	return 0;
    if (!ASN1Enc_AttributeSetValue(enc, 0, &(val)->values))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TaggedAttribute(ASN1decoding_t dec, ASN1uint32_t tag, TaggedAttribute *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->bodyPartID))
	return 0;
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->type))
	return 0;
    if (!ASN1Dec_AttributeSetValue(dd, 0, &(val)->values))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TaggedAttribute(TaggedAttribute *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->type);
	ASN1Free_AttributeSetValue(&(val)->values);
    }
}

static int ASN1CALL ASN1Enc_TaggedCertificationRequest(ASN1encoding_t enc, ASN1uint32_t tag, TaggedCertificationRequest *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->bodyPartID))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->certificationRequest))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TaggedCertificationRequest(ASN1decoding_t dec, ASN1uint32_t tag, TaggedCertificationRequest *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->bodyPartID))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->certificationRequest))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TaggedCertificationRequest(TaggedCertificationRequest *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TaggedContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, TaggedContentInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->bodyPartID))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->contentInfo))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TaggedContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, TaggedContentInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->bodyPartID))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->contentInfo))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TaggedContentInfo(TaggedContentInfo *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TaggedOtherMsg(ASN1encoding_t enc, ASN1uint32_t tag, TaggedOtherMsg *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->bodyPartID))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->otherMsgType))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->otherMsgValue))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TaggedOtherMsg(ASN1decoding_t dec, ASN1uint32_t tag, TaggedOtherMsg *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->bodyPartID))
	return 0;
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->otherMsgType))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->otherMsgValue))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TaggedOtherMsg(TaggedOtherMsg *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->otherMsgType);
    }
}

static int ASN1CALL ASN1Enc_PendInfo(ASN1encoding_t enc, ASN1uint32_t tag, PendInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->pendToken).length, ((val)->pendToken).value))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->pendTime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PendInfo(ASN1decoding_t dec, ASN1uint32_t tag, PendInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->pendToken))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd, 0x18, &(val)->pendTime))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PendInfo(PendInfo *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_CmcAddExtensions(ASN1encoding_t enc, ASN1uint32_t tag, CmcAddExtensions *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->pkiDataReference))
	return 0;
    if (!ASN1Enc_BodyPartIDSequence(enc, 0, &(val)->certReferences))
	return 0;
    if (!ASN1Enc_Extensions(enc, 0, &(val)->extensions))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmcAddExtensions(ASN1decoding_t dec, ASN1uint32_t tag, CmcAddExtensions *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->pkiDataReference))
	return 0;
    if (!ASN1Dec_BodyPartIDSequence(dd, 0, &(val)->certReferences))
	return 0;
    if (!ASN1Dec_Extensions(dd, 0, &(val)->extensions))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmcAddExtensions(CmcAddExtensions *val)
{
    if (val) {
	ASN1Free_BodyPartIDSequence(&(val)->certReferences);
	ASN1Free_Extensions(&(val)->extensions);
    }
}

static int ASN1CALL ASN1Enc_CmcAddAttributes(ASN1encoding_t enc, ASN1uint32_t tag, CmcAddAttributes *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->pkiDataReference))
	return 0;
    if (!ASN1Enc_BodyPartIDSequence(enc, 0, &(val)->certReferences))
	return 0;
    if (!ASN1Enc_Attributes(enc, 0, &(val)->attributes))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmcAddAttributes(ASN1decoding_t dec, ASN1uint32_t tag, CmcAddAttributes *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->pkiDataReference))
	return 0;
    if (!ASN1Dec_BodyPartIDSequence(dd, 0, &(val)->certReferences))
	return 0;
    if (!ASN1Dec_Attributes(dd, 0, &(val)->attributes))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmcAddAttributes(CmcAddAttributes *val)
{
    if (val) {
	ASN1Free_BodyPartIDSequence(&(val)->certReferences);
	ASN1Free_Attributes(&(val)->attributes);
    }
}

static int ASN1CALL ASN1Enc_CertificateTemplate(ASN1encoding_t enc, ASN1uint32_t tag, CertificateTemplate *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->templateID))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->templateMajorVersion))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncU32(enc, 0x2, (val)->templateMinorVersion))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificateTemplate(ASN1decoding_t dec, ASN1uint32_t tag, CertificateTemplate *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->templateID))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->templateMajorVersion))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->templateMinorVersion))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificateTemplate(CertificateTemplate *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->templateID);
    }
}

static int ASN1CALL ASN1Enc_CmcStatusInfo_otherInfo(ASN1encoding_t enc, ASN1uint32_t tag, CmcStatusInfo_otherInfo *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1BEREncU32(enc, 0x2, (val)->u.failInfo))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_PendInfo(enc, 0, &(val)->u.pendInfo))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CmcStatusInfo_otherInfo(ASN1decoding_t dec, ASN1uint32_t tag, CmcStatusInfo_otherInfo *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x2:
	(val)->choice = 1;
	if (!ASN1BERDecU32Val(dec, 0x2, (ASN1uint32_t *) &(val)->u.failInfo))
	    return 0;
	break;
    case 0x10:
	(val)->choice = 2;
	if (!ASN1Dec_PendInfo(dec, 0, &(val)->u.pendInfo))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CmcStatusInfo_otherInfo(CmcStatusInfo_otherInfo *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_PendInfo(&(val)->u.pendInfo);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CpsURLs_Seq(ASN1encoding_t enc, ASN1uint32_t tag, CpsURLs_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    t = lstrlenA((val)->url);
    if (!ASN1DEREncCharString(enc, 0x16, t, (val)->url))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->digestAlgorithmId))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->digest).length, ((val)->digest).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CpsURLs_Seq(ASN1decoding_t dec, ASN1uint32_t tag, CpsURLs_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecZeroCharString(dd, 0x16, &(val)->url))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->digestAlgorithmId))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x4) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->digest))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CpsURLs_Seq(CpsURLs_Seq *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->url);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_AlgorithmIdentifier(&(val)->digestAlgorithmId);
	}
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_Attribute(ASN1encoding_t enc, ASN1uint32_t tag, Attribute *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->type))
	return 0;
    if (!ASN1Enc_AttributeSetValue(enc, 0, &(val)->values))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Attribute(ASN1decoding_t dec, ASN1uint32_t tag, Attribute *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->type))
	return 0;
    if (!ASN1Dec_AttributeSetValue(dd, 0, &(val)->values))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Attribute(Attribute *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->type);
	ASN1Free_AttributeSetValue(&(val)->values);
    }
}

static int ASN1CALL ASN1Enc_X942DhParameters(ASN1encoding_t enc, ASN1uint32_t tag, X942DhParameters *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->p))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->g))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->q))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncSX(enc, 0x2, &(val)->j))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_X942DhValidationParams(enc, 0, &(val)->validationParams))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_X942DhParameters(ASN1decoding_t dec, ASN1uint32_t tag, X942DhParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->p))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->g))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->q))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecSXVal(dd, 0x2, &(val)->j))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_X942DhValidationParams(dd, 0, &(val)->validationParams))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_X942DhParameters(X942DhParameters *val)
{
    if (val) {
	ASN1intx_free(&(val)->p);
	ASN1intx_free(&(val)->g);
	ASN1intx_free(&(val)->q);
	if ((val)->o[0] & 0x80) {
	    ASN1intx_free(&(val)->j);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_X942DhValidationParams(&(val)->validationParams);
	}
    }
}

static int ASN1CALL ASN1Enc_X942DhOtherInfo(ASN1encoding_t enc, ASN1uint32_t tag, X942DhOtherInfo *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_X942DhKeySpecificInfo(enc, 0, &(val)->keyInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->pubInfo).length, ((val)->pubInfo).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->keyLength).length, ((val)->keyLength).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_X942DhOtherInfo(ASN1decoding_t dec, ASN1uint32_t tag, X942DhOtherInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1Dec_X942DhKeySpecificInfo(dd, 0, &(val)->keyInfo))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString2(dd0, 0x4, &(val)->pubInfo))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString2(dd0, 0x4, &(val)->keyLength))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_X942DhOtherInfo(X942DhOtherInfo *val)
{
    if (val) {
	ASN1Free_X942DhKeySpecificInfo(&(val)->keyInfo);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_CertificateToBeSigned(ASN1encoding_t enc, ASN1uint32_t tag, CertificateToBeSigned *val)
{
    ASN1uint32_t nLenOff;
    ASN1octet_t o[1];
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    CopyMemory(o, (val)->o, 1);
    if ((val)->version == 0)
	o[0] &= ~0x80;
    if (o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncSX(enc, 0x2, &(val)->serialNumber))
	return 0;
    if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->signature))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->issuer))
	return 0;
    if (!ASN1Enc_Validity(enc, 0, &(val)->validity))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->subject))
	return 0;
    if (!ASN1Enc_SubjectPublicKeyInfo(enc, 0, &(val)->subjectPublicKeyInfo))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1DEREncBitString(enc, 0x80000001, ((val)->issuerUniqueIdentifier).length, ((val)->issuerUniqueIdentifier).value))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1DEREncBitString(enc, 0x80000002, ((val)->subjectUniqueIdentifier).length, ((val)->subjectUniqueIdentifier).value))
	    return 0;
    }
    if (o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1Enc_Extensions(enc, 0, &(val)->extensions))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificateToBeSigned(ASN1decoding_t dec, ASN1uint32_t tag, CertificateToBeSigned *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->serialNumber))
	return 0;
    if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->signature))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->issuer))
	return 0;
    if (!ASN1Dec_Validity(dd, 0, &(val)->validity))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->subject))
	return 0;
    if (!ASN1Dec_SubjectPublicKeyInfo(dd, 0, &(val)->subjectPublicKeyInfo))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecBitString2(dd, 0x80000001, &(val)->issuerUniqueIdentifier))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecBitString2(dd, 0x80000002, &(val)->subjectUniqueIdentifier))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_Extensions(dd0, 0, &(val)->extensions))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!((val)->o[0] & 0x80))
	(val)->version = 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificateToBeSigned(CertificateToBeSigned *val)
{
    if (val) {
	ASN1intx_free(&(val)->serialNumber);
	ASN1Free_AlgorithmIdentifier(&(val)->signature);
	ASN1Free_Validity(&(val)->validity);
	ASN1Free_SubjectPublicKeyInfo(&(val)->subjectPublicKeyInfo);
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_Extensions(&(val)->extensions);
	}
    }
}

static int ASN1CALL ASN1Enc_CertificateRevocationListToBeSigned(ASN1encoding_t enc, ASN1uint32_t tag, CertificateRevocationListToBeSigned *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	    return 0;
    }
    if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->signature))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->issuer))
	return 0;
    if (!ASN1Enc_ChoiceOfTime(enc, 0, &(val)->thisUpdate))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_ChoiceOfTime(enc, 0, &(val)->nextUpdate))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_RevokedCertificates(enc, 0, &(val)->revokedCertificates))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_Extensions(enc, 0, &(val)->crlExtensions))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificateRevocationListToBeSigned(ASN1decoding_t dec, ASN1uint32_t tag, CertificateRevocationListToBeSigned *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	    return 0;
    }
    if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->signature))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->issuer))
	return 0;
    if (!ASN1Dec_ChoiceOfTime(dd, 0, &(val)->thisUpdate))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x17 || t == 0x18) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_ChoiceOfTime(dd, 0, &(val)->nextUpdate))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x20;
	if (!ASN1Dec_RevokedCertificates(dd, 0, &(val)->revokedCertificates))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_Extensions(dd0, 0, &(val)->crlExtensions))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificateRevocationListToBeSigned(CertificateRevocationListToBeSigned *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(&(val)->signature);
	ASN1Free_ChoiceOfTime(&(val)->thisUpdate);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_ChoiceOfTime(&(val)->nextUpdate);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_RevokedCertificates(&(val)->revokedCertificates);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_Extensions(&(val)->crlExtensions);
	}
    }
}

static int ASN1CALL ASN1Enc_KeyAttributes(ASN1encoding_t enc, ASN1uint32_t tag, KeyAttributes *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->keyIdentifier).length, ((val)->keyIdentifier).value))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1DEREncBitString(enc, 0x3, ((val)->intendedKeyUsage).length, ((val)->intendedKeyUsage).value))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_PrivateKeyValidity(enc, 0, &(val)->privateKeyUsagePeriod))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KeyAttributes(ASN1decoding_t dec, ASN1uint32_t tag, KeyAttributes *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x4) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->keyIdentifier))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x3) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecBitString2(dd, 0x3, &(val)->intendedKeyUsage))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x20;
	if (!ASN1Dec_PrivateKeyValidity(dd, 0, &(val)->privateKeyUsagePeriod))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KeyAttributes(KeyAttributes *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_PrivateKeyValidity(&(val)->privateKeyUsagePeriod);
	}
    }
}

static int ASN1CALL ASN1Enc_KeyUsageRestriction(ASN1encoding_t enc, ASN1uint32_t tag, KeyUsageRestriction *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CertPolicySet(enc, 0, &(val)->certPolicySet))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1DEREncBitString(enc, 0x3, ((val)->restrictedKeyUsage).length, ((val)->restrictedKeyUsage).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KeyUsageRestriction(ASN1decoding_t dec, ASN1uint32_t tag, KeyUsageRestriction *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_CertPolicySet(dd, 0, &(val)->certPolicySet))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x3) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecBitString2(dd, 0x3, &(val)->restrictedKeyUsage))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KeyUsageRestriction(KeyUsageRestriction *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CertPolicySet(&(val)->certPolicySet);
	}
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_GeneralName(ASN1encoding_t enc, ASN1uint32_t tag, GeneralName *val)
{
    ASN1uint32_t nLenOff0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_OtherName(enc, 0x80000000, &(val)->u.otherName))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncCharString(enc, 0x80000001, ((val)->u.rfc822Name).length, ((val)->u.rfc822Name).value))
	    return 0;
	break;
    case 3:
	if (!ASN1DEREncCharString(enc, 0x80000002, ((val)->u.dNSName).length, ((val)->u.dNSName).value))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_SeqOfAny(enc, 0x80000003, &(val)->u.x400Address))
	    return 0;
	break;
    case 5:
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1BEREncOpenType(enc, &(val)->u.directoryName))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_SeqOfAny(enc, 0x80000005, &(val)->u.ediPartyName))
	    return 0;
	break;
    case 7:
	if (!ASN1DEREncCharString(enc, 0x80000006, ((val)->u.uniformResourceLocator).length, ((val)->u.uniformResourceLocator).value))
	    return 0;
	break;
    case 8:
	if (!ASN1DEREncOctetString(enc, 0x80000007, ((val)->u.iPAddress).length, ((val)->u.iPAddress).value))
	    return 0;
	break;
    case 9:
	if (!ASN1BEREncEoid(enc, 0x80000008, &(val)->u.registeredID))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GeneralName(ASN1decoding_t dec, ASN1uint32_t tag, GeneralName *val)
{
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1Dec_OtherName(dec, 0x80000000, &(val)->u.otherName))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1BERDecCharString(dec, 0x80000001, &(val)->u.rfc822Name))
	    return 0;
	break;
    case 0x80000002:
	(val)->choice = 3;
	if (!ASN1BERDecCharString(dec, 0x80000002, &(val)->u.dNSName))
	    return 0;
	break;
    case 0x80000003:
	(val)->choice = 4;
	if (!ASN1Dec_SeqOfAny(dec, 0x80000003, &(val)->u.x400Address))
	    return 0;
	break;
    case 0x80000004:
	(val)->choice = 5;
	if (!ASN1BERDecExplicitTag(dec, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOpenType2(dd0, &(val)->u.directoryName))
	    return 0;
	if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	    return 0;
	break;
    case 0x80000005:
	(val)->choice = 6;
	if (!ASN1Dec_SeqOfAny(dec, 0x80000005, &(val)->u.ediPartyName))
	    return 0;
	break;
    case 0x80000006:
	(val)->choice = 7;
	if (!ASN1BERDecCharString(dec, 0x80000006, &(val)->u.uniformResourceLocator))
	    return 0;
	break;
    case 0x80000007:
	(val)->choice = 8;
	if (!ASN1BERDecOctetString2(dec, 0x80000007, &(val)->u.iPAddress))
	    return 0;
	break;
    case 0x80000008:
	(val)->choice = 9;
	if (!ASN1BERDecEoid(dec, 0x80000008, &(val)->u.registeredID))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_GeneralName(GeneralName *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_OtherName(&(val)->u.otherName);
	    break;
	case 2:
	    ASN1charstring_free(&(val)->u.rfc822Name);
	    break;
	case 3:
	    ASN1charstring_free(&(val)->u.dNSName);
	    break;
	case 4:
	    ASN1Free_SeqOfAny(&(val)->u.x400Address);
	    break;
	case 5:
	    break;
	case 6:
	    ASN1Free_SeqOfAny(&(val)->u.ediPartyName);
	    break;
	case 7:
	    ASN1charstring_free(&(val)->u.uniformResourceLocator);
	    break;
	case 8:
	    break;
	case 9:
	    ASN1BEREoid_free(&(val)->u.registeredID);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_BasicConstraints(ASN1encoding_t enc, ASN1uint32_t tag, BasicConstraints *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->subjectType).length, ((val)->subjectType).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncS32(enc, 0x2, (val)->pathLenConstraint))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_SubtreesConstraint(enc, 0, &(val)->subtreesConstraint))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BasicConstraints(ASN1decoding_t dec, ASN1uint32_t tag, BasicConstraints *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecBitString2(dd, 0x3, &(val)->subjectType))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecS32Val(dd, 0x2, &(val)->pathLenConstraint))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_SubtreesConstraint(dd, 0, &(val)->subtreesConstraint))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BasicConstraints(BasicConstraints *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SubtreesConstraint(&(val)->subtreesConstraint);
	}
    }
}

static int ASN1CALL ASN1Enc_PolicyInformation(ASN1encoding_t enc, ASN1uint32_t tag, PolicyInformation *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->policyIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_PolicyQualifiers(enc, 0, &(val)->policyQualifiers))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PolicyInformation(ASN1decoding_t dec, ASN1uint32_t tag, PolicyInformation *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->policyIdentifier))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_PolicyQualifiers(dd, 0, &(val)->policyQualifiers))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PolicyInformation(PolicyInformation *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->policyIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_PolicyQualifiers(&(val)->policyQualifiers);
	}
    }
}

static int ASN1CALL ASN1Enc_UserNotice(ASN1encoding_t enc, ASN1uint32_t tag, UserNotice *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NoticeReference(enc, 0, &(val)->noticeRef))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_DisplayText(enc, 0, &(val)->explicitText))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UserNotice(ASN1decoding_t dec, ASN1uint32_t tag, UserNotice *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_NoticeReference(dd, 0, &(val)->noticeRef))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x1a || t == 0x1e) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_DisplayText(dd, 0, &(val)->explicitText))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UserNotice(UserNotice *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NoticeReference(&(val)->noticeRef);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_DisplayText(&(val)->explicitText);
	}
    }
}

static int ASN1CALL ASN1Enc_VerisignQualifier1(ASN1encoding_t enc, ASN1uint32_t tag, VerisignQualifier1 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	t = lstrlenA((val)->practicesReference);
	if (!ASN1DEREncCharString(enc, 0x16, t, (val)->practicesReference))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1BEREncEoid(enc, 0x6, &(val)->noticeId))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncEoid(enc, 0x6, &(val)->nsiNoticeId))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_CpsURLs(enc, 0, &(val)->cpsURLs))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VerisignQualifier1(ASN1decoding_t dec, ASN1uint32_t tag, VerisignQualifier1 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x16) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecZeroCharString(dd, 0x16, &(val)->practicesReference))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecEoid(dd0, 0x6, &(val)->noticeId))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecEoid(dd0, 0x6, &(val)->nsiNoticeId))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x10;
	if (!ASN1Dec_CpsURLs(dd, 0, &(val)->cpsURLs))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_VerisignQualifier1(VerisignQualifier1 *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1ztcharstring_free((val)->practicesReference);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1BEREoid_free(&(val)->noticeId);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1BEREoid_free(&(val)->nsiNoticeId);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_CpsURLs(&(val)->cpsURLs);
	}
    }
}

static int ASN1CALL ASN1Enc_AccessDescription(ASN1encoding_t enc, ASN1uint32_t tag, AccessDescription *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->accessMethod))
	return 0;
    if (!ASN1Enc_GeneralName(enc, 0, &(val)->accessLocation))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AccessDescription(ASN1decoding_t dec, ASN1uint32_t tag, AccessDescription *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->accessMethod))
	return 0;
    if (!ASN1Dec_GeneralName(dd, 0, &(val)->accessLocation))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AccessDescription(AccessDescription *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->accessMethod);
	ASN1Free_GeneralName(&(val)->accessLocation);
    }
}

static int ASN1CALL ASN1Enc_DistributionPoint(ASN1encoding_t enc, ASN1uint32_t tag, DistributionPoint *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_DistributionPointName(enc, 0, &(val)->distributionPoint))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1DEREncBitString(enc, 0x80000001, ((val)->reasons).length, ((val)->reasons).value))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_GeneralNames(enc, 0x80000002, &(val)->cRLIssuer))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DistributionPoint(ASN1decoding_t dec, ASN1uint32_t tag, DistributionPoint *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_DistributionPointName(dd0, 0, &(val)->distributionPoint))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecBitString2(dd, 0x80000001, &(val)->reasons))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x20;
	if (!ASN1Dec_GeneralNames(dd, 0x80000002, &(val)->cRLIssuer))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DistributionPoint(DistributionPoint *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_DistributionPointName(&(val)->distributionPoint);
	}
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_GeneralNames(&(val)->cRLIssuer);
	}
    }
}

static int ASN1CALL ASN1Enc_ContentInfoSeqOfAny(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfoSeqOfAny *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->contentType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_SeqOfAny(enc, 0, &(val)->contentSeqOfAny))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentInfoSeqOfAny(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfoSeqOfAny *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->contentType))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_SeqOfAny(dd0, 0, &(val)->contentSeqOfAny))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentInfoSeqOfAny(ContentInfoSeqOfAny *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->contentType);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SeqOfAny(&(val)->contentSeqOfAny);
	}
    }
}

static int ASN1CALL ASN1Enc_CertificateTrustList(ASN1encoding_t enc, ASN1uint32_t tag, CertificateTrustList *val)
{
    ASN1uint32_t nLenOff;
    ASN1octet_t o[1];
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    CopyMemory(o, (val)->o, 1);
    if ((val)->version == 0)
	o[0] &= ~0x80;
    if (o[0] & 0x80) {
	if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	    return 0;
    }
    if (!ASN1Enc_SubjectUsage(enc, 0, &(val)->subjectUsage))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->listIdentifier).length, ((val)->listIdentifier).value))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1BEREncSX(enc, 0x2, &(val)->sequenceNumber))
	    return 0;
    }
    if (!ASN1Enc_ChoiceOfTime(enc, 0, &(val)->ctlThisUpdate))
	return 0;
    if (o[0] & 0x10) {
	if (!ASN1Enc_ChoiceOfTime(enc, 0, &(val)->ctlNextUpdate))
	    return 0;
    }
    if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->subjectAlgorithm))
	return 0;
    if (o[0] & 0x8) {
	if (!ASN1Enc_TrustedSubjects(enc, 0, &(val)->trustedSubjects))
	    return 0;
    }
    if (o[0] & 0x4) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_Extensions(enc, 0, &(val)->ctlExtensions))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificateTrustList(ASN1decoding_t dec, ASN1uint32_t tag, CertificateTrustList *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	    return 0;
    }
    if (!ASN1Dec_SubjectUsage(dd, 0, &(val)->subjectUsage))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x4) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->listIdentifier))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecSXVal(dd, 0x2, &(val)->sequenceNumber))
	    return 0;
    }
    if (!ASN1Dec_ChoiceOfTime(dd, 0, &(val)->ctlThisUpdate))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x17 || t == 0x18) {
	(val)->o[0] |= 0x10;
	if (!ASN1Dec_ChoiceOfTime(dd, 0, &(val)->ctlNextUpdate))
	    return 0;
    }
    if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->subjectAlgorithm))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x8;
	if (!ASN1Dec_TrustedSubjects(dd, 0, &(val)->trustedSubjects))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x4;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_Extensions(dd0, 0, &(val)->ctlExtensions))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!((val)->o[0] & 0x80))
	(val)->version = 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificateTrustList(CertificateTrustList *val)
{
    if (val) {
	ASN1Free_SubjectUsage(&(val)->subjectUsage);
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	    ASN1intx_free(&(val)->sequenceNumber);
	}
	ASN1Free_ChoiceOfTime(&(val)->ctlThisUpdate);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_ChoiceOfTime(&(val)->ctlNextUpdate);
	}
	ASN1Free_AlgorithmIdentifier(&(val)->subjectAlgorithm);
	if ((val)->o[0] & 0x8) {
	    ASN1Free_TrustedSubjects(&(val)->trustedSubjects);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_Extensions(&(val)->ctlExtensions);
	}
    }
}

static int ASN1CALL ASN1Enc_NameConstraints(ASN1encoding_t enc, ASN1uint32_t tag, NameConstraints *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_GeneralSubtrees(enc, 0x80000000, &(val)->permittedSubtrees))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_GeneralSubtrees(enc, 0x80000001, &(val)->excludedSubtrees))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NameConstraints(ASN1decoding_t dec, ASN1uint32_t tag, NameConstraints *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_GeneralSubtrees(dd, 0x80000000, &(val)->permittedSubtrees))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_GeneralSubtrees(dd, 0x80000001, &(val)->excludedSubtrees))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NameConstraints(NameConstraints *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_GeneralSubtrees(&(val)->permittedSubtrees);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_GeneralSubtrees(&(val)->excludedSubtrees);
	}
    }
}

static int ASN1CALL ASN1Enc_GeneralSubtree(ASN1encoding_t enc, ASN1uint32_t tag, GeneralSubtree *val)
{
    ASN1uint32_t nLenOff;
    ASN1octet_t o[1];
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    CopyMemory(o, (val)->o, 1);
    if ((val)->minimum == 0)
	o[0] &= ~0x80;
    if (!ASN1Enc_GeneralName(enc, 0, &(val)->base))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1BEREncU32(enc, 0x80000000, (val)->minimum))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1BEREncU32(enc, 0x80000001, (val)->maximum))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GeneralSubtree(ASN1decoding_t dec, ASN1uint32_t tag, GeneralSubtree *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1Dec_GeneralName(dd, 0, &(val)->base))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecU32Val(dd, 0x80000000, (ASN1uint32_t *) &(val)->minimum))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecU32Val(dd, 0x80000001, (ASN1uint32_t *) &(val)->maximum))
	    return 0;
    }
    if (!((val)->o[0] & 0x80))
	(val)->minimum = 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GeneralSubtree(GeneralSubtree *val)
{
    if (val) {
	ASN1Free_GeneralName(&(val)->base);
    }
}

static int ASN1CALL ASN1Enc_CrossCertDistPoints(ASN1encoding_t enc, ASN1uint32_t tag, CrossCertDistPoints *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncU32(enc, 0x2, (val)->syncDeltaTime))
	    return 0;
    }
    if (!ASN1Enc_CrossCertDistPointNames(enc, 0, &(val)->crossCertDistPointNames))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CrossCertDistPoints(ASN1decoding_t dec, ASN1uint32_t tag, CrossCertDistPoints *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->syncDeltaTime))
	    return 0;
    }
    if (!ASN1Dec_CrossCertDistPointNames(dd, 0, &(val)->crossCertDistPointNames))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CrossCertDistPoints(CrossCertDistPoints *val)
{
    if (val) {
	ASN1Free_CrossCertDistPointNames(&(val)->crossCertDistPointNames);
    }
}

static int ASN1CALL ASN1Enc_CmcData(ASN1encoding_t enc, ASN1uint32_t tag, CmcData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_ControlSequence(enc, 0, &(val)->controlSequence))
	return 0;
    if (!ASN1Enc_ReqSequence(enc, 0, &(val)->reqSequence))
	return 0;
    if (!ASN1Enc_CmsSequence(enc, 0, &(val)->cmsSequence))
	return 0;
    if (!ASN1Enc_OtherMsgSequence(enc, 0, &(val)->otherMsgSequence))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmcData(ASN1decoding_t dec, ASN1uint32_t tag, CmcData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_ControlSequence(dd, 0, &(val)->controlSequence))
	return 0;
    if (!ASN1Dec_ReqSequence(dd, 0, &(val)->reqSequence))
	return 0;
    if (!ASN1Dec_CmsSequence(dd, 0, &(val)->cmsSequence))
	return 0;
    if (!ASN1Dec_OtherMsgSequence(dd, 0, &(val)->otherMsgSequence))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmcData(CmcData *val)
{
    if (val) {
	ASN1Free_ControlSequence(&(val)->controlSequence);
	ASN1Free_ReqSequence(&(val)->reqSequence);
	ASN1Free_CmsSequence(&(val)->cmsSequence);
	ASN1Free_OtherMsgSequence(&(val)->otherMsgSequence);
    }
}

static int ASN1CALL ASN1Enc_CmcResponseBody(ASN1encoding_t enc, ASN1uint32_t tag, CmcResponseBody *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_ControlSequence(enc, 0, &(val)->controlSequence))
	return 0;
    if (!ASN1Enc_CmsSequence(enc, 0, &(val)->cmsSequence))
	return 0;
    if (!ASN1Enc_OtherMsgSequence(enc, 0, &(val)->otherMsgSequence))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmcResponseBody(ASN1decoding_t dec, ASN1uint32_t tag, CmcResponseBody *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_ControlSequence(dd, 0, &(val)->controlSequence))
	return 0;
    if (!ASN1Dec_CmsSequence(dd, 0, &(val)->cmsSequence))
	return 0;
    if (!ASN1Dec_OtherMsgSequence(dd, 0, &(val)->otherMsgSequence))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmcResponseBody(CmcResponseBody *val)
{
    if (val) {
	ASN1Free_ControlSequence(&(val)->controlSequence);
	ASN1Free_CmsSequence(&(val)->cmsSequence);
	ASN1Free_OtherMsgSequence(&(val)->otherMsgSequence);
    }
}

static int ASN1CALL ASN1Enc_TaggedRequest(ASN1encoding_t enc, ASN1uint32_t tag, TaggedRequest *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_TaggedCertificationRequest(enc, 0x80000000, &(val)->u.tcr))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TaggedRequest(ASN1decoding_t dec, ASN1uint32_t tag, TaggedRequest *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1Dec_TaggedCertificationRequest(dec, 0x80000000, &(val)->u.tcr))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TaggedRequest(TaggedRequest *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_TaggedCertificationRequest(&(val)->u.tcr);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CmcStatusInfo(ASN1encoding_t enc, ASN1uint32_t tag, CmcStatusInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->cmcStatus))
	return 0;
    if (!ASN1Enc_BodyPartIDSequence(enc, 0, &(val)->bodyList))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncUTF8String(enc, 0xc, ((val)->statusString).length, ((val)->statusString).value))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_CmcStatusInfo_otherInfo(enc, 0, &(val)->otherInfo))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmcStatusInfo(ASN1decoding_t dec, ASN1uint32_t tag, CmcStatusInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->cmcStatus))
	return 0;
    if (!ASN1Dec_BodyPartIDSequence(dd, 0, &(val)->bodyList))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0xc) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecUTF8String(dd, 0xc, &(val)->statusString))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2 || t == 0x10) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_CmcStatusInfo_otherInfo(dd, 0, &(val)->otherInfo))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmcStatusInfo(CmcStatusInfo *val)
{
    if (val) {
	ASN1Free_BodyPartIDSequence(&(val)->bodyList);
	if ((val)->o[0] & 0x80) {
	    ASN1utf8string_free(&(val)->statusString);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_CmcStatusInfo_otherInfo(&(val)->otherInfo);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\chain\defce.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       defce.h
//
//  Contents:   Default Chain Engine Manager
//
//  History:    21-Apr-98    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__DEFCE_H__)
#define __DEFCE_H__

//
// Forward class declarations
//

class CDefaultChainEngineMgr;
class CImpersonationEngine;

//
// Class pointer definitions
//

typedef CDefaultChainEngineMgr* PCDEFAULTCHAINENGINEMGR;
typedef CImpersonationEngine*   PCIMPERSONATIONENGINE;

//
// Some default definitions
//

#define DEFAULT_ENGINE_URL_RETRIEVAL_TIMEOUT 15000

//
// CDefaultChainEngineMgr.  Manage the default chain engines
//

class CDefaultChainEngineMgr
{
public:

    //
    // Constructor
    //

    CDefaultChainEngineMgr ();
    ~CDefaultChainEngineMgr ();

    //
    // Initialization
    //

    BOOL Initialize ();
    VOID Uninitialize ();

    //
    // Get default chain engines
    //

    BOOL GetDefaultEngine (
            IN HCERTCHAINENGINE hDefaultHandle,
            OUT HCERTCHAINENGINE* phDefaultEngine
            );

    BOOL GetDefaultLocalMachineEngine (
            OUT HCERTCHAINENGINE* phDefaultEngine
            );

    BOOL GetDefaultCurrentUserEngine (
            OUT HCERTCHAINENGINE* phDefaultEngine
            );

    //
    // Flush default engines
    //

    VOID FlushDefaultEngine (IN HCERTCHAINENGINE hDefaultHandle);

private:

    //
    // Lock
    //

    CRITICAL_SECTION m_Lock;

    //
    // Local Machine Default Engine
    //

    HCERTCHAINENGINE m_hLocalMachineEngine;

    //
    // Process User Default Engine
    //

    HCERTCHAINENGINE m_hProcessUserEngine;

    //
    // Impersonated Users Default Engine Cache
    //

    HLRUCACHE        m_hImpersonationCache;

    //
    // Private methods
    //

    BOOL GetDefaultCurrentImpersonatedUserEngine (
            IN HANDLE hUserToken,
            OUT HCERTCHAINENGINE* phDefaultEngine
            );

    BOOL IsImpersonatingUser (
           OUT HANDLE* phUserToken
           );

    BOOL GetTokenId (
            IN HANDLE hUserToken,
            OUT PCRYPT_DATA_BLOB pTokenId
            );

    VOID FreeTokenId (
             IN PCRYPT_DATA_BLOB pTokenId
             );

    BOOL FindImpersonationEngine (
             IN PCRYPT_DATA_BLOB pTokenId,
             OUT PCIMPERSONATIONENGINE* ppEngine
             );

    // NOTE: The impersonation engine accepts ownership of the chain engine
    //       upon success
    BOOL CreateImpersonationEngine (
               IN PCRYPT_DATA_BLOB pTokenId,
               IN HCERTCHAINENGINE hChainEngine,
               OUT PCIMPERSONATIONENGINE* ppEngine
               );

    VOID AddToImpersonationCache (
            IN PCIMPERSONATIONENGINE pEngine
            );
};

VOID WINAPI
DefaultChainEngineMgrOnImpersonationEngineRemoval (
       IN LPVOID pv,
       IN LPVOID pvRemovalContext
       );

DWORD WINAPI
DefaultChainEngineMgrHashTokenIdentifier (
       IN PCRYPT_DATA_BLOB pIdentifier
       );

#define DEFAULT_IMPERSONATION_CACHE_BUCKETS 3
#define MAX_IMPERSONATION_CACHE_ENTRIES     3

//
// CImpersonationEngine, simply a ref-counted chain engine handle which
// can be added to the LRU cache
//

class CImpersonationEngine
{
public:

    //
    // Constructor
    //

    CImpersonationEngine (
                  IN HLRUCACHE hCache,
                  IN HCERTCHAINENGINE hChainEngine,
                  IN PCRYPT_DATA_BLOB pTokenId,
                  OUT BOOL& rfResult
                  );

    ~CImpersonationEngine ();

    //
    // Reference counting
    //

    inline VOID AddRef ();
    inline VOID Release ();

    //
    // Access to the chain engine
    //

    inline HCERTCHAINENGINE ChainEngine ();

    //
    // Access to the LRU entry handle
    //

    inline HLRUENTRY LruEntry ();

private:

    //
    // Reference count
    //

    ULONG            m_cRefs;

    //
    // Chain Engine
    //

    HCERTCHAINENGINE m_hChainEngine;

    //
    // LRU entry handle
    //

    HLRUENTRY        m_hLruEntry;
};

//
// Inline methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationEngine::AddRef, public
//
//  Synopsis:   add a reference to the object
//
//----------------------------------------------------------------------------
inline VOID
CImpersonationEngine::AddRef ()
{
    InterlockedIncrement( (LONG *)&m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationEngine::Release, public
//
//  Synopsis:   release a reference on the object
//
//----------------------------------------------------------------------------
inline VOID
CImpersonationEngine::Release ()
{
    if ( InterlockedDecrement( (LONG *)&m_cRefs ) == 0 )
    {
        delete this;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationEngine::ChainEngine, public
//
//  Synopsis:   return the cert chain engine
//
//----------------------------------------------------------------------------
inline HCERTCHAINENGINE
CImpersonationEngine::ChainEngine ()
{
    return( m_hChainEngine );
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationEngine::LruEntry, public
//
//  Synopsis:   return the LRU entry handle
//
//----------------------------------------------------------------------------
inline HLRUENTRY
CImpersonationEngine::LruEntry ()
{
    return( m_hLruEntry );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\chain\extract.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       extract.cpp
//
//  Contents:   Chain Cabinet Extraction
//
//  Functions:  ExtractAuthRootAutoUpdateCtlFromCab
//
//  History:    11-Nov-00    philh    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <setupapi.h>
#include <dbgdef.h>
#include <userenv.h>

#define CHAIN_CHAR_LEN(sz)    (sizeof(sz) / sizeof(sz[0]))

//+===========================================================================
//  Extract helper functions
//============================================================================

//+-------------------------------------------------------------------------
//  Allocate and read a blob from a file.
//
//  The allocated bytes must be freed by calling PkiFree().
//--------------------------------------------------------------------------
BOOL WINAPI
ReadBlobFromFileA(
    IN LPCSTR pszFileName,
    OUT BYTE **ppb,
    OUT DWORD *pcb
    )
{
    BOOL fResult;
    HANDLE hFile;
    BYTE *pb = NULL;
    DWORD cb = 0;
    DWORD cbRead = 0;

    hFile = CreateFileA(
        pszFileName,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,                               // lpsa
        OPEN_EXISTING,
        0,                                  // fdwAttrsAndFlags
        NULL                                // TemplateFile
        );
    if (INVALID_HANDLE_VALUE == hFile)
        goto CreateFileError;

    cb = GetFileSize(hFile, NULL);
    if (0 == cb)
        goto EmptyFile;

    if (NULL == (pb = (BYTE *) PkiNonzeroAlloc(cb)))
        goto OutOfMemory;

    if (!ReadFile(hFile, pb, cb, &cbRead, NULL))
        goto ReadFileError; 
    if (cbRead != cb)
        goto InvalidFileLengthError;

    fResult = TRUE;
CommonReturn:
    if (INVALID_HANDLE_VALUE != hFile) {
        DWORD dwLastErr = GetLastError();
        CloseHandle(hFile);
        SetLastError(dwLastErr);
    }

    *ppb = pb;
    *pcb = cb;

    return fResult;

ErrorReturn:
    if (pb) {
        PkiFree(pb);
        pb = NULL;
    }
    cb = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CreateFileError)
SET_ERROR(EmptyFile, ERROR_INVALID_DATA)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(ReadFileError)
SET_ERROR(InvalidFileLengthError, ERROR_INVALID_DATA)
}

//+-------------------------------------------------------------------------
//  Write the blob to the specified file
//--------------------------------------------------------------------------
BOOL WINAPI
WriteBlobToFileA(
    IN LPCSTR pszFileName,
    IN const BYTE *pb,
    IN DWORD cb
    )
{
    BOOL fResult;
    HANDLE hFile;
    DWORD cbWritten;

    hFile = CreateFileA(
        pszFileName,
        GENERIC_WRITE,
        0,                  // fdwShareMode
        NULL,               // lpsa
        CREATE_ALWAYS,
        0,                  // fdwAttrsAndFlags
        0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hFile)
        goto CreateFileError;

    if (!WriteFile(hFile, pb, cb, &cbWritten, NULL))
        goto WriteFileError;

    fResult = TRUE;
CommonReturn:
    if (INVALID_HANDLE_VALUE != hFile) {
        DWORD dwLastErr = GetLastError();
        CloseHandle(hFile);
        SetLastError(dwLastErr);
    }

    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CreateFileError)
TRACE_ERROR(WriteFileError)
}


typedef struct _EXTRACT_CAB_FILE_CONTEXT_A {
    LPCSTR      pszFileInCab;
    LPCSTR      pszTempTargetFileName;  // MAX_PATH array
    BOOL        fDidExtract;
} EXTRACT_CAB_FILE_CONTEXT_A, *PEXTRACT_CAB_FILE_CONTEXT_A;

//+-------------------------------------------------------------------------
//  Callback called by SetupIterateCabinetA to extract the file.
//--------------------------------------------------------------------------
UINT CALLBACK
ExtractCabFileCallbackA(
    IN PVOID Context,
    IN UINT Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    UINT uRet;
    PEXTRACT_CAB_FILE_CONTEXT_A pCabFileContext =
        (PEXTRACT_CAB_FILE_CONTEXT_A) Context;

    switch (Notification) {
        case SPFILENOTIFY_FILEINCABINET:
            {
                PFILE_IN_CABINET_INFO_A pInfo =
                    (PFILE_IN_CABINET_INFO_A) Param1;

                if (0 == _stricmp(pCabFileContext->pszFileInCab,
                        pInfo->NameInCabinet)) {
                    strncpy(pInfo->FullTargetName,
                        pCabFileContext->pszTempTargetFileName,
                        CHAIN_CHAR_LEN(pInfo->FullTargetName));
                    uRet = FILEOP_DOIT;
                } else
                    uRet = FILEOP_SKIP;
            }
            break;

        case SPFILENOTIFY_FILEEXTRACTED:
            {
                PFILEPATHS_A pInfo = (PFILEPATHS_A) Param1;

                uRet = pInfo->Win32Error;

                if (NO_ERROR == uRet &&
                        0 == _stricmp(pCabFileContext->pszTempTargetFileName,
                                    pInfo->Target))
                    pCabFileContext->fDidExtract = TRUE;
            }
            break;

        default:
            uRet = NO_ERROR;
    }

    return uRet;
}

typedef BOOL (WINAPI *PFN_SETUP_ITERATE_CABINET_A)(
    IN  PCSTR               CabinetFile,
    IN  DWORD               Reserved,
    IN  PSP_FILE_CALLBACK_A MsgHandler,
    IN  PVOID               Context
    );

//+-------------------------------------------------------------------------
//  Load setupapi.dll and call SetupIterateCabinetA to extract and
//  expand the specified file in the cab.
//--------------------------------------------------------------------------
BOOL WINAPI
ExtractFileFromCabFileA(
    IN LPCSTR pszFileInCab,
    IN const CHAR szTempCabFileName[MAX_PATH],
    IN const CHAR szTempTargetFileName[MAX_PATH]
    )
{
    BOOL fResult;
    HMODULE hDll = NULL;
    PFN_SETUP_ITERATE_CABINET_A pfnSetupIterateCabinetA;
    EXTRACT_CAB_FILE_CONTEXT_A CabFileContext;

    if (NULL == (hDll = LoadLibraryA("setupapi.dll")))
        goto LoadSetupApiDllError;

    if (NULL == (pfnSetupIterateCabinetA =
            (PFN_SETUP_ITERATE_CABINET_A) GetProcAddress(
                hDll, "SetupIterateCabinetA")))
        goto SetupIterateCabinetAProcAddressError;

    memset(&CabFileContext, 0, sizeof(CabFileContext));
    CabFileContext.pszFileInCab = pszFileInCab;
    CabFileContext.pszTempTargetFileName = szTempTargetFileName;

    if (!pfnSetupIterateCabinetA(
            szTempCabFileName,
            0,                      // Reserved
            ExtractCabFileCallbackA,
            &CabFileContext
            ))
        goto SetupIterateCabinetError;

    if (!CabFileContext.fDidExtract)
        goto NoCabFileExtracted;

    fResult = TRUE;

CommonReturn:
    if (hDll) {
        DWORD dwLastErr = GetLastError();
        FreeLibrary(hDll);
        SetLastError(dwLastErr);
    }
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(LoadSetupApiDllError)
TRACE_ERROR(SetupIterateCabinetAProcAddressError)
TRACE_ERROR(SetupIterateCabinetError)
SET_ERROR(NoCabFileExtracted, ERROR_FILE_NOT_FOUND)
}

typedef BOOL (WINAPI *PFN_EXPAND_ENVIRONMENT_STRINGS_FOR_USER_A)(
    IN HANDLE hToken,
    IN LPCSTR lpSrc,
    OUT LPSTR lpDest,
    IN DWORD dwSize
    );

//+-------------------------------------------------------------------------
//  Get the thread's temp directory. We may be doing thread impersonation.
//
//  Returns 0 if unable to get a thread temp path
//--------------------------------------------------------------------------
DWORD WINAPI
I_GetThreadTempPathA(
    OUT CHAR szTempPath[MAX_PATH]
    )
{
    DWORD cch;
    HANDLE hToken = NULL;
    HMODULE hDll = NULL;
    PFN_EXPAND_ENVIRONMENT_STRINGS_FOR_USER_A
        pfnExpandEnvironmentStringsForUserA;

    if (!FIsWinNT5())
        return 0;

    if (!OpenThreadToken(
            GetCurrentThread(),
            TOKEN_QUERY | TOKEN_IMPERSONATE,
            TRUE,
            &hToken
            ))
        // We aren't impersonating. Default to the system environment
        // variables.
        hToken = NULL;

    if (NULL == (hDll = LoadLibraryA("userenv.dll")))
        goto LoadUserenvDllError;

    if (NULL == (pfnExpandEnvironmentStringsForUserA =
            (PFN_EXPAND_ENVIRONMENT_STRINGS_FOR_USER_A) GetProcAddress(hDll,
                "ExpandEnvironmentStringsForUserA")))
        goto ExpandEnvironmentStringsForUserAProcAddressError;

    szTempPath[0] = L'\0';
    if (!pfnExpandEnvironmentStringsForUserA(
            hToken,
            "%Temp%\\",
            szTempPath,
            MAX_PATH - 1
            ) || '\0' == szTempPath[0])
        goto ExpandTempError;

    szTempPath[MAX_PATH - 1] = '\0';
    cch = strlen(szTempPath);

CommonReturn:
    if (hToken)
        CloseHandle(hToken);
    if (hDll)
        FreeLibrary(hDll);

    return cch;
ErrorReturn:
    cch = 0;
    goto CommonReturn;

TRACE_ERROR(LoadUserenvDllError)
TRACE_ERROR(ExpandEnvironmentStringsForUserAProcAddressError)
TRACE_ERROR(ExpandTempError)
}

//+-------------------------------------------------------------------------
//  Extract, expand and allocate an in-memory blob for the specified
//  file from the in-memory cab.
//  
//  The allocated bytes must be freed by calling PkiFree().
//--------------------------------------------------------------------------
BOOL WINAPI
ExtractBlobFromCabA(
    IN const BYTE *pbCab,
    IN DWORD cbCab,
    IN LPCSTR pszFileInCab,
    OUT BYTE **ppb,
    OUT DWORD *pcb
    )
{
    BOOL fResult;
    DWORD dwLastErr = 0;
    BYTE *pb = NULL;
    DWORD cb;

    CHAR szTempPath[MAX_PATH];
    CHAR szTempCabFileName[MAX_PATH]; szTempCabFileName[0] = '\0';
    CHAR szTempTargetFileName[MAX_PATH]; szTempTargetFileName[0] = '\0';
    DWORD cch;

    // Get temp filenames for the cabinet and extracted target
    cch = GetTempPathA(CHAIN_CHAR_LEN(szTempPath), szTempPath);
    if (0 == cch || (CHAIN_CHAR_LEN(szTempPath) - 1) < cch)
        goto GetTempPathError;

    if (0 == GetTempFileNameA(szTempPath, "Cab", 0, szTempCabFileName)) {
        dwLastErr = GetLastError();

        // If we are doing thread impersonation, we may not have access to the
        // process's temp directory. Try to get the impersonated thread's
        // temp directory.
        cch = I_GetThreadTempPathA(szTempPath);
        if (0 != cch)
            cch = GetTempFileNameA(szTempPath, "Cab", 0, szTempCabFileName);

        if (0 == cch) {
            SetLastError(dwLastErr);
            szTempCabFileName[0] = '\0';
            goto GetTempCabFileNameError;
        }
    }

    szTempCabFileName[CHAIN_CHAR_LEN(szTempCabFileName) - 1] = '\0';

    if (0 == GetTempFileNameA(szTempPath, "Tar", 0, szTempTargetFileName)) {
        szTempTargetFileName[0] = '\0';
        goto GetTempTargetFileNameError;
    }
    szTempTargetFileName[CHAIN_CHAR_LEN(szTempTargetFileName) - 1] = '\0';

    // Write the cab bytes to the temporary cab file
    if (!WriteBlobToFileA(szTempCabFileName, pbCab, cbCab))
        goto WriteCabFileError;

    // Extract the specified file from the temporary cab file
    if (!ExtractFileFromCabFileA(
            pszFileInCab, szTempCabFileName, szTempTargetFileName))
        goto ExtractFileFromCabFileError;

    // Read and allocate the bytes from the temporary target file
    if (!ReadBlobFromFileA(szTempTargetFileName, &pb, &cb))
        goto ReadTargetFileError;

    fResult = TRUE;

CommonReturn:
    // Delete the temp files
    if ('\0' != szTempCabFileName)
        DeleteFileA(szTempCabFileName);
    if ('\0' != szTempTargetFileName)
        DeleteFileA(szTempTargetFileName);

    *ppb = pb;
    *pcb = cb;

    SetLastError(dwLastErr);
    return fResult;

ErrorReturn:
    dwLastErr = GetLastError();
    if (pb) {
        PkiFree(pb);
        pb = NULL;
    }
    cb = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetTempPathError)
TRACE_ERROR(GetTempCabFileNameError)
TRACE_ERROR(GetTempTargetFileNameError)
TRACE_ERROR(WriteCabFileError)
TRACE_ERROR(ExtractFileFromCabFileError)
TRACE_ERROR(ReadTargetFileError)
}


//+---------------------------------------------------------------------------
//
//  Function:   ExtractAuthRootAutoUpdateCtlFromCab
//
//  Synopsis:   Extract the authroot.stl file from the cabinet blob
//              and create the AuthRoot Auto Update CTL.
//
//  Assumption: Chain engine isn't locked in the calling thread.
//
//----------------------------------------------------------------------------
PCCTL_CONTEXT WINAPI
ExtractAuthRootAutoUpdateCtlFromCab (
    IN PCRYPT_BLOB_ARRAY pcbaCab
    )
{
    PCRYPT_DATA_BLOB pCabBlob;
    PCCTL_CONTEXT pCtl = NULL;
    BYTE *pbEncodedCtl = NULL;
    DWORD cbEncodedCtl;
    CERT_CREATE_CONTEXT_PARA CreateContextPara;

    // Get the cab blob
    pCabBlob = pcbaCab->rgBlob;
    if (0 == pcbaCab->cBlob || 0 == pCabBlob->cbData)
        goto InvalidCabBlob;

    // Extract, expand and create an in-memory blob for the stl file in the
    // in-memory cab
    if (!ExtractBlobFromCabA(
            pCabBlob->pbData,
            pCabBlob->cbData,
            CERT_AUTH_ROOT_CTL_FILENAME_A,
            &pbEncodedCtl,
            &cbEncodedCtl
            ))
        goto ExtractStlFromCabError;

    // Create the Ctl from the extracted bytes
    memset(&CreateContextPara, 0, sizeof(CreateContextPara));
    CreateContextPara.cbSize = sizeof(CreateContextPara);
    CreateContextPara.pfnFree = PkiFree;

    pCtl = (PCCTL_CONTEXT) CertCreateContext(
        CERT_STORE_CTL_CONTEXT,
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        pbEncodedCtl,
        cbEncodedCtl,
        CERT_CREATE_CONTEXT_NOCOPY_FLAG,
        &CreateContextPara
        );
    // For NO_COPY_FLAG, pbEncodedCtl is always freed, even for an error
    pbEncodedCtl = NULL;
    if (NULL == pCtl)
        goto CreateCtlError;

CommonReturn:
    return pCtl;

ErrorReturn:
    assert(NULL == pCtl);
    if (pbEncodedCtl)
        PkiFree(pbEncodedCtl);

    goto CommonReturn;

SET_ERROR(InvalidCabBlob, ERROR_INVALID_DATA)
TRACE_ERROR(ExtractStlFromCabError)
TRACE_ERROR(CreateCtlError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\chain\lru.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       lru.cpp
//
//  Contents:   LRU cache implementation
//
//  History:    24-Dec-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::CLruEntry, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CLruEntry::CLruEntry (
               IN PCLRUCACHE pCache,
               IN PCRYPT_DATA_BLOB pIdentifier,
               IN LPVOID pvData,
               OUT BOOL& rfResult
               )
{
    rfResult = TRUE;

    m_cRefs = 1;
    m_pPrevEntry = NULL;
    m_pNextEntry = NULL;
    m_Usage = 0;

    m_pCache = pCache;
    m_pvData = pvData;
    m_pBucket = pCache->BucketFromIdentifier( pIdentifier );

    if ( pCache->Flags() & LRU_CACHE_NO_COPY_IDENTIFIER )
    {
        m_Identifier = *pIdentifier;
    }
    else
    {
        m_Identifier.cbData = pIdentifier->cbData;
        m_Identifier.pbData = new BYTE [ pIdentifier->cbData ];
        if ( m_Identifier.pbData != NULL )
        {
            memcpy(
               m_Identifier.pbData,
               pIdentifier->pbData,
               pIdentifier->cbData
               );
        }
        else
        {
            rfResult = FALSE;
            SetLastError( (DWORD) E_OUTOFMEMORY );
            return;
        }
    }

    assert( m_pBucket != NULL );
    assert( m_Identifier.pbData != NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::~CLruEntry, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CLruEntry::~CLruEntry ()
{
    m_pCache->FreeEntryData( m_pvData );

    if ( !( m_pCache->Flags() & LRU_CACHE_NO_COPY_IDENTIFIER ) )
    {
        delete m_Identifier.pbData;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::CLruCache, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CLruCache::CLruCache (
               IN PLRU_CACHE_CONFIG pConfig,
               OUT BOOL& rfResult
               )
{
    rfResult = TRUE;

    m_Config.dwFlags = LRU_CACHE_NO_SERIALIZE;
    m_cEntries = 0;
    m_aBucket = new LRU_CACHE_BUCKET [ pConfig->cBuckets ];
    if ( m_aBucket == NULL )
    {
        rfResult = FALSE;
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return;
    }

    memset( m_aBucket, 0, sizeof( LRU_CACHE_BUCKET ) * pConfig->cBuckets );

    if ( !( pConfig->dwFlags & LRU_CACHE_NO_SERIALIZE ) )
    {
        if (! Pki_InitializeCriticalSection( &m_Lock ))
        {
            rfResult = FALSE;
            return;
        }
    }

    m_Config = *pConfig;
    m_UsageClock = 0;
    m_cLruDisabled = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::~CLruCache, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CLruCache::~CLruCache ()
{
    if ( m_cEntries > 0 )
    {
        PurgeAllEntries( 0, NULL );
    }

    if ( !( m_Config.dwFlags & LRU_CACHE_NO_SERIALIZE ) )
    {
        DeleteCriticalSection( &m_Lock );
    }

    delete m_aBucket;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::EnableLruOfEntries, public
//
//  Synopsis:   enable LRU of entries and purge anything over the watermark
//
//----------------------------------------------------------------------------
VOID
CLruCache::EnableLruOfEntries (IN OPTIONAL LPVOID pvLruRemovalContext)
{
    LockCache();

    assert( m_cLruDisabled > 0 );

    if ( m_cLruDisabled == 0 )
    {
        return;
    }

    m_cLruDisabled -= 1;

    if ( m_cLruDisabled == 0 )
    {
        while ( m_cEntries > m_Config.MaxEntries )
        {
            PurgeLeastRecentlyUsed( pvLruRemovalContext );
        }
    }

    UnlockCache();
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::DisableLruOfEntries, public
//
//  Synopsis:   disable LRU of entries
//
//----------------------------------------------------------------------------
VOID
CLruCache::DisableLruOfEntries ()
{
    LockCache();

    m_cLruDisabled += 1;

    UnlockCache();
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::InsertEntry, public
//
//  Synopsis:   insert an entry into the cache
//
//----------------------------------------------------------------------------
VOID
CLruCache::InsertEntry (
                 IN PCLRUENTRY pEntry,
                 IN OPTIONAL LPVOID pvLruRemovalContext
                 )
{
    assert( pEntry->PrevPointer() == NULL );
    assert( pEntry->NextPointer() == NULL );

    pEntry->AddRef();

    LockCache();

    if ( ( m_cEntries == m_Config.MaxEntries ) &&
         ( m_Config.MaxEntries != 0 ) &&
         ( m_cLruDisabled == 0 ) )
    {
        PurgeLeastRecentlyUsed( pvLruRemovalContext );
    }

    assert( ( m_cEntries < m_Config.MaxEntries ) ||
            ( m_Config.MaxEntries == 0 ) ||
            ( m_cLruDisabled > 0 ) );

    pEntry->SetNextPointer( pEntry->Bucket()->pList );

    if ( pEntry->Bucket()->pList != NULL )
    {
        pEntry->Bucket()->pList->SetPrevPointer( pEntry );
    }

    pEntry->Bucket()->pList = pEntry;

    m_cEntries += 1;

    TouchEntryNoLock( pEntry, 0 );

    UnlockCache();
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::RemoveEntry, public
//
//  Synopsis:   remove an entry from the cache
//
//----------------------------------------------------------------------------
VOID
CLruCache::RemoveEntry (
                 IN PCLRUENTRY pEntry,
                 IN DWORD dwFlags,
                 IN OPTIONAL LPVOID pvRemovalContext
                 )
{
    LockCache();

    RemoveEntryFromBucket(
          pEntry->Bucket(),
          pEntry,
          dwFlags,
          pvRemovalContext
          );

    UnlockCache();
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::TouchEntry, public
//
//  Synopsis:   touch the entry
//
//----------------------------------------------------------------------------
VOID
CLruCache::TouchEntry (IN PCLRUENTRY pEntry, IN DWORD dwFlags)
{
    LockCache();

    TouchEntryNoLock( pEntry, dwFlags );

    UnlockCache();
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::FindEntry, public
//
//  Synopsis:   find the entry matching the given identifier
//
//----------------------------------------------------------------------------
PCLRUENTRY
CLruCache::FindEntry (IN PCRYPT_DATA_BLOB pIdentifier, IN BOOL fTouchEntry)
{
    PLRU_CACHE_BUCKET pBucket;

    pBucket = BucketFromIdentifier( pIdentifier );

    assert( pBucket != NULL );

    return( FindNextMatchingEntryInBucket(
                pBucket,
                NULL,
                pIdentifier,
                fTouchEntry
                ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::NextMatchingEntry, public
//
//  Synopsis:   find the next matching entry to pPrevEntry
//
//----------------------------------------------------------------------------
PCLRUENTRY
CLruCache::NextMatchingEntry (IN PCLRUENTRY pPrevEntry, IN BOOL fTouchEntry)
{
    PCLRUENTRY pNextEntry;

    pNextEntry = FindNextMatchingEntryInBucket(
                     NULL,
                     pPrevEntry,
                     NULL,
                     fTouchEntry
                     );

    pPrevEntry->Release();

    return( pNextEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::WalkEntries, public
//
//  Synopsis:   walk the entries
//
//----------------------------------------------------------------------------
VOID
CLruCache::WalkEntries (IN PFN_WALK_ENTRIES pfnWalk, IN LPVOID pvParameter)
{
    DWORD      cCount;
    PCLRUENTRY pEntry;
    PCLRUENTRY pNextEntry;

    for ( cCount = 0; cCount < m_Config.cBuckets; cCount++ )
    {
        pEntry = m_aBucket[ cCount ].pList;

        while ( pEntry != NULL )
        {
            pNextEntry = pEntry->NextPointer();

            if ( ( *pfnWalk )( pvParameter, pEntry ) == FALSE )
            {
                return;
            }

            pEntry = pNextEntry;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::RemoveEntryFromBucket, public
//
//  Synopsis:   remove entry from bucket
//
//----------------------------------------------------------------------------
VOID
CLruCache::RemoveEntryFromBucket (
                 IN PLRU_CACHE_BUCKET pBucket,
                 IN PCLRUENTRY pEntry,
                 IN DWORD dwFlags,
                 IN OPTIONAL LPVOID pvRemovalContext
                 )
{
    if ( pEntry->PrevPointer() != NULL )
    {
        pEntry->PrevPointer()->SetNextPointer( pEntry->NextPointer() );
    }
    else
    {
        assert( pBucket->pList == pEntry );

        pBucket->pList = pEntry->NextPointer();
    }

    if ( pEntry->NextPointer() != NULL )
    {
        pEntry->NextPointer()->SetPrevPointer( pEntry->PrevPointer() );
    }

    pEntry->SetPrevPointer( NULL );
    pEntry->SetNextPointer( NULL );

    m_cEntries -= 1;

    if (  ( m_Config.pfnOnRemoval != NULL ) &&
         !( dwFlags & LRU_SUPPRESS_REMOVAL_NOTIFICATION ) )
    {
        ( *m_Config.pfnOnRemoval )( pEntry->Data(), pvRemovalContext );
    }

    pEntry->Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::FindNextMatchingEntryInBucket, public
//
//  Synopsis:   find the next matching entry in the given bucket.  If pCurrent
//              is non NULL then start from there, the bucket is not needed and
//              pIdentifier is ignored. If pCurrent is NULL then pIdentifier
//              and the bucket must both be non NULL
//
//----------------------------------------------------------------------------
PCLRUENTRY
CLruCache::FindNextMatchingEntryInBucket (
               IN PLRU_CACHE_BUCKET pBucket,
               IN PCLRUENTRY pCurrent,
               IN PCRYPT_DATA_BLOB pIdentifier,
               IN BOOL fTouchEntry
               )
{
    LockCache();

    if ( pCurrent == NULL )
    {
        pCurrent = pBucket->pList;
    }
    else
    {
        pIdentifier = pCurrent->Identifier();
        pCurrent = pCurrent->NextPointer();
    }

    while ( pCurrent != NULL )
    {
        if ( ( pIdentifier->cbData == pCurrent->Identifier()->cbData ) &&
             ( memcmp(
                  pIdentifier->pbData,
                  pCurrent->Identifier()->pbData,
                  pIdentifier->cbData
                  ) == 0 ) )
        {
            break;
        }

        pCurrent = pCurrent->NextPointer();
    }

    if ( pCurrent != NULL )
    {
        pCurrent->AddRef();

        if ( fTouchEntry == TRUE )
        {
            TouchEntryNoLock( pCurrent, 0 );
        }
    }

    UnlockCache();

    return( pCurrent );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::PurgeLeastRecentlyUsed, public
//
//  Synopsis:   find and remove the least recently used entry
//
//----------------------------------------------------------------------------
VOID
CLruCache::PurgeLeastRecentlyUsed (IN OPTIONAL LPVOID pvLruRemovalContext)
{
    DWORD             cCount;
    PLRU_CACHE_BUCKET pBucket;
    PCLRUENTRY        pEntry;
    PCLRUENTRY        pLRU;

    assert( m_cEntries > 0 );

    for ( cCount = 0; cCount < m_Config.cBuckets; cCount++ )
    {
        if ( m_aBucket[cCount].pList != NULL )
        {
            break;
        }
    }

    pBucket = &m_aBucket[cCount];
    cCount += 1;
    for ( ; cCount < m_Config.cBuckets; cCount++ )
    {
        if ( ( m_aBucket[cCount].pList != NULL ) &&
             ( m_aBucket[cCount].Usage < pBucket->Usage ) )
        {
            pBucket = &m_aBucket[cCount];
        }
    }

    assert( pBucket != NULL );
    assert( pBucket->pList != NULL );

    pLRU = pBucket->pList;
    pEntry = pLRU->NextPointer();

    while ( pEntry != NULL )
    {
        if ( pEntry->Usage() < pLRU->Usage() )
        {
            pLRU = pEntry;
        }

        pEntry = pEntry->NextPointer();
    }

    RemoveEntryFromBucket( pBucket, pLRU, 0, pvLruRemovalContext );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::PurgeAllEntries, public
//
//  Synopsis:   remove all entries from the cache
//
//----------------------------------------------------------------------------
VOID
CLruCache::PurgeAllEntries (
                IN DWORD dwFlags,
                IN OPTIONAL LPVOID pvRemovalContext
                )
{
    DWORD cCount;

    for ( cCount = 0; cCount < m_Config.cBuckets; cCount++ )
    {
        while ( m_aBucket[cCount].pList != NULL )
        {
            RemoveEntryFromBucket(
                  &m_aBucket[cCount],
                  m_aBucket[cCount].pList,
                  dwFlags,
                  pvRemovalContext
                  );
        }
    }

    assert( m_cEntries == 0 );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptCreateLruCache
//
//  Synopsis:   create an LRU cache area
//
//----------------------------------------------------------------------------
BOOL WINAPI
I_CryptCreateLruCache (
       IN PLRU_CACHE_CONFIG pConfig,
       OUT HLRUCACHE* phCache
       )
{
    BOOL       fResult = FALSE;
    PCLRUCACHE pCache;

    pCache = new CLruCache( pConfig, fResult );
    if ( pCache == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    if ( fResult == FALSE )
    {
        delete pCache;
        return( FALSE );
    }

    *phCache = (HLRUCACHE)pCache;
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptFlushLruCache
//
//  Synopsis:   flush the cache
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptFlushLruCache (
       IN HLRUCACHE hCache,
       IN OPTIONAL DWORD dwFlags,
       IN OPTIONAL LPVOID pvRemovalContext
       )
{
    ( (PCLRUCACHE)hCache )->LockCache();

    ( (PCLRUCACHE)hCache )->PurgeAllEntries( dwFlags, pvRemovalContext );

    ( (PCLRUCACHE)hCache )->UnlockCache();
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptFreeLruCache
//
//  Synopsis:   free the LRU cache area
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptFreeLruCache (
       IN HLRUCACHE hCache,
       IN DWORD dwFlags,
       IN OPTIONAL LPVOID pvRemovalContext
       )
{
    if ( hCache == NULL )
    {
        return;
    }

    if ( dwFlags != 0 )
    {
        ( (PCLRUCACHE)hCache )->PurgeAllEntries( dwFlags, pvRemovalContext );
    }

    delete (PCLRUCACHE)hCache;
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptCreateLruEntry
//
//  Synopsis:   create an LRU entry
//
//----------------------------------------------------------------------------
BOOL WINAPI
I_CryptCreateLruEntry (
       IN HLRUCACHE hCache,
       IN PCRYPT_DATA_BLOB pIdentifier,
       IN LPVOID pvData,
       OUT HLRUENTRY* phEntry
       )
{
    BOOL       fResult = FALSE;
    PCLRUENTRY pEntry;

    pEntry = new CLruEntry(
                     (PCLRUCACHE)hCache,
                     pIdentifier,
                     pvData,
                     fResult
                     );

    if ( pEntry == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    if ( fResult == FALSE )
    {
        delete pEntry;
        return( FALSE );
    }

    *phEntry = (HLRUENTRY)pEntry;
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptGetLruEntryIdentifier
//
//  Synopsis:   return the identifier for the entry
//
//----------------------------------------------------------------------------
PCRYPT_DATA_BLOB WINAPI
I_CryptGetLruEntryIdentifier (
       IN HLRUENTRY hEntry
       )
{
    return( ( (PCLRUENTRY)hEntry )->Identifier() );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptGetLruEntryData
//
//  Synopsis:   get the data associated with the entry
//
//----------------------------------------------------------------------------
LPVOID WINAPI
I_CryptGetLruEntryData (
       IN HLRUENTRY hEntry
       )
{
    return( ( (PCLRUENTRY)hEntry )->Data() );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptAddRefLruEntry
//
//  Synopsis:   add a reference to the entry
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptAddRefLruEntry (
       IN HLRUENTRY hEntry
       )
{
    ( (PCLRUENTRY)hEntry )->AddRef();
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptReleaseLruEntry
//
//  Synopsis:   remove a reference from the entry
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptReleaseLruEntry (
       IN HLRUENTRY hEntry
       )
{
    ( (PCLRUENTRY)hEntry )->Release();
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptInsertLruEntry
//
//  Synopsis:   insert the entry into its associated cache
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptInsertLruEntry (
       IN HLRUENTRY hEntry,
       IN OPTIONAL LPVOID pvLruRemovalContext
       )
{
    PCLRUENTRY pEntry = (PCLRUENTRY)hEntry;

    pEntry->Cache()->InsertEntry( pEntry, pvLruRemovalContext );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptRemoveLruEntry
//
//  Synopsis:   remove the entry from its associated cache
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptRemoveLruEntry (
       IN HLRUENTRY hEntry,
       IN DWORD dwFlags,
       IN LPVOID pvLruRemovalContext
       )
{
    PCLRUENTRY pEntry = (PCLRUENTRY)hEntry;

    pEntry->Cache()->RemoveEntry( pEntry, dwFlags, pvLruRemovalContext );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptTouchLruEntry
//
//  Synopsis:   touch the entry
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptTouchLruEntry (
       IN HLRUENTRY hEntry,
       IN DWORD dwFlags
       )
{
    PCLRUENTRY pEntry = (PCLRUENTRY)hEntry;

    pEntry->Cache()->TouchEntry( pEntry, dwFlags );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptFindLruEntry
//
//  Synopsis:   find the entry with the given identifier
//
//----------------------------------------------------------------------------
HLRUENTRY WINAPI
I_CryptFindLruEntry (
       IN HLRUCACHE hCache,
       IN PCRYPT_DATA_BLOB pIdentifier
       )
{
    PCLRUCACHE pCache = (PCLRUCACHE)hCache;

    return( pCache->FindEntry( pIdentifier, FALSE ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptFindLruEntryData
//
//  Synopsis:   find the entry with the given identifier
//
//----------------------------------------------------------------------------
LPVOID WINAPI
I_CryptFindLruEntryData (
       IN HLRUCACHE hCache,
       IN PCRYPT_DATA_BLOB pIdentifier,
       OUT HLRUENTRY* phEntry
       )
{
    PCLRUCACHE pCache = (PCLRUCACHE)hCache;
    PCLRUENTRY pEntry;

    pEntry = pCache->FindEntry( pIdentifier, TRUE );
    *phEntry = (HLRUENTRY)pEntry;

    if ( pEntry != NULL )
    {
        return( pEntry->Data() );
    }

    return( NULL );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptEnumMatchingLruEntries
//
//  Synopsis:   get the next matching entry
//
//----------------------------------------------------------------------------
HLRUENTRY WINAPI
I_CryptEnumMatchingLruEntries (
       IN HLRUENTRY hPrevEntry
       )
{
    PCLRUCACHE pCache = ( (PCLRUENTRY)hPrevEntry )->Cache();
    PCLRUENTRY pNextEntry;

    pNextEntry = pCache->NextMatchingEntry( (PCLRUENTRY)hPrevEntry, FALSE );

    return( (HLRUENTRY)pNextEntry );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptEnableLruOfEntries
//
//  Synopsis:   enable LRU of entries
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptEnableLruOfEntries (
       IN HLRUCACHE hCache,
       IN OPTIONAL LPVOID pvLruRemovalContext
       )
{
    ( (PCLRUCACHE)hCache )->EnableLruOfEntries( pvLruRemovalContext);
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptDisableLruOfEntries
//
//  Synopsis:   disable LRU of entries
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptDisableLruOfEntries (
       IN HLRUCACHE hCache
       )
{
    ( (PCLRUCACHE)hCache )->DisableLruOfEntries();
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptWalkAllLruCacheEntries
//
//  Synopsis:   walk the LRU cache entries
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptWalkAllLruCacheEntries (
       IN HLRUCACHE hCache,
       IN PFN_WALK_ENTRIES pfnWalk,
       IN LPVOID pvParameter
       )
{
    ( (PCLRUCACHE)hCache )->WalkEntries( pfnWalk, pvParameter );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\chain\defce.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       defce.cpp
//
//  Contents:   Default Chain Engine Manager
//
//  History:    21-Apr-98    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::CDefaultChainEngineMgr, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CDefaultChainEngineMgr::CDefaultChainEngineMgr ()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::~CDefaultChainEngineMgr, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CDefaultChainEngineMgr::~CDefaultChainEngineMgr ()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::Initialize, public
//
//  Synopsis:   initialization routine
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::Initialize ()
{
    LRU_CACHE_CONFIG Config;

    if (!Pki_InitializeCriticalSection( &m_Lock ))
    {
        return FALSE;
    }

    m_hLocalMachineEngine = NULL;
    m_hProcessUserEngine = NULL;
    m_hImpersonationCache = NULL;

    memset( &Config, 0, sizeof( Config ) );

    Config.dwFlags = LRU_CACHE_NO_SERIALIZE;
    Config.cBuckets = DEFAULT_IMPERSONATION_CACHE_BUCKETS;
    Config.MaxEntries = MAX_IMPERSONATION_CACHE_ENTRIES;
    Config.pfnHash = DefaultChainEngineMgrHashTokenIdentifier;
    Config.pfnOnRemoval = DefaultChainEngineMgrOnImpersonationEngineRemoval;

    if (!I_CryptCreateLruCache( &Config, &m_hImpersonationCache ) )
    {
        DeleteCriticalSection( &m_Lock );
        return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::Uninitialize, public
//
//  Synopsis:   uninitialization routine
//
//----------------------------------------------------------------------------
VOID
CDefaultChainEngineMgr::Uninitialize ()
{
    if ( m_hLocalMachineEngine != NULL )
    {
        CertFreeCertificateChainEngine( m_hLocalMachineEngine );
    }

    if ( m_hProcessUserEngine != NULL )
    {
        CertFreeCertificateChainEngine( m_hProcessUserEngine );
    }

    if ( m_hImpersonationCache != NULL )
    {
        I_CryptFreeLruCache( m_hImpersonationCache, 0, NULL );
    }

    DeleteCriticalSection( &m_Lock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::GetDefaultEngine, public
//
//  Synopsis:   get the default engine
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::GetDefaultEngine (
                           IN HCERTCHAINENGINE hDefaultHandle,
                           OUT HCERTCHAINENGINE* phDefaultEngine
                           )
{
    assert( ( hDefaultHandle == HCCE_LOCAL_MACHINE ) ||
            ( hDefaultHandle == HCCE_CURRENT_USER ) );

    if ( hDefaultHandle == HCCE_LOCAL_MACHINE )
    {
        return( GetDefaultLocalMachineEngine( phDefaultEngine ) );
    }
    else if ( hDefaultHandle == HCCE_CURRENT_USER )
    {
        return( GetDefaultCurrentUserEngine( phDefaultEngine ) );
    }

    SetLastError( (DWORD) E_INVALIDARG );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::GetDefaultLocalMachineEngine, public
//
//  Synopsis:   get the default local machine chain engine
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::GetDefaultLocalMachineEngine (
                           OUT HCERTCHAINENGINE* phDefaultEngine
                           )
{
    BOOL fResult = TRUE;

    EnterCriticalSection( &m_Lock );

    if ( m_hLocalMachineEngine == NULL )
    {
        HCERTCHAINENGINE         hEngine = NULL;
        CERT_CHAIN_ENGINE_CONFIG Config;

        LeaveCriticalSection( &m_Lock );

        memset( &Config, 0, sizeof( Config ) );

        Config.cbSize = sizeof( Config );
        Config.dwFlags = CERT_CHAIN_USE_LOCAL_MACHINE_STORE;
        Config.dwFlags |= CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE |
            CERT_CHAIN_ENABLE_SHARE_STORE;

        fResult = CertCreateCertificateChainEngine(
                      &Config,
                      &hEngine
                      );

        EnterCriticalSection( &m_Lock );

        if ( ( fResult == TRUE ) && ( m_hLocalMachineEngine == NULL ) )
        {
            m_hLocalMachineEngine = hEngine;
            hEngine = NULL;
        }

        if ( hEngine != NULL )
        {
            ( (PCCERTCHAINENGINE)hEngine )->Release();
        }
    }

    if ( fResult == TRUE )
    {
        ( (PCCERTCHAINENGINE)m_hLocalMachineEngine )->AddRef();
        *phDefaultEngine = m_hLocalMachineEngine;
    }

    LeaveCriticalSection( &m_Lock );

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::GetDefaultCurrentUserEngine, public
//
//  Synopsis:   get the default current user chain engine
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::GetDefaultCurrentUserEngine (
                           OUT HCERTCHAINENGINE* phDefaultEngine
                           )
{
    BOOL   fResult = TRUE;
    HANDLE hUserToken;

    EnterCriticalSection( &m_Lock );

    if ( IsImpersonatingUser( &hUserToken ) == FALSE )
    {
        if ( GetLastError() != ERROR_NO_TOKEN )
        {
            LeaveCriticalSection( &m_Lock );
            return( FALSE );
        }

        if ( m_hProcessUserEngine == NULL )
        {
            HCERTCHAINENGINE         hEngine = NULL;
            CERT_CHAIN_ENGINE_CONFIG Config;

            LeaveCriticalSection( &m_Lock );

            memset( &Config, 0, sizeof( Config ) );

            Config.cbSize = sizeof( Config );
            Config.dwFlags |= CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE |
                CERT_CHAIN_ENABLE_SHARE_STORE;

            fResult = CertCreateCertificateChainEngine(
                          &Config,
                          &hEngine
                          );

            EnterCriticalSection( &m_Lock );

            if ( ( fResult == TRUE ) && ( m_hProcessUserEngine == NULL ) )
            {
                m_hProcessUserEngine = hEngine;
                hEngine = NULL;
            }

            if ( hEngine != NULL )
            {
                ( (PCCERTCHAINENGINE)hEngine )->Release();
            }
        }

        if ( fResult == TRUE )
        {
            ( (PCCERTCHAINENGINE)m_hProcessUserEngine )->AddRef();
            *phDefaultEngine = m_hProcessUserEngine;
        }
    }
    else
    {
        fResult = GetDefaultCurrentImpersonatedUserEngine(
                     hUserToken,
                     phDefaultEngine
                     );

        CloseHandle( hUserToken );
    }

    LeaveCriticalSection( &m_Lock );

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::FlushDefaultEngine, public
//
//  Synopsis:   flush default engine
//
//----------------------------------------------------------------------------
VOID
CDefaultChainEngineMgr::FlushDefaultEngine (IN HCERTCHAINENGINE hDefaultHandle)
{
    HCERTCHAINENGINE hEngine = NULL;
    HLRUCACHE        hCacheToFree = NULL;
    HLRUCACHE        hCache = NULL;
    LRU_CACHE_CONFIG Config;

    EnterCriticalSection( &m_Lock );

    if ( hDefaultHandle == HCCE_CURRENT_USER )
    {
        hEngine = m_hProcessUserEngine;
        m_hProcessUserEngine = NULL;

        assert( m_hImpersonationCache != NULL );

        memset( &Config, 0, sizeof( Config ) );

        Config.dwFlags = LRU_CACHE_NO_SERIALIZE;
        Config.cBuckets = DEFAULT_IMPERSONATION_CACHE_BUCKETS;
        Config.MaxEntries = MAX_IMPERSONATION_CACHE_ENTRIES;
        Config.pfnHash = DefaultChainEngineMgrHashTokenIdentifier;
        Config.pfnOnRemoval = DefaultChainEngineMgrOnImpersonationEngineRemoval;

        if ( I_CryptCreateLruCache( &Config, &hCache ) == TRUE )
        {
            hCacheToFree = m_hImpersonationCache;
            m_hImpersonationCache = hCache;
        }
        else
        {
            I_CryptFlushLruCache( m_hImpersonationCache, 0, NULL );
        }

        assert( m_hImpersonationCache != NULL );
    }
    else if ( hDefaultHandle == HCCE_LOCAL_MACHINE )
    {
        hEngine = m_hLocalMachineEngine;
        m_hLocalMachineEngine = NULL;
    }

    LeaveCriticalSection( &m_Lock );

    if ( hEngine != NULL )
    {
        CertFreeCertificateChainEngine( hEngine );
    }

    if ( hCacheToFree != NULL )
    {
        I_CryptFreeLruCache( hCacheToFree, 0, NULL );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::GetDefaultCurrentImpersonatedUserEngine
//
//  Synopsis:   get current impersonated user chain engine
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::GetDefaultCurrentImpersonatedUserEngine (
                           IN HANDLE hUserToken,
                           OUT HCERTCHAINENGINE* phDefaultEngine
                           )
{
    BOOL                  fResult;
    CRYPT_DATA_BLOB       TokenId;
    PCIMPERSONATIONENGINE pEngine = NULL;
    HCERTCHAINENGINE      hChainEngine = NULL;

    fResult = GetTokenId( hUserToken, &TokenId );

    if ( fResult == TRUE )
    {
        if ( FindImpersonationEngine( &TokenId, &pEngine ) == FALSE )
        {
            CERT_CHAIN_ENGINE_CONFIG Config;

            LeaveCriticalSection( &m_Lock );

            memset( &Config, 0, sizeof( Config ) );

            Config.cbSize = sizeof( Config );
            Config.dwFlags |= CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE |
                CERT_CHAIN_ENABLE_SHARE_STORE;

            fResult = CertCreateCertificateChainEngine(
                          &Config,
                          &hChainEngine
                          );

            EnterCriticalSection( &m_Lock );

            if ( fResult == TRUE )
            {
                fResult = FindImpersonationEngine( &TokenId, &pEngine );

                if ( fResult == FALSE )
                {
                    fResult = CreateImpersonationEngine(
                                    &TokenId,
                                    hChainEngine,
                                    &pEngine
                                    );

                    if ( fResult == TRUE )
                    {
                        hChainEngine = NULL;
                        AddToImpersonationCache( pEngine );
                    }
                }
            }
        }

        FreeTokenId( &TokenId );
    }

    if ( fResult == TRUE )
    {
        *phDefaultEngine = pEngine->ChainEngine();
        ( (PCCERTCHAINENGINE)*phDefaultEngine )->AddRef();
    }

    if ( pEngine != NULL )
    {
        pEngine->Release();
    }

    // NOTE: This release of the lock to free the unneeded chain engine handle
    //       must happen AFTER we're done with the impersonation engine and
    //       have addref'd the appropriate chain engine handle

    if ( hChainEngine != NULL )
    {
        LeaveCriticalSection( &m_Lock );

        CertFreeCertificateChainEngine( hChainEngine );

        EnterCriticalSection( &m_Lock );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::IsImpersonatingUser, public
//
//  Synopsis:   is impersonating user?
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::IsImpersonatingUser (
                          OUT HANDLE* phUserToken
                          )
{
    if ( FIsWinNT() == FALSE )
    {
        SetLastError( ERROR_NO_TOKEN );
        return( FALSE );
    }

    return( OpenThreadToken(
                GetCurrentThread(),
                TOKEN_QUERY,
                TRUE,
                phUserToken
                ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::GetTokenId, public
//
//  Synopsis:   get the token id which is the ModifiedId LUID inside of
//              the TOKEN_STATISTICS information
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::GetTokenId (
                           IN HANDLE hUserToken,
                           OUT PCRYPT_DATA_BLOB pTokenId
                           )
{
    BOOL             fResult;
    TOKEN_STATISTICS ts;
    DWORD            Length = 0;

    fResult = GetTokenInformation(
                 hUserToken,
                 TokenStatistics,
                 &ts,
                 sizeof( ts ),
                 &Length
                 );

    if ( fResult == TRUE )
    {
        pTokenId->cbData = sizeof( ts.ModifiedId );
        pTokenId->pbData = new BYTE [ sizeof( ts.ModifiedId ) ];
        if ( pTokenId->pbData != NULL )
        {
            memcpy(
               pTokenId->pbData,
               &ts.ModifiedId,
               sizeof( ts.ModifiedId )
               );
        }
        else
        {
            SetLastError( (DWORD) E_OUTOFMEMORY );
            fResult = FALSE;
        }
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::FreeTokenId, public
//
//  Synopsis:   free token id
//
//----------------------------------------------------------------------------
VOID
CDefaultChainEngineMgr::FreeTokenId (
                            IN PCRYPT_DATA_BLOB pTokenId
                            )
{
    delete pTokenId->pbData;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::FindImpersonationEngine, public
//
//  Synopsis:   find the impersonation engine
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::FindImpersonationEngine (
                            IN PCRYPT_DATA_BLOB pTokenId,
                            OUT PCIMPERSONATIONENGINE* ppEngine
                            )
{
    HLRUENTRY             hFound;
    PCIMPERSONATIONENGINE pEngine = NULL;

    hFound = I_CryptFindLruEntry( m_hImpersonationCache, pTokenId );

    if ( hFound != NULL )
    {
        pEngine = (PCIMPERSONATIONENGINE)I_CryptGetLruEntryData( hFound );
        pEngine->AddRef();

        *ppEngine = pEngine;

        I_CryptReleaseLruEntry( hFound );

        return( TRUE );
    }

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::CreateImpersonationEngine, public
//
//  Synopsis:   create an impersonation engine
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::CreateImpersonationEngine (
                              IN PCRYPT_DATA_BLOB pTokenId,
                              IN HCERTCHAINENGINE hChainEngine,
                              OUT PCIMPERSONATIONENGINE* ppEngine
                              )
{
    BOOL                  fResult = FALSE;
    PCIMPERSONATIONENGINE pEngine;

    pEngine = new CImpersonationEngine(
                                m_hImpersonationCache,
                                hChainEngine,
                                pTokenId,
                                fResult
                                );

    if ( pEngine == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }
    else if ( fResult == FALSE )
    {
        delete pEngine;
        return( FALSE );
    }

    *ppEngine = pEngine;
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::AddToImpersonationCache, public
//
//  Synopsis:   add to the cache
//
//----------------------------------------------------------------------------
VOID
CDefaultChainEngineMgr::AddToImpersonationCache(
                           IN PCIMPERSONATIONENGINE pEngine
                           )
{
    pEngine->AddRef();
    I_CryptInsertLruEntry( pEngine->LruEntry(), NULL );
}

//+---------------------------------------------------------------------------
//
//  Function:   DefaultChainEngineMgrOnImpersonationEngineRemoval
//
//  Synopsis:   removal notification
//
//----------------------------------------------------------------------------
VOID WINAPI
DefaultChainEngineMgrOnImpersonationEngineRemoval (
       IN LPVOID pv,
       IN LPVOID pvRemovalContext
       )
{
    ( (PCIMPERSONATIONENGINE)pv )->Release();
}

//+---------------------------------------------------------------------------
//
//  Function:   DefaultChainEngineMgrHashTokenIdentifier
//
//  Synopsis:   hash the token identifier
//
//----------------------------------------------------------------------------
DWORD WINAPI
DefaultChainEngineMgrHashTokenIdentifier (
       IN PCRYPT_DATA_BLOB pIdentifier
       )
{
    DWORD  dwHash = 0;
    DWORD  cb = pIdentifier->cbData;
    LPBYTE pb = pIdentifier->pbData;

    while ( cb-- )
    {
        if ( dwHash & 0x80000000 )
        {
            dwHash = ( dwHash << 1 ) | 1;
        }
        else
        {
            dwHash = dwHash << 1;
        }

        dwHash += *pb++;
    }

    return( dwHash );
}
//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationEngine::CImpersonationEngine, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CImpersonationEngine::CImpersonationEngine (
                                    IN HLRUCACHE hCache,
                                    IN HCERTCHAINENGINE hChainEngine,
                                    IN PCRYPT_DATA_BLOB pTokenId,
                                    OUT BOOL& rfResult
                                    )
{

    m_cRefs = 1;
    m_hChainEngine = NULL;
    m_hLruEntry = NULL;

    rfResult = I_CryptCreateLruEntry(
                      hCache,
                      pTokenId,
                      this,
                      &m_hLruEntry
                      );

    if ( rfResult == TRUE )
    {
        m_hChainEngine = hChainEngine;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationEngine::~CImpersonationEngine, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CImpersonationEngine::~CImpersonationEngine ()
{
    if ( m_hLruEntry != NULL )
    {
        I_CryptReleaseLruEntry( m_hLruEntry );
    }

    if ( m_hChainEngine != NULL )
    {
        CertFreeCertificateChainEngine( m_hChainEngine );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\chain\lru.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       lru.h
//
//  Contents:   LRU cache class definitions
//
//  History:    22-Dec-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__LRU_H__)
#define __LRU_H__

#include <lrucache.h>

//
// Forward declaration of LRU cache classes
//

class CLruCache;
class CLruEntry;

typedef CLruCache* PCLRUCACHE;
typedef CLruEntry* PCLRUENTRY;

//
// LRU cache bucket structure
//

typedef struct _LRU_CACHE_BUCKET {

    DWORD      Usage;
    PCLRUENTRY pList;

} LRU_CACHE_BUCKET, *PLRU_CACHE_BUCKET;

//
// CLruEntry class definition
//

class CLruEntry
{
public:

    //
    // Construction
    //

    CLruEntry (
        IN PCLRUCACHE pCache,
        IN PCRYPT_DATA_BLOB pIdentifier,
        IN LPVOID pvData,
        OUT BOOL& rfResult
        );

    ~CLruEntry ();

    //
    // Reference counting
    //

    inline VOID AddRef ();
    inline VOID Release ();

    //
    // Cache and Bucket access
    //

    inline PCLRUCACHE Cache ();
    inline PLRU_CACHE_BUCKET Bucket ();

    //
    // Data access
    //

    inline PCRYPT_DATA_BLOB Identifier ();
    inline LPVOID Data ();

    //
    // Link access
    //

    inline VOID SetPrevPointer (IN PCLRUENTRY pPrevEntry);
    inline VOID SetNextPointer (IN PCLRUENTRY pNextEntry);

    inline PCLRUENTRY PrevPointer ();
    inline PCLRUENTRY NextPointer ();

    //
    // LRU usage access
    //

    inline VOID SetUsage (DWORD Usage);
    inline DWORD Usage ();

    //
    // Cache Destruction notification
    //

    inline VOID OnCacheDestruction ();

private:

    //
    // Reference count
    //

    ULONG             m_cRefs;

    //
    // Cache pointer
    //

    PCLRUCACHE        m_pCache;

    //
    // Entry information
    //

    CRYPT_DATA_BLOB   m_Identifier;
    LPVOID            m_pvData;

    //
    // Links
    //

    PCLRUENTRY        m_pPrevEntry;
    PCLRUENTRY        m_pNextEntry;
    PLRU_CACHE_BUCKET m_pBucket;

    //
    // Usage
    //

    DWORD             m_Usage;
};

//
// CLruCache class definition
//

class CLruCache
{
public:

    //
    // Construction
    //

    CLruCache (
        IN PLRU_CACHE_CONFIG pConfig,
        OUT BOOL& rfResult
        );

    ~CLruCache ();

    //
    // Clearing the cache
    //

    VOID PurgeAllEntries (
              IN DWORD dwFlags,
              IN OPTIONAL LPVOID pvRemovalContext
              );

    //
    // Cache locking
    //

    inline VOID LockCache ();
    inline VOID UnlockCache ();

    //
    // LRU enable and disable
    //

    VOID EnableLruOfEntries (IN OPTIONAL LPVOID pvLruRemovalContext);

    VOID DisableLruOfEntries ();

    //
    // Cache entry manipulation
    //

    VOID InsertEntry (
               IN PCLRUENTRY pEntry,
               IN OPTIONAL LPVOID pvLruRemovalContext
               );

    VOID RemoveEntry (
               IN PCLRUENTRY pEntry,
               IN DWORD dwFlags,
               IN OPTIONAL LPVOID pvRemovalContext
               );

    VOID TouchEntry (IN PCLRUENTRY pEntry, IN DWORD dwFlags);

    //
    // Cache entry retrieval
    //

    PCLRUENTRY FindEntry (IN PCRYPT_DATA_BLOB pIdentifier, IN BOOL fTouchEntry);

    PCLRUENTRY NextMatchingEntry (
                   IN PCLRUENTRY pPrevEntry,
                   IN BOOL fTouchEntry
                   );

    //
    // Cache bucket retrieval
    //

    inline PLRU_CACHE_BUCKET BucketFromIdentifier (
                                   IN PCRYPT_DATA_BLOB pIdentifier
                                   );

    //
    // Configuration access
    //

    //
    // Use the configured free function to release the
    // pvData in an entry
    //
    // MOTE: This is called from the CLruEntry destructor
    //

    inline VOID FreeEntryData (IN LPVOID pvData);

    //
    // Access the configuration flags
    //

    inline DWORD Flags ();

    //
    // Usage clock access
    //

    inline VOID IncrementUsageClock ();
    inline DWORD UsageClock ();

    //
    // Walk all cache entries
    //

    VOID WalkEntries (IN PFN_WALK_ENTRIES pfnWalk, IN LPVOID pvParameter);

private:

    //
    // Cache configuration
    //

    LRU_CACHE_CONFIG  m_Config;

    //
    // Cache lock
    //

    CRITICAL_SECTION  m_Lock;

    //
    // Entry count
    //

    DWORD             m_cEntries;

    //
    // Cache Buckets
    //

    PLRU_CACHE_BUCKET m_aBucket;

    //
    // Usage clock
    //

    DWORD             m_UsageClock;

    //
    // LRU disabled count
    //

    DWORD             m_cLruDisabled;

    //
    // Private methods
    //

    VOID RemoveEntryFromBucket (
               IN PLRU_CACHE_BUCKET pBucket,
               IN PCLRUENTRY pEntry,
               IN DWORD dwFlags,
               IN OPTIONAL LPVOID pvRemovalContext
               );

    PCLRUENTRY FindNextMatchingEntryInBucket (
                   IN PLRU_CACHE_BUCKET pBucket,
                   IN PCLRUENTRY pCurrent,
                   IN PCRYPT_DATA_BLOB pIdentifier,
                   IN BOOL fTouchEntry
                   );

    VOID PurgeLeastRecentlyUsed (IN OPTIONAL LPVOID pvLruRemovalContext);

    inline VOID TouchEntryNoLock (IN PCLRUENTRY pEntry, IN DWORD dwFlags);
};

//
// Inline functions
//

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::AddRef, public
//
//  Synopsis:   increment entry reference count
//
//----------------------------------------------------------------------------
inline VOID
CLruEntry::AddRef ()
{
    InterlockedIncrement( (LONG *)&m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::Release, public
//
//  Synopsis:   decrement entry reference count and if count goes to zero
//              free the entry
//
//----------------------------------------------------------------------------
inline VOID
CLruEntry::Release ()
{
    if ( InterlockedDecrement( (LONG *)&m_cRefs ) == 0 )
    {
        delete this;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::Cache, public
//
//  Synopsis:   return the internal cache pointer
//
//----------------------------------------------------------------------------
inline PCLRUCACHE
CLruEntry::Cache ()
{
    return( m_pCache );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::Bucket, public
//
//  Synopsis:   return the internal cache bucket pointer
//
//----------------------------------------------------------------------------
inline PLRU_CACHE_BUCKET
CLruEntry::Bucket ()
{
    return( m_pBucket );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::Identifier, public
//
//  Synopsis:   return the internal entry identifier
//
//----------------------------------------------------------------------------
inline PCRYPT_DATA_BLOB
CLruEntry::Identifier ()
{
    return( &m_Identifier );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::Data, public
//
//  Synopsis:   return the internal entry data
//
//----------------------------------------------------------------------------
inline LPVOID
CLruEntry::Data ()
{
    return( m_pvData );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::SetPrevPointer, public
//
//  Synopsis:   set the previous entry pointer
//
//----------------------------------------------------------------------------
inline VOID
CLruEntry::SetPrevPointer (IN PCLRUENTRY pPrevEntry)
{
    m_pPrevEntry = pPrevEntry;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::SetNextPointer, public
//
//  Synopsis:   set the next entry pointer
//
//----------------------------------------------------------------------------
inline VOID
CLruEntry::SetNextPointer (IN PCLRUENTRY pNextEntry)
{
    m_pNextEntry = pNextEntry;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::PrevPointer, public
//
//  Synopsis:   return the previous entry pointer
//
//----------------------------------------------------------------------------
inline PCLRUENTRY
CLruEntry::PrevPointer ()
{
    return( m_pPrevEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::NextPointer, public
//
//  Synopsis:   return the next entry pointer
//
//----------------------------------------------------------------------------
inline PCLRUENTRY
CLruEntry::NextPointer ()
{
    return( m_pNextEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::SetUsage, public
//
//  Synopsis:   set the usage on the entry object and on
//              the corresponding cache bucket
//
//----------------------------------------------------------------------------
inline VOID
CLruEntry::SetUsage (IN DWORD Usage)
{
    m_Usage = Usage;
    m_pBucket->Usage = Usage;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::Usage, public
//
//  Synopsis:   return the internal entry usage
//
//----------------------------------------------------------------------------
inline DWORD
CLruEntry::Usage ()
{
    return( m_Usage );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::OnCacheDestruction, public
//
//  Synopsis:   cleanup reference to cache that is being destroyed
//
//----------------------------------------------------------------------------
inline VOID
CLruEntry::OnCacheDestruction ()
{
    m_pCache = NULL;
    m_pBucket = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::LockCache, public
//
//  Synopsis:   acquire the cache lock
//
//----------------------------------------------------------------------------
inline VOID
CLruCache::LockCache ()
{
    if ( m_Config.dwFlags & LRU_CACHE_NO_SERIALIZE )
    {
        return;
    }

    EnterCriticalSection( &m_Lock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::UnlockCache, public
//
//  Synopsis:   release the cache lock
//
//----------------------------------------------------------------------------
inline VOID
CLruCache::UnlockCache ()
{
    if ( m_Config.dwFlags & LRU_CACHE_NO_SERIALIZE )
    {
        return;
    }

    LeaveCriticalSection( &m_Lock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::BucketFromIdentifier, public
//
//  Synopsis:   retrieve the associated cache bucket given the entry identifier
//
//----------------------------------------------------------------------------
inline PLRU_CACHE_BUCKET
CLruCache::BucketFromIdentifier (
                 IN PCRYPT_DATA_BLOB pIdentifier
                 )
{
    DWORD Hash = ( *m_Config.pfnHash )( pIdentifier );

    return( &m_aBucket[ Hash % m_Config.cBuckets ] );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::FreeEntryData, public
//
//  Synopsis:   free the data using the configured free function
//
//----------------------------------------------------------------------------
inline VOID
CLruCache::FreeEntryData (IN LPVOID pvData)
{
    if ( m_Config.pfnFree != NULL )
    {
        ( *m_Config.pfnFree )( pvData );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::Flags, public
//
//  Synopsis:   access the configured flags
//
//----------------------------------------------------------------------------
inline DWORD
CLruCache::Flags ()
{
    return( m_Config.dwFlags );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::IncrementUsageClock, public
//
//  Synopsis:   increment the usage clock
//
//----------------------------------------------------------------------------
inline VOID
CLruCache::IncrementUsageClock ()
{
    m_UsageClock += 1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::UsageClock, public
//
//  Synopsis:   return the usage clock value
//
//----------------------------------------------------------------------------
inline DWORD
CLruCache::UsageClock ()
{
    return( m_UsageClock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::TouchEntryNoLock, public
//
//  Synopsis:   touch entry without taking the cache lock
//
//----------------------------------------------------------------------------
inline VOID
CLruCache::TouchEntryNoLock (IN PCLRUENTRY pEntry, IN DWORD dwFlags)
{
    if ( !( dwFlags & LRU_SUPPRESS_CLOCK_UPDATE ) )
    {
        IncrementUsageClock();
    }

    pEntry->SetUsage( UsageClock() );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\chain\ssctl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ssctl.cpp
//
//  Contents:   Self Signed Certificate Trust List Subsystem used by the
//              Certificate Chaining Infrastructure for building complex
//              chains
//
//  History:    11-Feb-98    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <dbgdef.h>

//+-------------------------------------------------------------------------
//  Attempt to get and allocate the CTL NextUpdate location Url array.
//--------------------------------------------------------------------------
BOOL
WINAPI
SSCtlGetNextUpdateUrl(
    IN PCCTL_CONTEXT pCtl,
    OUT PCRYPT_URL_ARRAY *ppUrlArray
    )
{
    BOOL fResult;
    PCRYPT_URL_ARRAY pUrlArray = NULL;
    DWORD cbUrlArray = 0;
    LPVOID apv[2];

    apv[0] = (LPVOID) pCtl;
    apv[1] = (LPVOID)(UINT_PTR)(0);     // Signer Index

    if (!ChainGetObjectUrl(
            URL_OID_CTL_NEXT_UPDATE,
            apv,
            0,              // dwFlags
            NULL,           // pUrlArray
            &cbUrlArray,
            NULL,           // pUrlInfo
            NULL,           // cbUrlInfo,
            NULL            // pvReserved
            ))
        goto GetObjectUrlError;

    pUrlArray = (PCRYPT_URL_ARRAY) new BYTE [cbUrlArray];
    if (NULL == pUrlArray)
        goto OutOfMemory;

    if (!ChainGetObjectUrl(
            URL_OID_CTL_NEXT_UPDATE,
            apv,
            0,              // dwFlags
            pUrlArray,
            &cbUrlArray,
            NULL,           // pUrlInfo
            NULL,           // cbUrlInfo,
            NULL            // pvReserved
            ))
        goto GetObjectUrlError;

    if (0 == pUrlArray->cUrl)
        goto NoNextUpdateUrls;

    fResult = TRUE;
CommonReturn:
    *ppUrlArray = pUrlArray;
    return fResult;

ErrorReturn:
    if (pUrlArray) {
        delete (LPBYTE) pUrlArray;
        pUrlArray = NULL;
    }
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetObjectUrlError)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
SET_ERROR(NoNextUpdateUrls, CRYPT_E_NOT_FOUND)
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::CSSCtlObject, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CSSCtlObject::CSSCtlObject (
                    IN PCCERTCHAINENGINE pChainEngine,
                    IN PCCTL_CONTEXT pCtlContext,
                    IN BOOL fAdditionalStore,
                    OUT BOOL& rfResult
                    )
{
    DWORD           cbData;
    CRYPT_DATA_BLOB DataBlob;

    rfResult = TRUE;

    m_cRefs = 1;
    m_pCtlContext = CertDuplicateCTLContext( pCtlContext );
    m_fHasSignatureBeenVerified = FALSE;
    m_fSignatureValid = FALSE;
    m_hMessageStore = NULL;
    m_hHashEntry = NULL;
    m_pChainEngine = pChainEngine;

    m_pNextUpdateUrlArray = NULL;
    m_dwOfflineCnt = 0;
    I_CryptZeroFileTime(&m_OfflineUpdateTime);

    memset( &m_SignerInfo, 0, sizeof( m_SignerInfo ) );

    cbData = CHAINHASHLEN;
    rfResult = CertGetCTLContextProperty(
                   pCtlContext,
                   CERT_MD5_HASH_PROP_ID,
                   m_rgbCtlHash,
                   &cbData 
                   );

    if ( rfResult && CHAINHASHLEN != cbData)
    {
        rfResult = FALSE;
        SetLastError( (DWORD) E_UNEXPECTED);
    }

    if (!fAdditionalStore)
    {
        if ( rfResult == TRUE )
        {
            DataBlob.cbData = CHAINHASHLEN;
            DataBlob.pbData = m_rgbCtlHash;

            rfResult = I_CryptCreateLruEntry(
                              pChainEngine->SSCtlObjectCache()->HashIndex(),
                              &DataBlob,
                              this,
                              &m_hHashEntry
                              );
        }

        if ( rfResult == TRUE )
        {
            m_hMessageStore = CertOpenStore(
                                  CERT_STORE_PROV_MSG,
                                  X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                  NULL,
                                  0,
                                  pCtlContext->hCryptMsg
                                  );

            if ( m_hMessageStore == NULL )
            {
                rfResult = FALSE;
            }
        }
    }

    if ( rfResult == TRUE )
    {
        rfResult = SSCtlGetSignerInfo( pCtlContext, &m_SignerInfo );
    }

    if (!fAdditionalStore)
    {
        if ( rfResult == TRUE )
        {
            if (!I_CryptIsZeroFileTime(&m_pCtlContext->pCtlInfo->NextUpdate))
            {
                // Ignore any errors
                SSCtlGetNextUpdateUrl(m_pCtlContext, &m_pNextUpdateUrlArray);
            }
        }
    }

    assert( m_pChainEngine != NULL );
    assert( m_pCtlContext != NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::~CSSCtlObject, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CSSCtlObject::~CSSCtlObject ()
{
    SSCtlFreeSignerInfo( &m_SignerInfo );

    if ( m_hMessageStore != NULL )
    {
        CertCloseStore( m_hMessageStore, 0 );
    }

    if ( m_pNextUpdateUrlArray != NULL )
    {
        delete (LPBYTE) m_pNextUpdateUrlArray;
    }

    if ( m_hHashEntry != NULL )
    {
        I_CryptReleaseLruEntry( m_hHashEntry );
    }

    CertFreeCTLContext( m_pCtlContext );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::GetSigner, public
//
//  Synopsis:   get the certificate object of the signer
//
//----------------------------------------------------------------------------
BOOL
CSSCtlObject::GetSigner (
                 IN PCCHAINPATHOBJECT pSubject,
                 IN PCCHAINCALLCONTEXT pCallContext,
                 IN HCERTSTORE hAdditionalStore,
                 OUT PCCHAINPATHOBJECT* ppSigner,
                 OUT BOOL* pfCtlSignatureValid
                 )
{
    BOOL              fResult;
    PCCHAINPATHOBJECT pSigner = NULL;
    BOOL fNewSigner = TRUE;

    fResult = SSCtlGetSignerChainPathObject(
                   pSubject,
                   pCallContext,
                   &m_SignerInfo,
                   hAdditionalStore,
                   &pSigner,
                   &fNewSigner
                   );

    if (fResult)
    {
        if ( !m_fHasSignatureBeenVerified || fNewSigner )
        {
            CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA CtrlPara;

            memset(&CtrlPara, 0, sizeof(CtrlPara));
            CtrlPara.cbSize = sizeof(CtrlPara);
            // CtrlPara.hCryptProv =

            // This needs to be updated when chain building
            // supports CTLs with more than one signer.
            CtrlPara.dwSignerIndex = 0;
            CtrlPara.dwSignerType = CMSG_VERIFY_SIGNER_CERT;
            CtrlPara.pvSigner = (void *) pSigner->CertObject()->CertContext();


            m_fSignatureValid = CryptMsgControl(
                                     m_pCtlContext->hCryptMsg,
                                     0,
                                     CMSG_CTRL_VERIFY_SIGNATURE_EX,
                                     &CtrlPara
                                     );

            m_fHasSignatureBeenVerified = TRUE;

            CertPerfIncrementChainVerifyCtlSignatureCount();
        }
        else
        {
            CertPerfIncrementChainBeenVerifiedCtlSignatureCount();
        }

        *ppSigner = pSigner;
    }
    *pfCtlSignatureValid = m_fSignatureValid;


    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::GetTrustListInfo, public
//
//  Synopsis:   get the trust list information relative to a particular cert
//              object
//
//----------------------------------------------------------------------------
BOOL
CSSCtlObject::GetTrustListInfo (
                 IN PCCERT_CONTEXT pCertContext,
                 OUT PCERT_TRUST_LIST_INFO* ppTrustListInfo
                 )
{
    PCTL_ENTRY            pCtlEntry;
    PCERT_TRUST_LIST_INFO pTrustListInfo;

    pCtlEntry = CertFindSubjectInCTL(
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    CTL_CERT_SUBJECT_TYPE,
                    (LPVOID)pCertContext,
                    m_pCtlContext,
                    0
                    );

    if ( pCtlEntry == NULL )
    {
        SetLastError( (DWORD) CRYPT_E_NOT_FOUND );
        return( FALSE );
    }

    pTrustListInfo = new CERT_TRUST_LIST_INFO;
    if ( pTrustListInfo == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    pTrustListInfo->cbSize = sizeof( CERT_TRUST_LIST_INFO );
    pTrustListInfo->pCtlEntry = pCtlEntry;
    pTrustListInfo->pCtlContext = CertDuplicateCTLContext( m_pCtlContext );

    *ppTrustListInfo = pTrustListInfo;

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::CalculateStatus, public
//
//  Synopsis:   calculate the status
//
//----------------------------------------------------------------------------
VOID
CSSCtlObject::CalculateStatus (
                       IN LPFILETIME pTime,
                       IN PCERT_USAGE_MATCH pRequestedUsage,
                       IN OUT PCERT_TRUST_STATUS pStatus
                       )
{
    assert( m_fHasSignatureBeenVerified == TRUE );

    SSCtlGetCtlTrustStatus(
         m_pCtlContext,
         m_fSignatureValid,
         pTime,
         pRequestedUsage,
         pStatus
         );
}


//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::HasNextUpdateUrl, public
//
//  Synopsis:   returns TRUE if the Ctl has a NextUpdate time and location Url
//
//----------------------------------------------------------------------------
BOOL CSSCtlObject::HasNextUpdateUrl (
                OUT LPFILETIME pUpdateTime
                )
{
    if ( m_pNextUpdateUrlArray != NULL )
    {
        assert(!I_CryptIsZeroFileTime(&m_pCtlContext->pCtlInfo->NextUpdate));
        if (0 != m_dwOfflineCnt) {
            assert(!I_CryptIsZeroFileTime(&m_OfflineUpdateTime));
            *pUpdateTime = m_OfflineUpdateTime;
        } else
            *pUpdateTime = m_pCtlContext->pCtlInfo->NextUpdate;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::SetOffline, public
//
//  Synopsis:   called when offline
//
//----------------------------------------------------------------------------
void CSSCtlObject::SetOffline (
                IN LPFILETIME pCurrentTime,
                OUT LPFILETIME pUpdateTime
                )
{
    m_dwOfflineCnt++;

    I_CryptIncrementFileTimeBySeconds(
            pCurrentTime,
            ChainGetOfflineUrlDeltaSeconds(m_dwOfflineCnt),
            &m_OfflineUpdateTime
            );

    *pUpdateTime = m_OfflineUpdateTime;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::CSSCtlObjectCache, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CSSCtlObjectCache::CSSCtlObjectCache (
                         OUT BOOL& rfResult
                         )
{
    LRU_CACHE_CONFIG Config;

    memset( &Config, 0, sizeof( Config ) );

    Config.dwFlags = LRU_CACHE_NO_SERIALIZE | LRU_CACHE_NO_COPY_IDENTIFIER;
    Config.pfnHash = CertObjectCacheHashMd5Identifier;
    Config.cBuckets = DEFAULT_CERT_OBJECT_CACHE_BUCKETS;
    Config.pfnOnRemoval = SSCtlOnRemovalFromCache;

    m_hHashIndex = NULL;

    rfResult = I_CryptCreateLruCache( &Config, &m_hHashIndex );

    I_CryptZeroFileTime(&m_UpdateTime);
    m_fFirstUpdate = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::~CSSCtlObjectCache, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CSSCtlObjectCache::~CSSCtlObjectCache ()
{
    I_CryptFreeLruCache( m_hHashIndex, 0, NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::PopulateCache, public
//
//  Synopsis:   populate the cache
//
//----------------------------------------------------------------------------
BOOL
CSSCtlObjectCache::PopulateCache (
                           IN PCCERTCHAINENGINE pChainEngine
                           )
{
    assert( pChainEngine->SSCtlObjectCache() == this );

    return( SSCtlPopulateCacheFromCertStore( pChainEngine, NULL ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::AddObject, public
//
//  Synopsis:   add an object to the cache
//
//----------------------------------------------------------------------------
BOOL
CSSCtlObjectCache::AddObject (
                      IN PCSSCTLOBJECT pSSCtlObject,
                      IN BOOL fCheckForDuplicate
                      )
{
    FILETIME UpdateTime;

    if ( fCheckForDuplicate == TRUE )
    {
        PCSSCTLOBJECT   pDuplicate;

        pDuplicate = FindObjectByHash( pSSCtlObject->CtlHash() );
        if ( pDuplicate != NULL )
        {
            pDuplicate->Release();
            SetLastError( (DWORD) CRYPT_E_EXISTS );
            return( FALSE );
        }
    }

    pSSCtlObject->AddRef();

    if (pSSCtlObject->HasNextUpdateUrl(&UpdateTime))
    {
        // Set earliest update time
        if (I_CryptIsZeroFileTime(&m_UpdateTime) ||
                0 > CompareFileTime(&UpdateTime, &m_UpdateTime))
        {
            m_UpdateTime = UpdateTime;
        }

        m_fFirstUpdate = TRUE;

    }

    I_CryptInsertLruEntry( pSSCtlObject->HashIndexEntry(), NULL );

    if (pSSCtlObject->MessageStore() )
    {
        CertAddStoreToCollection(
            pSSCtlObject->ChainEngine()->OtherStore(),
            pSSCtlObject->MessageStore(),
            0,
            0
            );
    }

    CertPerfIncrementChainCtlCacheCount();

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::RemoveObject, public
//
//  Synopsis:   remove object from cache
//
//----------------------------------------------------------------------------
VOID
CSSCtlObjectCache::RemoveObject (
                         IN PCSSCTLOBJECT pSSCtlObject
                         )
{
    I_CryptRemoveLruEntry( pSSCtlObject->HashIndexEntry(), 0, NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::FindObjectByHash, public
//
//  Synopsis:   find object with given hash
//
//----------------------------------------------------------------------------
PCSSCTLOBJECT
CSSCtlObjectCache::FindObjectByHash (
                       IN BYTE rgbHash [ CHAINHASHLEN ]
                       )
{
    HLRUENTRY       hFound;
    PCSSCTLOBJECT   pFound = NULL;
    CRYPT_HASH_BLOB HashBlob;

    HashBlob.cbData = CHAINHASHLEN;
    HashBlob.pbData = rgbHash;

    hFound = I_CryptFindLruEntry( m_hHashIndex, &HashBlob );
    if ( hFound != NULL )
    {
        pFound = (PCSSCTLOBJECT)I_CryptGetLruEntryData( hFound );
        pFound->AddRef();

        I_CryptReleaseLruEntry( hFound );
    }

    return( pFound );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::EnumObjects, public
//
//  Synopsis:   enumerate objects
//
//----------------------------------------------------------------------------
VOID
CSSCtlObjectCache::EnumObjects (
                       IN PFN_ENUM_SSCTLOBJECTS pfnEnum,
                       IN LPVOID pvParameter
                       )
{
    SSCTL_ENUM_OBJECTS_DATA EnumData;

    EnumData.pfnEnumObjects = pfnEnum;
    EnumData.pvEnumParameter = pvParameter;

    I_CryptWalkAllLruCacheEntries(
           m_hHashIndex,
           SSCtlEnumObjectsWalkFn,
           &EnumData
           );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::Resync, public
//
//  Synopsis:   resync the cache
//
//----------------------------------------------------------------------------
BOOL
CSSCtlObjectCache::Resync (IN PCCERTCHAINENGINE pChainEngine)
{
    I_CryptFlushLruCache( m_hHashIndex, 0, NULL );

    I_CryptZeroFileTime(&m_UpdateTime);
    m_fFirstUpdate = FALSE;

    return( PopulateCache( pChainEngine ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::UpdateCache, public
//
//  Synopsis:   update the cache
//
//              Leaves the engine's critical section to do the URL
//              fetching. If the engine was touched by another thread,
//              it fails with LastError set to ERROR_CAN_NOT_COMPLETE.
//
//              If the CTL is updated, increments the engine's touch count
//              and flushes issuer and end cert object caches.
//
//  Assumption: Chain engine is locked once in the calling thread.
//
//----------------------------------------------------------------------------
BOOL
CSSCtlObjectCache::UpdateCache (
    IN PCCERTCHAINENGINE pChainEngine,
    IN PCCHAINCALLCONTEXT pCallContext
    )
{
    FILETIME CurrentTime;
    SSCTL_UPDATE_CTL_OBJ_PARA Para;
    
    assert( pChainEngine->SSCtlObjectCache() == this );

    // Check if we have any CTLs needing to be updated
    if (I_CryptIsZeroFileTime(&m_UpdateTime))
        return TRUE;
    pCallContext->CurrentTime(&CurrentTime);
    if (0 < CompareFileTime(&m_UpdateTime, &CurrentTime))
        return TRUE;

    if (!m_fFirstUpdate && !pCallContext->IsOnline())
        return TRUE;

    memset(&Para, 0, sizeof(Para));
    Para.pChainEngine = pChainEngine;
    Para.pCallContext = pCallContext;

    EnumObjects(SSCtlUpdateCtlObjectEnumFn, &Para);
    if (pCallContext->IsTouchedEngine()) {
        PSSCTL_UPDATE_CTL_OBJ_ENTRY pEntry;

        pEntry = Para.pEntry;
        while (pEntry) {
            PSSCTL_UPDATE_CTL_OBJ_ENTRY pDeleteEntry;

            pEntry->pSSCtlObjectAdd->Release();

            pDeleteEntry = pEntry;
            pEntry = pEntry->pNext;
            delete pDeleteEntry;
        }

        return FALSE;
    }


    m_UpdateTime = Para.UpdateTime;
    m_fFirstUpdate = FALSE;

    if (Para.pEntry) {
        HCERTSTORE hTrustStore;
        PSSCTL_UPDATE_CTL_OBJ_ENTRY pEntry;

        hTrustStore = pChainEngine->OpenTrustStore();

        pChainEngine->CertObjectCache()->FlushObjects( pCallContext );
        pCallContext->TouchEngine();

        pEntry = Para.pEntry;
        while (pEntry) {
            PSSCTL_UPDATE_CTL_OBJ_ENTRY pDeleteEntry;

            RemoveObject(pEntry->pSSCtlObjectRemove);
            if (AddObject(pEntry->pSSCtlObjectAdd, TRUE)) {
                if (hTrustStore) {
                    // Persist the newer CTL to the trust store
                    CertAddCTLContextToStore(
                        hTrustStore,
                        pEntry->pSSCtlObjectAdd->CtlContext(),
                        CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES,
                        NULL
                        );
                }
            }

            pEntry->pSSCtlObjectAdd->Release();

            pDeleteEntry = pEntry;
            pEntry = pEntry->pNext;
            delete pDeleteEntry;
        }

        if (hTrustStore)
            CertCloseStore(hTrustStore, 0);
    }


    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlOnRemovalFromCache
//
//  Synopsis:   SS CTL removal notification used when the cache is destroyed
//              or an object is explicitly removed.  Note that this cache
//              does not LRU remove objects
//
//----------------------------------------------------------------------------
VOID WINAPI
SSCtlOnRemovalFromCache (
     IN LPVOID pv,
     IN OPTIONAL LPVOID pvRemovalContext
     )
{
    PCSSCTLOBJECT pSSCtlObject = (PCSSCTLOBJECT) pv;
    CertPerfDecrementChainCtlCacheCount();

    assert( pvRemovalContext == NULL );

    if (pSSCtlObject->MessageStore() )
    {
        CertRemoveStoreFromCollection(
            pSSCtlObject->ChainEngine()->OtherStore(),
            pSSCtlObject->MessageStore()
            );
    }

    pSSCtlObject->Release();
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlGetSignerInfo
//
//  Synopsis:   get the signer info
//
//----------------------------------------------------------------------------
BOOL WINAPI
SSCtlGetSignerInfo (
     IN PCCTL_CONTEXT pCtlContext,
     OUT PSSCTL_SIGNER_INFO pSignerInfo
     )
{
    BOOL              fResult;
    PCERT_INFO        pMessageSignerCertInfo = NULL;
    DWORD             cbData = 0;

    fResult = CryptMsgGetParam(
                   pCtlContext->hCryptMsg,
                   CMSG_SIGNER_CERT_INFO_PARAM,
                   0,
                   NULL,
                   &cbData
                   );

    if ( fResult == TRUE )
    {
        pMessageSignerCertInfo = (PCERT_INFO)new BYTE [ cbData ];
        if ( pMessageSignerCertInfo != NULL )
        {
            fResult = CryptMsgGetParam(
                           pCtlContext->hCryptMsg,
                           CMSG_SIGNER_CERT_INFO_PARAM,
                           0,
                           pMessageSignerCertInfo,
                           &cbData
                           );
        }
        else
        {
            SetLastError( (DWORD) E_OUTOFMEMORY );
            fResult = FALSE;
        }
    }

    if ( fResult == TRUE )
    {
        pSignerInfo->pMessageSignerCertInfo = pMessageSignerCertInfo;
        pSignerInfo->fSignerHashAvailable = FALSE;
    }
    else
    {
        delete pMessageSignerCertInfo;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlFreeSignerInfo
//
//  Synopsis:   free the data in the signer info
//
//----------------------------------------------------------------------------
VOID WINAPI
SSCtlFreeSignerInfo (
     IN PSSCTL_SIGNER_INFO pSignerInfo
     )
{
    delete (LPBYTE)pSignerInfo->pMessageSignerCertInfo;
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlGetSignerChainPathObject
//
//  Synopsis:   get the signer chain path object
//
//----------------------------------------------------------------------------
BOOL WINAPI
SSCtlGetSignerChainPathObject (
     IN PCCHAINPATHOBJECT pSubject,
     IN PCCHAINCALLCONTEXT pCallContext,
     IN PSSCTL_SIGNER_INFO pSignerInfo,
     IN HCERTSTORE hAdditionalStore,
     OUT PCCHAINPATHOBJECT* ppSigner,
     OUT BOOL *pfNewSigner
     )
{
    BOOL              fResult = TRUE;
    PCCERTCHAINENGINE pChainEngine = pSubject->CertObject()->ChainEngine();
    PCCERTOBJECTCACHE pCertObjectCache = pChainEngine->CertObjectCache();
    PCCERTOBJECT      pCertObject = NULL;
    PCCERT_CONTEXT    pCertContext = NULL;
    PCCHAINPATHOBJECT pSigner = NULL;
    BOOL              fAdditionalStoreUsed = FALSE;
    BYTE              rgbCertHash[ CHAINHASHLEN ];


    *pfNewSigner = FALSE;

    if ( pSignerInfo->fSignerHashAvailable == TRUE )
    {
        pCertObject = pCertObjectCache->FindIssuerObjectByHash(
            pSignerInfo->rgbSignerCertHash );
    }

    if ( pCertObject == NULL )
    {
        if ( pSignerInfo->fSignerHashAvailable == TRUE )
        {
            pCertContext = SSCtlFindCertificateInStoreByHash(
                                pChainEngine->OtherStore(),
                                pSignerInfo->rgbSignerCertHash
                                );

            if ( ( pCertContext == NULL ) && ( hAdditionalStore != NULL ) )
            {
                fAdditionalStoreUsed = TRUE;

                pCertContext = SSCtlFindCertificateInStoreByHash(
                                    hAdditionalStore,
                                    pSignerInfo->rgbSignerCertHash
                                    );
            }
        }

        if ( pCertContext == NULL )
        {
            *pfNewSigner = TRUE;
            fAdditionalStoreUsed = FALSE;

            pCertContext = CertGetSubjectCertificateFromStore(
                                pChainEngine->OtherStore(),
                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                pSignerInfo->pMessageSignerCertInfo
                                );
        }

        if ( ( pCertContext == NULL ) && ( hAdditionalStore != NULL ) )
        {
            fAdditionalStoreUsed = TRUE;

            pCertContext = CertGetSubjectCertificateFromStore(
                                hAdditionalStore,
                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                pSignerInfo->pMessageSignerCertInfo
                                );
        }

        if ( pCertContext != NULL )
        {
            DWORD cbData = CHAINHASHLEN;
            fResult = CertGetCertificateContextProperty(
                          pCertContext,
                          CERT_MD5_HASH_PROP_ID,
                          rgbCertHash,
                          &cbData
                          );

            if ( fResult && CHAINHASHLEN != cbData)
            {
                fResult = FALSE;
                SetLastError( (DWORD) E_UNEXPECTED);
            }

            if ( fResult == TRUE )
            {
                fResult = ChainCreateCertObject (
                    fAdditionalStoreUsed ?
                        CERT_EXTERNAL_ISSUER_OBJECT_TYPE :
                        CERT_CACHED_ISSUER_OBJECT_TYPE,
                    pCallContext,
                    pCertContext,
                    rgbCertHash,
                    &pCertObject
                    );
            }

            CertFreeCertificateContext( pCertContext );
        }
        else
        {
            fResult = FALSE;
            SetLastError((DWORD) CRYPT_E_NOT_FOUND);
        }
    }

    if ( fResult )
    {
        assert(pCertObject);
        fResult = ChainCreatePathObject(
            pCallContext,
            pCertObject,
            hAdditionalStore,
            &pSigner
            );
    }

    if ( fResult )
    {
        assert(pSigner);

        if ( !pSignerInfo->fSignerHashAvailable || *pfNewSigner )
        {
            memcpy(
               pSignerInfo->rgbSignerCertHash,
               rgbCertHash,
               CHAINHASHLEN
               );

            pSignerInfo->fSignerHashAvailable = TRUE;
        }

    }

    if ( pCertObject != NULL )
    {
        pCertObject->Release();
    }

    *ppSigner = pSigner;

    return( fResult );
}


//+---------------------------------------------------------------------------
//
//  Function:   SSCtlFindCertificateInStoreByHash
//
//  Synopsis:   find certificate in store by hash
//
//----------------------------------------------------------------------------
PCCERT_CONTEXT WINAPI
SSCtlFindCertificateInStoreByHash (
     IN HCERTSTORE hStore,
     IN BYTE rgbHash [ CHAINHASHLEN]
     )
{
    CRYPT_HASH_BLOB HashBlob;

    HashBlob.cbData = CHAINHASHLEN;
    HashBlob.pbData = rgbHash;

    return( CertFindCertificateInStore(
                hStore,
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                0,
                CERT_FIND_MD5_HASH,
                &HashBlob,
                NULL
                ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlGetCtlTrustStatus
//
//  Synopsis:   get the trust status for the CTL
//
//----------------------------------------------------------------------------
VOID WINAPI
SSCtlGetCtlTrustStatus (
     IN PCCTL_CONTEXT pCtlContext,
     IN BOOL fSignatureValid,
     IN LPFILETIME pTime,
     IN PCERT_USAGE_MATCH pRequestedUsage,
     IN OUT PCERT_TRUST_STATUS pStatus
     )
{
    FILETIME          NoTime;
    CERT_TRUST_STATUS UsageStatus;

    memset( &NoTime, 0, sizeof( NoTime ) );

    if ( fSignatureValid == FALSE )
    {
        pStatus->dwErrorStatus |= CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID;
    }

    if ( ( CompareFileTime(
                  pTime,
                  &pCtlContext->pCtlInfo->ThisUpdate
                  ) < 0 ) ||
         ( ( ( CompareFileTime(
                      &NoTime,
                      &pCtlContext->pCtlInfo->NextUpdate
                      ) != 0 ) &&
             ( CompareFileTime(
                      pTime,
                      &pCtlContext->pCtlInfo->NextUpdate
                      ) > 0 ) ) ) )
    {
        pStatus->dwErrorStatus |= CERT_TRUST_CTL_IS_NOT_TIME_VALID;
    }

    memset( &UsageStatus, 0, sizeof( UsageStatus ) );
    ChainGetUsageStatus(
         (PCERT_ENHKEY_USAGE)&pRequestedUsage->Usage,
         (PCERT_ENHKEY_USAGE)&pCtlContext->pCtlInfo->SubjectUsage,
         pRequestedUsage->dwType,
         &UsageStatus
         );

    if ( UsageStatus.dwErrorStatus & CERT_TRUST_IS_NOT_VALID_FOR_USAGE )
    {
        pStatus->dwErrorStatus |= CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlPopulateCacheFromCertStore
//
//  Synopsis:   populate the SS CTL object cache from certificate store CTLs
//
//----------------------------------------------------------------------------
BOOL WINAPI
SSCtlPopulateCacheFromCertStore (
     IN PCCERTCHAINENGINE pChainEngine,
     IN OPTIONAL HCERTSTORE hStore
     )
{
    BOOL               fResult;
    BOOL               fAdditionalStore = TRUE;
    PCCTL_CONTEXT      pCtlContext = NULL;
    BYTE               rgbCtlHash[ CHAINHASHLEN ];
    PCSSCTLOBJECT      pSSCtlObject;
    PCSSCTLOBJECTCACHE pSSCtlObjectCache;

    pSSCtlObjectCache = pChainEngine->SSCtlObjectCache();

    if ( hStore == NULL )
    {
        hStore = pChainEngine->TrustStore();
        fAdditionalStore = FALSE;
    }

    while ( ( pCtlContext = CertEnumCTLsInStore(
                                hStore,
                                pCtlContext
                                ) ) != NULL )
    {
        DWORD cbData = CHAINHASHLEN;
        fResult = CertGetCTLContextProperty(
                      pCtlContext,
                      CERT_MD5_HASH_PROP_ID,
                      rgbCtlHash,
                      &cbData
                      );
        if ( fResult && CHAINHASHLEN != cbData)
        {
            fResult = FALSE;
            SetLastError( (DWORD) E_UNEXPECTED);
        }

        if ( fResult == TRUE )
        {
            pSSCtlObject = pSSCtlObjectCache->FindObjectByHash( rgbCtlHash );
            if ( pSSCtlObject == NULL )
            {
                fResult = SSCtlCreateCtlObject(
                               pChainEngine,
                               pCtlContext,
                               FALSE,               // fAdditionalStore
                               &pSSCtlObject
                               );
            }
            else
            {
                pSSCtlObject->Release();
                fResult = FALSE;
            }

            if ( fResult == TRUE )
            {
                fResult = pSSCtlObjectCache->AddObject( pSSCtlObject, FALSE );

                // NOTE: Since fDuplicate == FALSE this should never fail
                assert( fResult == TRUE );

                pSSCtlObject->Release();
            }
        }
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlCreateCtlObject
//
//  Synopsis:   create an SS CTL Object
//
//----------------------------------------------------------------------------
BOOL WINAPI
SSCtlCreateCtlObject (
     IN PCCERTCHAINENGINE pChainEngine,
     IN PCCTL_CONTEXT pCtlContext,
     IN BOOL fAdditionalStore,
     OUT PCSSCTLOBJECT* ppSSCtlObject
     )
{
    BOOL          fResult = TRUE;
    PCSSCTLOBJECT pSSCtlObject;

    pSSCtlObject = new CSSCtlObject( 
        pChainEngine, pCtlContext, fAdditionalStore, fResult );
    if ( pSSCtlObject == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        fResult = FALSE;
    }
    else if ( fResult == TRUE )
    {
        *ppSSCtlObject = pSSCtlObject;
    }
    else
    {
        delete pSSCtlObject;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlEnumObjectsWalkFn
//
//  Synopsis:   object enumerator walk function
//
//----------------------------------------------------------------------------
BOOL WINAPI
SSCtlEnumObjectsWalkFn (
     IN LPVOID pvParameter,
     IN HLRUENTRY hEntry
     )
{
    PSSCTL_ENUM_OBJECTS_DATA pEnumData = (PSSCTL_ENUM_OBJECTS_DATA)pvParameter;

    return( ( *pEnumData->pfnEnumObjects )(
                             pEnumData->pvEnumParameter,
                             (PCSSCTLOBJECT)I_CryptGetLruEntryData( hEntry )
                             ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlCreateObjectCache
//
//  Synopsis:   create the SS CTL object cache
//
//----------------------------------------------------------------------------
BOOL WINAPI
SSCtlCreateObjectCache (
     OUT PCSSCTLOBJECTCACHE* ppSSCtlObjectCache
     )
{
    BOOL               fResult = TRUE;
    PCSSCTLOBJECTCACHE pSSCtlObjectCache;

    pSSCtlObjectCache = new CSSCtlObjectCache( fResult );

    if ( pSSCtlObjectCache == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        fResult = FALSE;
    }
    else if ( fResult == TRUE )
    {
        *ppSSCtlObjectCache = pSSCtlObjectCache;
    }
    else
    {
        delete pSSCtlObjectCache;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlFreeObjectCache
//
//  Synopsis:   free the object cache
//
//----------------------------------------------------------------------------
VOID WINAPI
SSCtlFreeObjectCache (
     IN PCSSCTLOBJECTCACHE pSSCtlObjectCache
     )
{
    delete pSSCtlObjectCache;
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlFreeTrustListInfo
//
//  Synopsis:   free the trust list info
//
//----------------------------------------------------------------------------
VOID WINAPI
SSCtlFreeTrustListInfo (
     IN PCERT_TRUST_LIST_INFO pTrustListInfo
     )
{
    CertFreeCTLContext( pTrustListInfo->pCtlContext );

    delete pTrustListInfo;
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlAllocAndCopyTrustListInfo
//
//  Synopsis:   allocate and copy the trust list info
//
//----------------------------------------------------------------------------
BOOL WINAPI
SSCtlAllocAndCopyTrustListInfo (
     IN PCERT_TRUST_LIST_INFO pTrustListInfo,
     OUT PCERT_TRUST_LIST_INFO* ppTrustListInfo
     )
{
    PCERT_TRUST_LIST_INFO pCopyTrustListInfo;

    pCopyTrustListInfo = new CERT_TRUST_LIST_INFO;
    if ( pCopyTrustListInfo == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    pCopyTrustListInfo->cbSize = sizeof( CERT_TRUST_LIST_INFO );

    pCopyTrustListInfo->pCtlContext = CertDuplicateCTLContext(
                                          pTrustListInfo->pCtlContext
                                          );

    pCopyTrustListInfo->pCtlEntry = pTrustListInfo->pCtlEntry;

    *ppTrustListInfo = pCopyTrustListInfo;

    return( TRUE );
}

//+-------------------------------------------------------------------------
//  Retrieve a newer and time valid CTL at one of the NextUpdate Urls
//
//  Leaves the engine's critical section to do the URL
//  fetching. If the engine was touched by another thread,
//  it fails with LastError set to ERROR_CAN_NOT_COMPLETE.
//
//  Assumption: Chain engine is locked once in the calling thread.
//--------------------------------------------------------------------------
BOOL
WINAPI
SSCtlRetrieveCtlUrl(
    IN PCCERTCHAINENGINE pChainEngine,
    IN PCCHAINCALLCONTEXT pCallContext,
    IN OUT PCRYPT_URL_ARRAY pNextUpdateUrlArray,
    IN DWORD dwRetrievalFlags,
    IN OUT PCCTL_CONTEXT *ppCtl,
    IN OUT BOOL *pfNewerCtl,
    IN OUT BOOL *pfTimeValid
    )
{
    BOOL fResult;
    DWORD i;

    // Loop through Urls and try to retrieve a newer and time valid CTL
    for (i = 0; i < pNextUpdateUrlArray->cUrl; i++) {
        PCCTL_CONTEXT pNewCtl = NULL;
        LPWSTR pwszUrl = NULL;
        DWORD cbUrl;


        // Do URL fetching outside of the engine's critical section

        // Need to make a copy of the Url string. pNextUpdateUrlArray
        // can be modified by another thread outside of the critical section.
        cbUrl = (wcslen(pNextUpdateUrlArray->rgwszUrl[i]) + 1) * sizeof(WCHAR);
        pwszUrl = (LPWSTR) PkiNonzeroAlloc(cbUrl);
        if (NULL == pwszUrl)
            goto OutOfMemory;
        memcpy(pwszUrl, pNextUpdateUrlArray->rgwszUrl[i], cbUrl);

        pCallContext->ChainEngine()->UnlockEngine();
        fResult = ChainRetrieveObjectByUrlW(
                pwszUrl,
                CONTEXT_OID_CTL,
                dwRetrievalFlags |
                    CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL |
                    CRYPT_STICKY_CACHE_RETRIEVAL,
                pCallContext->ChainPara()->dwUrlRetrievalTimeout,
                (LPVOID *) &pNewCtl,
                NULL,                               // hAsyncRetrieve
                NULL,                               // pCredentials
                NULL,                               // pvVerify
                NULL                                // pAuxInfo
                );
        pCallContext->ChainEngine()->LockEngine();

        PkiFree(pwszUrl);

        if (pCallContext->IsTouchedEngine()) {
            if (pNewCtl)
                CertFreeCTLContext(pNewCtl);
            goto TouchedDuringUrlRetrieval;
        }

        if (fResult) {
            PCCTL_CONTEXT pOldCtl;

            assert(pNewCtl);

            pOldCtl = *ppCtl;
            if (0 < CompareFileTime(&pNewCtl->pCtlInfo->ThisUpdate,
                        &pOldCtl->pCtlInfo->ThisUpdate)) {
                FILETIME CurrentTime;

                // Move us to the head of the Url list
                DWORD j;
                LPWSTR pwszUrl = pNextUpdateUrlArray->rgwszUrl[i];

                for (j = i; 0 < j; j--) {
                    pNextUpdateUrlArray->rgwszUrl[j] =
                        pNextUpdateUrlArray->rgwszUrl[j - 1];
                }
                pNextUpdateUrlArray->rgwszUrl[0] = pwszUrl;

                *pfNewerCtl = TRUE;
                CertFreeCTLContext(pOldCtl);
                *ppCtl = pNewCtl;

                pCallContext->CurrentTime(&CurrentTime);
                if (I_CryptIsZeroFileTime(&pNewCtl->pCtlInfo->NextUpdate) ||
                        0 < CompareFileTime(&pNewCtl->pCtlInfo->NextUpdate,
                                &CurrentTime)) {
                    *pfTimeValid = TRUE;
                    break;
                }
            } else
                CertFreeCTLContext(pNewCtl);
        }
    }


    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(TouchedDuringUrlRetrieval, ERROR_CAN_NOT_COMPLETE)
TRACE_ERROR(OutOfMemory)
}


//+-------------------------------------------------------------------------
//  Update Ctl Object Enum Function
//
//  Leaves the engine's critical section to do the URL
//  fetching. If the engine was touched by another thread,
//  it fails with LastError set to ERROR_CAN_NOT_COMPLETE.
//
//  Assumption: Chain engine is locked once in the calling thread.
//--------------------------------------------------------------------------
BOOL
WINAPI
SSCtlUpdateCtlObjectEnumFn(
    IN LPVOID pvPara,
    IN PCSSCTLOBJECT pSSCtlObject
    )
{
    BOOL fTouchResult = TRUE;

    PSSCTL_UPDATE_CTL_OBJ_PARA pPara = (PSSCTL_UPDATE_CTL_OBJ_PARA) pvPara;
    FILETIME CurrentTime;
    FILETIME UpdateTime;
    PCCTL_CONTEXT pRetrieveCtl = NULL;
    BOOL fTimeValid = FALSE;
    BOOL fNewerCtl = FALSE;
    PCRYPT_URL_ARRAY pNextUpdateUrlArray;

    if (!pSSCtlObject->HasNextUpdateUrl(&UpdateTime))
        return TRUE;

    pPara->pCallContext->CurrentTime(&CurrentTime);

    if (0 < CompareFileTime(&UpdateTime, &CurrentTime))
        goto CommonReturn;

    pRetrieveCtl = CertDuplicateCTLContext(pSSCtlObject->CtlContext());
    pNextUpdateUrlArray = pSSCtlObject->NextUpdateUrlArray();

    SSCtlRetrieveCtlUrl(
        pPara->pChainEngine,
        pPara->pCallContext,
        pNextUpdateUrlArray,
        CRYPT_CACHE_ONLY_RETRIEVAL,
        &pRetrieveCtl,
        &fNewerCtl,
        &fTimeValid
        );
    if (pPara->pCallContext->IsTouchedEngine()) {
        fTouchResult = FALSE;
        goto TouchedDuringUrlRetrieval;
    }

    if (!fTimeValid && pPara->pCallContext->IsOnline()) {
        SSCtlRetrieveCtlUrl(
            pPara->pChainEngine,
            pPara->pCallContext,
            pNextUpdateUrlArray,
            CRYPT_WIRE_ONLY_RETRIEVAL,
            &pRetrieveCtl,
            &fNewerCtl,
            &fTimeValid
            );
        if (pPara->pCallContext->IsTouchedEngine()) {
            fTouchResult = FALSE;
            goto TouchedDuringUrlRetrieval;
        }

        if (!fNewerCtl)
            pSSCtlObject->SetOffline(&CurrentTime, &UpdateTime);
    }

    if (fNewerCtl) {
        PSSCTL_UPDATE_CTL_OBJ_ENTRY pEntry;

        pSSCtlObject->SetOnline();

        pEntry = new SSCTL_UPDATE_CTL_OBJ_ENTRY;
        if (NULL == pEntry)
            goto OutOfMemory;

        if (!SSCtlCreateCtlObject(
                pPara->pChainEngine,
                pRetrieveCtl,
                FALSE,                      // fAdditionalStore
                &pEntry->pSSCtlObjectAdd
                )) {
            delete pEntry;
            goto CreateCtlObjectError;
        }

        pEntry->pSSCtlObjectRemove = pSSCtlObject;
        pEntry->pNext = pPara->pEntry;
        pPara->pEntry = pEntry;

    }

CommonReturn:
    if (!fNewerCtl) {
        if (I_CryptIsZeroFileTime(&pPara->UpdateTime) ||
                0 > CompareFileTime(&UpdateTime, &pPara->UpdateTime))
            pPara->UpdateTime = UpdateTime;
    }

    if (pRetrieveCtl)
        CertFreeCTLContext(pRetrieveCtl);

    return fTouchResult;

ErrorReturn:
    fNewerCtl = FALSE;
    goto CommonReturn;

SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
TRACE_ERROR(CreateCtlObjectError)
SET_ERROR(TouchedDuringUrlRetrieval, ERROR_CAN_NOT_COMPLETE)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\crypt32\crypt32.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       cryp32.cpp
//
//  Contents:   Crypto API, version 2.
//
//  Functions:  DllMain
//
//  History:    13-Aug-96    kevinr   created
//
//--------------------------------------------------------------------------

#include "windows.h"
#include "unicode.h"

// assignment within conditional expression
#pragma warning (disable: 4706)

#if DBG
extern BOOL WINAPI DebugDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
#endif
extern BOOL WINAPI I_CryptTlsDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI I_CryptOIDFuncDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI I_CryptOIDInfoDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI I_CertRevFuncDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI I_CertCTLUsageFuncDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI CertStoreDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI CertASNDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI CertHelperDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI CryptMsgDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI UnicodeDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI CryptFrmtFuncDllMain(HMODULE hModule, DWORD  fdwReason, LPVOID lpReserved);
extern BOOL WINAPI CryptSIPDllMain(HMODULE hModule, DWORD  fdwReason, LPVOID lpReserved);
extern BOOL WINAPI CryptPFXDllMain(HMODULE hModule, DWORD fdwReason, LPVOID lpReserved);
extern BOOL WINAPI CertChainPolicyDllMain(HMODULE hModule, DWORD fdwReason, LPVOID lpReserved);

extern BOOL WINAPI ChainDllMain (HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI CertPerfDllMain (HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);

typedef BOOL (WINAPI *PFN_DLL_MAIN_FUNC) (
                HMODULE hInstDLL,
                DWORD fdwReason,
                LPVOID lpvReserved
                );

// For process/thread attach, called in the following order. For process/thread
// detach, called in reverse order.
static const PFN_DLL_MAIN_FUNC rgpfnDllMain[] = {
#if DBG
    DebugDllMain,
#endif
    // For process/thread attach the following two functions must be called
    // first. For process/thread detach the following two functions must
    // be called last.
    I_CryptTlsDllMain,
    I_CryptOIDFuncDllMain,
    CertPerfDllMain,
    CryptSIPDllMain,
    I_CryptOIDInfoDllMain,
    CertHelperDllMain,
    UnicodeDllMain,
    I_CertRevFuncDllMain,
    I_CertCTLUsageFuncDllMain,
	CryptFrmtFuncDllMain,
    CertStoreDllMain,
    CryptPFXDllMain,
    CertASNDllMain,
    ChainDllMain,
    CertChainPolicyDllMain,
    CryptMsgDllMain
};
#define DLL_MAIN_FUNC_COUNT (sizeof(rgpfnDllMain) / sizeof(rgpfnDllMain[0]))

#if DBG
#include <crtdbg.h>

#ifndef _CRTDBG_LEAK_CHECK_DF
#define _CRTDBG_LEAK_CHECK_DF 0x20
#endif

#define DEBUG_MASK_LEAK_CHECK       _CRTDBG_LEAK_CHECK_DF     /* 0x20 */

static int WINAPI DbgGetDebugFlags()
{
    char    *pszEnvVar;
    char    *p;
    int     iDebugFlags = 0;

    if (pszEnvVar = getenv("DEBUG_MASK"))
        iDebugFlags = strtol(pszEnvVar, &p, 16);

    return iDebugFlags;
}
#endif

//
// I_CryptUIProtect loads cryptui.dll.  we need to free it on DLL_PROCESS_DETACH
// if it was loaded.
//

static HINSTANCE g_hCryptUI;


//+-------------------------------------------------------------------------
//  Return TRUE if DLL_PROCESS_DETACH is called for FreeLibrary instead
//  of ProcessExit. The third parameter, lpvReserved, passed to DllMain
//  is NULL for FreeLibrary and non-NULL for ProcessExit.
//
//  Also for debugging purposes, check the following environment variables:
//      CRYPT_DEBUG_FORCE_FREE_LIBRARY != 0     (retail and checked)
//      DEBUG_MASK & 0x20                       (only checked)
//
//  If either of the above environment variables is present and satisfies
//  the expression, TRUE is returned.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptIsProcessDetachFreeLibrary(
    LPVOID lpvReserved      // Third parameter passed to DllMain
    )
{
#define ENV_LEN 32
    char rgch[ENV_LEN + 1];
    DWORD cch;

    if (NULL == lpvReserved)
        return TRUE;

    cch = GetEnvironmentVariableA(
        "CRYPT_DEBUG_FORCE_FREE_LIBRARY",
        rgch,
        ENV_LEN
        );
    if (cch && cch <= ENV_LEN) {
        long lValue;

        rgch[cch] = '\0';
        lValue = atol(rgch);
        if (lValue)
            return TRUE;
    }

#if DBG
    if (DbgGetDebugFlags() & DEBUG_MASK_LEAK_CHECK)
        return TRUE;
#endif
    return FALSE;
}

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL WINAPI DllMain(
                HMODULE hInstDLL,
                DWORD fdwReason,
                LPVOID lpvReserved
                )
{
    BOOL    fReturn = TRUE;
    int     i;

#if DBG
    // NB- Due to an apparent bug in the Win95 loader, the CRT gets unloaded
    // too early in some circumstances. In particular, it can get unloaded
    // before this routine executes at process detach time. This can cause
    // faults when executing this routine, and also when executing the rest
    // of CRYPT32:CRT_INIT, after this initroutine returns. Ergo, we do an
    // extra load of the CRT, to be sure it stays around long enough.
    if ((fdwReason == DLL_PROCESS_ATTACH) && (!FIsWinNT()))
        LoadLibrary( "MSVCRTD.DLL");
#endif

    switch (fdwReason) {
        case DLL_PROCESS_DETACH:
            if( g_hCryptUI ) {
                FreeLibrary( g_hCryptUI );
                g_hCryptUI = NULL;
            }

            if (!I_CryptIsProcessDetachFreeLibrary(lpvReserved)) {
                // Process Exit. I have seen cases where other Dlls, like
                // wininet.dll, depend on crypt32.dll. However, crypt32.dll
                // gets called first at ProcessDetach. Since all the memory
                // and kernel handles will get freed anyway by the kernel,
                // we can skip the following detach freeing.

                // Always need to free shared memory used for certificate
                // performance counters
                CertPerfDllMain(hInstDLL, fdwReason, lpvReserved);
                return TRUE;
            }

            // Fall through for FreeLibrary
        case DLL_THREAD_DETACH:
            for (i = DLL_MAIN_FUNC_COUNT - 1; i >= 0; i--)
                fReturn &= rgpfnDllMain[i](hInstDLL, fdwReason, lpvReserved);
            break;

        case DLL_PROCESS_ATTACH:
            for (i = 0; i < DLL_MAIN_FUNC_COUNT; i++) {
                fReturn = rgpfnDllMain[i](hInstDLL, fdwReason, lpvReserved);
                if (!fReturn)
                    break;
            }

            if (!fReturn) {
                for (i--; i >= 0; i--)
                    rgpfnDllMain[i](hInstDLL, DLL_PROCESS_DETACH, NULL);
            }
            break;

        case DLL_THREAD_ATTACH:
        default:
            for (i = 0; i < DLL_MAIN_FUNC_COUNT; i++)
                fReturn &= rgpfnDllMain[i](hInstDLL, fdwReason, lpvReserved);
            break;
    }

    return(fReturn);
}

#if 1
typedef
DWORD
(WINAPI *PFN_I_CryptUIProtect)(
    IN      PVOID               pvReserved1,
    IN      PVOID               pvReserved2,
    IN      DWORD               dwReserved3,
    IN      PVOID               *pvReserved4,
    IN      BOOL                fReserved5,
    IN      PVOID               pvReserved6
    );
extern "C"
DWORD
WINAPI
I_CryptUIProtect(
    IN      PVOID               pvReserved1,
    IN      PVOID               pvReserved2,
    IN      DWORD               dwReserved3,
    IN      PVOID               *pvReserved4,
    IN      BOOL                fReserved5,
    IN      PVOID               pvReserved6
    )
{
    static PFN_I_CryptUIProtect pfn;
    DWORD rc;


    if ( g_hCryptUI == NULL ) {

        g_hCryptUI = LoadLibrary(TEXT("cryptui.dll"));

        if( g_hCryptUI == NULL )
            return GetLastError();
    }

    if ( pfn == NULL ) {
        pfn = (PFN_I_CryptUIProtect)GetProcAddress(g_hCryptUI, "I_CryptUIProtect");
    }

    if ( pfn != NULL ) {
        rc = (*pfn)(pvReserved1, pvReserved2, dwReserved3, pvReserved4, fReserved5, pvReserved6);
    } else {
        rc = GetLastError();

        if( rc == ERROR_SUCCESS )
            rc = ERROR_INVALID_PARAMETER;
    }

    return rc;
}

typedef
DWORD
(WINAPI *PFN_I_CryptUIProtectFailure)(
    IN      PVOID               pvReserved1,
    IN      DWORD               dwReserved2,
    IN      PVOID               *pvReserved3
    );
extern "C"
DWORD
WINAPI
I_CryptUIProtectFailure(
    IN      PVOID               pvReserved1,
    IN      DWORD               dwReserved2,
    IN      PVOID               *pvReserved3
    )
{
    static PFN_I_CryptUIProtectFailure pfn;
    DWORD rc;


    if ( g_hCryptUI == NULL ) {

        g_hCryptUI = LoadLibrary(TEXT("cryptui.dll"));

        if( g_hCryptUI == NULL )
            return GetLastError();
    }

    if ( pfn == NULL ) {
        pfn = (PFN_I_CryptUIProtectFailure)GetProcAddress(g_hCryptUI, "I_CryptUIProtectFailure");
    }

    if ( pfn != NULL ) {
        rc = (*pfn)(pvReserved1, dwReserved2, pvReserved3);
    } else {
        rc = GetLastError();

        if( rc == ERROR_SUCCESS )
            rc = ERROR_INVALID_PARAMETER;
    }

    return rc;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\cryptnet\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cryptnet.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\crypt32\makefile.inc ===
#
# Build private crypt32p.lib.  It contains all the private and public api's
#


$(O)\crypt32p.def: .\crypt32.src
    @echo Creating $@ from $**
    $(C_PREPROCESSOR_NAME) /DALL_WIN32_EXPORTS /DPRIVATE_VERSION $(C_PREPROCESSOR_FLAGS) $** > $@

$(O)\crypt32p.lib: $(O)\crypt32p.def $(LIBRARY_OBJS)
   -lib -out:$@ @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\crypt32p.def
$(LIBRARY_OBJS)
<<NOKEEP

$(PROJECT_LIB_PATH)\crypt32p.lib : $(O)\crypt32p.lib
    $(PUBLISH_CMD) {$?=$@}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\cryptnet\makefile.inc ===
#
# Build private cryptnet.lib.  It contains all the private and public api's
#

cryptnet_all: $O\cryptntp.lib

$O\cryptntp.def: .\cryptnet.src
    @echo Creating $@ from $**
    $(C_PREPROCESSOR_NAME) /DALL_WIN32_EXPORTS /DPRIVATE_VERSION $(C_PREPROCESSOR_FLAGS) $** > $@

$O\cryptntp.lib: $O\cryptntp.def $(LIBRARY_OBJS)
   -lib -out:$@ @<<
$(LIBRARIAN_FLAGS)
-def:$O\cryptntp.def
$(LIBRARY_OBJS)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\cryptnet\cryptnet.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cryptnet.cpp
//
//  Contents:   DllMain for CRYPTNET.DLL
//
//  History:    24-Jul-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include "windows.h"
#include "crtem.h"
#include "unicode.h"

//
// DllMain stuff
//

#if DBG
extern BOOL WINAPI DebugDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
#endif

extern BOOL WINAPI RPORDllMain (HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI DpsDllMain (HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI DemandLoadDllMain (HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI NSRevokeDllMain (HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);

typedef BOOL (WINAPI *PFN_DLL_MAIN_FUNC) (
                HMODULE hInstDLL,
                DWORD fdwReason,
                LPVOID lpvReserved
                );

HMODULE g_hModule;

// For process/thread attach, called in the following order. For process/thread
// detach, called in reverse order.
static const PFN_DLL_MAIN_FUNC rgpfnDllMain[] = {
#if DBG
    DebugDllMain,
#endif
    DemandLoadDllMain,
    RPORDllMain,
    NSRevokeDllMain
};
#define DLL_MAIN_FUNC_COUNT (sizeof(rgpfnDllMain) / sizeof(rgpfnDllMain[0]))

//
// DllRegisterServer and DllUnregisterServer stuff
//

extern HRESULT WINAPI DpsDllRegUnregServer (HMODULE hInstDLL, BOOL fRegUnreg);
extern HRESULT WINAPI RPORDllRegUnregServer (HMODULE hInstDLL, BOOL fRegUnreg);

typedef HRESULT (WINAPI *PFN_DLL_REGUNREGSERVER_FUNC) (
                              HMODULE hInstDLL,
                              BOOL fRegUnreg
                              );

static const PFN_DLL_REGUNREGSERVER_FUNC rgpfnDllRegUnregServer[] = {
    RPORDllRegUnregServer
};

#define DLL_REGUNREGSERVER_FUNC_COUNT (sizeof(rgpfnDllRegUnregServer) / \
                                       sizeof(rgpfnDllRegUnregServer[0]))

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL WINAPI DllMain(
                HMODULE hInstDLL,
                DWORD fdwReason,
                LPVOID lpvReserved
                )
{
    BOOL    fReturn = TRUE;
    int     i;

#if DBG
    // NB- Due to an apparent bug in the Win95 loader, the CRT gets unloaded
    // too early in some circumstances. In particular, it can get unloaded
    // before this routine executes at process detach time. This can cause
    // faults when executing this routine, and also when executing the rest
    // of CRYPT32:CRT_INIT, after this initroutine returns. Ergo, we do an
    // extra load of the CRT, to be sure it stays around long enough.
    if ((fdwReason == DLL_PROCESS_ATTACH) && (!FIsWinNT()))
        LoadLibrary( "MSVCRTD.DLL");
#endif

    switch (fdwReason) {
        case DLL_PROCESS_DETACH:
        case DLL_THREAD_DETACH:
            for (i = DLL_MAIN_FUNC_COUNT - 1; i >= 0; i--)
                fReturn &= rgpfnDllMain[i](hInstDLL, fdwReason, lpvReserved);
            break;

        case DLL_PROCESS_ATTACH:
            g_hModule = hInstDLL;
        case DLL_THREAD_ATTACH:
        default:
            for (i = 0; i < DLL_MAIN_FUNC_COUNT; i++)
                fReturn &= rgpfnDllMain[i](hInstDLL, fdwReason, lpvReserved);
            break;
    }

    return(fReturn);
}

STDAPI DllRegisterServer ()
{
    HRESULT hr = 0;
    ULONG   cCount;

    for ( cCount = 0; cCount < DLL_REGUNREGSERVER_FUNC_COUNT; cCount++ )
    {
        hr = rgpfnDllRegUnregServer[cCount]( g_hModule, TRUE );
        if ( hr != S_OK )
        {
            break;
        }
    }

    return( hr );
}

STDAPI DllUnregisterServer ()
{
    HRESULT hr = 0;
    ULONG   cCount;

    for ( cCount = 0; cCount < DLL_REGUNREGSERVER_FUNC_COUNT; cCount++ )
    {
        hr = rgpfnDllRegUnregServer[cCount]( g_hModule, FALSE );
        if ( hr != S_OK )
        {
            break;
        }
    }

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\chain\ssctl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ssctl.h
//
//  Contents:   Self Signed Certificate Trust List Subsystem used by the
//              Certificate Chaining Infrastructure for building complex
//              chains
//
//  History:    02-Feb-98    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__SSCTL_H__)
#define __SSCTL_H__

#include <chain.h>

//
// CSSCtlObject.  This is the main object for caching trust information about
// a self signed certificate trust list
//

typedef struct _SSCTL_SIGNER_INFO {
    PCERT_INFO             pMessageSignerCertInfo;
    BOOL                   fSignerHashAvailable;
    BYTE                   rgbSignerCertHash[ CHAINHASHLEN ];
} SSCTL_SIGNER_INFO, *PSSCTL_SIGNER_INFO;

class CSSCtlObject
{
public:

    //
    // Construction
    //

    CSSCtlObject (
          IN PCCERTCHAINENGINE pChainEngine,
          IN PCCTL_CONTEXT pCtlContext,
          IN BOOL fAdditionalStore,
          OUT BOOL& rfResult
          );

    ~CSSCtlObject ();

    //
    // Reference counting
    //

    inline VOID AddRef ();
    inline VOID Release ();

    //
    // Trust information access
    //

    inline PCCTL_CONTEXT CtlContext ();

    BOOL GetSigner (
            IN PCCHAINPATHOBJECT pSubject,
            IN PCCHAINCALLCONTEXT pCallContext,
            IN HCERTSTORE hAdditionalStore,
            OUT PCCHAINPATHOBJECT* ppSigner,
            OUT BOOL* pfCtlSignatureValid
            );

    BOOL GetTrustListInfo (
            IN PCCERT_CONTEXT pCertContext,
            OUT PCERT_TRUST_LIST_INFO* ppTrustListInfo
            );

    VOID CalculateStatus (
                  IN LPFILETIME pTime,
                  IN PCERT_USAGE_MATCH pRequestedUsage,
                  IN OUT PCERT_TRUST_STATUS pStatus
                  );

    //
    // Hash access
    //

    inline LPBYTE CtlHash ();

    //
    // Index entry handles
    //

    inline HLRUENTRY HashIndexEntry ();

    //
    // Returns pointer to the Ctl's NextUpdate location url array
    //

    inline PCRYPT_URL_ARRAY NextUpdateUrlArray ();

    //
    // Returns TRUE if the Ctl has a NextUpdate time and location Url
    //

    BOOL HasNextUpdateUrl (
                    OUT LPFILETIME pUpdateTime
                    );

    //
    // Called for successful online Url retrieval
    //

    inline void SetOnline ();


    //
    // Called for unsuccessful online Url retrieval
    //

    void SetOffline (
                    IN LPFILETIME pCurrentTime,
                    OUT LPFILETIME pUpdateTime
                    );


    //
    // Chain engine access
    //

    inline PCCERTCHAINENGINE ChainEngine ();

    //
    // Message store access
    //

    inline HCERTSTORE MessageStore ();


private:

    //
    // Reference count
    //

    LONG                   m_cRefs;

    //
    // Self Signed Certificate Trust List Context
    //

    PCCTL_CONTEXT          m_pCtlContext;

    //
    // MD5 Hash of CTL
    //

    BYTE                   m_rgbCtlHash[ CHAINHASHLEN ];

    //
    // Signer information
    //

    SSCTL_SIGNER_INFO      m_SignerInfo;
    BOOL                   m_fHasSignatureBeenVerified;
    BOOL                   m_fSignatureValid;

    //
    // Message Store
    //

    HCERTSTORE             m_hMessageStore;

    //
    // Hash Index Entry
    //

    HLRUENTRY              m_hHashEntry;

    //
    // Chain engine
    //

    PCCERTCHAINENGINE      m_pChainEngine;

    //
    // The following is only set if the CTL has a NextUpdate time and location
    //

    PCRYPT_URL_ARRAY       m_pNextUpdateUrlArray;

    //
    // The following is incremented for each SetOffline() call
    //
    DWORD                  m_dwOfflineCnt;

    //
    // The next update time when offline
    //
    FILETIME               m_OfflineUpdateTime;

};

//
// CSSCtlObjectCache.  Cache of self signed certificate trust list objects
// indexed by hash. Note that this cache is NOT LRU maintained.  We expect
// the number of these objects to be small
//

typedef BOOL (WINAPI *PFN_ENUM_SSCTLOBJECTS) (
                          IN LPVOID pvParameter,
                          IN PCSSCTLOBJECT pSSCtlObject
                          );

class CSSCtlObjectCache
{
public:

    //
    // Construction
    //

    CSSCtlObjectCache (
          OUT BOOL& rfResult
          );

    ~CSSCtlObjectCache ();

    //
    // Object Management
    //

    BOOL PopulateCache (
                 IN PCCERTCHAINENGINE pChainEngine
                 );

    BOOL AddObject (
            IN PCSSCTLOBJECT pSSCtlObject,
            IN BOOL fCheckForDuplicate
            );

    VOID RemoveObject (
               IN PCSSCTLOBJECT pSSCtlObject
               );

    //
    // Access the indexes
    //

    inline HLRUCACHE HashIndex ();

    //
    // Searching and Enumeration
    //

    PCSSCTLOBJECT FindObjectByHash (
                      IN BYTE rgbHash [ CHAINHASHLEN ]
                      );

    VOID EnumObjects (
             IN PFN_ENUM_SSCTLOBJECTS pfnEnum,
             IN LPVOID pvParameter
             );

    //
    // Resync
    //

    BOOL Resync (IN PCCERTCHAINENGINE pChainEngine);

    //
    // Update the cache by retrieving any expired CTLs having a
    // NextUpdate time and location.
    //

    BOOL UpdateCache (
        IN PCCERTCHAINENGINE pChainEngine,
        IN PCCHAINCALLCONTEXT pCallContext
        );

private:

    //
    // Hash Index
    //

    HLRUCACHE m_hHashIndex;

    //
    // The following is nonzero, if any CTL has a NextUpdate time and location
    //

    FILETIME m_UpdateTime;

    //
    // The following is TRUE, for the first update of any CTL with a
    // NextUpdate time and location
    //
    BOOL m_fFirstUpdate;
};

//
// Object removal notification function
//

VOID WINAPI
SSCtlOnRemovalFromCache (
     IN LPVOID pv,
     IN OPTIONAL LPVOID pvRemovalContext
     );

//
// SSCtl Subsystem Utility Function Prototypes
//

BOOL WINAPI
SSCtlGetSignerInfo (
     IN PCCTL_CONTEXT pCtlContext,
     OUT PSSCTL_SIGNER_INFO pSignerInfo
     );

VOID WINAPI
SSCtlFreeSignerInfo (
     IN PSSCTL_SIGNER_INFO pSignerInfo
     );

BOOL WINAPI
SSCtlGetSignerChainPathObject (
     IN PCCHAINPATHOBJECT pSubject,
     IN PCCHAINCALLCONTEXT pCallContext,
     IN PSSCTL_SIGNER_INFO pSignerInfo,
     IN HCERTSTORE hAdditionalStore,
     OUT PCCHAINPATHOBJECT* ppSigner,
     OUT BOOL *pfNewSigner
     );

PCCERT_CONTEXT WINAPI
SSCtlFindCertificateInStoreByHash (
     IN HCERTSTORE hStore,
     IN BYTE rgbHash [ CHAINHASHLEN]
     );

VOID WINAPI
SSCtlGetCtlTrustStatus (
     IN PCCTL_CONTEXT pCtlContext,
     IN BOOL fSignatureValid,
     IN LPFILETIME pTime,
     IN PCERT_USAGE_MATCH pRequestedUsage,
     IN OUT PCERT_TRUST_STATUS pStatus
     );

BOOL WINAPI
SSCtlPopulateCacheFromCertStore (
     IN PCCERTCHAINENGINE pChainEngine,
     IN OPTIONAL HCERTSTORE hStore
     );

BOOL WINAPI
SSCtlCreateCtlObject (
     IN PCCERTCHAINENGINE pChainEngine,
     IN PCCTL_CONTEXT pCtlContext,
     IN BOOL fAdditionalStore,
     OUT PCSSCTLOBJECT* ppSSCtlObject
     );

typedef struct _SSCTL_ENUM_OBJECTS_DATA {
    PFN_ENUM_SSCTLOBJECTS pfnEnumObjects;
    LPVOID                pvEnumParameter;
} SSCTL_ENUM_OBJECTS_DATA, *PSSCTL_ENUM_OBJECTS_DATA;

BOOL WINAPI
SSCtlEnumObjectsWalkFn (
     IN LPVOID pvParameter,
     IN HLRUENTRY hEntry
     );

BOOL WINAPI
SSCtlCreateObjectCache (
     OUT PCSSCTLOBJECTCACHE* ppSSCtlObjectCache
     );

VOID WINAPI
SSCtlFreeObjectCache (
     IN PCSSCTLOBJECTCACHE pSSCtlObjectCache
     );

VOID WINAPI
SSCtlFreeTrustListInfo (
     IN PCERT_TRUST_LIST_INFO pTrustListInfo
     );

BOOL WINAPI
SSCtlAllocAndCopyTrustListInfo (
     IN PCERT_TRUST_LIST_INFO pTrustListInfo,
     OUT PCERT_TRUST_LIST_INFO* ppTrustListInfo
     );

//
//  Retrieve a newer and time valid CTL at one of the NextUpdate Urls
//

BOOL
WINAPI
SSCtlRetrieveCtlUrl(
    IN PCCERTCHAINENGINE pChainEngine,
    IN PCCHAINCALLCONTEXT pCallContext,
    IN OUT PCRYPT_URL_ARRAY pNextUpdateUrlArray,
    IN DWORD dwRetrievalFlags,
    IN OUT PCCTL_CONTEXT *ppCtl,
    IN OUT BOOL *pfNewerCtl,
    IN OUT BOOL *pfTimeValid
    );

//
//  Update Ctl Object Enum Function
//

typedef struct _SSCTL_UPDATE_CTL_OBJ_ENTRY SSCTL_UPDATE_CTL_OBJ_ENTRY,
                                            *PSSCTL_UPDATE_CTL_OBJ_ENTRY;

struct _SSCTL_UPDATE_CTL_OBJ_ENTRY {
    PCSSCTLOBJECT               pSSCtlObjectAdd;
    PCSSCTLOBJECT               pSSCtlObjectRemove;
    PSSCTL_UPDATE_CTL_OBJ_ENTRY pNext;
};

typedef struct _SSCTL_UPDATE_CTL_OBJ_PARA {
    PCCERTCHAINENGINE           pChainEngine;
    PCCHAINCALLCONTEXT          pCallContext;

    FILETIME                    UpdateTime;
    PSSCTL_UPDATE_CTL_OBJ_ENTRY pEntry;
} SSCTL_UPDATE_CTL_OBJ_PARA, *PSSCTL_UPDATE_CTL_OBJ_PARA;

BOOL
WINAPI
SSCtlUpdateCtlObjectEnumFn(
    IN LPVOID pvPara,
    IN PCSSCTLOBJECT pSSCtlObject
    );

//
// Inline methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::AddRef, public
//
//  Synopsis:   add a reference
//
//----------------------------------------------------------------------------
inline VOID
CSSCtlObject::AddRef ()
{
    InterlockedIncrement( &m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::Release, public
//
//  Synopsis:   release a reference
//
//----------------------------------------------------------------------------
inline VOID
CSSCtlObject::Release ()
{
    if ( InterlockedDecrement( &m_cRefs ) == 0 )
    {
        delete this;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::CtlContext, public
//
//  Synopsis:   return the CTL context
//
//----------------------------------------------------------------------------
inline PCCTL_CONTEXT
CSSCtlObject::CtlContext ()
{
    return( m_pCtlContext );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::CtlHash, public
//
//  Synopsis:   return the hash
//
//----------------------------------------------------------------------------
inline LPBYTE
CSSCtlObject::CtlHash ()
{
    return( m_rgbCtlHash );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::HashIndexEntry, public
//
//  Synopsis:   return the hash index entry
//
//----------------------------------------------------------------------------
inline HLRUENTRY
CSSCtlObject::HashIndexEntry ()
{
    return( m_hHashEntry );
}


//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::NextUpdateUrlArray, public
//
//  Synopsis:   return pointer to the Ctl's NextUpdate location url array
//
//----------------------------------------------------------------------------
inline PCRYPT_URL_ARRAY CSSCtlObject::NextUpdateUrlArray ()
{
    return m_pNextUpdateUrlArray;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::SetOnlineUpdate, public
//
//  Synopsis:   called for successful online Url retrieval
//
//----------------------------------------------------------------------------
inline void CSSCtlObject::SetOnline ()
{
    m_dwOfflineCnt = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::ChainEngine, public
//
//  Synopsis:   return the chain engine object
//
//----------------------------------------------------------------------------
inline PCCERTCHAINENGINE
CSSCtlObject::ChainEngine ()
{
    return( m_pChainEngine );
}


//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::MessageStore, public
//
//  Synopsis:   return the object's message store
//
//----------------------------------------------------------------------------
inline HCERTSTORE
CSSCtlObject::MessageStore ()
{
    return( m_hMessageStore );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::HashIndex, public
//
//  Synopsis:   return the hash index
//
//----------------------------------------------------------------------------
inline HLRUCACHE
CSSCtlObjectCache::HashIndex ()
{
    return( m_hHashIndex );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\chain\xcert.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       xcert.cpp
//
//  Contents:   CCertChainEngine's Cross Certificate Methods
//
//  History:    22-Dec-99    philh    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <dbgdef.h>




//+=========================================================================
// Cross Certificate Distribution Point Support Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Get and allocate the cross certificate distribution points Url array
//  and info for the specified certificate.
//--------------------------------------------------------------------------
BOOL
WINAPI
XCertGetDistPointsUrl(
    IN PCCERT_CONTEXT pCert,
    OUT PCRYPT_URL_ARRAY *ppUrlArray,
    OUT PCRYPT_URL_INFO *ppUrlInfo
    )
{
    BOOL fResult;
    PCRYPT_URL_ARRAY pUrlArray = NULL;
    DWORD cbUrlArray = 0;
    PCRYPT_URL_INFO pUrlInfo = NULL;
    DWORD cbUrlInfo = 0;

    if (!ChainGetObjectUrl(
            URL_OID_CROSS_CERT_DIST_POINT,
            (LPVOID) pCert,
            CRYPT_GET_URL_FROM_PROPERTY | CRYPT_GET_URL_FROM_EXTENSION,
            NULL,           // pUrlArray
            &cbUrlArray,
            NULL,           // pUrlInfo
            &cbUrlInfo,
            NULL            // pvReserved
            ))
        goto GetObjectUrlError;

    pUrlArray = (PCRYPT_URL_ARRAY) new BYTE [cbUrlArray];
    if (NULL == pUrlArray)
        goto OutOfMemory;

    pUrlInfo = (PCRYPT_URL_INFO) new BYTE [cbUrlInfo];
    if (NULL == pUrlInfo)
        goto OutOfMemory;

    if (!ChainGetObjectUrl(
            URL_OID_CROSS_CERT_DIST_POINT,
            (LPVOID) pCert,
            CRYPT_GET_URL_FROM_PROPERTY | CRYPT_GET_URL_FROM_EXTENSION,
            pUrlArray,
            &cbUrlArray,
            pUrlInfo,
            &cbUrlInfo,
            NULL            // pvReserved
            ))
        goto GetObjectUrlError;

    if (0 == pUrlArray->cUrl || 0 == pUrlInfo->cGroup)
        goto NoDistPointUrls;

    fResult = TRUE;
CommonReturn:
    *ppUrlArray = pUrlArray;
    *ppUrlInfo = pUrlInfo;
    return fResult;

ErrorReturn:
    if (pUrlArray) {
        delete (LPBYTE) pUrlArray;
        pUrlArray = NULL;
    }
    if (pUrlInfo) {
        delete (LPBYTE) pUrlInfo;
        pUrlInfo = NULL;
    }
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetObjectUrlError)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
SET_ERROR(NoDistPointUrls, CRYPT_E_NOT_FOUND)
}



//+-------------------------------------------------------------------------
//  Checks and returns TRUE if all the Urls are contained in the
//  distribution point.
//--------------------------------------------------------------------------
BOOL
WINAPI
XCertIsUrlInDistPoint(
    IN DWORD cUrl,
    IN LPWSTR *ppwszUrl,
    IN PXCERT_DP_ENTRY pEntry
    )
{
    for ( ; 0 < cUrl; cUrl--, ppwszUrl++) {
        DWORD cDPUrl = pEntry->cUrl;
        LPWSTR *ppwszDPUrl = pEntry->rgpwszUrl;

        for ( ; 0 < cDPUrl; cDPUrl--, ppwszDPUrl++) {
            if (0 == wcscmp(*ppwszUrl, *ppwszDPUrl))
                break;
        }

        if (0 == cDPUrl)
            return FALSE;
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//  Finds a distribution point link containing all the Urls.
//--------------------------------------------------------------------------
PXCERT_DP_LINK
WINAPI
XCertFindUrlInDistPointLinks(
    IN DWORD cUrl,
    IN LPWSTR *rgpwszUrl,
    IN PXCERT_DP_LINK pLink
    )
{
    for ( ; pLink; pLink = pLink->pNext) {
        if (XCertIsUrlInDistPoint(cUrl, rgpwszUrl, pLink->pCrossCertDPEntry))
            return pLink;
    }

    return NULL;
}


//+-------------------------------------------------------------------------
//  Finds a distribution point entry containing all the Urls.
//--------------------------------------------------------------------------
PXCERT_DP_ENTRY
WINAPI
XCertFindUrlInDistPointEntries(
    IN DWORD cUrl,
    IN LPWSTR *rgpwszUrl,
    PXCERT_DP_ENTRY pEntry
    )
{
    for ( ; pEntry; pEntry = pEntry->pNext) {
        if (XCertIsUrlInDistPoint(cUrl, rgpwszUrl, pEntry))
            return pEntry;
    }

    return NULL;
}


//+-------------------------------------------------------------------------
//  Inserts the cross certificate distribution entry into the engine's
//  list. The list is ordered according to ascending NextSyncTimes.
//--------------------------------------------------------------------------
void
CCertChainEngine::InsertCrossCertDistPointEntry(
    IN OUT PXCERT_DP_ENTRY pEntry
    )
{
    if (NULL == m_pCrossCertDPEntry) {
        // First entry to be added to engine's list
        pEntry->pNext = NULL;
        pEntry->pPrev = NULL;
        m_pCrossCertDPEntry = pEntry;
    } else {
        PXCERT_DP_ENTRY pListEntry = m_pCrossCertDPEntry;
        BOOL fLast = FALSE;

        // Loop while Entry's NextSyncTime > list's NextSyncTime
        while (0 < CompareFileTime(&pEntry->NextSyncTime,
                &pListEntry->NextSyncTime)) {
            if (NULL == pListEntry->pNext) {
                fLast = TRUE;
                break;
            } else
                pListEntry = pListEntry->pNext;
        }

        if (fLast) {
            assert(NULL == pListEntry->pNext);
            pEntry->pNext = NULL;
            pEntry->pPrev = pListEntry;
            pListEntry->pNext = pEntry;
        } else {
            pEntry->pNext = pListEntry;
            pEntry->pPrev = pListEntry->pPrev;
            if (pListEntry->pPrev) {
                assert(pListEntry->pPrev->pNext == pListEntry);
                pListEntry->pPrev->pNext = pEntry;
            } else {
                assert(m_pCrossCertDPEntry == pListEntry);
                m_pCrossCertDPEntry = pEntry;
            }
            pListEntry->pPrev = pEntry;
        }
    }
}

//+-------------------------------------------------------------------------
//  Removes the cross certificate distribution point from the engine's list.
//--------------------------------------------------------------------------
void
CCertChainEngine::RemoveCrossCertDistPointEntry(
    IN OUT PXCERT_DP_ENTRY pEntry
    )
{
    if (pEntry->pNext)
        pEntry->pNext->pPrev = pEntry->pPrev;
    if (pEntry->pPrev)
        pEntry->pPrev->pNext = pEntry->pNext;
    else
        m_pCrossCertDPEntry = pEntry->pNext;
}

//+-------------------------------------------------------------------------
//  For an online certificate distribution point updates the NextSyncTime
//  and repositions accordingly in the engine's list.
//
//  NextSyncTime = LastSyncTime + dwSyncDeltaTime.
//--------------------------------------------------------------------------
void
CCertChainEngine::RepositionOnlineCrossCertDistPointEntry(
    IN OUT PXCERT_DP_ENTRY pEntry,
    IN LPFILETIME pLastSyncTime
    )
{
    assert(!I_CryptIsZeroFileTime(pLastSyncTime));
    pEntry->LastSyncTime = *pLastSyncTime;
    pEntry->dwOfflineCnt = 0;

    I_CryptIncrementFileTimeBySeconds(
        pLastSyncTime,
        pEntry->dwSyncDeltaTime,
        &pEntry->NextSyncTime
        );

    RemoveCrossCertDistPointEntry(pEntry);
    InsertCrossCertDistPointEntry(pEntry);
}

//+-------------------------------------------------------------------------
//  For an offline certificate distribution point, increments the offline
//  count, updates the NextSyncTime to be some delta from the current time
//  and repositions accordingly in the engine's list.
//
//  NextSyncTime = CurrentTime +
//                      rgChainOfflineUrlDeltaSeconds[dwOfflineCnt - 1]
//--------------------------------------------------------------------------
void
CCertChainEngine::RepositionOfflineCrossCertDistPointEntry(
    IN OUT PXCERT_DP_ENTRY pEntry,
    IN LPFILETIME pCurrentTime
    )
{
    pEntry->dwOfflineCnt++;

    I_CryptIncrementFileTimeBySeconds(
        pCurrentTime,
        ChainGetOfflineUrlDeltaSeconds(pEntry->dwOfflineCnt),
        &pEntry->NextSyncTime
        );

    RemoveCrossCertDistPointEntry(pEntry);
    InsertCrossCertDistPointEntry(pEntry);
}

//+-------------------------------------------------------------------------
//  For a smaller SyncDeltaTime in a certificate distribution point,
//  updates the NextSyncTime and repositions accordingly in the engine's list.
//
//  Note, if the distribution point is offline, the NextSyncTime isn't
//  updated.
//
//  NextSyncTime = LastSyncTime + dwSyncDeltaTime.
//--------------------------------------------------------------------------
void
CCertChainEngine::RepositionNewSyncDeltaTimeCrossCertDistPointEntry(
    IN OUT PXCERT_DP_ENTRY pEntry,
    IN DWORD dwSyncDeltaTime
    )
{
    if (dwSyncDeltaTime >= pEntry->dwSyncDeltaTime)
        return;

    pEntry->dwSyncDeltaTime = dwSyncDeltaTime;

    if (I_CryptIsZeroFileTime(&pEntry->LastSyncTime) ||
            0 != pEntry->dwOfflineCnt)
        return;

    RepositionOnlineCrossCertDistPointEntry(pEntry, &pEntry->LastSyncTime);
}

//+-------------------------------------------------------------------------
//  Creates the cross certificate distribution point and insert's in the
//  engine's list.
//
//  The returned entry has a refCnt of 1.
//--------------------------------------------------------------------------
PXCERT_DP_ENTRY
CCertChainEngine::CreateCrossCertDistPointEntry(
    IN DWORD dwSyncDeltaTime,
    IN DWORD cUrl,
    IN LPWSTR *rgpwszUrl
    )
{
    PXCERT_DP_ENTRY pEntry;
    DWORD cbEntry;
    LPWSTR *ppwszEntryUrl;
    LPWSTR pwszEntryUrl;
    DWORD i;

    cbEntry = sizeof(XCERT_DP_ENTRY) + cUrl * sizeof(LPWSTR);
    for (i = 0; i < cUrl; i++)
        cbEntry += (wcslen(rgpwszUrl[i]) + 1) * sizeof(WCHAR);

    pEntry = (PXCERT_DP_ENTRY) new BYTE [cbEntry];
    if (NULL == pEntry) {
        SetLastError((DWORD) E_OUTOFMEMORY);
        return NULL;
    }

    memset(pEntry, 0, sizeof(XCERT_DP_ENTRY));
    pEntry->lRefCnt = 1;
    pEntry->dwSyncDeltaTime = dwSyncDeltaTime;

    pEntry->cUrl = cUrl;
    pEntry->rgpwszUrl = ppwszEntryUrl = (LPWSTR *) &pEntry[1];
    pwszEntryUrl = (LPWSTR) &ppwszEntryUrl[cUrl];

    for (i = 0; i < cUrl; i++) {
        ppwszEntryUrl[i] = pwszEntryUrl;
        wcscpy(pwszEntryUrl, rgpwszUrl[i]);
        pwszEntryUrl += wcslen(rgpwszUrl[i]) + 1;
    }

    InsertCrossCertDistPointEntry(pEntry);

    return pEntry;
}

//+-------------------------------------------------------------------------
//  Increments the cross certificate distribution point's reference count.
//--------------------------------------------------------------------------
void
CCertChainEngine::AddRefCrossCertDistPointEntry(
    IN OUT PXCERT_DP_ENTRY pEntry
    )
{
    pEntry->lRefCnt++;
}

//+-------------------------------------------------------------------------
//  Decrements the cross certificate distribution point's reference count.
//
//  When decremented to 0, removed from the engine's list and freed.
//
//  Returns TRUE if decremented to 0 and freed.
//--------------------------------------------------------------------------
BOOL
CCertChainEngine::ReleaseCrossCertDistPointEntry(
    IN OUT PXCERT_DP_ENTRY pEntry
    )
{
    if (0 != --pEntry->lRefCnt)
        return FALSE;

    RemoveCrossCertDistPointEntry(pEntry);
    FreeCrossCertDistPoints(&pEntry->pChildCrossCertDPLink);

    if (pEntry->hUrlStore) {
        CertRemoveStoreFromCollection(
            m_hCrossCertStore,
            pEntry->hUrlStore
            );
        CertCloseStore(pEntry->hUrlStore, 0);
    }

    delete (LPBYTE) pEntry;

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Finds and gets the Cross Certificate Distribution Points for the
//  specified certificate store.
//
//  *ppLinkHead is updated to contain the store's distribution point links.
//--------------------------------------------------------------------------
BOOL
CCertChainEngine::GetCrossCertDistPointsForStore(
    IN HCERTSTORE hStore,
    IN OUT PXCERT_DP_LINK *ppLinkHead
    )
{
    BOOL fResult;
    PXCERT_DP_LINK pOldLinkHead = *ppLinkHead;
    PXCERT_DP_LINK pNewLinkHead = NULL;
    PCCERT_CONTEXT pCert = NULL;
    PCRYPT_URL_ARRAY pUrlArray = NULL;
    PCRYPT_URL_INFO pUrlInfo = NULL;

    while (pCert = CertFindCertificateInStore(
            hStore,
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            0,                                          // dwFindFlags
            CERT_FIND_CROSS_CERT_DIST_POINTS,
            NULL,                                       // pvFindPara,
            pCert
            )) {

        DWORD dwSyncDeltaTime;
        DWORD cDP;
        DWORD *pcUrl;
        LPWSTR *ppwszUrl;

        if (!XCertGetDistPointsUrl(
                pCert,
                &pUrlArray,
                &pUrlInfo
                ))
            continue;

        dwSyncDeltaTime = pUrlInfo->dwSyncDeltaTime;
        if (0 == dwSyncDeltaTime)
            dwSyncDeltaTime = XCERT_DEFAULT_SYNC_DELTA_TIME;
        else if (XCERT_MIN_SYNC_DELTA_TIME > dwSyncDeltaTime)
            dwSyncDeltaTime = XCERT_MIN_SYNC_DELTA_TIME;

        cDP = pUrlInfo->cGroup;
        pcUrl = pUrlInfo->rgcGroupEntry;
        ppwszUrl = pUrlArray->rgwszUrl;

        for ( ; 0 < cDP; cDP--, ppwszUrl += *pcUrl++) {
            PXCERT_DP_LINK pLink;
            PXCERT_DP_ENTRY pEntry;
            DWORD cUrl = *pcUrl;

            if (0 == cUrl)
                continue;

            // Do we already have an entry in the new list
            if (XCertFindUrlInDistPointLinks(cUrl, ppwszUrl, pNewLinkHead))
                continue;

            // If the entry existed in the old list, move to the new list
            if (pLink = XCertFindUrlInDistPointLinks(
                    cUrl, ppwszUrl, pOldLinkHead)) {
                if (pLink->pNext)
                    pLink->pNext->pPrev = pLink->pPrev;
                if (pLink->pPrev)
                    pLink->pPrev->pNext = pLink->pNext;
                else
                    pOldLinkHead = pLink->pNext;

                RepositionNewSyncDeltaTimeCrossCertDistPointEntry(
                    pLink->pCrossCertDPEntry, dwSyncDeltaTime);
            } else {
                // Check if the entry already exists for the engine
                if (pEntry = XCertFindUrlInDistPointEntries(
                        cUrl, ppwszUrl, m_pCrossCertDPEntry)) {
                    AddRefCrossCertDistPointEntry(pEntry);
                    RepositionNewSyncDeltaTimeCrossCertDistPointEntry(
                        pEntry, dwSyncDeltaTime);
                } else {
                    // Create entry and insert at beginning of
                    // entries list.
                    if (NULL == (pEntry = CreateCrossCertDistPointEntry(
                            dwSyncDeltaTime,
                            cUrl,
                            ppwszUrl
                            )))
                        goto CreateDistPointEntryError;
                }

                pLink = new XCERT_DP_LINK;
                if (NULL == pLink) {
                    ReleaseCrossCertDistPointEntry(pEntry);
                    goto CreateDistPointLinkError;
                }

                pLink->pCrossCertDPEntry = pEntry;

            }

            if (pNewLinkHead) {
                assert(NULL == pNewLinkHead->pPrev);
                pNewLinkHead->pPrev = pLink;
            }
            pLink->pNext = pNewLinkHead;
            pLink->pPrev = NULL;
            pNewLinkHead = pLink;
        }

        delete (LPBYTE) pUrlArray;
        pUrlArray = NULL;
        delete (LPBYTE) pUrlInfo;
        pUrlInfo = NULL;
    }

    assert(NULL == pUrlArray);
    assert(NULL == pUrlInfo);
    assert(NULL == pCert);

    *ppLinkHead = pNewLinkHead;
    fResult = TRUE;
CommonReturn:
    if (pOldLinkHead) {
        DWORD dwErr = GetLastError();

        FreeCrossCertDistPoints(&pOldLinkHead);

        SetLastError(dwErr);
    }

    return fResult;

ErrorReturn:
    *ppLinkHead = NULL;
    if (pUrlArray)
        delete (LPBYTE) pUrlArray;
    if (pUrlInfo)
        delete (LPBYTE) pUrlInfo;
    if (pCert)
        CertFreeCertificateContext(pCert);

    if (pNewLinkHead) {
        FreeCrossCertDistPoints(&pNewLinkHead);
        assert(NULL == pNewLinkHead);
    }
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CreateDistPointEntryError)
TRACE_ERROR(CreateDistPointLinkError)
}


//+-------------------------------------------------------------------------
//  Removes an orphan'ed entry not in any list of links.
//--------------------------------------------------------------------------
void
CCertChainEngine::RemoveCrossCertDistPointOrphanEntry(
    IN PXCERT_DP_ENTRY pOrphanEntry
    )
{
    PXCERT_DP_ENTRY pEntry;

    for (pEntry = m_pCrossCertDPEntry; pEntry; pEntry = pEntry->pNext) {
        PXCERT_DP_LINK pLink = pEntry->pChildCrossCertDPLink;

        while (pLink) {
            if (pLink->pCrossCertDPEntry == pOrphanEntry) {
                if (pLink->pNext)
                    pLink->pNext->pPrev = pLink->pPrev;
                if (pLink->pPrev)
                    pLink->pPrev->pNext = pLink->pNext;
                else
                    pEntry->pChildCrossCertDPLink = pLink->pNext;

                delete pLink;

                if (ReleaseCrossCertDistPointEntry(pOrphanEntry))
                    return;
                else
                    break;
            }

            pLink = pLink->pNext;
        }
            
    }
}

//+-------------------------------------------------------------------------
//  Returns TRUE if the entry is in this or any child link list
//--------------------------------------------------------------------------
BOOL
WINAPI
XCertIsDistPointInLinkList(
    IN PXCERT_DP_ENTRY pOrphanEntry,
    IN PXCERT_DP_LINK pLink
    )
{
    for (; pLink; pLink = pLink->pNext) {
        PXCERT_DP_ENTRY pEntry = pLink->pCrossCertDPEntry;
        if (pOrphanEntry == pEntry)
            return TRUE;

        // Note, inhibit recursion by checking an entry's list of links
        // only once.
        if (!pEntry->fChecked) {
            pEntry->fChecked = TRUE;

            if (XCertIsDistPointInLinkList(pOrphanEntry,
                    pEntry->pChildCrossCertDPLink))
                return TRUE;
        }
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//  Frees the cross certificate distribution point links.
//--------------------------------------------------------------------------
void
CCertChainEngine::FreeCrossCertDistPoints(
    IN OUT PXCERT_DP_LINK *ppLinkHead
    )
{
    PXCERT_DP_LINK pLink = *ppLinkHead;
    *ppLinkHead = NULL;

    while (pLink) {
        PXCERT_DP_LINK pDelete;
        PXCERT_DP_ENTRY pEntry;

        pEntry = pLink->pCrossCertDPEntry;
        if (ReleaseCrossCertDistPointEntry(pEntry))
            ;
        else {
            // Clear the fChecked flag for all entries
            PXCERT_DP_ENTRY pCheckEntry;
            for (pCheckEntry = m_pCrossCertDPEntry; pCheckEntry;
                                            pCheckEntry = pCheckEntry->pNext)
                pCheckEntry->fChecked = FALSE;

            if (!XCertIsDistPointInLinkList(pEntry, m_pCrossCertDPLink))
                // An orphaned entry. Not in anyone else's list
                RemoveCrossCertDistPointOrphanEntry(pEntry);
        }
        
        pDelete = pLink;
        pLink = pLink->pNext;
        delete pDelete;
    }
}
            


//+-------------------------------------------------------------------------
//  Retrieve the cross certificates
//
//  Leaves the engine's critical section to do the URL
//  fetching. If the engine was touched by another thread,
//  it fails with LastError set to ERROR_CAN_NOT_COMPLETE.
//
//  If the URL store is changed, increments engine's touch count and flushes
//  issuer and end cert object caches.
//
//  Assumption: Chain engine is locked once in the calling thread.
//--------------------------------------------------------------------------
BOOL
CCertChainEngine::RetrieveCrossCertUrl(
    IN PCCHAINCALLCONTEXT pCallContext,
    IN OUT PXCERT_DP_ENTRY pEntry,
    IN DWORD dwRetrievalFlags,
    IN OUT BOOL *pfTimeValid
    )
{
    BOOL fResult;
    FILETIME CurrentTime;
    HCERTSTORE hNewUrlStore = NULL;
    FILETIME NewLastSyncTime;
    CRYPT_RETRIEVE_AUX_INFO RetrieveAuxInfo;
    DWORD i;

    memset(&RetrieveAuxInfo, 0, sizeof(RetrieveAuxInfo));
    RetrieveAuxInfo.cbSize = sizeof(RetrieveAuxInfo);
    RetrieveAuxInfo.pLastSyncTime = &NewLastSyncTime;

    pCallContext->CurrentTime(&CurrentTime);

    // Loop through Urls and try to retrieve a time valid cross cert URL
    for (i = 0; i < pEntry->cUrl; i++) {
        NewLastSyncTime = CurrentTime;
        LPWSTR pwszUrl = NULL;
        DWORD cbUrl;

        // Do URL fetching outside of the engine's critical section

        // Need to make a copy of the Url string. pEntry
        // can be modified by another thread outside of the critical section.
        cbUrl = (wcslen(pEntry->rgpwszUrl[i]) + 1) * sizeof(WCHAR);
        pwszUrl = (LPWSTR) PkiNonzeroAlloc(cbUrl);
        if (NULL == pwszUrl)
            goto OutOfMemory;
        memcpy(pwszUrl, pEntry->rgpwszUrl[i], cbUrl);

        pCallContext->ChainEngine()->UnlockEngine();
        fResult = ChainRetrieveObjectByUrlW(
                pwszUrl,
                CONTEXT_OID_CAPI2_ANY,
                dwRetrievalFlags |
                    CRYPT_RETRIEVE_MULTIPLE_OBJECTS |
                    CRYPT_STICKY_CACHE_RETRIEVAL,
                pCallContext->ChainPara()->dwUrlRetrievalTimeout,
                (LPVOID *) &hNewUrlStore,
                NULL,                               // hAsyncRetrieve
                NULL,                               // pCredentials
                NULL,                               // pvVerify
                &RetrieveAuxInfo
                );
        pCallContext->ChainEngine()->LockEngine();

        PkiFree(pwszUrl);

        if (pCallContext->IsTouchedEngine())
            goto TouchedDuringUrlRetrieval;

        if (fResult) {
            assert(hNewUrlStore);

            if (0 > CompareFileTime(&pEntry->LastSyncTime, &NewLastSyncTime)) {
                BOOL fStoreChanged = FALSE;

                // Move us to the head of the Url list
                DWORD j;
                LPWSTR pwszUrl = pEntry->rgpwszUrl[i];

                for (j = i; 0 < j; j--)
                    pEntry->rgpwszUrl[j] = pEntry->rgpwszUrl[j - 1];
                pEntry->rgpwszUrl[0] = pwszUrl;

                if (NULL == pEntry->hUrlStore) {
                    if (!CertAddStoreToCollection(
                            m_hCrossCertStore,
                            hNewUrlStore,
                            0,
                            0
                            ))
                        goto AddStoreToCollectionError;
                    pEntry->hUrlStore = hNewUrlStore;
                    hNewUrlStore = NULL;
                    fStoreChanged = TRUE;
                } else {
                    DWORD dwOutFlags = 0;
                    if (!I_CertSyncStoreEx(
                            pEntry->hUrlStore,
                            hNewUrlStore,
                            ICERT_SYNC_STORE_INHIBIT_SYNC_PROPERTY_IN_FLAG,
                            &dwOutFlags,
                            NULL                    // pvReserved
                            ))
                        goto SyncStoreError;
                    if (dwOutFlags & ICERT_SYNC_STORE_CHANGED_OUT_FLAG)
                        fStoreChanged = TRUE;
                }

                if (fStoreChanged) {
                    m_pCertObjectCache->FlushObjects( pCallContext );
                    pCallContext->TouchEngine();

                    if (!GetCrossCertDistPointsForStore(
                            pEntry->hUrlStore,
                            &pEntry->pChildCrossCertDPLink
                            ))
                        goto UpdateDistPointError;
                }

                RepositionOnlineCrossCertDistPointEntry(pEntry,
                    &NewLastSyncTime);

                if (0 < CompareFileTime(&pEntry->NextSyncTime, &CurrentTime)) {
                    *pfTimeValid = TRUE;
                    break;
                }
            }

            if (hNewUrlStore) {
                CertCloseStore(hNewUrlStore, 0);
                hNewUrlStore = NULL;
            }
        }
    }

    fResult = TRUE;
CommonReturn:
    if (hNewUrlStore)
        CertCloseStore(hNewUrlStore, 0);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(AddStoreToCollectionError)
TRACE_ERROR(SyncStoreError)
TRACE_ERROR(UpdateDistPointError)
TRACE_ERROR(OutOfMemory)
SET_ERROR(TouchedDuringUrlRetrieval, ERROR_CAN_NOT_COMPLETE)
}

//+-------------------------------------------------------------------------
//  Update cross certificate distribution points whose NextSyncTime has
//  expired.
//
//  Leaves the engine's critical section to do the URL
//  fetching. If the engine was touched by another thread,
//  it fails with LastError set to ERROR_CAN_NOT_COMPLETE.
//
//  If the URL store is changed, increments engine's touch count and flushes
//  issuer and end cert object caches.
//
//  Assumption: Chain engine is locked once in the calling thread.
//--------------------------------------------------------------------------
BOOL
CCertChainEngine::UpdateCrossCerts(
    IN PCCHAINCALLCONTEXT pCallContext
    )
{
    BOOL fResult;
    PXCERT_DP_ENTRY pEntry;
    FILETIME CurrentTime;

    pEntry = m_pCrossCertDPEntry;
    if (NULL == pEntry)
        goto SuccessReturn;
    
    m_dwCrossCertDPResyncIndex++;

    pCallContext->CurrentTime(&CurrentTime);
    while (pEntry &&
            0 >= CompareFileTime(&pEntry->NextSyncTime, &CurrentTime)) {
        PXCERT_DP_ENTRY pNextEntry = pEntry->pNext;

        if (pEntry->dwResyncIndex < m_dwCrossCertDPResyncIndex) {
            BOOL fTimeValid = FALSE;

            if (0 == pEntry->dwResyncIndex || pCallContext->IsOnline()) {
                RetrieveCrossCertUrl(
                    pCallContext,
                    pEntry,
                    CRYPT_CACHE_ONLY_RETRIEVAL,
                    &fTimeValid
                    );
                if (pCallContext->IsTouchedEngine())
                    goto TouchedDuringUrlRetrieval;

                if (!fTimeValid && pCallContext->IsOnline()) {
                    RetrieveCrossCertUrl(
                        pCallContext,
                        pEntry,
                        CRYPT_WIRE_ONLY_RETRIEVAL,
                        &fTimeValid
                        );
                    if (pCallContext->IsTouchedEngine())
                        goto TouchedDuringUrlRetrieval;

                    if (!fTimeValid)
                        RepositionOfflineCrossCertDistPointEntry(pEntry,
                            &CurrentTime);
                }

                // Start over at the beginning. May have added some entries.
                pNextEntry = m_pCrossCertDPEntry;
            }

            pEntry->dwResyncIndex = m_dwCrossCertDPResyncIndex;

        }
        // else
        //  Skip entries we have already processed.

        pEntry = pNextEntry;
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(TouchedDuringUrlRetrieval, ERROR_CAN_NOT_COMPLETE)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\pfxlib\des.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       des.h
//
//--------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _destable {
	unsigned long	keytab[16][2];
} DESTable;

#define DES_TABLESIZE	sizeof(DESTable)
#define DES_BLOCKLEN	8
#define DES_KEYSIZE	8

/* In deskey.c:

	 Fill in the DESTable struct with the decrypt and encrypt
	 key expansions.

	 Assumes that the second parameter points to DES_BLOCKLEN
	 bytes of key.
	 
*/

void deskey(DESTable *,unsigned char *);

/* In desport.c:

	 Encrypt or decrypt with the key in DESTable

*/

void des(BYTE *pbIn, BYTE *pbOut, void *key, int op);

extern int Asmversion;	/* 1 if we're linked with an asm version, 0 if C */

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\pfxlib\impexppk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       impexppk.h
//
//--------------------------------------------------------------------------

#ifndef _IMPEXPPK_H
#define _IMPEXPPK_H

BOOL   
WINAPI   
ImportExportDllMain(
        HMODULE hInst, 
        ULONG ul_reason_for_call,
        LPVOID lpReserved);






#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\pfxlib\encdecpk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       encdecpk.h
//
//--------------------------------------------------------------------------

#ifndef _ENCDECPK_H
#define _ENCDECPK_H

BOOL   
WINAPI   
EncodeDecodeDllMain(
        HMODULE hInst, 
        ULONG ul_reason_for_call,
        LPVOID lpReserved);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\pfxlib\nscpfmt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       nscp.cpp
//
//  Contents:   PFX: Personal Information Exchange.
//
//  Functions:
//
//  History:    02-Jun-97    mattt    created
//
//--------------------------------------------------------------------------
#include "global.hxx"

#include <wincrypt.h>
#include "shacomm.h"
#include "des.h"
#include "tripldes.h"
#include "modes.h"

#define _PFX_SOURCE_
#include "dbgdef.h"

extern "C" {
    #include "pfxnscp.h"    // ASN1 generated
}

#include "pfxhelp.h"
#include "pfxcrypt.h"
#include "pfxcmn.h"

#define DES_BLOCKLEN 8

///////////////////////////////////////////////////////////////////////////////////
// OLD PKCS #12 Object Identifiers - these are for supporting the old netscape file format
#define OLD_szOID_PKCS_12_OIDs                          szOID_PKCS_12               ".5"    // 1.2.840.113549.1.12.5
#define OLD_szOID_PKCS_12_PbeIds                        OLD_szOID_PKCS_12_OIDs      ".1"
#define OLD_szOID_PKCS_12_pbeWithSHA1And128BitRC4       OLD_szOID_PKCS_12_PbeIds    ".1"
#define OLD_szOID_PKCS_12_pbeWithSHA1And40BitRC4        OLD_szOID_PKCS_12_PbeIds    ".2"
#define OLD_szOID_PKCS_12_pbeWithSHA1AndTripleDES       OLD_szOID_PKCS_12_PbeIds    ".3"
#define OLD_szOID_PKCS_12_pbeWithSHA1And128BitRC2       OLD_szOID_PKCS_12_PbeIds    ".4"
#define OLD_szOID_PKCS_12_pbeWithSHA1And40BitRC2        OLD_szOID_PKCS_12_PbeIds    ".5"

#define OLD_szOID_PKCS_12_EnvelopingIds                 OLD_szOID_PKCS_12_OIDs          ".2"
#define OLD_szOID_PKCS_12_rsaEncryptionWith128BitRC4    OLD_szOID_PKCS_12_EnvelopingIds ".1"
#define OLD_szOID_PKCS_12_rsaEncryptionWith40BitRC4     OLD_szOID_PKCS_12_EnvelopingIds ".2"
#define OLD_szOID_PKCS_12_rsaEncryptionWithTripleDES    OLD_szOID_PKCS_12_EnvelopingIds ".3"

#define OLD_szOID_PKCS_12_SignatureIds                  OLD_szOID_PKCS_12_OIDs          ".3"
#define OLD_szOID_PKCS_12_rsaSignatureWithSHA1Digest    OLD_szOID_PKCS_12_SignatureIds  ".1"

#define OLD_szOID_PKCS_12_ModeIDs               OLD_szOID_PKCS_12               ".1"    // 1.2.840.113549.1.12.1
#define OLD_szOID_PKCS_12_PubKeyMode            OLD_szOID_PKCS_12_ModeIDs       ".1"    // 1.2.840.113549.1.12.1.1
#define OLD_szOID_PKCS_12_PasswdMode            OLD_szOID_PKCS_12_ModeIDs       ".2"    // 1.2.840.113549.1.12.1.2
#define OLD_szOID_PKCS_12_offlineTransportMode  OLD_szOID_PKCS_12_ModeIds       ".1"    // obsolete
#define OLD_szOID_PKCS_12_onlineTransportMode   OLD_szOID_PKCS_12_ModeIds       ".2"    // obsolete

#define OLD_szOID_PKCS_12_EspvkIDs              OLD_szOID_PKCS_12               ".2"    // 1.2.840.113549.1.12.2
#define OLD_szOID_PKCS_12_KeyShrouding          OLD_szOID_PKCS_12_EspvkIDs      ".1"    // 1.2.840.113549.1.12.2.1

#define OLD_szOID_PKCS_12_BagIDs                OLD_szOID_PKCS_12               ".3"    // obsolete
#define OLD_szOID_PKCS_12_KeyBagIDs             OLD_szOID_PKCS_12_BagIDs        ".1"    // obsolete
#define OLD_szOID_PKCS_12_CertCrlBagIDs         OLD_szOID_PKCS_12_BagIDs        ".2"    // obsolete
#define OLD_szOID_PKCS_12_SecretBagIDs          OLD_szOID_PKCS_12_BagIDs        ".3"    // obsolete
#define OLD_szOID_PKCS_12_SafeCntIDs            OLD_szOID_PKCS_12_BagIDs        ".4"    // obsolete
#define OLD_szOID_PKCS_12_ShrKeyBagIDs          OLD_szOID_PKCS_12_BagIDs        ".5"    // obsolete

#define OLD_szOID_PKCS_12_CertBagIDs            OLD_szOID_PKCS_12               ".4"    // obsolete
#define OLD_szOID_PKCS_12_x509CertCrlBagIDs     OLD_szOID_PKCS_12_CertBagIDs    ".1"    // obsolete
#define OLD_szOID_PKCS_12_sdsiCertBagIDs        OLD_szOID_PKCS_12_CertBagIDs    ".2"    // obsolete


static HCRYPTASN1MODULE hNSCPAsn1Module;

// fwd
//BOOL FNSCPDumpSafeCntsToHPFX(SafeContents* pSafeCnts, HPFX hpfx);


BOOL InitNSCP()
{
#ifdef OSS_CRYPT_ASN1
    if (0 == (hNSCPAsn1Module = I_CryptInstallAsn1Module(pfxnscp, 0, NULL)) )
        return FALSE;
#else
    PFXNSCP_Module_Startup();
    if (0 == (hNSCPAsn1Module = I_CryptInstallAsn1Module(
            PFXNSCP_Module, 0, NULL))) {
        PFXNSCP_Module_Cleanup();
        return FALSE;
    }
#endif  // OSS_CRYPT_ASN1
    
    return TRUE;
}

BOOL TerminateNSCP()
{
    I_CryptUninstallAsn1Module(hNSCPAsn1Module);
#ifndef OSS_CRYPT_ASN1
    PFXNSCP_Module_Cleanup();
#endif  // OSS_CRYPT_ASN1
    return TRUE;
}

static inline ASN1decoding_t GetDecoder(void)
{
    return I_CryptGetAsn1Decoder(hNSCPAsn1Module);
}



//+-------------------------------------------------------------------------
//  Function:   INSCP_Asn1ToObjectID
//
//  Synopsis:   Convert a dotted string oid to an ASN1 ObjectID
//
//  Returns:    FALSE iff failed
//--------------------------------------------------------------------------
BOOL
INSCP_Asn1ToObjectID(
    IN OID          oid,
    OUT ObjectID    *pooid
)
{
    BOOL            fRet;

    pooid->count = 16;
    if (!PkiAsn1ToObjectIdentifier(
	    oid,
	    &pooid->count,
	    pooid->value))
	goto PkiAsn1ToObjectIdentifierError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    SetLastError(CRYPT_E_OID_FORMAT);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(PkiAsn1ToObjectIdentifierError)
}


//+-------------------------------------------------------------------------
//  Function:   INSCP_Asn1FromObjectID
//
//  Synopsis:   Convert an ASN1 ObjectID to a dotted string oid
//
//  Returns:    FALSE iff failed
//--------------------------------------------------------------------------
BOOL
INSCP_Asn1FromObjectID(
    IN ObjectID     *pooid,
    OUT OID         *poid
)
{
    BOOL        fRet;
    OID         oid = NULL;
    DWORD       cb;

    if (!PkiAsn1FromObjectIdentifier(
	    pooid->count,
	    pooid->value,
	    NULL,
	    &cb))
	goto PkiAsn1FromObjectIdentifierSizeError;
    if (NULL == (oid = (OID)SSAlloc( cb)))
	    goto OidAllocError;
    if (!PkiAsn1FromObjectIdentifier(
	    pooid->count,
	    pooid->value,
	    oid,
	    &cb))
	goto PkiAsn1FromObjectIdentifierError;

    fRet = TRUE;
CommonReturn:
    *poid = oid;
    return fRet;

ErrorReturn:
    SSFree(oid);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(OidAllocError)
SET_ERROR(PkiAsn1FromObjectIdentifierSizeError , CRYPT_E_OID_FORMAT)
SET_ERROR(PkiAsn1FromObjectIdentifierError     , CRYPT_E_OID_FORMAT)
}

//+-------------------------------------------------------------------------
//  Function:   INSCP_EqualObjectIDs
//
//  Compare 2 OSS object id's.
//
//  Returns:    FALSE iff !equal
//--------------------------------------------------------------------------
BOOL
WINAPI
INSCP_EqualObjectIDs(
    IN ObjectID     *poid1,
    IN ObjectID     *poid2)
{
    BOOL        fRet;
    DWORD       i;
    PDWORD      pdw1;
    PDWORD      pdw2;

    if (poid1->count != poid2->count)
        goto Unequal;
    for (i=poid1->count, pdw1=poid1->value, pdw2=poid2->value;
            (i>0) && (*pdw1==*pdw2);
            i--, pdw1++, pdw2++)
        ;
    if (i>0)
        goto Unequal;

    fRet = TRUE;        // equal
CommonReturn:
    return fRet;

Unequal:
    fRet = FALSE;       // !equal
    goto CommonReturn;
}



//+ --------------------------------------------------------------
//  in NSCP's initial implementation of PFX020, this 
//  is the algorithm they used to derive a key from a password.
//  ACTUALLY, they have two slightly different methods of generating
//  a key, this is the one needed to decrypt the baggage.
//  We include it so we can interoperate.
BOOL NCSPDeriveBaggageDecryptionKey(
        LPCWSTR szPassword,
        int     iPKCS5Iterations,
        PBYTE   pbPKCS5Salt, 
        DWORD   cbPKCS5Salt,
        PBYTE   pbDerivedMaterial,
        DWORD   cbDerivedMaterial)
{
    
    BOOL  fRet = TRUE;
    LPSTR szASCIIPassword = NULL;
    DWORD cbASCIIPassword = 0;
    DWORD i;
    BYTE  paddedPKCS5Salt[20];
    BYTE  *pbTempPKCS5Salt = NULL;
    DWORD cbTempPKCS5Salt = 0;

    BYTE    rgbPKCS5Key[A_SHA_DIGEST_LEN];

    // for some reason the password is used as ASCII in this key derivation
    // so change it from unicode to ASCII
    if (0 == (cbASCIIPassword = WideCharToMultiByte(
                                    CP_ACP,
                                    0,
                                    szPassword,
                                    -1,
                                    NULL,
                                    0,
                                    NULL,
                                    NULL))) {
        goto ErrorReturn;
    }

    if (NULL == (szASCIIPassword = (LPSTR) SSAlloc(cbASCIIPassword))) 
        goto ErrorReturn;

    if (0 == (cbASCIIPassword = WideCharToMultiByte(
                                    CP_ACP,
                                    0,
                                    szPassword,
                                    -1,
                                    szASCIIPassword,
                                    cbASCIIPassword,
                                    NULL,
                                    NULL))) {
        goto ErrorReturn;
    }

    // get rid of the NULL character, Netscape doesn't include it
    cbASCIIPassword--; 

    // because of a Netscape bug the minimum length of password + salt is 20,
    // if the password + salt is less than 20 they pad with 0's.
    // so, check to see if the password + salt is less than 20, if so then pad the 
    // salt since it will be appended to the password.  
    if (cbASCIIPassword+cbPKCS5Salt < 20) {
        // reset the pbPKCS5Salt pointer to a local buffer 
        // which is padded with 0's, and adjust cbPKCS5Salt 
        memset(paddedPKCS5Salt, 0, 20);
        memcpy(paddedPKCS5Salt, pbPKCS5Salt, cbPKCS5Salt);
        pbTempPKCS5Salt = paddedPKCS5Salt;
        cbTempPKCS5Salt = 20 - cbASCIIPassword;
    }
    else {
        pbTempPKCS5Salt = pbPKCS5Salt;
        cbTempPKCS5Salt = cbPKCS5Salt;
    }
    
    
    // use PKCS#5 to generate initial bit stream (seed)
    if (!PKCS5_GenKey(
            iPKCS5Iterations,
            (BYTE *)szASCIIPassword, 
            cbASCIIPassword, 
            pbTempPKCS5Salt, 
            cbTempPKCS5Salt, 
            rgbPKCS5Key))
        goto Ret;
    
    // if there isn't engough key material, then use PHash to generate more
    if (cbDerivedMaterial > sizeof(rgbPKCS5Key))
    {
        // P_hash (secret, seed) =  HMAC_hash (secret, A(0) + seed),
        //                          HMAC_hash (secret, A(1) + seed),
        //                          HMAC_hash (secret, A(2) + seed),
        //                          HMAC_hash (secret, A(3) + seed) ...
        // where
        // A(0) = seed
        // A(i) = HMAC_hash(secret, A(i-1))
        // seed = PKCS5 salt for PKCS5 PBE param
        // secret = normal PKCS5 hashed key

        if (!P_Hash (
                rgbPKCS5Key,
                sizeof(rgbPKCS5Key), 

                pbPKCS5Salt, 
                cbPKCS5Salt,  

                pbDerivedMaterial,      // output
                cbDerivedMaterial,      // # of output bytes requested
                TRUE) )                 // NSCP compat mode?
            goto Ret;
    }
    else
    {
        // we already have enough bits to satisfy the request
        CopyMemory(pbDerivedMaterial, rgbPKCS5Key, cbDerivedMaterial);
    }

    goto Ret;

ErrorReturn:
    fRet = FALSE;
Ret:
    if (szASCIIPassword)
        SSFree(szASCIIPassword);
 
    return fRet;
}



// this function will create a SAFE_BAG structure contained in a single buffer
// for the given encoded private key, friendly name, and local key ID
static
BOOL
SetupKeyBag (
    SAFE_BAG    **ppKeyBag,
    DWORD       dwLocalKeyID,
    BYTE        *pbFriendlyName,
    DWORD       cbFriendlyName,
    BYTE        *pbEncodedPrivateKey,
    DWORD       cbEncodedPrivateKey
    )
{

    BOOL                fRet = TRUE;
    SAFE_BAG            *pSafeBag;
    DWORD               cbBytesNeeded = sizeof(SAFE_BAG);
    DWORD				dwKeyID = 0;
	CRYPT_ATTR_BLOB		keyID;
    CERT_NAME_VALUE		wideFriendlyName;
    BYTE                *pbEncodedLocalKeyID = NULL;
    DWORD               cbEncodedLocalKeyID = 0;
    BYTE                *pbEncodedFriendlyName = NULL;
    DWORD               cbEncodedFriendlyName = 0;
    BYTE                *pbCurrentBufferLocation = NULL;

    keyID.pbData = (BYTE *) &dwKeyID;
	keyID.cbData = sizeof(DWORD);
    dwKeyID = dwLocalKeyID;   

    // calculate the size needed for a buffer to fit all the SAFE_BAG information
    cbBytesNeeded += strlen(szOID_PKCS_12_KEY_BAG) + 1;
    cbBytesNeeded += cbEncodedPrivateKey;
    cbBytesNeeded += sizeof(CRYPT_ATTRIBUTE) * 2;
    cbBytesNeeded += strlen(szOID_PKCS_12_LOCAL_KEY_ID) + 1;
    cbBytesNeeded += sizeof(CRYPT_ATTR_BLOB);
    
    // encode the keyID attribute
   if (!CryptEncodeObject(
		    X509_ASN_ENCODING,
		    X509_OCTET_STRING,
		    &keyID,
		    NULL,
		    &cbEncodedLocalKeyID)) {
	    goto ErrorReturn;
    }

    if (NULL == (pbEncodedLocalKeyID = (BYTE *) SSAlloc(cbEncodedLocalKeyID)))
	    goto ErrorReturn;

    cbBytesNeeded += cbEncodedLocalKeyID;

    if (!CryptEncodeObject(
		    X509_ASN_ENCODING,
		    X509_OCTET_STRING,
		    &keyID,
		    pbEncodedLocalKeyID,
		    &cbEncodedLocalKeyID)) {
	    goto ErrorReturn;
    }

    cbBytesNeeded += strlen(szOID_PKCS_12_FRIENDLY_NAME_ATTR) + 1;
    cbBytesNeeded += sizeof(CRYPT_ATTR_BLOB);
    
    // encode the friendly name attribute
    wideFriendlyName.dwValueType = CERT_RDN_BMP_STRING;
    wideFriendlyName.Value.pbData = pbFriendlyName;
    wideFriendlyName.Value.cbData = 0;

    if (!CryptEncodeObject(
		    X509_ASN_ENCODING,
		    X509_UNICODE_ANY_STRING,
		    (void *)&wideFriendlyName,
		    NULL,
		    &cbEncodedFriendlyName)) {
	    goto ErrorReturn;
    }

    if (NULL == (pbEncodedFriendlyName = (BYTE *) SSAlloc(cbEncodedFriendlyName))) 
	    goto ErrorReturn;

    cbBytesNeeded += cbEncodedFriendlyName;

    if (!CryptEncodeObject(
		    X509_ASN_ENCODING,
		    X509_UNICODE_ANY_STRING,
		    (void *)&wideFriendlyName,
		    pbEncodedFriendlyName,
		    &cbEncodedFriendlyName)) {
	    goto ErrorReturn;
    }

    // now allocate space for the all the SAFE_BAG data and copy the data into the buffer
    if (NULL == (pSafeBag = (SAFE_BAG *) SSAlloc(cbBytesNeeded))) 
        goto ErrorReturn;

    memset(pSafeBag, 0, cbBytesNeeded);

    // set current buffer location to be at the end of the SAFE_BAG
    // structure which is at the head of the buffer
    pbCurrentBufferLocation = ((BYTE *) pSafeBag) + sizeof(SAFE_BAG);
    
    // copy key bag type OID
    pSafeBag->pszBagTypeOID = (LPSTR) pbCurrentBufferLocation;
    strcpy((LPSTR) pbCurrentBufferLocation, szOID_PKCS_12_KEY_BAG);
    pbCurrentBufferLocation += strlen(szOID_PKCS_12_KEY_BAG) + 1;

    // copy the private key 
    pSafeBag->BagContents.pbData = pbCurrentBufferLocation;
    pSafeBag->BagContents.cbData = cbEncodedPrivateKey; 
    memcpy(pbCurrentBufferLocation, pbEncodedPrivateKey, cbEncodedPrivateKey);
    pbCurrentBufferLocation += cbEncodedPrivateKey;

    // create space for the attributes array
    pSafeBag->Attributes.cAttr = 2;
    pSafeBag->Attributes.rgAttr = (CRYPT_ATTRIBUTE *) pbCurrentBufferLocation;
    pbCurrentBufferLocation += sizeof(CRYPT_ATTRIBUTE) * 2;

    // copy the local key ID attribute and value
    pSafeBag->Attributes.rgAttr[0].pszObjId = (LPSTR) pbCurrentBufferLocation;
    strcpy((LPSTR) pbCurrentBufferLocation, szOID_PKCS_12_LOCAL_KEY_ID);
    pbCurrentBufferLocation += strlen(szOID_PKCS_12_LOCAL_KEY_ID) + 1;
    pSafeBag->Attributes.rgAttr[0].cValue = 1;
    pSafeBag->Attributes.rgAttr[0].rgValue = (CRYPT_ATTR_BLOB *) pbCurrentBufferLocation;
    pbCurrentBufferLocation += sizeof(CRYPT_ATTR_BLOB);
    pSafeBag->Attributes.rgAttr[0].rgValue->cbData = cbEncodedLocalKeyID;
    pSafeBag->Attributes.rgAttr[0].rgValue->pbData = pbCurrentBufferLocation;
    memcpy(pbCurrentBufferLocation, pbEncodedLocalKeyID, cbEncodedLocalKeyID);
    pbCurrentBufferLocation += cbEncodedLocalKeyID;

     // copy the friendly name attribute and value
    pSafeBag->Attributes.rgAttr[1].pszObjId = (LPSTR) pbCurrentBufferLocation;
    strcpy((LPSTR) pbCurrentBufferLocation, szOID_PKCS_12_FRIENDLY_NAME_ATTR);
    pbCurrentBufferLocation += strlen(szOID_PKCS_12_FRIENDLY_NAME_ATTR) + 1;
    pSafeBag->Attributes.rgAttr[1].cValue = 1;
    pSafeBag->Attributes.rgAttr[1].rgValue = (CRYPT_ATTR_BLOB *) pbCurrentBufferLocation;
    pbCurrentBufferLocation += sizeof(CRYPT_ATTR_BLOB);
    pSafeBag->Attributes.rgAttr[1].rgValue->cbData = cbEncodedFriendlyName;
    pSafeBag->Attributes.rgAttr[1].rgValue->pbData = pbCurrentBufferLocation;
    memcpy(pbCurrentBufferLocation, pbEncodedFriendlyName, cbEncodedFriendlyName);

    *ppKeyBag = pSafeBag;
    
    goto Ret;

ErrorReturn:
    fRet = FALSE;
Ret:
    if (pbEncodedLocalKeyID)
        SSFree(pbEncodedLocalKeyID);
    if (pbEncodedFriendlyName)
        SSFree(pbEncodedFriendlyName);
    return fRet;
}



// this function will extract a private key from the baggage structure handed in
// and put the private key in a SAFE_BAG structure, where all the data of the 
// SAFE_BAG is contained in a single in a single buffer
static
BOOL
ExtractKeyFromBaggage(
    Baggage     baggage, 
    SAFE_BAG    **ppKeyBag,
    LPCWSTR     szPassword,
    DWORD       dwLocalKeyID,
    BYTE        **ppbCertThumbprint
    )
{
    BOOL                                fRet = TRUE;
	DWORD								dwErr;

    DWORD                               cbEncryptedPrivateKeyInfoStruct = 0;
    CRYPT_ENCRYPTED_PRIVATE_KEY_INFO	*pEncryptedPrivateKeyInfoStruct = NULL;	
    BYTE                                rgbDerivedKeyMatl[40]; // 320 bits is enough for 128 bit key, 64 bit IV
    DWORD                               cbEncodedPrivateKeyInfoStruct = 0;
    BYTE                                *pbEncodedPrivateKeyInfoStruct = NULL;
    PBEParameter                        *pPBEParameter = NULL;
    ASN1decoding_t                      pDec = GetDecoder();

        
    // there should only be one baggage item
    if (baggage.count != 1)
        goto SetPFXDecodeError;

    // there should only be one private key 
    if (baggage.value->espvks.count != 1)
        goto SetPFXDecodeError;

    // decode the PKCS8, which is actually stored in the espvkCipherText field
    // of the ESPVK structure.  it's a Netscape thing man!!!!
    if (!CryptDecodeObject(X509_ASN_ENCODING,
				PKCS_ENCRYPTED_PRIVATE_KEY_INFO,
				(BYTE *) baggage.value->espvks.value->espvkCipherText.value,
				baggage.value->espvks.value->espvkCipherText.length,
				CRYPT_DECODE_NOCOPY_FLAG,
				NULL,
				&cbEncryptedPrivateKeyInfoStruct))
		goto SetPFXDecodeError;	

	if (NULL == (pEncryptedPrivateKeyInfoStruct = (CRYPT_ENCRYPTED_PRIVATE_KEY_INFO *)
				 SSAlloc(cbEncryptedPrivateKeyInfoStruct)))
		goto SetPFXDecodeError;

	if (!CryptDecodeObject(X509_ASN_ENCODING,
				PKCS_ENCRYPTED_PRIVATE_KEY_INFO,
				(BYTE *) baggage.value->espvks.value->espvkCipherText.value,
				baggage.value->espvks.value->espvkCipherText.length,
				CRYPT_DECODE_NOCOPY_FLAG,
				pEncryptedPrivateKeyInfoStruct,
				&cbEncryptedPrivateKeyInfoStruct))
		goto SetPFXDecodeError;

    // verify that the algorithm is the one we expect
    if (strcmp("1.2.840.113549.1.12.5.1.3", pEncryptedPrivateKeyInfoStruct->EncryptionAlgorithm.pszObjId) != 0)
        goto SetPFXDecodeError;

    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&pPBEParameter,
            PBEParameter_PDU,
            pEncryptedPrivateKeyInfoStruct->EncryptionAlgorithm.Parameters.pbData,
            pEncryptedPrivateKeyInfoStruct->EncryptionAlgorithm.Parameters.cbData))
    	goto SetPFXDecodeError;

    // derive the key to be used for decrypting,
    if (!NCSPDeriveBaggageDecryptionKey(
            szPassword,
            pPBEParameter->iterationCount,
            pPBEParameter->salt.value,      // pkcs5 salt
            pPBEParameter->salt.length,
            rgbDerivedKeyMatl,
            40)) { // 192 bits for triple des - 3key, and 64 bit IV ---- for some reason netscape asks for 
                   // 40 bytes of key material, then uses the first 192 bits for key and last 64 bits for IV,
                   // skipping 64 bits in between.  who knows why they do these things!!
       goto ErrorReturn;
    }

    // decrypt the private key
    {
        DWORD       dwDataPos;
        DWORD       cbToBeDec = pEncryptedPrivateKeyInfoStruct->EncryptedPrivateKey.cbData;
        DES3TABLE   des3Table;
        BYTE        des3Fdbk [DES_BLOCKLEN];


        // key setup
        tripledes3key(&des3Table, rgbDerivedKeyMatl); 
        CopyMemory(des3Fdbk, &rgbDerivedKeyMatl[40 - sizeof(des3Fdbk)], sizeof(des3Fdbk));    // fdbk is last chunk
                               
        cbEncodedPrivateKeyInfoStruct = 
            ((pEncryptedPrivateKeyInfoStruct->EncryptedPrivateKey.cbData + 7) / 8) * 8;
                
        if (NULL == (pbEncodedPrivateKeyInfoStruct = (BYTE *) SSAlloc(cbEncodedPrivateKeyInfoStruct))) 
            goto ErrorReturn;

        for (dwDataPos=0; cbToBeDec > 0; dwDataPos += DES_BLOCKLEN, cbToBeDec -= DES_BLOCKLEN)
        {
            BYTE rgbDec[DES_BLOCKLEN];
            
            CBC(
                tripledes,
		        DES_BLOCKLEN,
		        rgbDec,
		        &(pEncryptedPrivateKeyInfoStruct->EncryptedPrivateKey.pbData[dwDataPos]),
		        (void *) &des3Table,
		        DECRYPT,
		        des3Fdbk);

            CopyMemory(&pbEncodedPrivateKeyInfoStruct[dwDataPos], rgbDec, DES_BLOCKLEN);
        }
    }

    // set up the SAFE_BAG to be returned
    if (!SetupKeyBag(
            ppKeyBag, 
            dwLocalKeyID, 
            (BYTE *) baggage.value->espvks.value->espvkData.nickname.value,
            baggage.value->espvks.value->espvkData.nickname.length,
            pbEncodedPrivateKeyInfoStruct, 
            cbEncodedPrivateKeyInfoStruct)) {
        goto ErrorReturn;
    }

    // copy the cert thumbprint
    assert(baggage.value->espvks.value->espvkData.assocCerts.count == 1);
    if (NULL == (*ppbCertThumbprint = (BYTE *) 
                    SSAlloc(baggage.value->espvks.value->espvkData.assocCerts.value->digest.length)))
        goto ErrorReturn;

    memcpy(
        *ppbCertThumbprint, 
        baggage.value->espvks.value->espvkData.assocCerts.value->digest.value,
        baggage.value->espvks.value->espvkData.assocCerts.value->digest.length);

    goto Ret;

SetPFXDecodeError:
	SetLastError(CRYPT_E_BAD_ENCODE);
ErrorReturn:
    fRet = FALSE;

Ret:
	// save last error from TLS madness
	dwErr = GetLastError();

    if (pEncryptedPrivateKeyInfoStruct)
		SSFree(pEncryptedPrivateKeyInfoStruct);
    if (pbEncodedPrivateKeyInfoStruct)
        SSFree(pbEncodedPrivateKeyInfoStruct);

    PkiAsn1FreeDecoded(pDec, pPBEParameter, PBEParameter_PDU);

	// save last error from TLS madness
	SetLastError(dwErr);

    return fRet;
}


// this function will take a SafeContents structure and format it as an array
// array of SAFE_BAGs with all the date for the SAGE_BAGs containted in a single
// buffer.  it also adds the local key ID attribute to the cert which has
// the same thumbprint as the thumbprint passed in 
static
BOOL
SetupCertBags(
    SafeContents    *pSafeCnts,
    SAFE_BAG        **ppCertBags,
    DWORD           *pcNumCertBags,
    DWORD           dwLocalKeyID,
    BYTE            *pbCertThumbprint
    )
{
    BOOL            fRet = TRUE;
	DWORD			dwErr;
    
    SAFE_BAG        *pSafeBags = NULL;
    DWORD           cNumSafeBags = 0;
    
    DWORD           cbBytesNeeded = 0;
    BYTE            *pbCurrentBufferLocation = NULL;
    
    X509Bag         *pX509Bag = NULL;
    CertCRLBag      *pCertCRLBag = NULL;
    
    HCERTSTORE      hCertStore = NULL;
    CRYPT_DATA_BLOB cryptDataBlob;
    PCCERT_CONTEXT  pCertContext = NULL;
    DWORD           dwSafeBagIndex = 0;
    
    DWORD			dwKeyID = 0;
	CRYPT_ATTR_BLOB keyID;
    DWORD           cbEncodedLocalKeyID = 0;
    BYTE            *pbEncodedLocalKeyID = NULL;
    ASN1decoding_t  pDec = GetDecoder();
    
    keyID.pbData = (BYTE *) &dwKeyID;
	keyID.cbData = sizeof(DWORD);
    dwKeyID = dwLocalKeyID;   

    // decode the safe bag content, should be a CertCrlBag
    assert(pSafeCnts->count == 1);
    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&pCertCRLBag,
            CertCRLBag_PDU,
            (BYTE *) pSafeCnts->value->safeBagContent.value,
            pSafeCnts->value->safeBagContent.length))
    	goto SetPFXDecodeError;

    // decode the X509bag
    assert(pCertCRLBag->count == 1);
    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&pX509Bag,
            X509Bag_PDU,
            (BYTE *) pCertCRLBag->value[0].value.value,
            pCertCRLBag->value[0].value.length))
    	goto SetPFXDecodeError;

    // encode the keyID so it is ready to be added to a SAFE_BAGs attributes
   if (!CryptEncodeObject(
		    X509_ASN_ENCODING,
		    X509_OCTET_STRING,
		    &keyID,
		    NULL,
		    &cbEncodedLocalKeyID)) {
	    goto ErrorReturn;
    }

    if (NULL == (pbEncodedLocalKeyID = (BYTE *) SSAlloc(cbEncodedLocalKeyID)))
	    goto ErrorReturn;

    
    if (!CryptEncodeObject(
		    X509_ASN_ENCODING,
		    X509_OCTET_STRING,
		    &keyID,
		    pbEncodedLocalKeyID,
		    &cbEncodedLocalKeyID)) {
	    goto ErrorReturn;
    }

    // open a cert store with the SignedData buffer we got from the SafeContents passed in,
    // this will allow access to all the certs as X509 encoded blobs, and it
    // will give access to the thumbprints so a cert can be matched with the
    // private key
    cryptDataBlob.pbData = (BYTE *) pX509Bag->certOrCRL.content.value;
    cryptDataBlob.cbData = pX509Bag->certOrCRL.content.length;
    hCertStore = CertOpenStore(
                    CERT_STORE_PROV_PKCS7,
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    NULL,
                    0,
                    &cryptDataBlob);
    
    if (NULL == hCertStore) {
        goto ErrorReturn;
    }

    // calculate how much space is needed to fit the array of SAFE_BAGs and
    // all their data into one contiguous buffer
    while (NULL != (pCertContext = CertEnumCertificatesInStore(
                                        hCertStore,
                                        pCertContext))) {
        DWORD cbEncodedCertBag = 0;
        
        cNumSafeBags++;
        cbBytesNeeded += sizeof(SAFE_BAG);
        
        // get the size for wrapping an encoded cert into an encoded cert bag
        if (!MakeEncodedCertBag(
                pCertContext->pbCertEncoded, 
                pCertContext->cbCertEncoded, 
                NULL, 
                &cbEncodedCertBag)) {
            goto ErrorReturn;
        }

        cbBytesNeeded += cbEncodedCertBag;
        cbBytesNeeded += strlen(szOID_PKCS_12_CERT_BAG) + 1;
    }

    // add bytes to cbBytesNeeded so there is enough space to add the 
    // LocalKeyID attribute to ONE of the certificates
    cbBytesNeeded += sizeof(CRYPT_ATTRIBUTE);
    cbBytesNeeded += sizeof(CRYPT_ATTR_BLOB);
    cbBytesNeeded += strlen(szOID_PKCS_12_LOCAL_KEY_ID) + 1;
    cbBytesNeeded += cbEncodedLocalKeyID;

    // allocate the one big buffer
    if (NULL == (pSafeBags = (SAFE_BAG *) SSAlloc(cbBytesNeeded)))
        goto ErrorReturn;

    memset(pSafeBags, 0, cbBytesNeeded);

    // set the current buffer location to the end of the SAFE_BAG array which
    // is at the head of the buffer
    pbCurrentBufferLocation = ((BYTE *) pSafeBags) + (sizeof(SAFE_BAG) * cNumSafeBags);

    // get the X509 blob for each cert and fill in the array of SAFE_BAGs
    pCertContext = NULL;
    dwSafeBagIndex = 0;
    while (NULL != (pCertContext = CertEnumCertificatesInStore(
                                        hCertStore,
                                        pCertContext))) {

        BYTE    *pbLocalThumbprint = NULL;
        DWORD   cbLocalThumbprint = 0;
        BYTE    *pbEncodedCertBag = NULL;
        DWORD   cbEncodedCertBag = 0;
        
        // copy the bag type OID 
        pSafeBags[dwSafeBagIndex].pszBagTypeOID = (LPSTR) pbCurrentBufferLocation;
        strcpy((LPSTR)pbCurrentBufferLocation, szOID_PKCS_12_CERT_BAG);
        pbCurrentBufferLocation += strlen(szOID_PKCS_12_CERT_BAG) + 1;

        // wrap the encoded cert into an encoded certbag
        // get the size for wrapping an encoded cert into an encoded cert bag
        if (!MakeEncodedCertBag(
                pCertContext->pbCertEncoded, 
                pCertContext->cbCertEncoded, 
                NULL, 
                &cbEncodedCertBag)) {
            goto ErrorReturn;
        }

        if (NULL == (pbEncodedCertBag = (BYTE *) SSAlloc(cbEncodedCertBag)))
            goto ErrorReturn;


        if (!MakeEncodedCertBag(
                pCertContext->pbCertEncoded, 
                pCertContext->cbCertEncoded, 
                pbEncodedCertBag, 
                &cbEncodedCertBag)) {
            SSFree(pbEncodedCertBag);
            goto ErrorReturn;
        }

        // copy the encoded certbag
        pSafeBags[dwSafeBagIndex].BagContents.cbData = cbEncodedCertBag;
        pSafeBags[dwSafeBagIndex].BagContents.pbData = pbCurrentBufferLocation;
        memcpy(pbCurrentBufferLocation, pbEncodedCertBag, cbEncodedCertBag);
        pbCurrentBufferLocation += cbEncodedCertBag;

        // we don't need the encoded cert bag anymore
        SSFree(pbEncodedCertBag);
        
        // check to see if this cert is the cert that matches the private key by 
        // comparing the thumbprints

        // Get the thumbprint
        if (!CertGetCertificateContextProperty(
                pCertContext, 
                CERT_SHA1_HASH_PROP_ID, 
                NULL,
                &cbLocalThumbprint)) {
            CertFreeCertificateContext(pCertContext);
            goto ErrorReturn;
        }

        if (NULL == (pbLocalThumbprint = (BYTE *) SSAlloc(cbLocalThumbprint))) {
            CertFreeCertificateContext(pCertContext);
            goto ErrorReturn;   
        }

        if (!CertGetCertificateContextProperty(
                pCertContext, 
                CERT_SHA1_HASH_PROP_ID, 
                pbLocalThumbprint,
                &cbLocalThumbprint)) {
            CertFreeCertificateContext(pCertContext);
            SSFree(pbLocalThumbprint);
            goto ErrorReturn;
        }

        // compare thumbprints
        if (memcmp(pbCertThumbprint, pbLocalThumbprint, cbLocalThumbprint) == 0) {

            // the thumbprints match so add a single attribute with a single value which
            pSafeBags[dwSafeBagIndex].Attributes.cAttr = 1;
            pSafeBags[dwSafeBagIndex].Attributes.rgAttr = (CRYPT_ATTRIBUTE *) pbCurrentBufferLocation;
            pbCurrentBufferLocation += sizeof(CRYPT_ATTRIBUTE);
            pSafeBags[dwSafeBagIndex].Attributes.rgAttr[0].pszObjId = (LPSTR) pbCurrentBufferLocation;
            strcpy((LPSTR) pbCurrentBufferLocation, szOID_PKCS_12_LOCAL_KEY_ID);
            pbCurrentBufferLocation += strlen(szOID_PKCS_12_LOCAL_KEY_ID) + 1;
            pSafeBags[dwSafeBagIndex].Attributes.rgAttr[0].cValue = 1;
            pSafeBags[dwSafeBagIndex].Attributes.rgAttr[0].rgValue = (CRYPT_ATTR_BLOB *) pbCurrentBufferLocation;
            pbCurrentBufferLocation += sizeof(CRYPT_ATTR_BLOB);
            pSafeBags[dwSafeBagIndex].Attributes.rgAttr[0].rgValue[0].cbData = cbEncodedLocalKeyID;
            pSafeBags[dwSafeBagIndex].Attributes.rgAttr[0].rgValue[0].pbData = pbCurrentBufferLocation;
            memcpy(pbCurrentBufferLocation, pbEncodedLocalKeyID, cbEncodedLocalKeyID);
            pbCurrentBufferLocation += cbEncodedLocalKeyID;
        }
        else {

            // otherwise the certificate bag has no attributes in it
            pSafeBags[dwSafeBagIndex].Attributes.cAttr = 0;
            pSafeBags[dwSafeBagIndex].Attributes.rgAttr = NULL;
        }

        SSFree(pbLocalThumbprint);
        dwSafeBagIndex++;
    }

    // return the safe bag array and the number of safe bags in the array
    *ppCertBags = pSafeBags;
    *pcNumCertBags = cNumSafeBags;

    goto Ret;

SetPFXDecodeError:
	SetLastError(CRYPT_E_BAD_ENCODE);
ErrorReturn:
    fRet = FALSE;

    if (pSafeBags)
        SSFree(pSafeBags);
    *ppCertBags = NULL;
    *pcNumCertBags = 0;

Ret:
	// save last error from TLS madness
	dwErr = GetLastError();
    
    PkiAsn1FreeDecoded(pDec, pCertCRLBag, CertCRLBag_PDU);
    PkiAsn1FreeDecoded(pDec, pX509Bag, X509Bag_PDU);

    if (pbEncodedLocalKeyID)
        SSFree(pbEncodedLocalKeyID);

    if (hCertStore)
        CertCloseStore(hCertStore, 0);

	// save last error from TLS madness
	SetLastError(dwErr);

    return fRet;
}


// this function will calculate the number of bytes needed for an
// attribute
static
DWORD
CalculateSizeOfAttributes(
    CRYPT_ATTRIBUTES *pAttributes
    )
{
    DWORD cbBytesNeeded = 0;
    DWORD i,j;

    for (i=0; i<pAttributes->cAttr; i++) {
        cbBytesNeeded += sizeof(CRYPT_ATTRIBUTE);
        cbBytesNeeded += strlen(pAttributes->rgAttr[i].pszObjId) + 1;
        for (j=0; j<pAttributes->rgAttr[i].cValue; j++) {
            cbBytesNeeded += sizeof(CRYPT_ATTR_BLOB);
            cbBytesNeeded += pAttributes->rgAttr[i].rgValue[j].cbData; 
        }
    }

    return cbBytesNeeded;
}


// this function will take two SAFE_BAG arrays and concatenate them into 
// a SAFE_CONTENT structure.  also, the SAFE_CONTENT structure and all
// it's supporting data will be in a single contiguous buffer
static
BOOL
ConcatenateSafeBagsIntoSafeContents(
    SAFE_BAG    *pSafeBagArray1,
    DWORD       cSafeBagArray1,
    SAFE_BAG    *pSafeBagArray2,
    DWORD       cSafeBagArray2,
    SAFE_CONTENTS **ppSafeContents
    )
{
    BOOL            fRet = TRUE;
    DWORD           cbBytesNeeded = 0;
    DWORD           i,j;
    SAFE_CONTENTS   *pSafeContents = NULL;
    DWORD           dwSafeBagIndex = 0;
    BYTE            *pbCurrentBufferLocation = NULL;

    cbBytesNeeded += sizeof(SAFE_CONTENTS);
    cbBytesNeeded += sizeof(SAFE_BAG) * (cSafeBagArray1 + cSafeBagArray2);

    for (i=0; i<cSafeBagArray1; i++) {
        cbBytesNeeded += strlen(pSafeBagArray1[i].pszBagTypeOID) + 1;
        cbBytesNeeded += pSafeBagArray1[i].BagContents.cbData;
        cbBytesNeeded += CalculateSizeOfAttributes(&pSafeBagArray1[i].Attributes);
    }

    for (i=0; i<cSafeBagArray2; i++) {
        cbBytesNeeded += strlen(pSafeBagArray2[i].pszBagTypeOID) + 1;
        cbBytesNeeded += pSafeBagArray2[i].BagContents.cbData;
        cbBytesNeeded += CalculateSizeOfAttributes(&pSafeBagArray2[i].Attributes);
    }

    if (NULL == (pSafeContents = (SAFE_CONTENTS *) SSAlloc(cbBytesNeeded)))
        goto ErrorReturn;

    memset(pSafeContents, 0, cbBytesNeeded);

    pbCurrentBufferLocation = ((BYTE *) pSafeContents) + sizeof(SAFE_CONTENTS);
    pSafeContents->cSafeBags = cSafeBagArray1 + cSafeBagArray2;
    pSafeContents->pSafeBags = (SAFE_BAG *) pbCurrentBufferLocation;
    pbCurrentBufferLocation += sizeof(SAFE_BAG) * (cSafeBagArray1 + cSafeBagArray2);

    for (i=0; i<cSafeBagArray1; i++) {
        pSafeContents->pSafeBags[dwSafeBagIndex].pszBagTypeOID = (LPSTR) pbCurrentBufferLocation;
        strcpy((LPSTR) pbCurrentBufferLocation, pSafeBagArray1[i].pszBagTypeOID);
        pbCurrentBufferLocation += strlen(pSafeBagArray1[i].pszBagTypeOID) + 1;
        pSafeContents->pSafeBags[dwSafeBagIndex].BagContents.cbData = pSafeBagArray1[i].BagContents.cbData;
        pSafeContents->pSafeBags[dwSafeBagIndex].BagContents.pbData = pbCurrentBufferLocation;
        memcpy(pbCurrentBufferLocation, pSafeBagArray1[i].BagContents.pbData, pSafeBagArray1[i].BagContents.cbData);
        pbCurrentBufferLocation += pSafeBagArray1[i].BagContents.cbData;
        
        pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.cAttr = pSafeBagArray1[i].Attributes.cAttr;
        if (pSafeBagArray1[i].Attributes.cAttr != 0) {
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr = (CRYPT_ATTRIBUTE *) pbCurrentBufferLocation;
            pbCurrentBufferLocation += sizeof(CRYPT_ATTRIBUTE) * pSafeBagArray1[i].Attributes.cAttr;
        }
        else {
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr = NULL;
        }

        for (j=0; j<pSafeBagArray1[i].Attributes.cAttr; j++) {
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[j].pszObjId = (LPSTR) pbCurrentBufferLocation;
            strcpy((LPSTR) pbCurrentBufferLocation, pSafeBagArray1[i].Attributes.rgAttr[j].pszObjId);
            pbCurrentBufferLocation += strlen(pSafeBagArray1[i].Attributes.rgAttr[j].pszObjId) + 1;
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[j].cValue = 1;
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[j].rgValue = (CRYPT_ATTR_BLOB *) pbCurrentBufferLocation;
            pbCurrentBufferLocation += sizeof(CRYPT_ATTR_BLOB);
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[j].rgValue[0].cbData = 
                pSafeBagArray1[i].Attributes.rgAttr[j].rgValue[0].cbData;  
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[j].rgValue[0].pbData = pbCurrentBufferLocation;
            memcpy(
                pbCurrentBufferLocation, 
                pSafeBagArray1[i].Attributes.rgAttr[j].rgValue[0].pbData, 
                pSafeBagArray1[i].Attributes.rgAttr[j].rgValue[0].cbData);
            pbCurrentBufferLocation += pSafeBagArray1[i].Attributes.rgAttr[j].rgValue[0].cbData;
        }

        dwSafeBagIndex++;
    }

    for (i=0; i<cSafeBagArray2; i++) {
        pSafeContents->pSafeBags[dwSafeBagIndex].pszBagTypeOID = (LPSTR) pbCurrentBufferLocation;
        strcpy((LPSTR) pbCurrentBufferLocation, pSafeBagArray2[i].pszBagTypeOID);
        pbCurrentBufferLocation += strlen(pSafeBagArray2[i].pszBagTypeOID) + 1;
        pSafeContents->pSafeBags[dwSafeBagIndex].BagContents.cbData = pSafeBagArray2[i].BagContents.cbData;
        pSafeContents->pSafeBags[dwSafeBagIndex].BagContents.pbData = pbCurrentBufferLocation;
        memcpy(pbCurrentBufferLocation, pSafeBagArray2[i].BagContents.pbData, pSafeBagArray2[i].BagContents.cbData);
        pbCurrentBufferLocation += pSafeBagArray2[i].BagContents.cbData;
        
        pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.cAttr = pSafeBagArray2[i].Attributes.cAttr;
        if (pSafeBagArray2[i].Attributes.cAttr != 0) {
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr = (CRYPT_ATTRIBUTE *) pbCurrentBufferLocation;
            pbCurrentBufferLocation += sizeof(CRYPT_ATTRIBUTE) * pSafeBagArray2[i].Attributes.cAttr;
        }
        else {
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr = NULL;
        }

        for (j=0; j<pSafeBagArray2[i].Attributes.cAttr; j++) {
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[j].pszObjId = (LPSTR) pbCurrentBufferLocation;
            strcpy((LPSTR) pbCurrentBufferLocation, pSafeBagArray2[i].Attributes.rgAttr[j].pszObjId);
            pbCurrentBufferLocation += strlen(pSafeBagArray2[i].Attributes.rgAttr[j].pszObjId) + 1;
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[j].cValue = 1;
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[j].rgValue = (CRYPT_ATTR_BLOB *) pbCurrentBufferLocation;
            pbCurrentBufferLocation += sizeof(CRYPT_ATTR_BLOB);
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[j].rgValue[0].cbData = 
                pSafeBagArray2[i].Attributes.rgAttr[j].rgValue[0].cbData;  
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[j].rgValue[0].pbData = pbCurrentBufferLocation;
            memcpy(
                pbCurrentBufferLocation, 
                pSafeBagArray2[i].Attributes.rgAttr[j].rgValue[0].pbData, 
                pSafeBagArray2[i].Attributes.rgAttr[j].rgValue[0].cbData);
            pbCurrentBufferLocation += pSafeBagArray2[i].Attributes.rgAttr[j].rgValue[0].cbData;
        }

        dwSafeBagIndex++;
    }

    *ppSafeContents = pSafeContents;
    goto Ret;

ErrorReturn:
    fRet = FALSE;
Ret:
    return fRet;
}


BOOL
PFXAPI
NSCPImportBlob
(   
    LPCWSTR  szPassword,
    PBYTE   pbIn,
    DWORD   cbIn,
    SAFE_CONTENTS **ppSafeContents
)
{
    BOOL            fRet = TRUE;
	DWORD			dwErr;
    
    int             iEncrType;
    OID             oid = NULL;

    PFX             *psPfx = NULL;
    EncryptedData   *pEncrData = NULL;
    RSAData         *pRSAData = NULL;
    PBEParameter    *pPBEParameter = NULL;
    SafeContents    *pSafeCnts = NULL;
    AuthenticatedSafe *pAuthSafe = NULL;
	SAFE_BAG		*pKeyBag = NULL;
	SAFE_BAG        *pCertBag = NULL;
    BYTE            *pCertThumbprint = NULL;
    DWORD           cNumCertBags = 0;
    ASN1decoding_t  pDec = GetDecoder();

    // Crack the PFX blob
    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&psPfx,
            PFX_PDU,
            pbIn,
            cbIn))
    	goto SetPFXDecodeError;
    
    // info blurted into psPfx(PFX) - ensure content present
    if (0 == (psPfx->authSafe.bit_mask & content_present))
	    goto SetPFXDecodeError;

    
    // UNDONE: tear apart MACData


    // Check authsafe(ContentInfo)

    // could be data/signeddata
    // UNDONE: only support szOID_RSA_data 
    if (!INSCP_Asn1FromObjectID( &psPfx->authSafe.contentType,  &oid))
	    goto ErrorReturn;
    if (0 != strcmp( oid, szOID_RSA_data))
	    goto SetPFXDecodeError;
    SSFree(oid);
    oid = NULL;
    
    // content is data: decode
    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&pRSAData,
            RSAData_PDU,
            (BYTE *) psPfx->authSafe.content.value,
            psPfx->authSafe.content.length))
    	goto SetPFXDecodeError;

    // now we have octet string: this is an encoded authSafe
    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&pAuthSafe,
            AuthenticatedSafe_PDU,
            pRSAData->value,
            pRSAData->length))
    	goto SetPFXDecodeError;

    // check version of the safe
    if (pAuthSafe->bit_mask & version_present)
#ifdef OSS_CRYPT_ASN1
        if (pAuthSafe->version != v1)
#else
        if (pAuthSafe->version != Version_v1)
#endif  // OSS_CRYPT_ASN1
	        goto SetPFXDecodeError;

    // require (officially optional) pieces
    
    // NSCP: transport mode is used but count is encoded incorrectly
//   if (0 == (pAuthSafe->bit_mask & transportMode_present))
//	    goto PFXDecodeError;

    if (0 == (pAuthSafe->bit_mask & privacySalt_present))
	    goto SetPFXDecodeError;
    if (0 == (pAuthSafe->bit_mask & baggage_present))
	    goto SetPFXDecodeError;

    // could be encryptedData/envelopedData
    // UNDONE: only support szOID_RSA_encryptedData 
    if (!INSCP_Asn1FromObjectID( &pAuthSafe->safe.contentType,  &oid))
	    goto ErrorReturn;
    if (0 != strcmp( oid, szOID_RSA_encryptedData))
	    goto SetPFXDecodeError;
    SSFree(oid);
    oid = NULL;


    //    
    // we have pAuthSafe->safe data as RSA_encryptedData
    // we have pAuthSafe->privacySalt to help us decrypt it

    // we have pAuthSafe->baggage 

    // decode content to encryptedData
    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&pEncrData,
            EncryptedData_PDU,
            (BYTE *) pAuthSafe->safe.content.value,
            pAuthSafe->safe.content.length))
    	goto SetPFXDecodeError;
    

    // chk version
    if (pEncrData->version != 0)  
        goto SetPFXDecodeError;

    // chk content present, type
    if (0 == (pEncrData->encryptedContentInfo.bit_mask & encryptedContent_present))
        goto SetPFXDecodeError;
    if (!INSCP_Asn1FromObjectID(&pEncrData->encryptedContentInfo.contentType, &oid))
        goto ErrorReturn;
    if (0 != strcmp( oid, szOID_RSA_data))
        goto SetPFXDecodeError;
    SSFree(oid);
    oid = NULL;


    // chk encr alg present, type
    if (0 == (pEncrData->encryptedContentInfo.contentEncryptionAlg.bit_mask & parameters_present))
        goto SetPFXDecodeError;
    if (!INSCP_Asn1FromObjectID(&pEncrData->encryptedContentInfo.contentEncryptionAlg.algorithm, &oid))
        goto ErrorReturn;

    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&pPBEParameter,
            PBEParameter_PDU,
            (BYTE *) pEncrData->encryptedContentInfo.contentEncryptionAlg.parameters.value,
            pEncrData->encryptedContentInfo.contentEncryptionAlg.parameters.length))
    	goto SetPFXDecodeError;


    
    if (0 == strcmp( oid, OLD_szOID_PKCS_12_pbeWithSHA1And40BitRC2))
    {
        iEncrType = RC2_40;
    }
    else if (0 == strcmp( oid, OLD_szOID_PKCS_12_pbeWithSHA1And40BitRC4))
    {
        iEncrType = RC4_40;
    }
    else if (0 == strcmp( oid, OLD_szOID_PKCS_12_pbeWithSHA1And128BitRC2))
    {
        iEncrType = RC2_128;
    }
    else if (0 == strcmp( oid, OLD_szOID_PKCS_12_pbeWithSHA1And128BitRC4))
    {
        iEncrType = RC4_128;
    }
    else if (0 == strcmp( oid, OLD_szOID_PKCS_12_pbeWithSHA1AndTripleDES))
    {
        iEncrType = TripleDES;
    }
    else
        goto SetPFXAlgIDError;
    SSFree(oid);
    oid = NULL;


    // DECRYPT encryptedData
    if (!NSCPPasswordDecryptData(
            iEncrType, 

            szPassword,
            pAuthSafe->privacySalt.value,   // privacy salt
            pAuthSafe->privacySalt.length/8,
            pPBEParameter->iterationCount,
            pPBEParameter->salt.value,      // pkcs5 salt
            pPBEParameter->salt.length,

            &pEncrData->encryptedContentInfo.encryptedContent.value,
            (PDWORD)&pEncrData->encryptedContentInfo.encryptedContent.length))
        goto SetPFXDecryptError;

    // decode plaintext encryptedData
    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&pSafeCnts,
            SafeContents_PDU,
            pEncrData->encryptedContentInfo.encryptedContent.value,
            pEncrData->encryptedContentInfo.encryptedContent.length))
    	goto SetPFXDecodeError;

    // get private keys out of baggage
	if (!ExtractKeyFromBaggage(
            pAuthSafe->baggage, 
            &pKeyBag, 
            szPassword,
            1,              // this parameter is the Local Key ID to add to the key bags attributes
            &pCertThumbprint)) { 
        goto ErrorReturn;
    }
    
    // set up the cert bag
    if (!SetupCertBags(
            pSafeCnts,
            &pCertBag,
            &cNumCertBags,
            1,    // this parameter is the Local Key ID to add to the cert bags attributes
            pCertThumbprint)) { 
        goto ErrorReturn;
    }

    ConcatenateSafeBagsIntoSafeContents(
        pKeyBag,
        1,
        pCertBag,
        cNumCertBags,
        ppSafeContents);
 	
    goto Ret;


SetPFXAlgIDError:
    SetLastError(NTE_BAD_ALGID);
    goto ErrorReturn;

SetPFXDecodeError:
	SetLastError(CRYPT_E_BAD_ENCODE);
    goto ErrorReturn;

SetPFXDecryptError:
	SetLastError(NTE_FAIL);
    goto ErrorReturn;

ErrorReturn:
    fRet = FALSE;
Ret:

	// save last error from TLS madness
	dwErr = GetLastError();

    PkiAsn1FreeDecoded(pDec, psPfx, PFX_PDU);
    PkiAsn1FreeDecoded(pDec, pRSAData, RSAData_PDU);
    PkiAsn1FreeDecoded(pDec, pAuthSafe, AuthenticatedSafe_PDU);
    PkiAsn1FreeDecoded(pDec, pEncrData, EncryptedData_PDU);
    PkiAsn1FreeDecoded(pDec, pPBEParameter, PBEParameter_PDU);
    PkiAsn1FreeDecoded(pDec, pSafeCnts, SafeContents_PDU);

    if (oid != NULL)
        SSFree(oid);

    if (pKeyBag)
        SSFree(pKeyBag);

    if (pCertBag)
        SSFree(pCertBag);

    if (pCertThumbprint)
        SSFree(pCertThumbprint);
	
	// save last error from TLS madness
	SetLastError(dwErr);

    return fRet;  // return bogus handle
}


BOOL
PFXAPI
IsNetscapePFXBlob(CRYPT_DATA_BLOB* pPFX)
{
    PFX             *psPfx = NULL;
    ASN1decoding_t  pDec = GetDecoder();
    
    // Crack the PFX blob
    if (0 == PkiAsn1Decode(
            pDec,
            (void **)&psPfx,
            PFX_PDU,
            pPFX->pbData,
            pPFX->cbData))
    {
        PkiAsn1FreeDecoded(pDec, psPfx, PFX_PDU);
        return TRUE;
    }
    	
    return FALSE;
}



/*
BOOL FNSCPDumpSafeCntsToHPFX(SafeContents* pSafeCnts, HPFX hpfx)
{
    PPFX_INFO           ppfx = (PPFX_INFO)hpfx;

    // sort and dump bags into correct areas
    ObjectID oKeyBag, oCertBag; 
    DWORD dw;

    ZeroMemory(&oKeyBag, sizeof(ObjectID));
    ZeroMemory(&oCertBag, sizeof(ObjectID));

    if (!INSCP_Asn1ToObjectID( &szOID_PKCS_12_KeyBagIDs, &oKeyBag))
	    return FALSE;

    if (!INSCP_Asn1ToObjectID( &szOID_PKCS_12_CertCrlBagIDs, &oCertBag))
	    return FALSE;

    for (dw=pSafeCnts->count; dw>0; --dw)
    {
        if (INSCP_EqualObjectIDs(&pSafeCnts->value->safeBagType,
                &oKeyBag) )
        {
            // inc size
            ppfx->cKeys++;
            if (ppfx->rgKeys)
                ppfx->rgKeys = (void**)SSReAlloc(ppfx->rgKeys, ppfx->cKeys * sizeof(SafeBag*));
            else
                ppfx->rgKeys = (void**)SSAlloc(ppfx->cKeys * sizeof(SafeBag*));

            // assign to keys
            ppfx->rgKeys[ppfx->cKeys-1] = &pSafeCnts->value[dw];
        }
        else if (INSCP_EqualObjectIDs(&pSafeCnts->value->safeBagType,
                &oCertBag) )
        {
            // inc size
            ppfx->cCertcrls++;
            if (ppfx->rgCertcrls)
                ppfx->rgCertcrls = (void**)SSReAlloc(ppfx->rgCertcrls, ppfx->cCertcrls * sizeof(SafeBag*));
            else
                ppfx->rgCertcrls = (void**)SSAlloc(ppfx->cCertcrls * sizeof(SafeBag*));

            // assign to certs/crls
            ppfx->rgCertcrls[ppfx->cCertcrls-1] = &pSafeCnts->value[dw];
        }
        else
        {
            // inc size
            ppfx->cSecrets++;
            if (ppfx->rgSecrets)
                ppfx->rgSecrets = (void**)SSReAlloc(ppfx->rgSecrets, ppfx->cSecrets * sizeof(SafeBag*));
            else
                ppfx->rgSecrets = (void**)SSAlloc(ppfx->cSecrets * sizeof(SafeBag*));

            // assign to safebag
            ppfx->rgSecrets[ppfx->cSecrets-1] = &pSafeCnts->value[dw];
        }
    }

    return TRUE;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\pfxlib\modes.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       modes.h
//
//--------------------------------------------------------------------------

/* modes.h

	Defines the generic routines used to do chaining modes with a
	block cipher.
*/


#ifdef __cplusplus
extern "C" {
#endif

// constants for operations
#define ENCRYPT		1
#define DECRYPT		0
	
/* CBC()
 *
 * Performs a XOR on the plaintext with the previous ciphertext
 *
 * Parameters:
 *
 *		output		Input buffer	-- MUST be RC2_BLOCKLEN
 *		input		Output buffer	-- MUST be RC2_BLOCKLEN
 *		keyTable
 *		op		ENCRYPT, or DECRYPT
 *		feedback	feedback register
 *
 */
void CBC(void	Cipher(BYTE *, BYTE *, void *, int),
		 DWORD	dwBlockLen,
		 BYTE	*output,
		 BYTE	*input,
		 void	*keyTable,
		 int	op,
		 BYTE	*feedback);


/* CFB (cipher feedback)
 *
 *
 * Parameters:
 *
 *
 *		output		Input buffer	-- MUST be RC2_BLOCKLEN
 *		input		Output buffer	-- MUST be RC2_BLOCKLEN
 *		keyTable
 *		op		ENCRYPT, or DECRYPT
 *		feedback	feedback register
 *
 */
void CFB(void	Cipher(BYTE *, BYTE *, void *, int),
		 DWORD	dwBlockLen,
		 BYTE	*output,
		 BYTE	*input,
		 void	*keyTable,
		 int	op,
		 BYTE	*feedback);


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\pfxlib\pfxcmn.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pfxcmn.h
//
//--------------------------------------------------------------------------

#ifndef _PFXCMN_H_
#define _PFXCMN_H_

#ifdef __cplusplus
extern "C" {
#endif


typedef DWORD   PFXERR;
typedef HANDLE  HPFXITEM;
typedef HANDLE  HPFX;
typedef LPSTR   OID;

#define PFXAPI __stdcall

// define allocators
#define SSAlloc(__x__)              LocalAlloc(LMEM_FIXED, __x__)
#define SSFree(__x__)               LocalFree(__x__)
#define SSReAlloc(__x__, __y__)     LocalReAlloc(__x__, __y__, LMEM_MOVEABLE)


// PFXExportCertStoreEx -> PFXExportCertStore internal param
#define PKCS12_ENHANCED_STRENGTH_ENCODING  0xffff0008 

#define PKCS12_ENCR_PWD_ITERATIONS      2000
#define PKCS12_MAC_PWD_ITERATIONS		2000


#define MAKEZERO(arg) ZeroMemory( &arg, sizeof(arg))

// count the number of bytes needed to fully store a WSZ
#define WSZ_BYTECOUNT(__z__)   \
    ( (__z__ == NULL) ? 0 : (wcslen(__z__)+1)*sizeof(WCHAR) )


typedef struct _PFX_INFO {

    #define     NSCP_BLOB   1
    #define     PFX_BLOB    2
    DWORD                   dwBlobType; // NSCP, PFX?

    LPWSTR                  szPassword;

    DWORD                   dwPrivacyMode;
    DWORD                   dwIntegrityMode;
    DWORD                   dwTransportMode;

    CRYPT_ALGORITHM_IDENTIFIER    aiKeyShroudingEncryptionAlgid;
    CRYPT_ALGORITHM_IDENTIFIER    aiSafePDUEncryptionAlgid;

    
    void**                  rgSecrets;          // SafeBag* []  -- array of safebag*'s
    DWORD                   cSecrets;

    void**                  rgCertcrls;         // SafeBag* []  -- array of safebag*'s
    DWORD                   cCertcrls;

    void**                  rgKeys;             // SafeBag* []  -- array of safebag*'s
    DWORD                   cKeys;

    void**                  rgShroudedKeys;     // SafeBag* []  -- array of safebag*'s
    DWORD                   cShroudedKeys;

} PFX_INFO, *PPFX_INFO;





// -------------------------------------------------------------------------
// begin nscp.cpp entry points
// -------------------------------------------------------------------------
BOOL InitNSCP();
BOOL TerminateNSCP();

////////////////////
// import pb, cb, return HPFX
BOOL
PFXAPI
NSCPImportBlob
(   
    LPCWSTR         szPassword,
    PBYTE           pbIn,
    DWORD           cbIn,
    SAFE_CONTENTS   **ppSafeContents
);

// -------------------------------------------------------------------------
// end nscp.cpp entry points
// -------------------------------------------------------------------------



// -------------------------------------------------------------------------
// begin PFX.cpp entry points
// -------------------------------------------------------------------------
BOOL InitPFX();
BOOL TerminatePFX();

////////////////////
//  returns HPFX, prepares PFX export
HPFX
PFXAPI
PfxExportCreate (
    LPCWSTR szPassword
);


////////////////////
//  Do header wrap of specified HPFX
BOOL
PFXAPI
PfxExportBlob
(   
    HPFX    hpfx,   
    PBYTE   pbOut,
    DWORD*  pcbOut,
    DWORD   dwFlags
);

////////////////////
//  Unwrap pb cb, return handle to new HPFX
HPFX
PFXAPI
PfxImportBlob
(   
    LPCWSTR szPassword,
    PBYTE   pbIn,
    DWORD   cbIn,
    DWORD   dwFlags
);

////////////////////
//  Free all resources associated with the hpfx
BOOL
PFXAPI
PfxCloseHandle(
    IN HPFX hpfx
);


//
// functions for checking if somethings is a pfx blob
//
BOOL
PFXAPI
IsRealPFXBlob
(
    CRYPT_DATA_BLOB* pPFX
);

BOOL
PFXAPI
IsNetscapePFXBlob
(
    CRYPT_DATA_BLOB* pPFX
);

// -------------------------------------------------------------------------
// end PFX.cpp entry points
// -------------------------------------------------------------------------

// new entry points for loading up the HPFX
BOOL PfxGetKeysAndCerts(
    HPFX hPfx, 
    SAFE_CONTENTS* pContents
);

BOOL PfxAddSafeBags(
    HPFX hPfx, 
    SAFE_BAG*   pSafeBags, 
    DWORD       cSafeBags
);

BOOL
MakeEncodedCertBag(
    BYTE *pbEncodedCert,
    DWORD cbEncodedCert,
    BYTE *pbEncodedCertBag,
    DWORD *pcbEncodedCertBag
);

BOOL
GetEncodedCertFromEncodedCertBag(
    BYTE    *pbEncodedCertBag,
    DWORD   cbEncodedCertBag,
    BYTE    *pbEncodedCert,
    DWORD   *pcbEncodedCert
);

BOOL
SetSaltAndIterationCount(
    BYTE    **ppbParameters,
    DWORD   *pcbParameters,
    BYTE    *pbSalt,
    DWORD   cbSalt,
    int     iIterationCount
);

BOOL
GetSaltAndIterationCount(
    BYTE    *pbParameters,
    DWORD   cbParameters,
    BYTE    **ppbSalt,
    DWORD   *pcbSalt,
    int     *piIterationCount
);

///////////////////////////////////////////////////////////////////////////////////
// The real PKCS #12 Object Identifiers
#define szOID_PKCS_12_PbeIds                        szOID_PKCS_12           ".1"
#define szOID_PKCS_12_pbeWithSHA1And128BitRC4       szOID_PKCS_12_PbeIds    ".1"
#define szOID_PKCS_12_pbeWithSHA1And40BitRC4        szOID_PKCS_12_PbeIds    ".2"
#define szOID_PKCS_12_pbeWithSHA1And3KeyTripleDES   szOID_PKCS_12_PbeIds    ".3"
#define szOID_PKCS_12_pbeWithSHA1And2KeyTripleDES   szOID_PKCS_12_PbeIds    ".4"
#define szOID_PKCS_12_pbeWithSHA1And128BitRC2       szOID_PKCS_12_PbeIds    ".5"
#define szOID_PKCS_12_pbeWithSHA1And40BitRC2        szOID_PKCS_12_PbeIds    ".6"

#define szOID_PKCS_12_EnvelopingIds                 OLD_szOID_PKCS_12_OIDs          ".2"
#define szOID_PKCS_12_rsaEncryptionWith128BitRC4    OLD_szOID_PKCS_12_EnvelopingIds ".1"
#define szOID_PKCS_12_rsaEncryptionWith40BitRC4     OLD_szOID_PKCS_12_EnvelopingIds ".2"
#define szOID_PKCS_12_rsaEncryptionWithTripleDES    OLD_szOID_PKCS_12_EnvelopingIds ".3"

#define szOID_PKCS_12_SignatureIds                  OLD_szOID_PKCS_12_OIDs          ".3"
#define szOID_PKCS_12_rsaSignatureWithSHA1Digest    OLD_szOID_PKCS_12_SignatureIds  ".1"



#define szOID_PKCS_12_PkekIDs               szOID_PKCS_12               ".6"    // 1.2.840.113549.1.12.6
#define szOID_PKCS_12_UserCertPkekId        szOID_PKCS_12_PkekIDs       ".1"    // 1.2.840.113549.1.12.6.1
#define szOID_PKCS_12_CACertPkekId          szOID_PKCS_12_PkekIDs       ".2"    // 1.2.840.113549.1.12.6.2
#define szOID_PKCS_12_SelfSignedPkekId      szOID_PKCS_12_PkekIDs       ".3"    // 1.2.840.113549.1.12.6.3

#define szOID_PKCS_12_Version1                  szOID_PKCS_12           ".10"
#define szOID_PKCS_12_BagIDs                    szOID_PKCS_12_Version1  ".1"
#define szOID_PKCS_12_KeyBag                    szOID_PKCS_12_BagIDs    ".1"
#define szOID_PKCS_12_ShroudedKeyBag            szOID_PKCS_12_BagIDs    ".2"
#define szOID_PKCS_12_CertBag                   szOID_PKCS_12_BagIDs    ".3"
#define szOID_PKCS_12_CRLBag                    szOID_PKCS_12_BagIDs    ".4"
#define szOID_PKCS_12_SecretBag                 szOID_PKCS_12_BagIDs    ".5"
#define szOID_PKCS_12_SafeContentsBag           szOID_PKCS_12_BagIDs    ".6"


// new oids 6/30/97
#define szOID_PKCS_12_FriendlyName              szOID_PKCS_9            ".20"
#define szOID_PKCS_12_LocalKeyID                szOID_PKCS_9            ".21"
#define szOID_PKCS_12_CertTypes                 szOID_PKCS_9            ".22"
#define szOID_PKCS_12_CRLTypes                  szOID_PKCS_9            ".23"
#define szOID_PKCS_12_x509Cert                  szOID_PKCS_12_CertTypes ".1"
#define szOID_PKCS_12_SDSICert                  szOID_PKCS_12_CertTypes ".2"
#define szOID_PKCS_12_x509CRL                   szOID_PKCS_12_CRLTypes  ".1"




#ifdef __cplusplus
}   // extern "C"
#endif

#endif // _PFXCMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\pfxlib\encdecpk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       certhlpr.cpp
//
//  Contents:   import and export of private keys
//
//  Functions:  ImportExoprtDllMain
//				CryptImportPKCS8
//				CryptExportPKCS8
//
//  History:    
//--------------------------------------------------------------------------

#include "global.hxx"

#ifdef __cplusplus
extern "C" {
#endif
#include "prvtkey.h"
#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)
static const BYTE NullDer[2] = {0x05, 0x00};
static const CRYPT_OBJID_BLOB NullDerBlob = {2, (BYTE *)&NullDer[0]};

static HCRYPTASN1MODULE hPrivateKeyAsn1Module;
static HCRYPTOIDFUNCSET hEncodePrivKeyFuncSet;
static HCRYPTOIDFUNCSET hDecodePrivKeyFuncSet;

//+-------------------------------------------------------------------------
//  OSS ASN.1 PKCS#8 PrivateKey Encode / Decode functions
//--------------------------------------------------------------------------
static BOOL WINAPI OssRSAPrivateKeyStrucEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN BLOBHEADER *pBlobHeader,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
static BOOL WINAPI OssRSAPrivateKeyStrucDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT BLOBHEADER *pBlobHeader,
        IN OUT DWORD *pcbBlobHeader
        );

static BOOL WINAPI OssPrivateKeyInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_PRIVATE_KEY_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
static BOOL WINAPI OssPrivateKeyInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRYPT_PRIVATE_KEY_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );

static BOOL WINAPI OssEncryptedPrivateKeyInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ENCRYPTED_PRIVATE_KEY_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
static BOOL WINAPI OssEncryptedPrivateKeyInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRYPT_ENCRYPTED_PRIVATE_KEY_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );

static const CRYPT_OID_FUNC_ENTRY PrivateKeyEncodeFuncTable[] = {
	PKCS_RSA_PRIVATE_KEY, OssRSAPrivateKeyStrucEncode,
	PKCS_PRIVATE_KEY_INFO, OssPrivateKeyInfoEncode,
	PKCS_ENCRYPTED_PRIVATE_KEY_INFO, OssEncryptedPrivateKeyInfoEncode
};
#define PRIVATEKEY_ENCODE_FUNC_COUNT (sizeof(PrivateKeyEncodeFuncTable) / \
                                    sizeof(PrivateKeyEncodeFuncTable[0]))

static const CRYPT_OID_FUNC_ENTRY PrivateKeyDecodeFuncTable[] = {
	PKCS_RSA_PRIVATE_KEY, OssRSAPrivateKeyStrucDecode,
	PKCS_PRIVATE_KEY_INFO, OssPrivateKeyInfoDecode,
	PKCS_ENCRYPTED_PRIVATE_KEY_INFO, OssEncryptedPrivateKeyInfoDecode,
};

#define PRIVATEKEY_DECODE_FUNC_COUNT (sizeof(PrivateKeyDecodeFuncTable) / \
                                    sizeof(PrivateKeyDecodeFuncTable[0]))



BOOL   
WINAPI   
EncodeDecodeDllMain(
        HMODULE hInst, 
        ULONG ul_reason_for_call,
        LPVOID lpReserved)
{
    switch( ul_reason_for_call ) 
    {
    case DLL_PROCESS_ATTACH:
        if (NULL == (hEncodePrivKeyFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_ENCODE_OBJECT_FUNC,
                0)))
            goto ErrorReturn;
        if (NULL == (hDecodePrivKeyFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_DECODE_OBJECT_FUNC,
                0)))
            goto ErrorReturn;

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_OBJECT_FUNC,
                PRIVATEKEY_ENCODE_FUNC_COUNT,
                PrivateKeyEncodeFuncTable,
                0))                         // dwFlags
            goto ErrorReturn;
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_DECODE_OBJECT_FUNC,
                PRIVATEKEY_DECODE_FUNC_COUNT,
                PrivateKeyDecodeFuncTable,
                0))                         // dwFlags
            goto ErrorReturn;
 
#ifdef OSS_CRYPT_ASN1
        if (0 == (hPrivateKeyAsn1Module =
                I_CryptInstallAsn1Module(prvtkey, 0, NULL)) )
            goto ErrorReturn;
#else
        PRVTKEY_Module_Startup();
        if (0 == (hPrivateKeyAsn1Module = I_CryptInstallAsn1Module(
                PRVTKEY_Module, 0, NULL))) {
            PRVTKEY_Module_Cleanup();
            goto ErrorReturn;
        }
#endif  // OSS_CRYPT_ASN1
        break;
        
    case DLL_PROCESS_DETACH:
        I_CryptUninstallAsn1Module(hPrivateKeyAsn1Module);
#ifndef OSS_CRYPT_ASN1
        PRVTKEY_Module_Cleanup();
#endif  // OSS_CRYPT_ASN1
        break;

    default:
        break;
    }

    return TRUE;
ErrorReturn:
    return FALSE;
}


static inline ASN1encoding_t GetEncoder(void)
{
    return I_CryptGetAsn1Encoder(hPrivateKeyAsn1Module);
}
static inline ASN1decoding_t GetDecoder(void)
{
    return I_CryptGetAsn1Decoder(hPrivateKeyAsn1Module);
}


//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure
//
//  Called by the OssX509*Encode() functions.
//--------------------------------------------------------------------------
static BOOL OssInfoEncode(
        IN int pdunum,
        IN void *pOssInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return PkiAsn1EncodeInfo(
        GetEncoder(),
        pdunum,
        pOssInfo,
        pbEncoded,
        pcbEncoded);
}


//+-------------------------------------------------------------------------
//  Decode into an allocated, OSS formatted info structure
//
//  Called by the OssX509*Decode() functions.
//--------------------------------------------------------------------------
static BOOL OssInfoDecodeAndAlloc(
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppOssInfo
        )
{
    return PkiAsn1DecodeAndAllocInfo(
        GetDecoder(),
        pdunum,
        pbEncoded,
        cbEncoded,
        ppOssInfo);
}


//+-------------------------------------------------------------------------
//  Free an allocated, OSS formatted info structure
//
//  Called by the OssX509*Decode() functions.
//--------------------------------------------------------------------------
static void OssInfoFree(
        IN int pdunum,
        IN void *pOssInfo
        )
{
    if (pOssInfo) {
        DWORD dwErr = GetLastError();

        // TlsGetValue globbers LastError
        PkiAsn1FreeInfo(GetDecoder(), pdunum, pOssInfo);

        SetLastError(dwErr);
    }
}


//+-------------------------------------------------------------------------
//  Set/Get CRYPT_DATA_BLOB (Octet String)
//--------------------------------------------------------------------------
static inline void OssX509SetOctetString(
        IN PCRYPT_DATA_BLOB pInfo,
        OUT OCTETSTRING *pOss
        )
{
    pOss->value = pInfo->pbData;
    pOss->length = pInfo->cbData;
}
static inline void OssX509GetOctetString(
        IN OCTETSTRING *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetOctetString(pOss->length, pOss->value, dwFlags,
        pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Get Object Identifier string
//--------------------------------------------------------------------------
static BOOL OssX509SetObjId(
        IN LPSTR pszObjId,
        OUT ObjectID *pOss
        )
{
    pOss->count = sizeof(pOss->value) / sizeof(pOss->value[0]);
    if (PkiAsn1ToObjectIdentifier(pszObjId, &pOss->count, pOss->value))
        return TRUE;
    else {
        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
        return FALSE;
    }
}

static void OssX509GetObjId(
        IN ObjectID *pOss,
        IN DWORD dwFlags,
        OUT LPSTR *ppszObjId,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    DWORD cbObjId;

    cbObjId = lRemainExtra > 0 ? lRemainExtra : 0;
    PkiAsn1FromObjectIdentifier(
        pOss->count,
        pOss->value,
        (LPSTR) pbExtra,
        &cbObjId
        );

    lAlignExtra = INFO_LEN_ALIGN(cbObjId);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if(cbObjId) {
            *ppszObjId = (LPSTR) pbExtra;
        } else
            *ppszObjId = NULL;
        pbExtra += lAlignExtra;
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
static inline void OssX509SetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT NOCOPYANY *pOss
        )
{
#ifdef OSS_CRYPT_ASN1
    PkiAsn1SetAny(pInfo, (OpenType *) pOss);
#else
    PkiAsn1SetAny(pInfo, pOss);
#endif  // OSS_CRYPT_ASN1
}
static inline void OssX509GetAny(
        IN NOCOPYANY *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
#ifdef OSS_CRYPT_ASN1
    PkiAsn1GetAny((OpenType *) pOss, dwFlags, pInfo, ppbExtra, plRemainExtra);
#else
    PkiAsn1GetAny(pOss, dwFlags, pInfo, ppbExtra, plRemainExtra);
#endif  // OSS_CRYPT_ASN1
}

//+-------------------------------------------------------------------------
//  Set/Free/Get SeqOfAny
//--------------------------------------------------------------------------
static BOOL WINAPI OssX509SetSeqOfAny(
        IN DWORD cValue,
        IN PCRYPT_DER_BLOB pValue,
#ifdef OSS_CRYPT_ASN1
        OUT unsigned int *pOssCount,
#else
        OUT ASN1uint32_t *pOssCount,
#endif  // OSS_CRYPT_ASN1
        OUT NOCOPYANY **ppOssValue
        )
{
    
    *pOssCount = 0;
    *ppOssValue = NULL;
    if (cValue > 0) {
        NOCOPYANY *pOssValue;

        pOssValue = (NOCOPYANY *) SSAlloc(cValue * sizeof(NOCOPYANY));
        if (pOssValue == NULL)
            return FALSE;
        memset(pOssValue, 0, cValue * sizeof(NOCOPYANY));
        *pOssCount = cValue;
        *ppOssValue = pOssValue;
        for ( ; cValue > 0; cValue--, pValue++, pOssValue++)
            OssX509SetAny(pValue, pOssValue);
    }
    return TRUE;
}

static void OssX509FreeSeqOfAny(
        IN NOCOPYANY *pOssValue
        )
{
    if (pOssValue)
        SSFree(pOssValue);
}

static void OssX509GetSeqOfAny(
        IN unsigned int OssCount,
        IN NOCOPYANY *pOssValue,
        IN DWORD dwFlags,
        OUT DWORD *pcValue,
        OUT PCRYPT_DER_BLOB *ppValue,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lAlignExtra;
    PCRYPT_ATTR_BLOB pValue;

    lAlignExtra = INFO_LEN_ALIGN(OssCount * sizeof(CRYPT_DER_BLOB));
    *plRemainExtra -= lAlignExtra;
    if (*plRemainExtra >= 0) {
        *pcValue = OssCount;
        pValue = (PCRYPT_DER_BLOB) *ppbExtra;
        *ppValue = pValue;
        *ppbExtra += lAlignExtra;
    } else
        pValue = NULL;

    for (; OssCount > 0; OssCount--, pOssValue++, pValue++)
        OssX509GetAny(pOssValue, dwFlags, pValue, ppbExtra, plRemainExtra);
}


//+-------------------------------------------------------------------------
//  Set/Free/Get CRYPT_ATTRIBUTE
//--------------------------------------------------------------------------
static BOOL WINAPI OssX509SetAttribute(
        IN PCRYPT_ATTRIBUTE pInfo,
        OUT Attribute *pOss
        )
{
    memset(pOss, 0, sizeof(*pOss));
    if (!OssX509SetObjId(pInfo->pszObjId, &pOss->type))
        return FALSE;

    return OssX509SetSeqOfAny(
            pInfo->cValue,
            pInfo->rgValue,
            &pOss->values.count,
            &pOss->values.value);
}

static void OssX509FreeAttribute(
        IN OUT Attribute *pOss
        )
{
    OssX509FreeSeqOfAny(pOss->values.value);
}

static void OssX509GetAttribute(
        IN Attribute *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_ATTRIBUTE pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    OssX509GetObjId(&pOss->type, dwFlags,
        &pInfo->pszObjId, ppbExtra, plRemainExtra);
    OssX509GetSeqOfAny(pOss->values.count, pOss->values.value, dwFlags,
        &pInfo->cValue, &pInfo->rgValue, ppbExtra, plRemainExtra);
}


//+-------------------------------------------------------------------------
//  Set/Get CRYPT_ALGORITHM_IDENTIFIER
//--------------------------------------------------------------------------
static BOOL OssX509SetAlgorithm(
        IN PCRYPT_ALGORITHM_IDENTIFIER pInfo,
        OUT AlgorithmIdentifier *pOss
        )
{
    memset(pOss, 0, sizeof(*pOss));
    if (pInfo->pszObjId) {
        if (!OssX509SetObjId(pInfo->pszObjId, &pOss->algorithm))
            return FALSE;
        if (pInfo->Parameters.cbData)
            OssX509SetAny(&pInfo->Parameters, &pOss->parameters);
        else
            // Per PKCS #1: default to the ASN.1 type NULL.
            OssX509SetAny((PCRYPT_OBJID_BLOB) &NullDerBlob, &pOss->parameters);
        pOss->bit_mask |= parameters_present;
    }
    return TRUE;
}

static void OssX509GetAlgorithm(
        IN AlgorithmIdentifier *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_ALGORITHM_IDENTIFIER pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    if (*plRemainExtra >= 0)
        memset(pInfo, 0, sizeof(*pInfo));
    OssX509GetObjId(&pOss->algorithm, dwFlags, &pInfo->pszObjId,
            ppbExtra, plRemainExtra);
    if (pOss->bit_mask & parameters_present)
        OssX509GetAny(&pOss->parameters, dwFlags, &pInfo->Parameters,
            ppbExtra, plRemainExtra);
}


//+-------------------------------------------------------------------------
//  Helper function for Encode RSA Private Key
//--------------------------------------------------------------------------
static BOOL WINAPI AllocAndCopyHugeInteger(
		IN BYTE *pbHugeInteger,
		IN DWORD cbHugeInteger,
		OUT HUGEINTEGER *pHugeInteger		
		)
{
	BYTE *pbAllocBuffer = NULL;
	
	if (NULL == (pbAllocBuffer = (BYTE *) SSAlloc(cbHugeInteger + 1)))
		return FALSE;
	*pbAllocBuffer = 0;
    memcpy(pbAllocBuffer + 1, pbHugeInteger, cbHugeInteger);
    PkiAsn1ReverseBytes(pbAllocBuffer + 1, cbHugeInteger);
    pHugeInteger->length = cbHugeInteger + 1;
    pHugeInteger->value = pbAllocBuffer;
	return TRUE;
}

#ifndef RSA2
#define RSA2 ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'2'<<24))
#endif

//+-------------------------------------------------------------------------
//  Encode RSA Private Key
//--------------------------------------------------------------------------
static BOOL WINAPI OssRSAPrivateKeyStrucEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN BLOBHEADER *pBlobHeader,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
	BOOL fResult;
    
	BYTE *pbKeyBlob;
    RSAPUBKEY *pRsaPubKey;
    
	BYTE *pbCurrentHugeInteger;
    DWORD cbHugeInteger;
    BYTE *pbAllocBuffer = NULL;
	   
	RSAPrivateKey OssRSAPrivateKey;

	memset(&OssRSAPrivateKey, 0, (size_t) sizeof(RSAPrivateKey));

    // The CAPI RSA private key representation consists of the following sequence:
    // - BLOBHEADER blobheader;
	// - RSAPUBKEY rsapubkey;
	// - BYTE modulus[rsapubkey.bitlen/8];
	// - BYTE prime1[rsapubkey.bitlen/16];
	// - BYTE prime2[rsapubkey.bitlen/16];
	// - BYTE exponent1[rsapubkey.bitlen/16];
	// - BYTE exponent2[rsapubkey.bitlen/16];
	// - BYTE coefficient[rsapubkey.bitlen/16];
	// - BYTE privateExponent[rsapubkey.bitlen/8];

    pbKeyBlob = (BYTE *) pBlobHeader;
    pRsaPubKey = (RSAPUBKEY *) (pbKeyBlob + sizeof(BLOBHEADER));
    
	assert(pRsaPubKey->bitlen / 8 > 0);
    assert(pBlobHeader->bType == PRIVATEKEYBLOB);
    assert(pBlobHeader->bVersion == CUR_BLOB_VERSION);
    assert(pBlobHeader->aiKeyAlg == CALG_RSA_SIGN ||
           pBlobHeader->aiKeyAlg == CALG_RSA_KEYX);
    assert(pRsaPubKey->magic == RSA2);
    assert(pRsaPubKey->bitlen % 8 == 0);

    if (pBlobHeader->bType != PRIVATEKEYBLOB)
        goto InvalidArg;

    // PKCS #1 ASN.1 encode
    //
    // ASN.1 isn't reversing HUGE_INTEGERs. Also, after doing the
    // reversal insert a leading 0 byte to force it to always be treated
    // as an unsigned integer 

	OssRSAPrivateKey.version = 0; // currently on version 0
	
	// MODULUS
	pbCurrentHugeInteger = pbKeyBlob + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY);
    cbHugeInteger = pRsaPubKey->bitlen / 8;
    if (!AllocAndCopyHugeInteger(pbCurrentHugeInteger, 
								cbHugeInteger, 
								&(OssRSAPrivateKey.modulus)))
		goto ErrorReturn;
	
	// PUBLIC EXPONENT
	OssRSAPrivateKey.publicExponent = pRsaPubKey->pubexp;

	// PRIME1
	pbCurrentHugeInteger += cbHugeInteger;
	cbHugeInteger = pRsaPubKey->bitlen / 16;
    if (!AllocAndCopyHugeInteger(pbCurrentHugeInteger, 
								cbHugeInteger, 
								&(OssRSAPrivateKey.prime1)))
		goto ErrorReturn;
	
	// PRIME2
	pbCurrentHugeInteger += cbHugeInteger;
	if (!AllocAndCopyHugeInteger(pbCurrentHugeInteger, 
								cbHugeInteger, 
								&(OssRSAPrivateKey.prime2)))
		goto ErrorReturn;
								
	// EXPONENT1
	pbCurrentHugeInteger += cbHugeInteger;
	if (!AllocAndCopyHugeInteger(pbCurrentHugeInteger, 
								cbHugeInteger, 
								&(OssRSAPrivateKey.exponent1)))
		goto ErrorReturn;

    // EXPONENT2
	pbCurrentHugeInteger += cbHugeInteger;
	if (!AllocAndCopyHugeInteger(pbCurrentHugeInteger, 
								cbHugeInteger, 
								&(OssRSAPrivateKey.exponent2)))
		goto ErrorReturn;

	// COEFFICIENT
	pbCurrentHugeInteger += cbHugeInteger;
	if (!AllocAndCopyHugeInteger(pbCurrentHugeInteger, 
								cbHugeInteger, 
								&(OssRSAPrivateKey.coefficient)))
		goto ErrorReturn;

	// PRIVATE EXPONENT
	pbCurrentHugeInteger += cbHugeInteger;
	cbHugeInteger = pRsaPubKey->bitlen / 8;
    if (!AllocAndCopyHugeInteger(pbCurrentHugeInteger, 
								cbHugeInteger, 
								&(OssRSAPrivateKey.privateExponent)))
		goto ErrorReturn;
    	
	fResult = OssInfoEncode(
        RSAPrivateKey_PDU,
        &OssRSAPrivateKey,
        pbEncoded,
        pcbEncoded
        );
    goto CommonReturn;

InvalidArg:
    SetLastError((DWORD) E_INVALIDARG);
ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (OssRSAPrivateKey.modulus.value)
        SSFree(OssRSAPrivateKey.modulus.value);
	if (OssRSAPrivateKey.prime1.value)
		SSFree(OssRSAPrivateKey.prime1.value);
	if (OssRSAPrivateKey.prime2.value)
		SSFree(OssRSAPrivateKey.prime2.value);
	if (OssRSAPrivateKey.exponent1.value)
		SSFree(OssRSAPrivateKey.exponent1.value);
	if (OssRSAPrivateKey.exponent2.value)
		SSFree(OssRSAPrivateKey.exponent2.value);
	if (OssRSAPrivateKey.coefficient.value)
		SSFree(OssRSAPrivateKey.coefficient.value);
	if (OssRSAPrivateKey.privateExponent.value)
		SSFree(OssRSAPrivateKey.privateExponent.value);
    return fResult;
}


//+-------------------------------------------------------------------------
//  Helper function for Decode RSA Private Key
//--------------------------------------------------------------------------
static BOOL WINAPI CopyHugeIntegerToByteArray(
		HUGEINTEGER *pHugeInteger, 
		BYTE *pbBuffer,
		DWORD cbBuffer,
        BOOL  fGetRidOfLeading0)
{
	memset(pbBuffer, 0, (size_t) cbBuffer);
	
	DWORD cbHugeInteger = pHugeInteger->length;
    BYTE *pbHugeInteger = pHugeInteger->value;
	
	// get rid of leading zero on the huge integer
	if ((cbHugeInteger > 1)     && 
        (*pbHugeInteger == 0)   &&
        (fGetRidOfLeading0))
    {
            pbHugeInteger++;
            cbHugeInteger--;
    }
    else if ((cbHugeInteger > cbBuffer) && 
             (*pbHugeInteger != 0)      &&
             (fGetRidOfLeading0))
    {
        //
        // THIS IS A UNSUPPORTED KEY FORMAT PROBLEM!!
        //
        SetLastError((DWORD) ERROR_UNSUPPORTED_TYPE);
		assert(0);
		return FALSE;
    }

	// verify there is enough space in pbBuffer to receive
	// the huge integer
	if (cbHugeInteger > cbBuffer)
	{
		SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
		assert(0);
		return FALSE;
	}
	// advance pbBuffer to the correct place within itself,
	// this will leave leading zeros at the beginning of the buffer
	/*else
		pbBuffer += (cbBuffer - cbHugeInteger);*/


	if (cbHugeInteger > 0) {
        memcpy(pbBuffer, pbHugeInteger, cbHugeInteger);
        // ASN.1 isn't reversing HUGEINTEGERs
        PkiAsn1ReverseBytes(pbBuffer, cbHugeInteger);
    }

	return TRUE;
}



//+-------------------------------------------------------------------------
//  Decode RSA Private Key
//--------------------------------------------------------------------------
static BOOL WINAPI OssRSAPrivateKeyStrucDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT BLOBHEADER *pBlobHeader,
        IN OUT DWORD *pcbBlobHeader
        )
{
	BOOL fResult;
    RSAPrivateKey *pOssPrivateKey = NULL;

    if (pBlobHeader == NULL)
        *pcbBlobHeader = 0;

    if ((fResult = OssInfoDecodeAndAlloc(
            RSAPrivateKey_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pOssPrivateKey))) {
        DWORD cbPrivateKeyStruc;
        BYTE *pbOssModulus;
        DWORD cbModulus;
        DWORD cbNonModulus;
        // Now convert the OSS RSA private key into CAPI's representation which
        // consists of the following sequence:
        // - BLOBHEADER blobheader;
		// - RSAPUBKEY rsapubkey;
		// - BYTE modulus[rsapubkey.bitlen/8];
		// - BYTE prime1[rsapubkey.bitlen/16];
		// - BYTE prime2[rsapubkey.bitlen/16];
		// - BYTE exponent1[rsapubkey.bitlen/16];
		// - BYTE exponent2[rsapubkey.bitlen/16];
		// - BYTE coefficient[rsapubkey.bitlen/16];
		// - BYTE privateExponent[rsapubkey.bitlen/8];
        cbModulus = pOssPrivateKey->modulus.length;
        
        pbOssModulus = pOssPrivateKey->modulus.value;
        // Strip off a leading 0 byte. Its there in the decoded ASN
        // integer for an unsigned integer with the leading bit set.
        if (cbModulus > 1 && *pbOssModulus == 0) {
            pbOssModulus++;
            cbModulus--;
        }

        cbNonModulus = (cbModulus / 2) + (cbModulus % 2);

        cbPrivateKeyStruc = sizeof(BLOBHEADER) + // length of BLOBHEADER
							sizeof(RSAPUBKEY) +  // length of RSAPUBKEY
							(cbModulus * 2) +    // length of modulus and privateExponent
							(cbNonModulus * 5);	 // length of prime1&2, exponent1&2, and coefficient
        if (*pcbBlobHeader < cbPrivateKeyStruc) {
            if (pBlobHeader) {
                fResult = FALSE;
                SetLastError((DWORD) ERROR_MORE_DATA);
            }
        } else {
            BYTE *pbKeyBlob = (BYTE *) pBlobHeader;
            RSAPUBKEY *pRsaPubKey =
                (RSAPUBKEY *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
            BYTE *pbModulus = pbKeyBlob + sizeof(PUBLICKEYSTRUC) +
                sizeof(RSAPUBKEY);
			BYTE *pbCurrentPosition = NULL;
    
            pBlobHeader->bType = PRIVATEKEYBLOB;
            pBlobHeader->bVersion = CUR_BLOB_VERSION;
            pBlobHeader->reserved = 0;
            // Note: KEYX can also be used for doing a signature
            pBlobHeader->aiKeyAlg = CALG_RSA_KEYX;
            
			pRsaPubKey->magic = RSA2;
            pRsaPubKey->bitlen = cbModulus * 8;
            pRsaPubKey->pubexp = pOssPrivateKey->publicExponent;
            
            // MODULUS
			if (cbModulus > 0) {
                memcpy(pbModulus, pbOssModulus, cbModulus);
                // ASN.1 isn't reversing HUGEINTEGERs
                PkiAsn1ReverseBytes(pbModulus, cbModulus);
            }

			// PRIME1
			pbCurrentPosition = pbModulus + cbModulus;
			if (!CopyHugeIntegerToByteArray(&pOssPrivateKey->prime1, 
											pbCurrentPosition,
											cbNonModulus,
                                            (pOssPrivateKey->prime1.length - 1) == cbNonModulus))
				goto ErrorReturn;

			// PRIME2
			pbCurrentPosition += cbNonModulus; 
			if (!CopyHugeIntegerToByteArray(&pOssPrivateKey->prime2, 
											pbCurrentPosition,
											cbNonModulus,
                                            (pOssPrivateKey->prime2.length - 1) == cbNonModulus))
				goto ErrorReturn;

			// EXPONENT1
			pbCurrentPosition += cbNonModulus;
			if (!CopyHugeIntegerToByteArray(&pOssPrivateKey->exponent1, 
											pbCurrentPosition,
											cbNonModulus,
                                            (pOssPrivateKey->exponent1.length - 1) == cbNonModulus))
				goto ErrorReturn;

			// EXPONENT2
			pbCurrentPosition += cbNonModulus;
			if (!CopyHugeIntegerToByteArray(&pOssPrivateKey->exponent2, 
											pbCurrentPosition,
											cbNonModulus,
                                            (pOssPrivateKey->exponent2.length - 1) == cbNonModulus))
				goto ErrorReturn;

			// COEFFICIENT
			pbCurrentPosition += cbNonModulus;
			if (!CopyHugeIntegerToByteArray(&pOssPrivateKey->coefficient, 
											pbCurrentPosition,
											cbNonModulus,
                                            (pOssPrivateKey->coefficient.length - 1) == cbNonModulus))
				goto ErrorReturn;

			// PRIVATE EXPONENT
			pbCurrentPosition += cbNonModulus;
			if (!CopyHugeIntegerToByteArray(&pOssPrivateKey->privateExponent, 
											pbCurrentPosition,
											cbModulus,
                                            (pOssPrivateKey->privateExponent.length - 1) == cbModulus))
				goto ErrorReturn;

        }
        *pcbBlobHeader = cbPrivateKeyStruc;
    } else
        *pcbBlobHeader = 0;

    OssInfoFree(RSAPrivateKey_PDU, pOssPrivateKey);

	goto CommonReturn;

ErrorReturn:
	*pcbBlobHeader = 0;
	fResult = FALSE;
CommonReturn:
    return fResult;
}


//+-------------------------------------------------------------------------
//  Encode Private Key Info 
//--------------------------------------------------------------------------
static BOOL WINAPI OssPrivateKeyInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_PRIVATE_KEY_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
	BOOL fResult;
	PrivateKeyInfo OssPrivateKeyInfo;
	Attribute *pOssAttr = NULL;
	DWORD cAttr;
	PCRYPT_ATTRIBUTE pAttr;

	memset(&OssPrivateKeyInfo, 0, sizeof(PrivateKeyInfo));

	OssPrivateKeyInfo.version = pInfo->Version; 

	if (!OssX509SetAlgorithm(&pInfo->Algorithm, &OssPrivateKeyInfo.privateKeyAlgorithm))
        goto ErrorReturn;
    
	OssX509SetOctetString(&pInfo->PrivateKey, &OssPrivateKeyInfo.privateKey);
	
	if (pInfo->pAttributes) {
		cAttr = pInfo->pAttributes->cAttr;
		pAttr = pInfo->pAttributes->rgAttr;
		
		OssPrivateKeyInfo.privateKeyAttributes.count = cAttr;
		OssPrivateKeyInfo.privateKeyAttributes.value = NULL;
		if (cAttr > 0) {
			pOssAttr = (Attribute *) SSAlloc(cAttr * sizeof(Attribute));
			if (pOssAttr == NULL)
				goto ErrorReturn;
			memset(pOssAttr, 0, cAttr * sizeof(Attribute));
			OssPrivateKeyInfo.privateKeyAttributes.value= pOssAttr;
		}

		for ( ; cAttr > 0; cAttr--, pAttr++, pOssAttr++) {
			if (!OssX509SetAttribute(pAttr, pOssAttr))
				goto ErrorReturn;
		}
		
		OssPrivateKeyInfo.bit_mask |= privateKeyAttributes_present;
	}

    fResult = OssInfoEncode(
        PrivateKeyInfo_PDU,
        &OssPrivateKeyInfo,
        pbEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
	if (OssPrivateKeyInfo.privateKeyAttributes.value) {
        pOssAttr = OssPrivateKeyInfo.privateKeyAttributes.value;
        cAttr = OssPrivateKeyInfo.privateKeyAttributes.count;
        for ( ; cAttr > 0; cAttr--, pOssAttr++)
            OssX509FreeAttribute(pOssAttr);

        SSFree(OssPrivateKeyInfo.privateKeyAttributes.value);
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode Private Key Info
//--------------------------------------------------------------------------
static BOOL WINAPI OssPrivateKeyInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRYPT_PRIVATE_KEY_INFO pInfo,
        IN OUT DWORD *pcbInfo
        )
{
	BOOL fResult;
    PrivateKeyInfo *pPrivateKeyInfo = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (!OssInfoDecodeAndAlloc(
            PrivateKeyInfo_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pPrivateKeyInfo))
        goto EncodeError;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(CRYPT_PRIVATE_KEY_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CRYPT_PRIVATE_KEY_INFO));

        // Update fields not needing extra memory after the CRYPT_PRIVATE_KEY_INFO
        pInfo->Version = pPrivateKeyInfo->version;
        
		pbExtra = (BYTE *) pInfo + sizeof(CRYPT_PRIVATE_KEY_INFO);
    }

    OssX509GetAlgorithm(&pPrivateKeyInfo->privateKeyAlgorithm, dwFlags,
            &pInfo->Algorithm, &pbExtra, &lRemainExtra);
    
	OssX509GetOctetString(&pPrivateKeyInfo->privateKey, dwFlags, 
			&pInfo->PrivateKey, &pbExtra, &lRemainExtra);
	
	if (pPrivateKeyInfo->bit_mask & privateKeyAttributes_present) {
        DWORD cAttr;
        PCRYPT_ATTRIBUTE pAttr;
        Attribute *pOssAttr;
		LONG lAlignExtra;

		// put the CRYPT_ATTRIBUTES structure in the extra buffer space
		// and point pInfo->pAttributes to it
		if ((pbExtra) && (lRemainExtra >= sizeof(CRYPT_ATTRIBUTES))) {
			memset(pbExtra, 0, sizeof(CRYPT_ATTRIBUTES));
			pInfo->pAttributes = (PCRYPT_ATTRIBUTES) pbExtra;
			pbExtra += sizeof(CRYPT_ATTRIBUTES);
		}
		lRemainExtra -= sizeof(CRYPT_ATTRIBUTES);
		
		cAttr = pPrivateKeyInfo->privateKeyAttributes.count;
        lAlignExtra = INFO_LEN_ALIGN(cAttr * sizeof(CRYPT_ATTRIBUTE));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pInfo->pAttributes->cAttr = cAttr;
            pAttr = (PCRYPT_ATTRIBUTE) pbExtra;
            pInfo->pAttributes->rgAttr = pAttr;
            pbExtra += lAlignExtra;
        } else
            pAttr = NULL;

        pOssAttr = pPrivateKeyInfo->privateKeyAttributes.value;
        for (; cAttr > 0; cAttr--, pAttr++, pOssAttr++)
            OssX509GetAttribute(pOssAttr, dwFlags,
                pAttr, &pbExtra, &lRemainExtra);
	}

	if (lRemainExtra >= 0)
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    else {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
EncodeError:
    SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
// ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
CommonReturn:
    OssInfoFree(PrivateKeyInfo_PDU, pPrivateKeyInfo);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Encode Encrypted Private Key Info
//--------------------------------------------------------------------------
static BOOL WINAPI OssEncryptedPrivateKeyInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ENCRYPTED_PRIVATE_KEY_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
	BOOL fResult;
	EncryptedPrivateKeyInfo OssEncryptedPrivateKeyInfo;
	
	memset(&OssEncryptedPrivateKeyInfo, 0, sizeof(EncryptedPrivateKeyInfo));

	if (!OssX509SetAlgorithm(&pInfo->EncryptionAlgorithm, &OssEncryptedPrivateKeyInfo.encryptionAlgorithm))
        goto ErrorReturn;
    
	OssX509SetOctetString(&pInfo->EncryptedPrivateKey, &OssEncryptedPrivateKeyInfo.encryptedData);
	
	fResult = OssInfoEncode(
        EncryptedPrivateKeyInfo_PDU,
        &OssEncryptedPrivateKeyInfo,
        pbEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
	return fResult;
}

//+-------------------------------------------------------------------------
//  Decode Encrypted Private Key Info
//--------------------------------------------------------------------------
static BOOL WINAPI OssEncryptedPrivateKeyInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRYPT_ENCRYPTED_PRIVATE_KEY_INFO pInfo,
        IN OUT DWORD *pcbInfo
        )
{
	BOOL fResult;
    EncryptedPrivateKeyInfo *pEncryptedPrivateKeyInfo = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (!OssInfoDecodeAndAlloc(
            EncryptedPrivateKeyInfo_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pEncryptedPrivateKeyInfo))
        goto EncodeError;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(CRYPT_ENCRYPTED_PRIVATE_KEY_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
		memset(pInfo, 0, sizeof(CRYPT_ENCRYPTED_PRIVATE_KEY_INFO));
		pbExtra = (BYTE *) pInfo + sizeof(CRYPT_ENCRYPTED_PRIVATE_KEY_INFO);
    }

    OssX509GetAlgorithm(&pEncryptedPrivateKeyInfo->encryptionAlgorithm, dwFlags,
            &pInfo->EncryptionAlgorithm, &pbExtra, &lRemainExtra);
    
	OssX509GetOctetString(&pEncryptedPrivateKeyInfo->encryptedData, dwFlags, 
			&pInfo->EncryptedPrivateKey, &pbExtra, &lRemainExtra);
	
	if (lRemainExtra >= 0)
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    else {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
EncodeError:
    SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
//ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
CommonReturn:
    OssInfoFree(EncryptedPrivateKeyInfo_PDU, pEncryptedPrivateKeyInfo);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\pfxlib\impexppk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       certhlpr.cpp
//
//  Contents:   import and export of private keys
//
//  Functions:  ImportExoprtDllMain
//				CryptImportPKCS8
//				CryptExportPKCS8
//
//  History:    
//--------------------------------------------------------------------------

#include "global.hxx"
//#include "prvtkey.h"
#include "impexppk.h"
#include "pfxcrypt.h"


// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

static BOOL WINAPI ExportRSAPrivateKeyInfo(
    HCRYPTPROV              hCryptProv,         // in
    DWORD                   dwKeySpec,          // in
    LPSTR                   pszPrivateKeyObjId, // in
    DWORD                   dwFlags,            // in
    void                    *pvAuxInfo,         // in
    CRYPT_PRIVATE_KEY_INFO  *pPrivateKeyInfo,   // out
    DWORD                   *pcbPrivateKeyInfo  // in, out	
    );

static BOOL WINAPI ImportRSAPrivateKeyInfo(
    HCRYPTPROV                  hCryptProv,			// in
    CRYPT_PRIVATE_KEY_INFO      *pPrivateKeyInfo,	// in
    DWORD                       dwFlags,			// in, optional
    void                        *pvAuxInfo			// in, optional
    );

static BOOL WINAPI ExportDSSPrivateKeyInfo(
    HCRYPTPROV              hCryptProv,         // in
    DWORD                   dwKeySpec,          // in
    LPSTR                   pszPrivateKeyObjId, // in
    DWORD                   dwFlags,            // in
    void                    *pvAuxInfo,         // in
    CRYPT_PRIVATE_KEY_INFO  *pPrivateKeyInfo,   // out
    DWORD                   *pcbPrivateKeyInfo  // in, out	
    );

static BOOL WINAPI ImportDSSPrivateKeyInfo(
    HCRYPTPROV                  hCryptProv,			// in
    CRYPT_PRIVATE_KEY_INFO      *pPrivateKeyInfo,	// in
    DWORD                       dwFlags,			// in, optional
    void                        *pvAuxInfo			// in, optional
    );


static HCRYPTOIDFUNCSET hExportPrivKeyFuncSet;
static HCRYPTOIDFUNCSET hImportPrivKeyFuncSet;

// Internal default OIDs
#define DEFAULT_CSP_PRIVKEY1     ((LPCSTR) 1)
#define DEFAULT_CSP_PRIVKEY2     ((LPCSTR) 2)

static const CRYPT_OID_FUNC_ENTRY ExportPrivKeyFuncTable[] = {
    DEFAULT_CSP_PRIVKEY1, ExportRSAPrivateKeyInfo,
    szOID_RSA_RSA, ExportRSAPrivateKeyInfo,
    szOID_OIWSEC_dsa, ExportDSSPrivateKeyInfo,
    szOID_X957_DSA, ExportDSSPrivateKeyInfo
};
#define EXPORT_PRIV_KEY_FUNC_COUNT (sizeof(ExportPrivKeyFuncTable) / \
                                    sizeof(ExportPrivKeyFuncTable[0]))

static const CRYPT_OID_FUNC_ENTRY ImportPrivKeyFuncTable[] = {
    szOID_RSA_RSA, ImportRSAPrivateKeyInfo,
    szOID_OIWSEC_dsa, ImportDSSPrivateKeyInfo,
    szOID_X957_DSA, ImportDSSPrivateKeyInfo
};
#define IMPORT_PRIV_KEY_FUNC_COUNT (sizeof(ImportPrivKeyFuncTable) / \
                                    sizeof(ImportPrivKeyFuncTable[0]))


BOOL   
WINAPI   
ImportExportDllMain(
        HMODULE hInst, 
        ULONG ul_reason_for_call,
        LPVOID lpReserved)
{
    switch( ul_reason_for_call ) 
    {
    case DLL_PROCESS_ATTACH:
 
        // Private key function setup
		if (NULL == (hExportPrivKeyFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_EXPORT_PRIVATE_KEY_INFO_FUNC,
                0)))
            goto ErrorReturn;
        if (NULL == (hImportPrivKeyFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_IMPORT_PRIVATE_KEY_INFO_FUNC,
                0)))
            goto ErrorReturn;

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_EXPORT_PRIVATE_KEY_INFO_FUNC,
                EXPORT_PRIV_KEY_FUNC_COUNT,
                ExportPrivKeyFuncTable,
                0))                         // dwFlags
            goto ErrorReturn;
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_IMPORT_PRIVATE_KEY_INFO_FUNC,
                IMPORT_PRIV_KEY_FUNC_COUNT,
                ImportPrivKeyFuncTable,
                0))                         // dwFlags
            goto ErrorReturn;
        break;
        
    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }


    return TRUE;

ErrorReturn:
    return FALSE;
}


//+-------------------------------------------------------------------------
// phCryptProv - a pointer to a HCRYPTPROV to put the handle of the provider
//				 that received the imported keyset.  if this is NON_NULL then
//				 the caller is responsible for calling CryptReleaseContext().
// pdwKeySpec - a pointer to a DWORD to receive the KeySpec of imported keyset
// privateKeyAndParams - private key blob and corresponding parameters
// dwFlags - The available flags are:
//				CRYPT_EXPORTABLE 
//				this flag is used when importing private keys, for a full 
//				explanation please see the documentation for CryptImportKey.
// phCryptProv - filled in with the handle of the provider the key was
//				 imported to, the caller is responsible for freeing it
// pvAuxInfo - This parameter is reserved for future use and should be set 
//			   to NULL in the interim.
//+-------------------------------------------------------------------------
BOOL 
WINAPI 
CryptImportPKCS8(
    CRYPT_PKCS8_IMPORT_PARAMS           sPrivateKeyAndParams,    // in
    DWORD                               dwFlags,                // in, optional
    HCRYPTPROV                          *phCryptProv,           // out
    void                                *pvAuxInfo              // in, optional
)
{
    BOOL                        fResult = TRUE;
    void                        *pvFuncAddr;
    HCRYPTOIDFUNCADDR           hFuncAddr;

    CRYPT_PRIVATE_KEY_INFO              *pPrivateKeyInfoStruct = NULL;	
    DWORD                               cbPrivateKeyInfoStruct = 0;
    CRYPT_ENCRYPTED_PRIVATE_KEY_INFO	*pEncryptedPrivateKeyInfoStruct = NULL;	
    DWORD                               cbEncryptedPrivateKeyInfoStruct = 0;
    BYTE                                *pbEncodedPrivateKey = sPrivateKeyAndParams.PrivateKey.pbData;
    DWORD                               cbEncodedPrivateKey = sPrivateKeyAndParams.PrivateKey.cbData;
    BOOL                                bEncodedPrivateKeyAlloced = FALSE;
    HCRYPTPROV                          hCryptProv = NULL;

	// try to decode private key blob as a CRYPT_PRIVATE_KEY_INFO structure
	if (!CryptDecodeObject(X509_ASN_ENCODING,
						PKCS_PRIVATE_KEY_INFO,
						sPrivateKeyAndParams.PrivateKey.pbData,
						sPrivateKeyAndParams.PrivateKey.cbData,
						CRYPT_DECODE_NOCOPY_FLAG,
						NULL,
						&cbPrivateKeyInfoStruct)) {	
		
		// that decode failed, so try to decode as CRYPT_ENCRYPTED_PRIVATE_KEY_INFO structure
		if (!CryptDecodeObject(X509_ASN_ENCODING,
					PKCS_ENCRYPTED_PRIVATE_KEY_INFO,
					sPrivateKeyAndParams.PrivateKey.pbData,
					sPrivateKeyAndParams.PrivateKey.cbData,
					CRYPT_DECODE_NOCOPY_FLAG,
					NULL,
					&cbEncryptedPrivateKeyInfoStruct))
			goto ErrorReturn;	

		if (NULL == (pEncryptedPrivateKeyInfoStruct = (CRYPT_ENCRYPTED_PRIVATE_KEY_INFO *)
					 SSAlloc(cbEncryptedPrivateKeyInfoStruct)))
			goto ErrorReturn;

		if (!CryptDecodeObject(X509_ASN_ENCODING,
					PKCS_ENCRYPTED_PRIVATE_KEY_INFO,
					sPrivateKeyAndParams.PrivateKey.pbData,
					sPrivateKeyAndParams.PrivateKey.cbData,
					CRYPT_DECODE_NOCOPY_FLAG,
					pEncryptedPrivateKeyInfoStruct,
					&cbEncryptedPrivateKeyInfoStruct))
			goto ErrorReturn;
		
		// call back the callee to decrypt the private key info
		pbEncodedPrivateKey = NULL;
		cbEncodedPrivateKey = 0;
		if (!sPrivateKeyAndParams.pDecryptPrivateKeyFunc(
							pEncryptedPrivateKeyInfoStruct->EncryptionAlgorithm,
							pEncryptedPrivateKeyInfoStruct->EncryptedPrivateKey,
							NULL,
							&cbEncodedPrivateKey,
							sPrivateKeyAndParams.pVoidDecryptFunc))
			goto ErrorReturn;

		if (NULL == (pbEncodedPrivateKey = (BYTE *) 
					 SSAlloc(cbEncodedPrivateKey)))
			goto ErrorReturn;

		bEncodedPrivateKeyAlloced = TRUE;
		if (!sPrivateKeyAndParams.pDecryptPrivateKeyFunc(
							pEncryptedPrivateKeyInfoStruct->EncryptionAlgorithm,
							pEncryptedPrivateKeyInfoStruct->EncryptedPrivateKey,
							pbEncodedPrivateKey,
							&cbEncodedPrivateKey,
							sPrivateKeyAndParams.pVoidDecryptFunc))
			goto ErrorReturn;
		
		// we are now back to square one with an encoded CRYPT_PRIVATE_KEY_INFO struct,
		// so get the size of that when it's decoded
		if (!CryptDecodeObject(X509_ASN_ENCODING,
					PKCS_PRIVATE_KEY_INFO,
					pbEncodedPrivateKey,
					cbEncodedPrivateKey,
					CRYPT_DECODE_NOCOPY_FLAG,
					NULL,
					&cbPrivateKeyInfoStruct))
			goto ErrorReturn;
	}

	if (NULL == (pPrivateKeyInfoStruct = (CRYPT_PRIVATE_KEY_INFO *)
				 SSAlloc(cbPrivateKeyInfoStruct)))
		goto ErrorReturn;

	if (!CryptDecodeObject(X509_ASN_ENCODING,
					PKCS_PRIVATE_KEY_INFO,
					pbEncodedPrivateKey,
					cbEncodedPrivateKey,
					CRYPT_DECODE_NOCOPY_FLAG,
					pPrivateKeyInfoStruct,
					&cbPrivateKeyInfoStruct))
		goto ErrorReturn;

	// call the caller back to get the provider to import to, if the
	// call back is null then just use the default provider.
	if (sPrivateKeyAndParams.pResolvehCryptProvFunc != NULL) {
		if (!sPrivateKeyAndParams.pResolvehCryptProvFunc(
				pPrivateKeyInfoStruct,
				&hCryptProv,
				sPrivateKeyAndParams.pVoidResolveFunc)) {
			goto ErrorReturn;
		}
	}
	else {
		if (!CryptAcquireContext(
				&hCryptProv,
				NULL,
				NULL,
				PROV_RSA_FULL,
				CRYPT_NEWKEYSET)) {
			goto ErrorReturn;
		}
	}
	
	// resolve what supporting import function to call based on the algorithm 
	// OID of the private key
	if (CryptGetOIDFunctionAddress(
				hImportPrivKeyFuncSet,
				X509_ASN_ENCODING,
				pPrivateKeyInfoStruct->Algorithm.pszObjId,
				0,                      // dwFlags
				&pvFuncAddr,
				&hFuncAddr)) {
		fResult = ((PFN_IMPORT_PRIV_KEY_FUNC) pvFuncAddr)(
				hCryptProv,
				pPrivateKeyInfoStruct,  
				dwFlags,
				pvAuxInfo
				);
		CryptFreeOIDFunctionAddress(hFuncAddr, 0);
	} 
	else {
		SetLastError(ERROR_UNSUPPORTED_TYPE);
        goto ErrorReturn;
	}

	// check to see if the caller wants the hCryptProv
	if (phCryptProv) {
		*phCryptProv = hCryptProv;
	}
	else {
        HRESULT hr = GetLastError();
		CryptReleaseContext(hCryptProv, 0);	
        SetLastError(hr);
	}

	goto CommonReturn;

		
ErrorReturn:
	fResult = FALSE;
	if (hCryptProv)
    {
		HRESULT hr = GetLastError();
        CryptReleaseContext(hCryptProv, 0);	
        SetLastError(hr);
    }

CommonReturn:
	if (pPrivateKeyInfoStruct)
		SSFree(pPrivateKeyInfoStruct);
	if (pEncryptedPrivateKeyInfoStruct)
		SSFree(pEncryptedPrivateKeyInfoStruct);
	if (bEncodedPrivateKeyAlloced)
		SSFree(pbEncodedPrivateKey);
	return fResult;
	
}



////////
// old crusty API kept around for compat reasons
BOOL 
WINAPI 
CryptExportPKCS8(
    HCRYPTPROV  hCryptProv,         // in
    DWORD       dwKeySpec,          // in
    LPSTR       pszPrivateKeyObjId, // in
    DWORD       dwFlags,            // in
    void        *pvAuxInfo,         // in
    BYTE        *pbPrivateKeyBlob,  // out
    DWORD       *pcbPrivateKeyBlob  // in, out
    )
{
    CRYPT_PKCS8_EXPORT_PARAMS sExportParams;
    ZeroMemory(&sExportParams, sizeof(sExportParams));

    // copy args to pkcs8_export struct
    sExportParams.hCryptProv = hCryptProv;
    sExportParams.dwKeySpec = dwKeySpec;
    sExportParams.pszPrivateKeyObjId = pszPrivateKeyObjId;

    // these are not available to non-Ex function
    sExportParams.pEncryptPrivateKeyFunc = NULL;
    sExportParams.pVoidEncryptFunc = NULL;

    return CryptExportPKCS8Ex(
        &sExportParams,
        dwFlags,
        pvAuxInfo,
        pbPrivateKeyBlob,
        pcbPrivateKeyBlob);
}

//+-------------------------------------------------------------------------
// hCryptProv - specifies the provider to export from
// dwKeySpec - Identifies the public key to use from the provider's container. 
//             For example, AT_KEYEXCHANGE or AT_SIGNATURE.
// pszPrivateKeyObjId - Specifies the private key algorithm. If an installable 
//						function was not found for the pszPrivateKeyObjId, an 
//						attempt is made to export the key as a RSA Public Key 
//						(szOID_RSA_RSA).
// dwFlags - The flag values. Current supported values are:
//				DELETE_KEYSET - (NOT CURRENTLY SUPPORTED!!!!)
//				will delete key after export
// pvAuxInfo - This parameter is reserved for future use and should be set to 
//			   NULL in the interim.
// pbPrivateKeyBlob - A pointer to the private key blob.  It will be encoded
//					  as a PKCS8 PrivateKeyInfo.
// pcbPrivateKeyBlob - A pointer to a DWORD that contains the size, in bytes, 
//					   of the private key blob being exported.
//+-------------------------------------------------------------------------
BOOL 
WINAPI 
CryptExportPKCS8Ex(
    CRYPT_PKCS8_EXPORT_PARAMS* psExportParams, // in
    DWORD       dwFlags,            // in
    void        *pvAuxInfo,         // in
    BYTE        *pbPrivateKeyBlob,  // out
    DWORD       *pcbPrivateKeyBlob  // in, out	
)
{
    BOOL                    fResult = TRUE;
    void                    *pvFuncAddr;
    HCRYPTOIDFUNCADDR       hFuncAddr;
    CRYPT_PRIVATE_KEY_INFO	*pPrivateKeyInfo = NULL;
    DWORD                   cbPrivateKeyInfo = 0;
    DWORD                   cbEncoded = 0;

    // optional; used during encrypted export 
    PBYTE                   pbTmpKeyBlob = NULL;
    CRYPT_ENCRYPTED_PRIVATE_KEY_INFO sEncryptedKeyInfo; ZeroMemory(&sEncryptedKeyInfo, sizeof(sEncryptedKeyInfo));
	
    if (CryptGetOIDFunctionAddress(
            hExportPrivKeyFuncSet,
            X509_ASN_ENCODING,
            psExportParams->pszPrivateKeyObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        
		if (!((PFN_EXPORT_PRIV_KEY_FUNC) pvFuncAddr)(
				psExportParams->hCryptProv,
				psExportParams->dwKeySpec,
				psExportParams->pszPrivateKeyObjId, 

				dwFlags & ~GIVE_ME_DATA,    // sizeit
				pvAuxInfo,
				NULL,
				&cbPrivateKeyInfo
				))
			goto ErrorReturn;

		if (NULL == (pPrivateKeyInfo = (CRYPT_PRIVATE_KEY_INFO *) 
                        SSAlloc(cbPrivateKeyInfo)))
			goto ErrorReturn;

		if (!((PFN_EXPORT_PRIV_KEY_FUNC) pvFuncAddr)(

				psExportParams->hCryptProv,
				psExportParams->dwKeySpec,
				psExportParams->pszPrivateKeyObjId,

				dwFlags,        // maybe real data...
				pvAuxInfo,
				pPrivateKeyInfo,
				&cbPrivateKeyInfo
				))
			goto ErrorReturn;

        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } 
	else {	// if (CryptGetOIDFunctionAddress())
        SetLastError(ERROR_UNSUPPORTED_TYPE);
        return FALSE;
    }
	
	// encode the private key info struct 
	if (!CryptEncodeObject(
			X509_ASN_ENCODING,
			PKCS_PRIVATE_KEY_INFO,
			pPrivateKeyInfo,
			NULL,
			&cbEncoded))
		goto ErrorReturn;

    if (NULL == psExportParams->pEncryptPrivateKeyFunc) 
    {
        // no encryption; this is output buffer

        // check to see if the caller specified a buffer and has enough space
	    if ((pbPrivateKeyBlob != NULL) && (*pcbPrivateKeyBlob >= cbEncoded)) {
		    if (!CryptEncodeObject(
				    X509_ASN_ENCODING,
				    PKCS_PRIVATE_KEY_INFO,
				    pPrivateKeyInfo,
				    pbPrivateKeyBlob,
				    pcbPrivateKeyBlob))
			    goto ErrorReturn;
	    }
	    else {
		    *pcbPrivateKeyBlob = cbEncoded;
		    
		    if (pbPrivateKeyBlob != NULL) {
			    SetLastError((DWORD) ERROR_MORE_DATA);
			    goto ErrorReturn;
		    }	
	    }
    }
    else
    {
        // we do want to encrypt!!

        // always encode: use tmp alloc
        pbTmpKeyBlob = (PBYTE)SSAlloc(cbEncoded);
        if (pbTmpKeyBlob == NULL)
            goto ErrorReturn;
        DWORD cbTmpKeyBlob = cbEncoded;

        // NOW add optional encryption and encode as ENCR_PRIV_KEY_INFO
        CRYPT_DATA_BLOB sClearTextKey = { cbTmpKeyBlob, pbTmpKeyBlob};

        // do inner encode
		if (!CryptEncodeObject(
				X509_ASN_ENCODING,
				PKCS_PRIVATE_KEY_INFO,
				pPrivateKeyInfo,
				pbTmpKeyBlob,
				&cbTmpKeyBlob))
			goto ErrorReturn;

        // exported the key; encoded as PRIVATE_KEY_INFO.
        if (!psExportParams->pEncryptPrivateKeyFunc(
                            &sEncryptedKeyInfo.EncryptionAlgorithm,     // out
                            &sClearTextKey,                             // in
                            NULL,                                       // opt
                            &sEncryptedKeyInfo.EncryptedPrivateKey.cbData,  // out
                            psExportParams->pVoidEncryptFunc))          
            goto ErrorReturn;

		if (NULL == (sEncryptedKeyInfo.EncryptedPrivateKey.pbData = (BYTE*) SSAlloc(sEncryptedKeyInfo.EncryptedPrivateKey.cbData)))
			goto ErrorReturn;

        if (dwFlags & GIVE_ME_DATA)
        {
            if (!psExportParams->pEncryptPrivateKeyFunc(
                                &sEncryptedKeyInfo.EncryptionAlgorithm,         // out
                                &sClearTextKey,                                 // in
                                sEncryptedKeyInfo.EncryptedPrivateKey.pbData,   // opt
                                &sEncryptedKeyInfo.EncryptedPrivateKey.cbData,  // out
                                psExportParams->pVoidEncryptFunc))
                goto ErrorReturn;
        }
        else
        {
            // fill in phony encr key
            FillMemory(sEncryptedKeyInfo.EncryptedPrivateKey.pbData, sEncryptedKeyInfo.EncryptedPrivateKey.cbData, 0x69);
        }

        // item is now encrypted; now encode

	    // encode the private key info struct 
	    if (!CryptEncodeObject(
			    X509_ASN_ENCODING,
			    PKCS_ENCRYPTED_PRIVATE_KEY_INFO,
			    &sEncryptedKeyInfo,
			    NULL,
			    &cbEncoded))
		    goto ErrorReturn;


        // check to see if the caller specified a buffer and has enough space
	    if ((pbPrivateKeyBlob != NULL) && (*pcbPrivateKeyBlob >= cbEncoded)) {
		    if (!CryptEncodeObject(
				    X509_ASN_ENCODING,
				    PKCS_ENCRYPTED_PRIVATE_KEY_INFO,
				    &sEncryptedKeyInfo,
				    pbPrivateKeyBlob,
				    pcbPrivateKeyBlob))
			    goto ErrorReturn;
	    }
	    else {
		    *pcbPrivateKeyBlob = cbEncoded;
		    
		    if (pbPrivateKeyBlob != NULL) {
			    SetLastError((DWORD) ERROR_MORE_DATA);
			    goto ErrorReturn;
		    }	
	    }
    }

    goto CommonReturn;

ErrorReturn:
	fResult = FALSE;

CommonReturn:
	if (pPrivateKeyInfo)
		SSFree(pPrivateKeyInfo);

    if (pbTmpKeyBlob)
        SSFree(pbTmpKeyBlob);

    if (sEncryptedKeyInfo.EncryptedPrivateKey.pbData)
        SSFree(sEncryptedKeyInfo.EncryptedPrivateKey.pbData);

    if (sEncryptedKeyInfo.EncryptionAlgorithm.Parameters.pbData)
        SSFree(sEncryptedKeyInfo.EncryptionAlgorithm.Parameters.pbData);

	return fResult;	
}

static LONG counter = 0;

// hack function to create a mock RSA private key blob based only on size
BYTE * AllocFakeRSAPrivateKey(DWORD cb)
{
    BLOBHEADER  *pBlobHeader;
    RSAPUBKEY   *pKey;
    BYTE        *pByte;
    DWORD       dwJumpSize;

    pBlobHeader = (BLOBHEADER *) SSAlloc(cb);
    if (pBlobHeader == NULL)
        return NULL;

    memset(pBlobHeader, 0, cb);

    pBlobHeader->bType = PRIVATEKEYBLOB;
    pBlobHeader->bVersion = CUR_BLOB_VERSION;
    pBlobHeader->reserved = 0;
    pBlobHeader->aiKeyAlg = CALG_RSA_SIGN;

    pKey = (RSAPUBKEY *) (((BYTE*) pBlobHeader) + sizeof(BLOBHEADER));
    pKey->magic = 0x32415352;
    pKey->bitlen = ((cb - sizeof(BLOBHEADER) - sizeof(RSAPUBKEY)) / 9) * 2 * 8;
    pKey->pubexp = 65537;

    dwJumpSize = (cb - sizeof(BLOBHEADER) - sizeof(RSAPUBKEY)) / 9;
    pByte = ((BYTE *) pBlobHeader) + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY);
    
    // put some bogus data at the start of the key so 
	// that we know will be unique for each key so that 
	// they look different durring a comparison
	InterlockedIncrement(&counter);
	*((LONG *) pByte) = counter;

    // most significant byte of modulus
    pByte += (dwJumpSize * 2) - 1;
    *pByte = 0x80;

    // most significant byte of prime1
    pByte += dwJumpSize;
    *pByte = 0x80;

    // most significant byte of prime2
    pByte += dwJumpSize;
    *pByte = 0x80;

    // most significant byte of exponent1
    pByte += dwJumpSize;
    *pByte = 0x80;

    // most significant byte of exponent2
    pByte += dwJumpSize;
    *pByte = 0x80;

    // most significant byte of coefficient
    pByte += dwJumpSize;
    *pByte = 0x80;

    // most significant byte of privateExponent
    pByte += dwJumpSize * 2;
    *pByte = 0x80;

    return ((BYTE *)pBlobHeader);
}

static BOOL WINAPI ExportRSAPrivateKeyInfo(
	HCRYPTPROV				hCryptProv,			// in
	DWORD					dwKeySpec,			// in
	LPSTR					pszPrivateKeyObjId,	// in
	DWORD					dwFlags,			// in
    void					*pvAuxInfo,			// in
    CRYPT_PRIVATE_KEY_INFO	*pPrivateKeyInfo,	// out
    DWORD					*pcbPrivateKeyInfo	// in, out	
	)
{
	BOOL			fResult = TRUE;
	HCRYPTKEY		hCryptKey = NULL;
	BYTE			*pKeyBlob = NULL;
	DWORD			cbKeyBlob = 0;
	BYTE			*pEncodedKeyBlob = NULL;
	DWORD			cbEncodedKeyBlob = 0;
	BYTE			*pKeyUsage = NULL;
	DWORD			cbKeyUsage = 0;
	DWORD			dwSize = 0;
	CRYPT_BIT_BLOB	CryptBitBlob;
	BYTE			KeyUsageByte = 0;
	BYTE			*pbCurrentLocation = NULL;

	// get a handle to the keyset to export
	if (!CryptGetUserKey(
			hCryptProv,
			dwKeySpec,
			&hCryptKey))
		goto ErrorReturn;

	// export the key set to a CAPI blob
	if (!CryptExportKey(
			hCryptKey,
			0,
			PRIVATEKEYBLOB,
			0,
			NULL,
			&cbKeyBlob)) 
		goto ErrorReturn;

	// make sure the caller REALLY wants the key at this point
    if ((dwFlags & PFX_MODE) && !(dwFlags & GIVE_ME_DATA))
    {
        if (NULL == (pKeyBlob = AllocFakeRSAPrivateKey(cbKeyBlob)))
		    goto ErrorReturn;
    }
    // if not in PFX export mode or we really want the key then just do normal processing
    else
    {
        if (NULL == (pKeyBlob = (BYTE *) SSAlloc(cbKeyBlob)))
		    goto ErrorReturn;
	    
	    if (!CryptExportKey(
			    hCryptKey,
			    0,
			    PRIVATEKEYBLOB,
			    0,
			    pKeyBlob,
			    &cbKeyBlob))
		    goto ErrorReturn;
    }

	// encode the key blob to a RSA private key
	if (!CryptEncodeObject(
			X509_ASN_ENCODING,
			PKCS_RSA_PRIVATE_KEY,
			pKeyBlob,
			NULL,
			&cbEncodedKeyBlob))
		goto ErrorReturn;

	if (NULL == (pEncodedKeyBlob = (BYTE *) SSAlloc(cbEncodedKeyBlob)))
		goto ErrorReturn;
		
	if (!CryptEncodeObject(
			X509_ASN_ENCODING,
			PKCS_RSA_PRIVATE_KEY,
			pKeyBlob,
			pEncodedKeyBlob,
			&cbEncodedKeyBlob))
		goto ErrorReturn;
	
	// encode the KEY_USAGE attribute
	CryptBitBlob.cbData = 1;
	CryptBitBlob.pbData = &KeyUsageByte;
	CryptBitBlob.cUnusedBits = 0;
	if (((BLOBHEADER *) pKeyBlob)->aiKeyAlg == CALG_RSA_SIGN) 
		KeyUsageByte = CERT_DIGITAL_SIGNATURE_KEY_USAGE; 
	else if (((BLOBHEADER *) pKeyBlob)->aiKeyAlg == CALG_RSA_KEYX) 
		KeyUsageByte = CERT_DATA_ENCIPHERMENT_KEY_USAGE;
	else {
		goto ErrorReturn;
	}

	if (!CryptEncodeObject(
			X509_ASN_ENCODING,
			X509_BITS,
			(void *) &CryptBitBlob,
			NULL,
			&cbKeyUsage))
		goto ErrorReturn;

	if (NULL == (pKeyUsage = (BYTE *) SSAlloc(cbKeyUsage)))
		goto ErrorReturn;

	if (!CryptEncodeObject(
			X509_ASN_ENCODING,
			X509_BITS,
			(void *) &CryptBitBlob,
			pKeyUsage,
			&cbKeyUsage))
		goto ErrorReturn;

	// we can now calculate the size needed
	dwSize =	sizeof(CRYPT_PRIVATE_KEY_INFO) +	// main private key info struct
 INFO_LEN_ALIGN(sizeof(szOID_RSA_RSA)) +	        // size of the RSA algorithm identifier string
 INFO_LEN_ALIGN(cbEncodedKeyBlob) +			        // buffer that holds encoded RSA private key
				sizeof(CRYPT_ATTRIBUTES) +	        // struct for private key attributes
				sizeof(CRYPT_ATTRIBUTE) +	        // struct for the one attribute being set, KEY_USAGE
 INFO_LEN_ALIGN(sizeof(szOID_KEY_USAGE)) +	        // size of attribute OID for key usage
				sizeof(CRYPT_ATTR_BLOB)	+	        // struct for values in attribute
				cbKeyUsage;					        // size of buffer for encoded attribute

	// check to see if the caller passed in a buffer, and enough space
	if (pPrivateKeyInfo == NULL)
		goto CommonReturn;
	else if (*pcbPrivateKeyInfo < dwSize) {
		SetLastError((DWORD) ERROR_MORE_DATA);
		goto ErrorReturn;
	}

	// everything is OK so copy all the information to the caller's buffer
	pbCurrentLocation = ((BYTE *) pPrivateKeyInfo) + sizeof(CRYPT_PRIVATE_KEY_INFO);
	
	pPrivateKeyInfo->Version = 0;
	
	pPrivateKeyInfo->Algorithm.pszObjId = (LPSTR) pbCurrentLocation;
	memcpy(pbCurrentLocation, szOID_RSA_RSA, sizeof(szOID_RSA_RSA));
	pbCurrentLocation += INFO_LEN_ALIGN(sizeof(szOID_RSA_RSA));
	pPrivateKeyInfo->Algorithm.Parameters.cbData = 0;	// no parameters for RSA
	pPrivateKeyInfo->Algorithm.Parameters.pbData = NULL;// no parameters for RSA

	pPrivateKeyInfo->PrivateKey.cbData = cbEncodedKeyBlob;
	pPrivateKeyInfo->PrivateKey.pbData = pbCurrentLocation;
	memcpy(pbCurrentLocation, pEncodedKeyBlob, cbEncodedKeyBlob);
	pbCurrentLocation += INFO_LEN_ALIGN(cbEncodedKeyBlob);

	pPrivateKeyInfo->pAttributes = (PCRYPT_ATTRIBUTES) pbCurrentLocation;
	pbCurrentLocation += sizeof(CRYPT_ATTRIBUTES);
	pPrivateKeyInfo->pAttributes->cAttr = 1;	// the only attribute right now is KEY_USAGE
	pPrivateKeyInfo->pAttributes->rgAttr = (PCRYPT_ATTRIBUTE) pbCurrentLocation;
	pbCurrentLocation += sizeof(CRYPT_ATTRIBUTE);
	pPrivateKeyInfo->pAttributes->rgAttr[0].pszObjId = (LPSTR) pbCurrentLocation;
	memcpy(pbCurrentLocation, szOID_KEY_USAGE, sizeof(szOID_KEY_USAGE));
	pbCurrentLocation += INFO_LEN_ALIGN(sizeof(szOID_KEY_USAGE));
	pPrivateKeyInfo->pAttributes->rgAttr[0].cValue = 1; 
	pPrivateKeyInfo->pAttributes->rgAttr[0].rgValue = (PCRYPT_ATTR_BLOB) pbCurrentLocation;
	pbCurrentLocation += sizeof(CRYPT_ATTR_BLOB);
	pPrivateKeyInfo->pAttributes->rgAttr[0].rgValue[0].cbData = cbKeyUsage;
	pPrivateKeyInfo->pAttributes->rgAttr[0].rgValue[0].pbData = pbCurrentLocation;
	memcpy(pbCurrentLocation, pKeyUsage, cbKeyUsage);
	
	goto CommonReturn;

ErrorReturn:
	fResult = FALSE;

CommonReturn:
	*pcbPrivateKeyInfo = dwSize;

    if (hCryptKey)
    {
        DWORD dwErr = GetLastError();
        CryptDestroyKey(hCryptKey);
        SetLastError(dwErr);
    }
	if (pKeyBlob)
		SSFree(pKeyBlob);
	if (pEncodedKeyBlob)
		SSFree(pEncodedKeyBlob);
	if (pKeyUsage)
		SSFree(pKeyUsage);
	return fResult;
}


static DWORD ResolveKeySpec(
	PCRYPT_ATTRIBUTES   pCryptAttributes)
{
	DWORD			i = 0;
	DWORD			dwKeySpec = 0;
	DWORD			cbAttribute = 0;
	CRYPT_BIT_BLOB	*pAttribute = NULL;

	if (pCryptAttributes != NULL)
		while (i < pCryptAttributes->cAttr) {
			if (lstrcmp(pCryptAttributes->rgAttr[i].pszObjId, szOID_KEY_USAGE) == 0) { 
				
				if (!CryptDecodeObject(
						X509_ASN_ENCODING,
						X509_BITS,
						pCryptAttributes->rgAttr[i].rgValue->pbData,
						pCryptAttributes->rgAttr[i].rgValue->cbData,
						0,
						NULL,
						&cbAttribute
						)) {
					i++;
					continue;
				}
				
				if (NULL == (pAttribute = (CRYPT_BIT_BLOB *) SSAlloc(cbAttribute))) 
                {
					i++;
					continue;
				}
			
				if (!CryptDecodeObject(
						X509_ASN_ENCODING,
						X509_BITS,
						pCryptAttributes->rgAttr[i].rgValue->pbData,
						pCryptAttributes->rgAttr[i].rgValue->cbData,
						0,
						pAttribute,
						&cbAttribute
						)) {
					i++;
					SSFree(pAttribute);
					continue;
				}
									
				if ((pAttribute->pbData[0] & CERT_KEY_ENCIPHERMENT_KEY_USAGE) ||
					(pAttribute->pbData[0] & CERT_DATA_ENCIPHERMENT_KEY_USAGE)) {
					dwKeySpec = AT_KEYEXCHANGE;
					goto CommonReturn;
				}
				else if ((pAttribute->pbData[0] & CERT_DIGITAL_SIGNATURE_KEY_USAGE) ||
						(pAttribute->pbData[0] & CERT_KEY_CERT_SIGN_KEY_USAGE) ||
						(pAttribute->pbData[0] & CERT_CRL_SIGN_KEY_USAGE)) {
					dwKeySpec = AT_SIGNATURE;
					goto CommonReturn;
				}
			} // if (lstrcmp(pCryptAttributes->rgAttr[i].pszObjId, szOID_KEY_USAGE) == 0) 
			
			i++;
		} // while (i < pCryptAttributes->cAttr)

//ErrorReturn:
CommonReturn:
	if (pAttribute)
		SSFree(pAttribute);
	return dwKeySpec;
}


static BOOL WINAPI ImportRSAPrivateKeyInfo(
	HCRYPTPROV					hCryptProv,			// in
	CRYPT_PRIVATE_KEY_INFO		*pPrivateKeyInfo,	// in
	DWORD						dwFlags,			// in, optional
	void						*pvAuxInfo			// in, optional
	)
{
	BOOL		fResult = TRUE;
	DWORD		cbRSAPrivateKey = 0;
	BYTE		*pbRSAPrivateKey = NULL;
	HCRYPTKEY	hCryptKey = NULL;
	DWORD		dwKeySpec = 0;

	// decode the rsa der-encoded keyblob into a CAPI type keyblob
	if (!CryptDecodeObject(X509_ASN_ENCODING,
						PKCS_RSA_PRIVATE_KEY,
						pPrivateKeyInfo->PrivateKey.pbData,
						pPrivateKeyInfo->PrivateKey.cbData,
						CRYPT_DECODE_NOCOPY_FLAG,
						NULL,
						&cbRSAPrivateKey))
		goto ErrorReturn;

	if (NULL == (pbRSAPrivateKey = (BYTE *) SSAlloc(cbRSAPrivateKey)))
		goto ErrorReturn;

	if (!CryptDecodeObject(X509_ASN_ENCODING,
						PKCS_RSA_PRIVATE_KEY,
						pPrivateKeyInfo->PrivateKey.pbData,
						pPrivateKeyInfo->PrivateKey.cbData,
						CRYPT_DECODE_NOCOPY_FLAG,
						pbRSAPrivateKey,
						&cbRSAPrivateKey))
		goto ErrorReturn;
	
	// figure out what keyspec to use and manually set the algid in the keyblob accordingly
	dwKeySpec = ResolveKeySpec(pPrivateKeyInfo->pAttributes);
	if ((dwKeySpec == AT_KEYEXCHANGE) || (dwKeySpec == 0)) 
		((BLOBHEADER *) pbRSAPrivateKey)->aiKeyAlg = CALG_RSA_KEYX;
	else
		((BLOBHEADER *) pbRSAPrivateKey)->aiKeyAlg = CALG_RSA_SIGN;

	// import this thing
	if (!CryptImportKey(hCryptProv,
			pbRSAPrivateKey,
			cbRSAPrivateKey,
			0,
			dwFlags & (CRYPT_EXPORTABLE | CRYPT_USER_PROTECTED),    // mask the flags that are used
			&hCryptKey))                                            // during the CryptImportKey
		goto ErrorReturn;

	goto CommonReturn;

ErrorReturn:
	fResult = FALSE;

CommonReturn:
	if (pbRSAPrivateKey)
		SSFree(pbRSAPrivateKey);
	if (hCryptKey)
		CryptDestroyKey(hCryptKey);

	return fResult;

}

#ifndef DSS2
#define DSS2 ((DWORD)'D'+((DWORD)'S'<<8)+((DWORD)'S'<<16)+((DWORD)'2'<<24))
#endif

#ifndef DSS_Q_LEN
#define DSS_Q_LEN   20
#endif


// hack function to create a mock RSA private key blob based only on size
BYTE * AllocFakeDSSPrivateKey(DWORD cb)
{
    BLOBHEADER  *pBlobHeader;
    DSSPUBKEY   *pCspPubKey = NULL;
    BYTE        *pbKeyBlob;
    BYTE        *pbKey;
    DWORD       cbKey;
    DSSSEED     *pCspSeed = NULL;

    pBlobHeader = (BLOBHEADER *) SSAlloc(cb);
    if (pBlobHeader == NULL)
        return NULL;

    memset(pBlobHeader, 0, cb);

    pbKeyBlob = (BYTE *) pBlobHeader;
    pCspPubKey = (DSSPUBKEY *) (pbKeyBlob + sizeof(BLOBHEADER));
    pbKey = pbKeyBlob + sizeof(BLOBHEADER) + sizeof(DSSPUBKEY);

    // BLOBHEADER
    pBlobHeader->bType = PRIVATEKEYBLOB;
    pBlobHeader->bVersion = CUR_BLOB_VERSION;
    pBlobHeader->reserved = 0;
    pBlobHeader->aiKeyAlg = CALG_DSS_SIGN;

    // DSSPUBKEY
    pCspPubKey->magic = DSS2;
    cbKey = (cb - sizeof(BLOBHEADER) - sizeof(DSSPUBKEY) - (2 * DSS_Q_LEN) - sizeof(DSSSEED)) / 2;
    pCspPubKey->bitlen = cbKey * 8;

    // put some bogus data at the start of the key so 
	// that we know will be unique for each key so that 
	// they look different durring a comparison
	InterlockedIncrement(&counter);
	
    // rgbP[cbKey]
    memset(pbKey, counter, cbKey);
    pbKey += cbKey;
    *(pbKey-1) = 0x80;

    // rgbQ[20]
    memset(pbKey, counter, DSS_Q_LEN);
    pbKey += DSS_Q_LEN;
    *(pbKey-1) = 0x80;
   
    // rgbG[cbKey]
    memset(pbKey, counter, cbKey);
    pbKey += cbKey;
    *(pbKey-1) = 0x80;

    // rgbX[20]
    memset(pbKey, counter, DSS_Q_LEN);
    pbKey += DSS_Q_LEN;
    *(pbKey-1) = 0x80;
    
    // DSSSEED: set counter to 0xFFFFFFFF to indicate not available
    pCspSeed = (DSSSEED *) pbKey;
    memset(&pCspSeed->counter, 0xFF, sizeof(pCspSeed->counter));

    return ((BYTE *)pBlobHeader);
}

static BOOL WINAPI ExportDSSPrivateKeyInfo(
	HCRYPTPROV				hCryptProv,			// in
	DWORD					dwKeySpec,			// in
	LPSTR					pszPrivateKeyObjId,	// in
	DWORD					dwFlags,			// in
    void					*pvAuxInfo,			// in
    CRYPT_PRIVATE_KEY_INFO	*pPrivateKeyInfo,	// out
    DWORD					*pcbPrivateKeyInfo	// in, out	
	)
{
    BOOL			    fResult = TRUE;
	HCRYPTKEY		    hCryptKey = NULL;
	BYTE			    *pbKeyBlob = NULL;
	DWORD			    cbKeyBlob = 0;
	BYTE			    *pbEncodedPrivateKeyBlob = NULL;
	DWORD			    cbEncodedPrivateKeyBlob = 0;
    BYTE                *pbEncodedParameters = NULL;
    DWORD               cbEncodedParameters = 0;
    CRYPT_INTEGER_BLOB  PrivateKeyBlob;
    CERT_DSS_PARAMETERS DssParameters;
    DWORD               cbKey;
    DSSPUBKEY           *pCspPubKey = NULL;
    BYTE                *pbBytes;
    DWORD			    dwSize = 0;
    BYTE                *pbCurrentLocation;
	
	// get a handle to the keyset to export
	if (!CryptGetUserKey(
			hCryptProv,
			dwKeySpec,
			&hCryptKey))
		goto ErrorReturn;

	// export the key set to a CAPI blob
	if (!CryptExportKey(
			hCryptKey,
			0,
			PRIVATEKEYBLOB,
			0,
			NULL,
			&cbKeyBlob)) 
		goto ErrorReturn;

	// make sure the caller REALLY wants the key at this point
    if ((dwFlags & PFX_MODE) && !(dwFlags & GIVE_ME_DATA))
    {
        if (NULL == (pbKeyBlob = AllocFakeDSSPrivateKey(cbKeyBlob)))
		    goto ErrorReturn;
    }
    // if not in PFX export mode or we really want the key then just do normal processing
    else
    {
        if (NULL == (pbKeyBlob = (BYTE *) SSAlloc(cbKeyBlob)))
		    goto ErrorReturn;
	    
	    if (!CryptExportKey(
			    hCryptKey,
			    0,
			    PRIVATEKEYBLOB,
			    0,
			    pbKeyBlob,
			    &cbKeyBlob))
		    goto ErrorReturn;
    }

	pCspPubKey = (DSSPUBKEY *) (pbKeyBlob + sizeof(BLOBHEADER));
    pbBytes = pbKeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(DSSPUBKEY);
    cbKey = pCspPubKey->bitlen / 8;

    // encode the DSS paramaters
    memset(&DssParameters, 0, sizeof(CERT_DSS_PARAMETERS));
    DssParameters.p.cbData = cbKey;
    DssParameters.p.pbData = pbBytes;
    pbBytes += cbKey;
    DssParameters.q.cbData = DSS_Q_LEN;
    DssParameters.q.pbData = pbBytes;
    pbBytes += DSS_Q_LEN;
    DssParameters.g.cbData = cbKey;
    DssParameters.g.pbData = pbBytes;
    pbBytes += cbKey;

    if (!CryptEncodeObject(
			X509_ASN_ENCODING,
			X509_DSS_PARAMETERS,
			&DssParameters,
			NULL,
			&cbEncodedParameters))
		goto ErrorReturn;

    if (NULL == (pbEncodedParameters = (BYTE *) SSAlloc(cbEncodedParameters)))
		goto ErrorReturn;

    if (!CryptEncodeObject(
			X509_ASN_ENCODING,
			X509_DSS_PARAMETERS,
			&DssParameters,
			pbEncodedParameters,
			&cbEncodedParameters))
		goto ErrorReturn;

	// encode the key DSS private key
    PrivateKeyBlob.cbData = DSS_Q_LEN;
    PrivateKeyBlob.pbData = pbBytes;

	if (!CryptEncodeObject(
			X509_ASN_ENCODING,
			X509_MULTI_BYTE_INTEGER,
			&PrivateKeyBlob,
			NULL,
			&cbEncodedPrivateKeyBlob))
		goto ErrorReturn;

	if (NULL == (pbEncodedPrivateKeyBlob = (BYTE *) SSAlloc(cbEncodedPrivateKeyBlob)))
		goto ErrorReturn;
		
	if (!CryptEncodeObject(
			X509_ASN_ENCODING,
			X509_MULTI_BYTE_INTEGER,
			&PrivateKeyBlob,
			pbEncodedPrivateKeyBlob,
			&cbEncodedPrivateKeyBlob))
		goto ErrorReturn;
	
    
    
    
	// we can now calculate the size needed
	dwSize =	sizeof(CRYPT_PRIVATE_KEY_INFO) +	// main private key info struct
				sizeof(szOID_X957_DSA) +		    // size of the DSA algorithm identifier string
                cbEncodedParameters +               // size of the DSA parameters
				cbEncodedPrivateKeyBlob;			// buffer that holds encoded DSS private key
				

	// check to see if the caller passed in a buffer, and enough space
	if (pPrivateKeyInfo == NULL)
		goto CommonReturn;
	else if (*pcbPrivateKeyInfo < dwSize) {
		SetLastError((DWORD) ERROR_MORE_DATA);
		goto ErrorReturn;
	}

	// everything is OK so copy all the information to the caller's buffer
	pbCurrentLocation = ((BYTE *) pPrivateKeyInfo) + sizeof(CRYPT_PRIVATE_KEY_INFO);
	
	pPrivateKeyInfo->Version = 0;
	pPrivateKeyInfo->Algorithm.pszObjId = (LPSTR) pbCurrentLocation;
	memcpy(pbCurrentLocation, szOID_X957_DSA, sizeof(szOID_X957_DSA));
	pbCurrentLocation += sizeof(szOID_X957_DSA);
	pPrivateKeyInfo->Algorithm.Parameters.cbData = cbEncodedParameters;	
	pPrivateKeyInfo->Algorithm.Parameters.pbData = pbCurrentLocation;
    memcpy(pbCurrentLocation, pbEncodedParameters, cbEncodedParameters);
    pbCurrentLocation += cbEncodedParameters;

	pPrivateKeyInfo->PrivateKey.cbData = cbEncodedPrivateKeyBlob;
	pPrivateKeyInfo->PrivateKey.pbData = pbCurrentLocation;
	memcpy(pbCurrentLocation, pbEncodedPrivateKeyBlob, cbEncodedPrivateKeyBlob);
	pbCurrentLocation += cbEncodedPrivateKeyBlob;

	pPrivateKeyInfo->pAttributes = NULL;
	
	goto CommonReturn;

ErrorReturn:
	fResult = FALSE;

CommonReturn:
	*pcbPrivateKeyInfo = dwSize;

    if (hCryptKey)
    {
        DWORD dwErr = GetLastError();
        CryptDestroyKey(hCryptKey);
        SetLastError(dwErr);
    }
	if (pbKeyBlob)
		SSFree(pbKeyBlob);
    if (pbEncodedParameters)
		SSFree(pbEncodedParameters);
	if (pbEncodedPrivateKeyBlob)
		SSFree(pbEncodedPrivateKeyBlob);
	

	return fResult;
}

static BOOL WINAPI ImportDSSPrivateKeyInfo(
	HCRYPTPROV					hCryptProv,			// in
	CRYPT_PRIVATE_KEY_INFO		*pPrivateKeyInfo,	// in
	DWORD						dwFlags,			// in, optional
	void						*pvAuxInfo			// in, optional
	)
{
	BOOL		            fResult = TRUE;
	DWORD		            cbDSSPrivateKey = 0;
	CRYPT_DATA_BLOB		    *pbDSSPrivateKey = NULL;
	HCRYPTKEY	            hCryptKey = NULL;
	DWORD		            dwKeySpec = 0;
    DWORD                   cbParameters = 0;
    PCERT_DSS_PARAMETERS    pDssParameters = NULL;
    BLOBHEADER              *pPrivateKeyBlob = NULL;
    DWORD                   cbPrivateKeyStruc = 0;
    DSSPUBKEY               *pCspPubKey = NULL;
    DSSSEED                 *pCspSeed = NULL;
    BYTE                    *pbKey = NULL;
    BYTE                    *pbKeyBlob = NULL;
    DWORD                   cb;
    DWORD                   cbKey;

	// decode the DSS private key
	if (!CryptDecodeObject(X509_ASN_ENCODING,
						X509_MULTI_BYTE_UINT,
						pPrivateKeyInfo->PrivateKey.pbData,
						pPrivateKeyInfo->PrivateKey.cbData,
						CRYPT_DECODE_NOCOPY_FLAG,
						NULL,
						&cbDSSPrivateKey))
		goto ErrorReturn;

	if (NULL == (pbDSSPrivateKey = (CRYPT_DATA_BLOB *) SSAlloc(cbDSSPrivateKey)))
    {
		SetLastError(E_OUTOFMEMORY);
        goto ErrorReturn;
    }

	if (!CryptDecodeObject(X509_ASN_ENCODING,
						X509_MULTI_BYTE_UINT,
						pPrivateKeyInfo->PrivateKey.pbData,
						pPrivateKeyInfo->PrivateKey.cbData,
						CRYPT_DECODE_NOCOPY_FLAG,
						pbDSSPrivateKey,
						&cbDSSPrivateKey))
		goto ErrorReturn;

    
    // decode the DSS parameters
    if (!CryptDecodeObject(
			X509_ASN_ENCODING,
			X509_DSS_PARAMETERS,
			pPrivateKeyInfo->Algorithm.Parameters.pbData,
			pPrivateKeyInfo->Algorithm.Parameters.cbData,
			0,
			NULL,
			&cbParameters
			)) 
        goto ErrorReturn;
	
	if (NULL == (pDssParameters = (PCERT_DSS_PARAMETERS) SSAlloc(cbParameters))) 
    {
        SetLastError(E_OUTOFMEMORY);
        goto ErrorReturn;
    }

	if (!CryptDecodeObject(
			X509_ASN_ENCODING,
			X509_DSS_PARAMETERS,
			pPrivateKeyInfo->Algorithm.Parameters.pbData,
			pPrivateKeyInfo->Algorithm.Parameters.cbData,
			0,
			pDssParameters,
			&cbParameters
			)) 
        goto ErrorReturn;


    // The CAPI private key representation consists of the following sequence:
    //  - BLOBHEADER
    //  - DSSPUBKEY
    //  - rgbP[cbKey]
    //  - rgbQ[20]
    //  - rgbG[cbKey]
    //  - rgbX[20]
    //  - DSSSEED

    cbKey = pDssParameters->p.cbData;
    if (0 == cbKey)
        goto ErrorInvalidKey;

    cbPrivateKeyStruc = sizeof(BLOBHEADER) + sizeof(DSSPUBKEY) +
        cbKey + DSS_Q_LEN + cbKey + DSS_Q_LEN + sizeof(DSSSEED);

    if (NULL == (pPrivateKeyBlob = (BLOBHEADER *) SSAlloc(cbPrivateKeyStruc))) 
    {
        SetLastError(E_OUTOFMEMORY);
        goto ErrorReturn;
    }
	
    pbKeyBlob = (BYTE *) pPrivateKeyBlob;
    pCspPubKey = (DSSPUBKEY *) (pbKeyBlob + sizeof(BLOBHEADER));
    pbKey = pbKeyBlob + sizeof(BLOBHEADER) + sizeof(DSSPUBKEY);

    // NOTE, the length of G can be less than the length of P.
    // The CSP requires G to be padded out with 0x00 bytes if it
    // is less and in little endian form

    // BLOBHEADER
    pPrivateKeyBlob->bType = PRIVATEKEYBLOB;
    pPrivateKeyBlob->bVersion = CUR_BLOB_VERSION;
    pPrivateKeyBlob->reserved = 0;
   	pPrivateKeyBlob->aiKeyAlg = CALG_DSS_SIGN;

    // DSSPUBKEY
    pCspPubKey->magic = DSS2;
    pCspPubKey->bitlen = cbKey * 8;

    // rgbP[cbKey]
    memcpy(pbKey, pDssParameters->p.pbData, cbKey);
    pbKey += cbKey;

    // rgbQ[20]
    cb = pDssParameters->q.cbData;
    if (0 == cb || cb > DSS_Q_LEN)
        goto ErrorInvalidKey;
    memcpy(pbKey, pDssParameters->q.pbData, cb);
    if (DSS_Q_LEN > cb)
        memset(pbKey + cb, 0, DSS_Q_LEN - cb);
    pbKey += DSS_Q_LEN;

    // rgbG[cbKey]
    cb = pDssParameters->g.cbData;
    if (0 == cb || cb > cbKey)
        goto ErrorInvalidKey;
    memcpy(pbKey, pDssParameters->g.pbData, cb);
    if (cbKey > cb)
        memset(pbKey + cb, 0, cbKey - cb);
    pbKey += cbKey;

    // rgbX[20]
    cb = pbDSSPrivateKey->cbData;
    if (0 == cb || cb > DSS_Q_LEN)
        goto ErrorInvalidKey;
    memcpy(pbKey, pbDSSPrivateKey->pbData, cb);
    if (DSS_Q_LEN > cb)
        memset(pbKey + cb, 0, DSS_Q_LEN - cb);
    pbKey += DSS_Q_LEN;

    // DSSSEED: set counter to 0xFFFFFFFF to indicate not available
    pCspSeed = (DSSSEED *) pbKey;
    memset(&pCspSeed->counter, 0xFF, sizeof(pCspSeed->counter));


	// import this thing
	if (!CryptImportKey(hCryptProv,
			(BYTE *)pPrivateKeyBlob,
			cbPrivateKeyStruc,
			0,
			dwFlags & (CRYPT_EXPORTABLE | CRYPT_USER_PROTECTED),    // mask the flags that are used
			&hCryptKey))                                            // during the CryptImportKey
    {
	    DWORD dw = GetLastError();
        goto ErrorReturn;
    }

	goto CommonReturn;

ErrorInvalidKey:
    SetLastError(E_INVALIDARG);

ErrorReturn:
	fResult = FALSE;

CommonReturn:
	if (pbDSSPrivateKey)
		SSFree(pbDSSPrivateKey);
    if (pDssParameters)
		SSFree(pDssParameters);
    if (pPrivateKeyBlob)
        SSFree(pPrivateKeyBlob);
	if (hCryptKey)
		CryptDestroyKey(hCryptKey);

	return fResult;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\pfxlib\pfxcrypt.cpp ===
#include "global.hxx"

// crypto defs
#include <wincrypt.h>
#include "randlib.h"

#include "pfxhelp.h"

#include "pfxcmn.h"
#include "pfxcrypt.h"

#include "sha.h"
#include "shacomm.h"
#include "rc2.h"
#include "modes.h"
#include "des.h"
#include "tripldes.h"

// constants used in PKCS5-like key derivation
#define DERIVE_ENCRYPT_DECRYPT  0x1
#define DERIVE_INITIAL_VECTOR   0x2
#define DERIVE_INTEGRITY_KEY    0x3

#define HMAC_K_PADSIZE              64

BOOL    FMyPrimitiveSHA(
			PBYTE       pbData,
			DWORD       cbData,
            BYTE        rgbHash[A_SHA_DIGEST_LEN])
{
    BOOL fRet = FALSE;
    A_SHA_CTX   sSHAHash;


    A_SHAInit(&sSHAHash);
    A_SHAUpdate(&sSHAHash, (BYTE *) pbData, cbData);
    A_SHAFinal(&sSHAHash, rgbHash);

    fRet = TRUE;
//Ret:

    return fRet;
}

BOOL FMyPrimitiveHMACParam(
        PBYTE       pbKeyMaterial,
        DWORD       cbKeyMaterial,
        PBYTE       pbData,
        DWORD       cbData,
        BYTE        rgbHMAC[A_SHA_DIGEST_LEN])
{
    BOOL fRet = FALSE;

    BYTE rgbKipad[HMAC_K_PADSIZE];
    BYTE rgbKopad[HMAC_K_PADSIZE];

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;


    ZeroMemory(rgbKipad, HMAC_K_PADSIZE);
    CopyMemory(rgbKipad, pbKeyMaterial, cbKeyMaterial);

    ZeroMemory(rgbKopad, HMAC_K_PADSIZE);
    CopyMemory(rgbKopad, pbKeyMaterial, cbKeyMaterial);



    BYTE  rgbHMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];

    // assert we're a multiple
    assert( (HMAC_K_PADSIZE % sizeof(DWORD)) == 0);

    // Kipad, Kopad are padded sMacKey. Now XOR across...
    for(DWORD dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)rgbKipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)rgbKopad)[dwBlock] ^= 0x5C5C5C5C;
    }


    // prepend Kipad to data, Hash to get H1
    {
        // do this inline, don't call MyPrimitiveSHA since it would require data copy
        A_SHA_CTX   sSHAHash;

        A_SHAInit(&sSHAHash);
        A_SHAUpdate(&sSHAHash, rgbKipad, HMAC_K_PADSIZE);
        A_SHAUpdate(&sSHAHash, pbData, cbData);

        // Finish off the hash
        A_SHAFinal(&sSHAHash, sSHAHash.HashVal);

        // prepend Kopad to H1, hash to get HMAC
        CopyMemory(rgbHMACTmp, rgbKopad, HMAC_K_PADSIZE);
        CopyMemory(rgbHMACTmp+HMAC_K_PADSIZE, sSHAHash.HashVal, A_SHA_DIGEST_LEN);
    }

    if (!FMyPrimitiveSHA(
			rgbHMACTmp,
			sizeof(rgbHMACTmp),
            rgbHMAC))
        goto Ret;

    fRet = TRUE;
Ret:

    return fRet;
}

static
BOOL
CopyPassword(
	BYTE	*pbLocation,
	LPCWSTR	szPassword,
    DWORD   dwMaxBytes
	)
{
	DWORD i = 0;
	DWORD cbWideChars = WSZ_BYTECOUNT(szPassword);
	BYTE  *pbWideChars = (BYTE *) szPassword;

    while ((i<cbWideChars) && (i<dwMaxBytes))
	{
		pbLocation[i] = pbWideChars[i+1];
		pbLocation[i+1] = pbWideChars[i];
        i+=2;
	}
	
	return TRUE;
}

//+ --------------------------------------------------------------
//  in NSCP's initial implementation of PFX020, this
//  is the algorithm they used to derive a key from a password.
//  We include it so we can interoperate.
BOOL NSCPDeriveKey(
        LPCWSTR szPassword,
        PBYTE   pbPrivacySalt,
        DWORD   cbPrivacySalt,
        int     iPKCS5Iterations,
        PBYTE   pbPKCS5Salt,
        DWORD   cbPKCS5Salt,
        PBYTE   pbDerivedMaterial,
        DWORD   cbDerivedMaterial)
{
    BOOL    fRet = FALSE;
    BYTE    rgbPKCS5Key[A_SHA_DIGEST_LEN];

    DWORD   cbVirtualPW = cbPrivacySalt + WSZ_BYTECOUNT(szPassword);
    PBYTE   pbVirtualPW = (PBYTE)SSAlloc(cbVirtualPW);
    if (pbVirtualPW == NULL)
        goto Ret;

    // Virtual PW = (salt | szPW)
    CopyMemory(pbVirtualPW, pbPrivacySalt, cbPrivacySalt);
    CopyPassword(&pbVirtualPW[cbPrivacySalt], szPassword, WSZ_BYTECOUNT(szPassword));

    // use PKCS#5 to generate initial bit stream (seed)
    if (!PKCS5_GenKey(
            iPKCS5Iterations,
            pbVirtualPW, cbVirtualPW,
            pbPKCS5Salt, cbPKCS5Salt,
            rgbPKCS5Key))
        goto Ret;

    if (cbDerivedMaterial > sizeof(rgbPKCS5Key))
    {
        // P_hash (secret, seed) =  HMAC_hash (secret, A(0) + seed),
        //                          HMAC_hash (secret, A(1) + seed),
        //                          HMAC_hash (secret, A(2) + seed),
        //                          HMAC_hash (secret, A(3) + seed) ...
        // where
        // A(0) = seed
        // A(i) = HMAC_hash(secret, A(i-1))
        // seed = PKCS5 salt for PKCS5 PBE param
        // secret = normal PKCS5 hashed key

        if (!P_Hash (
                rgbPKCS5Key,
                sizeof(rgbPKCS5Key),

                pbPKCS5Salt,
                cbPKCS5Salt,

                pbDerivedMaterial,      // output
                cbDerivedMaterial,      // # of output bytes requested
                TRUE) )                 // NSCP compat mode?
            goto Ret;
    }
    else
    {
        // we already have enough bits to satisfy the request
        CopyMemory(pbDerivedMaterial, rgbPKCS5Key, cbDerivedMaterial);
    }

    fRet = TRUE;
Ret:
    if (pbVirtualPW)
        SSFree(pbVirtualPW);

    return fRet;
}


static
BYTE
AddWithCarry(
    BYTE byte1,
    BYTE byte2,
    BYTE *carry  // IN and OUT
    )
{
    BYTE tempCarry = *carry;

    if (((DWORD)byte1 + (DWORD)byte2 + (DWORD)tempCarry) >= 256) {
        *carry = 1;
    }
    else {
        *carry = 0;
    }


    return (byte1 + byte2 + tempCarry);
}

// 512 bits = ? bytes
#define SHA_INTERNAL_BLOCKLEN (512/8)
#define SHA_V_LENGTH (512/8)

//+ --------------------------------------------------------------
//  In PKCS12 v1.0 Draft, this is the way they describe to
//  derive a key from a password.
BOOL
PKCS12DeriveKey(
        LPCWSTR szPassword,
        BYTE    bID,

        int     iIterations,
        PBYTE   pbSalt,
        DWORD   cbSalt,

        PBYTE   pbDerivedMaterial,
        DWORD   cbDerivedMaterial)
{
#if DBG
    if (iIterations>1)
        OutputDebugString("Perf hit: iterating key derivation! (pfxcrypt:PKCS12DeriveKey())\n");
#endif
	BOOL fRet = FALSE;
	
    BYTE rgSaltPwd[2*SHA_INTERNAL_BLOCKLEN];
    DWORD cbSaltPwd;
    BYTE rgDiversifier[SHA_INTERNAL_BLOCKLEN];
    BYTE B[SHA_V_LENGTH];
    DWORD i;
    DWORD cbPassword = WSZ_BYTECOUNT(szPassword);
    BYTE bCarry;
    DWORD vBlocks;

    A_SHA_CTX   sSHAHash;

    // construct D
    FillMemory(rgDiversifier, sizeof(rgDiversifier), bID);

    // concat salt to create string of length 64*(cb/64) bytes

    // copy salt (multiple) times, don't copy the last time
    for (i=0; i<(SHA_INTERNAL_BLOCKLEN-cbSalt); i+=cbSalt)
    {
        CopyMemory(&rgSaltPwd[i], pbSalt, cbSalt);
    }
    // do final copy (assert we have less than cbSalt bytes left to copy)
    assert(cbSalt >= (SHA_INTERNAL_BLOCKLEN - (i%SHA_INTERNAL_BLOCKLEN)) );
    CopyMemory(&rgSaltPwd[i], pbSalt, (SHA_INTERNAL_BLOCKLEN-(i%SHA_INTERNAL_BLOCKLEN)));


    // if the password is not NULL, concat pwd to create string of length 64*(cbPwd/64) bytes
    // copy pwd (multiple) times, don't copy the last time
    if (szPassword)
    {
        // truncate if necessary
        if (cbPassword > SHA_INTERNAL_BLOCKLEN)
            cbPassword = SHA_INTERNAL_BLOCKLEN;

        for (i=SHA_INTERNAL_BLOCKLEN; i<( (2*SHA_INTERNAL_BLOCKLEN)-cbPassword); i+=cbPassword)
        {
            // use CopyPassword because bytes need to be swapped
            CopyPassword(&rgSaltPwd[i], szPassword, cbPassword);
        }
        // do final copy (assert we have less than cbSalt bytes left to copy)
        assert(cbPassword >= (SHA_INTERNAL_BLOCKLEN - (i%SHA_INTERNAL_BLOCKLEN)) );
        CopyPassword(&rgSaltPwd[i], szPassword, (SHA_INTERNAL_BLOCKLEN-(i%SHA_INTERNAL_BLOCKLEN)));

        cbSaltPwd = sizeof(rgSaltPwd);
    }
    else
    {
        cbSaltPwd = sizeof(rgSaltPwd) / 2;
    }


    // concat S|P
    // done, available in rgSaltPwd


    // set c = cbDerivedMaterial/A_SHA_DIGEST_LEN
    //assert(0 == cbDerivedMaterial%A_SHA_DIGEST_LEN);
	
	// compute working size >= output size
	DWORD cBlocks = (DWORD)((cbDerivedMaterial/A_SHA_DIGEST_LEN) +1);
	DWORD cbTmpBuf = cBlocks * A_SHA_DIGEST_LEN;
	PBYTE pbTmpBuf = (PBYTE)LocalAlloc(LPTR, cbTmpBuf);
	if (pbTmpBuf == NULL)
		goto Ret;
	
	// now do only full blocks
    for (i=0; i< cBlocks; i++)
    {
        int iIter;
        int iCount;
        A_SHAInit(&sSHAHash);

        for (iIter=0; iIter<iIterations; iIter++)
        {
            // Tmp = Hash(D | I);
            if (iIter==0)
            {
                A_SHAUpdate(&sSHAHash, rgDiversifier, sizeof(rgDiversifier));
                A_SHAUpdate(&sSHAHash, rgSaltPwd, cbSaltPwd);
            }
            else
            {
                // rehash last output
                A_SHAUpdate(&sSHAHash, &pbTmpBuf[i*A_SHA_DIGEST_LEN], A_SHA_DIGEST_LEN);
            }

            // spit iteration output to final buffer
            A_SHAFinal(&sSHAHash, &pbTmpBuf[i*A_SHA_DIGEST_LEN]);
        }

        // concat A[x] | A[x] | ... and truncate to get 64 bytes
        iCount = 0;
        while (iCount+A_SHA_DIGEST_LEN <= sizeof(B)) {
            CopyMemory(&B[iCount], &pbTmpBuf[i*A_SHA_DIGEST_LEN], A_SHA_DIGEST_LEN);
            iCount += A_SHA_DIGEST_LEN;
        }
        CopyMemory(&B[iCount], &pbTmpBuf[i*A_SHA_DIGEST_LEN], sizeof(B) % A_SHA_DIGEST_LEN);


        // modify I by setting Ij += (B + 1) (mod 2^512)
        for (vBlocks = 0; vBlocks < cbSaltPwd; vBlocks += SHA_V_LENGTH) {
            bCarry = 1;
            for (iCount = SHA_V_LENGTH-1; iCount >= 0; iCount--)
            {
                rgSaltPwd[iCount+vBlocks] = AddWithCarry(rgSaltPwd[iCount+vBlocks], B[iCount], &bCarry);
            }
        }
    }

	// copy from (larger) working buffer to output buffer
	CopyMemory(pbDerivedMaterial, pbTmpBuf, cbDerivedMaterial);

	fRet = TRUE;
Ret:
	if (pbTmpBuf)
		LocalFree(pbTmpBuf);

    return fRet;
}

//+ --------------------------------------------------------------
//  in NSCP's initial implementation of PFX020, this
//  is the algorithm they used to decrypt data. This uses the
//  key derivation code above.
//  We include it so we can interoperate.
BOOL NSCPPasswordDecryptData(
        int     iEncrType,

        LPCWSTR szPassword,

        PBYTE   pbPrivacySalt,      // privacy salt
        DWORD   cbPrivacySalt,

        int     iPKCS5Iterations,   // pkcs5 data
        PBYTE   pbPKCS5Salt,
        DWORD   cbPKCS5Salt,

        PBYTE*  ppbData,            // in/out
        DWORD*  pcbData)
{
    BOOL fRet = FALSE;

    BYTE    rgbDerivedKeyMatl[40]; // 320 bits is enough for 128 bit key, 64 bit IV
    DWORD   cbNeeded;

    if (iEncrType == RC2_40)
        cbNeeded = (40/8)+RC2_BLOCKLEN; // key + IV
    else
        cbNeeded = 0;

    // make next muliple of SHA dig len
    if (cbNeeded % A_SHA_DIGEST_LEN)
    {
        cbNeeded += (A_SHA_DIGEST_LEN - (cbNeeded % A_SHA_DIGEST_LEN));
    }

    assert(0 == (cbNeeded % A_SHA_DIGEST_LEN));
    assert(cbNeeded <= sizeof(rgbDerivedKeyMatl));

    if (!NSCPDeriveKey(
            szPassword,
            pbPrivacySalt,
            cbPrivacySalt,
            iPKCS5Iterations,
            pbPKCS5Salt,
            cbPKCS5Salt,
            rgbDerivedKeyMatl,
            cbNeeded) )
        goto Ret;

    // NOW decrypt data
    if (iEncrType == RC2_40)
    {
        DWORD dwDataPos;
        DWORD cbToBeDec = *pcbData;
        WORD  rc2Table[RC2_TABLESIZE];
        BYTE  rc2Fdbk [RC2_BLOCKLEN];

        assert( (40/8) <= sizeof(rgbDerivedKeyMatl));
        assert( 0 == cbToBeDec % RC2_BLOCKLEN );     // must be even multiple

        // key setup
        RC2Key(rc2Table, rgbDerivedKeyMatl, (40/8));    // take first 40 bits of keying material
        CopyMemory(rc2Fdbk, &rgbDerivedKeyMatl[cbNeeded - sizeof(rc2Fdbk)], sizeof(rc2Fdbk));    // fdbk is last chunk

        // decryption
        for (dwDataPos=0; cbToBeDec > 0; dwDataPos+=RC2_BLOCKLEN, cbToBeDec -= RC2_BLOCKLEN)
        {
            BYTE rgbDec[RC2_BLOCKLEN];

            CBC(
                RC2,
		        RC2_BLOCKLEN,
		        rgbDec,
		        &(*ppbData)[dwDataPos],
		        rc2Table,
		        DECRYPT,
		        rc2Fdbk);

            CopyMemory(&(*ppbData)[dwDataPos], rgbDec, RC2_BLOCKLEN);
        }
    }
    else
        goto Ret;



    fRet = TRUE;

Ret:
    return fRet;
}



//+ --------------------------------------------------------------
//  in the PKCS12 v1.0 Draft, this is how they describe how to
//  encrypt data. 										
BOOL PFXPasswordEncryptData(
        int     iEncrType,
        LPCWSTR szPassword,

        int     iPKCS5Iterations,   // pkcs5 data
        PBYTE   pbPKCS5Salt,
        DWORD   cbPKCS5Salt,

        PBYTE*  ppbData,
        DWORD*  pcbData)
{
    BOOL fRet = FALSE;
	BOOL fIsBlockCipher = FALSE;
	DWORD cbToBeEnc;

    BYTE    rgbDerivedKey[A_SHA_DIGEST_LEN*2];    // 320 bits is enough for 256 bit key
    BYTE    rgbDerivedIV[A_SHA_DIGEST_LEN*2];     // 320 bits is enough for 256 bit IV
    DWORD   cbKeyNeeded, cbIVNeeded, cbBlockLen;

    if (iEncrType == RC2_40)
    {
        cbKeyNeeded = (40/8);      // key
        cbIVNeeded = RC2_BLOCKLEN; // IV
		cbBlockLen = RC2_BLOCKLEN;
		fIsBlockCipher = TRUE;
    }
    else if (iEncrType == TripleDES)
    {
        cbKeyNeeded = (64/8) * 3;
        cbIVNeeded = DES_BLOCKLEN;
		cbBlockLen = DES_BLOCKLEN;
		fIsBlockCipher = TRUE;
    }
	else
    {
        cbKeyNeeded = 0;
        cbIVNeeded = 0;
		cbBlockLen = 0;
    }

    // make next muliple of SHA dig len
    if (cbKeyNeeded % A_SHA_DIGEST_LEN)
        cbKeyNeeded += (A_SHA_DIGEST_LEN - (cbKeyNeeded % A_SHA_DIGEST_LEN));

    if (cbIVNeeded % A_SHA_DIGEST_LEN)
        cbIVNeeded += (A_SHA_DIGEST_LEN - (cbIVNeeded % A_SHA_DIGEST_LEN));

    assert(0 == (cbKeyNeeded % A_SHA_DIGEST_LEN));
    assert(0 == (cbIVNeeded % A_SHA_DIGEST_LEN));

    assert(cbKeyNeeded <= sizeof(rgbDerivedKey));
    assert(cbIVNeeded <= sizeof(rgbDerivedIV));


    if (!PKCS12DeriveKey(
            szPassword,
            DERIVE_ENCRYPT_DECRYPT,
            iPKCS5Iterations,
            pbPKCS5Salt,
            cbPKCS5Salt,
            rgbDerivedKey,
            cbKeyNeeded) )
        goto Ret;

    if (!PKCS12DeriveKey(
            szPassword,
            DERIVE_INITIAL_VECTOR,
            iPKCS5Iterations,
            pbPKCS5Salt,
            cbPKCS5Salt,
            rgbDerivedIV,
            cbIVNeeded) )
        goto Ret;

	if (fIsBlockCipher)
	{
		// extend buffer to multiple of blocklen
		cbToBeEnc = *pcbData;
		cbToBeEnc += cbBlockLen - (cbToBeEnc%cbBlockLen);   // {1..BLOCKLEN}
		*ppbData = (PBYTE)SSReAlloc(*ppbData, cbToBeEnc);
		if (NULL == *ppbData)
			goto Ret;

		// pad remaining bytes with length
		FillMemory(&((*ppbData)[*pcbData]), cbToBeEnc-(*pcbData), (BYTE)(cbToBeEnc-(*pcbData)));
		*pcbData = cbToBeEnc;

		assert( cbBlockLen <= sizeof(rgbDerivedKey));
		assert( 0 == cbToBeEnc % cbBlockLen );         // must be even multiple
	}

    // NOW encrypt data
    if (iEncrType == RC2_40)
    {
        DWORD dwDataPos;
        WORD  rc2Table[RC2_TABLESIZE];
        BYTE  rc2Fdbk [RC2_BLOCKLEN];

        // already done: extend buffer, add PKCS byte padding

        // key setup
        RC2Key(rc2Table, rgbDerivedKey, (40/8));            // take first 40 bits of keying material
        CopyMemory(rc2Fdbk, rgbDerivedIV, sizeof(rc2Fdbk));

        // decryption
        for (dwDataPos=0; cbToBeEnc > 0; dwDataPos+=RC2_BLOCKLEN, cbToBeEnc -= RC2_BLOCKLEN)
        {
            BYTE rgbEnc[RC2_BLOCKLEN];

            CBC(
                RC2,
		        RC2_BLOCKLEN,
		        rgbEnc,
		        &(*ppbData)[dwDataPos],
		        rc2Table,
		        ENCRYPT,
		        rc2Fdbk);

            CopyMemory(&(*ppbData)[dwDataPos], rgbEnc, sizeof(rgbEnc));
        }
    }
    else if (iEncrType == TripleDES)
	{
        DWORD       dwDataPos;
        DES3TABLE   des3Table;
        BYTE        des3Fdbk [DES_BLOCKLEN];

        // already done: extend buffer, add PKCS byte padding

        // key setup
        tripledes3key(&des3Table, rgbDerivedKey);
        CopyMemory(des3Fdbk, rgbDerivedIV, sizeof(des3Fdbk));    // fdbk is last chunk

        for (dwDataPos=0; cbToBeEnc > 0; dwDataPos+=DES_BLOCKLEN, cbToBeEnc -= DES_BLOCKLEN)
        {
            BYTE rgbEnc[DES_BLOCKLEN];

            CBC(
                tripledes,
		        DES_BLOCKLEN,
		        rgbEnc,
		        &(*ppbData)[dwDataPos],
		        (void *) &des3Table,
		        ENCRYPT,
		        des3Fdbk);

            CopyMemory(&(*ppbData)[dwDataPos], rgbEnc, DES_BLOCKLEN);
        }
	}
    else
        goto Ret;

    fRet = TRUE;

Ret:
    return fRet;
}

//+ --------------------------------------------------------------
//  in the PKCS12 v1.0 Draft, this is how they describe how to
//  decrypt data. 										
BOOL PFXPasswordDecryptData(
        int     iEncrType,
        LPCWSTR szPassword,

        int     iPKCS5Iterations,   // pkcs5 data
        PBYTE   pbPKCS5Salt,
        DWORD   cbPKCS5Salt,

        PBYTE*  ppbData,
        DWORD*  pcbData)
{
    BOOL fRet = FALSE;
	BOOL fIsBlockCipher = FALSE;

    BYTE    rgbDerivedKey[A_SHA_DIGEST_LEN*2];    // 320 bits is enough for 256 bit key
    BYTE    rgbDerivedIV[A_SHA_DIGEST_LEN*2];     // 320 bits is enough for 256 bit IV
    DWORD   cbKeyNeeded, cbIVNeeded, cbBlockLen;

    if (iEncrType == RC2_40)
    {
        cbKeyNeeded = (40/8);      // key
        cbIVNeeded = RC2_BLOCKLEN; // IV
		cbBlockLen = RC2_BLOCKLEN;
		fIsBlockCipher = TRUE;
    }
    else if (iEncrType == TripleDES)
    {
        cbKeyNeeded = (64/8) * 3;
        cbIVNeeded = DES_BLOCKLEN;
		cbBlockLen = DES_BLOCKLEN;
		fIsBlockCipher = TRUE;
    }
    else
    {
        cbKeyNeeded = 0;
        cbIVNeeded = 0;
		cbBlockLen = 0;
    }

    // make next muliple of SHA dig len
    if (cbKeyNeeded % A_SHA_DIGEST_LEN)
        cbKeyNeeded += (A_SHA_DIGEST_LEN - (cbKeyNeeded % A_SHA_DIGEST_LEN));

    if (cbIVNeeded % A_SHA_DIGEST_LEN)
        cbIVNeeded += (A_SHA_DIGEST_LEN - (cbIVNeeded % A_SHA_DIGEST_LEN));

    assert(0 == (cbKeyNeeded % A_SHA_DIGEST_LEN));
    assert(0 == (cbIVNeeded % A_SHA_DIGEST_LEN));

    assert(cbKeyNeeded <= sizeof(rgbDerivedKey));
    assert(cbIVNeeded <= sizeof(rgbDerivedIV));


    if (!PKCS12DeriveKey(
            szPassword,
            DERIVE_ENCRYPT_DECRYPT,
            iPKCS5Iterations,
            pbPKCS5Salt,
            cbPKCS5Salt,
            rgbDerivedKey,
            cbKeyNeeded) )
        goto Ret;

    if (!PKCS12DeriveKey(
            szPassword,
            DERIVE_INITIAL_VECTOR,
            iPKCS5Iterations,
            pbPKCS5Salt,
            cbPKCS5Salt,
            rgbDerivedIV,
            cbIVNeeded) )
        goto Ret;

    // NOW decrypt data
    if (iEncrType == RC2_40)
    {
        BYTE rgbDec[RC2_BLOCKLEN];

        DWORD dwDataPos;
        DWORD cbToBeDec = *pcbData;
        WORD  rc2Table[RC2_TABLESIZE];
        BYTE  rc2Fdbk [RC2_BLOCKLEN];

        assert( (40/8) <= sizeof(rgbDerivedKey));
        assert( 0 == cbToBeDec % RC2_BLOCKLEN );         // must be even multiple

        // key setup
        RC2Key(rc2Table, rgbDerivedKey, (40/8));            // take first 40 bits of keying material
        CopyMemory(rc2Fdbk, rgbDerivedIV, sizeof(rc2Fdbk));

        // decryption
        for (dwDataPos=0; cbToBeDec > 0; dwDataPos+=RC2_BLOCKLEN, cbToBeDec -= RC2_BLOCKLEN)
        {
            CBC(
                RC2,
		        RC2_BLOCKLEN,
		        rgbDec,
		        &(*ppbData)[dwDataPos],
		        rc2Table,
		        DECRYPT,
		        rc2Fdbk);

            CopyMemory(&(*ppbData)[dwDataPos], rgbDec, sizeof(rgbDec));
        }
    }
    else if (iEncrType == TripleDES) {
        DWORD       dwDataPos;
        DWORD       cbToBeDec = *pcbData;
        DES3TABLE   des3Table;
        BYTE        des3Fdbk [DES_BLOCKLEN];


        // key setup
        tripledes3key(&des3Table, rgbDerivedKey);
        CopyMemory(des3Fdbk, rgbDerivedIV, sizeof(des3Fdbk));    // fdbk is last chunk

        for (dwDataPos=0; cbToBeDec > 0; dwDataPos += DES_BLOCKLEN, cbToBeDec -= DES_BLOCKLEN)
        {
            BYTE rgbDec[DES_BLOCKLEN];

            CBC(
                tripledes,
		        DES_BLOCKLEN,
		        rgbDec,
		        &(*ppbData)[dwDataPos],
		        (void *) &des3Table,
		        DECRYPT,
		        des3Fdbk);

            CopyMemory(&(*ppbData)[dwDataPos], rgbDec, DES_BLOCKLEN);
        }
    }
    else
        goto Ret;

	// Remove padding
	if (fIsBlockCipher)
	{
		// last byte of decr is pad byte
        BYTE iPadBytes;
        iPadBytes = (*ppbData)[*pcbData-1];
        if (iPadBytes > cbBlockLen)
            goto Ret;

        *ppbData = (PBYTE)SSReAlloc( (*ppbData), *pcbData - iPadBytes);
		if (NULL == *ppbData)
			goto Ret;

        *pcbData -= iPadBytes;
	}

    fRet = TRUE;

Ret:
    return fRet;
}

//+ --------------------------------------------------------------
//  in the PKCS12 v1.0 Draft, this is how they describe how to
//  generate a checksum that will prove data integrid.
BOOL FGenerateMAC(

        LPCWSTR szPassword,

        PBYTE   pbPKCS5Salt,
        DWORD   cbPKCS5Salt,
        DWORD   iterationCount,

        PBYTE   pbData,     // pb data
        DWORD   cbData,     // cb data
        BYTE    rgbMAC[])   // output
{
	// UNDONE UNDONE: Use RSABase

    BOOL    fRet = FALSE;
    BYTE    rgbDerivedKey[A_SHA_DIGEST_LEN];    // 160 bits is enough for a MAC key
    DWORD   cbKeyNeeded = A_SHA_DIGEST_LEN;

    assert(0 == (cbKeyNeeded % A_SHA_DIGEST_LEN));
    assert(cbKeyNeeded <= sizeof(rgbDerivedKey));

    if (!PKCS12DeriveKey(
            szPassword,
            DERIVE_INTEGRITY_KEY,
            iterationCount,                      // no other way to determine iterations: HARDCODE
            pbPKCS5Salt,
            cbPKCS5Salt,
            rgbDerivedKey,
            cbKeyNeeded) )
        goto Ret;

    if (!FMyPrimitiveHMACParam(
            rgbDerivedKey,
            cbKeyNeeded,
            pbData,
            cbData,
            rgbMAC))
        goto Ret;

    fRet = TRUE;
Ret:

    return fRet;
}

/////////////////////////////////////////////////////////////////
// begin tls1key.cpp
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1999
* All rights reserved.
*----------------------------------------------------------------------------*/

// the original PKCS5 algorithm for generating a key from a password
BOOL PKCS5_GenKey
(
    int     iIterations,
    PBYTE   pbPW,
    DWORD   cbPW,
    PBYTE   pbSalt,
    DWORD   cbSalt,
    BYTE    rgbPKCS5Key[A_SHA_DIGEST_LEN]
)
{
    BOOL    fRet = FALSE;

    int     i;
    DWORD   cbTmp = cbSalt + cbPW;
    PBYTE   pbTmp = (PBYTE) SSAlloc(cbTmp);
    if (pbTmp == NULL)
        goto Ret;


    // pbTmp is ( PW | Salt )
    CopyMemory(pbTmp, pbPW, cbPW);
    CopyMemory(&pbTmp[cbPW], pbSalt, cbSalt);

    for (i=0; i<iIterations; i++)
    {
        if (i == 0) {
            if (!FMyPrimitiveSHA(
			        pbTmp,             // in
			        cbTmp,             // in
                    rgbPKCS5Key))
                goto Ret;

        }
        else {
             if (!FMyPrimitiveSHA(
			        rgbPKCS5Key,       // in
			        A_SHA_DIGEST_LEN,  // in
                    rgbPKCS5Key))
                goto Ret;
        }
    }

    fRet = TRUE;
Ret:
    SSFree(pbTmp);
    return fRet;
}

//+ ---------------------------------------------------------------------
// the P_Hash algorithm from TLS that was used in NSCP's PFX020 version
// to derive a key from a password. It is included here for completeness.

// NSCP made some implementation errors when they coded this up; to interop,
// use the fNSCPInteropMode parameter. The real P_Hash algorithm is used
// when fNSCPInteropMode is FALSE.
BOOL P_Hash
(
    PBYTE  pbSecret,
    DWORD  cbSecret,

    PBYTE  pbSeed,
    DWORD  cbSeed,

    PBYTE  pbKeyOut, //Buffer to copy the result...
    DWORD  cbKeyOut, //# of bytes of key length they want as output.

    BOOL    fNSCPInteropMode
)
{
    BOOL    fRet = FALSE;
    BYTE    rgbDigest[A_SHA_DIGEST_LEN];
    DWORD   iKey;

    PBYTE   pbAofiDigest = (PBYTE)SSAlloc(cbSeed + A_SHA_DIGEST_LEN);
    if (pbAofiDigest == NULL)
        goto Ret;

    ZeroMemory(pbAofiDigest, cbSeed+A_SHA_DIGEST_LEN);

//   First, we define a data expansion function, P_hash(secret, data)
//   which uses a single hash function to expand a secret and seed into
//   an arbitrary quantity of output:

//       P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
//                              HMAC_hash(secret, A(2) + seed) +
//                              HMAC_hash(secret, A(3) + seed) + ...

//   Where + indicates concatenation.

//   A() is defined as:
//       A(0) = seed
//       A(i) = HMAC_hash(secret, A(i-1))


    if (fNSCPInteropMode)
    {
        // NSCP interop mode: 7/7/97
        // nscp leaves (A_SHA_DIGEST_LEN-cbSeed) bytes zeroed between
        // the seed and the appended seed. For interop, do derivation this way

        // Also, they use A(0) to derive key bytes, whereas TLS spec
        // specifies to wait for A(1).
        CopyMemory(pbAofiDigest, pbSeed, cbSeed);
    }
    else
    {
        // build A(1)
        if (!FMyPrimitiveHMACParam(pbSecret, cbSecret, pbSeed, cbSeed, pbAofiDigest))
            goto Ret;
    }


    // create Aofi: (  A(i) | seed )
    CopyMemory(&pbAofiDigest[A_SHA_DIGEST_LEN], pbSeed, cbSeed);

    for (iKey=0; cbKeyOut; iKey++)
    {
        // build Digest = HMAC(key | A(i) | seed);
        if (!FMyPrimitiveHMACParam(pbSecret, cbSecret, pbAofiDigest, cbSeed + A_SHA_DIGEST_LEN, rgbDigest))
            goto Ret;

        // append to pbKeyOut
        CopyMemory(pbKeyOut, rgbDigest, A_SHA_DIGEST_LEN);
        pbKeyOut += A_SHA_DIGEST_LEN;

        if(cbKeyOut < A_SHA_DIGEST_LEN)
            break;
        cbKeyOut -= A_SHA_DIGEST_LEN;

        // build A(i) = HMAC(key, A(i-1))
        if (!FMyPrimitiveHMACParam(pbSecret, cbSecret, pbAofiDigest, A_SHA_DIGEST_LEN, pbAofiDigest))
            goto Ret;
    }

    fRet = TRUE;

Ret:
    if (pbAofiDigest)
        SSFree(pbAofiDigest);

    return fRet;
}



#if DBG

// test vector for real P_Hash
BOOL FTestPHASH_and_HMAC()
{
    BYTE rgbKey[] = {0x33, 0x62, 0xf9, 0x42, 0x43};
    CHAR szPwd[] = "My Password";

    BYTE rgbKeyOut[7*A_SHA_DIGEST_LEN];
    static BYTE rgbTestVectorOutput[] =  {
            0x24, 0xF2, 0x98, 0x75, 0xE1, 0x90, 0x6D, 0x49,
            0x96, 0x5B, 0x87, 0xB8, 0xBC, 0xD3, 0x11, 0x6C,
            0x13, 0xDC, 0xBD, 0xC2, 0x7E, 0x56, 0xD0, 0x3C,
            0xAC, 0xCD, 0x86, 0x58, 0x31, 0x67, 0x7B, 0x23,
            0x19, 0x6E, 0x36, 0x65, 0xBF, 0x9F, 0x3D, 0x03,
            0x5A, 0x9C, 0x6E, 0xD7, 0xEB, 0x3E, 0x5A, 0xE6,
            0x05, 0x86, 0x84, 0x5A, 0xC3, 0x97, 0xFC, 0x17,
            0xF5, 0xF0, 0xF5, 0x16, 0x67, 0xAD, 0x7C, 0xED,
            0x65, 0xDC, 0x0B, 0x99, 0x58, 0x5D, 0xCA, 0x66,
            0x28, 0xAD, 0xA5, 0x39, 0x54, 0x44, 0x36, 0x13,
            0x91, 0xCE, 0xE9, 0x73, 0x23, 0x43, 0x2E, 0xEC,
            0xA2, 0xC3, 0xE7, 0xFA, 0x74, 0xA7, 0xB6, 0x75,
            0x77, 0xF5, 0xF5, 0x16, 0xC2, 0xEE, 0xED, 0x7A,
            0x21, 0x86, 0x1D, 0x84, 0x6F, 0xC6, 0x03, 0xF3,
            0xCC, 0x77, 0x02, 0xFA, 0x76, 0x46, 0x64, 0x57,
            0xBB, 0x56, 0x3A, 0xF7, 0x7E, 0xB4, 0xD6, 0x52,
            0x72, 0x8C, 0x34, 0xF1, 0xA4, 0x1E, 0xA7, 0xA6,
            0xCD, 0xBD, 0x3C, 0x16, 0x4D, 0x79, 0x20, 0x50 };

    P_Hash(
        rgbKey, sizeof(rgbKey),
        (PBYTE)szPwd, strlen(szPwd),
        rgbKeyOut, sizeof(rgbKeyOut), FALSE);

    if (0 != memcmp(rgbKeyOut, rgbTestVectorOutput, sizeof(rgbKeyOut)) )
    {
        OutputDebugString("ERROR: phash vector test invalid!!!\n");
        return FALSE;
    }

    return TRUE;
}

// test vector for NSCP P_Hash
BOOL F_NSCP_TestPHASH_and_HMAC()
{
    BYTE rgbKey[] = {   0xc9, 0xc1, 0x69, 0x6e, 0x30, 0xa8, 0x91, 0x0d,
                        0x12, 0x19, 0x48, 0xef, 0x23, 0xac, 0x5b, 0x1f,
                        0x2e, 0xc4, 0x0e, 0xc2  };

    BYTE rgbSalt[] = {  0x1a, 0xb5, 0xf1, 0x1a, 0x5b, 0x6a, 0x6a, 0x5e };

    BYTE rgbKeyOut[7*A_SHA_DIGEST_LEN];
    static BYTE rgbTestVectorOutput[] =  {
                0x52, 0x7c, 0xbf, 0x90, 0xb1, 0xa1, 0xd0, 0xbf,
                0x21, 0x56, 0x34, 0xf2, 0x1f, 0x5c, 0x98, 0xcf,
                0x55, 0x95, 0xb1, 0x35, 0x65, 0xe3, 0x31, 0x44,
                0x78, 0xc5, 0x41, 0xa9, 0x2a, 0x14, 0x80, 0x19,
                0x56, 0x86, 0xa4, 0x71, 0x07, 0x24, 0x2d, 0x64 };

    assert(sizeof(rgbKeyOut) > sizeof(rgbTestVectorOutput));

    P_Hash(
        rgbKey, sizeof(rgbKey),
        rgbSalt, sizeof(rgbSalt),
        rgbKeyOut, sizeof(rgbTestVectorOutput),
        TRUE);

    if (0 != memcmp(rgbKeyOut, rgbTestVectorOutput, sizeof(rgbTestVectorOutput)) )
    {
        OutputDebugString("ERROR: NSCP phash vector test invalid!!!\n");
        return FALSE;
    }

    return TRUE;
}

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\pfxlib\pfxcrypt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pfxcrypt.h
//
//--------------------------------------------------------------------------

#define RC4_128     1
#define RC4_40      2
#define TripleDES   3
#define RC2_128     4
#define RC2_40      5


BOOL _stdcall 
PFXPasswordEncryptData(
        int     iEncrType,
        LPCWSTR szPassword,

        int     iPKCS5Iterations,   // pkcs5 data
        PBYTE   pbPKCS5Salt,
        DWORD   cbPKCS5Salt, 

        PBYTE* pbData,
        DWORD* pcbData);

BOOL _stdcall
PFXPasswordDecryptData(
        int     iEncrType,
        LPCWSTR szPassword,

        int     iPKCS5Iterations,   // pkcs5 data
        PBYTE   pbPKCS5Salt,
        DWORD   cbPKCS5Salt, 

        PBYTE* pbData,
        DWORD* pcbData);



BOOL NSCPPasswordDecryptData(
        int     iEncrType,

        LPCWSTR szPassword,

        PBYTE   pbPrivacySalt,
        DWORD   cbPrivacySalt,

        int     iPKCS5Iterations,
        PBYTE   pbPKCS5Salt,
        DWORD   cbPKCS5Salt, 

        PBYTE*  ppbData,
        DWORD*  pcbData);

BOOL FGenerateMAC(
        LPCWSTR szPassword,

        PBYTE   pbPKCS5Salt,
        DWORD   cbPKCS5Salt, 
        DWORD   iterationCount,

        PBYTE   pbData,     // pb data
        DWORD   cbData,     // cb data
        BYTE    rgbMAC[]);  // A_SHA_DIGEST_LEN



//////////////////////////////////////////////////
// begin tls1key.h
BOOL PKCS5_GenKey
(
    int     iIterations,

    PBYTE   pbPW, 
    DWORD   cbPW, 

    PBYTE   pbSalt, 
    DWORD   cbSalt, 

    BYTE    rgbPKCS5Key[]     // A_SHA_DIGEST_LEN
);

BOOL P_Hash
(
    PBYTE  pbSecret,
    DWORD  cbSecret, 

    PBYTE  pbSeed,  
    DWORD  cbSeed,  

    PBYTE  pbKeyOut, //Buffer to copy the result...
    DWORD  cbKeyOut, //# of bytes of key length they want as output.

    BOOL   fNSCPCompatMode
);

BOOL FTestPHASH_and_HMAC();
BOOL F_NSCP_TestPHASH_and_HMAC();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\pfxlib\pfxhelp.h ===
#ifndef _PFXHELP_H
#define _PFXHELP_H
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       pfxhelp.h
//
//  Contents:   PFX helper function defintions and types
//
//----------------------------------------------------------------------------



#include "pfx.h"

//+-------------------------------------------------------------------------
//  Safe Bag Type Object Identifiers 
//--------------------------------------------------------------------------

#define szOID_PKCS_12_VERSION1			szOID_PKCS_12           ".10"
#define szOID_PKCS_12_BAG_IDS           szOID_PKCS_12_VERSION1  ".1"
#define szOID_PKCS_12_KEY_BAG			szOID_PKCS_12_BAG_IDS   ".1"
#define szOID_PKCS_12_SHROUDEDKEY_BAG	szOID_PKCS_12_BAG_IDS   ".2"
#define szOID_PKCS_12_CERT_BAG			szOID_PKCS_12_BAG_IDS   ".3"
#define szOID_PKCS_12_CRL_BAG			szOID_PKCS_12_BAG_IDS   ".4"
#define szOID_PKCS_12_SECRET_BAG		szOID_PKCS_12_BAG_IDS   ".5"
#define szOID_PKCS_12_SAFECONTENTS_BAG	szOID_PKCS_12_BAG_IDS   ".6"


#define PBE_SALT_LENGTH 8


typedef struct _SAFE_BAG{
	LPSTR				pszBagTypeOID;
	CRYPT_DER_BLOB		BagContents;	
	CRYPT_ATTRIBUTES	Attributes; 
} SAFE_BAG, *PSAFE_BAG;


typedef struct _SAFE_CONTENTS{
	DWORD		cSafeBags;
	SAFE_BAG	*pSafeBags;
} SAFE_CONTENTS, *PSAFE_CONTENTS;



typedef struct _EXPORT_SAFE_CALLBACK_STRUCT {
	PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC	pEncryptPrivateKeyFunc;
	LPVOID						    pVoidEncryptFunc;
} EXPORT_SAFE_CALLBACK_STRUCT, *PEXPORT_SAFE_CALLBACK_STRUCT;

//+-------------------------------------------------------------------------
// hCertStore - handle to the cert store that contains the certs whose
//				corresponding private keys are to be exported
// pSafeContents - pointer to a buffer to receive the SAFE_CONTENTS structure
//				   and supporting data
// pcbSafeContents - (in) specifies the length, in bytes, of the pSafeContents 
//					  buffer.  (out) gets filled in with the number of bytes 
//					  used by the operation.  If this is set to 0, the 
//					  required length of pSafeContents is filled in, and 
//					  pSafeContents is ignored.
// ExportSafeCallbackStruct - pointer to callbacks to handle PKCS8 encryption. If NULL, 
//              no encryption is performed.
// dwFlags - the current available flags are:
//				EXPORT_PRIVATE_KEYS
//				if this flag is set then the private keys are exported as well
//				as the certificates
//				REPORT_NO_PRIVATE_KEY
//				if this flag is set and a certificate is encountered that has no
//				no associated private key, the function will return immediately
//				with ppCertContext filled in with a pointer to the cert context
//				in question.  the caller is responsible for freeing the cert
//				context which is passed back.
//				REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY
//				if this flag is set and a certificate is encountered that has a 
//				non-exportable private key, the function will return immediately
//				with ppCertContext filled in with a pointer to the cert context
//				in question.  the caller is responsible for freeing the cert
//				context which is passed back.
// ppCertContext - a pointer to a pointer to a cert context.  this is used 
//				   if REPORT_NO_PRIVATE_KEY or REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY
//				   flags are set.  the caller is responsible for freeing the
//				   cert context.
// pvAuxInfo - reserved for future use, must be set to NULL 
//+-------------------------------------------------------------------------
BOOL WINAPI CertExportSafeContents(
	HCERTSTORE		hCertStore,			// in
	SAFE_CONTENTS	*pSafeContents,		// out
	DWORD			*pcbSafeContents,	// in, out
    EXPORT_SAFE_CALLBACK_STRUCT* ExportSafeCallbackStruct, // in
	DWORD			dwFlags,			// in
	PCCERT_CONTEXT *ppCertContext,		// out
	void			*pvAuxInfo			// in
);


// this callback is called when a private key is going to be imported,
// this gives the caller a chance specify which provider to import the 
// key to.
// the parameters are:
// pPrivateKeyInfo - a PRIVATE_KEY_INFO structure which contains all
//					 the information about the private key being imported
// dwSafeBagIndex - the idex into the safe bag array so the caller can
//					identify which SAFE_BAG this key cam out of
// phCryptProvInfo - a pointer to a HCRYPTPROV that is to be filled in
//					 with the handle of the provider to import to
// ppVoidhCryptProvQueryVoid - the LPVOID that was passed in when 
//							   CertImportSafeContents called, this is 
//							   preserved and passed back to the caller for
//							   context
typedef BOOL (CALLBACK *PHCRYPTPROV_QUERY_FUNC)(
						CRYPT_PRIVATE_KEY_INFO	*pPrivateKeyInfo,
						DWORD   				dwSafeBagIndex,		
						HCRYPTPROV  			*phCryptProv,
						LPVOID		    		pVoidhCryptProvQuery,
                        DWORD                   dwPFXImportFlags);


typedef struct _IMPORT_SAFE_CALLBACK_STRUCT {
	PHCRYPTPROV_QUERY_FUNC		    phCryptProvQueryFunc;
	LPVOID						    pVoidhCryptProvQuery;
	PCRYPT_DECRYPT_PRIVATE_KEY_FUNC	pDecryptPrivateKeyFunc;
	LPVOID						    pVoidDecryptFunc;
} IMPORT_SAFE_CALLBACK_STRUCT, *PIMPORT_SAFE_CALLBACK_STRUCT;



//+-------------------------------------------------------------------------
// hCertStore -  handle of the cert store to import the safe contents to
// pSafeContents - pointer to the safe contents to import to the store
// dwCertAddDisposition - used when importing certificate to the store.
//						  for a full explanation of the possible values
//						  and their meanings see documentation for
//						  CertAddEncodedCertificateToStore
// ImportSafeCallbackStruct - structure that contains pointers to functions
//							  which are callled to get a HCRYPTPROV for import
//							  and to decrypt the key if a EncryptPrivateKeyInfo
//							  is encountered during import
// dwFlags - The available flags are:
//				CRYPT_EXPORTABLE 
//				this flag is used when importing private keys, for a full 
//				explanation please see the documentation for CryptImportKey.
// pvAuxInfo - reserved for future use, must be set to NULL
//+-------------------------------------------------------------------------
BOOL WINAPI CertImportSafeContents(
	HCERTSTORE					hCertStore,					// in
	SAFE_CONTENTS				*pSafeContents,				// in
	DWORD						dwCertAddDisposition,		// in
	IMPORT_SAFE_CALLBACK_STRUCT* ImportSafeCallbackStruct,	// in
	DWORD						dwFlags,					// in
	void						*pvAuxInfo					// in
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\pfxlib\pfxmain.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pfxmain.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"

#include <wincrypt.h>
#include "pfxhelp.h"
#include "pfxcmn.h"
#include "pfxcrypt.h"
#include "pfx.h"
#include "impexppk.h"
#include "encdecpk.h"
#include <rpcdce.h>

HINSTANCE           g_hInst;


BOOL   
WINAPI   
CryptPFXDllMain(
        HMODULE hInst, 
        ULONG ul_reason_for_call,
        LPVOID lpReserved)
{

    if (!ImportExportDllMain(hInst, ul_reason_for_call, lpReserved))
    {
        goto ImportExportError;
    }

    if (!EncodeDecodeDllMain(hInst, ul_reason_for_call, lpReserved))
    {
        goto EncodeDecodeError;
    }

    switch( ul_reason_for_call ) 
    {
    case DLL_PROCESS_ATTACH:
        g_hInst = hInst;

        if (!InitPFX())
            goto InitPFXError;
        if (!InitNSCP())
            goto InitNSCPError;

        break;

    case DLL_PROCESS_DETACH:
        TerminatePFX();
        TerminateNSCP();
        break;

    default:
        break;
    }


    return TRUE;   

InitNSCPError:
    TerminatePFX();
InitPFXError:
    EncodeDecodeDllMain(hInst, DLL_PROCESS_DETACH, NULL);
EncodeDecodeError:
    ImportExportDllMain(hInst, DLL_PROCESS_DETACH, NULL);
ImportExportError:
    return FALSE;
}



BOOL FreeCryptSafeContents(
	SAFE_CONTENTS *pSafeContents
	)
{
	DWORD i,j,k;


	// loop for each SAFE_BAG
	for (i=0; i<pSafeContents->cSafeBags; i++) {

        if (pSafeContents->pSafeBags[i].pszBagTypeOID)
            SSFree(pSafeContents->pSafeBags[i].pszBagTypeOID);

        if (pSafeContents->pSafeBags[i].BagContents.pbData)
			SSFree(pSafeContents->pSafeBags[i].BagContents.pbData);

		// loop for each attribute
		for (j=0; j<pSafeContents->pSafeBags[i].Attributes.cAttr; j++) {
			
            if (pSafeContents->pSafeBags[i].Attributes.rgAttr[j].pszObjId)
                SSFree(pSafeContents->pSafeBags[i].Attributes.rgAttr[j].pszObjId);

            // l0op for each value
			for (k=0; k<pSafeContents->pSafeBags[i].Attributes.rgAttr[j].cValue; k++) {
				
				if (pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue[k].pbData)
					SSFree(pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue[k].pbData);
			}

			// free the value struct array
			if (pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue)
				SSFree(pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue);
		}

		// free the attribute struct array
		if (pSafeContents->pSafeBags[i].Attributes.rgAttr)
			SSFree(pSafeContents->pSafeBags[i].Attributes.rgAttr);
	}

    if (pSafeContents->pSafeBags)
        SSFree(pSafeContents->pSafeBags);

	return TRUE;
}



BOOL CALLBACK 
Decrypt_Private_Key(
        CRYPT_ALGORITHM_IDENTIFIER  Alg,
        CRYPT_DATA_BLOB             EncrBlob,
        BYTE*                       pbClearText,
        DWORD*                      pcbClearText,
        LPVOID                      pVoidDecrypt)
{
    BOOL    fRet = TRUE;
    DWORD   cbSalt = 0;
    BYTE    *pbSalt = NULL;
    int     iIterationCount;
    int     iEncrType;
    BYTE    *pbTempBuffer = NULL;
    DWORD   cbTempBuffer = 0;
    
    if (0 == strcmp(Alg.pszObjId, szOID_PKCS_12_pbeWithSHA1And40BitRC2)) {
        iEncrType = RC2_40;
    }
    else if (0 == strcmp(Alg.pszObjId, szOID_PKCS_12_pbeWithSHA1And3KeyTripleDES)) {
        iEncrType = TripleDES;
    }
    else
        goto ErrorReturn;

    if (!GetSaltAndIterationCount(
            Alg.Parameters.pbData, 
            Alg.Parameters.cbData,
            &pbSalt,
            &cbSalt,
            &iIterationCount)) {
        goto ErrorReturn;
    }
    
    // since the decode is done in-place, copy the buffer to decode into a temp buffer,
    // we need to use our temp buffer because the decrypt function may do a realloc
    // on the decode buffer
    if (NULL == (pbTempBuffer = (BYTE *) SSAlloc(EncrBlob.cbData)))
        goto ErrorReturn;

    memcpy(pbTempBuffer, EncrBlob.pbData, EncrBlob.cbData);
    cbTempBuffer = EncrBlob.cbData;

    if (!PFXPasswordDecryptData(
            iEncrType, 
            (LPWSTR) pVoidDecrypt,

            iIterationCount,
            pbSalt,      
            cbSalt,

            &pbTempBuffer,
            &cbTempBuffer))
        goto SetPFXDecryptError;

    // if pcbClearText is not 0 and there is not enough space then error out
    if ((0 != *pcbClearText) && (*pcbClearText < cbTempBuffer)){
        *pcbClearText = cbTempBuffer;
        goto Ret;
    }
    else if (0 != *pcbClearText) {
        memcpy(pbClearText, pbTempBuffer, cbTempBuffer);
    }

    *pcbClearText = cbTempBuffer;

    goto Ret;

SetPFXDecryptError:
    SetLastError(NTE_FAIL);
    fRet = FALSE;
    goto Ret;

ErrorReturn:
    fRet = FALSE;
Ret:
    
    if (pbSalt)
        SSFree(pbSalt);

    if (pbTempBuffer)
        SSFree(pbTempBuffer);

    return fRet;
}


typedef struct _ENCRYPT_PRIVATE_PARAM_DATASTRUCT
{
    HCRYPTPROV  hVerifyProv;
    LPCWSTR     szPwd;
} ENCRYPT_PRIVATE_PARAM_DATASTRUCT, *PENCRYPT_PRIVATE_PARAM_DATASTRUCT;


BOOL CALLBACK 
Encrypt_Private_Key(
        CRYPT_ALGORITHM_IDENTIFIER* pAlg,
        CRYPT_DATA_BLOB*            pClearTextPrivateKey,
        BYTE*                       pbEncryptedKey,
        DWORD*                      pcbEncryptedKey,
        LPVOID                      pVoidEncrypt)
{
    BOOL    fRet = TRUE;
    DWORD   cbSalt = 0;
    BYTE    *pbSalt = NULL;
    int     iIterationCount;
    int     iEncrType;
    BYTE    *pbTempBuffer = NULL;
    DWORD   cbTempBuffer = 0;

    // crack param
    ENCRYPT_PRIVATE_PARAM_DATASTRUCT* pParam = (ENCRYPT_PRIVATE_PARAM_DATASTRUCT*)pVoidEncrypt;
    HCRYPTPROV  hVerifyProv = pParam->hVerifyProv;
    LPCWSTR     szPwd = pParam->szPwd;
    
    // use hardcoded params
    iEncrType = TripleDES;
    iIterationCount = PKCS12_ENCR_PWD_ITERATIONS;
	pbSalt = (BYTE *) SSAlloc(PBE_SALT_LENGTH);
    if (pbSalt == NULL)
        goto SetPFXAllocError;

	cbSalt = PBE_SALT_LENGTH;

	if (!CryptGenRandom(hVerifyProv, cbSalt, pbSalt))
		goto ErrorReturn;

    // out param
    pAlg->pszObjId = szOID_PKCS_12_pbeWithSHA1And3KeyTripleDES;

    if (!SetSaltAndIterationCount(
            &pAlg->Parameters.pbData, 
            &pAlg->Parameters.cbData,
            pbSalt,
            cbSalt,
            iIterationCount)) {
        goto ErrorReturn;
    }
    
    // since the decode is done in-place, copy the buffer to decode into a temp buffer,
    // we need to use our temp buffer because the decrypt function may do a realloc
    // on the decode buffer
    if (NULL == (pbTempBuffer = (BYTE *) SSAlloc(pClearTextPrivateKey->cbData)))
        goto SetPFXAllocError;

    CopyMemory(pbTempBuffer, pClearTextPrivateKey->pbData, pClearTextPrivateKey->cbData);
    cbTempBuffer = pClearTextPrivateKey->cbData;

    if (!PFXPasswordEncryptData(
            iEncrType, 
            szPwd,

            (pbEncryptedKey == NULL) ? 1 : iIterationCount,     // don't bother iterating if we're just sizing
            pbSalt,      
            cbSalt,

            &pbTempBuffer,
            &cbTempBuffer))
        goto SetPFXDecryptError;

    // if pcbEncryptedKey is not 0 and there is not enough space then error out
    if  (pbEncryptedKey == NULL)
    {
        // just sizing; return cb
        *pcbEncryptedKey = cbTempBuffer;
        goto Ret;
    }
    else if (*pcbEncryptedKey < cbTempBuffer)
    {
        // buffer passed in too small
        *pcbEncryptedKey = cbTempBuffer;
        goto ErrorReturn;
    }
    else
    {
        // buffer sufficient
        memcpy(pbEncryptedKey, pbTempBuffer, cbTempBuffer);
        *pcbEncryptedKey = cbTempBuffer;
    }


    goto Ret;

SetPFXDecryptError:
    SetLastError(NTE_FAIL);
    fRet = FALSE;
    goto Ret;

SetPFXAllocError:
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    fRet = FALSE;
    goto Ret;

ErrorReturn:
    fRet = FALSE;
Ret:
    
    if (pbSalt)
        SSFree(pbSalt);

    if (pbTempBuffer)
        SSFree(pbTempBuffer);

    return fRet;
}


BOOL 
GetNamedProviderType(
    LPCWSTR pwszProvName,
    DWORD   *pdwProvType)
{
    BOOL    fResult = FALSE;
    LPWSTR  pwszTempProvName;
    DWORD   cbTempProvName;
    DWORD   dwProvType;
    DWORD   dwProvIndex;

    for (dwProvIndex = 0; TRUE; dwProvIndex++) 
    {
        cbTempProvName = 0;
        dwProvType = 0;
        pwszTempProvName = NULL;

        if (!CryptEnumProvidersU(
                dwProvIndex,
                NULL,               // pdwReserved
                0,                  // dwFlags
                &dwProvType,
                NULL,               // pwszProvName,
                &cbTempProvName
                ) || 0 == cbTempProvName) 
        {
            if (ERROR_NO_MORE_ITEMS != GetLastError())
            {
                break;
            }
        }
        
        if (NULL == (pwszTempProvName = (LPWSTR) SSAlloc(
                (cbTempProvName + 1) * sizeof(WCHAR))))
        {
            break;
        }

        if (!CryptEnumProvidersU(
                dwProvIndex,
                NULL,               // pdwReserved
                0,                  // dwFlags
                &dwProvType,
                pwszTempProvName,
                &cbTempProvName
                )) 
        {
            SSFree(pwszTempProvName);
            break;
        }

        if (0 == wcscmp(pwszTempProvName, pwszProvName))
        {
            *pdwProvType = dwProvType;
            fResult = TRUE;
            SSFree(pwszTempProvName);
            break;
        }

        SSFree(pwszTempProvName);
    }

    return fResult;
}

BOOL CALLBACK
HCryptProv_Query_Func(
	CRYPT_PRIVATE_KEY_INFO	*pPrivateKeyInfo,
	DWORD				dwSafeBagIndex,		
	HCRYPTPROV			*phCryptProv,
	LPVOID				pVoidhCryptProvQuery,
    DWORD               dwPFXImportFlags
	)
{
    DWORD           dwErr = ERROR_SUCCESS;

    SAFE_CONTENTS *pSafeContents = (SAFE_CONTENTS *) pVoidhCryptProvQuery;
	DWORD i = 0;
	WCHAR			szName[256];
    DWORD           dwLocalMachineFlag = 0;
    GUID            guidContainerName;
    DWORD           cbProviderName = 0;
    CERT_NAME_VALUE *providerName = NULL;
    LPWSTR          szSizeDeterminedProvider = NULL;
    DWORD           dwKeyBitLen;
    DWORD           dwProvType;
    RPC_STATUS      rpcStatus;

    // UNDONE: support other than RSA or DSA keys
    if ((pPrivateKeyInfo->Algorithm.pszObjId) &&
        !(  (0 == strcmp(pPrivateKeyInfo->Algorithm.pszObjId, szOID_RSA_RSA)) ||
            (0 == strcmp(pPrivateKeyInfo->Algorithm.pszObjId, szOID_ANSI_X942_DH)) ||
            (0 == strcmp(pPrivateKeyInfo->Algorithm.pszObjId, szOID_OIWSEC_dsa)) ||
            (0 == strcmp(pPrivateKeyInfo->Algorithm.pszObjId, szOID_X957_DSA))))
    {
        SetLastError(NTE_BAD_ALGID);
        goto ErrorReturn;
    }

    // generate a GUID as the containter name for the keyset being imported
    rpcStatus = UuidCreate(&guidContainerName);
    if ((rpcStatus != RPC_S_OK) && (rpcStatus != RPC_S_UUID_LOCAL_ONLY))
    {
        SetLastError(rpcStatus);
        goto ErrorReturn;
    }
    guid2wstr(&guidContainerName, &(szName[0]));

    // get the provider name
    while ((i<pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.cAttr) && 
		(strcmp(pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[i].pszObjId, szOID_PKCS_12_KEY_PROVIDER_NAME_ATTR) != 0)) {
		i++;
	}

    // check to see if a provider name was found
    if (i<pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.cAttr)
    {
	    // decode the provider name
	    if (!CryptDecodeObject(
			    X509_ASN_ENCODING,
			    X509_UNICODE_ANY_STRING,
			    pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[i].rgValue[0].pbData,
			    pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[i].rgValue[0].cbData,
			    0,
			    NULL,
			    &cbProviderName)) {
		    goto ErrorReturn;
	    }

	    if (NULL == (providerName = (CERT_NAME_VALUE *) SSAlloc(cbProviderName)))
		    goto SetPFXAllocError;
	    
	    // decode the provider name
	    if (!CryptDecodeObject(
			    X509_ASN_ENCODING,
			    X509_UNICODE_ANY_STRING,
			    pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[i].rgValue[0].pbData,
			    pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[i].rgValue[0].cbData,
			    0,
			    (BYTE *) providerName,
			    &cbProviderName)) {
		    goto ErrorReturn;
	    }
    }
    
    // check to see if the szOID_LOCAL_MACHINE_KEYSET OID is present
    i = 0;
	while ((i<pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.cAttr) && 
		(strcmp(pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[i].pszObjId, szOID_LOCAL_MACHINE_KEYSET) != 0)) {
		i++;
	}
    if (i<pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.cAttr)
    {
        dwLocalMachineFlag = CRYPT_MACHINE_KEYSET;    
    }

    // regardless of whether the CRYPT_MACHINE_KEYSET property was in the pfx blob,
    // if the caller specifies a preference of user or local machine honor that
    // preference ultimately
    if (dwPFXImportFlags & CRYPT_MACHINE_KEYSET)
    {
        dwLocalMachineFlag = CRYPT_MACHINE_KEYSET; 
    }
    else if (dwPFXImportFlags & CRYPT_USER_KEYSET)
    {
        dwLocalMachineFlag = 0;
    }

    // still don't know where to put this: need keysize to determine
    if ((NULL == providerName) && (0 == strcmp(pPrivateKeyInfo->Algorithm.pszObjId, szOID_RSA_RSA)))
    {
        PBYTE pbRSAPrivateKey = NULL;
        DWORD cbRSAPrivateKey;

        // decode the rsa der-encoded keyblob into a CAPI type keyblob
	    if (!CryptDecodeObject(X509_ASN_ENCODING,
						    PKCS_RSA_PRIVATE_KEY,
						    pPrivateKeyInfo->PrivateKey.pbData,
						    pPrivateKeyInfo->PrivateKey.cbData,
						    CRYPT_DECODE_NOCOPY_FLAG,
						    NULL,
						    &cbRSAPrivateKey))
		    goto ErrorReturn;

	    if (NULL == (pbRSAPrivateKey = (BYTE *) SSAlloc(cbRSAPrivateKey)))
		    goto SetPFXAllocError;

	    if (!CryptDecodeObject(X509_ASN_ENCODING,
						    PKCS_RSA_PRIVATE_KEY,
						    pPrivateKeyInfo->PrivateKey.pbData,
						    pPrivateKeyInfo->PrivateKey.cbData,
						    CRYPT_DECODE_NOCOPY_FLAG,
						    pbRSAPrivateKey,
						    &cbRSAPrivateKey))
        {
		    if (pbRSAPrivateKey)
                SSFree(pbRSAPrivateKey);

            goto ErrorReturn;
        }

        dwKeyBitLen = 
		    ((RSAPUBKEY*) (pbRSAPrivateKey + sizeof(BLOBHEADER)) )->bitlen;

        szSizeDeterminedProvider = (dwKeyBitLen <= 1024) ? MS_DEF_PROV_W : MS_ENHANCED_PROV_W;

        ZeroMemory(pbRSAPrivateKey, cbRSAPrivateKey);
        SSFree(pbRSAPrivateKey); 
    }
    
    if (0 == strcmp(pPrivateKeyInfo->Algorithm.pszObjId, szOID_RSA_RSA))
    {
        if ((providerName == NULL) || (!GetNamedProviderType((LPWSTR)providerName->Value.pbData, &dwProvType)))
        {
            dwProvType = PROV_RSA_FULL;
        }

        // if we have a prov name AND acq works, we're done
        // try prov name if given to us
        if (CryptAcquireContextU(
                        phCryptProv,
                        szName,                                 
                        (providerName != NULL) ? (LPWSTR)providerName->Value.pbData : szSizeDeterminedProvider,
                        dwProvType,
                        dwLocalMachineFlag | CRYPT_NEWKEYSET  ))
            goto CommonReturn;

        // otherwise attempt default
        if (CryptAcquireContextU(
                        phCryptProv,
                        szName,                                 
                        NULL, 
                        PROV_RSA_FULL,
                        dwLocalMachineFlag | CRYPT_NEWKEYSET  ))
            goto CommonReturn;

        // Neither succeeded; fail
    }
    else
    {
        if ((providerName == NULL) || (!GetNamedProviderType((LPWSTR)providerName->Value.pbData, &dwProvType)))
        {
            dwProvType = PROV_DSS_DH;
        }
        
        if (CryptAcquireContextU(
                        phCryptProv,
                        szName,                                 
                        (providerName != NULL) ? (LPWSTR)providerName->Value.pbData : MS_DEF_DSS_DH_PROV_W,
                        dwProvType,
                        dwLocalMachineFlag | CRYPT_NEWKEYSET  ))
        {
            goto CommonReturn;
        }
        else if (CryptAcquireContextU(
                        phCryptProv,
                        szName,                                 
                        NULL, 
                        PROV_DSS_DH,
                        dwLocalMachineFlag | CRYPT_NEWKEYSET  ))
        {
            goto CommonReturn;
        }


        // did not succeed, so fail
    }

ErrorReturn:
    dwErr = GetLastError();
    goto CommonReturn;

SetPFXAllocError:
    dwErr = ERROR_NOT_ENOUGH_MEMORY;
    goto CommonReturn;

CommonReturn:
	
    if (providerName)
        SSFree(providerName);

    return (ERROR_SUCCESS == dwErr);
}


IMPORT_SAFE_CALLBACK_STRUCT g_sImportCallbacks = {HCryptProv_Query_Func, NULL, Decrypt_Private_Key, NULL};



//+-------------------------------------------------------------------------
//	PFXImportCertStore
//
//  Import the PFX blob and return a store containing certificates
//
//  if the password parameter is incorrect or any other problems decoding
//  the PFX blob are encountered, the function will return NULL and the
//	error code can be found from GetLastError(). 
//
//  The dwFlags parameter may be set to:
//  CRYPT_EXPORTABLE - which would then specify that any imported keys should 
//     be marked as exportable (see documentation on CryptImportKey)
//  CRYPT_USER_PROTECTED - (see documentation on CryptImportKey)
//  PKCS12_NO_DATA_COMMIT - will unpack the pfx blob but does not persist its contents.
//                       In this case, returns BOOL indicating successful unpack.
//  CRYPT_MACHINE_KEYSET - used to force the private key to be stored in the
//                        the local machine and not the current user.
//  CRYPT_USER_KEYSET - used to force the private key to be stored in the
//                      the current user and not the local machine, even if
//                      the pfx blob specifies that it should go into local machine.
//--------------------------------------------------------------------------
#define PKCS12_NO_DATA_COMMIT     0x10000000  // unpack but don't persist results

HCERTSTORE
WINAPI
PFXImportCertStore(
    CRYPT_DATA_BLOB* pPFX,
    LPCWSTR szPassword,
    DWORD   dwFlags)
{
    BOOL    fRet = FALSE;
    BOOL    fDataCommit = TRUE;
    HPFX    hPfx = NULL;
    HCERTSTORE hStore = NULL;
    SAFE_CONTENTS sContents; MAKEZERO(sContents);
    SAFE_CONTENTS *pSafeContents = NULL; 
    LPCWSTR szOldNetscapeNull = L"";
    LPCWSTR  szNetscapePassword = NULL;

    if (dwFlags & 
            ~(  CRYPT_EXPORTABLE | CRYPT_USER_PROTECTED | PKCS12_NO_DATA_COMMIT |
                CRYPT_MACHINE_KEYSET | CRYPT_USER_KEYSET))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    if ((pPFX == NULL)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    // shall we commit the data we unpack? 
    if (PKCS12_NO_DATA_COMMIT == (dwFlags & PKCS12_NO_DATA_COMMIT))
    {
        // no
        fDataCommit = FALSE;
    }
    else
    {
        // yes, open a store to populate
        hStore = CertOpenStore(
                    CERT_STORE_PROV_MEMORY, 
                    0,
                    NULL,
                    0, 
                    NULL);
    }
    
    // try to import as real PKCS12
    if (NULL != (hPfx = 
        PfxImportBlob (
            szPassword,
            pPFX->pbData,
            pPFX->cbData,
            dwFlags)) )
    {
        // break out if not saving data
        if (!fDataCommit)
        {
            fRet = TRUE;
            goto Ret;
        }

        // import all private keys and certs
        if (PfxGetKeysAndCerts(hPfx, &sContents))
        {
            g_sImportCallbacks.pVoidhCryptProvQuery = &sContents;
            g_sImportCallbacks.pVoidDecryptFunc = (void *) szPassword;

            if (!CertImportSafeContents(
                    hStore,
                    &sContents,
                    CERT_STORE_ADD_ALWAYS,
                    &g_sImportCallbacks,
                    dwFlags,
                    NULL))
                goto Ret;
        }   
    }
    else 
    {
	if (GetLastError() == CRYPT_E_BAD_ENCODE)
        {
	    // that decode failed; try an old netscape version

            // if the password is NULL then use L"" because that is what 
            // Netscape did in their old version, otherwise just use the password passed in
            if (szPassword == NULL) 
                szNetscapePassword = szOldNetscapeNull;
            else
                szNetscapePassword = szPassword;

            if (NSCPImportBlob(
		szNetscapePassword,
		pPFX->pbData,
		pPFX->cbData,
		&pSafeContents)) 
            { 

                // break out if not saving data
                if (!fDataCommit)
                {
                    fRet = TRUE;
                    goto Ret;
                }
        
                g_sImportCallbacks.pVoidhCryptProvQuery = pSafeContents;
        
	        if (!CertImportSafeContents( 
                            hStore,
                            pSafeContents,
                            CERT_STORE_ADD_ALWAYS,
                            &g_sImportCallbacks,
                            dwFlags,
			    NULL))
                        goto Ret;
        
	        SSFree(pSafeContents);
            }
            else	// nscp import fail
	        goto Ret;
        }
        else 
        {
	    // pfx import fail, not a decoding error
	    goto Ret;
        }
    }

    fRet = TRUE;
Ret:

    if (hPfx)
        PfxCloseHandle(hPfx);

    FreeCryptSafeContents(&sContents);

    if (!fRet)
    {
        if (hStore)
        {
            CertCloseStore(hStore, 0);
            hStore = NULL;
        }
    }

    if (fDataCommit)
        return hStore;
    else
        return (HCERTSTORE)(ULONG_PTR) fRet;
}


EXPORT_SAFE_CALLBACK_STRUCT g_sExportCallbacks = { Encrypt_Private_Key, NULL };


//+-------------------------------------------------------------------------
//      PFXExportCertStoreEx
//
//  Export the certificates and private keys referenced in the passed-in store 
//
//  This API encodes the blob under a stronger algorithm. The resulting
//  PKCS12 blobs are incompatible with the earlier APIs.
//
//  The value passed in the password parameter will be used to encrypt and 
//  verify the integrity of the PFX packet. If any problems encoding the store
//  are encountered, the function will return FALSE and the error code can 
//  be found from GetLastError(). 
//
//  The dwFlags parameter may be set to any combination of 
//      EXPORT_PRIVATE_KEYS
//      REPORT_NO_PRIVATE_KEY
//      REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY
//  These flags are as documented in the CertExportSafeContents Crypt32 API
//--------------------------------------------------------------------------
BOOL
WINAPI
PFXExportCertStoreEx(
    HCERTSTORE hStore,
    CRYPT_DATA_BLOB* pPFX,
    LPCWSTR szPassword,
    void*   pvReserved,
    DWORD   dwFlags)
{
    return 
    PFXExportCertStore(
        hStore,
        pPFX,
        szPassword,
        (dwFlags | PKCS12_ENHANCED_STRENGTH_ENCODING) );
}

//+-------------------------------------------------------------------------
//	PFXExportCertStore
//
//  Export the certificates and private keys referenced in the passed-in store 
//
//  This is an old API kept for compatibility with IE4 clients. New applications
//  should call PfxExportCertStoreEx for enhanced security.
//
//  The value passed in the password parameter will be used to encrypt and 
//  verify the integrity of the PFX packet. If any problems encoding the store
//  are encountered, the function will return FALSE and the error code can 
//  be found from GetLastError(). 
//
//  The dwFlags parameter may be set to any combination of 
//      EXPORT_PRIVATE_KEYS
//      REPORT_NO_PRIVATE_KEY
//      REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY
//      PKCS12_ENHANCED_STRENGTH_ENCODING (used only by ExportCertStoreEx)
//  These flags are as documented in the CertExportSafeContents Crypt32 API
//--------------------------------------------------------------------------

BOOL
WINAPI
PFXExportCertStore(
    HCERTSTORE hStore,
    CRYPT_DATA_BLOB* pPFX,
    LPCWSTR szPassword,
    DWORD   dwFlags)
{
    BOOL    fRet = FALSE;
    SAFE_CONTENTS* pContents = NULL;
    DWORD cbContents = 0;
    HPFX  hPfx = NULL;
    HCRYPTPROV hCrypt = NULL;
    ENCRYPT_PRIVATE_PARAM_DATASTRUCT sParam;

	PCCERT_CONTEXT	pBadCert = NULL;

    if (dwFlags & 
            ~(  EXPORT_PRIVATE_KEYS |
                REPORT_NO_PRIVATE_KEY | 
                REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY |
                PKCS12_ENHANCED_STRENGTH_ENCODING ))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    if ((hStore == NULL) ||
        (pPFX == NULL)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    // get HCRYPTPROV for rng 
    if (!CryptAcquireContextA(&hCrypt, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
        goto Ret;

    sParam.hVerifyProv = hCrypt;
    sParam.szPwd = szPassword;
    g_sExportCallbacks.pVoidEncryptFunc = &sParam;

    if (!CertExportSafeContents(
            hStore,
            pContents,
            &cbContents,
            &g_sExportCallbacks,
            dwFlags | PFX_MODE,
            &pBadCert,
            NULL))
        goto Ret;
    pContents = (SAFE_CONTENTS*)SSAlloc(cbContents);
    if (pContents == NULL)
        goto Ret;

    if (!CertExportSafeContents(
            hStore,
            pContents,
            &cbContents,
            &g_sExportCallbacks,
            (pPFX->cbData != 0) ? dwFlags | PFX_MODE | GIVE_ME_DATA : dwFlags | PFX_MODE,
            &pBadCert,
            NULL))
        goto Ret;


    if (NULL == (hPfx = PfxExportCreate(szPassword)) )
        goto Ret;

    if (!PfxAddSafeBags(hPfx, pContents->pSafeBags, pContents->cSafeBags))
        goto Ret;

    // export
    if (!PfxExportBlob(
            hPfx, 
            pPFX->pbData, 
            &pPFX->cbData, 
            dwFlags))
        goto Ret;

    fRet = TRUE;
Ret: 
    
    if (pBadCert != NULL)
        CertFreeCertificateContext(pBadCert);

    if (pContents)
        SSFree(pContents);

    if (hPfx)
        PfxCloseHandle(hPfx);

    if (hCrypt)
    {
        HRESULT hr = GetLastError();
        CryptReleaseContext(hCrypt, 0);
        SetLastError(hr);
    }

    return fRet;
}



//+-------------------------------------------------------------------------
//      IsPFXBlob
//
//  This function will try to decode the outer layer of the blob as a pfx 
//  blob, and if that works it will return TRUE, it will return FALSE otherwise
//
//--------------------------------------------------------------------------
BOOL
WINAPI
PFXIsPFXBlob(
    CRYPT_DATA_BLOB* pPFX)
{
    
    if (IsRealPFXBlob(pPFX))
    {
        return TRUE;
    }

    if (IsNetscapePFXBlob(pPFX))
    {
        return TRUE;
    }	

    return FALSE;
}

                           
//+-------------------------------------------------------------------------
//      VerifyPassword
//
//  This function will attempt to decode the outer layer of the blob as a pfx 
//  blob and decrypt with the given password. No data from the blob will be imported.
//  Return value is TRUE if password appears correct, FALSE otherwise.
//
//--------------------------------------------------------------------------
BOOL 
WINAPI
PFXVerifyPassword(
    CRYPT_DATA_BLOB* pPFX,
    LPCWSTR szPassword,
    DWORD dwFlags)
{
    // uses overloaded ImportCertStore API
    HCERTSTORE h;
    h = PFXImportCertStore(
        pPFX,
        szPassword,
        PKCS12_NO_DATA_COMMIT);

    return (h==NULL) ? FALSE:TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\pfxlib\pfxnscp.h ===
/* Copyright (C) Microsoft Corporation, 1996 - 1999 All rights reserved. */
/* ASN.1 definitions for PFXNSCP */

#ifndef _PFXNSCP_Module_H_
#define _PFXNSCP_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef ASN1objectidentifier2_t ObjectID;

typedef ASN1objectidentifier2_t ObjID;

typedef ASN1int32_t Version;
#define Version_v1 1

typedef ObjectID ContentType;

typedef ASN1octetstring_t RSAData;
#define RSAData_PDU 0
#define SIZE_PFXNSCP_Module_PDU_0 sizeof(RSAData)

typedef ASN1open_t Attribute;

typedef ASN1octetstring_t EncryptedContent;

typedef ASN1octetstring_t Digest;

typedef ObjID TransportMode;

typedef struct BaggageItem_unencryptedSecrets {
    ASN1uint32_t count;
    struct SafeBag *value;
} BaggageItem_unencryptedSecrets;

typedef struct BaggageItem_espvks {
    ASN1uint32_t count;
    struct ESPVK *value;
} BaggageItem_espvks;

typedef struct ContentInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ContentType contentType;
#   define content_present 0x80
    ASN1open_t content;
} ContentInfo;

typedef struct Attributes {
    ASN1uint32_t count;
    Attribute *value;
} Attributes;
#define Attributes_PDU 1
#define SIZE_PFXNSCP_Module_PDU_1 sizeof(Attributes)

typedef struct AlgorithmIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectID algorithm;
#   define parameters_present 0x80
    ASN1open_t parameters;
} AlgorithmIdentifier;

typedef struct PBEParameter {
    ASN1octetstring_t salt;
    ASN1int32_t iterationCount;
} PBEParameter;
#define PBEParameter_PDU 2
#define SIZE_PFXNSCP_Module_PDU_2 sizeof(PBEParameter)

typedef AlgorithmIdentifier DigestAlgorithmIdentifier;

typedef struct Baggage {
    ASN1uint32_t count;
    struct BaggageItem *value;
} Baggage;

typedef struct BaggageItem {
    BaggageItem_espvks espvks;
    BaggageItem_unencryptedSecrets unencryptedSecrets;
} BaggageItem;

typedef struct PvkAdditional {
    ObjID pvkAdditionalType;
    ASN1open_t pvkAdditionalContent;
} PvkAdditional;
#define PvkAdditional_PDU 3
#define SIZE_PFXNSCP_Module_PDU_3 sizeof(PvkAdditional)

typedef struct SafeContents {
    ASN1uint32_t count;
    struct SafeBag *value;
} SafeContents;
#define SafeContents_PDU 4
#define SIZE_PFXNSCP_Module_PDU_4 sizeof(SafeContents)

typedef struct SafeBag {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjID safeBagType;
    ASN1open_t safeBagContent;
#   define safeBagName_present 0x80
    ASN1char16string_t safeBagName;
} SafeBag;
#define SafeBag_PDU 5
#define SIZE_PFXNSCP_Module_PDU_5 sizeof(SafeBag)

typedef struct KeyBag {
    ASN1uint32_t count;
    struct PrivateKey *value;
} KeyBag;
#define KeyBag_PDU 6
#define SIZE_PFXNSCP_Module_PDU_6 sizeof(KeyBag)

typedef struct CertCRLBag {
    ASN1uint32_t count;
    struct CertCRL *value;
} CertCRLBag;
#define CertCRLBag_PDU 7
#define SIZE_PFXNSCP_Module_PDU_7 sizeof(CertCRLBag)

typedef struct CertCRL {
    ObjID bagId;
    ASN1open_t value;
} CertCRL;
#define CertCRL_PDU 8
#define SIZE_PFXNSCP_Module_PDU_8 sizeof(CertCRL)

typedef struct X509Bag {
    ContentInfo certOrCRL;
} X509Bag;
#define X509Bag_PDU 9
#define SIZE_PFXNSCP_Module_PDU_9 sizeof(X509Bag)

typedef struct SDSICertBag {
    ASN1ztcharstring_t value;
} SDSICertBag;
#define SDSICertBag_PDU 10
#define SIZE_PFXNSCP_Module_PDU_10 sizeof(SDSICertBag)

typedef struct SecretBag {
    ASN1uint32_t count;
    struct Secret *value;
} SecretBag;
#define SecretBag_PDU 11
#define SIZE_PFXNSCP_Module_PDU_11 sizeof(SecretBag)

typedef struct SecretAdditional {
    ObjID secretAdditionalType;
    ASN1open_t secretAdditionalContent;
} SecretAdditional;
#define SecretAdditional_PDU 12
#define SIZE_PFXNSCP_Module_PDU_12 sizeof(SecretAdditional)

typedef AlgorithmIdentifier PrivateKeyAlgorithmIdentifier;

typedef AlgorithmIdentifier EncryptionAlgorithmIdentifier;

typedef AlgorithmIdentifier ContentEncryptionAlgorithmIdentifier;

typedef struct DigestInfo {
    DigestAlgorithmIdentifier digestAlgorithm;
    Digest digest;
} DigestInfo;

typedef struct MacData {
    DigestInfo safeMAC;
    ASN1bitstring_t macSalt;
} MacData;

typedef struct AuthenticatedSafe {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define version_present 0x80
    Version version;
#   define transportMode_present 0x40
    TransportMode transportMode;
#   define privacySalt_present 0x20
    ASN1bitstring_t privacySalt;
#   define baggage_present 0x10
    Baggage baggage;
    ContentInfo safe;
} AuthenticatedSafe;
#define AuthenticatedSafe_PDU 13
#define SIZE_PFXNSCP_Module_PDU_13 sizeof(AuthenticatedSafe)

typedef DigestInfo Thumbprint;

typedef struct Secret {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1char16string_t secretName;
    ObjID secretType;
    ASN1open_t value;
#   define secretAdditional_present 0x80
    SecretAdditional secretAdditional;
} Secret;
#define Secret_PDU 14
#define SIZE_PFXNSCP_Module_PDU_14 sizeof(Secret)

typedef struct PVKSupportingData_assocCerts {
    ASN1uint32_t count;
    Thumbprint *value;
} PVKSupportingData_assocCerts;

typedef struct PrivateKeyInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Version version;
    PrivateKeyAlgorithmIdentifier privateKeyAlgorithm;
    ASN1octetstring_t privateKey;
#   define attributes_present 0x80
    Attributes attributes;
} PrivateKeyInfo;
#define PrivateKeyInfo_PDU 15
#define SIZE_PFXNSCP_Module_PDU_15 sizeof(PrivateKeyInfo)

typedef struct EncryptedContentInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ContentType contentType;
    ContentEncryptionAlgorithmIdentifier contentEncryptionAlg;
#   define encryptedContent_present 0x80
    EncryptedContent encryptedContent;
} EncryptedContentInfo;

typedef struct PFX {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define macData_present 0x80
    MacData macData;
    ContentInfo authSafe;
} PFX;
#define PFX_PDU 16
#define SIZE_PFXNSCP_Module_PDU_16 sizeof(PFX)

typedef struct PVKSupportingData {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PVKSupportingData_assocCerts assocCerts;
#   define regenerable_present 0x80
    ASN1bool_t regenerable;
    ASN1char16string_t nickname;
#   define pvkAdditional_present 0x40
    PvkAdditional pvkAdditional;
} PVKSupportingData;
#define PVKSupportingData_PDU 17
#define SIZE_PFXNSCP_Module_PDU_17 sizeof(PVKSupportingData)

typedef struct PrivateKey {
    PVKSupportingData pvkData;
    PrivateKeyInfo pkcs8data;
} PrivateKey;
#define PrivateKey_PDU 18
#define SIZE_PFXNSCP_Module_PDU_18 sizeof(PrivateKey)

typedef struct EncryptedData {
    Version version;
    EncryptedContentInfo encryptedContentInfo;
} EncryptedData;
#define EncryptedData_PDU 19
#define SIZE_PFXNSCP_Module_PDU_19 sizeof(EncryptedData)

typedef struct ESPVK {
    ObjID espvkObjID;
    PVKSupportingData espvkData;
    ASN1open_t espvkCipherText;
} ESPVK;
#define ESPVK_PDU 20
#define SIZE_PFXNSCP_Module_PDU_20 sizeof(ESPVK)

typedef struct EncryptedPrivateKeyInfo {
    EncryptionAlgorithmIdentifier encryptionAlgorithm;
    EncryptedData encryptedData;
} EncryptedPrivateKeyInfo;
#define EncryptedPrivateKeyInfo_PDU 21
#define SIZE_PFXNSCP_Module_PDU_21 sizeof(EncryptedPrivateKeyInfo)

extern ASN1bool_t PVKSupportingData_regenerable_default;
extern Version AuthenticatedSafe_version_default;
extern ASN1objectidentifier2_t rsa1;
extern ASN1objectidentifier2_t pkcs_12;
extern ASN1objectidentifier2_t pkcs_12ModeIds;
extern ASN1objectidentifier2_t off_lineTransportMode;

extern ASN1module_t PFXNSCP_Module;
extern void ASN1CALL PFXNSCP_Module_Startup(void);
extern void ASN1CALL PFXNSCP_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _PFXNSCP_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\pfxlib\pfxfmt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pfx.cpp
//
//  Contents:   PFX: Personal Information Exchange.
//
//  Functions:
//
//  History:    02-Aug-96    kevinr   created
//              01-May-97    mattt    modified for pstore provider usage
//              07-Jul-97    mattt    modified for crypt32 inclusion
//
//--------------------------------------------------------------------------
#include "global.hxx"

#define _PFX_SOURCE_

extern "C" {
#include "pfxpkcs.h"    // ASN1-generated
}

#include "pfxhelp.h"
#include "pfxcmn.h"
#include "crypttls.h"

#include "pfxcrypt.h"
#include "shacomm.h"
#include "dbgdef.h"

#define CURRENT_PFX_VERSION  0x3


// fwd
BOOL FPFXDumpSafeCntsToHPFX(SafeContents* pSafeCnts, HPFX hpfx);

static HCRYPTASN1MODULE hPFXAsn1Module;

BOOL InitPFX()
{
#ifdef OSS_CRYPT_ASN1
    if (0 == (hPFXAsn1Module = I_CryptInstallAsn1Module(pfxpkcs, 0, NULL)) )
        return FALSE;
#else
    PFXPKCS_Module_Startup();
    if (0 == (hPFXAsn1Module = I_CryptInstallAsn1Module(
            PFXPKCS_Module, 0, NULL))) {
        PFXPKCS_Module_Cleanup();
        return FALSE;
    }
#endif  // OSS_CRYPT_ASN1

    return TRUE;
}

BOOL TerminatePFX()
{
    I_CryptUninstallAsn1Module(hPFXAsn1Module);
#ifndef OSS_CRYPT_ASN1
    PFXPKCS_Module_Cleanup();
#endif  // OSS_CRYPT_ASN1
    return TRUE;
}



static inline ASN1encoding_t GetEncoder(void)
{
    return I_CryptGetAsn1Encoder(hPFXAsn1Module);
}
static inline ASN1decoding_t GetDecoder(void)
{
    return I_CryptGetAsn1Decoder(hPFXAsn1Module);
}


//+-------------------------------------------------------------------------
//  Function:   IPFX_Asn1ToObjectID
//
//  Synopsis:   Convert a dotted string oid to an ASN1 ObjectID
//
//  Returns:    FALSE iff failed
//--------------------------------------------------------------------------
BOOL
IPFX_Asn1ToObjectID(
    IN OID          oid,
    OUT ObjectID    *pooid
)
{
    BOOL            fRet;

    pooid->count = 16;
    if (!PkiAsn1ToObjectIdentifier(
	    oid,
	    &pooid->count,
	    pooid->value))
	goto PkiAsn1ToObjectIdentifierError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    SetLastError(CRYPT_E_OID_FORMAT);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(PkiAsn1ToObjectIdentifierError)
}


//+-------------------------------------------------------------------------
//  Function:   IPFX_Asn1FromObjectID
//
//  Synopsis:   Convert an ASN1 ObjectID to a dotted string oid
//
//  Returns:    FALSE iff failed
//--------------------------------------------------------------------------
BOOL
IPFX_Asn1FromObjectID(
    IN ObjectID     *pooid,
    OUT OID         *poid
)
{
    BOOL        fRet;
    OID         oid = NULL;
    DWORD       cb;

    if (!PkiAsn1FromObjectIdentifier(
	    pooid->count,
	    pooid->value,
	    NULL,
	    &cb))
	goto PkiAsn1FromObjectIdentifierSizeError;
    if (NULL == (oid = (OID)SSAlloc( cb)))
    	goto OidAllocError;
    if (!PkiAsn1FromObjectIdentifier(
	    pooid->count,
	    pooid->value,
	    oid,
	    &cb))
	goto PkiAsn1FromObjectIdentifierError;

    fRet = TRUE;
CommonReturn:
    *poid = oid;
    return fRet;

ErrorReturn:
    SSFree(oid);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(OidAllocError)
SET_ERROR(PkiAsn1FromObjectIdentifierSizeError ,CRYPT_E_OID_FORMAT)
SET_ERROR(PkiAsn1FromObjectIdentifierError     ,CRYPT_E_OID_FORMAT)
}

//+-------------------------------------------------------------------------
//  Function:   IPFX_EqualObjectIDs
//
//  Compare 2 OSS object id's.
//
//  Returns:    FALSE iff !equal
//--------------------------------------------------------------------------
BOOL
WINAPI
IPFX_EqualObjectIDs(
    IN ObjectID     *poid1,
    IN ObjectID     *poid2)
{
    BOOL        fRet;
    DWORD       i;
    PDWORD      pdw1;
    PDWORD      pdw2;

    if (poid1->count != poid2->count)
        goto Unequal;
    for (i=poid1->count, pdw1=poid1->value, pdw2=poid2->value;
            (i>0) && (*pdw1==*pdw2);
            i--, pdw1++, pdw2++)
        ;
    if (i>0)
        goto Unequal;

    fRet = TRUE;        // equal
CommonReturn:
    return fRet;

Unequal:
    fRet = FALSE;       // !equal
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Function:   PfxExportCreate
//
//  Synopsis:   Prepare the PFX for export
//
//  Returns:    NULL iff failed
//--------------------------------------------------------------------------
HPFX
PFXAPI
PfxExportCreate (
    LPCWSTR             szPassword
)
{
    PPFX_INFO       ppfx  = NULL;
    PCCERT_CONTEXT  pcctx = NULL;

    // Create the HPFX
    if (NULL == (ppfx = (PPFX_INFO)SSAlloc(sizeof(PFX_INFO))))
    	goto PfxInfoAllocError;
    ZeroMemory(ppfx, sizeof(PFX_INFO));

    if (szPassword) 
    {
        if (NULL == (ppfx->szPassword = (LPWSTR)SSAlloc(WSZ_BYTECOUNT(szPassword)) ))
    	    goto PfxInfoAllocError;

        CopyMemory(ppfx->szPassword, szPassword, WSZ_BYTECOUNT(szPassword));
    }
    else 
    {
        ppfx->szPassword = NULL;
    }

CommonReturn:
    // free pcctx
    return (HPFX)ppfx;

ErrorReturn:
    PfxCloseHandle((HPFX)ppfx);
    ppfx = NULL;
    goto CommonReturn;

TRACE_ERROR(PfxInfoAllocError)
}



BOOL ASNFreeSafeBag(SafeBag* pBag)
{
    DWORD iAttr, iAnys;

    if (pBag->safeBagAttribs.value)
    {
        if (pBag->safeBagContent.value)
        {
            SSFree(pBag->safeBagContent.value);
            pBag->safeBagContent.value = NULL;
        }

        for (iAttr=0; iAttr<pBag->safeBagAttribs.count; iAttr++)
        {
            for (iAnys=0; iAnys<pBag->safeBagAttribs.value[iAttr].attributeValue.count; iAnys++)
            {
                if (pBag->safeBagAttribs.value[iAttr].attributeValue.value[iAnys].value)
                    SSFree(pBag->safeBagAttribs.value[iAttr].attributeValue.value[iAnys].value);
                
                pBag->safeBagAttribs.value[iAttr].attributeValue.value[iAnys].value = NULL;
            }
    
            SSFree(pBag->safeBagAttribs.value[iAttr].attributeValue.value);
        }

        SSFree(pBag->safeBagAttribs.value);
        pBag->safeBagAttribs.value = NULL;
        pBag->safeBagAttribs.count = 0;
    }
    
    SSFree(pBag);

    return TRUE;
}



//+-------------------------------------------------------------------------
//  Function:  PfxCloseHandle
//
//  Synopsis:  Free all resources associated with the hpfx
//
//  Returns:   error code
//--------------------------------------------------------------------------
BOOL
PFXAPI
PfxCloseHandle (
    IN HPFX hpfx)
{
    BOOL            fRet = FALSE;
    PPFX_INFO       pPfx = (PPFX_INFO)hpfx;
    DWORD           i;

    
    if (pPfx) 
    {
        if (pPfx->szPassword)
            SSFree(pPfx->szPassword);
    
        // keys struct
        for (i=0; i<pPfx->cKeys; i++)
        {
            ASNFreeSafeBag((SafeBag*)pPfx->rgKeys[i]);
            pPfx->rgKeys[i] = NULL;
        }

        SSFree(pPfx->rgKeys);
        pPfx->rgKeys = NULL;
        pPfx->cKeys = 0;

        // shrouded keys
        for (i=0; i<pPfx->cShroudedKeys; i++)
        {
            ASNFreeSafeBag((SafeBag*)pPfx->rgShroudedKeys[i]);
            pPfx->rgShroudedKeys[i] = NULL;
        }

        SSFree(pPfx->rgShroudedKeys);
        pPfx->rgShroudedKeys = NULL;
        pPfx->cShroudedKeys = 0;


        // certcrl struct
        for (i=0; i<pPfx->cCertcrls; i++)
        {
            ASNFreeSafeBag((SafeBag*)pPfx->rgCertcrls[i]);
            pPfx->rgCertcrls[i] = NULL;
        }

        SSFree(pPfx->rgCertcrls);
        pPfx->rgCertcrls = NULL;
        pPfx->cCertcrls = 0;



        // secrets struct
        for (i=0; i<pPfx->cSecrets; i++)
        {
            ASNFreeSafeBag((SafeBag*)pPfx->rgSecrets[i]);
            pPfx->rgSecrets[i] = NULL;
        }

        SSFree(pPfx->rgSecrets);
        pPfx->rgSecrets = NULL;
        pPfx->cSecrets = 0;


        SSFree(pPfx);
    }

    fRet = TRUE;

//Ret:
    return fRet;
}



BOOL
MakeEncodedCertBag(
    BYTE *pbEncodedCert,
    DWORD cbEncodedCert,
    BYTE *pbEncodedCertBag,
    DWORD *pcbEncodedCertBag
    )
{
    
    BOOL            fRet = TRUE;
	DWORD			dwErr;

    OctetStringType encodedCert;
    DWORD           cbCertAsOctetString = 0;
    BYTE            *pbCertAsOctetString = NULL;
    DWORD           dwBytesNeeded = 0;
    CertBag         certBag;
    BYTE            *pbEncoded = NULL;
    DWORD           cbEncoded = 0;
    ASN1encoding_t  pEnc = GetEncoder();

    // wrap the encoded cert in an OCTET_STRING
    encodedCert.length = cbEncodedCert;
    encodedCert.value = pbEncodedCert;

    if (0 != PkiAsn1Encode(
            pEnc,
	        &encodedCert,
	        OctetStringType_PDU,
            &pbCertAsOctetString,
            &cbCertAsOctetString))
	    goto SetPFXEncodeError;
    
    // setup and encode the CertBag
    
    // convert the X509Cert oid from a string to an ASN1 ObjectIdentifier
    if (!IPFX_Asn1ToObjectID(szOID_PKCS_12_x509Cert, &certBag.certType)) {
        goto ErrorReturn;
    }

    certBag.value.length = cbCertAsOctetString;
    certBag.value.value = pbCertAsOctetString;

    if (0 != PkiAsn1Encode(
            pEnc,
	        &certBag,
	        CertBag_PDU,
            &pbEncoded,
            &cbEncoded))
	    goto SetPFXEncodeError;

    // check to see if the caller has enough space for the data
    if ((0 != *pcbEncodedCertBag) && (*pcbEncodedCertBag < cbEncoded)) {
        goto ErrorReturn;
    }
    else if (0 != *pcbEncodedCertBag) {
        memcpy(pbEncodedCertBag, pbEncoded, cbEncoded);
    }
    
    goto CommonReturn;
  
SetPFXEncodeError:
    SetLastError(CRYPT_E_BAD_ENCODE);
ErrorReturn:
    fRet = FALSE;
	    
CommonReturn:

	// save last error from TLS madness
    dwErr = GetLastError();

    *pcbEncodedCertBag = cbEncoded;

    PkiAsn1FreeEncoded(pEnc, pbCertAsOctetString);

    PkiAsn1FreeEncoded(pEnc, pbEncoded);

	// save last error from TLS madness
	SetLastError(dwErr);

    return fRet;
}



BOOL
GetEncodedCertFromEncodedCertBag(
    BYTE    *pbEncodedCertBag,
    DWORD   cbEncodedCertBag,
    BYTE    *pbEncodedCert,
    DWORD   *pcbEncodedCert)
{
    BOOL            fRet = TRUE;
	DWORD			dwErr;

    CertBag         *pCertBag = NULL;
    OID             oid = NULL;
    OctetStringType *pEncodedCert = NULL;
    ASN1decoding_t  pDec = GetDecoder();
    

    // decode the cert bag
    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&pCertBag,
            CertBag_PDU,
            pbEncodedCertBag,
            cbEncodedCertBag))
    	goto SetPFXDecodeError;

    // make sure this is a X509 cert since that is all we support
    if (!IPFX_Asn1FromObjectID(&pCertBag->certType,  &oid))
	    goto ErrorReturn;

    // only support SHA1
    if (0 != strcmp( oid, szOID_PKCS_12_x509Cert))
	    goto SetPFXDecodeError;
 
    // strip off the octet string wrapper of the encoded cert
    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&pEncodedCert,
            OctetStringType_PDU,
            (BYTE *) pCertBag->value.value,
            pCertBag->value.length))
    	goto SetPFXDecodeError;

    // check to see if the caller has enough space for the data
    if ((0 != *pcbEncodedCert) && (*pcbEncodedCert < (DWORD) pEncodedCert->length)) {
        goto ErrorReturn;
    }
    else if (0 != *pcbEncodedCert) {
        memcpy(pbEncodedCert, pEncodedCert->value, pEncodedCert->length);
    }

    goto CommonReturn;

    
SetPFXDecodeError:
	SetLastError(CRYPT_E_BAD_ENCODE);
ErrorReturn:
    fRet = FALSE;
CommonReturn:

	// save last error from TLS madness
    dwErr = GetLastError();

    if (pEncodedCert)
        *pcbEncodedCert = pEncodedCert->length;

    PkiAsn1FreeDecoded(pDec, pCertBag, CertBag_PDU);
    PkiAsn1FreeDecoded(pDec, pEncodedCert, OctetStringType_PDU);

    if (oid)
        SSFree(oid);

	// save last error from TLS madness
    SetLastError(dwErr);

    return fRet;
}


BOOL
GetSaltAndIterationCount(
    BYTE    *pbParameters,
    DWORD   cbParameters,
    BYTE    **ppbSalt,
    DWORD   *pcbSalt,
    int     *piIterationCount
    )
{
    BOOL            fRet = TRUE;
	DWORD			dwErr;

    PBEParameter    *pPBEParameter = NULL;
    ASN1decoding_t  pDec = GetDecoder();
    
    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&pPBEParameter,
            PBEParameter_PDU,
            pbParameters,
            cbParameters))
    	goto SetPFXDecodeError;

    if (NULL == (*ppbSalt = (BYTE *) SSAlloc(pPBEParameter->salt.length))) 
        goto ErrorReturn;

    memcpy(*ppbSalt, pPBEParameter->salt.value, pPBEParameter->salt.length);
    *pcbSalt = pPBEParameter->salt.length;
    *piIterationCount = pPBEParameter->iterationCount;

    goto Ret;

SetPFXDecodeError:
	SetLastError(CRYPT_E_BAD_ENCODE);
    fRet = FALSE;
    goto Ret;

ErrorReturn:
    fRet = FALSE;
Ret:

	// save last error from TLS madness
    dwErr = GetLastError();

    PkiAsn1FreeDecoded(pDec, pPBEParameter, PBEParameter_PDU);

	// save last error from TLS madness
    SetLastError(dwErr);

    return fRet;

}

BOOL
SetSaltAndIterationCount(
    BYTE    **ppbParameters,
    DWORD   *pcbParameters,
    BYTE    *pbSalt,
    DWORD   cbSalt,
    int     iIterationCount
    )
{
    BOOL            fRet = TRUE;
	DWORD			dwErr;

    PBEParameter    sPBEParameter;
    sPBEParameter.salt.length = cbSalt;
    sPBEParameter.salt.value = pbSalt;
    sPBEParameter.iterationCount = iIterationCount;

    BYTE            *pbEncoded = NULL;
    DWORD           cbEncoded;
    ASN1encoding_t  pEnc = GetEncoder();

    if (0 != PkiAsn1Encode(
            pEnc,
            &sPBEParameter,
            PBEParameter_PDU,
            &pbEncoded,
            &cbEncoded))
    	goto SetPFXDecodeError;

    if (NULL == (*ppbParameters = (BYTE *) SSAlloc(cbEncoded))) 
        goto ErrorReturn;

    memcpy(*ppbParameters, pbEncoded, cbEncoded);
    *pcbParameters = cbEncoded;

    goto Ret;

SetPFXDecodeError:
	SetLastError(CRYPT_E_BAD_ENCODE);
    fRet = FALSE;
    goto Ret;

ErrorReturn:
    fRet = FALSE;
Ret:

	// save last error from TLS madness
    dwErr = GetLastError();

    PkiAsn1FreeEncoded(pEnc, pbEncoded);

	// save last error from TLS madness
    SetLastError(dwErr);

    return fRet;

}


///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////

// wrap up data from pfx_info.safeContents area
BOOL 
PFXAPI
PfxExportBlob
(   
    HPFX    hpfx,   
    PBYTE   pbOut,
    DWORD*  pcbOut,
    DWORD   dwFlags
)
{
    BOOL                fRet = FALSE;
    BOOL                fSizeOnly = (pbOut==NULL);

	DWORD				dwErr;
    PPFX_INFO           ppfx = (PPFX_INFO)hpfx;

    BYTE                rgbSafeMac[A_SHA_DIGEST_LEN];
    BYTE                rgbMacSalt[A_SHA_DIGEST_LEN];   

    OID                 oid = NULL;
    EncryptedData       EncrData;           MAKEZERO(EncrData);
    OctetStringType     OctetStr;           MAKEZERO(OctetStr);
    AuthenticatedSafes  AuthSafes;          MAKEZERO(AuthSafes);
    PBEParameter        PbeParam;           MAKEZERO(PbeParam);
	ContentInfo		    rgCntInfo[2];		MAKEZERO(rgCntInfo);
    SafeContents        SafeCnts;           MAKEZERO(SafeCnts);
    PFX                 sPfx;               MAKEZERO(sPfx);

    BYTE                *pbEncoded = NULL;
    DWORD               cbEncoded;
    ASN1encoding_t      pEnc = GetEncoder();

    PBYTE               pbEncrData = NULL;
    DWORD               cbEncrData;

    DWORD               i;

	// multi bags with differing security levels
	int					iLevel, iBagSecurityLevels = 0;
	BOOL				fNoSecurity, fLowSecurity, fHighSecurity;
	DWORD				dwEncrAlg;

    HCRYPTPROV          hVerifyProv = NULL; 

    if (!CryptAcquireContext(&hVerifyProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
        goto ErrorOut;

    // Encode all SafeBags
    fNoSecurity = (ppfx->cShroudedKeys != 0);                   // no encr on these items
	fLowSecurity = ((ppfx->cSecrets + ppfx->cCertcrls) != 0);   // low level crypto on these items
	fHighSecurity = (ppfx->cKeys != 0);	                        // high level crypto on these items

    iBagSecurityLevels = (fNoSecurity ? 1:0) + (fLowSecurity ? 1:0) + (fHighSecurity ? 1:0);
	assert(iBagSecurityLevels <= (sizeof(rgCntInfo)/sizeof(rgCntInfo[0])) );

	for (iLevel=0; iLevel<iBagSecurityLevels; iLevel++)
	{
		// clean up these each time through loop
        if (SafeCnts.value)
		{
			SSFree(SafeCnts.value);
			MAKEZERO(SafeCnts);
		}
        if (PbeParam.salt.value)
        {
            SSFree(PbeParam.salt.value);
            MAKEZERO(PbeParam);
        }
        if (EncrData.encryptedContentInfo.contentEncryptionAlg.parameters.value)
        {
        	PkiAsn1FreeEncoded( pEnc, EncrData.encryptedContentInfo.contentEncryptionAlg.parameters.value);
            MAKEZERO(EncrData);
        }
        if (pbEncrData)
        {
            SSFree(pbEncrData);
            pbEncrData = NULL;
        }


		if (fNoSecurity)
        {
            // no security: bag already shrouded

			SafeCnts.count = ppfx->cShroudedKeys;
			if (NULL == (SafeCnts.value = (SafeBag*) SSAlloc(SafeCnts.count * sizeof(SafeBag)) ))
                goto SetPfxAllocError;

            ZeroMemory(SafeCnts.value, SafeCnts.count * sizeof(SafeBag));

			for (i=0; i<(ppfx->cShroudedKeys); i++)
				CopyMemory(&SafeCnts.value[i], ppfx->rgShroudedKeys[i], sizeof(SafeBag));

			// bag already shrouded!
            dwEncrAlg = 0;

			// done with no security setup
			fNoSecurity = FALSE;
        }
        else if (fLowSecurity)
		{
			DWORD dw = 0;

			// do low security (keys/secrets)
			SafeCnts.count =    ppfx->cSecrets + 
								ppfx->cCertcrls;
			if (NULL == (SafeCnts.value = (SafeBag*) SSAlloc(SafeCnts.count * sizeof(SafeBag)) ))
                goto SetPfxAllocError;

            ZeroMemory(SafeCnts.value, SafeCnts.count * sizeof(SafeBag));

			for (i=0; i<(ppfx->cSecrets); i++, dw++)
				CopyMemory(SafeCnts.value, ppfx->rgSecrets[i], sizeof(SafeBag));
			for (i=0; i<(ppfx->cCertcrls); i++, dw++)
				CopyMemory(&SafeCnts.value[dw], ppfx->rgCertcrls[i], sizeof(SafeBag));

			// encr alg present, type
			EncrData.encryptedContentInfo.contentEncryptionAlg.bit_mask |= parameters_present;
			if (!IPFX_Asn1ToObjectID(szOID_PKCS_12_pbeWithSHA1And40BitRC2, &EncrData.encryptedContentInfo.contentEncryptionAlg.algorithm))
				goto ErrorOut;

			dwEncrAlg = RC2_40;

			// done with low security setup
			fLowSecurity = FALSE;
		}
		else if (fHighSecurity)
		{
            // high security: need strength for unencr keys

			SafeCnts.count = ppfx->cKeys;
			if (NULL == (SafeCnts.value = (SafeBag*) SSAlloc(SafeCnts.count * sizeof(SafeBag)) ))
                goto SetPfxAllocError;

            ZeroMemory(SafeCnts.value, SafeCnts.count * sizeof(SafeBag));

			for (i=0; i<(ppfx->cKeys); i++)
				CopyMemory(&SafeCnts.value[i], ppfx->rgKeys[i], sizeof(SafeBag));


			// encr alg present, type
			EncrData.encryptedContentInfo.contentEncryptionAlg.bit_mask |= parameters_present;
			if (!IPFX_Asn1ToObjectID(szOID_PKCS_12_pbeWithSHA1And3KeyTripleDES, &EncrData.encryptedContentInfo.contentEncryptionAlg.algorithm))
				goto ErrorOut;


			// bag already shrouded!
            dwEncrAlg = TripleDES;

			// done with high security setup
			fHighSecurity = FALSE;
		}
		else
			break;	// no more bags


		// encode safecontents
        if (0 != PkiAsn1Encode(
                pEnc,
				&SafeCnts,
				SafeContents_PDU,
                &pbEncoded,
                &cbEncoded))
			goto SetPFXEncodeError;

        if (dwEncrAlg == 0)
        {
            // no encryption?
            OctetStr.length = cbEncoded;
            OctetStr.value = pbEncoded;

		    // jam octet string into contentInfo
            if (0 != PkiAsn1Encode(
                    pEnc,
				    &OctetStr,
				    OctetStringType_PDU,
                    &pbEncoded,
                    &cbEncoded))
    		    goto SetPFXEncodeError;

            if (OctetStr.value)
            {
                PkiAsn1FreeEncoded(pEnc, OctetStr.value);
                OctetStr.value = NULL;
            }

		    // set up content info struct
		    if (!IPFX_Asn1ToObjectID(
				    szOID_RSA_data,
				    &rgCntInfo[iLevel].contentType))
			    goto ErrorOut;

		    rgCntInfo[iLevel].content.length = cbEncoded;
		    rgCntInfo[iLevel].content.value = pbEncoded;
		    rgCntInfo[iLevel].bit_mask = content_present;
        }
        else
        {
		    cbEncrData = cbEncoded;
		    if (NULL == (pbEncrData = (PBYTE)SSAlloc(cbEncoded)) )
                goto SetPfxAllocError;

		    CopyMemory(pbEncrData, pbEncoded, cbEncrData);
            PkiAsn1FreeEncoded(pEnc, pbEncoded);

            // PBE Param
            PbeParam.iterationCount = PKCS12_ENCR_PWD_ITERATIONS; 
		    if (NULL == (PbeParam.salt.value = (BYTE *) SSAlloc(PBE_SALT_LENGTH) ))
                goto SetPfxAllocError;

		    PbeParam.salt.length = PBE_SALT_LENGTH;

		    if (!CryptGenRandom(hVerifyProv, PBE_SALT_LENGTH, PbeParam.salt.value))
			    goto ErrorOut;

            if (0 != PkiAsn1Encode(
                    pEnc,
				    &PbeParam,
				    PBEParameter_PDU,
                    &pbEncoded,
                    &cbEncoded))
    		    goto SetPFXEncodeError;

		    EncrData.encryptedContentInfo.contentEncryptionAlg.parameters.length = cbEncoded;
		    EncrData.encryptedContentInfo.contentEncryptionAlg.parameters.value = pbEncoded;

		    // ENCRYPT safeContents into encryptedData 
		    // using szPassword (in place)
		    if (!PFXPasswordEncryptData(
				    dwEncrAlg,                      

				    ppfx->szPassword,               // pwd itself

				    (fSizeOnly) ? 1 : PbeParam.iterationCount,  // don't do iterations if only returning size
				    PbeParam.salt.value,            // pkcs5 salt
				    PbeParam.salt.length,

				    &pbEncrData,
				    &cbEncrData))
			    goto SetPFXEncryptError;

		    // encode content to encryptedContentInfo
		    EncrData.encryptedContentInfo.bit_mask |= encryptedContent_present;
		    if (!IPFX_Asn1ToObjectID(szOID_RSA_data, &EncrData.encryptedContentInfo.contentType))
			    goto ErrorOut;
		    EncrData.encryptedContentInfo.encryptedContent.length = cbEncrData;
		    EncrData.encryptedContentInfo.encryptedContent.value = pbEncrData;

            if (0 != PkiAsn1Encode(
                    pEnc,
				    &EncrData,
				    EncryptedData_PDU,
                    &pbEncoded,
                    &cbEncoded))
			    goto SetPFXEncodeError;

		    // jam octet string into contentInfo
		    // set up content info struct
		    if (!IPFX_Asn1ToObjectID(
				    szOID_RSA_encryptedData,
				    &rgCntInfo[iLevel].contentType))
			    goto ErrorOut;

		    rgCntInfo[iLevel].content.length = cbEncoded;
		    rgCntInfo[iLevel].content.value = pbEncoded;
		    rgCntInfo[iLevel].bit_mask = content_present;
        }
	}

    AuthSafes.count = iBagSecurityLevels;
    AuthSafes.value = rgCntInfo;

    // set up authenticated safe struct
    if (0 != PkiAsn1Encode(
            pEnc,
	        &AuthSafes,
	        AuthenticatedSafes_PDU,
            &pbEncoded,
            &cbEncoded))
	    goto SetPFXEncodeError;

    {
        sPfx.macData.bit_mask = macIterationCount_present;
        sPfx.macData.safeMac.digest.length = sizeof(rgbSafeMac);
        sPfx.macData.safeMac.digest.value = rgbSafeMac;

        // COMPATIBILITY MODE: export with macIterationCount == 1
        if (dwFlags & PKCS12_ENHANCED_STRENGTH_ENCODING)
            sPfx.macData.macIterationCount = PKCS12_MAC_PWD_ITERATIONS;
        else
            sPfx.macData.macIterationCount = 1;


        if (!IPFX_Asn1ToObjectID( szOID_OIWSEC_sha1, &sPfx.macData.safeMac.digestAlgorithm.algorithm))
	        goto ErrorOut;

        sPfx.macData.macSalt.length = sizeof(rgbMacSalt);
        sPfx.macData.macSalt.value = rgbMacSalt;

        if (!CryptGenRandom(hVerifyProv, sPfx.macData.macSalt.length, sPfx.macData.macSalt.value))
            goto ErrorOut;
    
        // create MAC
        if (!FGenerateMAC(
                ppfx->szPassword,
                sPfx.macData.macSalt.value,         // pb salt
                sPfx.macData.macSalt.length,        // cb salt
                (fSizeOnly) ? 1 : sPfx.macData.macIterationCount,   // don't do iterations if only returning size
                pbEncoded,                          // pb data
                cbEncoded,                          // cb data
                sPfx.macData.safeMac.digest.value))
            goto SetPFXPasswordError;
    }
    sPfx.bit_mask |= macData_present;
    
    // stream to octet string
    OctetStr.length = cbEncoded;
    OctetStr.value = pbEncoded;
    if (0 != PkiAsn1Encode(
            pEnc,
	        &OctetStr,
	        OctetStringType_PDU,
            &pbEncoded,
            &cbEncoded))
	    goto SetPFXEncodeError;
    
    // take encoded authsafes octet string, encode in PFX pdu
    if (!IPFX_Asn1ToObjectID(
	        szOID_RSA_data,
	        &sPfx.authSafes.contentType))
	    goto ErrorOut;
    sPfx.authSafes.content.length = cbEncoded;
    sPfx.authSafes.content.value = pbEncoded;
    sPfx.authSafes.bit_mask = content_present;
    sPfx.version = CURRENT_PFX_VERSION;
    if (0 != PkiAsn1Encode(
            pEnc,
	        &sPfx,
	        PFX_PDU,
            &pbEncoded,
            &cbEncoded))
	    goto SetPFXEncodeError;

    fRet = TRUE;
    goto Ret;


SetPFXEncodeError:
    SetLastError(CRYPT_E_BAD_ENCODE);
    goto Ret;

SetPFXPasswordError:
    SetLastError(ERROR_INVALID_PASSWORD);
    goto Ret;

SetPFXEncryptError:
    SetLastError(NTE_FAIL);
    goto Ret;

SetPfxAllocError:
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    goto Ret;

ErrorOut:   // error already set; just return failure
Ret:
  	// save last error from TLS madness
    dwErr = GetLastError();
	
	if (hVerifyProv)
        CryptReleaseContext(hVerifyProv, 0);

    if (EncrData.encryptedContentInfo.contentEncryptionAlg.parameters.value)
    	PkiAsn1FreeEncoded( pEnc, EncrData.encryptedContentInfo.contentEncryptionAlg.parameters.value);

    for(iLevel=0; iLevel<iBagSecurityLevels; iLevel++)
	{
		if (rgCntInfo[iLevel].content.value)
			PkiAsn1FreeEncoded( pEnc, rgCntInfo[iLevel].content.value);
	}

    PkiAsn1FreeEncoded(pEnc, OctetStr.value);
    PkiAsn1FreeEncoded(pEnc, sPfx.authSafes.content.value);

    if (pbEncrData)
        SSFree(pbEncrData);

    if (SafeCnts.value)
        SSFree(SafeCnts.value);

    if (PbeParam.salt.value)
        SSFree(PbeParam.salt.value);

    if (fRet)
    {
	    if (pbOut == NULL) 
	    {
	        // report size only
            *pcbOut = cbEncoded;
	    } 
	    else if (*pcbOut < cbEncoded) 
	    {
	        // report that we need a bigger buffer
            *pcbOut = cbEncoded;
            fRet = FALSE;
	    }
	    else 
	    {
	        // give full results
            CopyMemory( pbOut, pbEncoded, cbEncoded);
            *pcbOut = cbEncoded;
	    } 
    }
    else
    	*pcbOut = 0;


    PkiAsn1FreeEncoded(pEnc, pbEncoded);

	// save last error from TLS madness
    SetLastError(dwErr);

    return fRet;
}

HPFX
PFXAPI
PfxImportBlob
(   
    LPCWSTR  szPassword,
    PBYTE   pbIn,
    DWORD   cbIn,
    DWORD   dwFlags
)
{
    PPFX_INFO           ppfx = NULL;
	BOOL				fRet = FALSE;
	DWORD				dwErr;

    int                 iEncrType;
    OID                 oid = NULL;
    DWORD               iAuthSafes;         // # of safes in a pfx bag

    PFX                 *psPfx = NULL;
    OctetStringType     *pOctetString = NULL;
    AuthenticatedSafes  *pAuthSafes = NULL;
    PBEParameter        *pPBEParameter = NULL;
    EncryptedData       *pEncrData = NULL;
    SafeContents        *pSafeCnts = NULL;
    OctetStringType     *pNonEncryptedOctetString = NULL;

    DWORD               cbDecrData;
    PBYTE               pbDecrData = NULL;

    BYTE                *pbEncoded = NULL;
    DWORD               cbEncoded;
    ASN1decoding_t      pDec = GetDecoder();

    // alloc return struct
    if (NULL == (ppfx = (PFX_INFO*)SSAlloc(sizeof(PFX_INFO)) ))
        goto SetPfxAllocError;

    ZeroMemory(ppfx, sizeof(PFX_INFO));


    // Crack the PFX blob
    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&psPfx,
            PFX_PDU,
            pbIn,
            cbIn))
    	goto SetPFXDecodeError;
    
    // check version of the PFX bag
    if (psPfx->version != CURRENT_PFX_VERSION)
	    goto SetPFXDecodeError;

    // info blurted into psPfx(PFX) - ensure content present
    if (0 == (psPfx->authSafes.bit_mask & content_present))
	    goto SetPFXDecodeError;

    // could be data/signeddata
    // UNDONE: only support szOID_RSA_data 
    if (!IPFX_Asn1FromObjectID( &psPfx->authSafes.contentType,  &oid))
	    goto ErrorOut;
    if (0 != strcmp( oid, szOID_RSA_data))
	    goto SetPFXDecodeError;
    SSFree(oid);
    // DSIE: Bug 144526.
    oid = NULL;

    // content is data: decode
    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&pOctetString,
            OctetStringType_PDU,
            (BYTE *) psPfx->authSafes.content.value,
            psPfx->authSafes.content.length))
    	goto SetPFXDecodeError;

    if (0 != (psPfx->bit_mask & macData_present))
    {
        BYTE rgbMAC[A_SHA_DIGEST_LEN];

        if (!IPFX_Asn1FromObjectID( &psPfx->macData.safeMac.digestAlgorithm.algorithm,  &oid))
	        goto ErrorOut;

        // only support SHA1
        if (0 != strcmp( oid, szOID_OIWSEC_sha1))
	        goto SetPFXDecodeError;
        SSFree(oid);
        // DSIE: Bug 144526.
        oid = NULL;

        if (psPfx->macData.safeMac.digest.length != A_SHA_DIGEST_LEN)
            goto SetPFXIntegrityError;

        // check MAC
        // if there is no iterationCount then 1 is the default
        if (!(psPfx->macData.bit_mask & macIterationCount_present))
        {
        if (!FGenerateMAC(
                szPassword,
                psPfx->macData.macSalt.value,   // pb salt
                psPfx->macData.macSalt.length,  // cb salt
                1,
                pOctetString->value,            // pb data
                pOctetString->length,           // cb data
                rgbMAC))
            goto SetPFXIntegrityError;
        }
        else
        {
            if (!FGenerateMAC(
                szPassword,
                psPfx->macData.macSalt.value,   // pb salt
                psPfx->macData.macSalt.length,  // cb salt
                (DWORD)psPfx->macData.macIterationCount,
                pOctetString->value,            // pb data
                pOctetString->length,           // cb data
                rgbMAC))
            goto SetPFXIntegrityError;
        }

        if (0 != memcmp(rgbMAC, psPfx->macData.safeMac.digest.value, A_SHA_DIGEST_LEN))
            goto SetPFXIntegrityError;
    }
    
    // now we have octet string: this is an encoded authSafe
    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&pAuthSafes,
            AuthenticatedSafes_PDU,
            pOctetString->value,
            pOctetString->length))
    	goto SetPFXDecodeError;
    
    // handle multiple safes
    for (iAuthSafes = 0; iAuthSafes < pAuthSafes->count; iAuthSafes++)
    {
        // could be encryptedData/envelopedData

        // check to see if the content is szOID_RSA_encryptedData or szOID_RSA_data
        if (!IPFX_Asn1FromObjectID( &pAuthSafes->value[iAuthSafes].contentType,  &oid))
	        goto ErrorOut;
        if (0 == strcmp( oid, szOID_RSA_encryptedData)) 
        {    
            SSFree(oid);
            // DSIE: Bug 144526.
            oid = NULL;
            
            // decode content to encryptedData
            if (0 != PkiAsn1Decode(
                    pDec,
                    (void **)&pEncrData,
                    EncryptedData_PDU,
                    (BYTE *) pAuthSafes->value[iAuthSafes].content.value,
                    pAuthSafes->value[iAuthSafes].content.length))
    	        goto SetPFXDecodeError;

            // chk version
            if (pEncrData->version != 0)  
                goto SetPFXDecodeError;

            // chk content present, type
            if (0 == (pEncrData->encryptedContentInfo.bit_mask & encryptedContent_present))
                goto SetPFXDecodeError;
            if (!IPFX_Asn1FromObjectID(&pEncrData->encryptedContentInfo.contentType, &oid))
                goto ErrorOut;
            if (0 != strcmp( oid, szOID_RSA_data))
                goto SetPFXDecodeError;
            SSFree(oid);
            // DSIE: Bug 144526.
            oid = NULL;

            // chk encr alg present, type
            if (0 == (pEncrData->encryptedContentInfo.contentEncryptionAlg.bit_mask & parameters_present))
                goto SetPFXDecodeError;
            if (!IPFX_Asn1FromObjectID(&pEncrData->encryptedContentInfo.contentEncryptionAlg.algorithm, &oid))
                goto ErrorOut;

            if (0 != PkiAsn1Decode(
                    pDec,
                    (void **)&pPBEParameter,
                    PBEParameter_PDU,
                    (BYTE *) pEncrData->encryptedContentInfo.contentEncryptionAlg.parameters.value,
                    pEncrData->encryptedContentInfo.contentEncryptionAlg.parameters.length))
    	        goto SetPFXDecodeError;


            if (0 == strcmp( oid, szOID_PKCS_12_pbeWithSHA1And40BitRC2))
            {
                iEncrType = RC2_40;
            }
            else if (0 == strcmp( oid, szOID_PKCS_12_pbeWithSHA1And40BitRC4))
            {
                iEncrType = RC4_40;
            }
            else if (0 == strcmp( oid, szOID_PKCS_12_pbeWithSHA1And128BitRC2))
            {
                iEncrType = RC2_128;
            }
            else if (0 == strcmp( oid, szOID_PKCS_12_pbeWithSHA1And128BitRC4))
            {
                iEncrType = RC4_128;
            }
            else if (0 == strcmp( oid, szOID_PKCS_12_pbeWithSHA1And3KeyTripleDES))
            {
                // FIX - we need to differentiate between 2 and 3 key triple des
                iEncrType = TripleDES;
            }
            else
                goto SetPFXAlgIDError;
            SSFree(oid);
            // DSIE: Bug 144526.
            oid = NULL;

            // DECRYPT encryptedData using szPassword (in place)
            cbDecrData = pEncrData->encryptedContentInfo.encryptedContent.length;
            if (NULL == (pbDecrData = (PBYTE)SSAlloc(pEncrData->encryptedContentInfo.encryptedContent.length)) )
                goto SetPfxAllocError;

            CopyMemory(pbDecrData, pEncrData->encryptedContentInfo.encryptedContent.value, cbDecrData);

            if (!PFXPasswordDecryptData(
                    iEncrType, // encr type
                    szPassword,

                    pPBEParameter->iterationCount,
                    pPBEParameter->salt.value,      // pkcs5 salt
                    pPBEParameter->salt.length,

                    &pbDecrData,
                    (PDWORD)&cbDecrData))
                goto SetPFXDecryptError;
        
            // set up to decode the  SafeContents
            cbEncoded = cbDecrData;
            pbEncoded = pbDecrData;
        }
        else if (0 == strcmp( oid, szOID_RSA_data)) 
        {
            SSFree(oid);
            // DSIE: Bug 144526.
            oid = NULL;

            // strip off the octet string wrapper
            if (0 != PkiAsn1Decode(
                    pDec,
                    (void **)&pNonEncryptedOctetString,
                    OctetStringType_PDU,
                    (BYTE *) pAuthSafes->value[iAuthSafes].content.value,
                    pAuthSafes->value[iAuthSafes].content.length))
    	        goto SetPFXDecodeError;

            // the safe isn't encrypted, so just setup to decode the data as SafeContents
            cbEncoded = pNonEncryptedOctetString->length;
            pbEncoded = pNonEncryptedOctetString->value;
        }
        else 
        {
            SSFree(oid);
	        // DSIE: Bug 144526.
            oid = NULL;
            goto SetPFXDecodeError;
        }
        
        // decode the SafeContents, it is either the plaintext encryptedData or the original data
        if (0 != PkiAsn1Decode(
                pDec,
                (void **)&pSafeCnts,
                SafeContents_PDU,
                pbEncoded,
                cbEncoded))
    	    goto SetPFXDecodeError;

        // tear pSafeCnts apart, mash into ppfx
        if (!FPFXDumpSafeCntsToHPFX(pSafeCnts, ppfx))
             goto SetPFXDecodeError;

        // loop cleanup
        if (pEncrData) {
            PkiAsn1FreeDecoded(pDec, pEncrData, EncryptedData_PDU);
            pEncrData = NULL;
        }

        if (pPBEParameter) {
            PkiAsn1FreeDecoded(pDec, pPBEParameter, PBEParameter_PDU);
            pPBEParameter = NULL;
        }

        if (pNonEncryptedOctetString) {
            PkiAsn1FreeDecoded(pDec, pNonEncryptedOctetString,
                OctetStringType_PDU);
            pNonEncryptedOctetString = NULL;
        }

        PkiAsn1FreeDecoded(pDec, pSafeCnts, SafeContents_PDU);
        pSafeCnts = NULL;
    
        if (pbDecrData)
        {
            SSFree(pbDecrData);
            pbDecrData = NULL;
        }
    }

    fRet = TRUE;
    goto Ret;


SetPFXAlgIDError:
    SetLastError(NTE_BAD_ALGID);
    goto Ret;

SetPFXIntegrityError:
    SetLastError(ERROR_INVALID_PASSWORD);
    goto Ret;


SetPFXDecodeError:
	SetLastError(CRYPT_E_BAD_ENCODE);
    goto Ret;

SetPFXDecryptError:
    SetLastError(NTE_FAIL);
    goto Ret;

SetPfxAllocError:
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    goto Ret;

ErrorOut:
Ret:

	// save any error conditions
	dwErr = GetLastError();

    PkiAsn1FreeDecoded(pDec, psPfx, PFX_PDU);
    PkiAsn1FreeDecoded(pDec, pOctetString, OctetStringType_PDU);
    PkiAsn1FreeDecoded(pDec, pAuthSafes, AuthenticatedSafes_PDU);
    PkiAsn1FreeDecoded(pDec, pEncrData, EncryptedData_PDU);
    PkiAsn1FreeDecoded(pDec, pPBEParameter, PBEParameter_PDU);
    PkiAsn1FreeDecoded(pDec, pSafeCnts, SafeContents_PDU);

    // DSIE: Bug 144526.
    if (oid)
        SSFree(oid);

    if (pbDecrData)
        SSFree(pbDecrData);

    if (!fRet)
    { 
        if (ppfx)
            SSFree(ppfx);

        ppfx = NULL;
    }

	// restore error conditions AFTER GetDecoder() calls, since TLS will clobber
	SetLastError(dwErr);

    return (HPFX)ppfx;
}





BOOL FPFXDumpSafeCntsToHPFX(SafeContents* pSafeCnts, HPFX hpfx)
{
    PPFX_INFO           ppfx = (PPFX_INFO)hpfx;

    // sort and dump bags into correct areas
    ObjectID oKeyBag, oCertBag, oShroudedKeyBag; 
    DWORD dw, iAttr, iAnys;

    ZeroMemory(&oKeyBag, sizeof(ObjectID));
    ZeroMemory(&oCertBag, sizeof(ObjectID));
    ZeroMemory(&oShroudedKeyBag, sizeof(ObjectID));

    if (!IPFX_Asn1ToObjectID( &szOID_PKCS_12_KEY_BAG, &oKeyBag))
	    return FALSE;

    if (!IPFX_Asn1ToObjectID( &szOID_PKCS_12_CERT_BAG, &oCertBag))
	    return FALSE;

    if (!IPFX_Asn1ToObjectID( &szOID_PKCS_12_SHROUDEDKEY_BAG, &oShroudedKeyBag))
	    return FALSE;

    for (dw=0; dw<pSafeCnts->count; dw++)
    {
        SafeBag* pBag;

// new begin            
        // assign value to keys
        if (NULL == (pBag = (SafeBag*)SSAlloc(sizeof(SafeBag)) ))
            goto SetPfxAllocError;

        CopyMemory(pBag, &pSafeCnts->value[dw], sizeof (SafeBag));
        
        // obj id is static

        // alloc content    
        if (NULL == (pBag->safeBagContent.value = (PBYTE)SSAlloc(pBag->safeBagContent.length) ))
            goto SetPfxAllocError;

        CopyMemory(pBag->safeBagContent.value, pSafeCnts->value[dw].safeBagContent.value, pBag->safeBagContent.length);

        // alloc attributes
        if (pBag->bit_mask & safeBagAttribs_present)
        {
            if (NULL == (pBag->safeBagAttribs.value = (Attribute*)SSAlloc(sizeof(Attribute) * pSafeCnts->value[dw].safeBagAttribs.count) ))
                goto SetPfxAllocError;

            for (iAttr=0; iAttr < pSafeCnts->value[dw].safeBagAttribs.count; iAttr++)
            {
                // copy static section of attribute
                CopyMemory(&pBag->safeBagAttribs.value[iAttr], &pSafeCnts->value[dw].safeBagAttribs.value[iAttr], sizeof(Attribute));

                // Alloc Attribute Anys
                if (pSafeCnts->value[dw].safeBagAttribs.value[iAttr].attributeValue.count != 0)
                {
                    if (NULL == (pBag->safeBagAttribs.value[iAttr].attributeValue.value = (Any*)SSAlloc(pSafeCnts->value[dw].safeBagAttribs.value[iAttr].attributeValue.count * sizeof(Any)) ))
                        goto SetPfxAllocError;

                    CopyMemory(pBag->safeBagAttribs.value[iAttr].attributeValue.value, pSafeCnts->value[dw].safeBagAttribs.value[iAttr].attributeValue.value, sizeof(Any));
        
                    for (iAnys=0; iAnys<pBag->safeBagAttribs.value[iAttr].attributeValue.count; iAnys++)
                    {
                        if (NULL == (pBag->safeBagAttribs.value[iAttr].attributeValue.value[iAnys].value = (PBYTE)SSAlloc(pSafeCnts->value[dw].safeBagAttribs.value[iAttr].attributeValue.value[iAnys].length) ))
                            goto SetPfxAllocError;

                        CopyMemory(pBag->safeBagAttribs.value[iAttr].attributeValue.value[iAnys].value, pSafeCnts->value[dw].safeBagAttribs.value[iAttr].attributeValue.value[iAnys].value, pSafeCnts->value[dw].safeBagAttribs.value[iAttr].attributeValue.value[iAnys].length);
                    }
                }
                else
                {
                    pBag->safeBagAttribs.value[iAttr].attributeValue.value = NULL;  
                }
            }
        }
// new end 

        if (IPFX_EqualObjectIDs(&pSafeCnts->value[dw].safeBagType, &oKeyBag) )
        {
            // inc size
            ppfx->cKeys++;
            if (ppfx->rgKeys)
                ppfx->rgKeys = (void**)SSReAlloc(ppfx->rgKeys, ppfx->cKeys * sizeof(SafeBag*));
            else
                ppfx->rgKeys = (void**)SSAlloc(ppfx->cKeys * sizeof(SafeBag*));

            if (ppfx->rgKeys == NULL)
                goto SetPfxAllocError;

            // assign to keys
            ppfx->rgKeys[ppfx->cKeys-1] = pBag;  
        }
        else if (IPFX_EqualObjectIDs(&pSafeCnts->value[dw].safeBagType,
                &oShroudedKeyBag) )
        {
            // inc size
            ppfx->cShroudedKeys++;
            if (ppfx->rgShroudedKeys)
                ppfx->rgShroudedKeys = (void**)SSReAlloc(ppfx->rgShroudedKeys, ppfx->cShroudedKeys * sizeof(SafeBag*));
            else
                ppfx->rgShroudedKeys = (void**)SSAlloc(ppfx->cShroudedKeys * sizeof(SafeBag*));

            if (ppfx->rgShroudedKeys == NULL)
                goto SetPfxAllocError;

            // assign to keys
            ppfx->rgShroudedKeys[ppfx->cShroudedKeys-1] = pBag;  
        }
        else if (IPFX_EqualObjectIDs(&pSafeCnts->value[dw].safeBagType,
                &oCertBag) )
        {
            // inc size
            ppfx->cCertcrls++;
            if (ppfx->rgCertcrls)
                ppfx->rgCertcrls = (void**)SSReAlloc(ppfx->rgCertcrls, ppfx->cCertcrls * sizeof(SafeBag*));
            else
                ppfx->rgCertcrls = (void**)SSAlloc(ppfx->cCertcrls * sizeof(SafeBag*));

            if (ppfx->rgCertcrls == NULL)
                goto SetPfxAllocError;

            // assign to certs/crls
            ppfx->rgCertcrls[ppfx->cCertcrls-1] = pBag;  
        }
        else
        {
            // inc size
            ppfx->cSecrets++;
            if (ppfx->rgSecrets)
                ppfx->rgSecrets = (void**)SSReAlloc(ppfx->rgSecrets, ppfx->cSecrets * sizeof(SafeBag*));
            else
                ppfx->rgSecrets = (void**)SSAlloc(ppfx->cSecrets * sizeof(SafeBag*));

            if (ppfx->rgSecrets == NULL)
                goto SetPfxAllocError;

            // assign to safebag
            ppfx->rgSecrets[ppfx->cSecrets-1] = pBag;
        }
    }

    return TRUE;

SetPfxAllocError:
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return FALSE;
}



BOOL CopyASNtoCryptSafeBag(
    SAFE_BAG*   pCryptBag,
    SafeBag*    pAsnBag)
{
    DWORD iAttrs, iAttr;

    // ensure target is zeroed
    ZeroMemory(pCryptBag, sizeof(SAFE_BAG));

    if (!IPFX_Asn1FromObjectID( &pAsnBag->safeBagType,  &pCryptBag->pszBagTypeOID))
	    return FALSE;

    // copy bag contents
    pCryptBag->BagContents.cbData = pAsnBag->safeBagContent.length;
    if (NULL == (pCryptBag->BagContents.pbData = (PBYTE)SSAlloc(pCryptBag->BagContents.cbData) ))
        goto SetPfxAllocError;

    CopyMemory(pCryptBag->BagContents.pbData, pAsnBag->safeBagContent.value, pCryptBag->BagContents.cbData);

    pCryptBag->Attributes.cAttr = pAsnBag->safeBagAttribs.count;
    if (NULL == (pCryptBag->Attributes.rgAttr = (CRYPT_ATTRIBUTE*)SSAlloc(pCryptBag->Attributes.cAttr * sizeof(CRYPT_ATTRIBUTE)) ))
        goto SetPfxAllocError;

    // sizeof attribute data
    for (iAttrs=0; iAttrs<pAsnBag->safeBagAttribs.count; iAttrs++)
    {
        // pAsnBag->safeBagAttribs.value === attribute struct
        
        if (!IPFX_Asn1FromObjectID( &pAsnBag->safeBagAttribs.value[iAttrs].attributeType,  &pCryptBag->Attributes.rgAttr[iAttrs].pszObjId))
	        continue;

        pCryptBag->Attributes.rgAttr[iAttrs].cValue = pAsnBag->safeBagAttribs.value[iAttrs].attributeValue.count;
        if (NULL == (pCryptBag->Attributes.rgAttr[iAttrs].rgValue = (CRYPT_ATTR_BLOB*)SSAlloc(pAsnBag->safeBagAttribs.value[iAttrs].attributeValue.count * sizeof(CRYPT_ATTR_BLOB)) ))
            goto SetPfxAllocError;

        for (iAttr=0; iAttr<pAsnBag->safeBagAttribs.value[iAttrs].attributeValue.count; iAttr++)
        {
            // alloc and copy: for every attribute in attrs
            pCryptBag->Attributes.rgAttr[iAttrs].rgValue[iAttr].cbData = pAsnBag->safeBagAttribs.value[iAttrs].attributeValue.value[iAttr].length;
            if (NULL == (pCryptBag->Attributes.rgAttr[iAttrs].rgValue[iAttr].pbData = (PBYTE)SSAlloc(pCryptBag->Attributes.rgAttr[iAttrs].rgValue[iAttr].cbData) ))
                goto SetPfxAllocError;

            CopyMemory(pCryptBag->Attributes.rgAttr[iAttrs].rgValue[iAttr].pbData, pAsnBag->safeBagAttribs.value[iAttrs].attributeValue.value[iAttr].value, pCryptBag->Attributes.rgAttr[iAttrs].rgValue[iAttr].cbData);
        }
    }   

    return TRUE;

SetPfxAllocError:
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return FALSE;
}


BOOL CopyCrypttoASNSafeBag(
    SAFE_BAG*   pCryptBag, 
    SafeBag*    pAsnBag)
{
    DWORD iAttrs, iAttr;
    
    // ensure target is zeroed
    ZeroMemory(pAsnBag, sizeof(SafeBag));

    if (!IPFX_Asn1ToObjectID( pCryptBag->pszBagTypeOID, &pAsnBag->safeBagType))
	    return FALSE;

    pAsnBag->safeBagContent.length = pCryptBag->BagContents.cbData;
    if (NULL == (pAsnBag->safeBagContent.value = (PBYTE)SSAlloc(pAsnBag->safeBagContent.length) ))
        goto SetPfxAllocError;

    CopyMemory(pAsnBag->safeBagContent.value, pCryptBag->BagContents.pbData, pAsnBag->safeBagContent.length);
    
    pAsnBag->safeBagAttribs.count = pCryptBag->Attributes.cAttr;
    if (NULL == (pAsnBag->safeBagAttribs.value = (Attribute*) SSAlloc(pAsnBag->safeBagAttribs.count * sizeof(Attribute)) ))
        goto SetPfxAllocError;

    //
    // always set the present bit for backwards compatibility
    //
    pAsnBag->bit_mask = safeBagAttribs_present;

    for (iAttrs=0; iAttrs<pCryptBag->Attributes.cAttr; iAttrs++)
    {
        //pAsnBag->bit_mask = safeBagAttribs_present;

        if (!IPFX_Asn1ToObjectID( pCryptBag->Attributes.rgAttr[iAttrs].pszObjId, &pAsnBag->safeBagAttribs.value[iAttrs].attributeType))
	        continue;

        pAsnBag->safeBagAttribs.value[iAttrs].attributeValue.count = pCryptBag->Attributes.rgAttr[iAttrs].cValue;
        if (NULL == (pAsnBag->safeBagAttribs.value[iAttrs].attributeValue.value = (Any*)SSAlloc(pAsnBag->safeBagAttribs.value[iAttrs].attributeValue.count * sizeof(Any)) ))
            goto SetPfxAllocError;


        for (iAttr=0; iAttr<pCryptBag->Attributes.rgAttr[iAttrs].cValue; iAttr++)
        {
            // for every attribute in attrs
            pAsnBag->safeBagAttribs.value[iAttrs].attributeValue.value[iAttr].length = pCryptBag->Attributes.rgAttr[iAttrs].rgValue[iAttr].cbData;
            if (NULL == (pAsnBag->safeBagAttribs.value[iAttrs].attributeValue.value[iAttr].value = (PBYTE)SSAlloc(pAsnBag->safeBagAttribs.value[iAttrs].attributeValue.value[iAttr].length) ))
                goto SetPfxAllocError;

            CopyMemory(pAsnBag->safeBagAttribs.value[iAttrs].attributeValue.value[iAttr].value, pCryptBag->Attributes.rgAttr[iAttrs].rgValue[iAttr].pbData, pAsnBag->safeBagAttribs.value[iAttrs].attributeValue.value[iAttr].length);
        }
    }
    
    return TRUE;

SetPfxAllocError:
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return FALSE;
}

// new entry points for loading up the HPFX
BOOL PfxGetKeysAndCerts(
    HPFX hPfx, 
    SAFE_CONTENTS* pContents
)
{
    PFX_INFO*   pPfx = (PFX_INFO*)hPfx;
    SafeBag*    pAsnBag;
    SAFE_BAG*   pCryptBag;
    DWORD       iTotal, iBag;
    DWORD       cSafeBags;

    pContents->cSafeBags = 0;
    cSafeBags = pPfx->cKeys + pPfx->cCertcrls + pPfx->cShroudedKeys;
    if (NULL == (pContents->pSafeBags = (SAFE_BAG*)SSAlloc(cSafeBags * sizeof(SAFE_BAG)) )) // make an array of safe bag *s
        goto SetPfxAllocError;

    pContents->cSafeBags = cSafeBags;

    for (iBag=0, iTotal=0; iBag<pPfx->cKeys; iBag++, iTotal++)
    {
        pCryptBag = &pContents->pSafeBags[iTotal];
        pAsnBag = (SafeBag*)pPfx->rgKeys[iBag];

        if (!CopyASNtoCryptSafeBag(pCryptBag, pAsnBag))
            continue;
    }

    iTotal = iBag; 

    for (iBag=0; iBag<pPfx->cShroudedKeys; iBag++, iTotal++)
    {
        pCryptBag = &pContents->pSafeBags[iTotal];
        pAsnBag = (SafeBag*)pPfx->rgShroudedKeys[iBag];

        if (!CopyASNtoCryptSafeBag(pCryptBag, pAsnBag))
            continue;
    }

    for (iBag=0; iBag<pPfx->cCertcrls; iBag++, iTotal++)
    {
        pCryptBag = &pContents->pSafeBags[iTotal];
        pAsnBag = (SafeBag*)pPfx->rgCertcrls[iBag];

        if (!CopyASNtoCryptSafeBag(pCryptBag, pAsnBag))
            continue;
    }

    return TRUE;

SetPfxAllocError:
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return FALSE;
}


BOOL PfxAddSafeBags(
    HPFX hPfx, 
    SAFE_BAG*   pSafeBags, 
    DWORD       cSafeBags
)
{
    PFX_INFO* pPfx = (PFX_INFO*)hPfx;
    DWORD   i;

    for (i=0; i<cSafeBags; i++)
    {
        if (0 == strcmp(pSafeBags[i].pszBagTypeOID, szOID_PKCS_12_KEY_BAG))
        {
            pPfx->cKeys++;
            if (pPfx->rgKeys)
                pPfx->rgKeys = (void**)SSReAlloc(pPfx->rgKeys, pPfx->cKeys*sizeof(SafeBag*));
            else
                pPfx->rgKeys = (void**)SSAlloc(pPfx->cKeys*sizeof(SafeBag*));

            if (pPfx->rgKeys == NULL)
                goto SetPfxAllocError;
                
            if (NULL == (pPfx->rgKeys[pPfx->cKeys-1] = (SafeBag*)SSAlloc(sizeof(SafeBag)) ))
                goto SetPfxAllocError;

            if (!CopyCrypttoASNSafeBag(&pSafeBags[i], (SafeBag*)pPfx->rgKeys[pPfx->cKeys-1]))
                continue;
        }
        else if (0 == strcmp(pSafeBags[i].pszBagTypeOID, szOID_PKCS_12_SHROUDEDKEY_BAG))
        {
            pPfx->cShroudedKeys++;
            if (pPfx->rgShroudedKeys)
                pPfx->rgShroudedKeys = (void**)SSReAlloc(pPfx->rgShroudedKeys, pPfx->cShroudedKeys*sizeof(SafeBag*));
            else
                pPfx->rgShroudedKeys = (void**)SSAlloc(pPfx->cShroudedKeys*sizeof(SafeBag*));

            if (pPfx->rgShroudedKeys == NULL)
                goto SetPfxAllocError;

            if (NULL == (pPfx->rgShroudedKeys[pPfx->cShroudedKeys-1] = (SafeBag*)SSAlloc(sizeof(SafeBag)) ))
                goto SetPfxAllocError;

            if (!CopyCrypttoASNSafeBag(&pSafeBags[i], (SafeBag*)pPfx->rgShroudedKeys[pPfx->cShroudedKeys-1]))
                continue;
        }
        else if (0 == strcmp(pSafeBags[i].pszBagTypeOID, szOID_PKCS_12_CERT_BAG))
        {
            pPfx->cCertcrls++;
            if (pPfx->rgCertcrls)
                pPfx->rgCertcrls = (void**)SSReAlloc(pPfx->rgCertcrls, pPfx->cCertcrls*sizeof(SafeBag*));
            else
                pPfx->rgCertcrls = (void**)SSAlloc(pPfx->cCertcrls*sizeof(SafeBag*));

            if (pPfx->rgCertcrls == NULL)
                goto SetPfxAllocError;

            if (NULL == (pPfx->rgCertcrls[pPfx->cCertcrls-1] = (SafeBag*)SSAlloc(sizeof(SafeBag)) ))
                goto SetPfxAllocError;

            if (!CopyCrypttoASNSafeBag(&pSafeBags[i], (SafeBag*)pPfx->rgCertcrls[pPfx->cCertcrls-1]))
                continue;
        }
        else if (0 == strcmp(pSafeBags[i].pszBagTypeOID, szOID_PKCS_12_SECRET_BAG))
        {
            pPfx->cSecrets++;
            if (pPfx->rgSecrets)
                pPfx->rgSecrets = (void**)SSReAlloc(pPfx->rgSecrets, pPfx->cSecrets*sizeof(SafeBag*));
            else
                pPfx->rgSecrets = (void**)SSAlloc(pPfx->cSecrets*sizeof(SafeBag*));

            if (pPfx->rgSecrets == NULL)
                goto SetPfxAllocError;

            if (NULL == (pPfx->rgSecrets[pPfx->cSecrets-1] = (SafeBag*)SSAlloc(sizeof(SafeBag)) ))
                goto SetPfxAllocError;

            if (!CopyCrypttoASNSafeBag(&pSafeBags[i], (SafeBag*)pPfx->rgSecrets[pPfx->cSecrets-1]))
                continue;
        }
        else
        {
#if DBG
            OutputDebugString(pSafeBags[i].pszBagTypeOID);
#endif
            continue;
        }

    }

    return TRUE;

SetPfxAllocError:
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return FALSE;
}


BOOL
PFXAPI
IsRealPFXBlob(CRYPT_DATA_BLOB* pPFX)
{
    PFX    *psPfx = NULL;
    ASN1decoding_t  pDec = GetDecoder();

    // Crack the PFX blob
    if (0 == PkiAsn1Decode(
            pDec,
            (void **)&psPfx,
            PFX_PDU,
            pPFX->pbData,
            pPFX->cbData
            ))
    {
        PkiAsn1FreeDecoded(pDec, psPfx, PFX_PDU);
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\pfxlib\pfxnscp.c ===
/* Copyright (C) Microsoft Corporation, 1996 - 1999 All rights reserved. */
/* ASN.1 definitions for PFXNSCP */

#include <windows.h>
#include "pfxnscp.h"

ASN1module_t PFXNSCP_Module = NULL;

static int ASN1CALL ASN1Enc_RSAData(ASN1encoding_t enc, ASN1uint32_t tag, RSAData *val);
static int ASN1CALL ASN1Enc_BaggageItem_unencryptedSecrets(ASN1encoding_t enc, ASN1uint32_t tag, BaggageItem_unencryptedSecrets *val);
static int ASN1CALL ASN1Enc_BaggageItem_espvks(ASN1encoding_t enc, ASN1uint32_t tag, BaggageItem_espvks *val);
static int ASN1CALL ASN1Enc_ContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfo *val);
static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_PBEParameter(ASN1encoding_t enc, ASN1uint32_t tag, PBEParameter *val);
static int ASN1CALL ASN1Enc_DigestAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_Baggage(ASN1encoding_t enc, ASN1uint32_t tag, Baggage *val);
static int ASN1CALL ASN1Enc_BaggageItem(ASN1encoding_t enc, ASN1uint32_t tag, BaggageItem *val);
static int ASN1CALL ASN1Enc_PvkAdditional(ASN1encoding_t enc, ASN1uint32_t tag, PvkAdditional *val);
static int ASN1CALL ASN1Enc_SafeContents(ASN1encoding_t enc, ASN1uint32_t tag, SafeContents *val);
static int ASN1CALL ASN1Enc_SafeBag(ASN1encoding_t enc, ASN1uint32_t tag, SafeBag *val);
static int ASN1CALL ASN1Enc_KeyBag(ASN1encoding_t enc, ASN1uint32_t tag, KeyBag *val);
static int ASN1CALL ASN1Enc_CertCRLBag(ASN1encoding_t enc, ASN1uint32_t tag, CertCRLBag *val);
static int ASN1CALL ASN1Enc_CertCRL(ASN1encoding_t enc, ASN1uint32_t tag, CertCRL *val);
static int ASN1CALL ASN1Enc_X509Bag(ASN1encoding_t enc, ASN1uint32_t tag, X509Bag *val);
static int ASN1CALL ASN1Enc_SDSICertBag(ASN1encoding_t enc, ASN1uint32_t tag, SDSICertBag *val);
static int ASN1CALL ASN1Enc_SecretBag(ASN1encoding_t enc, ASN1uint32_t tag, SecretBag *val);
static int ASN1CALL ASN1Enc_SecretAdditional(ASN1encoding_t enc, ASN1uint32_t tag, SecretAdditional *val);
static int ASN1CALL ASN1Enc_PrivateKeyAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyAlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_EncryptionAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, EncryptionAlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_ContentEncryptionAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, ContentEncryptionAlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_DigestInfo(ASN1encoding_t enc, ASN1uint32_t tag, DigestInfo *val);
static int ASN1CALL ASN1Enc_MacData(ASN1encoding_t enc, ASN1uint32_t tag, MacData *val);
static int ASN1CALL ASN1Enc_AuthenticatedSafe(ASN1encoding_t enc, ASN1uint32_t tag, AuthenticatedSafe *val);
static int ASN1CALL ASN1Enc_Thumbprint(ASN1encoding_t enc, ASN1uint32_t tag, Thumbprint *val);
static int ASN1CALL ASN1Enc_Secret(ASN1encoding_t enc, ASN1uint32_t tag, Secret *val);
static int ASN1CALL ASN1Enc_PVKSupportingData_assocCerts(ASN1encoding_t enc, ASN1uint32_t tag, PVKSupportingData_assocCerts *val);
static int ASN1CALL ASN1Enc_PrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyInfo *val);
static int ASN1CALL ASN1Enc_EncryptedContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedContentInfo *val);
static int ASN1CALL ASN1Enc_PFX(ASN1encoding_t enc, ASN1uint32_t tag, PFX *val);
static int ASN1CALL ASN1Enc_PVKSupportingData(ASN1encoding_t enc, ASN1uint32_t tag, PVKSupportingData *val);
static int ASN1CALL ASN1Enc_PrivateKey(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKey *val);
static int ASN1CALL ASN1Enc_EncryptedData(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedData *val);
static int ASN1CALL ASN1Enc_ESPVK(ASN1encoding_t enc, ASN1uint32_t tag, ESPVK *val);
static int ASN1CALL ASN1Enc_EncryptedPrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedPrivateKeyInfo *val);
static int ASN1CALL ASN1Dec_RSAData(ASN1decoding_t dec, ASN1uint32_t tag, RSAData *val);
static int ASN1CALL ASN1Dec_BaggageItem_unencryptedSecrets(ASN1decoding_t dec, ASN1uint32_t tag, BaggageItem_unencryptedSecrets *val);
static int ASN1CALL ASN1Dec_BaggageItem_espvks(ASN1decoding_t dec, ASN1uint32_t tag, BaggageItem_espvks *val);
static int ASN1CALL ASN1Dec_ContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfo *val);
static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_PBEParameter(ASN1decoding_t dec, ASN1uint32_t tag, PBEParameter *val);
static int ASN1CALL ASN1Dec_DigestAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_Baggage(ASN1decoding_t dec, ASN1uint32_t tag, Baggage *val);
static int ASN1CALL ASN1Dec_BaggageItem(ASN1decoding_t dec, ASN1uint32_t tag, BaggageItem *val);
static int ASN1CALL ASN1Dec_PvkAdditional(ASN1decoding_t dec, ASN1uint32_t tag, PvkAdditional *val);
static int ASN1CALL ASN1Dec_SafeContents(ASN1decoding_t dec, ASN1uint32_t tag, SafeContents *val);
static int ASN1CALL ASN1Dec_SafeBag(ASN1decoding_t dec, ASN1uint32_t tag, SafeBag *val);
static int ASN1CALL ASN1Dec_KeyBag(ASN1decoding_t dec, ASN1uint32_t tag, KeyBag *val);
static int ASN1CALL ASN1Dec_CertCRLBag(ASN1decoding_t dec, ASN1uint32_t tag, CertCRLBag *val);
static int ASN1CALL ASN1Dec_CertCRL(ASN1decoding_t dec, ASN1uint32_t tag, CertCRL *val);
static int ASN1CALL ASN1Dec_X509Bag(ASN1decoding_t dec, ASN1uint32_t tag, X509Bag *val);
static int ASN1CALL ASN1Dec_SDSICertBag(ASN1decoding_t dec, ASN1uint32_t tag, SDSICertBag *val);
static int ASN1CALL ASN1Dec_SecretBag(ASN1decoding_t dec, ASN1uint32_t tag, SecretBag *val);
static int ASN1CALL ASN1Dec_SecretAdditional(ASN1decoding_t dec, ASN1uint32_t tag, SecretAdditional *val);
static int ASN1CALL ASN1Dec_PrivateKeyAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyAlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_EncryptionAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, EncryptionAlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_ContentEncryptionAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, ContentEncryptionAlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_DigestInfo(ASN1decoding_t dec, ASN1uint32_t tag, DigestInfo *val);
static int ASN1CALL ASN1Dec_MacData(ASN1decoding_t dec, ASN1uint32_t tag, MacData *val);
static int ASN1CALL ASN1Dec_AuthenticatedSafe(ASN1decoding_t dec, ASN1uint32_t tag, AuthenticatedSafe *val);
static int ASN1CALL ASN1Dec_Thumbprint(ASN1decoding_t dec, ASN1uint32_t tag, Thumbprint *val);
static int ASN1CALL ASN1Dec_Secret(ASN1decoding_t dec, ASN1uint32_t tag, Secret *val);
static int ASN1CALL ASN1Dec_PVKSupportingData_assocCerts(ASN1decoding_t dec, ASN1uint32_t tag, PVKSupportingData_assocCerts *val);
static int ASN1CALL ASN1Dec_PrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyInfo *val);
static int ASN1CALL ASN1Dec_EncryptedContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedContentInfo *val);
static int ASN1CALL ASN1Dec_PFX(ASN1decoding_t dec, ASN1uint32_t tag, PFX *val);
static int ASN1CALL ASN1Dec_PVKSupportingData(ASN1decoding_t dec, ASN1uint32_t tag, PVKSupportingData *val);
static int ASN1CALL ASN1Dec_PrivateKey(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKey *val);
static int ASN1CALL ASN1Dec_EncryptedData(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedData *val);
static int ASN1CALL ASN1Dec_ESPVK(ASN1decoding_t dec, ASN1uint32_t tag, ESPVK *val);
static int ASN1CALL ASN1Dec_EncryptedPrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedPrivateKeyInfo *val);
static void ASN1CALL ASN1Free_RSAData(RSAData *val);
static void ASN1CALL ASN1Free_BaggageItem_unencryptedSecrets(BaggageItem_unencryptedSecrets *val);
static void ASN1CALL ASN1Free_BaggageItem_espvks(BaggageItem_espvks *val);
static void ASN1CALL ASN1Free_ContentInfo(ContentInfo *val);
static void ASN1CALL ASN1Free_Attributes(Attributes *val);
static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_PBEParameter(PBEParameter *val);
static void ASN1CALL ASN1Free_DigestAlgorithmIdentifier(DigestAlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_Baggage(Baggage *val);
static void ASN1CALL ASN1Free_BaggageItem(BaggageItem *val);
static void ASN1CALL ASN1Free_PvkAdditional(PvkAdditional *val);
static void ASN1CALL ASN1Free_SafeContents(SafeContents *val);
static void ASN1CALL ASN1Free_SafeBag(SafeBag *val);
static void ASN1CALL ASN1Free_KeyBag(KeyBag *val);
static void ASN1CALL ASN1Free_CertCRLBag(CertCRLBag *val);
static void ASN1CALL ASN1Free_CertCRL(CertCRL *val);
static void ASN1CALL ASN1Free_X509Bag(X509Bag *val);
static void ASN1CALL ASN1Free_SDSICertBag(SDSICertBag *val);
static void ASN1CALL ASN1Free_SecretBag(SecretBag *val);
static void ASN1CALL ASN1Free_SecretAdditional(SecretAdditional *val);
static void ASN1CALL ASN1Free_PrivateKeyAlgorithmIdentifier(PrivateKeyAlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_EncryptionAlgorithmIdentifier(EncryptionAlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_ContentEncryptionAlgorithmIdentifier(ContentEncryptionAlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_DigestInfo(DigestInfo *val);
static void ASN1CALL ASN1Free_MacData(MacData *val);
static void ASN1CALL ASN1Free_AuthenticatedSafe(AuthenticatedSafe *val);
static void ASN1CALL ASN1Free_Thumbprint(Thumbprint *val);
static void ASN1CALL ASN1Free_Secret(Secret *val);
static void ASN1CALL ASN1Free_PVKSupportingData_assocCerts(PVKSupportingData_assocCerts *val);
static void ASN1CALL ASN1Free_PrivateKeyInfo(PrivateKeyInfo *val);
static void ASN1CALL ASN1Free_EncryptedContentInfo(EncryptedContentInfo *val);
static void ASN1CALL ASN1Free_PFX(PFX *val);
static void ASN1CALL ASN1Free_PVKSupportingData(PVKSupportingData *val);
static void ASN1CALL ASN1Free_PrivateKey(PrivateKey *val);
static void ASN1CALL ASN1Free_EncryptedData(EncryptedData *val);
static void ASN1CALL ASN1Free_ESPVK(ESPVK *val);
static void ASN1CALL ASN1Free_EncryptedPrivateKeyInfo(EncryptedPrivateKeyInfo *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[22] = {
    (ASN1EncFun_t) ASN1Enc_RSAData,
    (ASN1EncFun_t) ASN1Enc_Attributes,
    (ASN1EncFun_t) ASN1Enc_PBEParameter,
    (ASN1EncFun_t) ASN1Enc_PvkAdditional,
    (ASN1EncFun_t) ASN1Enc_SafeContents,
    (ASN1EncFun_t) ASN1Enc_SafeBag,
    (ASN1EncFun_t) ASN1Enc_KeyBag,
    (ASN1EncFun_t) ASN1Enc_CertCRLBag,
    (ASN1EncFun_t) ASN1Enc_CertCRL,
    (ASN1EncFun_t) ASN1Enc_X509Bag,
    (ASN1EncFun_t) ASN1Enc_SDSICertBag,
    (ASN1EncFun_t) ASN1Enc_SecretBag,
    (ASN1EncFun_t) ASN1Enc_SecretAdditional,
    (ASN1EncFun_t) ASN1Enc_AuthenticatedSafe,
    (ASN1EncFun_t) ASN1Enc_Secret,
    (ASN1EncFun_t) ASN1Enc_PrivateKeyInfo,
    (ASN1EncFun_t) ASN1Enc_PFX,
    (ASN1EncFun_t) ASN1Enc_PVKSupportingData,
    (ASN1EncFun_t) ASN1Enc_PrivateKey,
    (ASN1EncFun_t) ASN1Enc_EncryptedData,
    (ASN1EncFun_t) ASN1Enc_ESPVK,
    (ASN1EncFun_t) ASN1Enc_EncryptedPrivateKeyInfo,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[22] = {
    (ASN1DecFun_t) ASN1Dec_RSAData,
    (ASN1DecFun_t) ASN1Dec_Attributes,
    (ASN1DecFun_t) ASN1Dec_PBEParameter,
    (ASN1DecFun_t) ASN1Dec_PvkAdditional,
    (ASN1DecFun_t) ASN1Dec_SafeContents,
    (ASN1DecFun_t) ASN1Dec_SafeBag,
    (ASN1DecFun_t) ASN1Dec_KeyBag,
    (ASN1DecFun_t) ASN1Dec_CertCRLBag,
    (ASN1DecFun_t) ASN1Dec_CertCRL,
    (ASN1DecFun_t) ASN1Dec_X509Bag,
    (ASN1DecFun_t) ASN1Dec_SDSICertBag,
    (ASN1DecFun_t) ASN1Dec_SecretBag,
    (ASN1DecFun_t) ASN1Dec_SecretAdditional,
    (ASN1DecFun_t) ASN1Dec_AuthenticatedSafe,
    (ASN1DecFun_t) ASN1Dec_Secret,
    (ASN1DecFun_t) ASN1Dec_PrivateKeyInfo,
    (ASN1DecFun_t) ASN1Dec_PFX,
    (ASN1DecFun_t) ASN1Dec_PVKSupportingData,
    (ASN1DecFun_t) ASN1Dec_PrivateKey,
    (ASN1DecFun_t) ASN1Dec_EncryptedData,
    (ASN1DecFun_t) ASN1Dec_ESPVK,
    (ASN1DecFun_t) ASN1Dec_EncryptedPrivateKeyInfo,
};
static const ASN1FreeFun_t freefntab[22] = {
    (ASN1FreeFun_t) ASN1Free_RSAData,
    (ASN1FreeFun_t) ASN1Free_Attributes,
    (ASN1FreeFun_t) ASN1Free_PBEParameter,
    (ASN1FreeFun_t) ASN1Free_PvkAdditional,
    (ASN1FreeFun_t) ASN1Free_SafeContents,
    (ASN1FreeFun_t) ASN1Free_SafeBag,
    (ASN1FreeFun_t) ASN1Free_KeyBag,
    (ASN1FreeFun_t) ASN1Free_CertCRLBag,
    (ASN1FreeFun_t) ASN1Free_CertCRL,
    (ASN1FreeFun_t) ASN1Free_X509Bag,
    (ASN1FreeFun_t) ASN1Free_SDSICertBag,
    (ASN1FreeFun_t) ASN1Free_SecretBag,
    (ASN1FreeFun_t) ASN1Free_SecretAdditional,
    (ASN1FreeFun_t) ASN1Free_AuthenticatedSafe,
    (ASN1FreeFun_t) ASN1Free_Secret,
    (ASN1FreeFun_t) ASN1Free_PrivateKeyInfo,
    (ASN1FreeFun_t) ASN1Free_PFX,
    (ASN1FreeFun_t) ASN1Free_PVKSupportingData,
    (ASN1FreeFun_t) ASN1Free_PrivateKey,
    (ASN1FreeFun_t) ASN1Free_EncryptedData,
    (ASN1FreeFun_t) ASN1Free_ESPVK,
    (ASN1FreeFun_t) ASN1Free_EncryptedPrivateKeyInfo,
};
static const ULONG sizetab[22] = {
    SIZE_PFXNSCP_Module_PDU_0,
    SIZE_PFXNSCP_Module_PDU_1,
    SIZE_PFXNSCP_Module_PDU_2,
    SIZE_PFXNSCP_Module_PDU_3,
    SIZE_PFXNSCP_Module_PDU_4,
    SIZE_PFXNSCP_Module_PDU_5,
    SIZE_PFXNSCP_Module_PDU_6,
    SIZE_PFXNSCP_Module_PDU_7,
    SIZE_PFXNSCP_Module_PDU_8,
    SIZE_PFXNSCP_Module_PDU_9,
    SIZE_PFXNSCP_Module_PDU_10,
    SIZE_PFXNSCP_Module_PDU_11,
    SIZE_PFXNSCP_Module_PDU_12,
    SIZE_PFXNSCP_Module_PDU_13,
    SIZE_PFXNSCP_Module_PDU_14,
    SIZE_PFXNSCP_Module_PDU_15,
    SIZE_PFXNSCP_Module_PDU_16,
    SIZE_PFXNSCP_Module_PDU_17,
    SIZE_PFXNSCP_Module_PDU_18,
    SIZE_PFXNSCP_Module_PDU_19,
    SIZE_PFXNSCP_Module_PDU_20,
    SIZE_PFXNSCP_Module_PDU_21,
};

/* forward declarations of values: */
/* definitions of value components: */
ASN1objectidentifier2_t rsa1 = {
    4, { 1, 2, 840, 113549 }
};
ASN1objectidentifier2_t pkcs_12 = {
    6, { 1, 2, 840, 113549, 1, 12 }
};
ASN1objectidentifier2_t pkcs_12ModeIds = {
    7, { 1, 2, 840, 113549, 1, 12, 1 }
};
ASN1objectidentifier2_t off_lineTransportMode = {
    8, { 1, 2, 840, 113549, 1, 12, 1, 1 }
};
/* definitions of values: */
ASN1bool_t PVKSupportingData_regenerable_default = 0;
Version AuthenticatedSafe_version_default = 1;

void ASN1CALL PFXNSCP_Module_Startup(void)
{
    PFXNSCP_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 22, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x6e786670);
}

void ASN1CALL PFXNSCP_Module_Cleanup(void)
{
    ASN1_CloseModule(PFXNSCP_Module);
    PFXNSCP_Module = NULL;
}

static int ASN1CALL ASN1Enc_RSAData(ASN1encoding_t enc, ASN1uint32_t tag, RSAData *val)
{
    if (!ASN1DEREncOctetString(enc, tag ? tag : 0x4, (val)->length, (val)->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RSAData(ASN1decoding_t dec, ASN1uint32_t tag, RSAData *val)
{
    if (!ASN1BERDecOctetString(dec, tag ? tag : 0x4, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RSAData(RSAData *val)
{
    if (val) {
	ASN1octetstring_free(val);
    }
}

static int ASN1CALL ASN1Enc_BaggageItem_unencryptedSecrets(ASN1encoding_t enc, ASN1uint32_t tag, BaggageItem_unencryptedSecrets *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_SafeBag(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BaggageItem_unencryptedSecrets(ASN1decoding_t dec, ASN1uint32_t tag, BaggageItem_unencryptedSecrets *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (SafeBag *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_SafeBag(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BaggageItem_unencryptedSecrets(BaggageItem_unencryptedSecrets *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_SafeBag(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_SafeBag(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_BaggageItem_espvks(ASN1encoding_t enc, ASN1uint32_t tag, BaggageItem_espvks *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_ESPVK(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BaggageItem_espvks(ASN1decoding_t dec, ASN1uint32_t tag, BaggageItem_espvks *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (ESPVK *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_ESPVK(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BaggageItem_espvks(BaggageItem_espvks *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_ESPVK(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_ESPVK(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_ContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfo *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->contentType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1BEREncOpenType(enc, &(val)->content))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->contentType))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	if (t == 0x80000000) {
	    (val)->o[0] |= 0x80;
	    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
		return 0;
	    if (!ASN1BERDecOpenType(dd0, &(val)->content))
		return 0;
	    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
		return 0;
	}
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentInfo(ContentInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1open_free(&(val)->content);
	}
    }
}

static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (Attribute *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Attributes(Attributes *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1open_free(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1open_free(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->algorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->algorithm))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1open_free(&(val)->parameters);
	}
    }
}

static int ASN1CALL ASN1Enc_PBEParameter(ASN1encoding_t enc, ASN1uint32_t tag, PBEParameter *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->salt).length, ((val)->salt).value))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->iterationCount))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PBEParameter(ASN1decoding_t dec, ASN1uint32_t tag, PBEParameter *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->salt))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->iterationCount))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PBEParameter(PBEParameter *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->salt);
    }
}

static int ASN1CALL ASN1Enc_DigestAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmIdentifier *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmIdentifier *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestAlgorithmIdentifier(DigestAlgorithmIdentifier *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_Baggage(ASN1encoding_t enc, ASN1uint32_t tag, Baggage *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_BaggageItem(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Baggage(ASN1decoding_t dec, ASN1uint32_t tag, Baggage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (BaggageItem *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_BaggageItem(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Baggage(Baggage *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_BaggageItem(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_BaggageItem(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_BaggageItem(ASN1encoding_t enc, ASN1uint32_t tag, BaggageItem *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_BaggageItem_espvks(enc, 0, &(val)->espvks))
	return 0;
    if (!ASN1Enc_BaggageItem_unencryptedSecrets(enc, 0, &(val)->unencryptedSecrets))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BaggageItem(ASN1decoding_t dec, ASN1uint32_t tag, BaggageItem *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_BaggageItem_espvks(dd, 0, &(val)->espvks))
	return 0;
    if (!ASN1Dec_BaggageItem_unencryptedSecrets(dd, 0, &(val)->unencryptedSecrets))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BaggageItem(BaggageItem *val)
{
    if (val) {
	ASN1Free_BaggageItem_espvks(&(val)->espvks);
	ASN1Free_BaggageItem_unencryptedSecrets(&(val)->unencryptedSecrets);
    }
}

static int ASN1CALL ASN1Enc_PvkAdditional(ASN1encoding_t enc, ASN1uint32_t tag, PvkAdditional *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->pvkAdditionalType))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->pvkAdditionalContent))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PvkAdditional(ASN1decoding_t dec, ASN1uint32_t tag, PvkAdditional *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->pvkAdditionalType))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOpenType(dd0, &(val)->pvkAdditionalContent))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PvkAdditional(PvkAdditional *val)
{
    if (val) {
	ASN1open_free(&(val)->pvkAdditionalContent);
    }
}

static int ASN1CALL ASN1Enc_SafeContents(ASN1encoding_t enc, ASN1uint32_t tag, SafeContents *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_SafeBag(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SafeContents(ASN1decoding_t dec, ASN1uint32_t tag, SafeContents *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (SafeBag *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_SafeBag(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SafeContents(SafeContents *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_SafeBag(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_SafeBag(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SafeBag(ASN1encoding_t enc, ASN1uint32_t tag, SafeBag *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->safeBagType))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->safeBagContent))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->safeBagName).length, ((val)->safeBagName).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SafeBag(ASN1decoding_t dec, ASN1uint32_t tag, SafeBag *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->safeBagType))
	return 0;
    if (!ASN1BERDecOpenType(dd, &(val)->safeBagContent))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x1e) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecChar16String(dd, 0x1e, &(val)->safeBagName))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SafeBag(SafeBag *val)
{
    if (val) {
	ASN1open_free(&(val)->safeBagContent);
	if ((val)->o[0] & 0x80) {
	    ASN1char16string_free(&(val)->safeBagName);
	}
    }
}

static int ASN1CALL ASN1Enc_KeyBag(ASN1encoding_t enc, ASN1uint32_t tag, KeyBag *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_PrivateKey(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KeyBag(ASN1decoding_t dec, ASN1uint32_t tag, KeyBag *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (PrivateKey *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_PrivateKey(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KeyBag(KeyBag *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_PrivateKey(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_PrivateKey(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_CertCRLBag(ASN1encoding_t enc, ASN1uint32_t tag, CertCRLBag *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_CertCRL(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertCRLBag(ASN1decoding_t dec, ASN1uint32_t tag, CertCRLBag *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (CertCRL *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_CertCRL(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertCRLBag(CertCRLBag *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_CertCRL(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_CertCRL(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_CertCRL(ASN1encoding_t enc, ASN1uint32_t tag, CertCRL *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->bagId))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertCRL(ASN1decoding_t dec, ASN1uint32_t tag, CertCRL *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->bagId))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOpenType(dd0, &(val)->value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertCRL(CertCRL *val)
{
    if (val) {
	ASN1open_free(&(val)->value);
    }
}

static int ASN1CALL ASN1Enc_X509Bag(ASN1encoding_t enc, ASN1uint32_t tag, X509Bag *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_ContentInfo(enc, 0, &(val)->certOrCRL))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_X509Bag(ASN1decoding_t dec, ASN1uint32_t tag, X509Bag *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_ContentInfo(dd, 0, &(val)->certOrCRL))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_X509Bag(X509Bag *val)
{
    if (val) {
	ASN1Free_ContentInfo(&(val)->certOrCRL);
    }
}

static int ASN1CALL ASN1Enc_SDSICertBag(ASN1encoding_t enc, ASN1uint32_t tag, SDSICertBag *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    t = lstrlenA((val)->value);
    if (!ASN1DEREncCharString(enc, 0x16, t, (val)->value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SDSICertBag(ASN1decoding_t dec, ASN1uint32_t tag, SDSICertBag *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecZeroCharString(dd, 0x16, &(val)->value))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SDSICertBag(SDSICertBag *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SecretBag(ASN1encoding_t enc, ASN1uint32_t tag, SecretBag *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_Secret(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SecretBag(ASN1decoding_t dec, ASN1uint32_t tag, SecretBag *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (Secret *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_Secret(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SecretBag(SecretBag *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_Secret(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_Secret(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SecretAdditional(ASN1encoding_t enc, ASN1uint32_t tag, SecretAdditional *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->secretAdditionalType))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->secretAdditionalContent))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SecretAdditional(ASN1decoding_t dec, ASN1uint32_t tag, SecretAdditional *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->secretAdditionalType))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOpenType(dd0, &(val)->secretAdditionalContent))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SecretAdditional(SecretAdditional *val)
{
    if (val) {
	ASN1open_free(&(val)->secretAdditionalContent);
    }
}

static int ASN1CALL ASN1Enc_PrivateKeyAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyAlgorithmIdentifier *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateKeyAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyAlgorithmIdentifier *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivateKeyAlgorithmIdentifier(PrivateKeyAlgorithmIdentifier *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_EncryptionAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, EncryptionAlgorithmIdentifier *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, EncryptionAlgorithmIdentifier *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionAlgorithmIdentifier(EncryptionAlgorithmIdentifier *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_ContentEncryptionAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, ContentEncryptionAlgorithmIdentifier *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentEncryptionAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, ContentEncryptionAlgorithmIdentifier *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentEncryptionAlgorithmIdentifier(ContentEncryptionAlgorithmIdentifier *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_DigestInfo(ASN1encoding_t enc, ASN1uint32_t tag, DigestInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_DigestAlgorithmIdentifier(enc, 0, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->digest).length, ((val)->digest).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestInfo(ASN1decoding_t dec, ASN1uint32_t tag, DigestInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_DigestAlgorithmIdentifier(dd, 0, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->digest))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestInfo(DigestInfo *val)
{
    if (val) {
	ASN1Free_DigestAlgorithmIdentifier(&(val)->digestAlgorithm);
	ASN1octetstring_free(&(val)->digest);
    }
}

static int ASN1CALL ASN1Enc_MacData(ASN1encoding_t enc, ASN1uint32_t tag, MacData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_DigestInfo(enc, 0, &(val)->safeMAC))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->macSalt).length, ((val)->macSalt).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MacData(ASN1decoding_t dec, ASN1uint32_t tag, MacData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_DigestInfo(dd, 0, &(val)->safeMAC))
	return 0;
    if (!ASN1BERDecBitString(dd, 0x3, &(val)->macSalt))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MacData(MacData *val)
{
    if (val) {
	ASN1Free_DigestInfo(&(val)->safeMAC);
	ASN1bitstring_free(&(val)->macSalt);
    }
}

static int ASN1CALL ASN1Enc_AuthenticatedSafe(ASN1encoding_t enc, ASN1uint32_t tag, AuthenticatedSafe *val)
{
    ASN1uint32_t nLenOff;
    ASN1octet_t o[1];
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    CopyMemory(o, (val)->o, 1);
    if ((val)->version == 1)
	o[0] &= ~0x80;
    if (!ASN1objectidentifier2_cmp(&val->transportMode, &off_lineTransportMode))
	o[0] &= ~0x40;
    if (o[0] & 0x80) {
	if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->transportMode))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1DEREncBitString(enc, 0x3, ((val)->privacySalt).length, ((val)->privacySalt).value))
	    return 0;
    }
    if (o[0] & 0x10) {
	if (!ASN1Enc_Baggage(enc, 0, &(val)->baggage))
	    return 0;
    }
    if (!ASN1Enc_ContentInfo(enc, 0, &(val)->safe))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AuthenticatedSafe(ASN1decoding_t dec, ASN1uint32_t tag, AuthenticatedSafe *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x6) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->transportMode))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x3) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecBitString(dd, 0x3, &(val)->privacySalt))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x11) {
	(val)->o[0] |= 0x10;
	if (!ASN1Dec_Baggage(dd, 0, &(val)->baggage))
	    return 0;
    }
    if (!ASN1Dec_ContentInfo(dd, 0, &(val)->safe))
	return 0;
    if (!((val)->o[0] & 0x80))
	(val)->version = 1;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AuthenticatedSafe(AuthenticatedSafe *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	    ASN1bitstring_free(&(val)->privacySalt);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_Baggage(&(val)->baggage);
	}
	ASN1Free_ContentInfo(&(val)->safe);
    }
}

static int ASN1CALL ASN1Enc_Thumbprint(ASN1encoding_t enc, ASN1uint32_t tag, Thumbprint *val)
{
    if (!ASN1Enc_DigestInfo(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Thumbprint(ASN1decoding_t dec, ASN1uint32_t tag, Thumbprint *val)
{
    if (!ASN1Dec_DigestInfo(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Thumbprint(Thumbprint *val)
{
    if (val) {
	ASN1Free_DigestInfo(val);
    }
}

static int ASN1CALL ASN1Enc_Secret(ASN1encoding_t enc, ASN1uint32_t tag, Secret *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->secretName).length, ((val)->secretName).value))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->secretType))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_SecretAdditional(enc, 0, &(val)->secretAdditional))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Secret(ASN1decoding_t dec, ASN1uint32_t tag, Secret *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecChar16String(dd, 0x1e, &(val)->secretName))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->secretType))
	return 0;
    if (!ASN1BERDecOpenType(dd, &(val)->value))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_SecretAdditional(dd, 0, &(val)->secretAdditional))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Secret(Secret *val)
{
    if (val) {
	ASN1char16string_free(&(val)->secretName);
	ASN1open_free(&(val)->value);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SecretAdditional(&(val)->secretAdditional);
	}
    }
}

static int ASN1CALL ASN1Enc_PVKSupportingData_assocCerts(ASN1encoding_t enc, ASN1uint32_t tag, PVKSupportingData_assocCerts *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_Thumbprint(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PVKSupportingData_assocCerts(ASN1decoding_t dec, ASN1uint32_t tag, PVKSupportingData_assocCerts *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (Thumbprint *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_Thumbprint(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PVKSupportingData_assocCerts(PVKSupportingData_assocCerts *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_Thumbprint(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_Thumbprint(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_PrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_PrivateKeyAlgorithmIdentifier(enc, 0, &(val)->privateKeyAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->privateKey).length, ((val)->privateKey).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Attributes(enc, 0x80000000, &(val)->attributes))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_PrivateKeyAlgorithmIdentifier(dd, 0, &(val)->privateKeyAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->privateKey))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Attributes(dd, 0x80000000, &(val)->attributes))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivateKeyInfo(PrivateKeyInfo *val)
{
    if (val) {
	ASN1Free_PrivateKeyAlgorithmIdentifier(&(val)->privateKeyAlgorithm);
	ASN1octetstring_free(&(val)->privateKey);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Attributes(&(val)->attributes);
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptedContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedContentInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->contentType))
	return 0;
    if (!ASN1Enc_ContentEncryptionAlgorithmIdentifier(enc, 0, &(val)->contentEncryptionAlg))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->encryptedContent).length, ((val)->encryptedContent).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptedContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedContentInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->contentType))
	return 0;
    if (!ASN1Dec_ContentEncryptionAlgorithmIdentifier(dd, 0, &(val)->contentEncryptionAlg))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOctetString(dd, 0x80000000, &(val)->encryptedContent))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptedContentInfo(EncryptedContentInfo *val)
{
    if (val) {
	ASN1Free_ContentEncryptionAlgorithmIdentifier(&(val)->contentEncryptionAlg);
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->encryptedContent);
	}
    }
}

static int ASN1CALL ASN1Enc_PFX(ASN1encoding_t enc, ASN1uint32_t tag, PFX *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_MacData(enc, 0x80000000, &(val)->macData))
	    return 0;
    }
    if (!ASN1Enc_ContentInfo(enc, 0x80000001, &(val)->authSafe))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PFX(ASN1decoding_t dec, ASN1uint32_t tag, PFX *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_MacData(dd, 0x80000000, &(val)->macData))
	    return 0;
    }
    if (!ASN1Dec_ContentInfo(dd, 0x80000001, &(val)->authSafe))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PFX(PFX *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_MacData(&(val)->macData);
	}
	ASN1Free_ContentInfo(&(val)->authSafe);
    }
}

static int ASN1CALL ASN1Enc_PVKSupportingData(ASN1encoding_t enc, ASN1uint32_t tag, PVKSupportingData *val)
{
    ASN1uint32_t nLenOff;
    ASN1octet_t o[1];
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    CopyMemory(o, (val)->o, 1);
    if (!(val)->regenerable)
	o[0] &= ~0x80;
    if (!ASN1Enc_PVKSupportingData_assocCerts(enc, 0, &(val)->assocCerts))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1BEREncBool(enc, 0x1, (val)->regenerable))
	    return 0;
    }
    if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->nickname).length, ((val)->nickname).value))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1Enc_PvkAdditional(enc, 0, &(val)->pvkAdditional))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PVKSupportingData(ASN1decoding_t dec, ASN1uint32_t tag, PVKSupportingData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1Dec_PVKSupportingData_assocCerts(dd, 0, &(val)->assocCerts))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x1) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecBool(dd, 0x1, &(val)->regenerable))
	    return 0;
    }
    if (!ASN1BERDecChar16String(dd, 0x1e, &(val)->nickname))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_PvkAdditional(dd, 0, &(val)->pvkAdditional))
	    return 0;
    }
    if (!((val)->o[0] & 0x80))
	(val)->regenerable = 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PVKSupportingData(PVKSupportingData *val)
{
    if (val) {
	ASN1Free_PVKSupportingData_assocCerts(&(val)->assocCerts);
	ASN1char16string_free(&(val)->nickname);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_PvkAdditional(&(val)->pvkAdditional);
	}
    }
}

static int ASN1CALL ASN1Enc_PrivateKey(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKey *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_PVKSupportingData(enc, 0, &(val)->pvkData))
	return 0;
    if (!ASN1Enc_PrivateKeyInfo(enc, 0, &(val)->pkcs8data))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateKey(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKey *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_PVKSupportingData(dd, 0, &(val)->pvkData))
	return 0;
    if (!ASN1Dec_PrivateKeyInfo(dd, 0, &(val)->pkcs8data))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivateKey(PrivateKey *val)
{
    if (val) {
	ASN1Free_PVKSupportingData(&(val)->pvkData);
	ASN1Free_PrivateKeyInfo(&(val)->pkcs8data);
    }
}

static int ASN1CALL ASN1Enc_EncryptedData(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_EncryptedContentInfo(enc, 0, &(val)->encryptedContentInfo))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptedData(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_EncryptedContentInfo(dd, 0, &(val)->encryptedContentInfo))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptedData(EncryptedData *val)
{
    if (val) {
	ASN1Free_EncryptedContentInfo(&(val)->encryptedContentInfo);
    }
}

static int ASN1CALL ASN1Enc_ESPVK(ASN1encoding_t enc, ASN1uint32_t tag, ESPVK *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->espvkObjID))
	return 0;
    if (!ASN1Enc_PVKSupportingData(enc, 0, &(val)->espvkData))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->espvkCipherText))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ESPVK(ASN1decoding_t dec, ASN1uint32_t tag, ESPVK *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->espvkObjID))
	return 0;
    if (!ASN1Dec_PVKSupportingData(dd, 0, &(val)->espvkData))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOpenType(dd0, &(val)->espvkCipherText))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ESPVK(ESPVK *val)
{
    if (val) {
	ASN1Free_PVKSupportingData(&(val)->espvkData);
	ASN1open_free(&(val)->espvkCipherText);
    }
}

static int ASN1CALL ASN1Enc_EncryptedPrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedPrivateKeyInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_EncryptionAlgorithmIdentifier(enc, 0, &(val)->encryptionAlgorithm))
	return 0;
    if (!ASN1Enc_EncryptedData(enc, 0, &(val)->encryptedData))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptedPrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedPrivateKeyInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_EncryptionAlgorithmIdentifier(dd, 0, &(val)->encryptionAlgorithm))
	return 0;
    if (!ASN1Dec_EncryptedData(dd, 0, &(val)->encryptedData))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptedPrivateKeyInfo(EncryptedPrivateKeyInfo *val)
{
    if (val) {
	ASN1Free_EncryptionAlgorithmIdentifier(&(val)->encryptionAlgorithm);
	ASN1Free_EncryptedData(&(val)->encryptedData);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\pfxlib\pfxhelp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       pfxhelp.cpp
//
//  Contents:   Support functions for PFX
//
//  Functions:	CertExportSafeContents
//				CertImportSafeContents 
//
//  History:    23-Feb-96   philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>
#include "pfxhelp.h"
#include "pfxpkcs.h"
#include "pfxcmn.h"
#include "pfxcrypt.h"

// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

// remove when this is defined in wincrypt.h
#ifndef PP_KEYSET_TYPE
#define	PP_KEYSET_TYPE			27
#endif

#define DISALLOWED_FLAG_MASK    ~(CRYPT_EXPORTABLE | CRYPT_DELETEKEYSET)

//+-------------------------------------------------------------------------
//  PFX helpe allocation and free functions
//--------------------------------------------------------------------------
static void *PFXHelpAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}
static void *PFXHelpRealloc(
    IN void *pvOrg,
    IN size_t cbBytes
    )
{
    void *pv;
    if (NULL == (pv = pvOrg ? realloc(pvOrg, cbBytes) : malloc(cbBytes)))
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

static void PFXHelpFree(
    IN void *pv
    )
{
    if (pv)
        free(pv);
}


// this function will search an a SAFE_CONTENTS to see if any of the SAFE_BAGS have the
// same private key as the one passed to the function.  if it finds a matching private
// key it will return a pointer the encoded keyID and return TRUE, it will return FALSE 
// otherwise.  NOTE that if it returns a pointer to the encoded blob that the caller
// is responsible for copying the data and must not free what is returned
static BOOL WINAPI PrivateKeyAlreadyExists(
	BYTE				*pPrivateKey,
	DWORD				cbPrivateKey,
	SAFE_CONTENTS		*pSafeContents,
	PCRYPT_DER_BLOB		pEncodedKeyID
	)
{
	BOOL	bKeyFound = FALSE;
	DWORD	i = 0;

	if (pSafeContents == NULL) {
		goto CommonReturn;
	}

	while ((!bKeyFound) && (i < pSafeContents->cSafeBags)) 
    {
		if ( ((strcmp(pSafeContents->pSafeBags[i].pszBagTypeOID, szOID_PKCS_12_KEY_BAG) == 0) || 
              (strcmp(pSafeContents->pSafeBags[i].pszBagTypeOID, szOID_PKCS_12_SHROUDEDKEY_BAG) == 0)) &&
            
			 (cbPrivateKey == pSafeContents->pSafeBags[i].BagContents.cbData) && 
			 (memcmp(pPrivateKey, pSafeContents->pSafeBags[i].BagContents.pbData, cbPrivateKey) == 0)) 
        {
			pEncodedKeyID->pbData = pSafeContents->pSafeBags[i].Attributes.rgAttr[0].rgValue[0].pbData;
			pEncodedKeyID->cbData = pSafeContents->pSafeBags[i].Attributes.rgAttr[0].rgValue[0].cbData;
			bKeyFound = TRUE;
		}
		else {
			i++;
		}
	}

CommonReturn:
	return bKeyFound;
}


// this function will walk through a SAFE_CONTENTS structure and free all the space 
// associated with it
static BOOL WINAPI FreeSafeContents(
	SAFE_CONTENTS *pSafeContents
	)
{
	DWORD i,j,k;

	// loop for each SAFE_BAG
	for (i=0; i<pSafeContents->cSafeBags; i++) {

		if (pSafeContents->pSafeBags[i].BagContents.pbData)
			PFXHelpFree(pSafeContents->pSafeBags[i].BagContents.pbData);

		// loop for each attribute
		for (j=0; j<pSafeContents->pSafeBags[i].Attributes.cAttr; j++) {
			
			// l0op for each value
			for (k=0; k<pSafeContents->pSafeBags[i].Attributes.rgAttr[j].cValue; k++) {
				
				if (pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue[k].pbData)
					PFXHelpFree(pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue[k].pbData);
			}

			// free the value struct array
			if (pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue)
				PFXHelpFree(pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue);
		}

		// free the attribute struct array
		if (pSafeContents->pSafeBags[i].Attributes.rgAttr)
			PFXHelpFree(pSafeContents->pSafeBags[i].Attributes.rgAttr);
	}

    // finally, free the safe bag array
    if (pSafeContents->pSafeBags != NULL)
    {
        PFXHelpFree(pSafeContents->pSafeBags);
    }

	return TRUE;
}


#define SZ_NO_PROVIDER_NAME_KEY     L"Software\\Microsoft\\Windows\\CurrentVersion\\PFX"
#define SZ_NO_PROVIDER_NAME_VALUE   L"NoProviderName"

BOOL
NoProviderNameRegValueSet()
{
    HKEY    hKey = NULL;
    BOOL    fRet = FALSE;
    DWORD   dwData;
    DWORD   dwDataSize = sizeof(dwData);

    if (ERROR_SUCCESS != RegOpenKeyExU(
                                HKEY_CURRENT_USER,
                                SZ_NO_PROVIDER_NAME_KEY,
                                0,
                                KEY_EXECUTE,
                                &hKey))
    {
        goto Return;;
    }

    if (ERROR_SUCCESS == RegQueryValueExU(
                                hKey,
                                SZ_NO_PROVIDER_NAME_VALUE,
                                NULL,
                                NULL,
                                (LPBYTE) &dwData,
                                &dwDataSize))
    {
        fRet = (BOOL) dwData;
    }
    
Return:
    if (hKey != NULL)
        RegCloseKey(hKey);

    return fRet;
}


//+-------------------------------------------------------------------------
// hCertStore - handle to the cert store that contains the certs whose
//				corresponding private keys are to be exported
// pSafeContents - pointer to a buffer to receive the SAFE_CONTENTS structure
//				   and supporting data
// pcbSafeContents - (in) specifies the length, in bytes, of the pSafeContents 
//					  buffer.  (out) gets filled in with the number of bytes 
//					  used by the operation.  If this is set to 0, the 
//					  required length of pSafeContents is filled in, and 
//					  pSafeContents is ignored.
// dwFlags - the current available flags are:
//				EXPORT_PRIVATE_KEYS
//				if this flag is set then the private keys are exported as well
//				as the certificates
//				REPORT_NO_PRIVATE_KEY
//				if this flag is set and a certificate is encountered that has no
//				no associated private key, the function will return immediately
//				with ppCertContext filled in with a pointer to the cert context
//				in question.  the caller is responsible for freeing the cert
//				context which is passed back.
//				REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY
//				if this flag is set and a certificate is encountered that has a 
//				non-exportable private key, the function will return immediately
//				with ppCertContext filled in with a pointer to the cert context
//				in question.  the caller is responsible for freeing the cert
//				context which is passed back.
// ppCertContext - a pointer to a pointer to a cert context.  this is used 
//				   if REPORT_NO_PRIVATE_KEY or REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY
//				   flags are set.  the caller is responsible for freeing the
//				   cert context.
// pvAuxInfo - reserved for future use, must be set to NULL
//+-------------------------------------------------------------------------
BOOL WINAPI CertExportSafeContents(
	HCERTSTORE		                hCertStore,			// in
	SAFE_CONTENTS	                *pSafeContents,		// out
	DWORD			                *pcbSafeContents,	// in, out
    EXPORT_SAFE_CALLBACK_STRUCT     *ExportSafeCallbackStruct, // in
	DWORD			                dwFlags,			// in
	PCCERT_CONTEXT                  *ppCertContext,		// out
	void			                *pvAuxInfo			// in
)
{
	BOOL				fResult = TRUE;
	PCCERT_CONTEXT		pCertContext = NULL;
	DWORD				dwKeySpec;
	DWORD				dwBytesRequired = sizeof(SAFE_CONTENTS);
	SAFE_CONTENTS		localSafeContents;  
	BYTE				*pCurrentBufferLocation = NULL;
	DWORD				dwIDs = 1;
	DWORD				i,j,k;

	// all these variables are used in the while loop that enumerates through
	// the cert contexts
	CRYPT_KEY_PROV_INFO	*pCryptKeyProvInfo = NULL;
	DWORD				cbCryptKeyProvInfo = 0;
	HCRYPTPROV			hCryptProv = NULL;
	BYTE				*pPrivateKey = NULL;
	DWORD				cbPrivateKey = 0;
	void				*pTempMemBlock = NULL;
	SAFE_BAG			*pCurrentSafeBag = NULL;
	DWORD				dwKeyID = 0;
	CRYPT_ATTR_BLOB		keyID;
	CRYPT_DER_BLOB		EncodedKeyID;
	CERT_NAME_VALUE		wideFriendlyName;
    BYTE                *pFriendlyName = NULL;
    DWORD               cbFriendlyName = 0;
    DWORD               dwFriendlyNameAttributeIndex = 0;
    BOOL                fAddProviderName;
    LPWSTR              pwszProviderName = NULL;
    DWORD               cbProviderName = 0;
	
	localSafeContents.cSafeBags = 0;
	localSafeContents.pSafeBags = NULL;

	// validate input parameters
	if ((pcbSafeContents == NULL)	|| 
		(pvAuxInfo != NULL			||
		((*pcbSafeContents != 0) && (pSafeContents == NULL)))) {
		SetLastError((DWORD)ERROR_INVALID_PARAMETER);
		goto ErrorReturn;
	}

	if ((dwFlags & REPORT_NO_PRIVATE_KEY) || (dwFlags & REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY)) {
		if (ppCertContext == NULL) {
			SetLastError((DWORD)ERROR_INVALID_PARAMETER);
			goto ErrorReturn;
		}
		*ppCertContext = NULL;
	}

    fAddProviderName = !NoProviderNameRegValueSet();

	// loop for each certificate context in the store and export the cert and 
	// corresponding private key if one exists
	while (NULL != (pCertContext = CertEnumCertificatesInStore(hCertStore, pCertContext))) {
		
		// initialize all loop variables
		if (pCryptKeyProvInfo)
			PFXHelpFree(pCryptKeyProvInfo);
		pCryptKeyProvInfo = NULL;
		cbCryptKeyProvInfo = 0;

		if (hCryptProv)
			CryptReleaseContext(hCryptProv, 0);
		hCryptProv = NULL;
		
		if (pPrivateKey)
			PFXHelpFree(pPrivateKey);
		pPrivateKey = NULL;
		cbPrivateKey = 0;
		
		pTempMemBlock = NULL;
		pCurrentSafeBag = NULL;
		
		// keyID is the CRYPT_ATTR_BLOB that is always used to encode the key id
		// for certs and private keys.  dwKeyID is the only thing that will need
		// to be set properly before calling CryptEncodeObject with keyID.
		keyID.pbData = (BYTE *) &dwKeyID;
		keyID.cbData = sizeof(DWORD);

		// initialize EncodedKeyID so when exporting the cert it can check to see if this
		// has been set
		EncodedKeyID.pbData = NULL;
		EncodedKeyID.cbData = 0;

		// if the EXPORT_PRIVATE_KEYS flag is set then
		// try to export the private key which corresponds to this certificate before
		// exporting the certificate so we know how to set the key ID on the certificate

		if (EXPORT_PRIVATE_KEYS  & dwFlags)
		// get the provider info so we can export the private key
		if (CertGetCertificateContextProperty(
				pCertContext,
				CERT_KEY_PROV_INFO_PROP_ID,
				NULL,
				&cbCryptKeyProvInfo
				)) {
			
			if (NULL == (pCryptKeyProvInfo = (CRYPT_KEY_PROV_INFO *) 
							PFXHelpAlloc(cbCryptKeyProvInfo))) {
				goto ErrorReturn;
			}
			
			if (CertGetCertificateContextProperty(
					pCertContext,
					CERT_KEY_PROV_INFO_PROP_ID,
					pCryptKeyProvInfo,
					&cbCryptKeyProvInfo
					)) {
				
				// acquire the HCRYPTPROV so we can export the private key in that puppy
				if (!CryptAcquireContextU(
						&hCryptProv,
						pCryptKeyProvInfo->pwszContainerName,
						pCryptKeyProvInfo->pwszProvName,
						pCryptKeyProvInfo->dwProvType,
						pCryptKeyProvInfo->dwFlags & (DISALLOWED_FLAG_MASK)) ) {
					goto ErrorReturn;
				}
                
                CRYPT_PKCS8_EXPORT_PARAMS sExportParams = { hCryptProv, 
                                                            pCryptKeyProvInfo->dwKeySpec,
                                                            pCertContext->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId,
                                                            //szOID_RSA_RSA,  // FIX -what do I do here??, possibly look at the algorithm in the cert
                                                            (ExportSafeCallbackStruct) ? ExportSafeCallbackStruct->pEncryptPrivateKeyFunc : NULL,
                                                            (ExportSafeCallbackStruct) ? ExportSafeCallbackStruct->pVoidEncryptFunc : NULL};

				// do the actual export of the private key
				if (CryptExportPKCS8Ex(
                        &sExportParams,

						PFX_MODE,
						NULL,
						NULL,
						&cbPrivateKey
						)) {
					
					if (NULL == (pPrivateKey = (BYTE *) PFXHelpAlloc(cbPrivateKey))) {
						goto ErrorReturn;
					}

					if (CryptExportPKCS8Ex(
                            &sExportParams,

                            (dwFlags & GIVE_ME_DATA) ? PFX_MODE | GIVE_ME_DATA : PFX_MODE,
							NULL,
							pPrivateKey,
							&cbPrivateKey
							)) {
							
						// search the array of key bags to see if the private key is already there
						// and take action accordingly.  if the private key already exists, the
						// EncodedKeyID contains the encoded keyID attribute for exporting the 
						// certificate so we don't need to do anything
						if (!PrivateKeyAlreadyExists(
								pPrivateKey,
								cbPrivateKey,
								&localSafeContents, 
								&EncodedKeyID
								)) {
													
							// extend the length of the SAFE_BAGs array by one
							if (NULL == (pTempMemBlock = PFXHelpRealloc(
															localSafeContents.pSafeBags, 
															sizeof(SAFE_BAG) * 
																++localSafeContents.cSafeBags))) {
								goto ErrorReturn;
							}
							localSafeContents.pSafeBags = (SAFE_BAG *) pTempMemBlock;
							pCurrentSafeBag = 
								&localSafeContents.pSafeBags[localSafeContents.cSafeBags - 1]; 
							ZeroMemory(pCurrentSafeBag, sizeof(SAFE_BAG));
							dwBytesRequired += sizeof(SAFE_BAG);

							// set up the OID information for the bag type
                            pCurrentSafeBag->pszBagTypeOID = (ExportSafeCallbackStruct->pEncryptPrivateKeyFunc) ? szOID_PKCS_12_SHROUDEDKEY_BAG : szOID_PKCS_12_KEY_BAG;
							dwBytesRequired += INFO_LEN_ALIGN(strlen(pCurrentSafeBag->pszBagTypeOID) + 1);
							
							// copy the pointer to the private key into the new safe bag
							// and NULL out the pPrivateKey pointer so the memory does not get freed
							pCurrentSafeBag->BagContents.pbData = pPrivateKey;
							pCurrentSafeBag->BagContents.cbData = cbPrivateKey;
							dwBytesRequired += INFO_LEN_ALIGN(cbPrivateKey);
							pPrivateKey = NULL;
							cbPrivateKey = 0;
						
							// set up the attributes array for the SAFE_BAG
							// FIX - for right now just do the 
 							// szOID_PKCS_12_LOCAL_KEY_ID,
                            // szOID_PKCS_12_FRIENDLY_NAME_ATTR,
                            // and szOID_PKCS_12_KEY_PROVIDER_NAME_ATTR. (if the NoProviderName reg value not set)
                            // optional szOID_LOCAL_MACHINE_KEYSET if needed
                            pCurrentSafeBag->Attributes.cAttr = fAddProviderName ? 3 : 2;

                            if (pCryptKeyProvInfo->dwFlags & CRYPT_MACHINE_KEYSET)
							    pCurrentSafeBag->Attributes.cAttr++;

                            if (NULL == (pCurrentSafeBag->Attributes.rgAttr = (CRYPT_ATTRIBUTE *)
											 PFXHelpAlloc(sizeof(CRYPT_ATTRIBUTE) * pCurrentSafeBag->Attributes.cAttr))) {
								goto ErrorReturn;
							}
							ZeroMemory(pCurrentSafeBag->Attributes.rgAttr, sizeof(CRYPT_ATTRIBUTE) * pCurrentSafeBag->Attributes.cAttr);
							dwBytesRequired += sizeof(CRYPT_ATTRIBUTE) * pCurrentSafeBag->Attributes.cAttr;


                            // allocate space and do setup based on whether the szOID_LOCAL_MACHINE_KEYSET
                            // attribute is needed
                            if (pCryptKeyProvInfo->dwFlags & CRYPT_MACHINE_KEYSET)
                            {
                                // since there is nothing to do for the szOID_LOCAL_MACHINE_KEYSET
                                // besides just setting the OID do it here and put it in the last
                                // attribute
                                pCurrentSafeBag->Attributes.rgAttr[pCurrentSafeBag->Attributes.cAttr-1].pszObjId = 
								    szOID_LOCAL_MACHINE_KEYSET;
							    dwBytesRequired += INFO_LEN_ALIGN(strlen(szOID_LOCAL_MACHINE_KEYSET) + 1);
                                pCurrentSafeBag->Attributes.rgAttr[pCurrentSafeBag->Attributes.cAttr-1].rgValue = NULL;
                                pCurrentSafeBag->Attributes.rgAttr[pCurrentSafeBag->Attributes.cAttr-1].cValue = 0;
                            }
							
							// set the OID in the szOID_PKCS_12_LOCAL_KEY_ID attribute
							pCurrentSafeBag->Attributes.rgAttr[0].pszObjId = 
								szOID_PKCS_12_LOCAL_KEY_ID;
							dwBytesRequired += INFO_LEN_ALIGN(strlen(szOID_PKCS_12_LOCAL_KEY_ID) + 1);
							
							// allocate space for the single value inside the attribute
							if (NULL == (pCurrentSafeBag->Attributes.rgAttr[0].rgValue = 
											(CRYPT_ATTR_BLOB *) PFXHelpAlloc(sizeof(CRYPT_ATTR_BLOB)))) {
								goto ErrorReturn;
							}
							ZeroMemory(pCurrentSafeBag->Attributes.rgAttr[0].rgValue, sizeof(CRYPT_ATTR_BLOB));
							dwBytesRequired += sizeof(CRYPT_ATTR_BLOB);
							pCurrentSafeBag->Attributes.rgAttr[0].cValue = 1;

							// set the key ID to the appropriate key ID
							dwKeyID = dwIDs++;

							// encode the keyID
							pCurrentSafeBag->Attributes.rgAttr[0].rgValue[0].pbData = NULL;
							pCurrentSafeBag->Attributes.rgAttr[0].rgValue[0].cbData = 0;
							if (!CryptEncodeObject(
									X509_ASN_ENCODING,
									X509_OCTET_STRING,
									&keyID,
									NULL,
									&pCurrentSafeBag->Attributes.rgAttr[0].rgValue[0].cbData)) {
								goto ErrorReturn;
							}

							if (NULL == (pCurrentSafeBag->Attributes.rgAttr[0].rgValue[0].pbData = 
											(BYTE *) PFXHelpAlloc(pCurrentSafeBag->Attributes.rgAttr[0].rgValue[0].cbData))) {
								goto ErrorReturn;
							}
							dwBytesRequired += INFO_LEN_ALIGN(pCurrentSafeBag->Attributes.rgAttr[0].rgValue[0].cbData);

							if (!CryptEncodeObject(
									X509_ASN_ENCODING,
									X509_OCTET_STRING,
									&keyID,
									pCurrentSafeBag->Attributes.rgAttr[0].rgValue[0].pbData,
									&pCurrentSafeBag->Attributes.rgAttr[0].rgValue[0].cbData)) {
								goto ErrorReturn;
							}
							
							// set the fields in EncodedKeyID so that when the cert is exported
							// it can just copy the already encoded keyID to it's attributes
							EncodedKeyID.pbData = pCurrentSafeBag->Attributes.rgAttr[0].rgValue[0].pbData;
							EncodedKeyID.cbData = pCurrentSafeBag->Attributes.rgAttr[0].rgValue[0].cbData;					

 							// Friendly Name

 							// set the OID in the szOID_PKCS_12_FRIENDLY_NAME_ATTR attribute
							pCurrentSafeBag->Attributes.rgAttr[1].pszObjId = 
								szOID_PKCS_12_FRIENDLY_NAME_ATTR;
							dwBytesRequired += INFO_LEN_ALIGN(strlen(szOID_PKCS_12_FRIENDLY_NAME_ATTR) + 1);
							
							// allocate space for the single value inside the attribute
							if (NULL == (pCurrentSafeBag->Attributes.rgAttr[1].rgValue = 
											(CRYPT_ATTR_BLOB *) PFXHelpAlloc(sizeof(CRYPT_ATTR_BLOB)))) {
								goto ErrorReturn;
							}
							ZeroMemory(pCurrentSafeBag->Attributes.rgAttr[1].rgValue, sizeof(CRYPT_ATTR_BLOB));
							dwBytesRequired += sizeof(CRYPT_ATTR_BLOB);
							pCurrentSafeBag->Attributes.rgAttr[1].cValue = 1;

 							// encode the provider name so it can be used on import
                            wideFriendlyName.dwValueType = CERT_RDN_BMP_STRING;
 							wideFriendlyName.Value.pbData = (BYTE *) pCryptKeyProvInfo->pwszContainerName;
                            wideFriendlyName.Value.cbData = 0;
                            
							if (!CryptEncodeObject(
									X509_ASN_ENCODING,
									X509_UNICODE_ANY_STRING,
									(void *)&wideFriendlyName,
									NULL,
									&pCurrentSafeBag->Attributes.rgAttr[1].rgValue[0].cbData)) {
								goto ErrorReturn;
							}

							if (NULL == (pCurrentSafeBag->Attributes.rgAttr[1].rgValue[0].pbData = 
											(BYTE *) PFXHelpAlloc(pCurrentSafeBag->Attributes.rgAttr[1].rgValue[0].cbData))) {
								goto ErrorReturn;
							}
							dwBytesRequired += INFO_LEN_ALIGN(pCurrentSafeBag->Attributes.rgAttr[1].rgValue[0].cbData);

							if (!CryptEncodeObject(
									X509_ASN_ENCODING,
									X509_UNICODE_ANY_STRING,
									(void *)&wideFriendlyName,
									pCurrentSafeBag->Attributes.rgAttr[1].rgValue[0].pbData,
									&pCurrentSafeBag->Attributes.rgAttr[1].rgValue[0].cbData)) {
								goto ErrorReturn;
							}

                            // Provider Name
                            if (fAddProviderName)
                            {
                                // set the OID in the szOID_PKCS_12_KEY_PROVIDER_NAME_ATTR attribute
							    pCurrentSafeBag->Attributes.rgAttr[2].pszObjId = 
								    szOID_PKCS_12_KEY_PROVIDER_NAME_ATTR;
							    dwBytesRequired += INFO_LEN_ALIGN(strlen(szOID_PKCS_12_KEY_PROVIDER_NAME_ATTR) + 1);
							    
							    // allocate space for the single value inside the attribute
							    if (NULL == (pCurrentSafeBag->Attributes.rgAttr[2].rgValue = 
											    (CRYPT_ATTR_BLOB *) PFXHelpAlloc(sizeof(CRYPT_ATTR_BLOB)))) {
								    goto ErrorReturn;
							    }
							    ZeroMemory(pCurrentSafeBag->Attributes.rgAttr[2].rgValue, sizeof(CRYPT_ATTR_BLOB));
							    dwBytesRequired += sizeof(CRYPT_ATTR_BLOB);
							    pCurrentSafeBag->Attributes.rgAttr[2].cValue = 1;

 							    // encode the provider name so it can be used on import
                                //
                                // if the provider name is NULL or the empty string, then use
                                // the default provider name for the provider type
                                //
                                wideFriendlyName.dwValueType = CERT_RDN_BMP_STRING;
                                wideFriendlyName.Value.cbData = 0;
                                if ((pCryptKeyProvInfo->pwszProvName == NULL) ||
                                    (wcscmp(pCryptKeyProvInfo->pwszProvName, L"") == 0))
                                {
                                    if (!CryptGetDefaultProviderW(
                                            pCryptKeyProvInfo->dwProvType,   
                                            NULL, 
                                            (pCryptKeyProvInfo->dwFlags & CRYPT_MACHINE_KEYSET) ?
                                                CRYPT_MACHINE_DEFAULT : CRYPT_USER_DEFAULT,      
                                            NULL, 
                                            &cbProviderName))
                                    {
                                        goto ErrorReturn;
                                    }

                                    if (NULL == (pwszProviderName = (LPWSTR) PFXHelpAlloc(cbProviderName)))
                                    {
                                        goto ErrorReturn;
                                    }

                                    if (!CryptGetDefaultProviderW(
                                            pCryptKeyProvInfo->dwProvType,   
                                            NULL, 
                                            (pCryptKeyProvInfo->dwFlags & CRYPT_MACHINE_KEYSET) ?
                                                CRYPT_MACHINE_DEFAULT : CRYPT_USER_DEFAULT,      
                                            pwszProviderName, 
                                            &cbProviderName))
                                    {
                                        goto ErrorReturn;
                                    }

                                    wideFriendlyName.Value.pbData = (BYTE *) pwszProviderName;
                                }
                                else
                                {
 							        wideFriendlyName.Value.pbData = (BYTE *) pCryptKeyProvInfo->pwszProvName;
                                }
                                
							    if (!CryptEncodeObject(
									    X509_ASN_ENCODING,
									    X509_UNICODE_ANY_STRING,
									    (void *)&wideFriendlyName,
									    NULL,
									    &pCurrentSafeBag->Attributes.rgAttr[2].rgValue[0].cbData)) {
								    goto ErrorReturn;
							    }

							    if (NULL == (pCurrentSafeBag->Attributes.rgAttr[2].rgValue[0].pbData = 
											    (BYTE *) PFXHelpAlloc(pCurrentSafeBag->Attributes.rgAttr[2].rgValue[0].cbData))) {
								    goto ErrorReturn;
							    }
							    dwBytesRequired += INFO_LEN_ALIGN(pCurrentSafeBag->Attributes.rgAttr[2].rgValue[0].cbData);

							    if (!CryptEncodeObject(
									    X509_ASN_ENCODING,
									    X509_UNICODE_ANY_STRING,
									    (void *)&wideFriendlyName,
									    pCurrentSafeBag->Attributes.rgAttr[2].rgValue[0].pbData,
									    &pCurrentSafeBag->Attributes.rgAttr[2].rgValue[0].cbData)) {
								    goto ErrorReturn;
							    }
                            }
						} 

					} // if (CryptExportPKCS8Ex())
					else {
						
						// check to see if it is a non-exportable key error or no key error
						if (GetLastError() == NTE_BAD_KEY ||
                            GetLastError() == NTE_BAD_KEY_STATE) {
							
							// the user has specified whether this is a fatal error or not
							if (dwFlags & REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY) {
								*ppCertContext = pCertContext;
								pCertContext = NULL;
								goto ErrorReturn;
							}
						}
						else if (GetLastError() == NTE_NO_KEY) {
							// the user has specified whether this is a fatal error or not
							if (dwFlags & REPORT_NO_PRIVATE_KEY) {
								*ppCertContext = pCertContext;
								pCertContext = NULL;
								goto ErrorReturn;
							}
						}
						else {
							// it isn't a non-exportable key error or no key error, so it is bad... bad...
							goto ErrorReturn;
						}
					}
		
				} // if (CryptExportPKCS8Ex())	
				else {
					
					// check to see if it is a non-exportable key error or no key error
					if (GetLastError() == NTE_BAD_KEY ||
                        GetLastError() == NTE_BAD_KEY_STATE) {
						
						// the user has specified whether this is a fatal error or not
						if (dwFlags & REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY) {
							*ppCertContext = pCertContext;
							pCertContext = NULL;
							goto ErrorReturn;
						}
					}
					else if (GetLastError() == NTE_NO_KEY) {
							// the user has specified whether this is a fatal error or not
							if (dwFlags & REPORT_NO_PRIVATE_KEY) {
								*ppCertContext = pCertContext;
								pCertContext = NULL;
								goto ErrorReturn;
							}
						}
					else {
						// it was not a non-exportable error,so go directly to ErrorReturn
						goto ErrorReturn;
					}
				}	

			} // if (CertGetCertificateContextProperty())
			else {
				
				// if CertGetCertificateContextProperty failed then there is no corresponding 
				// private key, the user has indicated via dwFlags whether this is fatal or not,
				// if it is fatal then return an error, otherwise just loop and get the next cert
				if (dwFlags & REPORT_NO_PRIVATE_KEY) {
					*ppCertContext = pCertContext;
					pCertContext = NULL;
					goto ErrorReturn;
				}
			}

		} // if (CertGetCertificateContextProperty())
		else {
			
			// if CertGetCertificateContextProperty failed then there is no corresponding 
			// private key, the user has indicated via dwFlags whether this is fatal or not,
			// if it is fatal then return an error, otherwise just continue and export the cert
			if (dwFlags & REPORT_NO_PRIVATE_KEY) {
				*ppCertContext = pCertContext;
				pCertContext = NULL;
				goto ErrorReturn;
			}
		}


		// now export the current cert!!

		// extend the length of the SAFE_BAGs array by one
		if (NULL == (pTempMemBlock = PFXHelpRealloc(
										localSafeContents.pSafeBags, 
										sizeof(SAFE_BAG) * ++localSafeContents.cSafeBags))) {
			goto ErrorReturn;
		}
		localSafeContents.pSafeBags = (SAFE_BAG *) pTempMemBlock;
		pCurrentSafeBag = &localSafeContents.pSafeBags[localSafeContents.cSafeBags - 1]; 
		ZeroMemory(pCurrentSafeBag, sizeof(SAFE_BAG));
		dwBytesRequired += sizeof(SAFE_BAG);

		// set up the OID information for the bag type
		pCurrentSafeBag->pszBagTypeOID = szOID_PKCS_12_CERT_BAG;
		dwBytesRequired += INFO_LEN_ALIGN(strlen(szOID_PKCS_12_CERT_BAG) + 1);
		
        // take the encoded cert and turn it into an encoded CertBag and place in the
        // BagContents
        pCurrentSafeBag->BagContents.cbData = 0;
        if (!MakeEncodedCertBag(
                pCertContext->pbCertEncoded, 
			    pCertContext->cbCertEncoded,
                NULL,
                &(pCurrentSafeBag->BagContents.cbData))) {
            goto ErrorReturn;
        }

		if (NULL == (pCurrentSafeBag->BagContents.pbData = 
						(BYTE *) PFXHelpAlloc(pCurrentSafeBag->BagContents.cbData))) {
			goto ErrorReturn;
		}

		if (!MakeEncodedCertBag(
                pCertContext->pbCertEncoded, 
			    pCertContext->cbCertEncoded,
                pCurrentSafeBag->BagContents.pbData,
                &(pCurrentSafeBag->BagContents.cbData))) {
            goto ErrorReturn;
        }
        
		dwBytesRequired += INFO_LEN_ALIGN(pCurrentSafeBag->BagContents.cbData);
	
        // check to see how many attributes there will be, the possibilities right now 
        // are FREINDLY_NAME and LOCAL_KEY_ID  
      
        // try to get the friendly name property from the cert context
        if (!CertGetCertificateContextProperty(
                pCertContext,
                CERT_FRIENDLY_NAME_PROP_ID,
                NULL,
                &cbFriendlyName)) {
            
            // just set this to insure that it is 0 if we don't have a friendly name
            cbFriendlyName = 0;  
        }

        // allocate space for the attributes array in the safe bag accordingly
        // if EncodedKeyID.pbData != NULL means there is a corresponding private
        // key, so the LOCAL_KEY_ID attribute needs to be set
        if ((cbFriendlyName != 0) && (EncodedKeyID.pbData != NULL)) {
            
            if (NULL == (pCurrentSafeBag->Attributes.rgAttr = 
							(CRYPT_ATTRIBUTE *) PFXHelpAlloc(sizeof(CRYPT_ATTRIBUTE) * 2))) {
				goto ErrorReturn;
			}
			ZeroMemory(pCurrentSafeBag->Attributes.rgAttr, sizeof(CRYPT_ATTRIBUTE) * 2);
			dwBytesRequired += sizeof(CRYPT_ATTRIBUTE) * 2;
			pCurrentSafeBag->Attributes.cAttr = 2;
        }
        else if ((cbFriendlyName != 0) || (EncodedKeyID.pbData != NULL)) {
            
			if (NULL == (pCurrentSafeBag->Attributes.rgAttr = 
							(CRYPT_ATTRIBUTE *) PFXHelpAlloc(sizeof(CRYPT_ATTRIBUTE)))) {
				goto ErrorReturn;
			}
			ZeroMemory(pCurrentSafeBag->Attributes.rgAttr, sizeof(CRYPT_ATTRIBUTE));
			dwBytesRequired += sizeof(CRYPT_ATTRIBUTE);
			pCurrentSafeBag->Attributes.cAttr = 1;
        }
        else {
            pCurrentSafeBag->Attributes.rgAttr = NULL;
			pCurrentSafeBag->Attributes.cAttr = 0;
        }

		// check to see if the cert has a corresponding private key, if so then set
		// up the first attribute to point to it.... if there is a private key then
        // LOCAL_KEY_ID will always be the 0th element in the attribute array
		if (EncodedKeyID.pbData != NULL) {
			
			// set the OID in the single attribute
			pCurrentSafeBag->Attributes.rgAttr[0].pszObjId = szOID_PKCS_12_LOCAL_KEY_ID;
			dwBytesRequired += INFO_LEN_ALIGN(strlen(szOID_PKCS_12_LOCAL_KEY_ID) + 1);
			
			// allocate space for the single value inside the single attribute
			if (NULL == (pCurrentSafeBag->Attributes.rgAttr[0].rgValue = 
							(CRYPT_ATTR_BLOB *) PFXHelpAlloc(sizeof(CRYPT_ATTR_BLOB)))) {
				goto ErrorReturn;
			}
			ZeroMemory(pCurrentSafeBag->Attributes.rgAttr[0].rgValue, sizeof(CRYPT_ATTR_BLOB));
			dwBytesRequired += sizeof(CRYPT_ATTR_BLOB);
			pCurrentSafeBag->Attributes.rgAttr[0].cValue = 1;

			// copy the encoded keyID that was set up during export of private key
			if (NULL == (pCurrentSafeBag->Attributes.rgAttr[0].rgValue[0].pbData = 
							(B